#
# PySNMP MIB module CISCO-RTTMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-RTTMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:02:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
CfmMepid, = mibBuilder.importSymbols("CISCO-ETHER-CFM-MIB", "CfmMepid")
QosLayer2Cos, = mibBuilder.importSymbols("CISCO-QOS-PIB-MIB", "QosLayer2Cos")
RttMonTargetAddress, RttMplsVpnMonLpdFailureSense, RttMonCodecType, RttMonReactVar, RttMonProtocol, RttMonOperation, RttMonScheduleStartType, RttMonLSPPingReplyMode, RttMonRttType, RttMplsVpnMonRttType, RttResponseSense, RttMplsVpnMonLpdGrpStatus, RttReset = mibBuilder.importSymbols("CISCO-RTTMON-TC-MIB", "RttMonTargetAddress", "RttMplsVpnMonLpdFailureSense", "RttMonCodecType", "RttMonReactVar", "RttMonProtocol", "RttMonOperation", "RttMonScheduleStartType", "RttMonLSPPingReplyMode", "RttMonRttType", "RttMplsVpnMonRttType", "RttResponseSense", "RttMplsVpnMonLpdGrpStatus", "RttReset")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
Dscp, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
VlanId, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64, IpAddress, Gauge32, ObjectIdentity, ModuleIdentity, Counter32, Unsigned32, NotificationType, Bits, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64", "IpAddress", "Gauge32", "ObjectIdentity", "ModuleIdentity", "Counter32", "Unsigned32", "NotificationType", "Bits", "MibIdentifier", "iso")
TruthValue, DisplayString, MacAddress, TimeStamp, StorageType, TextualConvention, TimeInterval, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "MacAddress", "TimeStamp", "StorageType", "TextualConvention", "TimeInterval", "RowStatus")
ciscoRttMonMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 42))
ciscoRttMonMIB.setRevisions(('2016-04-14 00:00', '2014-04-10 00:00', '2012-08-16 00:00', '2011-09-15 00:00', '2011-02-21 00:00', '2010-10-18 00:00', '2010-06-04 00:00', '2009-04-07 00:00', '2008-03-24 00:00', '2008-01-06 00:00', '2006-12-08 00:00', '2006-06-08 00:00', '2006-03-02 00:00', '2005-08-11 00:00', '2005-04-21 00:00', '2005-01-04 00:00', '2004-08-26 00:00', '2004-05-18 00:00', '2004-01-20 00:00', '2003-08-11 00:00', '2003-05-21 00:00', '2003-04-15 00:00', '2003-03-12 00:00', '2000-11-03 00:00', '1999-06-15 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoRttMonMIB.setRevisionsDescriptions(('Refined rttMonCtrlAdminFrequency range in the new compliance statement from Integer32 (0..604800) to (1..604800). This change was advertised in revision 200405180000Z but was not implemented. Refined range for the following port objects to exclude value 0 rttMonEchoAdminTargetPort, rttMonEchoAdminSourcePort, rttMonEchoAdminEmulateSourcePort, rttMonEchoAdminEmulateTargetPort Added following objects to support random start-time feature for scheduling group and sla probes. rttMonScheduleAdminStartType, rttMonScheduleAdminStartDelay, rttMonGrpScheduleAdminStartType, rttMonGrpScheduleAdminStartDelay Added following objects to report over threshold statistics for jitter probes rttMonLatestJitterOperNumOverThresh, rttMonJitterStatsNumOverThresh Deprecated rttMonCtrlAdminTag and replaced with rttMonCtrlAdminLongTag Added new compliance ciscoRttMonMibComplianceRev23.', 'Added following objects for Fabric Path Echo probe rttMonEchoAdminTargetSwitchId, rttMonEchoAdminProfileId, rttMonEchoAdminOutputInterface Added new compliance ciscoRttMonMibComplianceRev22.', 'Added following objects to support Y1731 Synthetic Loss Measurement rttMonEchoAdminEnableBurst, rttMonEchoAdminAggBurstCycles, rttMonEchoAdminLossRatioNumFrames, rttMonEchoAdminAvailNumFrames Added following object to support improving accuracy for jitter probes measurement. rttMonEchoAdminTstampOptimization Deprecated rttMonScheduleAdminConceptRowAgeout and replace with rttMonScheduleAdminConceptRowAgeoutV2. Deprecated rttMonControlEnableErrors, rttMonStatsRetrieveErrors and replace with rttMonStatsCollectCtrlEnErrors, rttMonStatsCollectRetrieveErrors. Modified the descriptions for rttMonLatestJitterOperMOS rttMonLatestJitterOperICPIF, rttMonJitterStatsMinOfMOS rttMonJitterStatsMinOfICPIF, rttMonJitterStatsMaxOfMOS rttMonJitterStatsMaxOfICPIF Added new compliance ciscoRttMonMibComplianceRev21.', 'Added following objects to rttMonEchoAdmin to support Y1731 extensions. - rttMonEchoAdminTargetMacAddress, - rttMonEchoAdminSourceMacAddress and - rttMonEchoAdminSourceMPID', 'Added four new objects rttMonEchoAdminEmulateSourceAddress, rttMonEchoAdminEmulateSourcePort, rttMonEchoAdminEmulateTargetAddress, rttMonEchoAdminEmulateTargetPort to RttMonEchoAdminEntry.', 'Added three new objects rttMonEchoAdminDscp, rttMonEchoAdminReserveDsp, rttMonEchoAdminInputInterface', 'Changes added for video operation: -Added new MIB object rttMonEchoAdminVideoTrafficProfile -Changed the maximum range of rttMonEchoAdminCallDuration to 600 -Changed the minimum range of rttMonEchoAdminCallDuration to 1 from 10', '- Added rttMonEchoAdminTargetMEPPort object in rttMonEchoAdminEntry.', '- Added nine new objects rttMonLatestJitterOperRTTSumHigh, rttMonLatestJitterOperRTTSum2High, rttMonLatestJitterOperOWSumSDHigh, rttMonLatestJitterOperOWSum2SDHigh, rttMonLatestJitterOperOWSumDSHigh, rttMonLatestJitterOperOWSum2DSHigh, rttMonJitterStatsRTTSumHigh, rttMonJitterStatsOWSumSDHigh, rttMonJitterStatsOWSumDSHigh. - Modified the unit and the description of rttMonLatestRttOperCompletionTime, rttMonJitterStatsRTTSum, rttMonJitterStatsOWSumSD, rttMonJitterStatsOWSumDS, rttMonLatestJitterOperRTTSum, rttMonLatestJitterOperRTTSum2, rttMonLatestJitterOperOWSumSD, rttMonLatestJitterOperOWSumDS, rttMonLatestJitterOperOWSum2SD, rttMonLatestJitterOperOWSum2DS.', 'Added a new object rttMonEchoAdminTargetEVC.', 'Added a new object rttMonCtrlAdminGroupName to support the auto measure project. Group Name will be shown for auto generated operations.', 'Added a new rttMonRttType named as lspPingPseudowire. Added an object rttMonEchoAdminLSPVccvID to support lspPingPseudowire. Change the default value of rttMplsVpnMonTypeLpdScanPeriod from 1 to 240.', "Added two new rttMonRttType's ethernetPing and ethernetJitter. Added four objects rttMonEchoAdminTargetMPID, rttMonEchoAdminTargetVLAN, rttMonEchoAdminTargetDomainName and rttMonEchoAdminEthernetCOS in rttMonEchoAdminEntry to support ethernetPing and ethernetJitter. Change the default value of rttMplsVpnMonTypeLpdScanPeriod from 0 to 1. Modified the range of rttMonApplProbeCapacity and rttMonApplNumCtrlAdminEntry to 1 .. 2147483647. Modified the range of rttMonLatestJitterOperMOS, rttMonJitterStatsMinOfMOS and rttMonJitterStatsMaxOfMOS to (0|100 .. 500). Modified the SYNTAX of rttMonCtrlAdminOwner to OCTET STRING because OwnerString is deprecated.", '- TEXTUAL Conventions previously defined in the MIB are defined in CISCO-RTTMON-TC-MIB.', '- Added new objects given in ciscoCtrlGroupRev4 to rttMonGrpScheduleAdminTable. - Changed description of object rttMonHTTPStatsRTTMax.', "Added two new rttMonRttType's rtp and lspGroup. Added a new object rttMonApplLpdGrpStatsReset to reset the LPD Group Stats. Added rttMonLpdGrpStatsTable for supporting LSP Path Discovery. Added two new notifications rttMonLpdDiscoveryNotification and rttMonLpdGrpStatusNotification. Added and modified descriptions of some objects in rttMplsVpnMonCtrlTable, rttMplsVpnMonTypeTable and rttMplsVpnMonReactTable for LSP Path Discovery. Added 6 options in the rttMonReactVar. Added rttMonEchoAdminSourceVoicePort and rttMonEchoAdminCallDuration in rttMonEchoAdminTable.", 'Added a table rttMonReactTable, which defines the the reaction configurations for the probes. Deprecated the old reaction table rttMonReactAdminTable. This is replaced by the new table (rttMonReactTable). Depreacted the notification types rttMonConnectionChangeNotification rttMonTimeoutNotification rttMonThresholdNotification rttMonVerifyErrorNotification Added new notification type rttMonNotification. Added two objects, rttMonGrpScheduleAdminFreqMax and rttMonGrpScheduleAdminFreqMin to table rttMonGrpScheduleAdminTable.', '- Add the following fields for VoIP GK registration delay: RttMonEchoAdminEntry: rttMonEchoAdminGKRegistration - Add the following fields for VoIP Post dial delay: RttMonOperation: voipDTAlertRinging(6), voipDTConnectOK(7) RttMonRttType: voip(13) RttMonProtocol: voipAppl(31) RttMonEchoAdminEntry: rttMonEchoAdminCalledNumber rttMonEchoAdminDetectPoint - Add HTTP code 301, 302 as non-error scenario. - Modify description for rttMonEchoAdminNameServer: it is applicable for DNS and HTTP probe. - Modify rttMonCtrlAdminFrequency range from Integer32 (0..604800) to (1..604800) - Added following new objects for jitter probe precision and other improvements: rttMonEchoAdminPrecision, rttMonEchoAdminProbePakPriority, rttMonJitterStatsIAJOut, rttMonJitterStatsIAJIn, rttMonJitterStatsAvgJitter, rttMonJitterStatsAvgJitterSD, rttMonJitterStatsAvgJitterDS, rttMonJitterStatsUnSyncRTs, rttMonLatestJitterOperIAJIn, rttMonLatestJitterOperAvgJitter, rttMonLatestJitterOperAvgSDJ, rttMonLatestJitterOperAvgDSJ, rttMonLatestJitterOperOWAvgSD, rttMonLatestJitterOperOWAvgDS, rttMonLatestJitterOperIAJOut, rttMonLatestJitterOperNTPState, rttMonEchoAdminOWNTPSyncTolAbs, rttMonEchoAdminOWNTPSyncTolPct, rttMonEchoAdminOWNTPSyncTolType, rttMonLatestJitterOperUNSyncRTs', 'Created new tables for Auto SAA L3 MPLS VPN. rttMplsVpnMonCtrlTable rttMplsVpnMonTypeTable rttMplsVpnMonScheduleTable rttMplsVpnMonReactTable. Modified MIB for creation of echo and pathecho operations based on MPLS LSP Ping.', 'Added 1 object rttMonScheduleAdminRttRecurring to the rttMonScheduleAdminTable. Added a new table rttMonGrpScheduleAdminTable for group scheduling. This table contains the following objects rttMonGrpScheduleAdminIndex rttMonGrpScheduleAdminProbes rttMonGrpScheduleAdminPeriod rttMonGrpScheduleAdminFrequency rttMonGrpScheduleAdminLife rttMonGrpScheduleAdminAgeout rttMonGrpScheduleAdminStatus. Modified the default value of rttMonReactTriggerAdminStatus from createAndGo to no default value. Corrected the Revision clause specified for the existing and all the earlier submissions.', 'Range for rttMonLatestJitterOperMOS, rttMonJitterStatsMinOfMOS and rttMonJitterStatsMaxOfMOS to be changed to 100..500 instead of 1..5. Modifying the range of rttMonApplProbeCapacity and rttMonApplNumCtrlAdminEntry to 1..10000.Added value other(0) for RttResponseSense and changed the range of objects rttMonLatestRttOperApplSpecificSense and rttMonHistoryCollectionApplSpecificSense to 0..2147483647. Added range for rttMonApplAuthIndex.', 'Removed default values from rttMonEchoAdminCodecInterval rttMonEchoAdminCodecPayload rttMonEchoAdminCodecNumPackets. Corrected some typos in the earliar revision.', 'Added 5 objects in the rttMonEchoAdminTable to support codec configuration. Added few objects in rttMonLatestJitterOperTable and rttMonJitterStatsTable for ICPIF (Calculated Planning Impairment Factor) and MOS (Mean Opinion Score) scores.', 'deprecated 4 objects in the rttMonJitterStatsTable and added the same objects with a SYNTAX of Gauge32. Also added the capability to specify a VrfName.', 'created rttMonAuthTable.',))
if mibBuilder.loadTexts: ciscoRttMonMIB.setLastUpdated('201604140000Z')
if mibBuilder.loadTexts: ciscoRttMonMIB.setOrganization('Cisco IOS')
if mibBuilder.loadTexts: ciscoRttMonMIB.setContactInfo('Cisco Systems, Inc. Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 Tel: +1 800 553 NETS cs-ipsla@cisco.com')
if mibBuilder.loadTexts: ciscoRttMonMIB.setDescription("This module defines a MIB for Round Trip Time (RTT) monitoring of a list of targets, using a variety of protocols. The table structure overview is a follows (t: indicates a table, at: indicates an augmented table, and it: indicates table with the same indices/control as parent table): RTTMON MIB |--- Application Group | |--- Application Identity | |--- Application Capabilities | |--- Application Reset | |t-- Supported RTT Types | |--- Truth Value | |t-- Supported Protocols | |--- Truth Value | |t-- Application Preconfigured | |--- Script Names | |--- File Paths | |--- Responder control | |t-- Control Protocol Authentication | |--- Overall Control Group | |t-- Master Definitions Table | | |--- Global Configuration Definitions | | |--- Config for a single RTT Life | | |it- Echo Specific Configuration | | |it- Echo Path Hop Address Configuration | | |it- File I/O Specific Configuration | | |it- Script Specific Configuration | | |at- Schedule Configuration | | |at- Reaction Specific Config | | |at- Statistics Capture Configuration | | |at- History Collection Configuration | | |at- Monitoring Operational State | | |at- Last RTT operation | | | |t-- Reaction Trigger Table | |at- Reaction Trigger Operational State | |--- Statistics Collection Group | |t-- Statistics Capture Table | |--- Captured Statistics | |--- Path Information | |--- Distribution Capture | |--- Mean and Deviation Capture | |it- Statistics Collection Table | |it- Statistics Totals Table | |t-- HTTP Stats Table | |t-- Jitter Stats Table | |--- History Collection Group | |t-- History Collection Table | |-- Path Information | |-- Completion Information per operation | |--- Latest Operation Group | |t-- Latest HTTP Oper Table | |t-- Latest Jitter Oper Table DEFINITIONS: conceptual RTT control row - This is a row in the 'Overall Control Group'. This row is indexed via the rttMonCtrlAdminIndex object. This row is spread across multiple real tables in the 'Overall Control Group'. probe - This is the entity that executes via a conceptual RTT control row and populates a conceptual statistics row and a conceptual history row. Rtt operation - This is a single operation performed by a probe. This operation can be a single Rtt attempt/completion or a group of Rtt attempts/completions that produce one operation table entry. ARR Protocol Definition: The format of the RTT Asymmetric Request/Responses (ARR) protocol is as follows: The ARR Header (total of 12 octets): 4 octet -> eyecatcher: 'WxYz' 1 octet -> version : 0x01 - protocol version 1 octet -> command : 0x01 - logoff request 0x02 - echo request 0x03 - echo response 0x04 - software version request 0x05 - software version response 2 octet -> sequence number (Network Byte Order) 4 octet -> response data size (Network Byte Order) The ARR Data: n octets -> request/response data : 'AB..ZAB..ZAB..' For software version request/response the protocol version octet will contain the version number of the responder. Thus the sequence number, etc will not be included. For snaLU0EchoAppl and snaLU2EchoAppl all character fields will be in EBCDIC. The response data should be appended to the origin request data. This allows data verification to check the data that flows in both directions. If the response data size is smaller than the request data size the original request data will be truncated. An example would be: Request: / Response: 'WxYz' / 'WxYz' 0x01 / 0x01 0x02 / 0x03 0x0001 / 0x0001 0x00000008 / 0x00000008 'ABCDEF' / 'ABCDEFGH' NOTE: We requested 8 bytes in the response and the response had 8 bytes. The size of the request data has no correlation to the size of the response data. NOTE: For native RTT request/response (i.e. ipIcmpecho) operations both the 'Header' and 'Data' will be included. Only the 'sequence number' in the Header will be valid. NOTE: For non-connection oriented protocol the initial RTT request/response operation will be preceded with an RTT request/response operation to the target address to force path exploration and to prove connectivity. The History collection table will contain these responses, but the Statistics capture table will omit them to prevent skewed results.")
ciscoRttMonObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1))
rttMonAppl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1))
rttMonCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2))
rttMonStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3))
rttMonHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4))
rttMonLatestOper = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5))
rttMonApplVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplVersion.setStatus('current')
if mibBuilder.loadTexts: rttMonApplVersion.setDescription("Round Trip Time monitoring application version string. The format will be: 'Version.Release.Patch-Level: Textual-Description' For example: '1.0.0: Initial RTT Application'")
rttMonApplMaxPacketDataSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplMaxPacketDataSize.setStatus('current')
if mibBuilder.loadTexts: rttMonApplMaxPacketDataSize.setDescription("The maximum size of the data portion an echo packet supported by this RTT application. This is the maximum value that can be specified by (rttMonEchoAdminPktDataRequestSize + ARR Header) or (rttMonEchoAdminPktDataResponseSize + ARR Header) in the rttMonCtrlAdminTable. This object is undefined for conceptual RTT control rows when the RttMonRttType object is set to 'fileIO' or 'script'.")
rttMonApplTimeOfLastSet = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplTimeOfLastSet.setStatus('current')
if mibBuilder.loadTexts: rttMonApplTimeOfLastSet.setDescription("The last time at which a set operation occurred on any of the objects in this MIB. The managing application can inspect this value in order to determine whether changes have been made without retrieving the entire Administration portion of this MIB. This object applies to all settable objects in this MIB, including the 'Reset' objects that could clear saved history/statistics.")
rttMonApplNumCtrlAdminEntry = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplNumCtrlAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonApplNumCtrlAdminEntry.setDescription('This object defines the maximum number of entries that can be added to the rttMonCtrlAdminTable. It is calculated at the system init time. The value is impacted when rttMonApplFreeMemLowWaterMark is changed.')
rttMonApplReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 5), RttReset()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplReset.setStatus('current')
if mibBuilder.loadTexts: rttMonApplReset.setDescription("When set to 'reset' the entire RTT application goes through a reset sequence, making a best effort to revert to its startup condition. Any and all rows in the Overall Control Group will be immediately deleted, together with any associated rows in the Statistics Collection Group, and History Collection Group. All open connections will also be closed. Finally the rttMonApplPreConfigedTable will reset (see rttMonApplPreConfigedReset).")
rttMonApplPreConfigedReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 6), RttReset()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplPreConfigedReset.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonApplPreConfigedReset.setDescription("When set to 'reset' the RTT application will reset the Application Preconfigured MIB section. This will force the RTT application to delete all entries in the rttMonApplPreConfigedTable and then to repopulate the table with the current configuration. This provides a mechanism to load and unload user scripts and file paths.")
rttMonApplSupportedRttTypesTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7), )
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesTable.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesTable.setDescription('A table of which contains the supported Rtt Monitor Types. See the RttMonRttType textual convention for the definition of each type.')
rttMonApplSupportedRttTypesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplSupportedRttTypes"))
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesEntry.setDescription('A list that presents the valid Rtt Monitor Types.')
rttMonApplSupportedRttTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7, 1, 1), RttMonRttType())
if mibBuilder.loadTexts: rttMonApplSupportedRttTypes.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedRttTypes.setDescription("This object indexes the supported 'RttMonRttType' types.")
rttMonApplSupportedRttTypesValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesValid.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesValid.setDescription("This object defines the supported 'RttMonRttType' types.")
rttMonApplSupportedProtocolsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8), )
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsTable.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsTable.setDescription('A table of which contains the supported Rtt Monitor Protocols. See the RttMonProtocol textual convention for the definition of each protocol.')
rttMonApplSupportedProtocolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplSupportedProtocols"))
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsEntry.setDescription('A list that presents the valid Rtt Monitor Protocols.')
rttMonApplSupportedProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8, 1, 1), RttMonProtocol())
if mibBuilder.loadTexts: rttMonApplSupportedProtocols.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedProtocols.setDescription("This object indexes the supported 'RttMonProtocol' protocols.")
rttMonApplSupportedProtocolsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsValid.setStatus('current')
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsValid.setDescription("This object defines the supported 'RttMonProtocol' protocols.")
rttMonApplPreConfigedTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9), )
if mibBuilder.loadTexts: rttMonApplPreConfigedTable.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonApplPreConfigedTable.setDescription('A table of which contains the previously configured Script Names and File IO targets. These Script Names and File IO targets are installed via a different mechanism than this application, and are specific to each platform.')
rttMonApplPreConfigedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplPreConfigedType"), (0, "CISCO-RTTMON-MIB", "rttMonApplPreConfigedName"))
if mibBuilder.loadTexts: rttMonApplPreConfigedEntry.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonApplPreConfigedEntry.setDescription('A list of objects that describe the previously configured Script Names and File IO targets.')
rttMonApplPreConfigedType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filePath", 1), ("scriptName", 2))))
if mibBuilder.loadTexts: rttMonApplPreConfigedType.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonApplPreConfigedType.setDescription('This is the type of value being stored in the rttMonApplPreConfigedName object.')
rttMonApplPreConfigedName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1, 3), DisplayString())
if mibBuilder.loadTexts: rttMonApplPreConfigedName.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonApplPreConfigedName.setDescription("This is either one of the following depending on the value of the rttMonApplPreConfigedType object: - The file path to a server. One of these file paths must be used when defining an entry in the rttMonFileIOAdminTable table with 'fileIO' as the value of the rttMonCtrlAdminRttType object. - The script name to be used when generating RTT operations. One of these script names must be used when defining an entry in the rttMonScriptAdminTable table with 'script' as the value of the rttMonCtrlAdminRttType object. NOTE: For script names, command line parameters can follow these names in the rttMonScriptAdminTable table.")
rttMonApplPreConfigedValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplPreConfigedValid.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonApplPreConfigedValid.setDescription("When this row exists, this value will be 'true'. This object exists only to create a valid row in this table.")
rttMonApplProbeCapacity = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplProbeCapacity.setStatus('current')
if mibBuilder.loadTexts: rttMonApplProbeCapacity.setDescription('This object defines the number of new probes that can be configured on a router. The number depends on the value of rttMonApplFreeMemLowWaterMark, free bytes available on the router and the system configured rttMonCtrlAdminEntry number. Equation: rttMonApplProbeCapacity = MIN(((Free_Bytes_on_the_Router - rttMonApplFreeMemLowWaterMark)/ Memory_required_by_each_probe), rttMonApplNumCtrlAdminEntry - Num_of_Probes_already_configured))')
rttMonApplFreeMemLowWaterMark = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplFreeMemLowWaterMark.setStatus('current')
if mibBuilder.loadTexts: rttMonApplFreeMemLowWaterMark.setDescription('This object defines the amount of free memory a router must have in order to configure RTR. If RTR found out that the memory is falling below this mark, it will not allow new probes to be configured. This value should not be set higher (or very close to) than the free bytes available on the router.')
rttMonApplLatestSetError = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplLatestSetError.setStatus('current')
if mibBuilder.loadTexts: rttMonApplLatestSetError.setDescription('An error description for the last error message caused by set. Currently, it includes set error caused due to setting rttMonApplFreeMemLowWaterMark greater than the available free memory on the router or not enough memory left to create new probes.')
rttMonApplResponder = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplResponder.setStatus('current')
if mibBuilder.loadTexts: rttMonApplResponder.setDescription('Enable or disable RTR responder on the router.')
rttMonApplAuthTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14), )
if mibBuilder.loadTexts: rttMonApplAuthTable.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthTable.setDescription('A table which contains the definitions for key-strings that will be used in authenticating RTR Control Protocol.')
rttMonApplAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplAuthIndex"))
if mibBuilder.loadTexts: rttMonApplAuthEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthEntry.setDescription('A list that presents the valid parameters for Authenticating RTR Control Protocol.')
rttMonApplAuthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rttMonApplAuthIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthIndex.setDescription("Uniquely identifies a row in the rttMonApplAuthTable. This is a pseudo-random number selected by the management station when creating a row via the rttMonApplAuthStatus object. If the pseudo-random number is already in use, an 'inconsistentValue' is returned. Currently, only one row can be created.")
rttMonApplAuthKeyChain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyChain.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthKeyChain.setDescription('A string which represents the key-chain name. If multiple key-strings are specified, then the authenticator will alternate between the specified strings.')
rttMonApplAuthKeyString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString1.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthKeyString1.setDescription('A string which represents a key-string name whose id is 1.')
rttMonApplAuthKeyString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString2.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthKeyString2.setDescription('A string which represents a key-string name whose id is 2.')
rttMonApplAuthKeyString3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString3.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthKeyString3.setDescription('A string which represents a key-string name whose id is 3.')
rttMonApplAuthKeyString4 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString4.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthKeyString4.setDescription('A string which represents a key-string name whose id is 4.')
rttMonApplAuthKeyString5 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString5.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthKeyString5.setDescription('A string which represents a key-string name whose id is 5.')
rttMonApplAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonApplAuthStatus.setDescription('The status of the Authentication row.')
rttMonApplLpdGrpStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplLpdGrpStatsReset.setStatus('current')
if mibBuilder.loadTexts: rttMonApplLpdGrpStatsReset.setDescription("This object is used to reset certain objects within the rttMonLpdGrpStatsTable. When the object is set to value of an active LPD Group identifier the associated objects will be reset. The reset objects will be set to a value as specified in the object's description. The following objects will not be reset. - rttMonLpdGrpStatsTargetPE - rttMonLpdGrpStatsGroupProbeIndex - rttMonLpdGrpStatsGroupIndex - rttMonLpdGrpStatsStartTimeIndex.")
rttMonCtrlAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1), )
if mibBuilder.loadTexts: rttMonCtrlAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring definitions. The RTT administration control is in multiple tables. This first table, is used to create a conceptual RTT control row. The following tables contain objects which configure scheduling, information gathering, and notification/trigger generation. All of these tables will create the same conceptual RTT control row as this table using this tables' index as their own index. This table is limited in size by the agent implementation. The object rttMonApplNumCtrlAdminEntry will reflect this tables maximum number of entries.")
rttMonCtrlAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonCtrlAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminEntry.setDescription('A base list of objects that define a conceptual RTT control row.')
rttMonCtrlAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonCtrlAdminIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminIndex.setDescription("Uniquely identifies a row in the rttMonCtrlAdminTable. This is a pseudo-random number, selected by the management station or auto-generated based on operation started by the management station,when creating a row via the rttMonCtrlAdminStatus object. If the pseudo-random number is already in use an 'inconsistentValue' return code will be returned when set operation is attempted.")
rttMonCtrlAdminOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminOwner.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminOwner.setDescription('Identifies the entity that created this table row.')
rttMonCtrlAdminTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminTag.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonCtrlAdminTag.setDescription('A string which is used by a managing application to identify the RTT target. This string is inserted into trap notifications, but has no other significance to the agent. rttMonCtrlAdminTag object is superseded by rttMonCtrlAdminLongTag.')
rttMonCtrlAdminRttType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 4), RttMonRttType().clone('echo')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminRttType.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminRttType.setDescription("The type of RTT operation to be performed. This value must be set in the same PDU or before setting any type specific configuration. Note: The RTT operation 'lspGroup' cannot be created via this control row. It will be created automatically by Auto SAA L3 MPLS VPN when rttMplsVpnMonCtrlLpd is 'true'.")
rttMonCtrlAdminThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminThreshold.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminThreshold.setDescription('This object defines an administrative threshold limit. If the RTT operation time exceeds this limit and if the conditions specified in rttMonReactAdminThresholdType or rttMonHistoryAdminFilter are satisfied, a threshold is generated.')
rttMonCtrlAdminFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminFrequency.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminFrequency.setDescription("Specifies the duration between initiating each RTT operation. This object cannot be set to a value which would be a shorter duration than rttMonCtrlAdminTimeout. When the RttMonRttType specifies an operation that is synchronous in nature, it may happen that the next RTT operation is blocked by a RTT operation which has not yet completed. In this case, the value of a counter (rttMonStatsCollectBusies) in rttMonStatsCaptureTable is incremented in lieu of initiating a RTT operation, and the next attempt will occur at the next rttMonCtrlAdminFrequency expiration. NOTE: When the rttMonCtrlAdminRttType object is defined to be 'pathEcho', setting this value to a small value for your network size may cause an operation attempt (or multiple attempts) to be started before the previous operation has finished. In this situation the rttMonStatsCollectBusies object will be incremented in lieu of initiating a new RTT operation, and the next attempt will occur at the next rttMonCtrlAdminFrequency expiration. When the rttMonCtrlAdminRttType object is defined to be 'pathEcho', the suggested value for this object is greater than rttMonCtrlAdminTimeout times the maximum number of expected hops to the target. NOTE: When the rttMonCtrlAdminRttType object is defined to be 'dhcp', the minimum allowed value for this object is 10 seconds. This restriction is due to protocol limitations described in RFC 2131.")
rttMonCtrlAdminTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminTimeout.setDescription('Specifies the duration to wait for a RTT operation completion. The value of this object cannot be set to a value which would specify a duration exceeding rttMonCtrlAdminFrequency. For connection oriented protocols, this may cause the connection to be closed by the probe. Once closed, it will be assumed that the connection reestablishment will be performed. To prevent unwanted closure of connections, be sure to set this value to a realistic connection timeout.')
rttMonCtrlAdminVerifyData = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminVerifyData.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminVerifyData.setDescription('When set to true, the resulting data in each RTT operation is compared with the expected data. This includes checking header information (if possible) and exact packet size. Any mismatch will be recorded in the rttMonStatsCollectVerifyErrors object. Some RttMonRttTypes may not support this option. When a type does not support this option, the agent will transition this object to false. It is the management applications responsibility to check for this transition.')
rttMonCtrlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminStatus.setDescription("The status of the conceptual RTT control row. In order for this object to become active, the following row objects must be defined: - rttMonCtrlAdminRttType Additionally: - for echo, pathEcho based on 'ipIcmpEcho' and dlsw probes rttMonEchoAdminProtocol and rttMonEchoAdminTargetAddress; - for echo, pathEcho based on 'mplsLspPingAppl' rttMonEchoAdminProtocol, rttMonEchoAdminTargetAddress and rttMonEchoAdminLSPFECType - for udpEcho, tcpConnect and jitter probes rttMonEchoAdminTargetAddress and rttMonEchoAdminTargetPort - for http and ftp probe rttMonEchoAdminURL - for dns probe rttMonEchoAdminTargetAddressString rttMonEchoAdminNameServer - dhcp probe doesn't require any additional objects All other objects can assume default values. The conceptual Rtt control row will be placed into a 'pending' state (via the rttMonCtrlOperState object) if rttMonScheduleAdminRttStartTime is not specified. Most conceptual Rtt control row objects cannot be modified once this conceptual Rtt control row has been created. The objects that can change are the following: - Objects in the rttMonReactAdminTable can be modified as needed without setting this object to 'notInService'. - Objects in the rttMonScheduleAdminTable can be modified only when this object has the value of 'notInService'. - The rttMonCtrlOperState can be modified to control the state of the probe. Once this object is in 'active' status, it cannot be set to 'notInService' while the rttMonCtrlOperState is in 'active' state. Thus the rttMonCtrlOperState object must be transitioned first. This object can be set to 'destroy' from any value at any time.")
rttMonCtrlAdminNvgen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminNvgen.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminNvgen.setDescription("When set to true, this entry will be shown in 'show running' command and can be saved into Non-volatile memory.")
rttMonCtrlAdminGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlAdminGroupName.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminGroupName.setDescription('If the operation is created through auto measure group creation, then this string will specify the group name to which this operation is associated.')
rttMonCtrlAdminLongTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminLongTag.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlAdminLongTag.setDescription('This object provides additional information about the Probe and is inserted into trap notifications, but has no other significance to the agent. Setting this object will overwrite any description already set by rttMonCtrlAdminTag and vice-versa.')
rttMonEchoAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2), )
if mibBuilder.loadTexts: rttMonEchoAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTable.setDescription('A table that contains Round Trip Time (RTT) specific definitions. This table is controlled via the rttMonCtrlAdminTable. Entries in this table are created via the rttMonCtrlAdminStatus object.')
rttMonEchoAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonEchoAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEntry.setDescription('A list of objects that define specific configuration for RttMonRttType conceptual Rtt control rows.')
rttMonEchoAdminProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 1), RttMonProtocol().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProtocol.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminProtocol.setDescription("Specifies the protocol to be used to perform the RTT operation. The following list defines what protocol should be used for each probe type: echo, pathEcho - ipIcmpEcho / mplsLspPingAppl udpEcho - ipUdpEchoAppl tcpConnect - ipTcpConn http - httpAppl jitter - jitterAppl dlsw - dlswAppl dhcp - dhcpAppl ftp - ftpAppl mplsLspPing - mplsLspPingAppl voip - voipAppl video - videoAppl fabricPathEcho - fabricPathEchoAppl When this protocol does not support the type, a 'badValue' error will be returned.")
rttMonEchoAdminTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 2), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetAddress.setDescription('A string which specifies the address of the target.')
rttMonEchoAdminPktDataRequestSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(1)).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminPktDataRequestSize.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminPktDataRequestSize.setDescription("This object represents the number of octets to be placed into the ARR Data portion of the request message, when using SNA protocols. For non-ARR protocols' RTT request/responses, this value represents the native payload size. REMEMBER: The ARR Header overhead is not included in this value. For echo probes the total packet size = (IP header(20) + ICMP header(8) + 8 (internal timestamps) + request size). For echo and pathEcho default request size is 28. For udp probe, default request size is 16 and for jitter probe it is 32. For dlsw probes default request size is 0. The minimum request size for echo and pathEcho is 28 bytes, for udp it is 4 and for jitter it is 16. For udp and jitter probes the maximum request size is 1500. For ethernetPing the default request size is 66. For ethernetJitter the default request size is 51.")
rttMonEchoAdminPktDataResponseSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminPktDataResponseSize.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminPktDataResponseSize.setDescription('This object represents the number of octets to be placed into the ARR Data portion of the response message. This value is passed to the RTT Echo Server via a field in the ARR Header. For non-ARR RTT request/response (i.e. ipIcmpecho) this value will be set by the agent to match the size of rttMonEchoAdminPktDataRequestSize, when native payloads are supported. REMEMBER: The ARR Header overhead is not included in this value. This object is only supported by SNA protocols.')
rttMonEchoAdminTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetPort.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetPort.setDescription("This object represents the target's port number. This object is applicable to udpEcho, tcpConnect and jitter probes.")
rttMonEchoAdminSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 6), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSourceAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminSourceAddress.setDescription('A string which specifies the IP address of the source. This object is applicable to all probes except dns, dlsw and sna.')
rttMonEchoAdminSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSourcePort.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminSourcePort.setDescription("This object represents the source's port number. If this object is not specified, the application will get a port allocated by the system. This object is applicable to all probes except dns, dlsw and sna.")
rttMonEchoAdminControlEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminControlEnable.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminControlEnable.setDescription('If this object is enabled, then the RTR application will send control messages to a responder, residing on the target router to respond to the data request packets being sent by the source router. This object is not applicable to echo, pathEcho, dns and http probes.')
rttMonEchoAdminTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTOS.setReference('Refer to the following documents for TOS definition. RFC791/1349 for IPv4, IPv6, draft-ietf-diffserv-header-02.txt')
if mibBuilder.loadTexts: rttMonEchoAdminTOS.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTOS.setDescription('This object represents the type of service octet in an IP header. This object is not applicable to dhcp, dns, ethernetPing and ethernetJitter.')
rttMonEchoAdminLSREnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminLSREnable.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSREnable.setDescription('If this object is enabled then it means that the application calculates response time for a specific path, defined in rttMonEchoPathAdminEntry. This object is applicable to echo probe only.')
rttMonEchoAdminTargetAddressString = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 11), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetAddressString.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetAddressString.setDescription('A string which specifies the address of the target. This string can be in IP address format or a hostname. This object is applicable to dns probe only.')
rttMonEchoAdminNameServer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 12), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminNameServer.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminNameServer.setDescription('A string which specifies the ip address of the name-server. This object is applicable to dns probe only.')
rttMonEchoAdminOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 13), RttMonOperation()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOperation.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminOperation.setDescription('A code that represents the specific type of RTT operation. This object is applicable to http and ftp probe only.')
rttMonEchoAdminHTTPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 10)).clone('1.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminHTTPVersion.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminHTTPVersion.setDescription('A string which specifies the version number of the HTTP Server. The syntax for the version string is <major number>.<minor number> An example would be 1.0, 1.1 etc.,. This object is applicable to http probe only.')
rttMonEchoAdminURL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 15), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminURL.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminURL.setDescription('A string which represents the URL to which a HTTP probe should communicate with. This object is applicable to http probe only.')
rttMonEchoAdminCache = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCache.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCache.setDescription('If this object is false then it means that HTTP request should not download cached pages. This means that the request should be forwarded to the origin server. This object is applicable to http probe only.')
rttMonEchoAdminInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(20)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminInterval.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminInterval.setDescription('This value represents the inter-packet delay between packets and is in milliseconds. This value is currently used for Jitter probe. This object is applicable to jitter probe only.')
rttMonEchoAdminNumPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 18), Integer32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminNumPackets.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminNumPackets.setDescription('This value represents the number of packets that need to be transmitted. This value is currently used for Jitter probe. This object is applicable to jitter probe only.')
rttMonEchoAdminProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 19), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProxy.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminProxy.setDescription('This string represents the proxy server information. This object is applicable to http probe only.')
rttMonEchoAdminString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 20), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString1.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminString1.setDescription('This string stores the content of HTTP raw request. If the request cannot fit into String1 then it should be split and put in Strings 1 through 5. This string stores the content of the DHCP raw option data. The raw DHCP option data must be in HEX. If an odd number of characters are specified, a 0 will be appended to the end of the string. Only DHCP option 82 (decimal) is allowed. Here is an example of a valid string: 5208010610005A6F1234 Only rttMonEchoAdminString1 is used for dhcp, Strings 1 through 5 are not used. This object is applicable to http and dhcp probe types only.')
rttMonEchoAdminString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 21), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString2.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminString2.setDescription('This string stores the content of HTTP raw request. rttMonEchoAdminString1-5 are concatenated to form the HTTP raw request used in the RTT operation. This object is applicable to http probe only.')
rttMonEchoAdminString3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 22), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString3.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminString3.setDescription('This string stores the content of HTTP raw request. rttMonEchoAdminString1-5 are concatenated to form the HTTP raw request used in the RTT operation. This object is applicable to http probe only.')
rttMonEchoAdminString4 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 23), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString4.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminString4.setDescription('This string stores the content of HTTP raw request. rttMonEchoAdminString1-5 are concatenated to form the HTTP raw request used in the RTT operation. This object is applicable to http probe only.')
rttMonEchoAdminString5 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 24), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString5.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminString5.setDescription('This string stores the content of HTTP raw request. rttMonEchoAdminString1-5 are concatenated to form the HTTP raw request used in the RTT operation. This object is applicable to http probe only.')
rttMonEchoAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 25), RttMonOperation().clone('ftpPassive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminMode.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminMode.setDescription('A code that represents the specific type of RTT operation. This object is applicable to ftp probe only.')
rttMonEchoAdminVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminVrfName.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminVrfName.setDescription('This field is used to specify the VPN name in which the RTT operation will be used. For regular RTT operation this field should not be configured. The agent will use this field to identify the VPN routing Table for this operation.')
rttMonEchoAdminCodecType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 27), RttMonCodecType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecType.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCodecType.setDescription('Specifies the codec type to be used with jitter probe. This is applicable only for the jitter probe. If codec-type is configured the following parameters cannot be configured. rttMonEchoAdminPktDataRequestSize rttMonEchoAdminInterval rttMonEchoAdminNumPackets')
rttMonEchoAdminCodecInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecInterval.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCodecInterval.setDescription('This field represents the inter-packet delay between packets and is in milliseconds. This object is applicable only to jitter probe which uses codec type.')
rttMonEchoAdminCodecPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecPayload.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCodecPayload.setDescription('This object represents the number of octets that needs to be placed into the Data portion of the message. This value is used only for jitter probe which uses codec type.')
rttMonEchoAdminCodecNumPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecNumPackets.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCodecNumPackets.setDescription('This value represents the number of packets that need to be transmitted. This value is used only for jitter probe which uses codec type.')
rttMonEchoAdminICPIFAdvFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminICPIFAdvFactor.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminICPIFAdvFactor.setDescription('The advantage factor is dependant on the type of access and how the service is to be used. Conventional Wire-line 0 Mobility within Building 5 Mobility within geographic area 10 Access to hard-to-reach location 20 This will be used while calculating the ICPIF values This valid only for Jitter while calculating the ICPIF value')
rttMonEchoAdminLSPFECType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ldpIpv4Prefix", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPFECType.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPFECType.setDescription("The type of the target FEC for the RTT 'echo' and 'pathEcho' operations based on 'mplsLspPingAppl' RttMonProtocol. ldpIpv4Prefix - LDP IPv4 prefix.")
rttMonEchoAdminLSPSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 33), RttMonTargetAddress().clone('7F 00 00 01')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPSelector.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPSelector.setDescription("A string which specifies a valid 127/8 address. This address is of the form 127.x.y.z. This address is not used to route the MPLS echo packet to the destination but is used for load balancing in cases where the IP payload's destination address is used for load balancing.")
rttMonEchoAdminLSPReplyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 34), RttMonLSPPingReplyMode().clone('replyIpv4Udp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPReplyMode.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPReplyMode.setDescription('This object specifies the reply mode for the LSP Echo requests.')
rttMonEchoAdminLSPTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPTTL.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPTTL.setDescription("This object represents the TTL setting for MPLS echo request packets. For ping operation this represents the TTL value to be set in the echo request packet. For trace operation it represent the maximum ttl value that can be set in the echo request packets starting with TTL=1. For 'echo' based on mplsLspPingAppl the default TTL will be set to 255, and for 'pathEcho' based on mplsLspPingAppl the default will be set to 30. Note: This object cannot be set to the value of 0. The default value of 0 signifies the default TTL values to be used for 'echo' and 'pathEcho' based on 'mplsLspPingAppl'.")
rttMonEchoAdminLSPExp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPExp.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPExp.setDescription('This object represents the EXP value that needs to be put as precedence bit in the MPLS echo request IP header.')
rttMonEchoAdminPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("milliseconds", 1), ("microseconds", 2))).clone('milliseconds')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminPrecision.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminPrecision.setDescription('This object specifies the accuracy of statistics that needs to be calculated milliseconds - The accuracy of stats will be of milliseconds microseconds - The accuracy of stats will be in microseconds. This value can be set only for jitter operation')
rttMonEchoAdminProbePakPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("high", 2))).clone('normal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProbePakPriority.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminProbePakPriority.setDescription('This object specifies the priority that will be assigned to probe packet. This value can be set only for jitter operation')
rttMonEchoAdminOWNTPSyncTolAbs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 39), Integer32()).setUnits('microseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolAbs.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolAbs.setDescription('This object specifies the total clock synchronization error on source and responder that is considered acceptable for oneway measurement when NTP is used as clock synchronization mechanism. The total clock synchronization error is sum of NTP offsets on source and responder. The value specified is microseconds. This value can be set only for jitter operation with precision of microsecond.')
rttMonEchoAdminOWNTPSyncTolPct = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolPct.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolPct.setDescription('This object specifies the total clock synchronization error on source and responder that is considered acceptable for oneway measurement when NTP is used as clock synchronization mechanism. The total clock synchronization error is sum of NTP offsets on source and responder. The value is expressed as the percentage of actual oneway latency that is measured. This value can be set only for jitter operation with precision of microsecond.')
rttMonEchoAdminOWNTPSyncTolType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("percent", 1), ("absolute", 2))).clone('percent')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolType.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolType.setDescription('This object specifies whether the value in specified for oneway NTP sync tolerance is absolute value or percent value')
rttMonEchoAdminCalledNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 42), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCalledNumber.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCalledNumber.setDescription('This string stores the called number of post dial delay. This object is applicable to voip post dial delay probe only. The number will be like the one actualy the user could dial. It has the number required by the local country dial plan, plus E.164 number. The maximum length is 24 digits. Only digit (0-9) is allowed.')
rttMonEchoAdminDetectPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 43), RttMonOperation().clone('voipDTAlertRinging')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminDetectPoint.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminDetectPoint.setDescription('A code that represents the detect point of post dial delay. This object is applicable to SAA post dial delay probe only.')
rttMonEchoAdminGKRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 44), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminGKRegistration.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminGKRegistration.setDescription('A boolean that represents VoIP GK registration delay. This object is applicable to SAA GK registration delay probe only.')
rttMonEchoAdminSourceVoicePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 45), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSourceVoicePort.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminSourceVoicePort.setDescription('A string which specifies the voice-port on the source gateway. This object is applicable to RTP probe only.')
rttMonEchoAdminCallDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCallDuration.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminCallDuration.setDescription('Duration of RTP/Video Probe session. This object is applicable to RTP and Video probe.')
rttMonEchoAdminLSPReplyDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 63), ValueRangeConstraint(255, 255), )).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPReplyDscp.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPReplyDscp.setDescription('This object specifies the DSCP value to be set in the IP header of the LSP echo reply packet. The value of this object will be in range of DiffServ codepoint values between 0 to 63. Note: This object cannot be set to value of 255. This default value specifies that DSCP is not set for this row.')
rttMonEchoAdminLSPNullShim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 48), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPNullShim.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPNullShim.setDescription('This object specifies if the explicit-null label is to be added to LSP echo requests which are sent while performing RTT operation.')
rttMonEchoAdminTargetMPID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 49), CfmMepid()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetMPID.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetMPID.setDescription('This object specifies the destination maintenance point ID. It is only applicable to ethernetPing and ethernetJitter operation. It will be set to 0 for other types of operations.')
rttMonEchoAdminTargetDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 50), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetDomainName.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetDomainName.setDescription('This object specifies the name of the domain in which the destination maintenance point lies. It is only applicable to ethernetPing and ethernetJitter operation.')
rttMonEchoAdminTargetVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 51), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetVLAN.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetVLAN.setDescription('This object specifies the ID of the VLAN in which the destination maintenance point lies. It is only applicable to ethernetPing and ethernetJitter operation. It will be set to 0 for other types of operations.')
rttMonEchoAdminEthernetCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 52), QosLayer2Cos().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEthernetCOS.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEthernetCOS.setDescription('This object specifies the class of service in an Ethernet packet header. It is only applicable to ethernetPing and ethernetJitter operation.')
rttMonEchoAdminLSPVccvID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPVccvID.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLSPVccvID.setDescription('This object specifies MPLS LSP pseudowire VCCV ID values between 1 to 2147483647. Note: This object cannot be set to value of 0. This default value specifies that VCCV is not set for this row.')
rttMonEchoAdminTargetEVC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 54), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetEVC.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetEVC.setDescription('This object specifies the Ethernet Virtual Connection in which the destination maintenance point lies. It is only applicable to ethernetPing and ethernetJitter operation. It will be set to NULL for other types of operations.')
rttMonEchoAdminTargetMEPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 55), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetMEPPort.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetMEPPort.setDescription('This object specifies that Port Level CFM testing towards an Outward/Down MEP will be used. It is only applicable to ethernetPing and ethernetJitter operation. It will be set to NULL for other types of operations.')
rttMonEchoAdminVideoTrafficProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 56), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminVideoTrafficProfile.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminVideoTrafficProfile.setDescription('A string which represents the profile name to which a video probe should use. This object is applicable to video probe only.')
rttMonEchoAdminDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 57), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminDscp.setReference('RFC 2474, RFC 2780')
if mibBuilder.loadTexts: rttMonEchoAdminDscp.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminDscp.setDescription('This object represents the Differentiated Service Code Point (DSCP) QoS marking in the generated synthetic packets. Value - DiffServ Class 0 - BE (default) 10 - AF11 12 - AF12 14 - AF13 18 - AF21 20 - AF22 22 - AF23 26 - AF31 28 - AF32 30 - AF33 34 - AF41 36 - AF42 38 - AF43 8 - CS1 16 - CS2 24 - CS3 32 - CS4 40 - CS5 48 - CS6 56 - CS7 46 - EF')
rttMonEchoAdminReserveDsp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("be", 1), ("gs", 2), ("na", 3))).clone('na')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminReserveDsp.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminReserveDsp.setDescription('This object represents the video traffic generation source. be : best effort using DSP but without reservation gs : guaranteed service using DSP with reservation na : not applicable for not using DSP')
rttMonEchoAdminInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 59), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminInputInterface.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminInputInterface.setDescription('This object represents the network input interface on the sender router where the synthetic packets are received from the emulated endpoint source. This is used for path congruence with correct feature processing at the sender router. The user can get the InterfaceIndex number from ifIndex object by looking up in ifTable. In fact, it should be useful to first get the entry by the augmented table ifXTable which has ifName object which matches the interface name used on the router or switch equipment console.')
rttMonEchoAdminEmulateSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 60), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateSourceAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEmulateSourceAddress.setDescription('This object specifies the IP address of the emulated source from which the synthetic packets would be generated. If this object is not specified, the emulated source IP address will by default be the same as rttMonEchoAdminSourceAddress. This object is applicable to video probes.')
rttMonEchoAdminEmulateSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateSourcePort.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEmulateSourcePort.setDescription('This object represents the port number of the emulated source from which the synthetic packets would be generated. If this object is not specified, the emulated source port number will by default be the same as rttMonEchoAdminSourcePort. This object is applicable to video probes.')
rttMonEchoAdminEmulateTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 62), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateTargetAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEmulateTargetAddress.setDescription('This object specifies the IP address of the emulated target by which the synthetic packets would be received. If this object is not specified, the emulated target IP address will by default be the same as rttMonEchoAdminTargetAddress. This object is applicable to video probes.')
rttMonEchoAdminEmulateTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateTargetPort.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEmulateTargetPort.setDescription('This object represents the port number of the emulated target by which the synthetic packets would be received. If this object is not specified, the emulated target port number will by default be the same as rttMonEchoAdminTargetPort. This object is applicable to video probes.')
rttMonEchoAdminTargetMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 64), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetMacAddress.setDescription('This object indicates the MAC address of the target device. This object is only applicable for Y.1731 operations. rttMonEchoAdminTargetMacAddress and rttMonEchoAdminTargetMPID may not be used in conjunction.')
rttMonEchoAdminSourceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 65), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminSourceMacAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminSourceMacAddress.setDescription('This object indicates the MAC address of the source device. This object is only applicable for Y.1731 operations. rttMonEchoAdminSourceMacAddress and rttMonEchoAdminSourceMPID may not be used in conjunction.')
rttMonEchoAdminSourceMPID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 66), CfmMepid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminSourceMPID.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminSourceMPID.setDescription('This object indicates the source maintenance point ID. It is only applicable to Y.1731 operation. It will be set to zero for other types of opearations. rttMonEchoAdminSourceMPID and rttMonEchoAdminSourceMacAddress may not be used in conjunction.')
rttMonEchoAdminEndPointListName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 67), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEndPointListName.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEndPointListName.setDescription('This object specifies the name of endpoint list which a probe uses to generate operations.')
rttMonEchoAdminSSM = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 68), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSSM.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminSSM.setDescription('This object specifies if Source Specific Multicast is to be added. This object is applicable to multicast probe only.')
rttMonEchoAdminControlRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 69), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminControlRetry.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminControlRetry.setDescription('This object specifies the maximum number of retries for control message.')
rttMonEchoAdminControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminControlTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminControlTimeout.setDescription('This object specifies the wait duration before control message timeout.')
rttMonEchoAdminIgmpTreeInit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 71), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminIgmpTreeInit.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminIgmpTreeInit.setDescription('This object specifies number of packets to be sent for multicast tree setup. This object is applicable to multicast probe only.')
rttMonEchoAdminEnableBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 72), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminEnableBurst.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminEnableBurst.setDescription('This object indicates that packets will be sent in burst.')
rttMonEchoAdminAggBurstCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 73), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminAggBurstCycles.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminAggBurstCycles.setDescription('This object indicates the number of burst cycles to be sent during the aggregate interval. This value is currently used for Y1731 SLM(Synthetic Loss Measurment) probe. This object is applicable to Y1731 SLM probe only.')
rttMonEchoAdminLossRatioNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 74), Integer32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminLossRatioNumFrames.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminLossRatioNumFrames.setDescription('This object indicates the number of frames over which to calculate the frame loss ratio. This object is applicable to Y1731 SLM probe only.')
rttMonEchoAdminAvailNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 75), Integer32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminAvailNumFrames.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminAvailNumFrames.setDescription('This object indicates the number of frames over which to calculate the availability. This object is applicable to Y1731 SLM probe only.')
rttMonEchoAdminTstampOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 76), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTstampOptimization.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTstampOptimization.setDescription("This object specifies whether timestamp optimization is enabled. When the value is 'true' then timestamp optimization is enabled. The probe will utilize lower layer (Hardware/Packet Processor) timestamping values to improve accuracy of statistics. This value can be set only for udp jitter operation with precision of microsecond.")
rttMonEchoAdminTargetSwitchId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 77), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 65535), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetSwitchId.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminTargetSwitchId.setDescription('This object represents the destination Switch Id that needed to send one TRILL/FB OAM Loopback request. This object is applicable to Fabric Path Echo probe only. Value 0 means not applicable.')
rttMonEchoAdminProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 78), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1023), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProfileId.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminProfileId.setDescription('This object represents the destination Profile Id that needed to send one TRILL/FB OAM Loopback request. This object is applicable to Fabric Path Echo probe only. Value 0 means not applicable.')
rttMonEchoAdminOutputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 79), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOutputInterface.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoAdminOutputInterface.setDescription('This object represents the network interface on the sender router where the packets are transmitted from the emulated endpoint source. The user can get the InterfaceIndex number from ifIndex object by looking up in ifTable. In fact, it should be useful to first get the entry by the augmented table ifXTable which has ifName object which matches the interface name used on the router or switch equipment console.')
rttMonFileIOAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3), )
if mibBuilder.loadTexts: rttMonFileIOAdminTable.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonFileIOAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring 'fileIO' specific definitions. When the RttMonRttType is not 'fileIO' this table is not valid. This table is controlled via the rttMonCtrlAdminTable. Entries in this table are created via the rttMonCtrlAdminStatus object.")
rttMonFileIOAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonFileIOAdminEntry.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonFileIOAdminEntry.setDescription("A list of objects that define specific configuration for 'fileIO' RttMonRttType conceptual Rtt control rows.")
rttMonFileIOAdminFilePath = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1, 1), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonFileIOAdminFilePath.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonFileIOAdminFilePath.setDescription('The fully qualified file path that will be the target of the RTT operation. This value must match one of the rttMonApplPreConfigedName entries.')
rttMonFileIOAdminSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("n256", 1), ("n1k", 2), ("n64k", 3), ("n128k", 4), ("n256k", 5))).clone('n256')).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonFileIOAdminSize.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonFileIOAdminSize.setDescription('The size of the file to write/read from the File Server.')
rttMonFileIOAdminAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("write", 1), ("read", 2), ("writeRead", 3))).clone('read')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonFileIOAdminAction.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonFileIOAdminAction.setDescription('The File I/O action to be performed.')
rttMonScriptAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4), )
if mibBuilder.loadTexts: rttMonScriptAdminTable.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonScriptAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring 'script' specific definitions. When the RttMonRttType is not 'script' this table is not valid. This table is controlled via the rttMonCtrlAdminTable. Entries in this table are created via the rttMonCtrlAdminStatus object.")
rttMonScriptAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonScriptAdminEntry.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonScriptAdminEntry.setDescription("A list of objects that define specific configuration for 'script' RttMonRttType conceptual Rtt control rows.")
rttMonScriptAdminName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4, 1, 1), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScriptAdminName.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonScriptAdminName.setDescription('This will be the Name of the Script that will be used to generate RTT operations. This object must match one of the rttMonApplPreConfigedName entries.')
rttMonScriptAdminCmdLineParams = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScriptAdminCmdLineParams.setStatus('obsolete')
if mibBuilder.loadTexts: rttMonScriptAdminCmdLineParams.setDescription('This will be the actual command line parameters passed to the rttMonScriptAdminName when being executed.')
rttMonScheduleAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5), )
if mibBuilder.loadTexts: rttMonScheduleAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminTable.setDescription('A table of Round Trip Time (RTT) monitoring scheduling specific definitions. This table is controlled via the rttMonCtrlAdminTable. Entries in this table are created via the rttMonCtrlAdminStatus object.')
rttMonScheduleAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1), )
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonScheduleAdminEntry"))
rttMonScheduleAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonScheduleAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminEntry.setDescription('A list of objects that define specific configuration for the scheduling of RTT operations.')
rttMonScheduleAdminRttLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminRttLife.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminRttLife.setDescription("This object value will be placed into the rttMonCtrlOperRttLife object when the rttMonCtrlOperState object transitions to 'active' or 'pending'. The value 2147483647 has a special meaning. When this object is set to 2147483647, the rttMonCtrlOperRttLife object will not decrement. And thus the life time will never end.")
rttMonScheduleAdminRttStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 2), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminRttStartTime.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminRttStartTime.setDescription("This is the time when this conceptional row will activate. This is the value of MIB-II's sysUpTime in the future. When sysUpTime equals this value this object will cause the activation of a conceptual Rtt row. When an agent has the capability to determine date and time, the agent should store this object as DateAndTime. This allows the agent to completely reset (restart) and still be able to start conceptual Rtt rows at the intended time. If the agent cannot keep date and time and the agent resets, all entries should take on one of the special value defined below. The first special value allows this conceptual Rtt control row to immediately transition the rttMonCtrlOperState object into 'active' state when the rttMonCtrlAdminStatus object transitions to active. This special value is defined to be a value of this object that, when initially set, is 1. The second special value allows this conceptual Rtt control row to immediately transition the rttMonCtrlOperState object into 'pending' state when the rttMonCtrlAdminStatus object transitions to active. Also, when the rttMonCtrlOperRttLife counts down to zero (and not when set to zero), this special value causes this conceptual Rtt control row to retransition the rttMonCtrlOperState object into 'pending' state. This special value is defined to be a value of this object that, when initially set, is smaller than the current sysUpTime. (With the exception of one, as defined in the previous paragraph) If rttMonScheduleAdminStartType is specified with this object then rttMonScheduleAdminRttStartTime is ignored and probe start time is configured based on rttMonScheduleAdminStartType.")
rttMonScheduleAdminConceptRowAgeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminConceptRowAgeout.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonScheduleAdminConceptRowAgeout.setDescription("The amount of time this conceptual Rtt control row will exist when not in an 'active' rttMonCtrlOperState. When this conceptual Rtt control row enters an 'active' state, this timer will be reset and suspended. When this conceptual RTT control row enters a state other than 'active', the timer will be restarted. NOTE: When a conceptual Rtt control row ages out, the agent needs to remove the associated entries in the rttMonReactTriggerAdminTable and rttMonReactTriggerOperTable. When this value is set to zero, this entry will never be aged out. rttMonScheduleAdminConceptRowAgeout object is superseded by rttMonScheduleAdminConceptRowAgeoutV2.")
rttMonScheduleAdminRttRecurring = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminRttRecurring.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminRttRecurring.setDescription('When set to true, this entry will be scheduled to run automatically for the specified duration equal to the life configured, at the same time daily. This value cannot be set to true (a) if rttMonScheduleAdminRttLife object has value greater or equal to 86400 seconds. (b) if sum of values of rttMonScheduleAdminRttLife and rttMonScheduleAdminConceptRowAgeout is less or equal to 86400 seconds.')
rttMonScheduleAdminConceptRowAgeoutV2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminConceptRowAgeoutV2.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminConceptRowAgeoutV2.setDescription("The amount of time this conceptual Rtt control row will exist when not in an 'active' rttMonCtrlOperState. When this conceptual Rtt control row enters an 'active' state, this timer will be reset and suspended. When this conceptual RTT control row enters a state other than 'active', the timer will be restarted. NOTE: It is the same as rttMonScheduleAdminConceptRowAgeout except DEFVAL is 0 to be consistent with CLI ageout default. When this value is set to zero, this entry will never be aged out.")
rttMonScheduleAdminStartType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 6), RttMonScheduleStartType().clone('pending')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminStartType.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminStartType.setDescription('This object specifies the start-time option to be used for scheduling the start time of RTT operation. The following list defines the start-time options that can be configured for the probe: pending(1) pending state. now(2) schedule to immediately start the probe. random(3) schedule start time of probe at random time over a range. after(4) schedule start time of probe after a certain amount of time from now. specific(5) schedule start time of probe at a given specific time interval')
rttMonScheduleAdminStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(500, 10000)).clone(500)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminStartDelay.setStatus('current')
if mibBuilder.loadTexts: rttMonScheduleAdminStartDelay.setDescription('This object specifies the start time delay range in milliseconds. The value of this object is only effective with rttMonScheduleAdminStartType value. For rttMonScheduleAdminStartType with random option, a random time is generated with in provided start delay range and added to current time to generate the random start time of the probe.')
rttMonReactAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6), )
if mibBuilder.loadTexts: rttMonReactAdminTable.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring Notification and Trigger definitions. All Notification/Reactions are applied to all RTT End-to-End operations. Thus, they do not apply to hops along a path to the target, when RttMonRttType is 'pathEcho'. The format and content of SNA NMVT's are not defined within this module. It can be noted, however, that there are Alert NMVT's, and traps which are sent when an abnormal condition occurs, i.e. when one of rttMonCtrlOperConnectionLostOccurred, rttMonCtrlOperTimeoutOccurred or rttMonCtrlOperOverThresholdOccurred are changed to true, and Resolution NMVT's, and Resolution traps which are sent when that condition clears, i.e. when one of rttMonCtrlOperConnectionLostOccurred, rttMonCtrlOperTimeoutOccurred or rttMonCtrlOperOverThresholdOccurred is changed back to false. When rttMonReactAdminActionType is set to one of the following: - triggerOnly - trapAndTrigger - nmvtAndTrigger - trapNmvtAndTrigger The corresponding rows in the rttMonReactTriggerAdminTable defined via the rttMonCtrlAdminIndex will become active. This table augments the rttMonCtrlAdminTable. rttMonReactAdminTable object is superseded by rttMonReactTable.")
rttMonReactAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1), )
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonReactAdminEntry"))
rttMonReactAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonReactAdminEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminEntry.setDescription('A list of objects that define RTT reaction operations. rttMonReactAdminEntry object is superseded by rttMonReactEntry.')
rttMonReactAdminConnectionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminConnectionEnable.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminConnectionEnable.setDescription('If true, a reaction is generated when a RTT operation to a rttMonEchoAdminTargetAddress (echo type) causes rttMonCtrlOperConnectionLostOccurred to change its value. Thus connections to intermediate hops will not cause this value to change. rttMonReactAdminConnectionEnable object is superseded by rttMonReactVar.')
rttMonReactAdminTimeoutEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminTimeoutEnable.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminTimeoutEnable.setDescription("If true, a reaction is generated when a RTT operation causes rttMonCtrlOperTimeoutOccurred to change its value. When the RttMonRttType is 'pathEcho' timeouts to intermediate hops will not cause rttMonCtrlOperTimeoutOccurred to change its value. rttMonReactAdminTimeoutEnable object is superseded by rttMonReactVar.")
rttMonReactAdminThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), ("xOfy", 4), ("average", 5))).clone('never')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdType.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminThresholdType.setDescription("This object specifies the conditions under which rttMonCtrlOperOverThresholdOccurred is changed: NOTE: When the RttMonRttType is 'pathEcho' this objects' value and all associated object values are only valid when RTT 'echo' operations are to the rttMonEchoAdminTargetAddress object address. Thus 'pathEcho' operations to intermediate hops will not cause this object to change. never - rttMonCtrlOperOverThresholdOccurred is never set immediate - rttMonCtrlOperOverThresholdOccurred is set to true when an operation completion time exceeds rttMonCtrlAdminThreshold; conversely rttMonCtrlOperOverThresholdOccurred is set to false when an operation completion time falls below rttMonReactAdminThresholdFalling consecutive - rttMonCtrlOperOverThresholdOccurred is set to true when an operation completion time exceeds rttMonCtrlAdminThreshold on rttMonReactAdminThresholdCount consecutive RTT operations; conversely, rttMonCtrlOperOverThresholdOccurred is set to false when an operation completion time falls under the rttMonReactAdminThresholdFalling for the same number of consecutive operations xOfy - rttMonCtrlOperOverThresholdOccurred is set to true when x (as specified by rttMonReactAdminThresholdCount) out of the last y (as specified by rttMonReactAdminThresholdCount2) operation completion time exceeds rttMonCtrlAdminThreshold; conversely, it is set to false when x, out of the last y operation completion time fall below rttMonReactAdminThresholdFalling NOTE: When x > y, the probe will never generate a reaction. average - rttMonCtrlOperOverThresholdOccurred is set to true when the running average of the previous rttMonReactAdminThresholdCount operation completion times exceed rttMonCtrlAdminThreshold; conversely, it is set to false when the running average falls below the rttMonReactAdminThresholdFalling If this value is changed by a management station, rttMonCtrlOperOverThresholdOccurred is set to false, but no reaction is generated if the prior value of rttMonCtrlOperOverThresholdOccurred was true. rttMonReactAdminThresholdType object is superseded by rttMonReactThresholdType.")
rttMonReactAdminThresholdFalling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdFalling.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminThresholdFalling.setDescription('This object defines a threshold limit. If the RTT operation time falls below this limit and if the conditions specified in rttMonReactAdminThresholdType are satisfied, an threshold is generated. rttMonReactAdminThresholdFalling object is superseded by rttMonReactThresholdFalling.')
rttMonReactAdminThresholdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdCount.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminThresholdCount.setDescription("This object defines the 'x' value of the xOfy condition specified in rttMonReactAdminThresholdType. rttMonReactAdminThresholdCount object is superseded by rttMonReactThresholdCountX.")
rttMonReactAdminThresholdCount2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdCount2.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminThresholdCount2.setDescription("This object defines the 'y' value of the xOfy condition specified in rttMonReactAdminThresholdType. rttMonReactAdminThresholdCount2 object is superseded by rttMonReactThresholdCountyY.")
rttMonReactAdminActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("trapOnly", 2), ("nmvtOnly", 3), ("triggerOnly", 4), ("trapAndNmvt", 5), ("trapAndTrigger", 6), ("nmvtAndTrigger", 7), ("trapNmvtAndTrigger", 8))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminActionType.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminActionType.setDescription('Specifies what type(s), if any, of reaction(s) to generate if an operation violates one of the watched conditions: none - no reaction is generated trapOnly - a trap is generated nmvtOnly - an SNA NMVT is generated triggerOnly - all trigger actions defined for this entry are initiated trapAndNmvt - both a trap and an SNA NMVT are generated trapAndTrigger - both a trap and all trigger actions are initiated nmvtAndTrigger - both a NMVT and all trigger actions are initiated trapNmvtAndTrigger - a NMVT, trap, and all trigger actions are initiated A trigger action is defined via the rttMonReactTriggerAdminTable. rttMonReactAdminActionType object is superseded by rttMonReactActionType.')
rttMonReactAdminVerifyErrorEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminVerifyErrorEnable.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonReactAdminVerifyErrorEnable.setDescription('If true, a reaction is generated when a RTT operation causes rttMonCtrlOperVerifyErrorOccurred to change its value. rttMonReactAdminVerifyErrorEnable object is superseded by rttMonReactVar.')
rttMonStatisticsAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7), )
if mibBuilder.loadTexts: rttMonStatisticsAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring statistics definitions. The definitions in this table control what and how many entries will be placed into the rttMonStatsCaptureTable. The statistics capture table is a rollover table. When the rttMonStatisticsAdminNumHourGroups index value exceeds its value defined in this table, the oldest corresponding group will be deleted and will be replaced with the new group. All other indices will only fill to there maximum size. NOTE: The maximum size of this table is defined to be the product of the rttMonCtrlAdminIndex times rttMonStatisticsAdminNumHourGroups times rttMonStatisticsAdminNumPaths times rttMonStatisticsAdminNumHops times rttMonStatisticsAdminNumDistBuckets. NOTE WELL: Each of the 'Num' objects values in this have a special behavior. When one of the objects is set to a value larger than the Rtt application can support the set will succeed, but the resultant value will be set to the applications maximum value. The setting management station must reread this object to verify the actual value. This table augments the rttMonCtrlAdminTable.")
rttMonStatisticsAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1), )
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonStatisticsAdminEntry"))
rttMonStatisticsAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonStatisticsAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminEntry.setDescription('A list of objects that define RTT statistics capture operations.')
rttMonStatisticsAdminNumHourGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumHourGroups.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminNumHourGroups.setDescription('The maximum number of groups of paths to record. Specifically this is the number of hourly groups to keep before rolling over. The value of one is not advisable because the group will close and immediately be deleted before the network management station will have the opportunity to retrieve the statistics. The value used in the rttMonStatsCaptureTable to uniquely identify this group is the rttMonStatsCaptureStartTimeIndex. HTTP and Jitter probes store only two hours of data. When this object is set to the value of zero all rttMonStatsCaptureTable data capturing will be shut off.')
rttMonStatisticsAdminNumPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumPaths.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminNumPaths.setDescription("When RttMonRttType is 'pathEcho' this is the maximum number of statistics paths to record per hourly group. This value directly represents the path to a target. For all other RttMonRttTypes this value will be forced to one by the agent. NOTE: For 'pathEcho' a source to target path will be created to to hold all errors that occur when a specific path or connection has not be found/setup. Thus, it is advised to set this value greater than one. Since this index does not rollover, only the first rttMonStatisticsAdminNumPaths will be kept.")
rttMonStatisticsAdminNumHops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumHops.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminNumHops.setDescription("When RttMonRttType is 'pathEcho' this is the maximum number of statistics hops to record per path group. This value directly represents the number of hops along a path to a target, thus we can only support 30 hops. For all other RttMonRttTypes this value will be forced to one by the agent. Since this index does not rollover, only the first rttMonStatisticsAdminNumHops will be kept. This object is applicable to pathEcho probes only.")
rttMonStatisticsAdminNumDistBuckets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumDistBuckets.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminNumDistBuckets.setDescription('The maximum number of statistical distribution Buckets to accumulate. Since this index does not rollover, only the first rttMonStatisticsAdminNumDistBuckets will be kept. The last rttMonStatisticsAdminNumDistBucket will contain all entries from its distribution interval start point to infinity. This object is not applicable to http and jitter probes.')
rttMonStatisticsAdminDistInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(20)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminDistInterval.setStatus('current')
if mibBuilder.loadTexts: rttMonStatisticsAdminDistInterval.setDescription('The statistical distribution buckets interval. Distribution Bucket Example: rttMonStatisticsAdminNumDistBuckets = 5 buckets rttMonStatisticsAdminDistInterval = 10 milliseconds | Bucket 1 | Bucket 2 | Bucket 3 | Bucket 4 | Bucket 5 | | 0-9 ms | 10-19 ms | 20-29 ms | 30-39 ms | 40-Inf ms | Odd Example: rttMonStatisticsAdminNumDistBuckets = 1 buckets rttMonStatisticsAdminDistInterval = 10 milliseconds | Bucket 1 | | 0-Inf ms | Thus, this odd example shows that the value of rttMonStatisticsAdminDistInterval does not apply when rttMonStatisticsAdminNumDistBuckets is one. This object is not applicable to http and jitter probes.')
rttMonHistoryAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8), )
if mibBuilder.loadTexts: rttMonHistoryAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring history definitions. The definitions in this table control what and how many entries will be placed into the rttMonHistoryCollectionTable. The history collection table is a rollover table. When the rttMonHistoryAdminNumLives index value exceeds its value defined in this table, the oldest corresponding 'lives' group will be deleted and will be replaced with the new 'lives' group. All other indices will only fill to their maximum size. NOTE: The maximum size of this table is defined to be the product of the rttMonCtrlAdminIndex times rttMonHistoryAdminNumLives times rttMonHistoryAdminNumBuckets times rttMonHistoryAdminNumSamples. NOTE WELL: Each of the 'Num' objects values in this have a special behavior. When one of the objects is set to a value larger than the Rtt application can support the set will succeed, but the resultant value will be set to the applications maximum value. The setting management station must reread this object to verify the actual value. NOTE: this table is not applicable to http and jitter probes")
rttMonHistoryAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1), )
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonHistoryAdminEntry"))
rttMonHistoryAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonHistoryAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryAdminEntry.setDescription('A list of objects that define RTT history collection operations.')
rttMonHistoryAdminNumLives = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminNumLives.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryAdminNumLives.setDescription('The maximum number of history lives to record. A life is defined by the countdown (or transition) to zero by the rttMonCtrlOperRttLife object. A new life is created when the same conceptual RTT control row is restarted via the transition of the rttMonCtrlOperRttLife object and its subsequent countdown. The value of zero will shut off all rttMonHistoryAdminTable data collection.')
rttMonHistoryAdminNumBuckets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminNumBuckets.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryAdminNumBuckets.setDescription("The maximum number of history buckets to record. When the RttMonRttType is 'pathEcho' this value directly represents a path to a target. For all other RttMonRttTypes this value should be set to the number of operations to keep per lifetime. After rttMonHistoryAdminNumBuckets are filled, the and the oldest entries are deleted and the most recent rttMonHistoryAdminNumBuckets buckets are retained.")
rttMonHistoryAdminNumSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminNumSamples.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryAdminNumSamples.setDescription("The maximum number of history samples to record per bucket. When the RttMonRttType is 'pathEcho' this value directly represents the number of hops along a path to a target, thus we can only support 30 hops. For all other RttMonRttTypes this value will be forced to one by the agent.")
rttMonHistoryAdminFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("all", 2), ("overThreshold", 3), ("failures", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminFilter.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryAdminFilter.setDescription('Defines a filter for adding RTT results to the history buffer: none - no history is recorded all - the results of all completion times and failed completions are recorded overThreshold - the results of completion times over rttMonCtrlAdminThreshold are recorded. failures - the results of failed operations (only) are recorded.')
rttMonCtrlOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9), )
if mibBuilder.loadTexts: rttMonCtrlOperTable.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperTable.setDescription('A table of which contains the Operational values for the probe, and the conceptual RTT control row. This table augments the rttMonCtrlAdminTable.')
rttMonCtrlOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1), )
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonCtrlOperEntry"))
rttMonCtrlOperEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonCtrlOperEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperEntry.setDescription('A list of objects that describe the current state of probe, and the conceptual RTT control row.')
rttMonCtrlOperModificationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperModificationTime.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperModificationTime.setDescription('This object is updated whenever an object in the conceptual RTT control row is changed or updated.')
rttMonCtrlOperDiagText = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 51))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperDiagText.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperDiagText.setDescription("A string which can be used as an aid in tracing problems. The content of this field will depend on the type of target (rttMonEchoAdminProtocol). When rttMonEchoAdminProtocol is one of snaLU0EchoAppl, or snaLU2EchoAppl this object contains the name of the Logical Unit (LU) being used for this RTT session (from the HOST's point of view), once the session has been established; this can then be used to correlate this name to the connection information stored in the Mainframe Host. When rttMonEchoAdminProtocol is snaLU62EchoAppl, this object contains the Logical Unit (LU) name being used for this RTT session, once the session has been established. This name can be used by the management application to correlate this objects value to the connection information stored at this SNMP Agent via the APPC or APPN mib. When rttMonEchoAdminProtocol is not one of the previously mentioned values, this value will be null. It is primarily intended that this object contains information which has significance to a human operator.")
rttMonCtrlOperResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperResetTime.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperResetTime.setDescription('This object is set when the rttMonCtrlOperState is set to reset.')
rttMonCtrlOperOctetsInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperOctetsInUse.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperOctetsInUse.setDescription('This object is the number of octets currently in use by this composite conceptual RTT row. A composite conceptual row include the control, statistics, and history conceptual rows combined. (All octets that are addressed via the rttMonCtrlAdminIndex in this mib.)')
rttMonCtrlOperConnectionLostOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 5), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperConnectionLostOccurred.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperConnectionLostOccurred.setDescription("This object will only change its value when the RttMonRttType is 'echo' or 'pathEcho'. This object is set to true when the RTT connection fails to be established or is lost, and set to false when a connection is reestablished. When the RttMonRttType is 'pathEcho', connection loss applies only to the rttMonEchoAdminTargetAddress and not to intermediate hops to the Target. When this value changes and rttMonReactAdminConnectionEnable is true, a reaction will occur. If a trap is sent it is a rttMonConnectionChangeNotification. When this value changes and any one of the rttMonReactTable row has rttMonReactVar object value as 'connectionLoss(8)', a reaction may occur. If a trap is sent it is rttMonNotification with rttMonReactVar value of 'connectionLoss'.")
rttMonCtrlOperTimeoutOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 6), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperTimeoutOccurred.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperTimeoutOccurred.setDescription("This object will change its value for all RttMonRttTypes. This object is set to true when an operation times out, and set to false when an operation completes under rttMonCtrlAdminTimeout. When this value changes, a reaction may occur, as defined by rttMonReactAdminTimeoutEnable. When the RttMonRttType is 'pathEcho', this timeout applies only to the rttMonEchoAdminTargetAddress and not to intermediate hops to the Target. If a trap is sent it is a rttMonTimeoutNotification. When this value changes and any one of the rttMonReactTable row has rttMonReactVar object value as 'timeout(7)', a reaction may occur. If a trap is sent it is rttMonNotification with rttMonReactVar value of 'timeout'.")
rttMonCtrlOperOverThresholdOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 7), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperOverThresholdOccurred.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperOverThresholdOccurred.setDescription("This object will change its value for all RttMonRttTypes. This object is changed by operation completion times over threshold, as defined by rttMonReactAdminThresholdType. When this value changes, a reaction may occur, as defined by rttMonReactAdminThresholdType. If a trap is sent it is a rttMonThresholdNotification. This object is set to true if the operation completion time exceeds the rttMonCtrlAdminThreshold and set to false when an operation completes under rttMonCtrlAdminThreshold. When this value changes, a reaction may occur, as defined by rttMonReactThresholdType. If a trap is sent it is rttMonNotification with rttMonReactVar value of 'rtt'.")
rttMonCtrlOperNumRtts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperNumRtts.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperNumRtts.setDescription("This is the total number of probe operations that have been attempted. This value is incremented for each start of an RTT operation. Thus when rttMonCtrlAdminRttType is set to 'pathEcho' this value will be incremented by one and not for very every hop along the path. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object. This value is not effected by the rollover of a statistics hourly group.")
rttMonCtrlOperRttLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperRttLife.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperRttLife.setDescription("This object is decremented every second, until it reaches zero. When the value of this object is zero RTT operations for this row are suspended. This object will either reach zero by a countdown or it will transition to zero via setting the rttMonCtrlOperState. When this object reaches zero the agent needs to transition the rttMonCtrlOperState to 'inactive'. REMEMBER: The value 2147483647 has a special meaning. When this object has the value 2147483647, this object will not decrement. And thus the life time will never. When the rttMonCtrlOperState object is 'active' and the rttMonReactTriggerOperState object transitions to 'active' this object will not be updated with the current value of rttMonCrtlAdminRttLife object.")
rttMonCtrlOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("reset", 1), ("orderlyStop", 2), ("immediateStop", 3), ("pending", 4), ("inactive", 5), ("active", 6), ("restart", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonCtrlOperState.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperState.setDescription("The RttMonOperStatus object is used to manage the 'state' of the probe that is implementing conceptual RTT control row. This status object has six defined values: reset(1) - reset this entry, transition to 'pending' orderlyStop(2) - shutdown this entry at the end of the next RTT operation attempt, transition to 'inactive' immediateStop(3) - shutdown this entry immediately (if possible), transition to 'inactive' pending(4) - this value is not settable and this conceptual RTT control row is waiting for further control either via the rttMonScheduleAdminTable or the rttMonReactAdminTable/ rttMonReactTriggerAdminTable; This object can transition to this value via two mechanisms, first by reseting this object, and second by creating a conceptual Rtt control row with the rttMonScheduleAdminRttStartTime object with the its special value inactive(5) - this value is not settable and this conceptual RTT control row is waiting for further control via the rttMonScheduleAdminTable; This object can transition to this value via two mechanisms, first by setting this object to 'orderlyStop' or 'immediateStop', second by the rttMonCtrlOperRttLife object reaching zero active(6) - this value is not settable and this conceptual RTT control row is currently active restart(7) - this value is only settable when the state is active. It clears the data of this entry and remain on active state. The probes action when this object is set to 'reset': - all rows in rttMonStatsCaptureTable that relate to this conceptual RTT control row are destroyed and the indices are set to 1 - if rttMonStatisticsAdminNumHourGroups is not zero, a single new rttMonStatsCaptureTable row is created - all rows in rttMonHistoryCaptureTable that relate to this RTT definition are destroyed and the indices are set to 1 - implied history used for timeout or threshold notification (see rttMonReactAdminThresholdType or rttMonReactThresholdType) is purged - rttMonCtrlOperRttLife is set to rttMonScheduleAdminRttLife - rttMonCtrlOperNumRtts is set to zero - rttMonCtrlOperTimeoutOccurred, rttMonCtrlOperOverThresholdOccurred, and rttMonCtrlOperConnectionLostOccurred are set to false; if this causes a change in the value of either of these objects, resolution notifications will not occur - the next RTT operation is controlled by the objects in the rttMonScheduleAdminTable or the rttMonReactAdminTable/rttMonReactTriggerAdminTable - if the rttMonReactTriggerOperState is 'active', it will transition to 'pending' - all rttMonReactTriggerAdminEntries pointing to this conceptual entry with their rttMonReactTriggerOperState object 'active', will transition their OperState to 'pending' - all open connections must be maintained This can be used to synchronize various RTT definitions, so that the RTT requests occur simultaneously, or as simultaneously as possible. The probes action when this object transitions to 'inactive' (via setting this object to 'orderlyStop' or 'immediateStop' or by rttMonCtrlOperRttLife reaching zero): - all statistics and history collection information table entries will be closed and kept - implied history used for timeout or threshold notification (see rttMonReactAdminThresholdType or rttMonReactThresholdType) is purged - rttMonCtrlOperTimeoutOccurred, rttMonCtrlOperOverThresholdOccurred, and rttMonCtrlOperConnectionLostOccurred are set to false; if this causes a change in the value of either of these objects, resolution notifications will not occur. - the next RTT request is controlled by the objects in the rttMonScheduleAdminTable - if the rttMonReactTriggerOperState is 'active', it will transition to 'pending' (this denotes that the Trigger will be ready the next time this object goes active) - all rttMonReactTriggerAdminEntries pointing to this conceptual entry with their rttMonReactTriggerOperState object 'active', will transition their OperState to 'pending' - all open connections are to be closed and cleanup. rttMonCtrlOperState STATE +-------------------------------------------+ | A | B | C | ACTION | 'pending' | 'inactive' | 'active' | +----------------+--------------+--------------+-------------+ | OperState set | noError |inconsistent- | noError | | to 'reset' | | Value | | | | -> A | | -> A | +----------------+--------------+--------------+-------------+ | OperState set | noError | noError | noError | |to 'orderlyStop'| -> B | -> B | -> B | | or to | | | | |'immediateStop' | | | | +----------------+--------------+--------------+-------------+ | Event causes | -> C | -> B | -> C | | Trigger State | | | see (3) | | to transition | | | | | to 'active' | | | | +----------------+--------------+--------------+-------------+ | AdminStatus | -> C | -> C | see (1) | | transitions to | | | | | 'active' & | | | | | RttStartTime is| | | | | special value | | | | | of one. | | | | +----------------+--------------+--------------+-------------+ | AdminStatus | -> A | -> A | see (1) | | transitions to | | | | | 'active' & | | | | | RttStartTime is| | | | | special value | | | | | of less than | | | | | current time, | | | | | excluding one. | | | | +----------------+--------------+--------------+-------------+ | AdminStatus | -> A | -> B | see (2) | | transitions to | | | | | 'notInService' | | | | +----------------+--------------+--------------+-------------+ | AdminStatus | -> B | -> B | -> B | | transitions to | | | | | 'delete' | | | | +----------------+--------------+--------------+-------------+ | AdminStatus is | -> C | -> C | -> C | | 'active' & the | | | see (3) | | RttStartTime | | | | | arrives | | | | +----------------+--------------+--------------+-------------+ | RowAgeout | -> B | -> B | -> B | | expires | | | | +----------------+--------------+--------------+-------------+ | OperRttLife | N/A | N/A | -> B | | counts down to | | | | | zero | | | | +----------------+--------------+--------------+-------------+ (1) - rttMonCtrlOperState must have transitioned to 'inactive' or 'pending' before the rttMonCtrlAdminStatus can transition to 'active'. See (2). (2) - rttMonCtrlAdminStatus cannot transition to 'notInService' unless rttMonCtrlOperState has been previously forced to 'inactive' or 'pending'. (3) - when this happens the rttMonCtrlOperRttLife will not be updated with the rttMonCtrlAdminRttLife. NOTE: In order for all objects in a PDU to be set at the same time, this object can not be part of a multi-bound PDU.")
rttMonCtrlOperVerifyErrorOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 11), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperVerifyErrorOccurred.setStatus('current')
if mibBuilder.loadTexts: rttMonCtrlOperVerifyErrorOccurred.setDescription('This object is true if rttMonCtrlAdminVerifyData is set to true and data corruption occurs.')
rttMonLatestRttOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10), )
if mibBuilder.loadTexts: rttMonLatestRttOperTable.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperTable.setDescription("A table of which contains the status of latest RTT operation. When the RttMonRttType is 'pathEcho', operations performed to the hops along the path will be recorded in this table. This table augments the RTT definition table, rttMonCtrlAdminTable.")
rttMonLatestRttOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1), )
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonLatestRttOperEntry"))
rttMonLatestRttOperEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonLatestRttOperEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperEntry.setDescription('A list of objects that record the latest RTT operation.')
rttMonLatestRttOperCompletionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 1), Gauge32()).setUnits('milliseconds/microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperCompletionTime.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperCompletionTime.setDescription("The completion time of the latest RTT operation successfully completed. The unit of this object will be microsecond when rttMonCtrlAdminRttType is set to 'jitter' and rttMonEchoAdminPrecision is set to 'microsecond'. Otherwise, the unit of this object will be millisecond.")
rttMonLatestRttOperSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 2), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperSense.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperSense.setDescription('A sense code for the completion status of the latest RTT operation.')
rttMonLatestRttOperApplSpecificSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperApplSpecificSense.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperApplSpecificSense.setDescription("An application specific sense code for the completion status of the latest RTT operation. This object will only be valid when the rttMonLatestRttOperSense object is set to 'applicationSpecific'. Otherwise, this object's value is not valid.")
rttMonLatestRttOperSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperSenseDescription.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperSenseDescription.setDescription("A sense description for the completion status of the latest RTT operation when the rttMonLatestRttOperSense object is set to 'applicationSpecific'.")
rttMonLatestRttOperTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperTime.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperTime.setDescription('The value of the agent system time at the time of the latest RTT operation.')
rttMonLatestRttOperAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 6), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestRttOperAddress.setDescription("When the RttMonRttType is 'echo', 'pathEcho', 'udpEcho', 'tcpConnect', 'dns' and 'dlsw' this is a string which specifies the address of the target for this RTT operation. When the RttMonRttType is not one of these types this object will be null. This address will be the address of the hop along the path to the rttMonEchoAdminTargetAddress address, including rttMonEchoAdminTargetAddress address, or just the rttMonEchoAdminTargetAddress address, when the path information is not collected. This behavior is defined by the rttMonCtrlAdminRttType object. The interpretation of this string depends on the type of RTT operation selected, as specified by the rttMonEchoAdminProtocol object. See rttMonEchoAdminTargetAddress for a complete description.")
rttMonLatestHTTPOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1), )
if mibBuilder.loadTexts: rttMonLatestHTTPOperTable.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperTable.setDescription('A table which contains the status of latest HTTP RTT operation.')
rttMonLatestHTTPOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonLatestHTTPOperEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperEntry.setDescription('A list of objects that record the latest HTTP RTT operation. This entry is created automatically after the rttMonCtrlAdminEntry is created. Also the entry is automatically deleted when rttMonCtrlAdminEntry is deleted.')
rttMonLatestHTTPOperRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperRTT.setDescription('Round Trip Time taken to perform HTTP operation. This value is the sum of DNSRTT, TCPConnectRTT and TransactionRTT.')
rttMonLatestHTTPOperDNSRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperDNSRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperDNSRTT.setDescription('Round Trip Time taken to perform DNS query within the HTTP operation. If an IP Address is specified in the URL, then DNSRTT is 0.')
rttMonLatestHTTPOperTCPConnectRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperTCPConnectRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperTCPConnectRTT.setDescription('Round Trip Time taken to connect to the HTTP server.')
rttMonLatestHTTPOperTransactionRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperTransactionRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperTransactionRTT.setDescription('Round Trip Time taken to download the object specified by the URL.')
rttMonLatestHTTPOperMessageBodyOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperMessageBodyOctets.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperMessageBodyOctets.setDescription('The size of the message body received as a response to the HTTP request.')
rttMonLatestHTTPOperSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 6), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperSense.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPOperSense.setDescription('An application specific sense code for the completion status of the latest RTT operation.')
rttMonLatestHTTPErrorSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPErrorSenseDescription.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestHTTPErrorSenseDescription.setDescription('An sense description for the completion status of the latest RTT operation.')
rttMonLatestJitterOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2), )
if mibBuilder.loadTexts: rttMonLatestJitterOperTable.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperTable.setDescription('A table which contains the status of latest Jitter operation.')
rttMonLatestJitterOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonLatestJitterOperEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperEntry.setDescription('A list of objects that record the latest Jitter operation.')
rttMonLatestJitterOperNumOfRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfRTT.setDescription("The number of RTT's that were successfully measured.")
rttMonLatestJitterOperRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum.setDescription("The sum of Jitter RTT's that are successfully measured (low order 32 bits). The high order 32 bits are stored in rttMonLatestJitterOperRTTSumHigh.")
rttMonLatestJitterOperRTTSum2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum2.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum2.setDescription("The sum of squares of RTT's that are successfully measured (low order 32 bits). The high order 32 bits are stored in rttMonLatestJitterOperRTTSum2High.")
rttMonLatestJitterOperRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTMin.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTMin.setDescription("The minimum of RTT's that were successfully measured.")
rttMonLatestJitterOperRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTMax.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTMax.setDescription("The maximum of RTT's that were successfully measured.")
rttMonLatestJitterOperMinOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfPositivesSD.setDescription('The minimum of all positive jitter values from packets sent from source to destination.')
rttMonLatestJitterOperMaxOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfPositivesSD.setDescription('The maximum of all positive jitter values from packets sent from source to destination.')
rttMonLatestJitterOperNumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfPositivesSD.setDescription('The sum of all positive jitter values from packets sent from source to destination.')
rttMonLatestJitterOperSumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfPositivesSD.setDescription("The sum of RTT's of all positive jitter values from packets sent from source to destination.")
rttMonLatestJitterOperSum2PositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2PositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2PositivesSD.setDescription("The sum of square of RTT's of all positive jitter values from packets sent from source to destination.")
rttMonLatestJitterOperMinOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfNegativesSD.setDescription('The minimum of absolute values of all negative jitter values from packets sent from source to destination.')
rttMonLatestJitterOperMaxOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfNegativesSD.setDescription('The maximum of absolute values of all negative jitter values from packets sent from source to destination.')
rttMonLatestJitterOperNumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfNegativesSD.setDescription('The sum of number of all negative jitter values from packets sent from source to destination.')
rttMonLatestJitterOperSumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfNegativesSD.setDescription('The sum of all negative jitter values from packets sent from source to destination.')
rttMonLatestJitterOperSum2NegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2NegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2NegativesSD.setDescription("The sum of square of RTT's of all negative jitter values from packets sent from source to destination.")
rttMonLatestJitterOperMinOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfPositivesDS.setDescription('The minimum of all positive jitter values from packets sent from destination to source.')
rttMonLatestJitterOperMaxOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfPositivesDS.setDescription('The maximum of all positive jitter values from packets sent from destination to source.')
rttMonLatestJitterOperNumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfPositivesDS.setDescription('The sum of number of all positive jitter values from packets sent from destination to source.')
rttMonLatestJitterOperSumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfPositivesDS.setDescription("The sum of RTT's of all positive jitter values from packets sent from destination to source.")
rttMonLatestJitterOperSum2PositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2PositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2PositivesDS.setDescription("The sum of squares of RTT's of all positive jitter values from packets sent from destination to source.")
rttMonLatestJitterOperMinOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfNegativesDS.setDescription('The minimum of all negative jitter values from packets sent from destination to source.')
rttMonLatestJitterOperMaxOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfNegativesDS.setDescription('The maximum of all negative jitter values from packets sent from destination to source.')
rttMonLatestJitterOperNumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfNegativesDS.setDescription('The sum of number of all negative jitter values from packets sent from destination to source.')
rttMonLatestJitterOperSumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfNegativesDS.setDescription("The sum of RTT's of all negative jitter values from packets sent from destination to source.")
rttMonLatestJitterOperSum2NegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2NegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2NegativesDS.setDescription("The sum of squares of RTT's of all negative jitter values from packets sent from destination to source.")
rttMonLatestJitterOperPacketLossSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLossSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLossSD.setDescription('The number of packets lost when sent from source to destination.')
rttMonLatestJitterOperPacketLossDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLossDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLossDS.setDescription('The number of packets lost when sent from destination to source.')
rttMonLatestJitterOperPacketOutOfSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketOutOfSequence.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketOutOfSequence.setDescription('The number of packets arrived out of sequence.')
rttMonLatestJitterOperPacketMIA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketMIA.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketMIA.setDescription('The number of packets that are lost for which we cannot determine the direction.')
rttMonLatestJitterOperPacketLateArrival = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLateArrival.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLateArrival.setDescription('The number of packets that arrived after the timeout.')
rttMonLatestJitterOperSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 31), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSense.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperSense.setDescription('An application specific sense code for the completion status of the latest Jitter RTT operation.')
rttMonLatestJitterErrorSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 32), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterErrorSenseDescription.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterErrorSenseDescription.setDescription('An sense description for the completion status of the latest Jitter RTT operation.')
rttMonLatestJitterOperOWSumSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumSD.setDescription('The sum of one way latency from source to destination (low order 32 bits). The high order 32 bits are stored in rttMonLatestJitterOperOWSumSDHigh.')
rttMonLatestJitterOperOWSum2SD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2SD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2SD.setDescription('The sum of squares of one way latency from source to destination (low order 32 bits). The high order 32 bits are stored in rttMonLatestJitterOperOWSum2SDHigh.')
rttMonLatestJitterOperOWMinSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMinSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMinSD.setDescription('The minimum of all one way latency from source to destination.')
rttMonLatestJitterOperOWMaxSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMaxSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMaxSD.setDescription('The maximum of all one way latency from source to destination.')
rttMonLatestJitterOperOWSumDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumDS.setDescription('The sum of one way latency from destination to source (low order 32 bits). The high order 32 bits are stored in rttMonLatestJitterOperOWSumDSHigh.')
rttMonLatestJitterOperOWSum2DS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2DS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2DS.setDescription('The sum of squares of one way latency from destination to source (low order 32 bits). The high order 32 bits are stored in rttMonLatestJitterOperOWSum2DSHigh.')
rttMonLatestJitterOperOWMinDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMinDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMinDS.setDescription('The minimum of all one way latency from destination to source.')
rttMonLatestJitterOperOWMaxDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 40), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMaxDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMaxDS.setDescription('The maximum of all one way latency from destination to source.')
rttMonLatestJitterOperNumOfOW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 41), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfOW.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfOW.setDescription('The number of successful one way latency measurements.')
rttMonLatestJitterOperMOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 42), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(100, 500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMOS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperMOS.setDescription('The MOS value for the latest jitter operation in hundreds. This value will be 0 if - rttMonEchoAdminCodecType of the operation is notApplicable - the operation is not started - the operation is started but failed This value will be 1 for packet loss of 10% or more.')
rttMonLatestJitterOperICPIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 43), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperICPIF.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperICPIF.setDescription('Represents ICPIF value for the latest jitter operation. This value will be 93 for packet loss of 10% or more.')
rttMonLatestJitterOperIAJOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 44), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJOut.setReference('Refer to the following documents for the definition: RFC 1889')
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJOut.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJOut.setDescription('Interarrival Jitter (RC1889) at responder.')
rttMonLatestJitterOperIAJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 45), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJIn.setReference('Refer to the following documents for the definition: RFC 1889')
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJIn.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJIn.setDescription('Interarrival Jitter (RFC1889) at source.')
rttMonLatestJitterOperAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 46), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgJitter.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgJitter.setDescription('The average of positive and negative jitter values in SD and DS direction for latest operation.')
rttMonLatestJitterOperAvgSDJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 47), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgSDJ.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgSDJ.setDescription('The average of positive and negative jitter values from source to destination for latest operation.')
rttMonLatestJitterOperAvgDSJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 48), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgDSJ.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgDSJ.setDescription('The average of positive and negative jitter values from destination to source for latest operation.')
rttMonLatestJitterOperOWAvgSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 49), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWAvgSD.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWAvgSD.setDescription('The average latency value from source to destination.')
rttMonLatestJitterOperOWAvgDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 50), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWAvgDS.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWAvgDS.setDescription('The average latency value from destination to source.')
rttMonLatestJitterOperNTPState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("outOfSync", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNTPState.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNTPState.setDescription('A value of sync(1) means sender and responder was in sync with NTP. The NTP sync means the total of NTP offset on sender and responder is within configured tolerance level.')
rttMonLatestJitterOperUnSyncRTs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperUnSyncRTs.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperUnSyncRTs.setDescription('The number of RTT operations that have completed with sender and responder out of sync with NTP. The NTP sync means the total of NTP offset on sender and responder is within configured tolerance level.')
rttMonLatestJitterOperRTTSumHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSumHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSumHigh.setDescription("The sum of Jitter RTT's that are successfully measured. (high order 32 bits). The low order 32 bits are stored in rttMonLatestJitterOperRTTSum.")
rttMonLatestJitterOperRTTSum2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum2High.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum2High.setDescription("The sum of squares of RTT's that are successfully measured (high order 32 bits). The low order 32 bits are stored in rttMonLatestJitterOperRTTSum2.")
rttMonLatestJitterOperOWSumSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumSDHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumSDHigh.setDescription('The sum of one way latency from source to destination (high order 32 bits). The low order 32 bits are stored in rttMonLatestJitterOperOWSumSD.')
rttMonLatestJitterOperOWSum2SDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 56), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2SDHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2SDHigh.setDescription('The sum of squares of one way latency from source to destination (high order 32 bits). The low order 32 bits are stored in rttMonLatestJitterOperOWSum2SD.')
rttMonLatestJitterOperOWSumDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 57), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumDSHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumDSHigh.setDescription('The sum of one way latency from destination to source (high order 32 bits). The low order 32 bits are stored in rttMonLatestJitterOperOWSumDS.')
rttMonLatestJitterOperOWSum2DSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2DSHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2DSHigh.setDescription('The sum of squares of one way latency from destination to source (high order 32 bits). The low order 32 bits are stored in rttMonLatestJitterOperOWSum2DS.')
rttMonLatestJitterOperNumOverThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 59), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOverThresh.setStatus('current')
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOverThresh.setDescription('This object indicates the number of RTTs that were over the threshold value.')
rttMonReactTriggerAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11), )
if mibBuilder.loadTexts: rttMonReactTriggerAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerAdminTable.setDescription("A table of which contains the list of conceptual RTT control rows that will start to collect data when a reaction condition is violated and when rttMonReactAdminActionType is set to one of the following: - triggerOnly - trapAndTrigger - nmvtAndTrigger - trapNmvtAndTrigger or when a reaction condition is violated and when any of the row in rttMonReactTable has rttMonReactActionType as one of the following: - triggerOnly - trapAndTrigger The goal of this table is to define one or more additional conceptual RTT control rows that will become active and start to collect additional history and statistics (depending on the rows configuration values), when a problem has been detected. If the conceptual RTT control row is undefined, and a trigger occurs, no action will take place. If the conceptual RTT control row is scheduled to start at a later time, triggering that row will have no effect. If the conceptual RTT control row is currently active, triggering that row will have no effect on that row, but the rttMonReactTriggerOperState object will transition to 'active'. An entry in this table can only be triggered when it is not currently in a triggered state. The object rttMonReactTriggerOperState will reflect the state of each entry in this table.")
rttMonReactTriggerAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonReactTriggerAdminRttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonReactTriggerAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerAdminEntry.setDescription('A list of objects that will be triggered when a reaction condition is violated.')
rttMonReactTriggerAdminRttMonCtrlAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonReactTriggerAdminRttMonCtrlAdminIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerAdminRttMonCtrlAdminIndex.setDescription('This object points to a single conceptual Rtt control row. If this row does not exist and this value is triggered no action will result. The conceptual Rtt control row will be triggered for the rttMonCtrlOperRttLife length. If this conceptual Rtt control row is already active, rttMonCtrlOperRttLife will not be updated, and its life will continue as previously defined.')
rttMonReactTriggerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactTriggerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerAdminStatus.setDescription('This object is used to create Trigger entries.')
rttMonReactTriggerOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 12), )
if mibBuilder.loadTexts: rttMonReactTriggerOperTable.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerOperTable.setDescription('A table of which contains the operational state of each entry in the rttMonReactTriggerAdminTable. This table augments the RTT trigger definition table, rttMonReactTriggerAdminTable.')
rttMonReactTriggerOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 12, 1), )
rttMonReactTriggerAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonReactTriggerOperEntry"))
rttMonReactTriggerOperEntry.setIndexNames(*rttMonReactTriggerAdminEntry.getIndexNames())
if mibBuilder.loadTexts: rttMonReactTriggerOperEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerOperEntry.setDescription('A list of state objects for the rttMonReactTriggerAdminTable.')
rttMonReactTriggerOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("pending", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonReactTriggerOperState.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTriggerOperState.setDescription('This object takes on the value active when its associated entry in the rttMonReactTriggerAdminTable has been triggered. When the associated entry in the rttMonReactTriggerAdminTable is not under a trigger state, this object will be pending. When this object is in the active state this entry can not be retriggered.')
rttMonEchoPathAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13), )
if mibBuilder.loadTexts: rttMonEchoPathAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoPathAdminTable.setDescription('A table to store the hop addresses in a Loose Source Routing path. Response times are computed along the specified path using ping. This maximum table size is limited by the size of the maximum number of hop addresses that can fit in an IP header, which is 8. The object rttMonEchoPathAdminEntry will reflect this tables maximum number of entries. This table is coupled with rttMonCtrlAdminStatus.')
rttMonEchoPathAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonEchoPathAdminHopIndex"))
if mibBuilder.loadTexts: rttMonEchoPathAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoPathAdminEntry.setDescription("A list of objects that define intermediate hop's IP Address. This entry can be added only if the rttMonCtrlAdminRttType is 'echo'. The entry gets deleted when the corresponding RTR entry, which has an index of rttMonCtrlAdminIndex, is deleted.")
rttMonEchoPathAdminHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: rttMonEchoPathAdminHopIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoPathAdminHopIndex.setDescription('Uniquely identifies a row in the rttMonEchoPathAdminTable. This number represents the hop address number in a specific ping path. All the indicies should start from 1 and must be contiguous ie., entries should be (say rttMonCtrlAdminIndex = 1) 1.1, 1.2, 1.3, they cannot be 1.1, 1.2, 1.4')
rttMonEchoPathAdminHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13, 1, 2), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoPathAdminHopAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonEchoPathAdminHopAddress.setDescription("A string which specifies the address of an intermediate hop's IP Address for a RTT 'echo' operation")
rttMonGrpScheduleAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14), )
if mibBuilder.loadTexts: rttMonGrpScheduleAdminTable.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminTable.setDescription('A table of Round Trip Time (RTT) monitoring group scheduling specific definitions. This table is used to create a conceptual group scheduling control row. The entries in this control row contain objects used to define group schedule configuration parameters. The objects of this table will be used to schedule a group of probes identified by the conceptual rows of the rttMonCtrlAdminTable.')
rttMonGrpScheduleAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminIndex"))
if mibBuilder.loadTexts: rttMonGrpScheduleAdminEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminEntry.setDescription('A list of objects that define a conceptual group scheduling control row.')
rttMonGrpScheduleAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonGrpScheduleAdminIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminIndex.setDescription("Uniquely identifies a row in the rttMonGrpScheduleAdminTable. This is a pseudo-random number selected by the management station when creating a row via the rttMonGrpScheduleAdminStatus object. If the pseudo-random number is already in use an 'inconsistentValue' return code will be returned when set operation is attempted.")
rttMonGrpScheduleAdminProbes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 200))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminProbes.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminProbes.setDescription("A string which holds the different probes which are to be group scheduled. The probes can be specified in the following forms. (a) Individual ID's with comma separated as 23,45,34. (b) Range form including hyphens with multiple ranges being separated by a comma as 1-10,12-34. (c) Mix of the above two forms as 1,2,4-10,12,15,19-25. Any whitespace in the string is considered an error. Duplicates and overlapping ranges as an example 1,2,3,2-10 are considered fine. For a single range like 1-20 the upper value (in this example 20) must be greater than lower value (1), otherwise it's treated as an error. The agent will not normalize the list e.g., it will not change 1,2,1-10 or even 1,2,3,4,5,6.. to 1-10.")
rttMonGrpScheduleAdminPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminPeriod.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminPeriod.setDescription('Specifies the time duration over which all the probes have to be scheduled.')
rttMonGrpScheduleAdminFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFrequency.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFrequency.setDescription('Specifies the duration between initiating each RTT operation for all the probes specified in the group. The value of this object is only effective when both rttMonGrpScheduleAdminFreqMax and rttMonGrpScheduleAdminFreqMin have zero values.')
rttMonGrpScheduleAdminLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminLife.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminLife.setDescription("This object specifies the life of all the probes included in the object rttMonGrpScheduleAdminProbes, that are getting group scheduled. This value will be placed into rttMonScheduleAdminRttLife object for each of the probes listed in rttMonGrpScheduleAdminProbes when this conceptual control row becomes 'active'. The value 2147483647 has a special meaning. When this object is set to 2147483647, the rttMonCtrlOperRttLife object for all the probes listed in rttMonGrpScheduleAdminProbes, will not decrement. And thus the life time of the probes will never end.")
rttMonGrpScheduleAdminAgeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600)).clone(3600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminAgeout.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminAgeout.setDescription("This object specifies the ageout value of all the probes included in the object rttMonGrpScheduleAdminProbes, that are getting group scheduled. This value will be placed into rttMonScheduleAdminConceptRowAgeout object for each of the probes listed in rttMonGrpScheduleAdminProbes when this conceptual control row becomes 'active'. When this value is set to zero, the probes listed in rttMonGrpScheduleAdminProbes, will never ageout.")
rttMonGrpScheduleAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStatus.setDescription("The status of the conceptual RTT group schedule control row. In order for this object to become active, the following row objects must be defined: - rttMonGrpScheduleAdminProbes - rttMonGrpScheduleAdminPeriod All other objects can assume default values. The conceptual RTT group schedule control row objects cannot be modified once this conceptual RTT group schedule control row has been created. Once this object is in 'active' status, it cannot be set to 'notInService'. When this object moves to 'active' state it will schedule the probes of the rttMonCtrlAdminTable which had been created using 'createAndWait'. This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy' it will stop all the probes of the rttMonCtrlAdminTable, which had been group scheduled by it earlier, before destroying the RTT group schedule control row.")
rttMonGrpScheduleAdminFreqMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFreqMax.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFreqMax.setDescription('Specifies the max duration between initiating each RTT operation for all the probes specified in the group. If this is 0 and rttMonGrpScheduleAdminFreqMin is also 0 then rttMonGrpScheduleAdminFrequency becomes the fixed frequency.')
rttMonGrpScheduleAdminFreqMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFreqMin.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFreqMin.setDescription('Specifies the min duration between initiating each RTT operation for all the probes specified in the group. The value of this object cannot be greater than the value of rttMonGrpScheduleAdminFreqMax. If this is 0 and rttMonGrpScheduleAdminFreqMax is 0 then rttMonGrpScheduleAdminFrequency becomes the fixed frequency.')
rttMonGrpScheduleAdminStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartTime.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartTime.setDescription('This is the time in seconds after which the member probes of this group specified in rttMonGrpScheduleAdminProbes will transition to active state If rttMonScheduleAdminStartType is specified with this object then rttMonScheduleAdminRttStartTime is ignored and group start time is configured based on rttMonScheduleAdminStartType.')
rttMonGrpScheduleAdminAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminAdd.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminAdd.setDescription('Addition of members to an existing group will be allowed if this object is set to TRUE (1). The members, IDs of which are mentioned in rttMonGrpScheduleAdminProbes object are added to the existing group')
rttMonGrpScheduleAdminDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 12), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminDelete.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminDelete.setDescription('Removal of members from an existing group will be allowed if this object is set to TRUE (1). The members, IDs of which are mentioned in rttMonGrpScheduleAdminProbes object are removed from the existing group')
rttMonGrpScheduleAdminReset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 13), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminReset.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminReset.setDescription('When this is set to true then all members of this group will be stopped and rescheduled using the previously set values of this group.')
rttMonGrpScheduleAdminStartType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 14), RttMonScheduleStartType().clone('pending')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartType.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartType.setDescription('This object specifies the start-time option to be used for scheduling the start time of the group with probes included in the object rttMonGrpScheduleAdminProbes. The following list defines the start-time options that can be configured for the group schedule: pending(1) pending state. now(2) schedule to immediately start the group with defined probes. random(3) schedule start time of group at random time over a range. after(4) schedule start time of group after a certain amount of time from now. specific(5) schedule start time of group at a given specific time interval.')
rttMonGrpScheduleAdminStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartDelay.setStatus('current')
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartDelay.setDescription('This object specifies the start time delay range in milliseconds. The value of this object is only effective with rttMonScheduleAdminStartType value. For rttMonGrpScheduleAdminStartType with random option, a random time is generated with in provided start delay range and added to current time to generate the random start time of the group with defined probes.')
rttMplsVpnMonCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15), )
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTable.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTable.setDescription("A table of Auto SAA L3 MPLS VPN definitions. The Auto SAA L3 MPLS VPN administration control is in multiple tables. This first table, is used to create a conceptual Auto SAA L3 MPLS VPN control row. The following tables contain objects which used in type specific configurations, scheduling and reaction configurations. All of these tables will create the same conceptual control row as this table using this table's index as their own index. In order to a row in this table to become active the following objects must be defined. rttMplsVpnMonCtrlRttType, rttMplsVpnMonCtrlVrfName and rttMplsVpnMonSchedulePeriod.")
rttMplsVpnMonCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlIndex"))
if mibBuilder.loadTexts: rttMplsVpnMonCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlEntry.setDescription('A base list of objects that define a conceptual Auto SAA L3 MPLS VPN control row.')
rttMplsVpnMonCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMplsVpnMonCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlIndex.setDescription("Uniquely identifies a row in the rttMplsVpnMonCtrlTable. This is a pseudo-random number selected by the management station when creating a row via the rttMplsVpnMonCtrlStatus object. If the pseudo-random number is already in use an 'inconsistentValue' return code will be returned when set operation is attempted.")
rttMplsVpnMonCtrlRttType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 2), RttMplsVpnMonRttType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlRttType.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlRttType.setDescription('The type of RTT operation to be performed for Auto SAA L3 MPLS VPN. This value must be set in the same PDU of rttMplsVpnMonCtrlStatus. This value must be set before setting any other parameter configuration of an Auto SAA L3 MPLS VPN.')
rttMplsVpnMonCtrlVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlVrfName.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlVrfName.setDescription("This field is used to specify the VPN name for which the Auto SAA L3 MPLS VPN RTT operation will be used. This value must be set in the same PDU of rttMplsVpnMonCtrlStatus. The Auto SAA L3 MPLS VPN will find the PEs participating in this VPN and configure RTT operation corresponding to value specified in rttMplsVpnMonCtrlRttType. If the VPN corresponds to the value configured for this object doesn't exist 'inconsistentValue' error will be returned. The value 'saa-vrf-all' has a special meaning. When this object is set to 'saa-vrf-all', all the VPNs in the PE will be discovered and Auto SAA L3 MPLS VPN will configure RTT operations corresponding to all these PEs with the value specified in rttMplsVpnMonCtrlRttType as type for those operations. So, the user should avoid using this string for a particular VPN name when using this feature in order to avoid ambiguity.")
rttMplsVpnMonCtrlTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTag.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTag.setDescription('A string which is used by a managing application to identify the RTT target. This string will be configured as rttMonCtrlAdminTag for all the operations configured by this Auto SAA L3 MPLS VPN. The usage of this value in Auto SAA L3 MPLS VPN is same as rttMonCtrlAdminTag in RTT operation.')
rttMplsVpnMonCtrlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlThreshold.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlThreshold.setDescription('This object defines an administrative threshold limit. This value will be configured as rttMonCtrlAdminThreshold for all the operations that will be configured by the current Auto SAA L3 MPLS VPN. The usage of this value in Auto SAA L3 MPLS VPN is same as rttMonCtrlAdminThreshold.')
rttMplsVpnMonCtrlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTimeout.setDescription('Specifies the duration to wait for a RTT operation configured automatically by the Auto SAA L3 MPLS VPN to complete. The value of this object cannot be set to a value which would specify a duration exceeding rttMplsVpnMonScheduleFrequency. The usage of this value in Auto SAA L3 MPLS VPN is similar to rttMonCtrlAdminTimeout.')
rttMplsVpnMonCtrlScanInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 70560)).clone(240)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlScanInterval.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlScanInterval.setDescription('Specifies the frequency at which the automatic PE addition should take place if there is any for an Auto SAA L3 MPLS VPN. New RTT operations corresponding to the new PEs discovered will be created and scheduled. The default value for this object is 4 hours. The maximum value supported is 49 days.')
rttMplsVpnMonCtrlDelScanFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlDelScanFactor.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlDelScanFactor.setDescription("Specifies the frequency at which the automatic PE deletion should take place. This object specifies the number of times of rttMonMplslmCtrlScanInterval (rttMplsVpnMonCtrlDelScanFactor * rttMplsVpnMonCtrlScanInterval) to wait before removing the PEs. This object doesn't directly specify the explicit value to wait before removing the PEs that were down. If this object set 0 the entries will never removed.")
rttMplsVpnMonCtrlEXP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlEXP.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlEXP.setDescription('This object represents the EXP value that needs to be put as precedence bit of an IP header.')
rttMplsVpnMonCtrlRequestSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(1)).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlRequestSize.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlRequestSize.setDescription('This object represents the native payload size that needs to be put on the packet. This value will be configured as rttMonEchoAdminPktDataRequestSize for all the RTT operations configured by the current Auto SAA L3 MPLS VPN. The minimum request size for jitter probe is 16. The maximum for jitter probe is 1500. The default request size is 32 for jitter probe. For echo and pathEcho default request size is 28. The minimum request size for echo and pathEcho is 28 bytes.')
rttMplsVpnMonCtrlVerifyData = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlVerifyData.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlVerifyData.setDescription('When set to true, the resulting data in each RTT operation created by the current Auto SAA L3 MPLS VPN is compared with the expected data. This includes checking header information (if possible) and exact packet size. Any mismatch will be recorded in the rttMonStatsCollectVerifyErrors object of each RTT operation created by the current Auto SAA L3 MPLS VPN.')
rttMplsVpnMonCtrlStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 12), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlStorageType.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlStorageType.setDescription("The storage type of this conceptual row. When set to 'nonVolatile', this entry will be shown in 'show running' command and can be saved into Non-volatile memory. By Default the entry will not be saved into Non-volatile memory. This object can be set to either 'volatile' or 'nonVolatile'. Other values are not applicable for this conceptual row and are not supported.")
rttMplsVpnMonCtrlProbeList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlProbeList.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlProbeList.setDescription("This object holds the list of probes ID's that are created by the Auto SAA L3 MPLS VPN. The probes will be specified in the following form. (a) Individual ID's with comma separated as 1,5,3. (b) Range form including hyphens with multiple ranges being separated by comma as 1-10,12-34. (c) Mix of the above two forms as 1,2,4-10,12,15,19-25.")
rttMplsVpnMonCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlStatus.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlStatus.setDescription("The status of the conceptual Auto SAA L3 MPLS VPN control row. In order for this object to become active rttMplsVpnMonCtrlRttType, rttMplsVpnMonCtrlVrfName and rttMplsVpnMonSchedulePeriod objects must be defined. All other objects can assume default values. If the object is set to 'createAndGo' rttMplsVpnMonCtrlRttType, rttMplsVpnMonCtrlVrfName and rttMplsVpnMonSchedulePeriod needs to be set along with rttMplsVpnMonCtrlStatus. If the object is set to 'createAndWait' rttMplsVpnMonCtrlRttType and rttMplsVpnMonCtrlVrfName needs to be set along with rttMplsVpnMonCtrlStatus. rttMplsVpnMonSchedulePeriod needs to be specified before setting rttMplsVpnMonCtrlStatus to 'active'. The following objects cannot be modified after creating the Auto SAA L3 MPLS VPN conceptual row. - rttMplsVpnMonCtrlRttType - rttMplsVpnMonCtrlVrfName The following objects can be modified even after creating the Auto SAA L3 MPLS VPN conceptual row by setting this object to 'notInService' - All other writable objects in rttMplsVpnMonCtrlTable except rttMplsVpnMonCtrlRttType and rttMplsVpnMonCtrlVrfName. - Objects in the rttMplsVpnMonTypeTable. - Objects in the rttMplsVpnMonScheduleTable. The following objects can be modified as needed without setting this object to 'notInService' even after creating the Auto SAA L3 MPLS VPN conceptual row. - Objects in rttMplsVpnMonReactTable. This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy' it will stop and destroy all the probes created by this Auto SAA L3 MPLS VPN before destroying Auto SAA L3 MPLS VPN control row.")
rttMplsVpnMonCtrlLpd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpd.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpd.setDescription("When set to true, this implies that LPD (LSP Path Discovery) is enabled for this row. The Auto SAA L3 MPLS VPN will find all the paths to each of the PE's and configure RTT operation with rttMonCtrlAdminRttType value as 'lspGroup'. The 'lspGroup' probe will walk through the list of set of information that uniquely identifies a path and send the LSP echo requests across them. All these LSP echo requests sent for 1st path, 2nd path etc. can be thought of as 'single probes' sent as a part of 'lspGroup'. These single probes will of type 'rttMplsVpnMonCtrlRttType'. 'lspGroup' probe is a superset of individual probes that will test multiple paths. For example Suppose there are 10 paths to the target. One 'lspGroup' probe will be created which will store all the information related to uniquely identify the 10 paths. When the 'lspGroup' probe will run it will sweep through the set of information for 1st path, 2nd path, 3rd path and so on till it has tested all the paths.")
rttMplsVpnMonCtrlLpdGrpList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpdGrpList.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpdGrpList.setDescription("This object holds the list of LPD Group IDs that are created for this Auto SAA L3 MPLS VPN row. This object will be applicable only when LSP Path Discovery is enabled for this row. The LPD Groups will be specified in the following form. (a) Individual ID's with comma separated as 1,5,3. (b) Range form including hyphens with multiple ranges being separated by comma as 1-10,12-34. (c) Mix of the above two forms as 1,2,4-10,12,15,19-25.")
rttMplsVpnMonCtrlLpdCompTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpdCompTime.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpdCompTime.setDescription('The completion time of the LSP Path Discovery for the entire set of PEs which are discovered for this Auto SAA. This object will be applicable only when LSP Path Discovery is enabled for this row.')
rttMplsVpnMonTypeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16), )
if mibBuilder.loadTexts: rttMplsVpnMonTypeTable.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeTable.setDescription('A table that contains Auto SAA L3 MPLS VPN configured RTT operation specific definitions. This table is controlled via the rttMplsVpnMonCtrlTable. Entries in this table are created via the rttMplsVpnMonCtrlStatus object.')
rttMplsVpnMonTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1), )
rttMplsVpnMonCtrlEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeEntry"))
rttMplsVpnMonTypeEntry.setIndexNames(*rttMplsVpnMonCtrlEntry.getIndexNames())
if mibBuilder.loadTexts: rttMplsVpnMonTypeEntry.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeEntry.setDescription('A list of objects that define RTT operation specific configuration for an Auto SAA L3 MPLS VPN.')
rttMplsVpnMonTypeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(20)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeInterval.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeInterval.setDescription('This value represents the inter-packet delay between packets and is in milliseconds. This value is currently used for Jitter probe. This object is applicable to jitter probe only. The usage of this value in RTT operation is same as rttMonEchoAdminInterval.')
rttMplsVpnMonTypeNumPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeNumPackets.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeNumPackets.setDescription('This value represents the number of packets that need to be transmitted. This value is currently used for Jitter probe. This object is applicable to jitter probe only. The usage of this value in RTT operation is same as rttMonEchoAdminNumPackets.')
rttMplsVpnMonTypeDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeDestPort.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeDestPort.setDescription("This object represents the target's port number to which the packets need to be sent. This value will be configured as target port for all the operations that is going to be configured The usage of this value is same as rttMonEchoAdminTargetPort in RTT operation. This object is applicable to jitter type. If this object is not being set random port will be used as destination port.")
rttMplsVpnMonTypeSecFreqType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("timeout", 2), ("connectionLoss", 3), ("both", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeSecFreqType.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeSecFreqType.setDescription("This object specifies the reaction type for which the rttMplsVpnMonTypeSecFreqValue should be applied. The Value 'timeout' will cause secondary frequency to be set for frequency on timeout condition. The Value 'connectionLoss' will cause secondary frequency to be set for frequency on connectionloss condition. The Value 'both' will cause secondary frequency to be set for frequency on either of timeout/connectionloss condition. Notifications must be configured on corresponding reaction type in order to rttMplsVpnMonTypeSecFreqValue get effect. When LSP Path Discovery is enabled for this row the following rttMplsVpnMonReactLpdNotifyType notifications must be configured in order to rttMplsVpnMonTypeSecFreqValue get effect. - 'lpdGroupStatus' or 'lpdAll'. Since the Frequency of the operation changes the stats will be collected in new bucket. If any of the reaction type (timeout/connectionLoss) occurred for an operation configured by this Auto SAA L3 MPLS VPN and the following conditions are satisfied, the frequency of the operation will be changed to rttMplsVpnMonTypeSecFreqValue. 1) rttMplsVpnMonTypeSecFreqType is set for a reaction type (timeout/connectionLoss). 2) A notification is configured for the same reaction type (timeout/connectionLoss). When LSP Path Discovery is enabled for this row, if any of the reaction type (timeout/connectionLoss) occurred for 'single probes' configured by this Auto SAA L3 MPLS VPN and the following conditions are satisfied, the secondary frequency rttMplsVpnMonTypeSecFreqValue will be applied to the 'lspGroup' probe. 1) rttMplsVpnMonTypeSecFreqType is set for a reaction type (timeout/connectionLoss/both). 2) rttMplsVpnMonReactLpdNotifyType object must be set to value of 'lpdGroupStatus' or 'lpdAll'. The frequency of the individual operations will be restored to original frequency once the trap is sent.")
rttMplsVpnMonTypeSecFreqValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeSecFreqValue.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeSecFreqValue.setDescription('This object represents the value that needs to be applied to secondary frequency of individual RTT operations configured by Auto SAA L3 MPLS VPN. Setting rttMplsVpnMonTypeSecFreqValue without setting rttMplsVpnMonTypeSecFreqType will not have any effect.')
rttMplsVpnMonTypeLspSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 6), OctetString().clone('7F 00 00 01')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLspSelector.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLspSelector.setDescription('A string which specifies the address of the local host (127.X.X.X). This object will be used as lsp-selector in MPLS RTT operations configured by the Auto SAA L3 MPLS VPN. When LSP Path Discovery is enabled for the row, this object will be used to indicate the base LSP selector value to be used in the LSP Path Discovery. This value of this object is significant in MPLS load balancing scenario. This value will be used as one of the parameter in that load balancing.')
rttMplsVpnMonTypeLSPReplyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 7), RttMonLSPPingReplyMode().clone('replyIpv4Udp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPReplyMode.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPReplyMode.setDescription('This object specifies the reply mode for the LSP Echo requests originated by the operations configured by the Auto SAA L3 MPLS VPN. This object is currently used by echo and pathEcho.')
rttMplsVpnMonTypeLSPTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPTTL.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPTTL.setDescription("This object represents the TTL setting for MPLS echo request packets originated by the operations configured by the Auto SAA L3 MPLS VPN. This object is currently used by echo and pathEcho. For 'echo' the default TTL will be set to 255. For 'pathEcho' the default will be set to 30. Note: This object cannot be set to the value of 0. The default value of 0 signifies the default TTL values will be used for 'echo' and 'pathEcho'.")
rttMplsVpnMonTypeLSPReplyDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 63), ValueRangeConstraint(255, 255), )).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPReplyDscp.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPReplyDscp.setDescription('This object specifies the DSCP value to be set in the IP header of the LSP echo reply packet. The value of this object will be in range of DiffServ codepoint values between 0 to 63. Note: This object cannot be set to value of 255. This default value specifies that DSCP is not set for this row.')
rttMplsVpnMonTypeLpdMaxSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdMaxSessions.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdMaxSessions.setDescription('This object represents the number of concurrent path discovery requests that will be active at one time per MPLS VPN control row. This object is meant for reducing the time for discovery of all the paths to the target in a large customer network. However its value should be chosen such that it does not cause any performance impact. Note: If the customer network has low end routers in the Core it is recommended to keep this value low.')
rttMplsVpnMonTypeLpdSessTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 900)).clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdSessTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdSessTimeout.setDescription('This object specifies the maximum allowed duration of a particular tree trace request. If no response is received in configured time the request will be considered a failure.')
rttMplsVpnMonTypeLpdEchoTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoTimeout.setDescription('This object specifies the timeout value for the LSP echo requests which are sent while performing the LSP Path Discovery.')
rttMplsVpnMonTypeLpdEchoInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoInterval.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoInterval.setDescription('This object specifies the send interval between LSP echo requests which are sent while performing the LSP Path Discovery.')
rttMplsVpnMonTypeLpdEchoNullShim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoNullShim.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoNullShim.setDescription('This object specifies if the explicit-null label is added to LSP echo requests which are sent while performing the LSP Path Discovery. If set to TRUE all the probes configured as part of this control row will send the LSP echo requests with the explicit-null label added.')
rttMplsVpnMonTypeLpdScanPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7200)).clone(240)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdScanPeriod.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdScanPeriod.setDescription("This object specifies the scan time for the completion of LSP Path Discovery for all the PEs discovered for this control row. If the scan period is exceeded on completion of the LSP Path Discovery for all the PEs, the next discovery will start immediately else it will wait till expiry of scan period. For example: If the value is set to 30 minutes then on start of the LSP Path Discovery a timestamp will be taken say T1. At the end of the tree trace discovery one more timestamp will be taken again say T2. If (T2-T1) is greater than 30, the next discovery will start immediately else next discovery will wait for [30 - (T2-T1)]. Note: If the object is set to a special value of '0', it will force immediate start of the next discovery on all neighbours without any delay.")
rttMplsVpnMonTypeLpdStatHours = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdStatHours.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdStatHours.setDescription("The maximum number of hours of data to be kept per LPD group. The LPD group statistics will be kept in an hourly bucket. At the maximum there can be two buckets. The value of 'one' is not advisable because the group will close and immediately be deleted before the network management station will have the opportunity to retrieve the statistics. The value used in the rttMplsVpnLpdGroupStatsTable to uniquely identify this group is the rttMonStatsCaptureStartTimeIndex. Note: When this object is set to the value of '0' all rttMplsVpnLpdGroupStatsTable data capturing will be shut off.")
rttMplsVpnMonScheduleTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17), )
if mibBuilder.loadTexts: rttMplsVpnMonScheduleTable.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonScheduleTable.setDescription('A table of Auto SAA L3 MPLS VPN monitoring scheduling specific definitions. This table is controlled via the rttMplsVpnMonCtrlTable. Entries in this table are created via the rttMplsVpnMonCtrlStatus object.')
rttMplsVpnMonScheduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1), )
rttMplsVpnMonCtrlEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMplsVpnMonScheduleEntry"))
rttMplsVpnMonScheduleEntry.setIndexNames(*rttMplsVpnMonCtrlEntry.getIndexNames())
if mibBuilder.loadTexts: rttMplsVpnMonScheduleEntry.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonScheduleEntry.setDescription('A list of objects that define specific configuration for the scheduling of RTT operations.')
rttMplsVpnMonScheduleRttStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1, 1), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonScheduleRttStartTime.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonScheduleRttStartTime.setDescription("This is the time when this conceptual row will activate. rttMplsVpnMonSchedulePeriod object must be specified before setting this object. This is the value of MIB-II's sysUpTime in the future. When sysUpTime equals this value this object will cause the activation of a conceptual Auto SAA L3 MPLS VPN row. When an agent has the capability to determine date and time, the agent should store this object as DateAndTime. This allows the agent to be able to activate conceptual Auto SAA L3 MPLS VPN row at the intended time. If this object has value as 1, this means start the operation now itself. Value of 0 puts the operation in pending state.")
rttMplsVpnMonSchedulePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonSchedulePeriod.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonSchedulePeriod.setDescription('Specifies the time duration over which all the probes created by the current Auto SAA L3 MPLS VPN have to be scheduled. This object must be set first before setting rttMplsVpnMonScheduleRttStartTime.')
rttMplsVpnMonScheduleFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonScheduleFrequency.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonScheduleFrequency.setDescription('Specifies the duration between initiating each RTT operation configured by the Auto SAA L3 MPLS VPN. This object cannot be set to a value which would be a shorter duration than rttMplsVpnMonCtrlTimeout. The usage of this value in RTT operation is same as rttMonCtrlAdminFrequency.')
rttMplsVpnMonReactTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18), )
if mibBuilder.loadTexts: rttMplsVpnMonReactTable.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactTable.setDescription('A Table of Auto SAA L3 MPLS VPN Notification definitions. This table augments the rttMplsVpnMonCtrlTable.')
rttMplsVpnMonReactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1), )
rttMplsVpnMonCtrlEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMplsVpnMonReactEntry"))
rttMplsVpnMonReactEntry.setIndexNames(*rttMplsVpnMonCtrlEntry.getIndexNames())
if mibBuilder.loadTexts: rttMplsVpnMonReactEntry.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactEntry.setDescription('A list of objects that define Auto SAA L3 MPLS VPN reaction configuration.')
rttMplsVpnMonReactConnectionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactConnectionEnable.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactConnectionEnable.setDescription("The value set for this will be applied as rttMonReactAdminConnectionEnable for individual probes created by the Auto SAA L3 MPLS VPN. When this object is set to true, rttMonReactVar for individual probes created by the Auto SAA L3 MPLS VPN will be set to 'connectionLoss(8)'.")
rttMplsVpnMonReactTimeoutEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactTimeoutEnable.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactTimeoutEnable.setDescription("The value set for this will be applied as rttMonReactAdminTimeoutEnable for individual probes created by the Auto SAA L3 MPLS VPN. When this object is set to true, rttMonReactVar for individual probes created by the Auto SAA L3 MPLS VPN will be set to 'timeout(7)'.")
rttMplsVpnMonReactThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3))).clone('never')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactThresholdType.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactThresholdType.setDescription('The value corresponding to this object will be applied as rttMonReactAdminThresholdType for individual probes created by the Auto SAA L3 MPLS VPN. The value corresponding to this object will be applied as rttMonReactThresholdType for individual probes created by the Auto SAA L3 MPLS VPN.')
rttMplsVpnMonReactThresholdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactThresholdCount.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactThresholdCount.setDescription('This object value will be applied as rttMonReactAdminThresholdCount for individual probes created by the Auto SAA L3 MPLS VPN. This object value will be applied as rttMonReactThresholdCountX for individual probes created by the Auto SAA L3 MPLS VPN.')
rttMplsVpnMonReactActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("trapOnly", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactActionType.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactActionType.setDescription('The value corresponding to this object will be applied as rttMonReactAdminActionType of individual probes created by this Auto SAA L3 MPLS VPN. The value corresponding to this object will be applied as rttMonReactActionType of individual probes created by this Auto SAA L3 MPLS VPN.')
rttMplsVpnMonReactLpdNotifyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("lpdPathDiscovery", 2), ("lpdGroupStatus", 3), ("lpdAll", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactLpdNotifyType.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactLpdNotifyType.setDescription("This object specifies the type of LPD notifications to be generated for the current Auto SAA L3 MPLS VPN control row. This object will be applicable only when LSP Path Discovery is enabled for this row. There are two types of notifications supported for the LPD - (a) rttMonLpdDiscoveryNotification - This notification will be sent on the failure of LSP Path Discovery to the particular PE. Reversal of the failure will also result in sending the notification. (b) rttMonLpdGrpStatusNotification - Individual probes in an LPD group will not generate notifications independently but will be generating dependent on the state of the group. Any individual probe can initiate the generation of a notification, dependent on the state of the group. Notifications are only generated if the failure/restoration of an individual probe causes the state of the group to change. The Value 'none' will not cause any notifications to be sent. The Value 'lpdPathDiscovery' will cause (a) to be sent. The Value 'lpdGroupStatus' will cause (b) to be sent. The Value 'lpdAll' will cause both (a) and (b) to sent depending on the failure conditions.")
rttMplsVpnMonReactLpdRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setUnits('attempts').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactLpdRetryCount.setStatus('current')
if mibBuilder.loadTexts: rttMplsVpnMonReactLpdRetryCount.setDescription("This object value specifies the number of attempts to be performed before declaring the path as 'down'. Each 'single probe' which is part of 'lspGroup' probe will be retried these many times before marking it as 'down'. This object will be applicable only when LSP Path Discovery is enabled for this row. - When rttMplsVpnMonTypeSecFreqType is not configured, the failure count will be incremented at the next cycle of 'lspGroup' probe at interval's of rttMplsVpnMonScheduleFrequency value. For example: Assume there are 10 paths discovered and on the first run of the 'lspGroup' probe first two paths failed and rest passed. On the second run all the probes will be run again. The probes 1 and 2 will be retried till the rttMplsVpnMonReactLpdRetryCount value, and then marked as 'down' and rttMonLpdGrpStatusNotification will be sent if configured. - When rttMplsVpnMonTypeSecFreqType value is anything other than 'none', the retry will happen for the failed probes at the rttMplsVpnMonTypeSecFreqValue and only the failed probes will be retried. For example: Assume there are 10 paths discovered and on the first run of the 'lspGroup' probe first two paths failed and rest passed. The secondary frequency will be applied to the failed probes. At secondary frequency interval the first two probes will be run again. The probes 1 and 2 will be retried till the rttMplsVpnMonReactLpdRetryCount value, and then marked as 'down' and rttMonLpdGrpStatusNotification will be sent if configured.")
rttMonReactTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19), )
if mibBuilder.loadTexts: rttMonReactTable.setStatus('current')
if mibBuilder.loadTexts: rttMonReactTable.setDescription('A table that contains the reaction configurations. Each conceptual row in rttMonReactTable corresponds to a reaction configured for the probe defined in rttMonCtrlAdminTable. For each reaction configured for a probe there is an entry in the table. Each Probe can have multiple reactions and hence there can be multiple rows for a particular probe. This table is coupled with rttMonCtrlAdminTable.')
rttMonReactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonReactConfigIndex"))
if mibBuilder.loadTexts: rttMonReactEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonReactEntry.setDescription('A base list of objects that define a conceptual reaction configuration control row.')
rttMonReactConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonReactConfigIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonReactConfigIndex.setDescription("This object along with rttMonCtrlAdminIndex identifies a particular reaction-configuration for a particular probe. This is a pseudo-random number selected by the management station when creating a row via the rttMonReactStatus. If the pseudo-random number is already in use an 'inconsistentValue' return code will be returned when set operation is attempted.")
rttMonReactVar = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 2), RttMonReactVar()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactVar.setStatus('current')
if mibBuilder.loadTexts: rttMonReactVar.setDescription("This object specifies the type of reaction configured for a probe. The reaction types 'rtt', 'timeout', and 'connectionLoss' can be configured for all probe types. The reaction type 'verifyError' can be configured for all probe types except RTP probe type. The reaction types 'jitterSDAvg', 'jitterDSAvg', 'jitterAvg', 'packetLateArrival', 'packetOutOfSequence', 'maxOfPositiveSD', 'maxOfNegativeSD', 'maxOfPositiveDS' and 'maxOfNegativeDS' can be configured for UDP jitter and ICMP jitter probe types only. The reaction types 'mos' and 'icpif' can be configured for UDP jitter and ICMP jitter probe types only. The reaction types 'packetLossDS', 'packetLossSD' and 'packetMIA' can be configured for UDP jitter, and RTP probe types only. The reaction types 'iaJitterDS', 'frameLossDS', 'mosLQDS', 'mosCQDS', 'rFactorDS', 'iaJitterSD', 'rFactorSD', 'mosCQSD' can be configured for RTP probe type only. The reaction types 'successivePacketLoss', 'maxOfLatencyDS', 'maxOfLatencySD', 'latencyDSAvg', 'latencySDAvg' and 'packetLoss' can be configured for ICMP jitter probe type only.")
rttMonReactThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), ("xOfy", 4), ("average", 5))).clone('never')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdType.setStatus('current')
if mibBuilder.loadTexts: rttMonReactThresholdType.setDescription("This object specifies the conditions under which the notification ( trap ) is sent. never - rttMonReactOccurred is never set immediate - rttMonReactOccurred is set to 'true' when the value of parameter for which reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold. Conversely, rttMonReactOccurred is set to 'false' when the parameter ( e.g rtt, jitterAvg, packetLossSD, mos etc ) is below the threshold limits. consecutive - rttMonReactOccurred is set to true when the value of parameter for which reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold for configured consecutive times. Conversely, rttMonReactOccurred is set to false when the value of parameter ( e.g rtt, jitterAvg packetLossSD, mos etc ) is below the threshold limits for the same number of consecutive operations. xOfy - rttMonReactOccurred is set to true when x ( as specified by rttMonReactThresholdCountX ) out of the last y ( as specified by rttMonReacthresholdCountY ) times the value of parameter for which the reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold. Conversely, it is set to false when x, out of the last y times the value of parameter ( e.g rtt, jitterAvg, packetLossSD, mos ) is below the threshold limits. NOTE: When x > y, the probe will never generate a reaction. average - rttMonReactOccurred is set to true when the average ( rttMonReactThresholdCountX times ) value of parameter for which reaction is configured ( e.g rtt, jitterAvg, packetLossSD, mos etc ) violates the threshold condition. Conversely, it is set to false when the average value of parameter ( e.g rtt, jitterAvg, packetLossSD, mos etc ) is below the threshold limits. If this value is changed by a management station, rttMonReactOccurred is set to false, but no reaction is generated if the prior value of rttMonReactOccurred was true.")
rttMonReactActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("trapOnly", 2), ("triggerOnly", 3), ("trapAndTrigger", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactActionType.setStatus('current')
if mibBuilder.loadTexts: rttMonReactActionType.setDescription('Specifies what type(s), if any, of reaction(s) to generate if an operation violates one of the watched ( reaction-configuration ) conditions: none - no reaction is generated trapOnly - a trap is generated triggerOnly - all trigger actions defined for this entry are initiated trapAndTrigger - both a trap and all trigger actions are initiated A trigger action is defined via the rttMonReactTriggerAdminTable.')
rttMonReactThresholdRising = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdRising.setStatus('current')
if mibBuilder.loadTexts: rttMonReactThresholdRising.setDescription("This object defines the higher threshold limit. If the value ( e.g rtt, jitterAvg, packetLossSD etc ) rises above this limit and if the condition specified in rttMonReactThresholdType are satisfied, a trap is generated. Default value of rttMonReactThresholdRising for 'rtt' is 5000 'jitterAvg' is 100. 'jitterSDAvg' is 100. 'jitterDSAvg' 100. 'packetLossSD' is 10000. 'packetLossDS' is 10000. 'mos' is 500. 'icpif' is 93. 'packetMIA' is 10000. 'packetLateArrival' is 10000. 'packetOutOfSequence' is 10000. 'maxOfPositiveSD' is 10000. 'maxOfNegativeSD' is 10000. 'maxOfPositiveDS' is 10000. 'maxOfNegativeDS' is 10000. 'iaJitterDS' is 20. 'frameLossDS' is 10000. 'mosLQDS' is 400. 'mosCQDS' is 400. 'rFactorDS' is 80. 'successivePacketLoss' is 1000. 'maxOfLatencyDS' is 5000. 'maxOfLatencySD' is 5000. 'latencyDSAvg' is 5000. 'latencySDAvg' is 5000. 'packetLoss' is 10000. This object is not applicable if the rttMonReactVar is 'timeout', 'connectionLoss' or 'verifyError'. For 'timeout', 'connectionLoss' and 'verifyError' default value of rttMonReactThresholdRising will be 0.")
rttMonReactThresholdFalling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdFalling.setStatus('current')
if mibBuilder.loadTexts: rttMonReactThresholdFalling.setDescription("This object defines a lower threshold limit. If the value ( e.g rtt, jitterAvg, packetLossSD etc ) falls below this limit and if the conditions specified in rttMonReactThresholdType are satisfied, a trap is generated. Default value of rttMonReactThresholdFalling 'rtt' is 3000 'jitterAvg' is 100. 'jitterSDAvg' is 100. 'jitterDSAvg' 100. 'packetLossSD' is 10000. 'packetLossDS' is 10000. 'mos' is 500. 'icpif' is 93. 'packetMIA' is 10000. 'packetLateArrival' is 10000. 'packetOutOfSequence' is 10000. 'maxOfPositiveSD' is 10000. 'maxOfNegativeSD' is 10000. 'maxOfPositiveDS' is 10000. 'maxOfNegativeDS' is 10000. 'iaJitterDS' is 20. 'frameLossDS' is 10000. 'mosLQDS' is 310. 'mosCQDS' is 310. 'rFactorDS' is 60. 'successivePacketLoss' is 1000. 'maxOfLatencyDS' is 3000. 'maxOfLatencySD' is 3000. 'latencyDSAvg' is 3000. 'latencySDAvg' is 3000. 'packetLoss' is 10000. 'iaJitterSD' is 20. 'mosCQSD' is 310. 'rFactorSD' is 60. This object is not applicable if the rttMonReactVar is 'timeout', 'connectionLoss' or 'verifyError'. For 'timeout', 'connectionLoss' and 'verifyError' default value of rttMonReactThresholdFalling will be 0.")
rttMonReactThresholdCountX = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdCountX.setStatus('current')
if mibBuilder.loadTexts: rttMonReactThresholdCountX.setDescription("If rttMonReactThresholdType value is 'xOfy', this object defines the 'x' value. If rttMonReactThresholdType value is 'consecutive' this object defines the number of consecutive occurrences that needs threshold violation before setting rttMonReactOccurred as true. If rttMonReactThresholdType value is 'average' this object defines the number of samples that needs be considered for calculating average. This object has no meaning if rttMonReactThresholdType has value of 'never' and 'immediate'.")
rttMonReactThresholdCountY = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdCountY.setStatus('current')
if mibBuilder.loadTexts: rttMonReactThresholdCountY.setDescription("This object defines the 'y' value of the xOfy condition if rttMonReactThresholdType is 'xOfy'. For other values of rttMonReactThresholdType, this object is not applicable.")
rttMonReactValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonReactValue.setStatus('current')
if mibBuilder.loadTexts: rttMonReactValue.setDescription('This object will be set when the configured threshold condition is violated as defined by rttMonReactThresholdType and holds the actual value that violated the configured threshold values. This object is not valid for the following values of rttMonReactVar and It will be always 0: - timeout - connectionLoss - verifyError.')
rttMonReactOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 10), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonReactOccurred.setStatus('current')
if mibBuilder.loadTexts: rttMonReactOccurred.setDescription("This object is set to true when the configured threshold condition is violated as defined by rttMonReactThresholdType. It will be again set to 'false' if the condition reverses. This object is set to true in the following conditions: - rttMonReactVar is set to timeout and rttMonCtrlOperTimeoutOccurred set to true. - rttMonReactVar is set to connectionLoss and rttMonCtrlOperConnectionLostOccurred set to true. - rttMonReactVar is set to verifyError and rttMonCtrlOperVerifyErrorOccurred is set to true. - For all other values of rttMonReactVar, if the corresponding value exceeds the configured rttMonReactThresholdRising. This object is set to false in the following conditions: - rttMonReactVar is set to timeout and rttMonCtrlOperTimeoutOccurred set to false. - rttMonReactVar is set to connectionLoss and rttMonCtrlOperConnectionLostOccurred set to false. - rttMonReactVar is set to verifyError and rttMonCtrlOperVerifyErrorOccurred is set to false. - For all other values of rttMonReactVar, if the corresponding value fall below the configured rttMonReactThresholdFalling. When the RttMonRttType is 'pathEcho' or 'pathJitter', this object is applied only to the rttMonEchoAdminTargetAddress and not to intermediate hops to the Target.")
rttMonReactStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonReactStatus.setDescription("This objects indicates the status of the conceptual RTT Reaction Control Row.Only CreateAndGo and destroy operations are permitted on the row. When this object moves to active state, the conceptual row having the Reaction configuration for the probe is monitored and the notifications are generated when the threshold violation takes place. In order for this object to become active rttMonReactVar must be defined. All other objects assume the default value. This object can be set to 'destroy' from any value at any time. When this object is set to 'destroy' no reaction configuration for the probes would exist. The reaction configuration for the probe is removed.")
rttMonGeneratedOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20), )
if mibBuilder.loadTexts: rttMonGeneratedOperTable.setStatus('current')
if mibBuilder.loadTexts: rttMonGeneratedOperTable.setDescription('This table contains information about the generated operation id as part of a parent IP SLA operation. The parent operation id is pseudo-random number, selected by the management station based on an operation started by the management station,when creating a row via the rttMonCtrlAdminStatus object in the rttMonCtrlAdminTable table.')
rttMonGeneratedOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonGeneratedOperRespIpAddrType"), (0, "CISCO-RTTMON-MIB", "rttMonGeneratedOperRespIpAddr"))
if mibBuilder.loadTexts: rttMonGeneratedOperEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonGeneratedOperEntry.setDescription('An entry in the Generated Oper table corresponding to a child or generated operation as part of a parent IP SLA operation.')
rttMonGeneratedOperRespIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rttMonGeneratedOperRespIpAddrType.setStatus('current')
if mibBuilder.loadTexts: rttMonGeneratedOperRespIpAddrType.setDescription('The type of Internet address, IPv4 or IPv6, of a responder for an IP SLA operation.')
rttMonGeneratedOperRespIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1, 2), InetAddress())
if mibBuilder.loadTexts: rttMonGeneratedOperRespIpAddr.setStatus('current')
if mibBuilder.loadTexts: rttMonGeneratedOperRespIpAddr.setDescription('The internet address of a responder for IP SLA operation. The type of this address is determined by the value of rttMonGeneratedOperRespIpAddrType.')
rttMonGeneratedOperCtrlAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonGeneratedOperCtrlAdminIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonGeneratedOperCtrlAdminIndex.setDescription('This is a pseudo-random number, auto-generated based to identify a child operation based on a parent operation started by the management station,when creating a row via the rttMonCtrlAdminStatus object.')
rttMonStatsCaptureTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1), )
if mibBuilder.loadTexts: rttMonStatsCaptureTable.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureTable.setDescription("The statistics capture database. The statistics capture table contains summarized information of the results for a conceptual RTT control row. A rolling accumulated history of this information is maintained in a series of hourly 'group(s)'. Each 'group' contains a series of 'path(s)', each 'path' contains a series of 'hop(s)', each 'hop' contains a series of 'statistics distribution bucket(s)'. Each conceptual statistics row has a current hourly group, into which RTT results are accumulated. At the end of each hour a new hourly group is created which then becomes current. The counters and accumulators in the new group are initialized to zero. The previous group(s) is kept in the table until the table contains rttMonStatisticsAdminNumHourGroups groups for the conceptual statistics row; at this point, the oldest group is discarded and is replaced by the newly created one. The hourly group is uniquely identified by the rttMonStatsCaptureStartTimeIndex object. If the activity for a conceptual RTT control row ceases because the rttMonCtrlOperState object transitions to 'inactive', the corresponding current hourly group in this table is 'frozen', and a new hourly group is created when activity is resumed. If the activity for a conceptual RTT control row ceases because the rttMonCtrlOperState object transitions to 'pending' this whole table will be cleared and reset to its initial state. When the RttMonRttType is 'pathEcho', the path exploration RTT requests' statistics will not be accumulated in this table. NOTE: When the RttMonRttType is 'pathEcho', a source to target rttMonStatsCapturePathIndex path will be created for each rttMonStatsCaptureStartTimeIndex to hold all errors that occur when a specific path had not been found or connection has not be setup. Using this rttMonStatsCaptureTable, a managing application can retrieve summarized data from accurately measured periods, which is synchronized across multiple conceptual RTT control rows. With the new hourly group creation being performed on a 60 minute period, the managing station has plenty of time to collect the data, and need not be concerned with the vagaries of network delays and lost PDU's when trying to get matching data. Also, the managing station can spread the data gathering over a longer period, which removes the need for a flood of get requests in a short period which otherwise would occur.")
rttMonStatsCaptureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureStartTimeIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCapturePathIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureHopIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureDistIndex"))
if mibBuilder.loadTexts: rttMonStatsCaptureEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureEntry.setDescription("A list of objects which accumulate the results of a series of RTT operations over a 60 minute time period. The statistics capture table is a rollover table. When rttMonStatsCaptureStartTimeIndex groups exceeds the rttMonStatisticsAdminNumHourGroups value, the oldest corresponding hourly group will be deleted and will be replaced with the new rttMonStatsCaptureStartTimeIndex hourly group. All other indices will fill to there maximum size. The statistics capture table has five indices. Each described as follows: - The first index correlates its entries to a conceptual RTT control row via the rttMonCtrlAdminIndex object. - The second index is a rollover group and it uniquely identifies a 60 minute group. (The rttMonStatsCaptureStartTimeIndex object is used to make this value unique.) - When the RttMonRttType is 'pathEcho', the third index uniquely identifies the paths in a statistics period. (The period is 60 minutes.) A path will be created for each unique path through the network. Note: A path that does not contain the target is considered a different path than one which uses the exact same path, but does contain the target. For all other values of RttMonRttType this index will be one. - When the RttMonRttType is 'pathEcho', the fourth index uniquely identifies the hops in each path, as grouped by the third index. This index does imply the order of the hops along the path to a target. For all other values of RttMonRttType this index will be one. - The fifth index uniquely creates a statistical distribution bucket.")
rttMonStatsCaptureStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 1), TimeStamp())
if mibBuilder.loadTexts: rttMonStatsCaptureStartTimeIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureStartTimeIndex.setDescription("The time when this row was created. This object is the second index of the rttMonStatsCaptureTable Table. The the number of rttMonStatsCaptureStartTimeIndex groups exceeds the rttMonStatisticsAdminNumHourGroups value, the oldest rttMonStatsCaptureStartTimeIndex group will be removed and replaced with the new entry. When the RttMonRttType is 'pathEcho', this object also uniquely defines a group of paths. See the rttMonStatsCaptureEntry object.")
rttMonStatsCapturePathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)))
if mibBuilder.loadTexts: rttMonStatsCapturePathIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCapturePathIndex.setDescription("When the RttMonRttType is 'pathEcho', this object uniquely defines a path for a given value of rttMonStatsCaptureStartTimeIndex. For all other values of RttMonRttType, this object will be one. For a particular value of rttMonStatsCaptureStartTimeIndex, the agent assigns the first instance of a path a value of 1, then second instance a value of 2, and so on. The sequence keeps incrementing until the number of paths equals rttMonStatisticsAdminNumPaths value, then no new paths are kept for the current rttMonStatsCaptureStartTimeIndex group. NOTE: A source to target rttMonStatsCapturePathIndex path will be created for each rttMonStatsCaptureStartTimeIndex to hold all errors that occur when a specific path or connection has not be setup. This value directly represents the path to a target. We can only support 128 paths.")
rttMonStatsCaptureHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)))
if mibBuilder.loadTexts: rttMonStatsCaptureHopIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureHopIndex.setDescription("When the RttMonRttType is 'pathEcho', this object uniquely defines a hop for a given value of rttMonStatsCapturePathIndex. For all other values of RttMonRttType, this object will be one. For a particular value of rttMonStatsCapturePathIndex, the agent assigns the first instance of a hop a value of 1, then second instance a value of 2, and so on. The sequence keeps incrementing until the number of hops equals rttMonStatisticsAdminNumHops value, then no new hops are kept for the current rttMonStatsCapturePathIndex. This value directly represents a hop along the path to a target, thus we can only support 30 hops. This value shows the order along the path to a target.")
rttMonStatsCaptureDistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: rttMonStatsCaptureDistIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureDistIndex.setDescription('This object uniquely defines a statistical distribution bucket for a given value of rttMonStatsCaptureHopIndex. For a particular value of rttMonStatsCaptureHopIndex, the agent assigns the first instance of a distribution a value of 1, then second instance a value of 2, and so on. The sequence keeps incrementing until the number of statistics distribution intervals equals rttMonStatisticsAdminNumDistBuckets value, then all values that fall above the last interval will be placed into the last interval. Each of these Statistics Distribution Buckets contain the results of each completion as defined by rttMonStatisticsAdminDistInterval object.')
rttMonStatsCaptureCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureCompletions.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureCompletions.setDescription('The number of RTT operations that have completed without an error and without timing out. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonStatsCaptureOverThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureOverThresholds.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureOverThresholds.setDescription('The number of RTT operations successfully completed, but in excess of rttMonCtrlAdminThreshold. This number is a subset of the accumulation of all rttMonStatsCaptureCompletions. The operation time of these completed operations will be accumulated. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonStatsCaptureSumCompletionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 7), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime.setDescription('The accumulated completion time of RTT operations which complete successfully.')
rttMonStatsCaptureSumCompletionTime2Low = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime2Low.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime2Low.setDescription("The low order 32 bits of the accumulated squares of completion times (in milliseconds) of RTT operations which complete successfully. Low/High order is defined where the binary number will look as follows: ------------------------------------------------- | High order 32 bits | Low order 32 bits | ------------------------------------------------- For example the number 4294967296 would have all Low order bits as '0' and the rightmost High order bit will be 1 (zeros,1).")
rttMonStatsCaptureSumCompletionTime2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime2High.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime2High.setDescription('The high order 32 bits of the accumulated squares of completion times (in milliseconds) of RTT operations which complete successfully. See the rttMonStatsCaptureSumCompletionTime2Low object for a definition of Low/High Order.')
rttMonStatsCaptureCompletionTimeMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 10), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureCompletionTimeMax.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureCompletionTimeMax.setDescription('The maximum completion time of any RTT operation which completes successfully.')
rttMonStatsCaptureCompletionTimeMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 11), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureCompletionTimeMin.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCaptureCompletionTimeMin.setDescription('The minimum completion time of any RTT operation which completes successfully.')
rttMonStatsCollectTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2), )
if mibBuilder.loadTexts: rttMonStatsCollectTable.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectTable.setDescription('The statistics collection database. This table has the exact same behavior as the rttMonStatsCaptureTable, except it does not keep statistical distribution information. For a complete table description see the rttMonStatsCaptureTable object.')
rttMonStatsCollectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureStartTimeIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCapturePathIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureHopIndex"))
if mibBuilder.loadTexts: rttMonStatsCollectEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectEntry.setDescription('A list of objects which accumulate the results of a series of RTT operations over a 60 minute time period. This entry has the exact same behavior as the rttMonStatsCaptureEntry, except it does not keep statistical distribution information. For a complete entry description see the rttMonStatsCaptureEntry object.')
rttMonStatsCollectNumDisconnects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectNumDisconnects.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectNumDisconnects.setDescription("When the RttMonRttType is 'echo' or pathEcho', this object represents the number of times that the target or hop along the path to a target became disconnected. For all other values of RttMonRttType, this object will remain zero. For connectionless protocols this has no meaning, and will consequently remain 0. When rttMonEchoAdminProtocol is one of snaRUEcho, this is the number of times that an LU-SSCP session was lost, for snaLU0EchoAppl, snaLU2EchoAppl, snaLu62Echo, and for snaLU62EchoAppl, this is the number of times that LU-LU session was lost. Since this error does not indicate any information about the failure of an RTT operation, no response time information for this instance will be recorded in the appropriate objects. If this error occurs and the rttMonStatsCapturePathIndex cannot be determined, this error will be accumulated in the source to target path, that will always exist. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.")
rttMonStatsCollectTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectTimeouts.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectTimeouts.setDescription('The number of occasions when a RTT operation was not completed before a timeout occurred, i.e. rttMonCtrlAdminTimeout was exceeded. Since the RTT operation was never completed, the completion time of these operations are not accumulated, nor do they increment rttMonStatsCaptureCompletions (in any of the statistics distribution buckets). This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonStatsCollectBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectBusies.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectBusies.setDescription("The number of occasions when a RTT operation could not be initiated because a previous RTT operation has not been completed. When the RttMonRttType is 'pathEcho' this can occur for both connection oriented protocols and connectionless protocols. When the RttMonRttType is 'echo' this can only occur for connection oriented protocols such as SNA. When the initiation of a new operation cannot be started, this object will be incremented and the operation will be omitted. (The next operation will start at the next Frequency). Since, a RTT operation was never initiated, the completion time of these operations is not accumulated, nor do they increment rttMonStatsCaptureCompletions. When the RttMonRttType is 'pathEcho', and this error occurs and the rttMonStatsCapturePathIndex cannot be determined, this error will be accumulated in the source to target path, that will always exist. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.")
rttMonStatsCollectNoConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectNoConnections.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectNoConnections.setDescription("When the RttMonRttType is 'echo' or 'pathEcho' this is the number of occasions when a RTT operation could not be initiated because the connection to the target has not been established. For all other RttMonRttTypes this object will remain zero. This cannot occur for connectionless protocols, but may occur for connection oriented protocols, such as SNA. Since a RTT operation was never initiated, the completion time of these operations are not accumulated, nor do they increment rttMonStatsCaptureCompletions. If this error occurs and the rttMonStatsCapturePathIndex cannot be determined, this error will be accumulated in the source to target path, that will always exist. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.")
rttMonStatsCollectDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectDrops.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectDrops.setDescription("The number of occasions when a RTT operation could not be initiated because some necessary internal resource (for example memory, or SNA subsystem) was not available, or the operation completion could not be recognized. Since a RTT operation was never initiated or was not recognized, the completion time of these operations are not accumulated, nor do they increment rttMonStatsCaptureCompletions (in the expected Distribution Bucket). When the RttMonRttType is 'pathEcho', and this error occurs and the rttMonStatsCapturePathIndex cannot be determined, this error will be accumulated in the source to target path, that will always exist. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.")
rttMonStatsCollectSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectSequenceErrors.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectSequenceErrors.setDescription("When the RttMonRttType is 'echo' of 'pathEcho' this is the number of RTT operation completions received with an unexpected sequence identifier. For all other values of RttMonRttType this object will remain zero. When this has occurred some of the possible reasons may be: - a duplicate packet was received - a response was received after it had timed-out - a corrupted packet was received and was not detected The completion time of these operations are not accumulated, nor do they increment rttMonStatsCaptureCompletions (in the expected Distribution Bucket). This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.")
rttMonStatsCollectVerifyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectVerifyErrors.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectVerifyErrors.setDescription('The number of RTT operation completions received with data that does not compare with the expected data. The completion time of these operations are not accumulated, nor do they increment rttMonStatsCaptureCompletions (in the expected Distribution Bucket). This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonStatsCollectAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 8), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectAddress.setDescription("This object only applies when the RttMonRttType is 'echo', 'pathEcho', 'dlsw', 'udpEcho', 'tcpConnect'. For all other values of the RttMonRttType, this will be null. The object is a string which specifies the address of the target for the this RTT operation. This address will be the address of the hop along the path to the rttMonEchoAdminTargetAddress address, including rttMonEchoAdminTargetAddress address, or just the rttMonEchoAdminTargetAddress address, when the path information is not collected. This behavior is defined by the rttMonCtrlAdminRttType object. The interpretation of this string depends on the type of RTT operation selected, as specified by the rttMonEchoAdminProtocol object.")
rttMonControlEnableErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonControlEnableErrors.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonControlEnableErrors.setDescription('The number of occasions when control enable request failed. Currently it is used for multicast operation type. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object. rttMonControlEnableErrors object is superseded by rttMonStatsCollectCtrlEnErrors.')
rttMonStatsRetrieveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsRetrieveErrors.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonStatsRetrieveErrors.setDescription('The number of occasions when stats retrieval request failed. Currently it is used for multicast operation type. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object. rttMonStatsRetrieveErrors object is superseded by rttMonStatsCollectRetrieveErrors.')
rttMonStatsCollectCtrlEnErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectCtrlEnErrors.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectCtrlEnErrors.setDescription('The object is same as rttMonControlEnableErrors, with corrected name for consistency. The number of occasions when control enable request failed. Currently it is used for multicast operation type. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonStatsCollectRetrieveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectRetrieveErrors.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsCollectRetrieveErrors.setDescription('The object is same as rttMonStatsRetrieveErrors, with corrected name for consistency. The number of occasions when stats retrieval request failed. Currently it is used for multicast operation type. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonStatsTotalsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3), )
if mibBuilder.loadTexts: rttMonStatsTotalsTable.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsTotalsTable.setDescription('The statistics totals database. This table has the exact same behavior as the rttMonStatsCaptureTable, except it only keeps 60 minute group values. For a complete table description see the rttMonStatsCaptureTable object.')
rttMonStatsTotalsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureStartTimeIndex"))
if mibBuilder.loadTexts: rttMonStatsTotalsEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsTotalsEntry.setDescription('A list of objects which accumulate the results of a series of RTT operations over a 60 minute time period. This entry has the exact same behavior as the rttMonStatsCaptureEntry, except it only keeps 60 minute group values. For a complete entry description see the rttMonStatsCaptureEntry object.')
rttMonStatsTotalsElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3, 1, 1), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsTotalsElapsedTime.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsTotalsElapsedTime.setDescription('The length of time since this conceptual statistics row was created.')
rttMonStatsTotalsInitiations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsTotalsInitiations.setStatus('current')
if mibBuilder.loadTexts: rttMonStatsTotalsInitiations.setDescription('The number of RTT operations that have been initiated. This number includes all RTT operations which succeed or fail for whatever reason. This object has the special behavior as defined by the ROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB object.')
rttMonHTTPStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4), )
if mibBuilder.loadTexts: rttMonHTTPStatsTable.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsTable.setDescription("The HTTP statistics collection database. The HTTP statistics table contains summarized information of the results for a conceptual RTT control row. A rolling accumulated history of this information is maintained in a series of hourly 'group(s)'. The operation of this table is same as that of rttMonStatsCaptureTable, except that this table can only store a maximum of 2 hours of data.")
rttMonHTTPStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHTTPStatsStartTimeIndex"))
if mibBuilder.loadTexts: rttMonHTTPStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsEntry.setDescription('A list of objects which accumulate the results of a series of RTT operations over a 60 minute time period. This entry is created only if the rttMonCtrlAdminRttType is http. The operation of this table is same as that of rttMonStatsCaptureTable.')
rttMonHTTPStatsStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 1), TimeStamp())
if mibBuilder.loadTexts: rttMonHTTPStatsStartTimeIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsStartTimeIndex.setDescription('This is the time when this row was created. This index uniquely identifies a HTTP Stats row in the rttMonHTTPStatsTable.')
rttMonHTTPStatsCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsCompletions.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsCompletions.setDescription('The number of HTTP operations that have completed successfully.')
rttMonHTTPStatsOverThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsOverThresholds.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsOverThresholds.setDescription('The number of HTTP operations that violate threshold.')
rttMonHTTPStatsRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum.setDescription('The sum of HTTP operations that are successfully measured.')
rttMonHTTPStatsRTTSum2Low = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum2Low.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum2Low.setDescription("The sum of squares of the RTT's that are successfully measured (low order 32 bits).")
rttMonHTTPStatsRTTSum2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum2High.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum2High.setDescription("The sum of squares of the RTT's that are successfully measured (high order 32 bits).")
rttMonHTTPStatsRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTMin.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsRTTMin.setDescription('The minimum RTT taken to perform HTTP operation.')
rttMonHTTPStatsRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 8), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTMax.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsRTTMax.setDescription('The maximum RTT taken to perform HTTP operation.')
rttMonHTTPStatsDNSRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsDNSRTTSum.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsDNSRTTSum.setDescription('The sum of RTT taken to perform DNS query within the HTTP operation.')
rttMonHTTPStatsTCPConnectRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTCPConnectRTTSum.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsTCPConnectRTTSum.setDescription('The sum of RTT taken to connect to the HTTP server.')
rttMonHTTPStatsTransactionRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTransactionRTTSum.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsTransactionRTTSum.setDescription('The sum of RTT taken to download the object specified by URL.')
rttMonHTTPStatsMessageBodyOctetsSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsMessageBodyOctetsSum.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsMessageBodyOctetsSum.setDescription('The sum of the size of the message body received as a response to the HTTP request.')
rttMonHTTPStatsDNSServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsDNSServerTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsDNSServerTimeout.setDescription('The number of requests that could not connect to the DNS Server.')
rttMonHTTPStatsTCPConnectTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTCPConnectTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsTCPConnectTimeout.setDescription('The number of requests that could not connect to the the HTTP Server.')
rttMonHTTPStatsTransactionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTransactionTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsTransactionTimeout.setDescription('The number of requests that timed out during HTTP transaction.')
rttMonHTTPStatsDNSQueryError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsDNSQueryError.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsDNSQueryError.setDescription('The number of requests that had DNS Query errors.')
rttMonHTTPStatsHTTPError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsHTTPError.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsHTTPError.setDescription('The number of requests that had HTTP errors while downloading the base page.')
rttMonHTTPStatsError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsError.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsError.setDescription('The number of occasions when a HTTP operation could not be initiated because an internal error')
rttMonHTTPStatsBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsBusies.setStatus('current')
if mibBuilder.loadTexts: rttMonHTTPStatsBusies.setDescription('The number of occasions when an HTTP operation could not be initiated because a previous HTTP operation has not been completed.')
rttMonJitterStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5), )
if mibBuilder.loadTexts: rttMonJitterStatsTable.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsTable.setDescription("The Jitter statistics collection database. The Jitter statistics table contains summarized information of the results for a conceptual RTT control row. A rolling accumulated history of this information is maintained in a series of hourly 'group(s)'. The operation of this table is same as that of rttMonStatsCaptureTable, except that this table will store 2 hours of data.")
rttMonJitterStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonJitterStatsStartTimeIndex"))
if mibBuilder.loadTexts: rttMonJitterStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsEntry.setDescription('A list of objects which accumulate the results of a series of RTT operations over a 60 minute time period. This entry is created only if the rttMonCtrlAdminRttType is jitter. The operation of this table is same as that of rttMonStatsCaptureTable.')
rttMonJitterStatsStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 1), TimeStamp())
if mibBuilder.loadTexts: rttMonJitterStatsStartTimeIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsStartTimeIndex.setDescription('The time when this row was created.')
rttMonJitterStatsCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsCompletions.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsCompletions.setDescription('The number of jitter operation that have completed successfully.')
rttMonJitterStatsOverThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOverThresholds.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOverThresholds.setDescription('The number of jitter operations that violate threshold.')
rttMonJitterStatsNumOfRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOfRTT.setDescription("The number of RTT's that are successfully measured.")
rttMonJitterStatsRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum.setDescription("The sum of RTT's that are successfully measured (low order 32 bits). The high order 32 bits are stored in rttMonJitterStatsRTTSumHigh.")
rttMonJitterStatsRTTSum2Low = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum2Low.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum2Low.setDescription("The sum of squares of RTT's that are successfully measured (low order 32 bits).")
rttMonJitterStatsRTTSum2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum2High.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum2High.setDescription("The sum of squares of RTT's that are successfully measured (high order 32 bits).")
rttMonJitterStatsRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTMin.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsRTTMin.setDescription("The minimum of RTT's that were successfully measured")
rttMonJitterStatsRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTMax.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsRTTMax.setDescription("The maximum of RTT's that were successfully measured")
rttMonJitterStatsMinOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMinOfPositivesSD.setDescription('The minimum of absolute values of all positive jitter values from packets sent from source to destination.')
rttMonJitterStatsMaxOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfPositivesSD.setDescription('The maximum of absolute values of all positive jitter values from packets sent from source to destination.')
rttMonJitterStatsNumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOfPositivesSD.setDescription('The sum of number of all positive jitter values from packets sent from source to destination.')
rttMonJitterStatsSumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfPositivesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSumOfPositivesSD.setDescription('The sum of all positive jitter values from packets sent from source to destination.')
rttMonJitterStatsSum2PositivesSDLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesSDLow.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesSDLow.setDescription("The sum of square of RTT's of all positive jitter values from packets sent from source to destination (low order 32 bits).")
rttMonJitterStatsSum2PositivesSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesSDHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesSDHigh.setDescription("The sum of square of RTT's of all positive jitter values from packets sent from source to destination (high order 32 bits).")
rttMonJitterStatsMinOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMinOfNegativesSD.setDescription('The minimum of all negative jitter values from packets sent from source to destination.')
rttMonJitterStatsMaxOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfNegativesSD.setDescription('The maximum of all negative jitter values from packets sent from source to destination.')
rttMonJitterStatsNumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOfNegativesSD.setDescription('The sum of number of all negative jitter values from packets sent from source to destination.')
rttMonJitterStatsSumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfNegativesSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSumOfNegativesSD.setDescription("The sum of RTT's of all negative jitter values from packets sent from source to destination.")
rttMonJitterStatsSum2NegativesSDLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesSDLow.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesSDLow.setDescription("The sum of square of RTT's of all negative jitter values from packets sent from source to destination (low order 32 bits).")
rttMonJitterStatsSum2NegativesSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesSDHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesSDHigh.setDescription("The sum of square of RTT's of all negative jitter values from packets sent from source to destination (high order 32 bits).")
rttMonJitterStatsMinOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMinOfPositivesDS.setDescription('The minimum of all positive jitter values from packets sent from destination to source.')
rttMonJitterStatsMaxOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfPositivesDS.setDescription('The maximum of all positive jitter values from packets sent from destination to source.')
rttMonJitterStatsNumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOfPositivesDS.setDescription('The sum of number of all positive jitter values from packets sent from destination to source.')
rttMonJitterStatsSumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfPositivesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSumOfPositivesDS.setDescription("The sum of RTT's of all positive jitter values from packets sent from destination to source.")
rttMonJitterStatsSum2PositivesDSLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesDSLow.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesDSLow.setDescription("The sum of squares of RTT's of all positive jitter values from packets sent from destination to source (low order 32 bits).")
rttMonJitterStatsSum2PositivesDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesDSHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesDSHigh.setDescription("The sum of squares of RTT's of all positive jitter values from packets sent from destination to source (high order 32 bits).")
rttMonJitterStatsMinOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMinOfNegativesDS.setDescription('The minimum of all negative jitter values from packets sent from destination to source.')
rttMonJitterStatsMaxOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfNegativesDS.setDescription('The maximum of all negative jitter values from packets sent from destination to source.')
rttMonJitterStatsNumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOfNegativesDS.setDescription('The sum of number of all negative jitter values from packets sent from destination to source.')
rttMonJitterStatsSumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfNegativesDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSumOfNegativesDS.setDescription("The sum of RTT's of all negative jitter values from packets sent from destination to source.")
rttMonJitterStatsSum2NegativesDSLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesDSLow.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesDSLow.setDescription("The sum of squares of RTT's of all negative jitter values from packets sent from destination to source (low order 32 bits).")
rttMonJitterStatsSum2NegativesDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesDSHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesDSHigh.setDescription("The sum of squares of RTT's of all negative jitter values from packets sent from destination to source (high order 32 bits).")
rttMonJitterStatsPacketLossSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketLossSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsPacketLossSD.setDescription('The number of packets lost when sent from source to destination.')
rttMonJitterStatsPacketLossDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketLossDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsPacketLossDS.setDescription('The number of packets lost when sent from destination to source.')
rttMonJitterStatsPacketOutOfSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketOutOfSequence.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsPacketOutOfSequence.setDescription('The number of packets arrived out of sequence.')
rttMonJitterStatsPacketMIA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketMIA.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsPacketMIA.setDescription('The number of packets that are lost for which we cannot determine the direction.')
rttMonJitterStatsPacketLateArrival = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketLateArrival.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsPacketLateArrival.setDescription('The number of packets that arrived after the timeout.')
rttMonJitterStatsError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsError.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsError.setDescription('The number of occasions when a jitter operation could not be initiated because an internal error')
rttMonJitterStatsBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsBusies.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsBusies.setDescription('The number of occasions when a jitter operation could not be initiated because a previous jitter operation has not been completed.')
rttMonJitterStatsOWSumSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSumSD.setDescription('The sum of one way times from source to destination (low order 32 bits). The high order 32 bits are stored in rttMonJitterStatsOWSumSDHigh.')
rttMonJitterStatsOWSum2SDLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2SDLow.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2SDLow.setDescription('The sum of squares of one way times from source to destination (low order 32 bits).')
rttMonJitterStatsOWSum2SDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2SDHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2SDHigh.setDescription('The sum of squares of one way times from source to destination (high order 32 bits).')
rttMonJitterStatsOWMinSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinSD.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonJitterStatsOWMinSD.setDescription('The minimum of all one way times from source to destination. rttMonJitterStatsOWMinSD object is superseded by rttMonJitterStatsOWMinSDNew.')
rttMonJitterStatsOWMaxSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxSD.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxSD.setDescription('The maximum of all one way times from source to destination. rttMonJitterStatsOWMaxSD object is superseded by rttMonJitterStatsOWMaxSDNew.')
rttMonJitterStatsOWSumDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSumDS.setDescription('The sum of one way times from destination to source (low order 32 bits). The high order 32 bits are stored in rttMonJitterStatsOWSumDSHigh.')
rttMonJitterStatsOWSum2DSLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2DSLow.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2DSLow.setDescription('The sum of squares of one way times from destination to source (low order 32 bits).')
rttMonJitterStatsOWSum2DSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2DSHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2DSHigh.setDescription('The sum of squares of one way times from destination to source (high order 32 bits).')
rttMonJitterStatsOWMinDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinDS.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonJitterStatsOWMinDS.setDescription('The minimum of all one way times from destination to source. rttMonJitterStatsOWMinDS object is superseded by rttMonJitterStatsOWMinDSNew.')
rttMonJitterStatsOWMaxDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxDS.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxDS.setDescription('The maximum of all one way times from destination to source. rttMonJitterStatsOWMaxDS object is superseded by rttMonJitterStatsOWMaxDSNew.')
rttMonJitterStatsNumOfOW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfOW.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOfOW.setDescription('The number of one way times that are successfully measured.')
rttMonJitterStatsOWMinSDNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 52), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinSDNew.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWMinSDNew.setDescription('The minimum of all one way times from source to destination. Replaces deprecated rttMonJitterStatsOWMinSD.')
rttMonJitterStatsOWMaxSDNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxSDNew.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxSDNew.setDescription('The maximum of all one way times from source to destination. Replaces deprecated rttMonJitterStatsOWMaxSD.')
rttMonJitterStatsOWMinDSNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinDSNew.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWMinDSNew.setDescription('The minimum of all one way times from destination to source. Replaces deprecated rttMonJitterStatsOWMinDS.')
rttMonJitterStatsOWMaxDSNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxDSNew.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxDSNew.setDescription('The maximum of all one way times from destination to source. Replaces deprecated rttMonJitterStatsOWMaxDS')
rttMonJitterStatsMinOfMOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 56), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(100, 500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfMOS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMinOfMOS.setDescription('The minimum of all MOS values for the jitter operations in hundreds. This value will be 0 if - rttMonEchoAdminCodecType of the operation is notApplicable - the operation is not started - the operation is started but failed This value will be 1 for packet loss of 10% or more.')
rttMonJitterStatsMaxOfMOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 57), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(100, 500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfMOS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfMOS.setDescription('The maximum of all MOS values for the jitter operations in hunderds. This value will be 0 if - rttMonEchoAdminCodecType of the operation is notApplicable - the operation is not started - the operation is started but failed This value will be 1 for packet loss of 10% or more.')
rttMonJitterStatsMinOfICPIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfICPIF.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMinOfICPIF.setDescription('The minimum of all ICPIF values for the jitter operations. This value will be 93 for packet loss of 10% or more.')
rttMonJitterStatsMaxOfICPIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 59), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfICPIF.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfICPIF.setDescription('The maximum of all ICPIF values for the jitter operations. This value will be 93 for packet loss of 10% or more.')
rttMonJitterStatsIAJOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 60), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsIAJOut.setReference('Refer to the following documents for the definition: RFC 1889')
if mibBuilder.loadTexts: rttMonJitterStatsIAJOut.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsIAJOut.setDescription('Interarrival Jitter (RFC 1889) at responder')
rttMonJitterStatsIAJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 61), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsIAJIn.setReference('Refer to the following documents for the definition: RFC 1889')
if mibBuilder.loadTexts: rttMonJitterStatsIAJIn.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsIAJIn.setDescription('Interarrival Jitter (RFC 1889) at sender')
rttMonJitterStatsAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 62), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitter.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitter.setDescription('The average of positive and negative jitter values for SD and DS direction.')
rttMonJitterStatsAvgJitterSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 63), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitterSD.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitterSD.setDescription('The average of positive and negative jitter values in SD direction.')
rttMonJitterStatsAvgJitterDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 64), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitterDS.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitterDS.setDescription('The average of positive and negative jitter values in DS direction.')
rttMonJitterStatsUnSyncRTs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsUnSyncRTs.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsUnSyncRTs.setDescription('The number of RTT operations that have completed with sender and responder out of sync with NTP. The NTP sync means the total of NTP offset on sender and responder is within configured tolerance level.')
rttMonJitterStatsRTTSumHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSumHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsRTTSumHigh.setDescription("The sum of RTT's that are successfully measured (high order 32 bits). The low order 32 bits are stored in rttMonJitterStatsRTTSum.")
rttMonJitterStatsOWSumSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumSDHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSumSDHigh.setDescription('The sum of one way times from source to destination (high order 32 bits). The low order 32 bits are stored in rttMonJitterStatsOWSumSD.')
rttMonJitterStatsOWSumDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumDSHigh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsOWSumDSHigh.setDescription('The sum of one way times from destination to source (high order 32 bits). The low order 32 bits are stored in rttMonJitterStatsOWSumDS.')
rttMonJitterStatsNumOverThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 69), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOverThresh.setStatus('current')
if mibBuilder.loadTexts: rttMonJitterStatsNumOverThresh.setDescription('This object indicates the number of RTTs that were over the threshold value.')
rttMonLpdGrpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7), )
if mibBuilder.loadTexts: rttMonLpdGrpStatsTable.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsTable.setDescription("The Auto SAA L3 MPLS VPN LPD Group Database. The LPD Group statistics table contains summarized performance statistics for the LPD group. LPD Group - The set of 'single probes' which are subset of the 'lspGroup' probe traversing set of paths between two PE end points are grouped together and called as the LPD group. The LPD group will be uniquely referenced by the LPD Group ID. A rolling accumulated history of this information is maintained in a series of hourly 'group(s)'. Each conceptual statistics row has a current hourly group, into which RTT results are accumulated. At the end of each hour a new hourly group is created which then becomes current. The counters and accumulators in the new group are initialized to zero. The previous group(s) is kept in the table until the table contains rttMplsVpnMonTypeLpdStatHours groups for the conceptual statistics row; at this point, the oldest group is discarded and is replaced by the newly created one. The hourly group is uniquely identified by the rttMonLpdGrpStatsStartTimeIndex object.")
rttMonLpdGrpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupIndex"), (0, "CISCO-RTTMON-MIB", "rttMonLpdGrpStatsStartTimeIndex"))
if mibBuilder.loadTexts: rttMonLpdGrpStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsEntry.setDescription('A list of objects which accumulate the results of a set of RTT operations over a 60 minute time period. The LPD group statistics table is a rollover table. When rttMonLpdGrpStatsStartTimeIndex groups exceeds the rttMplsVpnMonTypeLpdStatHours value, the oldest corresponding hourly group will be deleted and will be replaced with the new rttMonLpdGrpStatsStartTimeIndex hourly group. The LPD group statistics table has two indices. Each described as follows: - The first index correlates its entries to a LPD group via the rttMonLpdGrpStatsGroupIndex object. - The second index is a rollover group and it uniquely identifies a 60 minute group. (The rttMonLpdGrpStatsStartTimeIndex is used to make this value unique.)')
rttMonLpdGrpStatsGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupIndex.setDescription('Uniquely identifies a row in rttMonLpdGrpStatsTable. This is a pseudo-random number which identifies a particular LPD group.')
rttMonLpdGrpStatsStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 2), TimeStamp())
if mibBuilder.loadTexts: rttMonLpdGrpStatsStartTimeIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsStartTimeIndex.setDescription('The time when this row was created. This object is the second index of the rttMonLpdGrpStatsTable. When the number of rttMonLpdGrpStatsStartTimeIndex groups exceeds the rttMplsVpnMonTypeLpdStatHours value, the oldest rttMonLpdGrpStatsStartTimeIndex group will be removed and replaced with the new entry.')
rttMonLpdGrpStatsTargetPE = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 3), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsTargetPE.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsTargetPE.setDescription('The object is a string that specifies the address of the target PE for this LPD group.')
rttMonLpdGrpStatsNumOfPass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('passes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfPass.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfPass.setDescription("This object represents the number of successfull completions of 'single probes' for all the set of paths in the LPD group. Whenever the rttMonLatestRttOperSense value is 'ok' for a particular probe in the LPD Group this object will be incremented. This object will be set to '0' on reset.")
rttMonLpdGrpStatsNumOfFail = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('failures').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfFail.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfFail.setDescription("This object represents the number of failed operations of 'single probes' for all the set of paths in the LPD group. Whenever the rttMonLatestRttOperSense has a value other than 'ok' or 'timeout' for a particular probe in the LPD Group this object will be incremented. This object will be set to '0' on reset.")
rttMonLpdGrpStatsNumOfTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('timeouts').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfTimeout.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfTimeout.setDescription("This object represents the number of timed out operations of 'single probes' for all the set of paths in the LPD group. Whenever the rttMonLatestRttOperSense has a value of 'timeout' for a particular probe in the LPD Group this object will be incremented. This object will be set to '0' on reset.")
rttMonLpdGrpStatsAvgRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsAvgRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsAvgRTT.setDescription("The average RTT across all set of probes in the LPD group. This object will be set to '0' on reset.")
rttMonLpdGrpStatsMinRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMinRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsMinRTT.setDescription("The minimum of RTT's for all set of probes in the LPD group that were successfully measured. This object will be set to '0' on reset.")
rttMonLpdGrpStatsMaxRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMaxRTT.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsMaxRTT.setDescription("The maximum of RTT's for all set of probes in the LPD group that were successfully measured. This object will be set to '0' on reset.")
rttMonLpdGrpStatsMinNumPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('paths').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMinNumPaths.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsMinNumPaths.setDescription("The minimum number of active paths discovered to the rttMonLpdGrpStatsTargetPE target. This object will be set to '0' on reset.")
rttMonLpdGrpStatsMaxNumPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('paths').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMaxNumPaths.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsMaxNumPaths.setDescription("The maximum number of active paths discovered to the rttMonLpdGrpStatsTargetPE target. This object will be set to '0' on reset.")
rttMonLpdGrpStatsLPDStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 12), TimeStamp()).setUnits('tenths of milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDStartTime.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDStartTime.setDescription("The time when the last LSP Path Discovery to the group was attempted. This object will be set to '0' on reset.")
rttMonLpdGrpStatsLPDFailOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDFailOccurred.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDFailOccurred.setDescription("This object is set to true when the LSP Path Discovery to the target PE i.e. rttMonLpdGrpStatsTargetPE fails, and set to false when the LSP Path Discovery succeeds. When this value changes and rttMplsVpnMonReactLpdNotifyType is set to 'lpdPathDiscovery' or 'lpdAll' a rttMonLpdDiscoveryNotification will be generated. This object will be set to 'FALSE' on reset.")
rttMonLpdGrpStatsLPDFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 14), RttMplsVpnMonLpdFailureSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDFailCause.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDFailCause.setDescription("This object identifies the cause of failure for the LSP Path Discovery last attempted. It will be only valid if rttMonLpdGrpStatsLPDFailOccurred is set to true. This object will be set to 'unknown' on reset.")
rttMonLpdGrpStatsLPDCompTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDCompTime.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDCompTime.setDescription("The completion time of the last successfull LSP Path Discovery to the target PE. This object will be set to '0' on reset.")
rttMonLpdGrpStatsGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 16), RttMplsVpnMonLpdGrpStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupStatus.setDescription("This object identifies the LPD Group status. When the LPD Group status changes and rttMplsVpnMonReactLpdNotifyType is set to 'lpdGroupStatus' or 'lpdAll' a rttMonLpdGrpStatusNotification will be generated. When the LPD Group status value is 'unknown' or changes to 'unknown' this notification will not be generated. When LSP Path Discovery is enabled for a particular row in rttMplsVpnMonCtrlTable, 'single probes' in the 'lspGroup' probe cannot generate notifications independently but will be generating depending on the state of the group. Notifications are only generated if the failure/restoration of an individual probe causes the state of the LPD Group to change. This object will be set to 'unknown' on reset.")
rttMonLpdGrpStatsGroupProbeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('identifier').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupProbeIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupProbeIndex.setDescription("This object identifies 'lspGroup' probe uniquely created for this particular LPD Group.")
rttMonLpdGrpStatsPathIds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsPathIds.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsPathIds.setDescription("A string which holds the list of information to uniquely identify the paths to the target PE. This information is used by the 'single probes' when testing the paths. Following three parameters are needed to uniquely identify a path - lsp-selector (127.x.x.x) - outgoing-interface (i/f) - label-stack (s), if mutiple labels they will be colon (:) separated. These parameters will be hyphen (-) separated for a particular path. This set of information will be comma (,) separated for all the paths discovered as part of this LPD Group. For example: If there are 5 paths in the LPD group then this object will return all the identifier's to uniquely identify the path. The output will look like '127.0.0.1-Se3/0.1-20:18, 127.0.0.2-Se3/0.1-20,127.0.0.3-Se3/0.1-20,127.0.0.4-Se3/0.1-20, 127.0.0.5-Se3/0.1-20'. This object will be set to '0' on reset.")
rttMonLpdGrpStatsProbeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsProbeStatus.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsProbeStatus.setDescription("A string which holds the latest operation return code for all the set of 'single probes' which are part of the LPD group. The return codes will be comma separated and will follow the same sequence of probes as followed in 'rttMonLpdGrpStatsPathIds'. The latest operation return code will be mapped to 'up','down' or 'unkwown'. 'up' - Probe state is up when the rttMonLatestRttOperSense value is 'ok'. 'down' - Probe state is down when the rttMonLatestRttOperSense has value other then 'ok' and 'other'. 'unknown' - Probe state is unkown when the rttMonLatestRttOperSense value is 'other'. For example: If there are 5 paths in the LPD group then this object output will look like 'ok,ok,ok,down,down'. This object will be set to '0' on reset.")
rttMonLpdGrpStatsResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsResetTime.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatsResetTime.setDescription('This object specifies the time when this statistics row was last reset using the rttMonApplLpdGrpStatsReset object.')
rttMonHistoryCollectionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1), )
if mibBuilder.loadTexts: rttMonHistoryCollectionTable.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionTable.setDescription("The history collection database. The history table contains a point by point rolling history of the most recent RTT operations for each conceptual RTT control row. The rolling history of this information is maintained in a series of 'live(s)', each containing a series of 'bucket(s)', each 'bucket' contains a series of 'sample(s)'. Each conceptual history row can have lives. A life is defined by the rttMonCtrlOperRttLife object. A new life will be created when rttMonCtrlOperState transitions 'active'. When the number of lives become greater than rttMonHistoryAdminNumLives the oldest life will be discarded and a new life will be created by incrementing the index. The path exploration RTT operation will be kept as an entry in this table.")
rttMonHistoryCollectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHistoryCollectionLifeIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHistoryCollectionBucketIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHistoryCollectionSampleIndex"))
if mibBuilder.loadTexts: rttMonHistoryCollectionEntry.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionEntry.setDescription("A list of history objects that are recorded for each RTT operation. The history collection table has four indices. Each described as follows: - The first index correlates its entries to a conceptual RTT control row via the rttMonCtrlAdminIndex object. - The second index uniquely identifies the results of each 'life' as defined by the rttMonCtrlOperRttLife object. - The third index uniquely identifies the number of buckets in a life. A bucket will contain one sample per bucket if the rttMonCtrlAdminRttType object is set to any value other than 'pathEcho'. If the rttMonCtrlAdminRttType object is set to 'pathEcho', a bucket will contain one sample per hop along a path to the target (including the target). - The fourth index uniquely identifies the number of samples in a bucket. Again, if the rttMonCtrlAdminRttType object is set to 'pathEcho', this value is associated with each hop in an ascending order, thus for the first hop on a path, this index will be 1, the second will be 2 and so on. For all other values of rttMonCtrlAdminRttType this will be 1.")
rttMonHistoryCollectionLifeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonHistoryCollectionLifeIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionLifeIndex.setDescription('This uniquely defines a life for a conceptual history row. For a particular value of rttMonHistoryCollectionLifeIndex, the agent assigns the first value of 1, the second value of 2, and so on. The sequence keeps incrementing, despite older (lower) values being removed from the table.')
rttMonHistoryCollectionBucketIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rttMonHistoryCollectionBucketIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionBucketIndex.setDescription("When the RttMonRttType is 'pathEcho', this uniquely defines a bucket for a given value of rttMonHistoryCollectionLifeIndex. For all other RttMonRttType this value will be the number of operations per a lifetime. Thus, this object increments on each operation attempt. For a particular value of rttMonHistoryCollectionLifeIndex, the agent assigns the first value of 1, the second value of 2, and so on. The sequence keeps incrementing until the number of buckets equals rttMonHistoryAdminNumBuckets, after which the most recent rttMonHistoryAdminNumBuckets buckets are retained (the index is incremented though).")
rttMonHistoryCollectionSampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)))
if mibBuilder.loadTexts: rttMonHistoryCollectionSampleIndex.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionSampleIndex.setDescription("This uniquely defines a row for a given value of rttMonHistoryCollectionBucketIndex. This object represents a hop along a path to the Target. For a particular value of rttMonHistoryCollectionBucketIndex, the agent assigns the first value of 1, the second value of 2, and so on. The sequence keeps incrementing until the number of samples equals rttMonHistoryAdminNumSamples, then no new samples are created for the current rttMonHistoryCollectionBucketIndex. When the RttMonRttType is 'pathEcho', this value directly represents the number of hops along a path to a target, thus we can only support 512 hops. For all other values of RttMonRttType this object will be one.")
rttMonHistoryCollectionSampleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionSampleTime.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionSampleTime.setDescription('The time that the RTT operation was initiated.')
rttMonHistoryCollectionAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 5), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionAddress.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionAddress.setDescription("When the RttMonRttType is 'echo' or 'pathEcho' this is a string which specifies the address of the target for the this RTT operation. For all other values of RttMonRttType this string will be null. This address will be the address of the hop along the path to the rttMonEchoAdminTargetAddress address, including rttMonEchoAdminTargetAddress address, or just the rttMonEchoAdminTargetAddress address, when the path information is not collected. This behavior is defined by the rttMonCtrlAdminRttType object. The interpretation of this string depends on the type of RTT operation selected, as specified by the rttMonEchoAdminProtocol object. See rttMonEchoAdminTargetAddress for a complete description.")
rttMonHistoryCollectionCompletionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 6), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionCompletionTime.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionCompletionTime.setDescription('This is the operation completion time of the RTT operation. If the RTT operation fails (rttMonHistoryCollectionSense is any value other than ok), this has a value of 0.')
rttMonHistoryCollectionSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 7), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionSense.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionSense.setDescription('A sense code for the completion status of the RTT operation.')
rttMonHistoryCollectionApplSpecificSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionApplSpecificSense.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionApplSpecificSense.setDescription("An application specific sense code for the completion status of the last RTT operation. This object will only be valid when the rttMonHistoryCollectionSense object is set to 'applicationSpecific'. Otherwise, this object's value is not valid.")
rttMonHistoryCollectionSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionSenseDescription.setStatus('current')
if mibBuilder.loadTexts: rttMonHistoryCollectionSenseDescription.setDescription("A sense description for the completion status of the last RTT operation when the rttMonHistoryCollectionSense object is set to 'applicationSpecific'.")
rttMonNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 2))
rttMonNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0))
rttMonConnectionChangeNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 1)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperConnectionLostOccurred"))
if mibBuilder.loadTexts: rttMonConnectionChangeNotification.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonConnectionChangeNotification.setDescription("This notification is only valid when the RttMonRttType is 'echo' or 'pathEcho'. A rttMonConnectionChangeNotification indicates that a connection to a target (not to a hop along the path to a target) has either failed on establishment or been lost and when reestablished. Precisely, this has resulted in rttMonCtrlOperConnectionLostOccurred changing value. If History is not being collected, the instance values for the rttMonHistoryCollectionAddress object will not be valid. When RttMonRttType is not 'echo' or 'pathEcho' the rttMonHistoryCollectionAddress object will be null. rttMonConnectionChangeNotification object is superseded by rttMonNotification.")
rttMonTimeoutNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 2)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperTimeoutOccurred"))
if mibBuilder.loadTexts: rttMonTimeoutNotification.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonTimeoutNotification.setDescription("A rttMonTimeoutNotification indicates the occurrence of a timeout for a RTT operation, and it indicates the clearing of such a condition by a subsequent RTT operation. Precisely, this has resulted in rttMonCtrlOperTimeoutOccurred changing value. When the RttMonRttType is 'pathEcho', this notification will only be sent when the timeout occurs during an operation to the target and not to a hop along the path to the target. This also applies to the clearing of the timeout. If History is not being collected, the instance values for the rttMonHistoryCollectionAddress object will not be valid. When RttMonRttType is not 'echo' or 'pathEcho' the rttMonHistoryCollectionAddress object will be null. rttMonTimeoutNotification object is superseded by rttMonNotification.")
rttMonThresholdNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 3)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOverThresholdOccurred"))
if mibBuilder.loadTexts: rttMonThresholdNotification.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonThresholdNotification.setDescription("A rttMonThresholdNotification indicates the occurrence of a threshold violation for a RTT operation, and it indicates the previous violation has subsided for a subsequent RTT operation. Precisely, this has resulted in rttMonCtrlOperOverThresholdOccurred changing value. When the RttMonRttType is 'pathEcho', this notification will only be sent when the threshold violation occurs during an operation to the target and not to a hop along the path to the target. This also applies to the subsiding of a threshold condition. If History is not being collected, the instance values for the rttMonHistoryCollectionAddress object will not be valid. When RttMonRttType is not 'echo' or 'pathEcho' the rttMonHistoryCollectionAddress object will be null. rttMonThresholdNotification object is superseded by rttMonNotification.")
rttMonVerifyErrorNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 4)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperVerifyErrorOccurred"))
if mibBuilder.loadTexts: rttMonVerifyErrorNotification.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonVerifyErrorNotification.setDescription('A rttMonVerifyErrorNotification indicates the occurrence of a data corruption in an RTT operation. rttMonVerifyErrorNotification object is superseded by rttMonNotification.')
rttMonNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 5)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonReactVar"), ("CISCO-RTTMON-MIB", "rttMonReactOccurred"), ("CISCO-RTTMON-MIB", "rttMonReactValue"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdRising"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPSelector"))
if mibBuilder.loadTexts: rttMonNotification.setStatus('deprecated')
if mibBuilder.loadTexts: rttMonNotification.setDescription("A rttMonNotification indicates the occurrence of a threshold violation, and it indicates the previous violation has subsided for a subsequent operation. When the RttMonRttType is 'pathEcho', this notification will only be sent when the threshold violation occurs during an operation to the target and not to a hop along the path to the target. This also applies to the subsiding of a threshold condition. If History is not being collected, the instance values for the rttMonHistoryCollectionAddress object will not be valid. When RttMonRttType is not 'echo' or 'pathEcho' the rttMonHistoryCollectionAddress object will be null. rttMonReactVar defines the type of reaction that is configured for the probe ( e.g jitterAvg, rtt etc ). In the rttMonReactTable there are trap definitions for the probes and each probe may have more than one trap definitions for various types ( e.g rtt, jitterAvg, packetLoossSD etc ). So the object rttMonReactVar indicates the type ( e.g. rtt, packetLossSD, timeout etc ) for which threshold violation traps has been generated. The object rttMonEchoAdminLSPSelector will be valid only for the probes based on 'mplsLspPingAppl' RttMonProtocol. For all other probes it will be null. rttMonNotification object is superseded by rttMonNotificationV2.")
rttMonLpdDiscoveryNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 6)).setObjects(("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTag"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsTargetPE"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailCause"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailOccurred"))
if mibBuilder.loadTexts: rttMonLpdDiscoveryNotification.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdDiscoveryNotification.setDescription("A rttMonLpdDiscoveryNotification indicates that the LSP Path Discovery to the target PE has failed, and it also indicates the clearing of such condition. Precisely this has resulted in rttMonLpdGrpStatsLPDFailOccurred changing value. When the rttMonLpdGrpStatsLPDFailOccurred is 'false', the instance value for rttMonLpdGrpStatsLPDFailCause is not valid.")
rttMonLpdGrpStatusNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 7)).setObjects(("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTag"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsTargetPE"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupStatus"))
if mibBuilder.loadTexts: rttMonLpdGrpStatusNotification.setStatus('current')
if mibBuilder.loadTexts: rttMonLpdGrpStatusNotification.setDescription('A rttMonLpdGrpStatusNotification indicates that the LPD Group status rttMonLpdGrpStatsGroupStatus has changed indicating some connectivity change to the target PE. This has resulted in rttMonLpdGrpStatsGroupStatus changing value.')
rttMonNotificationV2 = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 8)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminLongTag"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonReactVar"), ("CISCO-RTTMON-MIB", "rttMonReactOccurred"), ("CISCO-RTTMON-MIB", "rttMonReactValue"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdRising"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPSelector"))
if mibBuilder.loadTexts: rttMonNotificationV2.setStatus('current')
if mibBuilder.loadTexts: rttMonNotificationV2.setDescription('A rttMonNotification indicates the occurrence of a threshold violation, and it indicates the previous violation has subsided for a subsequent operation. Enhanced version of rttMonNotification which replaces rttMonCtrlAdminTag with rttMonCtrlAdminLongTag object.')
ciscoRttMonMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 3))
ciscoRttMonMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1))
ciscoRttMonMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2))
ciscoRttMonMibComplianceRev12 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 12)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev12 = ciscoRttMonMibComplianceRev12.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev12.setDescription('The compliance statement for new MIB extensions for (1) supporting LSP Path Discovery for Auto SAA L3 MPLS VPN. (2) Group Scheduler Enhancement.')
ciscoRttMonMibComplianceRev13 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 13)).setObjects(("CISCO-RTTMON-MIB", "ciscoRttMonDeprecatedGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev13 = ciscoRttMonMibComplianceRev13.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev13.setDescription('The compliance statement for the deprecated groups.')
ciscoRttMonMibComplianceRev14 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 14)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev14 = ciscoRttMonMibComplianceRev14.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev14.setDescription('The compliance statement for new MIB extensions for (1) supporting LSP Path Discovery for Auto SAA L3 MPLS VPN. (2) Group Scheduler Enhancement.')
ciscoRttMonMibComplianceRev15 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 15)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev15 = ciscoRttMonMibComplianceRev15.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev15.setDescription('The compliance statement for new MIB extensions for supporting Ethernet CFM for Virtual Connection.')
ciscoRttMonMibComplianceRev16 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 16)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev16 = ciscoRttMonMibComplianceRev16.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev16.setDescription('The compliance statement for new MIB extensions for supporting high order 32 bit of RTT and OW statistics for jitter probe.')
ciscoRttMonMibComplianceRev17 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 17)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev17 = ciscoRttMonMibComplianceRev17.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev17.setDescription('The compliance statement for new MIB extensions for supporting high order 32 bit of RTT and OW statistics for jitter probe.')
ciscoRttMonMibComplianceRev18 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 18)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev18 = ciscoRttMonMibComplianceRev18.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev18.setDescription('The compliance statement for new MIB extensions for supporting high order 32 bit of RTT and OW statistics for jitter probe.')
ciscoRttMonMibComplianceRev19 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 19)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev19 = ciscoRttMonMibComplianceRev19.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev19.setDescription('The compliance statement for new MIB extensions for supporting high order 32 bit of RTT and OW statistics for jitter probe.')
ciscoRttMonMibComplianceRev20 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 20)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev24"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev25"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev23"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev20 = ciscoRttMonMibComplianceRev20.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev20.setDescription('This compliance statement specifies the minimal requirements an implementation must meet in order to claim full compliance with the definition of the CISCO- RTTMON-MIB.')
ciscoRttMonMibComplianceRev21 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 21)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev24"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev25"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev28"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev23"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev26"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev27"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev21 = ciscoRttMonMibComplianceRev21.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev21.setDescription('Please enter description here')
ciscoRttMonMibComplianceRev22 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 22)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev24"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev25"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev28"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev23"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev26"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev27"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev29"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev22 = ciscoRttMonMibComplianceRev22.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev22.setDescription('The compliance statement for CISCO-RTTMON-MIB')
ciscoRttMonMibComplianceRev23 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 23)).setObjects(("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev24"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev25"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev28"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev23"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev26"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev27"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev29"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev30"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev31"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev3"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonMibComplianceRev23 = ciscoRttMonMibComplianceRev23.setStatus('current')
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev23.setDescription('The compliance statement for CISCO-RTTMON-MIB')
ciscoStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 3)).setObjects(("CISCO-RTTMON-MIB", "rttMonStatsCaptureCompletions"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureOverThresholds"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureSumCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureSumCompletionTime2Low"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureSumCompletionTime2High"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureCompletionTimeMax"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureCompletionTimeMin"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectNumDisconnects"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectTimeouts"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectBusies"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectNoConnections"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectDrops"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectSequenceErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectVerifyErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectAddress"), ("CISCO-RTTMON-MIB", "rttMonStatsTotalsElapsedTime"), ("CISCO-RTTMON-MIB", "rttMonStatsTotalsInitiations"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroup = ciscoStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroup.setDescription('A collection of objects providing accumulated statistical history.')
ciscoHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 4)).setObjects(("CISCO-RTTMON-MIB", "rttMonHistoryCollectionSampleTime"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionSense"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionApplSpecificSense"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionSenseDescription"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoHistoryGroup = ciscoHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoHistoryGroup.setDescription('A collection of objects providing point by point history of each RTT operation.')
ciscoCtrlGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 5)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetPort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSourcePort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminControlEnable"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTOS"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSREnable"), ("CISCO-RTTMON-MIB", "rttMonEchoPathAdminHopAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev1 = ciscoCtrlGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev1.setDescription('A collection of objects that were added to enhance the functionality of the RTT application.')
ciscoCtrlGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 6)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetAddressString"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminNameServer"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOperation"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminHTTPVersion"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminURL"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCache"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminInterval"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminNumPackets"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProxy"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString1"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString2"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString3"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString4"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString5"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev2 = ciscoCtrlGroupRev2.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev2.setDescription('A collection of objects that were added to enhance the functionality of the RTT application to configure HTTP, DNS and Jitter probes.')
ciscoLatestOperGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 7)).setObjects(("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperDNSRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperTCPConnectRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperTransactionRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperMessageBodyOctets"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperSense"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPErrorSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSum"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSum2"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTMin"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTMax"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2PositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2NegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2PositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2NegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketLossSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketLossDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketOutOfSequence"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketMIA"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketLateArrival"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSense"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterErrorSenseDescription"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLatestOperGroupRev1 = ciscoLatestOperGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoLatestOperGroupRev1.setDescription('A collection of objects that were added to store the latest operational results for HTTP, DNS and Jitter probes.')
ciscoStatsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 8)).setObjects(("CISCO-RTTMON-MIB", "rttMonHTTPStatsCompletions"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsOverThresholds"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTSum"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTSum2Low"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTSum2High"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTMin"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTMax"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsDNSRTTSum"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTCPConnectRTTSum"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTransactionRTTSum"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsMessageBodyOctetsSum"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsDNSServerTimeout"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTCPConnectTimeout"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTransactionTimeout"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsDNSQueryError"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsHTTPError"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsError"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsBusies"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsCompletions"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOverThresholds"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfRTT"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSum"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSum2Low"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSum2High"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTMin"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTMax"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesSDLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesSDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesSDLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesSDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesDSLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesDSHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesDSLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesDSHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketLossSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketLossDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketOutOfSequence"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketMIA"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketLateArrival"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsError"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsBusies"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev1 = ciscoStatsGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev1.setDescription("A collection of objects that were added to enhance the functionality of the RTT application to store 'HTTP' and 'Jitter' probes statistics.")
ciscoApplGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 11)).setObjects(("CISCO-RTTMON-MIB", "rttMonApplResponder"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyChain"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString1"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString2"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString3"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString4"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString5"), ("CISCO-RTTMON-MIB", "rttMonApplAuthStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoApplGroupRev2 = ciscoApplGroupRev2.setStatus('current')
if mibBuilder.loadTexts: ciscoApplGroupRev2.setDescription('These objects provide support for configuring responder on a router and also configure authentication information.')
ciscoCtrlGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 12)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminVrfName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev4 = ciscoCtrlGroupRev4.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev4.setDescription('A collection of objects that were added to enhance the functionality of the RTT application.')
ciscoStatsGroupRev3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 14)).setObjects(("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2SD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMinSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMaxSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2DS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMinDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMaxDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfOW"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2SDLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2SDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2DSLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2DSHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfOW"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinSDNew"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxSDNew"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinDSNew"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxDSNew"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev3 = ciscoStatsGroupRev3.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev3.setDescription("A collection of objects that were added to enhance the functionality of the RTT application to store one way 'Jitter' probes statistics.")
ciscoCtrlGroupRev6 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 16)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecType"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecInterval"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecPayload"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecNumPackets"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminICPIFAdvFactor"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev6 = ciscoCtrlGroupRev6.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev6.setDescription('A collection of objects that were added to enhance the functionality of the RTT application.')
ciscoStatsGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 17)).setObjects(("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMOS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperICPIF"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfMOS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfMOS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfICPIF"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfICPIF"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev4 = ciscoStatsGroupRev4.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev4.setDescription("A collection of objects that were added to enhance the functionality of the RTT application to store MOS and ICPIF for 'Jitter' probe statistics.")
ciscoNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 18)).setObjects(("CISCO-RTTMON-MIB", "rttMonConnectionChangeNotification"), ("CISCO-RTTMON-MIB", "rttMonTimeoutNotification"), ("CISCO-RTTMON-MIB", "rttMonThresholdNotification"), ("CISCO-RTTMON-MIB", "rttMonVerifyErrorNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoNotificationGroup = ciscoNotificationGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoNotificationGroup.setDescription('A collection of notifications. ciscoNotificationGroup object is superseded by ciscoNotificationGroupRev1.')
ciscoApplGroupRev3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 19)).setObjects(("CISCO-RTTMON-MIB", "rttMonApplVersion"), ("CISCO-RTTMON-MIB", "rttMonApplMaxPacketDataSize"), ("CISCO-RTTMON-MIB", "rttMonApplTimeOfLastSet"), ("CISCO-RTTMON-MIB", "rttMonApplSupportedRttTypesValid"), ("CISCO-RTTMON-MIB", "rttMonApplSupportedProtocolsValid"), ("CISCO-RTTMON-MIB", "rttMonApplNumCtrlAdminEntry"), ("CISCO-RTTMON-MIB", "rttMonApplReset"), ("CISCO-RTTMON-MIB", "rttMonApplProbeCapacity"), ("CISCO-RTTMON-MIB", "rttMonApplFreeMemLowWaterMark"), ("CISCO-RTTMON-MIB", "rttMonApplLatestSetError"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoApplGroupRev3 = ciscoApplGroupRev3.setStatus('current')
if mibBuilder.loadTexts: ciscoApplGroupRev3.setDescription('A collection of objects providing the RTT Monitoring Application defaults. This group of information is provided to the agent when the Application starts.')
ciscoCtrlGroupRev7 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 20)).setObjects(("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttRecurring"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminProbes"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminPeriod"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminFrequency"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminLife"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminAgeout"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev7 = ciscoCtrlGroupRev7.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev7.setDescription('A collection of objects that were added to enhance the scheduling functionality of the RTT application.')
ciscoCtrlGroupRev8 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 21)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPFECType"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPSelector"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPReplyMode"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPTTL"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPExp"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlRttType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlVrfName"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTag"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlThreshold"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTimeout"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlScanInterval"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlDelScanFactor"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlEXP"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlRequestSize"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlVerifyData"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlStorageType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlProbeList"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlStatus"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeInterval"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeNumPackets"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeDestPort"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeSecFreqType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeSecFreqValue"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLspSelector"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLSPReplyMode"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLSPTTL"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonScheduleRttStartTime"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonSchedulePeriod"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonScheduleFrequency"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactConnectionEnable"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactTimeoutEnable"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactThresholdType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactThresholdCount"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactActionType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev8 = ciscoCtrlGroupRev8.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev8.setDescription('A collection of objects that were added to support (1) echo operations support based on MPLS LSP Ping, (2) pathEcho operations support based on MPLS LSP Ping and (3) Auto SAA L3 MPLS VPN enhancement.')
ciscoStatsGroupRev5 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 22)).setObjects(("CISCO-RTTMON-MIB", "rttMonJitterStatsIAJOut"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsIAJIn"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsAvgJitter"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsAvgJitterSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsAvgJitterDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsUnSyncRTs"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperIAJIn"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperIAJOut"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperAvgJitter"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperAvgSDJ"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperAvgDSJ"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWAvgSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWAvgDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNTPState"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperUnSyncRTs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev5 = ciscoStatsGroupRev5.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev5.setDescription('A collection of objects that are added to report intera-rrival Jitter, average jitter and improve accuracy.')
ciscoCtrlGroupRev9 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 23)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminPrecision"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProbePakPriority"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOWNTPSyncTolAbs"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOWNTPSyncTolPct"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOWNTPSyncTolType"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCalledNumber"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminDetectPoint"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminGKRegistration"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev9 = ciscoCtrlGroupRev9.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev9.setDescription('A collection of objects that are added to enhance the jitter probe accuracy.')
ciscoCtrlGroupRev10 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 24)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminOwner"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminRttType"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminThreshold"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminFrequency"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTimeout"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminVerifyData"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminStatus"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminNvgen"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProtocol"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataRequestSize"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataResponseSize"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttLife"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttStartTime"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminConceptRowAgeout"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHourGroups"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumPaths"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHops"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumDistBuckets"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminDistInterval"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumLives"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumBuckets"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumSamples"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminFilter"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperModificationTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperDiagText"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperResetTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOctetsInUse"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperConnectionLostOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperTimeoutOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperVerifyErrorOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOverThresholdOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperNumRtts"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperRttLife"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperState"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSense"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperApplSpecificSense"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperTime"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperAddress"), ("CISCO-RTTMON-MIB", "rttMonReactTriggerAdminStatus"), ("CISCO-RTTMON-MIB", "rttMonReactTriggerOperState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev10 = ciscoCtrlGroupRev10.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoCtrlGroupRev10.setDescription('A collection of objects providing the Administration, Operational, Last Statistical values for the RTT Monitoring Application. ciscoCtrlGroupRev10 object is superseded by ciscoCtrlGroupRev28.')
ciscoCtrlGroupRev11 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 25)).setObjects(("CISCO-RTTMON-MIB", "rttMonReactVar"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdType"), ("CISCO-RTTMON-MIB", "rttMonReactActionType"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdRising"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdCountX"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdCountY"), ("CISCO-RTTMON-MIB", "rttMonReactValue"), ("CISCO-RTTMON-MIB", "rttMonReactOccurred"), ("CISCO-RTTMON-MIB", "rttMonReactStatus"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminFreqMax"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminFreqMin"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev11 = ciscoCtrlGroupRev11.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev11.setDescription('A collection of objects that were added for the reaction configuration of probe.')
ciscoNotificationGroupRev1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 26)).setObjects(("CISCO-RTTMON-MIB", "rttMonNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoNotificationGroupRev1 = ciscoNotificationGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoNotificationGroupRev1.setDescription('A collection of notifications.')
ciscoCtrlGroupRev12 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 27)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceVoicePort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCallDuration"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev12 = ciscoCtrlGroupRev12.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev12.setDescription('A collection of objects that were added for the configuration of rtp operation.')
ciscoCtrlGroupRev13 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 29)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPReplyDscp"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPNullShim"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlLpd"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlLpdGrpList"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlLpdCompTime"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLSPReplyDscp"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdMaxSessions"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdSessTimeout"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdEchoTimeout"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdEchoInterval"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdEchoNullShim"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdScanPeriod"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdStatHours"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactLpdNotifyType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactLpdRetryCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev13 = ciscoCtrlGroupRev13.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev13.setDescription('A collection of objects that were added for the parameters configuration of mpls based operations.')
ciscoStatsGroupRev7 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 30)).setObjects(("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsTargetPE"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsNumOfPass"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsNumOfFail"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsNumOfTimeout"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsAvgRTT"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMinRTT"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMaxRTT"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMinNumPaths"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMaxNumPaths"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDStartTime"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailOccurred"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailCause"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDCompTime"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupStatus"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupProbeIndex"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsProbeStatus"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsPathIds"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsResetTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev7 = ciscoStatsGroupRev7.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev7.setDescription('A collection of objects that are added for collecting the statistics for LSP Path Discovery Group.')
ciscoNotificationGroupRev2 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 31)).setObjects(("CISCO-RTTMON-MIB", "rttMonLpdDiscoveryNotification"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatusNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoNotificationGroupRev2 = ciscoNotificationGroupRev2.setStatus('current')
if mibBuilder.loadTexts: ciscoNotificationGroupRev2.setDescription('A collection of notifications added for supporting LSP Path Discovery.')
ciscoApplGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 32)).setObjects(("CISCO-RTTMON-MIB", "rttMonApplLpdGrpStatsReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoApplGroupRev4 = ciscoApplGroupRev4.setStatus('current')
if mibBuilder.loadTexts: ciscoApplGroupRev4.setDescription('This object is added to reset the LSP Path Discovery Stats.')
ciscoCtrlGroupRev14 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 33)).setObjects(("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminStartTime"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminAdd"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminDelete"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev14 = ciscoCtrlGroupRev14.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev14.setDescription('This object is added for group scheduler enhancement')
ciscoCtrlGroupRev15 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 34)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetMPID"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetDomainName"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetVLAN"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEthernetCOS"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev15 = ciscoCtrlGroupRev15.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev15.setDescription('These objects are added for Ethernet ping/jitter operation.')
ciscoRttMonObsoleteGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 35)).setObjects(("CISCO-RTTMON-MIB", "rttMonApplPreConfigedReset"), ("CISCO-RTTMON-MIB", "rttMonApplPreConfigedValid"), ("CISCO-RTTMON-MIB", "rttMonFileIOAdminFilePath"), ("CISCO-RTTMON-MIB", "rttMonFileIOAdminSize"), ("CISCO-RTTMON-MIB", "rttMonFileIOAdminAction"), ("CISCO-RTTMON-MIB", "rttMonScriptAdminName"), ("CISCO-RTTMON-MIB", "rttMonScriptAdminCmdLineParams"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonObsoleteGroupRev1 = ciscoRttMonObsoleteGroupRev1.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoRttMonObsoleteGroupRev1.setDescription('A collection of all objects that are obsolete.')
ciscoRttMonDeprecatedGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 36)).setObjects(("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxDS"), ("CISCO-RTTMON-MIB", "rttMonReactAdminConnectionEnable"), ("CISCO-RTTMON-MIB", "rttMonReactAdminTimeoutEnable"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdType"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdCount"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdCount2"), ("CISCO-RTTMON-MIB", "rttMonReactAdminActionType"), ("CISCO-RTTMON-MIB", "rttMonReactAdminVerifyErrorEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRttMonDeprecatedGroupRev1 = ciscoRttMonDeprecatedGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoRttMonDeprecatedGroupRev1.setDescription('A collection of all objects that are deprecated. ciscoRttMonDeprecatedGroupRev1 object is superseded by ciscoCtrlGroupRev11.')
ciscoCtrlGroupRev16 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 37)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPVccvID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev16 = ciscoCtrlGroupRev16.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev16.setDescription('These objects are added for LSP Ping Pseudowire operation.')
ciscoCtrlGroupRev17 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 38)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminGroupName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev17 = ciscoCtrlGroupRev17.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev17.setDescription('This object is added for IP SLA Auto Measure project.')
ciscoCtrlGroupRev18 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 39)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetEVC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev18 = ciscoCtrlGroupRev18.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev18.setDescription('This object is added for Ethernet ping/jitter operation.')
ciscoCtrlGroupRev19 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 41)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetMEPPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev19 = ciscoCtrlGroupRev19.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev19.setDescription('This object is added for Ethernet ping/jitter operation.')
ciscoStatsGroupRev8 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 40)).setObjects(("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSumHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSum2High"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumSDHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2SDHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumDSHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2DSHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSumHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumSDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumDSHigh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev8 = ciscoStatsGroupRev8.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev8.setDescription("A collection of objects that were added to store the high order 32 bits of RTT and one way latency statistics for 'jitter' probe.")
ciscoCtrlGroupRev20 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 43)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminVideoTrafficProfile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev20 = ciscoCtrlGroupRev20.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev20.setDescription('This object has been added for video operation.')
ciscoCtrlGroupRev21 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 44)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminDscp"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminReserveDsp"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminInputInterface"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev21 = ciscoCtrlGroupRev21.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev21.setDescription('This object has been added to support of DSCP marking, sender DSP reservation, and source interface for path congruence in video operation.')
ciscoCtrlGroupRev22 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 45)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateSourceAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateSourcePort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateTargetAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateTargetPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev22 = ciscoCtrlGroupRev22.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev22.setDescription('This object has been added to support of emulate source address, emulate source port, emulate target address and emulate target port for path congruence in video operation.')
ciscoCtrlGroupRev23 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 46)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetMacAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceMacAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceMPID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev23 = ciscoCtrlGroupRev23.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev23.setDescription('This group contains objects describing Y1731 operation.')
ciscoCtrlGroupRev24 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 47)).setObjects(("CISCO-RTTMON-MIB", "rttMonGeneratedOperCtrlAdminIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev24 = ciscoCtrlGroupRev24.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev24.setDescription('This object has been added to for Generated Oper Table.')
ciscoCtrlGroupRev25 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 48)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminEndPointListName"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSSM"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminControlRetry"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminControlTimeout"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminIgmpTreeInit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev25 = ciscoCtrlGroupRev25.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev25.setDescription('This object has been added to support Multicast operation.')
ciscoStatsGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 49)).setObjects(("CISCO-RTTMON-MIB", "rttMonControlEnableErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsRetrieveErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev2 = ciscoStatsGroupRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoStatsGroupRev2.setDescription('A collection of objects providing Multicast control request information. ciscoStatsGroupRev2 object is superseded by ciscoStatsGroupRev9.')
ciscoCtrlGroupRev26 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 50)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminEnableBurst"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminAggBurstCycles"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLossRatioNumFrames"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminAvailNumFrames"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev26 = ciscoCtrlGroupRev26.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev26.setDescription('New rttMonObjects related to the support of Y1731 Synthetic Loss Measurement.')
ciscoCtrlGroupRev27 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 51)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTstampOptimization"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev27 = ciscoCtrlGroupRev27.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev27.setDescription('The object is added to utilize lower layer (Hardware/Packet Processor) timestamping for improving accuracy of jitter probe statistics. Currently the object is supported for udp jitter operations.')
ciscoCtrlGroupRev28 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 52)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminOwner"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminRttType"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminThreshold"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminFrequency"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTimeout"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminVerifyData"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminStatus"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminNvgen"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProtocol"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataRequestSize"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataResponseSize"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttLife"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttStartTime"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHourGroups"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumPaths"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHops"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumDistBuckets"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminDistInterval"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumLives"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumBuckets"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumSamples"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminFilter"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperModificationTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperDiagText"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperResetTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOctetsInUse"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperConnectionLostOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperTimeoutOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperVerifyErrorOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOverThresholdOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperNumRtts"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperRttLife"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperState"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSense"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperApplSpecificSense"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperTime"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperAddress"), ("CISCO-RTTMON-MIB", "rttMonReactTriggerAdminStatus"), ("CISCO-RTTMON-MIB", "rttMonReactTriggerOperState"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminConceptRowAgeoutV2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev28 = ciscoCtrlGroupRev28.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev28.setDescription('A collection of objects providing the Administration, Operational, Last Statistical values for the RTT Monitoring Application. Deprecated rttMonScheduleAdminConceptRowAgeout and added new rttMonScheduleAdminConceptRowAgeoutV2 to consider 0 as default age out value.')
ciscoStatsGroupRev9 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 53)).setObjects(("CISCO-RTTMON-MIB", "rttMonStatsCollectCtrlEnErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectRetrieveErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev9 = ciscoStatsGroupRev9.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev9.setDescription('A collection of objects providing Multicast control request information.')
ciscoCtrlGroupRev29 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 54)).setObjects(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetSwitchId"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProfileId"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOutputInterface"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev29 = ciscoCtrlGroupRev29.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev29.setDescription('A collection of objects providing Fabric Path Echo probe information.')
ciscoNotificationGroupRev3 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 55)).setObjects(("CISCO-RTTMON-MIB", "rttMonNotificationV2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoNotificationGroupRev3 = ciscoNotificationGroupRev3.setStatus('current')
if mibBuilder.loadTexts: ciscoNotificationGroupRev3.setDescription('Added notification rttMonNotificationV2 with the enhanced rttMonCtrlAdminLongTag object')
ciscoCtrlGroupRev30 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 56)).setObjects(("CISCO-RTTMON-MIB", "rttMonScheduleAdminStartType"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminStartDelay"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminStartType"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminStartDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev30 = ciscoCtrlGroupRev30.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev30.setDescription('Object added to support Random Start-Time feature for group and sla probes.')
ciscoCtrlGroupRev31 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 57)).setObjects(("CISCO-RTTMON-MIB", "rttMonCtrlAdminLongTag"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCtrlGroupRev31 = ciscoCtrlGroupRev31.setStatus('current')
if mibBuilder.loadTexts: ciscoCtrlGroupRev31.setDescription('Object rttMonCtrlAdminLongTag added to enhance current tag object for capturing long descriptions.')
ciscoStatsGroupRev10 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 58)).setObjects(("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOverThresh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOverThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoStatsGroupRev10 = ciscoStatsGroupRev10.setStatus('current')
if mibBuilder.loadTexts: ciscoStatsGroupRev10.setDescription('A collection of objects providing over threshold statistics for jitter probes.')
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", ciscoRttMonMibComplianceRev16=ciscoRttMonMibComplianceRev16, rttMonJitterStatsMaxOfNegativesSD=rttMonJitterStatsMaxOfNegativesSD, rttMonLatestJitterOperMinOfPositivesSD=rttMonLatestJitterOperMinOfPositivesSD, rttMonApplProbeCapacity=rttMonApplProbeCapacity, rttMonCtrlOperRttLife=rttMonCtrlOperRttLife, rttMonEchoAdminString4=rttMonEchoAdminString4, rttMonReactThresholdCountY=rttMonReactThresholdCountY, rttMonLatestJitterOperSumOfNegativesSD=rttMonLatestJitterOperSumOfNegativesSD, rttMonHTTPStatsStartTimeIndex=rttMonHTTPStatsStartTimeIndex, rttMonGrpScheduleAdminTable=rttMonGrpScheduleAdminTable, ciscoRttMonMibComplianceRev18=ciscoRttMonMibComplianceRev18, rttMonStatsTotalsElapsedTime=rttMonStatsTotalsElapsedTime, rttMplsVpnMonCtrlStatus=rttMplsVpnMonCtrlStatus, ciscoCtrlGroupRev18=ciscoCtrlGroupRev18, ciscoCtrlGroupRev10=ciscoCtrlGroupRev10, rttMonLatestJitterOperTable=rttMonLatestJitterOperTable, rttMonCtrlOperVerifyErrorOccurred=rttMonCtrlOperVerifyErrorOccurred, rttMonEchoAdminProtocol=rttMonEchoAdminProtocol, rttMonGrpScheduleAdminStartTime=rttMonGrpScheduleAdminStartTime, rttMonJitterStatsMinOfPositivesSD=rttMonJitterStatsMinOfPositivesSD, rttMonLpdGrpStatsLPDFailCause=rttMonLpdGrpStatsLPDFailCause, rttMonLatestRttOperCompletionTime=rttMonLatestRttOperCompletionTime, rttMonLatestJitterOperIAJOut=rttMonLatestJitterOperIAJOut, rttMonCtrlAdminGroupName=rttMonCtrlAdminGroupName, rttMonReactAdminTimeoutEnable=rttMonReactAdminTimeoutEnable, rttMonReactTriggerOperState=rttMonReactTriggerOperState, rttMonHTTPStatsHTTPError=rttMonHTTPStatsHTTPError, rttMonJitterStatsSum2PositivesDSHigh=rttMonJitterStatsSum2PositivesDSHigh, rttMonReactOccurred=rttMonReactOccurred, rttMonReactAdminThresholdType=rttMonReactAdminThresholdType, rttMonApplLpdGrpStatsReset=rttMonApplLpdGrpStatsReset, rttMonReactActionType=rttMonReactActionType, rttMonHistoryCollectionSampleIndex=rttMonHistoryCollectionSampleIndex, rttMonEchoAdminCodecNumPackets=rttMonEchoAdminCodecNumPackets, rttMonStatsCollectVerifyErrors=rttMonStatsCollectVerifyErrors, rttMonHistoryCollectionSense=rttMonHistoryCollectionSense, rttMonLatestJitterOperSumOfPositivesDS=rttMonLatestJitterOperSumOfPositivesDS, rttMonApplNumCtrlAdminEntry=rttMonApplNumCtrlAdminEntry, ciscoRttMonObsoleteGroupRev1=ciscoRttMonObsoleteGroupRev1, rttMonLatestJitterOperOWMaxDS=rttMonLatestJitterOperOWMaxDS, rttMplsVpnMonReactTimeoutEnable=rttMplsVpnMonReactTimeoutEnable, rttMonEchoAdminTargetSwitchId=rttMonEchoAdminTargetSwitchId, rttMonHTTPStatsError=rttMonHTTPStatsError, rttMplsVpnMonCtrlStorageType=rttMplsVpnMonCtrlStorageType, rttMonJitterStatsOWSum2SDHigh=rttMonJitterStatsOWSum2SDHigh, rttMplsVpnMonReactLpdRetryCount=rttMplsVpnMonReactLpdRetryCount, rttMonStatisticsAdminEntry=rttMonStatisticsAdminEntry, rttMonLpdGrpStatsNumOfFail=rttMonLpdGrpStatsNumOfFail, rttMonLatestJitterOperPacketOutOfSequence=rttMonLatestJitterOperPacketOutOfSequence, rttMonEchoAdminURL=rttMonEchoAdminURL, rttMplsVpnMonCtrlScanInterval=rttMplsVpnMonCtrlScanInterval, rttMonStatsCollectCtrlEnErrors=rttMonStatsCollectCtrlEnErrors, rttMonLpdGrpStatsResetTime=rttMonLpdGrpStatsResetTime, rttMonEchoAdminInputInterface=rttMonEchoAdminInputInterface, rttMonEchoAdminLSPFECType=rttMonEchoAdminLSPFECType, rttMonLatestJitterOperOWAvgSD=rttMonLatestJitterOperOWAvgSD, rttMonStatsCaptureSumCompletionTime2High=rttMonStatsCaptureSumCompletionTime2High, rttMplsVpnMonCtrlVerifyData=rttMplsVpnMonCtrlVerifyData, rttMonLatestRttOperEntry=rttMonLatestRttOperEntry, rttMonHistoryCollectionCompletionTime=rttMonHistoryCollectionCompletionTime, rttMonScheduleAdminConceptRowAgeoutV2=rttMonScheduleAdminConceptRowAgeoutV2, rttMonJitterStatsOWSumSDHigh=rttMonJitterStatsOWSumSDHigh, ciscoApplGroupRev2=ciscoApplGroupRev2, rttMplsVpnMonScheduleEntry=rttMplsVpnMonScheduleEntry, rttMonApplAuthStatus=rttMonApplAuthStatus, rttMonEchoAdminSourceVoicePort=rttMonEchoAdminSourceVoicePort, ciscoCtrlGroupRev9=ciscoCtrlGroupRev9, ciscoRttMonMibComplianceRev17=ciscoRttMonMibComplianceRev17, rttMonHistoryCollectionAddress=rttMonHistoryCollectionAddress, rttMplsVpnMonTypeLpdEchoNullShim=rttMplsVpnMonTypeLpdEchoNullShim, rttMonVerifyErrorNotification=rttMonVerifyErrorNotification, rttMplsVpnMonReactTable=rttMplsVpnMonReactTable, rttMonStatsCaptureStartTimeIndex=rttMonStatsCaptureStartTimeIndex, ciscoCtrlGroupRev6=ciscoCtrlGroupRev6, rttMonHTTPStatsTCPConnectTimeout=rttMonHTTPStatsTCPConnectTimeout, rttMonScheduleAdminConceptRowAgeout=rttMonScheduleAdminConceptRowAgeout, rttMonEchoAdminHTTPVersion=rttMonEchoAdminHTTPVersion, rttMonEchoAdminCodecPayload=rttMonEchoAdminCodecPayload, rttMonScriptAdminCmdLineParams=rttMonScriptAdminCmdLineParams, rttMonEchoAdminTargetMEPPort=rttMonEchoAdminTargetMEPPort, ciscoRttMonMibComplianceRev22=ciscoRttMonMibComplianceRev22, ciscoCtrlGroupRev12=ciscoCtrlGroupRev12, rttMonFileIOAdminEntry=rttMonFileIOAdminEntry, rttMonApplSupportedProtocolsValid=rttMonApplSupportedProtocolsValid, rttMonStatsCaptureCompletionTimeMin=rttMonStatsCaptureCompletionTimeMin, rttMonHTTPStatsRTTSum2High=rttMonHTTPStatsRTTSum2High, rttMonConnectionChangeNotification=rttMonConnectionChangeNotification, rttMonHTTPStatsRTTMax=rttMonHTTPStatsRTTMax, rttMonGrpScheduleAdminFreqMin=rttMonGrpScheduleAdminFreqMin, ciscoNotificationGroupRev3=ciscoNotificationGroupRev3, ciscoRttMonMibComplianceRev15=ciscoRttMonMibComplianceRev15, rttMonGeneratedOperCtrlAdminIndex=rttMonGeneratedOperCtrlAdminIndex, rttMonEchoAdminAggBurstCycles=rttMonEchoAdminAggBurstCycles, rttMonLatestHTTPOperEntry=rttMonLatestHTTPOperEntry, rttMonJitterStatsRTTSum2High=rttMonJitterStatsRTTSum2High, rttMonGrpScheduleAdminDelete=rttMonGrpScheduleAdminDelete, ciscoHistoryGroup=ciscoHistoryGroup, rttMplsVpnMonReactEntry=rttMplsVpnMonReactEntry, rttMplsVpnMonCtrlEXP=rttMplsVpnMonCtrlEXP, rttMonStatsTotalsEntry=rttMonStatsTotalsEntry, ciscoStatsGroupRev4=ciscoStatsGroupRev4, ciscoRttMonMIB=ciscoRttMonMIB, rttMonScheduleAdminEntry=rttMonScheduleAdminEntry, rttMonLatestJitterOperMOS=rttMonLatestJitterOperMOS, rttMonTimeoutNotification=rttMonTimeoutNotification, rttMonApplAuthKeyString1=rttMonApplAuthKeyString1, rttMonApplAuthIndex=rttMonApplAuthIndex, rttMonLatestJitterOperOWSum2SD=rttMonLatestJitterOperOWSum2SD, rttMonHistoryAdminNumLives=rttMonHistoryAdminNumLives, ciscoCtrlGroupRev1=ciscoCtrlGroupRev1, ciscoNotificationGroupRev2=ciscoNotificationGroupRev2, rttMonLpdGrpStatsNumOfTimeout=rttMonLpdGrpStatsNumOfTimeout, rttMonLpdGrpStatsAvgRTT=rttMonLpdGrpStatsAvgRTT, rttMonLatestOper=rttMonLatestOper, rttMonEchoAdminSourcePort=rttMonEchoAdminSourcePort, rttMonReactThresholdFalling=rttMonReactThresholdFalling, rttMonLatestRttOperSenseDescription=rttMonLatestRttOperSenseDescription, ciscoStatsGroupRev9=ciscoStatsGroupRev9, rttMonEchoAdminOWNTPSyncTolType=rttMonEchoAdminOWNTPSyncTolType, rttMonCtrlOperOverThresholdOccurred=rttMonCtrlOperOverThresholdOccurred, rttMonHTTPStatsOverThresholds=rttMonHTTPStatsOverThresholds, rttMonLatestJitterOperPacketLateArrival=rttMonLatestJitterOperPacketLateArrival, rttMplsVpnMonScheduleRttStartTime=rttMplsVpnMonScheduleRttStartTime, rttMonStatsCaptureCompletions=rttMonStatsCaptureCompletions, rttMonLatestHTTPOperTransactionRTT=rttMonLatestHTTPOperTransactionRTT, rttMonApplFreeMemLowWaterMark=rttMonApplFreeMemLowWaterMark, rttMonJitterStatsMinOfMOS=rttMonJitterStatsMinOfMOS, rttMonNotification=rttMonNotification, rttMplsVpnMonReactConnectionEnable=rttMplsVpnMonReactConnectionEnable, rttMplsVpnMonTypeLpdStatHours=rttMplsVpnMonTypeLpdStatHours, rttMonApplMaxPacketDataSize=rttMonApplMaxPacketDataSize, rttMonNotificationsPrefix=rttMonNotificationsPrefix, rttMonEchoPathAdminTable=rttMonEchoPathAdminTable, rttMonLatestJitterOperAvgJitter=rttMonLatestJitterOperAvgJitter, rttMonJitterStatsBusies=rttMonJitterStatsBusies, rttMonReactStatus=rttMonReactStatus, rttMonReactTriggerAdminStatus=rttMonReactTriggerAdminStatus, rttMonJitterStatsSumOfPositivesSD=rttMonJitterStatsSumOfPositivesSD, rttMonJitterStatsOWMinDS=rttMonJitterStatsOWMinDS, rttMonApplPreConfigedEntry=rttMonApplPreConfigedEntry, rttMonGrpScheduleAdminReset=rttMonGrpScheduleAdminReset, ciscoCtrlGroupRev2=ciscoCtrlGroupRev2, rttMonHTTPStatsRTTMin=rttMonHTTPStatsRTTMin, rttMonLatestJitterOperNTPState=rttMonLatestJitterOperNTPState, rttMonStatsRetrieveErrors=rttMonStatsRetrieveErrors, ciscoStatsGroupRev5=ciscoStatsGroupRev5, rttMonJitterStatsEntry=rttMonJitterStatsEntry, rttMonApplSupportedProtocolsTable=rttMonApplSupportedProtocolsTable, ciscoApplGroupRev4=ciscoApplGroupRev4, rttMonLatestJitterOperNumOfOW=rttMonLatestJitterOperNumOfOW, rttMonEchoAdminSourceMPID=rttMonEchoAdminSourceMPID, rttMonCtrlAdminLongTag=rttMonCtrlAdminLongTag, rttMplsVpnMonTypeTable=rttMplsVpnMonTypeTable, rttMonJitterStatsAvgJitter=rttMonJitterStatsAvgJitter, rttMonEchoAdminTargetVLAN=rttMonEchoAdminTargetVLAN, rttMonLatestHTTPErrorSenseDescription=rttMonLatestHTTPErrorSenseDescription, rttMonLpdGrpStatsMaxNumPaths=rttMonLpdGrpStatsMaxNumPaths, rttMonEchoAdminCodecType=rttMonEchoAdminCodecType, rttMonCtrlOperResetTime=rttMonCtrlOperResetTime, rttMonJitterStatsSum2PositivesDSLow=rttMonJitterStatsSum2PositivesDSLow, rttMonLatestJitterErrorSenseDescription=rttMonLatestJitterErrorSenseDescription, rttMonFileIOAdminFilePath=rttMonFileIOAdminFilePath, rttMonLatestHTTPOperTable=rttMonLatestHTTPOperTable, ciscoCtrlGroupRev20=ciscoCtrlGroupRev20, rttMplsVpnMonCtrlRttType=rttMplsVpnMonCtrlRttType, rttMonEchoAdminVideoTrafficProfile=rttMonEchoAdminVideoTrafficProfile, rttMonLatestHTTPOperSense=rttMonLatestHTTPOperSense, ciscoCtrlGroupRev4=ciscoCtrlGroupRev4, rttMonEchoAdminVrfName=rttMonEchoAdminVrfName, rttMonCtrlAdminNvgen=rttMonCtrlAdminNvgen, rttMonCtrlOperModificationTime=rttMonCtrlOperModificationTime, rttMonHistoryCollectionSampleTime=rttMonHistoryCollectionSampleTime, rttMonHTTPStatsRTTSum=rttMonHTTPStatsRTTSum, rttMonEchoAdminReserveDsp=rttMonEchoAdminReserveDsp, rttMonApplPreConfigedValid=rttMonApplPreConfigedValid, rttMonCtrlAdminTimeout=rttMonCtrlAdminTimeout, rttMonJitterStatsMinOfNegativesDS=rttMonJitterStatsMinOfNegativesDS, ciscoStatsGroupRev7=ciscoStatsGroupRev7, rttMonJitterStatsNumOfNegativesDS=rttMonJitterStatsNumOfNegativesDS, rttMonStats=rttMonStats, rttMonCtrl=rttMonCtrl, rttMonEchoAdminEmulateSourceAddress=rttMonEchoAdminEmulateSourceAddress, rttMonJitterStatsStartTimeIndex=rttMonJitterStatsStartTimeIndex, rttMonReactAdminVerifyErrorEnable=rttMonReactAdminVerifyErrorEnable, rttMonHistoryCollectionApplSpecificSense=rttMonHistoryCollectionApplSpecificSense, rttMonGeneratedOperTable=rttMonGeneratedOperTable, rttMonEchoAdminEntry=rttMonEchoAdminEntry, rttMonCtrlAdminOwner=rttMonCtrlAdminOwner, rttMonLatestJitterOperOWMinSD=rttMonLatestJitterOperOWMinSD, rttMonJitterStatsPacketOutOfSequence=rttMonJitterStatsPacketOutOfSequence, rttMonJitterStatsMinOfPositivesDS=rttMonJitterStatsMinOfPositivesDS, rttMonEchoAdminLSPExp=rttMonEchoAdminLSPExp, ciscoRttMonMibComplianceRev13=ciscoRttMonMibComplianceRev13, rttMonEchoAdminEndPointListName=rttMonEchoAdminEndPointListName, rttMonJitterStatsAvgJitterDS=rttMonJitterStatsAvgJitterDS, rttMonLatestJitterOperPacketMIA=rttMonLatestJitterOperPacketMIA, ciscoRttMonMibComplianceRev14=ciscoRttMonMibComplianceRev14, rttMonStatisticsAdminNumHourGroups=rttMonStatisticsAdminNumHourGroups, ciscoCtrlGroupRev17=ciscoCtrlGroupRev17, rttMonLatestRttOperApplSpecificSense=rttMonLatestRttOperApplSpecificSense, rttMonEchoAdminProbePakPriority=rttMonEchoAdminProbePakPriority, rttMonLpdGrpStatsEntry=rttMonLpdGrpStatsEntry, rttMonHTTPStatsTable=rttMonHTTPStatsTable, rttMonStatsCaptureDistIndex=rttMonStatsCaptureDistIndex, rttMonEchoAdminProfileId=rttMonEchoAdminProfileId, rttMonLpdGrpStatsGroupProbeIndex=rttMonLpdGrpStatsGroupProbeIndex, rttMonLpdGrpStatsGroupIndex=rttMonLpdGrpStatsGroupIndex, rttMonEchoAdminTargetEVC=rttMonEchoAdminTargetEVC, rttMonCtrlAdminEntry=rttMonCtrlAdminEntry, ciscoCtrlGroupRev31=ciscoCtrlGroupRev31, rttMonScheduleAdminRttRecurring=rttMonScheduleAdminRttRecurring, rttMonEchoAdminLSPTTL=rttMonEchoAdminLSPTTL, rttMonHistoryCollectionLifeIndex=rttMonHistoryCollectionLifeIndex, rttMonReactAdminConnectionEnable=rttMonReactAdminConnectionEnable, rttMonJitterStatsAvgJitterSD=rttMonJitterStatsAvgJitterSD, rttMonApplTimeOfLastSet=rttMonApplTimeOfLastSet, rttMonReactVar=rttMonReactVar, rttMonJitterStatsOWMaxDS=rttMonJitterStatsOWMaxDS, rttMonLatestJitterOperRTTSumHigh=rttMonLatestJitterOperRTTSumHigh, rttMonEchoAdminTargetMacAddress=rttMonEchoAdminTargetMacAddress, rttMonLatestJitterOperRTTMax=rttMonLatestJitterOperRTTMax, rttMplsVpnMonTypeLpdMaxSessions=rttMplsVpnMonTypeLpdMaxSessions, rttMonGrpScheduleAdminEntry=rttMonGrpScheduleAdminEntry, rttMonGrpScheduleAdminIndex=rttMonGrpScheduleAdminIndex, rttMonStatsCollectTable=rttMonStatsCollectTable, rttMplsVpnMonCtrlLpd=rttMplsVpnMonCtrlLpd, rttMonApplPreConfigedTable=rttMonApplPreConfigedTable, rttMonApplPreConfigedName=rttMonApplPreConfigedName, rttMonLatestJitterOperOWSum2DSHigh=rttMonLatestJitterOperOWSum2DSHigh, rttMonLatestJitterOperEntry=rttMonLatestJitterOperEntry, rttMonHTTPStatsRTTSum2Low=rttMonHTTPStatsRTTSum2Low, rttMonEchoAdminLSPVccvID=rttMonEchoAdminLSPVccvID, rttMonEchoAdminDetectPoint=rttMonEchoAdminDetectPoint, rttMonApplAuthTable=rttMonApplAuthTable, ciscoCtrlGroupRev19=ciscoCtrlGroupRev19, rttMonHistoryCollectionBucketIndex=rttMonHistoryCollectionBucketIndex, rttMonStatsCapturePathIndex=rttMonStatsCapturePathIndex, rttMonJitterStatsOWMinSD=rttMonJitterStatsOWMinSD, ciscoRttMonMibComplianceRev21=ciscoRttMonMibComplianceRev21, rttMplsVpnMonTypeLSPReplyMode=rttMplsVpnMonTypeLSPReplyMode, rttMonLatestJitterOperOWSumSD=rttMonLatestJitterOperOWSumSD, rttMonCtrlAdminFrequency=rttMonCtrlAdminFrequency, rttMonApplSupportedProtocols=rttMonApplSupportedProtocols, rttMplsVpnMonCtrlLpdCompTime=rttMplsVpnMonCtrlLpdCompTime, rttMonStatsCaptureCompletionTimeMax=rttMonStatsCaptureCompletionTimeMax, ciscoRttMonMibComplianceRev12=ciscoRttMonMibComplianceRev12, rttMonJitterStatsSumOfNegativesDS=rttMonJitterStatsSumOfNegativesDS, rttMonEchoAdminTable=rttMonEchoAdminTable, rttMonEchoAdminTargetMPID=rttMonEchoAdminTargetMPID, rttMonLatestJitterOperNumOfPositivesDS=rttMonLatestJitterOperNumOfPositivesDS, rttMonJitterStatsPacketMIA=rttMonJitterStatsPacketMIA, ciscoCtrlGroupRev23=ciscoCtrlGroupRev23, rttMonEchoAdminOperation=rttMonEchoAdminOperation, rttMonApplAuthKeyString2=rttMonApplAuthKeyString2)
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMonJitterStatsCompletions=rttMonJitterStatsCompletions, ciscoRttMonObjects=ciscoRttMonObjects, rttMonStatsCaptureEntry=rttMonStatsCaptureEntry, rttMonJitterStatsSum2NegativesDSHigh=rttMonJitterStatsSum2NegativesDSHigh, ciscoStatsGroupRev2=ciscoStatsGroupRev2, ciscoCtrlGroupRev22=ciscoCtrlGroupRev22, rttMonReactConfigIndex=rttMonReactConfigIndex, rttMonJitterStatsSum2NegativesSDHigh=rttMonJitterStatsSum2NegativesSDHigh, rttMonEchoAdminMode=rttMonEchoAdminMode, rttMonEchoAdminGKRegistration=rttMonEchoAdminGKRegistration, rttMonScheduleAdminTable=rttMonScheduleAdminTable, rttMplsVpnMonCtrlThreshold=rttMplsVpnMonCtrlThreshold, rttMonEchoAdminString5=rttMonEchoAdminString5, rttMonJitterStatsMaxOfNegativesDS=rttMonJitterStatsMaxOfNegativesDS, ciscoNotificationGroupRev1=ciscoNotificationGroupRev1, ciscoCtrlGroupRev15=ciscoCtrlGroupRev15, rttMonEchoAdminOWNTPSyncTolPct=rttMonEchoAdminOWNTPSyncTolPct, rttMonLpdGrpStatsMaxRTT=rttMonLpdGrpStatsMaxRTT, rttMonLatestJitterOperRTTSum2=rttMonLatestJitterOperRTTSum2, rttMonReactThresholdCountX=rttMonReactThresholdCountX, rttMonJitterStatsRTTMin=rttMonJitterStatsRTTMin, rttMplsVpnMonTypeSecFreqValue=rttMplsVpnMonTypeSecFreqValue, rttMonEchoAdminCache=rttMonEchoAdminCache, rttMplsVpnMonScheduleTable=rttMplsVpnMonScheduleTable, rttMplsVpnMonCtrlRequestSize=rttMplsVpnMonCtrlRequestSize, rttMonHTTPStatsCompletions=rttMonHTTPStatsCompletions, rttMonEchoAdminLSPReplyDscp=rttMonEchoAdminLSPReplyDscp, rttMonJitterStatsPacketLossSD=rttMonJitterStatsPacketLossSD, rttMonLatestJitterOperOWSum2SDHigh=rttMonLatestJitterOperOWSum2SDHigh, rttMplsVpnMonTypeNumPackets=rttMplsVpnMonTypeNumPackets, rttMonLatestJitterOperMinOfNegativesSD=rttMonLatestJitterOperMinOfNegativesSD, rttMonLatestJitterOperOWSumSDHigh=rttMonLatestJitterOperOWSumSDHigh, rttMonApplAuthKeyString4=rttMonApplAuthKeyString4, rttMonHTTPStatsDNSQueryError=rttMonHTTPStatsDNSQueryError, rttMonCtrlAdminIndex=rttMonCtrlAdminIndex, rttMonGeneratedOperEntry=rttMonGeneratedOperEntry, rttMonJitterStatsUnSyncRTs=rttMonJitterStatsUnSyncRTs, rttMonHistoryAdminFilter=rttMonHistoryAdminFilter, rttMonHistoryCollectionTable=rttMonHistoryCollectionTable, rttMonAppl=rttMonAppl, rttMonGeneratedOperRespIpAddrType=rttMonGeneratedOperRespIpAddrType, ciscoStatsGroupRev3=ciscoStatsGroupRev3, rttMonReactTriggerOperTable=rttMonReactTriggerOperTable, rttMonEchoAdminLSPNullShim=rttMonEchoAdminLSPNullShim, rttMonJitterStatsMaxOfMOS=rttMonJitterStatsMaxOfMOS, rttMonEchoAdminIgmpTreeInit=rttMonEchoAdminIgmpTreeInit, rttMonGrpScheduleAdminFrequency=rttMonGrpScheduleAdminFrequency, rttMonJitterStatsRTTSum2Low=rttMonJitterStatsRTTSum2Low, rttMonLatestJitterOperRTTSum=rttMonLatestJitterOperRTTSum, rttMonLpdDiscoveryNotification=rttMonLpdDiscoveryNotification, ciscoCtrlGroupRev16=ciscoCtrlGroupRev16, rttMonApplSupportedProtocolsEntry=rttMonApplSupportedProtocolsEntry, rttMonGrpScheduleAdminAdd=rttMonGrpScheduleAdminAdd, rttMonGrpScheduleAdminStartDelay=rttMonGrpScheduleAdminStartDelay, rttMonHistoryAdminTable=rttMonHistoryAdminTable, rttMonStatsCollectNumDisconnects=rttMonStatsCollectNumDisconnects, rttMonLatestHTTPOperRTT=rttMonLatestHTTPOperRTT, rttMonApplReset=rttMonApplReset, rttMonReactValue=rttMonReactValue, rttMonScheduleAdminRttLife=rttMonScheduleAdminRttLife, rttMonEchoAdminOWNTPSyncTolAbs=rttMonEchoAdminOWNTPSyncTolAbs, rttMonApplAuthKeyString3=rttMonApplAuthKeyString3, rttMonHistory=rttMonHistory, rttMonJitterStatsMinOfNegativesSD=rttMonJitterStatsMinOfNegativesSD, rttMonJitterStatsSum2NegativesSDLow=rttMonJitterStatsSum2NegativesSDLow, rttMonLatestJitterOperNumOverThresh=rttMonLatestJitterOperNumOverThresh, rttMplsVpnMonTypeInterval=rttMplsVpnMonTypeInterval, rttMplsVpnMonCtrlDelScanFactor=rttMplsVpnMonCtrlDelScanFactor, rttMonEchoAdminCodecInterval=rttMonEchoAdminCodecInterval, rttMonJitterStatsNumOverThresh=rttMonJitterStatsNumOverThresh, rttMplsVpnMonTypeLpdSessTimeout=rttMplsVpnMonTypeLpdSessTimeout, rttMplsVpnMonTypeLspSelector=rttMplsVpnMonTypeLspSelector, rttMonStatsCollectSequenceErrors=rttMonStatsCollectSequenceErrors, rttMonJitterStatsNumOfRTT=rttMonJitterStatsNumOfRTT, rttMonReactTriggerAdminTable=rttMonReactTriggerAdminTable, rttMonJitterStatsOWMaxSDNew=rttMonJitterStatsOWMaxSDNew, rttMonLatestRttOperTable=rttMonLatestRttOperTable, rttMonLatestRttOperTime=rttMonLatestRttOperTime, rttMplsVpnMonCtrlTable=rttMplsVpnMonCtrlTable, rttMonLatestJitterOperPacketLossDS=rttMonLatestJitterOperPacketLossDS, rttMonEchoAdminPrecision=rttMonEchoAdminPrecision, rttMonApplSupportedRttTypesEntry=rttMonApplSupportedRttTypesEntry, rttMonEchoPathAdminHopIndex=rttMonEchoPathAdminHopIndex, ciscoRttMonMibComplianceRev23=ciscoRttMonMibComplianceRev23, rttMonFileIOAdminTable=rttMonFileIOAdminTable, rttMonJitterStatsOWMaxSD=rttMonJitterStatsOWMaxSD, rttMonJitterStatsMinOfICPIF=rttMonJitterStatsMinOfICPIF, rttMonCtrlAdminTable=rttMonCtrlAdminTable, rttMonEchoAdminCalledNumber=rttMonEchoAdminCalledNumber, rttMonLatestJitterOperAvgDSJ=rttMonLatestJitterOperAvgDSJ, rttMplsVpnMonReactActionType=rttMplsVpnMonReactActionType, rttMonJitterStatsOWSumSD=rttMonJitterStatsOWSumSD, rttMonReactTriggerAdminRttMonCtrlAdminIndex=rttMonReactTriggerAdminRttMonCtrlAdminIndex, ciscoCtrlGroupRev26=ciscoCtrlGroupRev26, rttMonJitterStatsSumOfNegativesSD=rttMonJitterStatsSumOfNegativesSD, rttMonJitterStatsPacketLossDS=rttMonJitterStatsPacketLossDS, rttMonLatestJitterOperMaxOfNegativesDS=rttMonLatestJitterOperMaxOfNegativesDS, rttMonApplAuthKeyString5=rttMonApplAuthKeyString5, rttMplsVpnMonCtrlVrfName=rttMplsVpnMonCtrlVrfName, rttMonLpdGrpStatsStartTimeIndex=rttMonLpdGrpStatsStartTimeIndex, rttMplsVpnMonTypeLSPTTL=rttMplsVpnMonTypeLSPTTL, rttMonGrpScheduleAdminAgeout=rttMonGrpScheduleAdminAgeout, rttMonJitterStatsMaxOfICPIF=rttMonJitterStatsMaxOfICPIF, rttMonNotificationV2=rttMonNotificationV2, rttMonScheduleAdminStartDelay=rttMonScheduleAdminStartDelay, rttMonHistoryAdminNumSamples=rttMonHistoryAdminNumSamples, rttMonLatestJitterOperNumOfRTT=rttMonLatestJitterOperNumOfRTT, rttMonCtrlOperEntry=rttMonCtrlOperEntry, rttMonReactTriggerOperEntry=rttMonReactTriggerOperEntry, ciscoCtrlGroupRev13=ciscoCtrlGroupRev13, rttMonEchoAdminTOS=rttMonEchoAdminTOS, rttMonJitterStatsSum2NegativesDSLow=rttMonJitterStatsSum2NegativesDSLow, ciscoStatsGroupRev8=ciscoStatsGroupRev8, rttMonJitterStatsOWMaxDSNew=rttMonJitterStatsOWMaxDSNew, rttMonCtrlOperState=rttMonCtrlOperState, rttMonStatsCollectTimeouts=rttMonStatsCollectTimeouts, rttMonLatestJitterOperOWSumDSHigh=rttMonLatestJitterOperOWSumDSHigh, rttMonHistoryAdminNumBuckets=rttMonHistoryAdminNumBuckets, rttMonReactEntry=rttMonReactEntry, rttMonJitterStatsOWMinDSNew=rttMonJitterStatsOWMinDSNew, rttMonEchoAdminString2=rttMonEchoAdminString2, rttMonLatestJitterOperSumOfPositivesSD=rttMonLatestJitterOperSumOfPositivesSD, ciscoCtrlGroupRev29=ciscoCtrlGroupRev29, rttMonApplPreConfigedType=rttMonApplPreConfigedType, rttMonLatestJitterOperICPIF=rttMonLatestJitterOperICPIF, rttMplsVpnMonTypeLpdEchoTimeout=rttMplsVpnMonTypeLpdEchoTimeout, rttMonJitterStatsOWSumDSHigh=rttMonJitterStatsOWSumDSHigh, rttMonLatestJitterOperOWAvgDS=rttMonLatestJitterOperOWAvgDS, rttMonJitterStatsTable=rttMonJitterStatsTable, rttMonJitterStatsNumOfPositivesSD=rttMonJitterStatsNumOfPositivesSD, ciscoRttMonMibCompliances=ciscoRttMonMibCompliances, rttMonEchoAdminLSREnable=rttMonEchoAdminLSREnable, rttMplsVpnMonReactLpdNotifyType=rttMplsVpnMonReactLpdNotifyType, rttMonLatestJitterOperIAJIn=rttMonLatestJitterOperIAJIn, ciscoRttMonMibConformance=ciscoRttMonMibConformance, rttMonJitterStatsIAJIn=rttMonJitterStatsIAJIn, rttMonReactAdminActionType=rttMonReactAdminActionType, rttMonLatestRttOperAddress=rttMonLatestRttOperAddress, rttMonReactAdminTable=rttMonReactAdminTable, rttMonGrpScheduleAdminPeriod=rttMonGrpScheduleAdminPeriod, rttMonHistoryAdminEntry=rttMonHistoryAdminEntry, rttMonEchoAdminEmulateTargetAddress=rttMonEchoAdminEmulateTargetAddress, rttMonJitterStatsOWSum2DSHigh=rttMonJitterStatsOWSum2DSHigh, rttMonLatestJitterOperOWSum2DS=rttMonLatestJitterOperOWSum2DS, rttMonEchoAdminLSPReplyMode=rttMonEchoAdminLSPReplyMode, rttMonStatisticsAdminDistInterval=rttMonStatisticsAdminDistInterval, rttMonGrpScheduleAdminFreqMax=rttMonGrpScheduleAdminFreqMax, rttMonReactAdminThresholdCount2=rttMonReactAdminThresholdCount2, rttMonScriptAdminName=rttMonScriptAdminName, rttMplsVpnMonTypeDestPort=rttMplsVpnMonTypeDestPort, rttMonReactAdminThresholdFalling=rttMonReactAdminThresholdFalling, rttMonEchoAdminPktDataRequestSize=rttMonEchoAdminPktDataRequestSize, rttMonLatestJitterOperNumOfNegativesSD=rttMonLatestJitterOperNumOfNegativesSD, rttMonLatestJitterOperUnSyncRTs=rttMonLatestJitterOperUnSyncRTs, rttMonGrpScheduleAdminProbes=rttMonGrpScheduleAdminProbes, rttMonGeneratedOperRespIpAddr=rttMonGeneratedOperRespIpAddr, rttMonJitterStatsRTTSumHigh=rttMonJitterStatsRTTSumHigh, rttMonLpdGrpStatsLPDStartTime=rttMonLpdGrpStatsLPDStartTime, ciscoCtrlGroupRev11=ciscoCtrlGroupRev11, rttMonEchoAdminSourceMacAddress=rttMonEchoAdminSourceMacAddress, rttMonApplSupportedRttTypesTable=rttMonApplSupportedRttTypesTable, ciscoRttMonMibGroups=ciscoRttMonMibGroups, ciscoRttMonMibComplianceRev20=ciscoRttMonMibComplianceRev20, rttMonStatsCaptureSumCompletionTime2Low=rttMonStatsCaptureSumCompletionTime2Low, rttMplsVpnMonCtrlTag=rttMplsVpnMonCtrlTag, rttMonLpdGrpStatsNumOfPass=rttMonLpdGrpStatsNumOfPass, rttMonNotifications=rttMonNotifications, ciscoCtrlGroupRev30=ciscoCtrlGroupRev30, rttMonLatestJitterOperMaxOfPositivesSD=rttMonLatestJitterOperMaxOfPositivesSD, rttMonLpdGrpStatusNotification=rttMonLpdGrpStatusNotification, rttMonScheduleAdminRttStartTime=rttMonScheduleAdminRttStartTime, rttMonHTTPStatsTCPConnectRTTSum=rttMonHTTPStatsTCPConnectRTTSum, rttMonApplAuthKeyChain=rttMonApplAuthKeyChain, rttMonJitterStatsSumOfPositivesDS=rttMonJitterStatsSumOfPositivesDS, rttMonLatestHTTPOperMessageBodyOctets=rttMonLatestHTTPOperMessageBodyOctets, ciscoCtrlGroupRev21=ciscoCtrlGroupRev21, rttMonReactThresholdType=rttMonReactThresholdType, rttMonGrpScheduleAdminStartType=rttMonGrpScheduleAdminStartType, rttMonLpdGrpStatsPathIds=rttMonLpdGrpStatsPathIds, rttMonEchoAdminCallDuration=rttMonEchoAdminCallDuration, rttMonFileIOAdminSize=rttMonFileIOAdminSize, rttMonCtrlAdminTag=rttMonCtrlAdminTag, rttMonCtrlAdminThreshold=rttMonCtrlAdminThreshold, rttMonLatestJitterOperSumOfNegativesDS=rttMonLatestJitterOperSumOfNegativesDS, rttMonGrpScheduleAdminStatus=rttMonGrpScheduleAdminStatus, rttMonJitterStatsOWMinSDNew=rttMonJitterStatsOWMinSDNew, rttMonLatestJitterOperOWSumDS=rttMonLatestJitterOperOWSumDS, rttMonStatsCaptureOverThresholds=rttMonStatsCaptureOverThresholds, rttMplsVpnMonCtrlIndex=rttMplsVpnMonCtrlIndex, rttMplsVpnMonTypeLpdScanPeriod=rttMplsVpnMonTypeLpdScanPeriod, rttMonStatsCaptureHopIndex=rttMonStatsCaptureHopIndex, rttMonThresholdNotification=rttMonThresholdNotification, rttMonEchoAdminString3=rttMonEchoAdminString3, rttMonJitterStatsPacketLateArrival=rttMonJitterStatsPacketLateArrival, rttMonJitterStatsError=rttMonJitterStatsError, rttMonReactAdminThresholdCount=rttMonReactAdminThresholdCount, ciscoStatsGroupRev1=ciscoStatsGroupRev1, rttMonHTTPStatsTransactionRTTSum=rttMonHTTPStatsTransactionRTTSum, rttMonHTTPStatsDNSServerTimeout=rttMonHTTPStatsDNSServerTimeout, rttMonHistoryCollectionEntry=rttMonHistoryCollectionEntry, rttMonJitterStatsOWSumDS=rttMonJitterStatsOWSumDS, rttMonLpdGrpStatsProbeStatus=rttMonLpdGrpStatsProbeStatus, ciscoCtrlGroupRev14=ciscoCtrlGroupRev14, rttMonEchoAdminControlTimeout=rttMonEchoAdminControlTimeout, rttMonStatsCaptureSumCompletionTime=rttMonStatsCaptureSumCompletionTime, rttMonHTTPStatsBusies=rttMonHTTPStatsBusies, rttMonJitterStatsOverThresholds=rttMonJitterStatsOverThresholds, rttMonCtrlOperTable=rttMonCtrlOperTable, rttMonStatsCollectRetrieveErrors=rttMonStatsCollectRetrieveErrors, rttMonLpdGrpStatsMinRTT=rttMonLpdGrpStatsMinRTT, rttMonStatsCollectDrops=rttMonStatsCollectDrops, rttMonCtrlOperNumRtts=rttMonCtrlOperNumRtts, rttMonJitterStatsNumOfNegativesSD=rttMonJitterStatsNumOfNegativesSD, rttMonApplResponder=rttMonApplResponder, rttMonLpdGrpStatsGroupStatus=rttMonLpdGrpStatsGroupStatus, rttMonEchoAdminICPIFAdvFactor=rttMonEchoAdminICPIFAdvFactor, rttMonJitterStatsMaxOfPositivesDS=rttMonJitterStatsMaxOfPositivesDS, ciscoCtrlGroupRev27=ciscoCtrlGroupRev27, rttMonGrpScheduleAdminLife=rttMonGrpScheduleAdminLife, rttMonEchoAdminControlRetry=rttMonEchoAdminControlRetry, ciscoRttMonMibComplianceRev19=ciscoRttMonMibComplianceRev19, rttMonJitterStatsRTTMax=rttMonJitterStatsRTTMax, rttMonJitterStatsOWSum2DSLow=rttMonJitterStatsOWSum2DSLow, rttMonStatisticsAdminNumDistBuckets=rttMonStatisticsAdminNumDistBuckets, rttMonJitterStatsNumOfOW=rttMonJitterStatsNumOfOW, rttMplsVpnMonTypeEntry=rttMplsVpnMonTypeEntry, rttMonLatestJitterOperSum2NegativesSD=rttMonLatestJitterOperSum2NegativesSD, rttMonEchoAdminEnableBurst=rttMonEchoAdminEnableBurst, rttMonStatsCollectNoConnections=rttMonStatsCollectNoConnections, rttMonLatestJitterOperOWMinDS=rttMonLatestJitterOperOWMinDS, rttMonEchoAdminTargetPort=rttMonEchoAdminTargetPort, rttMonEchoAdminProxy=rttMonEchoAdminProxy, rttMonJitterStatsMaxOfPositivesSD=rttMonJitterStatsMaxOfPositivesSD, rttMonReactThresholdRising=rttMonReactThresholdRising, rttMonEchoAdminOutputInterface=rttMonEchoAdminOutputInterface, rttMonLatestJitterOperAvgSDJ=rttMonLatestJitterOperAvgSDJ, ciscoNotificationGroup=ciscoNotificationGroup, rttMonLatestJitterOperNumOfPositivesSD=rttMonLatestJitterOperNumOfPositivesSD, rttMonEchoAdminEthernetCOS=rttMonEchoAdminEthernetCOS, rttMplsVpnMonCtrlTimeout=rttMplsVpnMonCtrlTimeout, rttMonStatisticsAdminTable=rttMonStatisticsAdminTable, rttMonStatsCollectEntry=rttMonStatsCollectEntry, rttMonEchoAdminControlEnable=rttMonEchoAdminControlEnable, rttMonStatsTotalsTable=rttMonStatsTotalsTable, rttMonJitterStatsSum2PositivesSDLow=rttMonJitterStatsSum2PositivesSDLow, rttMonCtrlAdminRttType=rttMonCtrlAdminRttType, rttMonLatestHTTPOperTCPConnectRTT=rttMonLatestHTTPOperTCPConnectRTT, rttMplsVpnMonCtrlEntry=rttMplsVpnMonCtrlEntry, rttMonEchoPathAdminHopAddress=rttMonEchoPathAdminHopAddress, rttMonStatisticsAdminNumHops=rttMonStatisticsAdminNumHops, ciscoStatsGroup=ciscoStatsGroup, ciscoCtrlGroupRev8=ciscoCtrlGroupRev8, rttMplsVpnMonTypeSecFreqType=rttMplsVpnMonTypeSecFreqType, rttMonLatestHTTPOperDNSRTT=rttMonLatestHTTPOperDNSRTT)
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMonScriptAdminEntry=rttMonScriptAdminEntry, rttMonCtrlAdminStatus=rttMonCtrlAdminStatus, rttMonScriptAdminTable=rttMonScriptAdminTable, ciscoApplGroupRev3=ciscoApplGroupRev3, rttMonHTTPStatsMessageBodyOctetsSum=rttMonHTTPStatsMessageBodyOctetsSum, ciscoLatestOperGroupRev1=ciscoLatestOperGroupRev1, rttMonEchoAdminNameServer=rttMonEchoAdminNameServer, rttMonApplPreConfigedReset=rttMonApplPreConfigedReset, rttMonLpdGrpStatsMinNumPaths=rttMonLpdGrpStatsMinNumPaths, rttMonHTTPStatsTransactionTimeout=rttMonHTTPStatsTransactionTimeout, rttMplsVpnMonCtrlLpdGrpList=rttMplsVpnMonCtrlLpdGrpList, rttMonCtrlOperTimeoutOccurred=rttMonCtrlOperTimeoutOccurred, rttMonEchoAdminNumPackets=rttMonEchoAdminNumPackets, rttMonStatsTotalsInitiations=rttMonStatsTotalsInitiations, rttMonLatestJitterOperPacketLossSD=rttMonLatestJitterOperPacketLossSD, ciscoCtrlGroupRev28=ciscoCtrlGroupRev28, rttMonLatestJitterOperOWMaxSD=rttMonLatestJitterOperOWMaxSD, rttMonApplVersion=rttMonApplVersion, rttMonLatestJitterOperNumOfNegativesDS=rttMonLatestJitterOperNumOfNegativesDS, rttMplsVpnMonScheduleFrequency=rttMplsVpnMonScheduleFrequency, ciscoRttMonDeprecatedGroupRev1=ciscoRttMonDeprecatedGroupRev1, rttMonCtrlAdminVerifyData=rttMonCtrlAdminVerifyData, rttMonEchoAdminEmulateTargetPort=rttMonEchoAdminEmulateTargetPort, rttMonLatestJitterOperMinOfPositivesDS=rttMonLatestJitterOperMinOfPositivesDS, rttMonLpdGrpStatsTable=rttMonLpdGrpStatsTable, rttMonJitterStatsSum2PositivesSDHigh=rttMonJitterStatsSum2PositivesSDHigh, rttMonLatestJitterOperSense=rttMonLatestJitterOperSense, rttMonHTTPStatsDNSRTTSum=rttMonHTTPStatsDNSRTTSum, rttMonLatestJitterOperSum2NegativesDS=rttMonLatestJitterOperSum2NegativesDS, rttMonEchoAdminTargetAddress=rttMonEchoAdminTargetAddress, rttMplsVpnMonReactThresholdCount=rttMplsVpnMonReactThresholdCount, rttMonReactTable=rttMonReactTable, rttMonReactTriggerAdminEntry=rttMonReactTriggerAdminEntry, rttMplsVpnMonReactThresholdType=rttMplsVpnMonReactThresholdType, rttMonScheduleAdminStartType=rttMonScheduleAdminStartType, ciscoCtrlGroupRev24=ciscoCtrlGroupRev24, rttMonEchoPathAdminEntry=rttMonEchoPathAdminEntry, rttMonLatestJitterOperMinOfNegativesDS=rttMonLatestJitterOperMinOfNegativesDS, rttMonLatestJitterOperMaxOfPositivesDS=rttMonLatestJitterOperMaxOfPositivesDS, rttMonJitterStatsOWSum2SDLow=rttMonJitterStatsOWSum2SDLow, rttMonControlEnableErrors=rttMonControlEnableErrors, rttMonEchoAdminInterval=rttMonEchoAdminInterval, rttMonStatisticsAdminNumPaths=rttMonStatisticsAdminNumPaths, rttMonApplAuthEntry=rttMonApplAuthEntry, rttMonCtrlOperOctetsInUse=rttMonCtrlOperOctetsInUse, PYSNMP_MODULE_ID=ciscoRttMonMIB, rttMonLpdGrpStatsLPDFailOccurred=rttMonLpdGrpStatsLPDFailOccurred, ciscoStatsGroupRev10=ciscoStatsGroupRev10, rttMonEchoAdminPktDataResponseSize=rttMonEchoAdminPktDataResponseSize, rttMonLatestJitterOperMaxOfNegativesSD=rttMonLatestJitterOperMaxOfNegativesSD, rttMonLatestJitterOperRTTSum2High=rttMonLatestJitterOperRTTSum2High, rttMonStatsCollectBusies=rttMonStatsCollectBusies, ciscoCtrlGroupRev7=ciscoCtrlGroupRev7, rttMonReactAdminEntry=rttMonReactAdminEntry, rttMonApplSupportedRttTypesValid=rttMonApplSupportedRttTypesValid, rttMonLatestJitterOperSum2PositivesDS=rttMonLatestJitterOperSum2PositivesDS, rttMonCtrlOperDiagText=rttMonCtrlOperDiagText, rttMonEchoAdminTstampOptimization=rttMonEchoAdminTstampOptimization, rttMonJitterStatsIAJOut=rttMonJitterStatsIAJOut, rttMonLpdGrpStatsLPDCompTime=rttMonLpdGrpStatsLPDCompTime, rttMonCtrlOperConnectionLostOccurred=rttMonCtrlOperConnectionLostOccurred, ciscoCtrlGroupRev25=ciscoCtrlGroupRev25, rttMonEchoAdminSourceAddress=rttMonEchoAdminSourceAddress, rttMplsVpnMonTypeLSPReplyDscp=rttMplsVpnMonTypeLSPReplyDscp, rttMonEchoAdminLSPSelector=rttMonEchoAdminLSPSelector, rttMonEchoAdminString1=rttMonEchoAdminString1, rttMonStatsCaptureTable=rttMonStatsCaptureTable, rttMonEchoAdminLossRatioNumFrames=rttMonEchoAdminLossRatioNumFrames, rttMonStatsCollectAddress=rttMonStatsCollectAddress, rttMonEchoAdminTargetAddressString=rttMonEchoAdminTargetAddressString, rttMonLatestRttOperSense=rttMonLatestRttOperSense, rttMonHTTPStatsEntry=rttMonHTTPStatsEntry, rttMonJitterStatsRTTSum=rttMonJitterStatsRTTSum, rttMplsVpnMonCtrlProbeList=rttMplsVpnMonCtrlProbeList, rttMonEchoAdminTargetDomainName=rttMonEchoAdminTargetDomainName, rttMonFileIOAdminAction=rttMonFileIOAdminAction, rttMonHistoryCollectionSenseDescription=rttMonHistoryCollectionSenseDescription, rttMonEchoAdminSSM=rttMonEchoAdminSSM, rttMonEchoAdminAvailNumFrames=rttMonEchoAdminAvailNumFrames, rttMonApplLatestSetError=rttMonApplLatestSetError, rttMonEchoAdminDscp=rttMonEchoAdminDscp, rttMonLpdGrpStatsTargetPE=rttMonLpdGrpStatsTargetPE, rttMonJitterStatsNumOfPositivesDS=rttMonJitterStatsNumOfPositivesDS, rttMonEchoAdminEmulateSourcePort=rttMonEchoAdminEmulateSourcePort, rttMonApplSupportedRttTypes=rttMonApplSupportedRttTypes, rttMplsVpnMonSchedulePeriod=rttMplsVpnMonSchedulePeriod, rttMplsVpnMonTypeLpdEchoInterval=rttMplsVpnMonTypeLpdEchoInterval, rttMonLatestJitterOperSum2PositivesSD=rttMonLatestJitterOperSum2PositivesSD, rttMonLatestJitterOperRTTMin=rttMonLatestJitterOperRTTMin)

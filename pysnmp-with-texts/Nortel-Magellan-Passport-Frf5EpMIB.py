#
# PySNMP MIB module Nortel-Magellan-Passport-Frf5EpMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-Frf5EpMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:27:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
mcsMgrIndex, mcsMgr = mibBuilder.importSymbols("Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex", "mcsMgr")
RowStatus, Counter32, DisplayString, RowPointer, Integer32, StorageType, Unsigned32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowStatus", "Counter32", "DisplayString", "RowPointer", "Integer32", "StorageType", "Unsigned32")
NonReplicated, IntegerSequence, HexString, AsciiString = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "NonReplicated", "IntegerSequence", "HexString", "AsciiString")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Bits, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Counter64, TimeTicks, IpAddress, iso, Gauge32, Unsigned32, Integer32, MibIdentifier, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Bits", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Counter64", "TimeTicks", "IpAddress", "iso", "Gauge32", "Unsigned32", "Integer32", "MibIdentifier", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
frf5EpMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121))
mcsMgrFrf5EpG = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14))
mcsMgrFrf5EpGRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGRowStatusTable.setDescription('This entry controls the addition and deletion of mcsMgrFrf5EpG components.')
mcsMgrFrf5EpGRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpG component.')
mcsMgrFrf5EpGRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpG components. These components can be added and deleted.')
mcsMgrFrf5EpGComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpG tables.')
mcsMgrFrf5EpGIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8191)))
if mibBuilder.loadTexts: mcsMgrFrf5EpGIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpG tables.')
mcsMgrFrf5EpGAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2))
mcsMgrFrf5EpGAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mcsMgrFrf5EpGAddr components.')
mcsMgrFrf5EpGAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGAddrIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpGAddr component.')
mcsMgrFrf5EpGAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpGAddr components. These components cannot be added nor deleted.')
mcsMgrFrf5EpGAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpGAddr tables.')
mcsMgrFrf5EpGAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpGAddr tables.')
mcsMgrFrf5EpGAddrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 10), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrProvTable.setDescription('This group contains the provisionable attributes of the Address component.')
mcsMgrFrf5EpGAddrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGAddrIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrProvEntry.setDescription('An entry in the mcsMgrFrf5EpGAddrProvTable.')
mcsMgrFrf5EpGAddrRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 44))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrRemoteAddress.setDescription("This attribute specifies the ATM End System Address (AESA) in the ISO NSAP format that is used by each EndPoint under this Frf5EpG to establish a VCC. For example, NSAP ATM address '45000006138292323F000000000020480D002900'.")
mcsMgrFrf5EpGAddrCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 750)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrCommentText.setDescription('This optional attribute contains additional textual information to be added by the network operator.')
mcsMgrFrf5EpGAddrAddrPreTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 362), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreTable.setDescription("This attribute specifies the list of prefixes directed to the EndPoints under this Frf5EndPointGroup. The individual end point is selected for each subconnection on the basis of its supportedTransferPriorities. For example, E.164 prefix 'e.613722', X.121 prefix 'x.302'.")
mcsMgrFrf5EpGAddrAddrPreEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 362, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGAddrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGAddrAddrPreValue"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreEntry.setDescription('An entry in the mcsMgrFrf5EpGAddrAddrPreTable.')
mcsMgrFrf5EpGAddrAddrPreValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 362, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreValue.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreValue.setDescription('This variable represents both the value and the index for the mcsMgrFrf5EpGAddrAddrPreTable.')
mcsMgrFrf5EpGAddrAddrPreRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 2, 362, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGAddrAddrPreRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mcsMgrFrf5EpGAddrAddrPreTable.')
mcsMgrFrf5EpGEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3))
mcsMgrFrf5EpGEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpRowStatusTable.setDescription('This entry controls the addition and deletion of mcsMgrFrf5EpGEp components.')
mcsMgrFrf5EpGEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpGEp component.')
mcsMgrFrf5EpGEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpGEp components. These components can be added and deleted.')
mcsMgrFrf5EpGEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpGEp tables.')
mcsMgrFrf5EpGEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpGEp tables.')
mcsMgrFrf5EpGEpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mcsMgrFrf5EpGEpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStateEntry.setDescription('An entry in the mcsMgrFrf5EpGEpStateTable.')
mcsMgrFrf5EpGEpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mcsMgrFrf5EpGEpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mcsMgrFrf5EpGEpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mcsMgrFrf5EpGEpAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mcsMgrFrf5EpGEpProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mcsMgrFrf5EpGEpControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mcsMgrFrf5EpGEpAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mcsMgrFrf5EpGEpStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mcsMgrFrf5EpGEpUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mcsMgrFrf5EpGEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpOperTable.setDescription('This group contains the operational attributes for the FRF.5 ATM connection.')
mcsMgrFrf5EpGEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpOperEntry.setDescription('An entry in the mcsMgrFrf5EpGEpOperTable.')
mcsMgrFrf5EpGEpLastVccClearCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLastVccClearCause.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLastVccClearCause.setDescription('This attribute indicates the clear cause value of the last SPVC release message received on the FRF.5 end point Vcc pipe.')
mcsMgrFrf5EpGEpConnectionTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpConnectionTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpConnectionTransferPriority.setDescription('This attribute indicates the transfer priority used to establish the ATM connection and to multiplex the Frame Relay DLCIs.')
mcsMgrFrf5EpGEpServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ubr", 0), ("cbr", 1), ("rtVbr", 2), ("nrtVbr", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpServiceCategory.setDescription('This attribute indicates the ATM service category that is used for this connection.')
mcsMgrFrf5EpGEpPeakCellRate01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpPeakCellRate01.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpPeakCellRate01.setDescription('This attribute indicates the Peak Cell Rate (PCR) of the FRF.5 ATM VCC for all cells (with CLP=0 and CLP=1). The pcr01 is derived from the End Point traffic parameters using the conversion policy of the connectionTransferPriority. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpSustainedCellRate0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpSustainedCellRate0.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpSustainedCellRate0.setDescription('This attribute indicates the Sustained Cell Rate (SCR) of the FRF.5 ATM VCC for high priority cells (with CLP=0). The scr0 is derived from the End Point traffic parameters using the conversion policy of the connectionTransferPriority. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpSustainedCellRate01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpSustainedCellRate01.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpSustainedCellRate01.setDescription('This attribute indicates the Sustained Cell Rate (SCR) of the FRF.5 ATM VCC for all cells (with CLP=0 and CLP=1). The scr01 is derived from the End Point traffic parameters using the conversion policy of the connectionTransferPriority. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpMaximumBurstSize0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpMaximumBurstSize0.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpMaximumBurstSize0.setDescription('This attribute indicates the Maximum Burst Size (MBS) of the FRF.5 ATM VCC for high priority cells (with CLP=0). The mbs0 is derived from the End Point traffic parameters using the conversion policy of the connectionTransferPriority. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpMaximumBurstSize01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpMaximumBurstSize01.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpMaximumBurstSize01.setDescription('This attribute indicates the Maximum Burst Size (MBS) of the FRF.5 ATM VCC for all cells (with CLP=0 and CLP=1). The mbs01 is derived from the End Point traffic parameters using the conversion policy of the connectionTransferPriority. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpAvgFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAvgFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAvgFrameSize.setDescription('This attribute indicates the average frame size that is used in the traffic parameter conversion policy calculations for this end point.')
mcsMgrFrf5EpGEpTrafficParmConversionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6))).clone(namedValues=NamedValues(("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpTrafficParmConversionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpTrafficParmConversionPolicy.setDescription('This attribute indicates the traffic parameter conversion policy used to specify the equivalent ATM bandwidth rate at this end point. Policy 3 characterizes the traffic in the following way: - ATM traffic descriptor type 6 is selected - PCR0+1 is based on the AR - SCR0+1 is based on the CIR and EIR - MBS0+1 is based on Bc,Be,CIR,EIR and AR - Takes into account that the instananeous rate of the frame relay stream can burst above CIR and up tp the AR. Policy 4 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by UPC traffic policer. - PCR0+1 is based on the AR - SCR0 is based on the CIR - MBS0 is based on Bc,CIR and AR - There is no direct characterization of EIR. The allowed EIR can be derived using the difference between the AR and CIR. Policy 5 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected . Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by UPC traffic policer - PCR0+1 is based on CIR and EIR - SCR0 is based on the CIR - MBS0 is based on the Bc,CIR and AR - The maximum PCR is no longer based on AR but based on the CIR and EIR. Policy 6 characterizes the traffic in the following way: - ATM traffic descriptor type 3 is selected - PCR0+1 is based only on CIR.')
mcsMgrFrf5EpGEpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpType.setDescription('This attribute indicates the FRF.5 End Point type. If the value is master, this End Point is responsible for initiating the call to set up the FRF.5 ATM VCC. If the value is slave, this End Point receives call setup requests from the remote end.')
mcsMgrFrf5EpGEpLastVccCauseDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 11, 1, 20), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLastVccCauseDiag.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLastVccCauseDiag.setDescription('This attribute indicates the diagnostic value of the last SPVC release message received on the FRF.5 end point Vcc pipe.')
mcsMgrFrf5EpGEpLmi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2))
mcsMgrFrf5EpGEpLmiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiRowStatusTable.setDescription('This entry controls the addition and deletion of mcsMgrFrf5EpGEpLmi components.')
mcsMgrFrf5EpGEpLmiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpLmiIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpGEpLmi component.')
mcsMgrFrf5EpGEpLmiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpGEpLmi components. These components can be added and deleted.')
mcsMgrFrf5EpGEpLmiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGEpLmiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpGEpLmi tables.')
mcsMgrFrf5EpGEpLmiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpGEpLmi tables.')
mcsMgrFrf5EpGEpLmiParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiParmsTable.setDescription('This group contains the provisionable attributes of the Local Management Interface component.')
mcsMgrFrf5EpGEpLmiParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpLmiIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiParmsEntry.setDescription('An entry in the mcsMgrFrf5EpGEpLmiParmsTable.')
mcsMgrFrf5EpGEpLmiProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ansi", 2), ("ccitt", 3))).clone('ccitt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiProcedures.setDescription('This attribute selects the procedures to be used for the Local Management Interface. The following are the supported procedures: none: no Local Management Interface procedures are running on the ATM VCC. This accomodates remote interworking functions which do not implement LMI procedures. In this case, the remaining attributes of this group will be ignored. ccitt: Local Management Interface procedures from the CCITT specification are supported. Dlci/0 is used for the LMI protocol, to comply with FRF.5. ansi: Local Management Interface procedures from the ANSI specification are supported. DLCI 0 is used for the LMI protocol.')
mcsMgrFrf5EpGEpLmiAsyncStatusReport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiAsyncStatusReport.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiAsyncStatusReport.setDescription('This attribute selects the use of asynchronous PVC status report procedures as specified in the CCITT specification (ITU-T Q.933, Annex A), and the ANSI specification Annex D.')
mcsMgrFrf5EpGEpLmiErrorEventThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiErrorEventThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiErrorEventThreshold.setDescription('For the network side procedure, an event is defined as follows: (1) receipt of a STATUS ENQUIRY message, or (2) expiration of timer T392. An error event is (1) nonreceipt of STATUS ENQUIRY in T392 seconds; (2) invalid format of an LMI message; (3) invalid receive sequence number. For the user side procedure, an event is defined as a polling cycle or a status enquiry and status report exchange. An error event is (1) non-receipt of a STATUS within the polling cycle, or (2) invalid format of an LMI message, or (3) invalid sequence number. This attribute specifies the number of error events which, if they occur within eventCount events, will cause a protocol error condition. The condition is cleared after eventCount sequential correct events occur. It must be less than or equal to eventCount (n393).')
mcsMgrFrf5EpGEpLmiEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiEventCount.setDescription('This attribute specifies the number of contiguous events within which no more than eventErrorThreshold error events are allowed. It must be greater than or equal to errorEventThreshold (n392).')
mcsMgrFrf5EpGEpLmiCheckPointTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 255)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiCheckPointTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiCheckPointTimer.setDescription('This attribute selects the time (in seconds) within which a STATUS ENQUIRY message is expected. It must be greater than linkVerificationTimer (t391).')
mcsMgrFrf5EpGEpLmiSide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("network", 0), ("user", 1), ("both", 2))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiSide.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiSide.setDescription('This attribute selects the user side procedure (DTE), or the network side procedure (DCE), or both the user side and the network side procedures of the LMI. This attribute can be set to user, network or both.')
mcsMgrFrf5EpGEpLmiNniParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 11), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNniParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNniParmsTable.setDescription('This group contains the provisionable attributes of the FRF.5 LMI procedures which are unique to NNI.')
mcsMgrFrf5EpGEpLmiNniParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpLmiIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNniParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNniParmsEntry.setDescription('An entry in the mcsMgrFrf5EpGEpLmiNniParmsTable.')
mcsMgrFrf5EpGEpLmiFullStatusPollingCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusPollingCycles.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusPollingCycles.setDescription('This attribute specifies how frequently the FRF.5 LMI initiates a Status Enquiry for a full PVC status report. A polling cycle is a Status Enquiry and Status Report exchange.')
mcsMgrFrf5EpGEpLmiLinkVerificationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 255)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiLinkVerificationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiLinkVerificationTimer.setDescription('This attribute specifies how frequently the FRF.5 LMI initiates a Status Enquiry for link integrity verification. It must be less than checkPointTimer (t392).')
mcsMgrFrf5EpGEpLmiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 12), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mcsMgrFrf5EpGEpLmiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpLmiIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStateEntry.setDescription('An entry in the mcsMgrFrf5EpGEpLmiStateTable.')
mcsMgrFrf5EpGEpLmiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mcsMgrFrf5EpGEpLmiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mcsMgrFrf5EpGEpLmiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mcsMgrFrf5EpGEpLmiPsiTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 13), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiPsiTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiPsiTable.setDescription('This group provides the protocol status of the Local Management Interface.')
mcsMgrFrf5EpGEpLmiPsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpLmiIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiPsiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiPsiEntry.setDescription('An entry in the mcsMgrFrf5EpGEpLmiPsiTable.')
mcsMgrFrf5EpGEpLmiProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("errorCondition", 0), ("normalCondition", 1))).clone('normalCondition')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiProtocolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiProtocolStatus.setDescription('This attribute indicates whether the LMI is in an error condition or whether the protocol is behaving normally. This attribute will be set to errorCondition after enough LMI errors have been detected to warrant a change in condition. This occurs when n392 of the last n393 events are in error. The error condition is lifted when a sufficient number of consecutive events has occurred without error. This occurs when n393 consecutive good events take place. The consequence of an error condition is that all DLCIs on this interface will become inactive in both directions.')
mcsMgrFrf5EpGEpLmiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStatsTable.setDescription('This group contains the operational statistics for the FRF.5 NNI Local Management Interface.')
mcsMgrFrf5EpGEpLmiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpLmiIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStatsEntry.setDescription('An entry in the mcsMgrFrf5EpGEpLmiStatsTable.')
mcsMgrFrf5EpGEpLmiKeepAliveStatusToInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiKeepAliveStatusToInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiKeepAliveStatusToInterface.setDescription('This attribute counts the Local Management Interface keep alive status messages sent to the ATM VCC in response to a status enquiry for keep alive status. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiFullStatusToInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusToInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusToInterface.setDescription('This attribute counts the Local Management Interface full status messages sent to the ATM VCC in response to a status enquiry for keep alive or full status. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiKeepAliveStatusEnqFromInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiKeepAliveStatusEnqFromInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiKeepAliveStatusEnqFromInterface.setDescription('This attribute counts the Local Management Interface valid keep alive status enquiry messages received from the ATM VCC. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiFullStatusEnqFromInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusEnqFromInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusEnqFromInterface.setDescription('This attribute counts the Local Management Interface valid full status enquiry messages received from the ATM VCC. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiNetworkSideEventHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNetworkSideEventHistory.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNetworkSideEventHistory.setDescription("This attribute displays the Local Management Interface network side procedure event history in order of occurrence. An event is represented by a single symbol. A '+' symbol indicates a good event. An 'X' symbol indicates a protocol error event. The left most event is the most recent to occur. The provisioned eventCount dictates the maximum number of events displayed. A good event is triggered by receipt of a valid status enquiry message. An error event is either a T392 timer expiry or receipt of a status enquiry with an incorrect sequence number.")
mcsMgrFrf5EpGEpLmiUserSideEventHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 6), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUserSideEventHistory.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUserSideEventHistory.setDescription("This attribute displays the Local Management Interface user side procedure event history in order of occurrence. An event is represented by a single symbol. A '+' symbol indicates a good event. An 'X' symbol indicates a protocol error event. The left most event is the most recent to occur. The provisioned eventCount dictates the maximum number of events displayed. A good event is triggered by receipt of a valid status message. An error event is either a T391 timer expiry or receipt of a status message with an incorrect sequence number.")
mcsMgrFrf5EpGEpLmiProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiProtocolErrors.setDescription('This attribute counts the number of Local Management Interface protocol errors. It is the sum of the sequence (sequenceErrors and statusSequenceErrors) and timeout (pollingVerifTimeouts and noStatusReportCount) errors. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiUnexpectedIes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUnexpectedIes.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUnexpectedIes.setDescription('This attribute counts the number of Local Managament Interface frames received with an Information Element identifier that is unknown or unexpected. An unexpected Information Element is not a protocol error. When the maximum count is reached, this counter wraps to zero.')
mcsMgrFrf5EpGEpLmiSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiSequenceErrors.setDescription('This attribute counts the number of Local Management Interface Status Enquiry message sequence errors. A sequence error is receipt of a Status Enquiry message with a receive sequence number not equal to the last send sequence number. When the maximum count is reached the counter wraps to zero.')
mcsMgrFrf5EpGEpLmiStatusSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStatusSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiStatusSequenceErrors.setDescription('This attribute counts the number of Local Management Interface Status message sequence errors. A sequence error is receipt of a Status message with a receive sequence number not equal to the last send sequence number. When the maximum count is reached the counter wraps to zero.')
mcsMgrFrf5EpGEpLmiUnexpectedReports = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUnexpectedReports.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiUnexpectedReports.setDescription('This attribute counts the number of Local Management Interface frames received with an unknown or unexpected report type. An unexpected report type is not a protocol error. When the maximum count is reached the counter wraps to zero.')
mcsMgrFrf5EpGEpLmiPollingVerifTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiPollingVerifTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiPollingVerifTimeouts.setDescription('This attribute counts the checkPointTimer (T392) expiries occurring on the Local Management Interface. When the maximum count is reached the counter wraps to zero.')
mcsMgrFrf5EpGEpLmiNoStatusReportCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNoStatusReportCount.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiNoStatusReportCount.setDescription('This attribute counts the number of times when no status report or an invalid status report comes from the external network. This attribute is incremented: i) after a status enquiry is sent out and the T391 timer expires without having a status report received. ii) if an invalid status report is received. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiKeepAliveEnqToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiKeepAliveEnqToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiKeepAliveEnqToIf.setDescription('This attribute counts the number of Local Management Interface keep alive enquiry status messages sent to the external user device for keep alive status. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpLmiFullStatusEnqToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 2, 14, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusEnqToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpLmiFullStatusEnqToIf.setDescription('This attribute counts the number of Local Management Interface full status messages sent to the external user device in response to a status enquiry for keep alive or full status. When the maximum count is reached it wraps to zero.')
mcsMgrFrf5EpGEpEpd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3))
mcsMgrFrf5EpGEpEpdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRowStatusTable.setDescription('This entry controls the addition and deletion of mcsMgrFrf5EpGEpEpd components.')
mcsMgrFrf5EpGEpEpdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpEpdIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpGEpEpd component.')
mcsMgrFrf5EpGEpEpdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpGEpEpd components. These components cannot be added nor deleted.')
mcsMgrFrf5EpGEpEpdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGEpEpdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpGEpEpd tables.')
mcsMgrFrf5EpGEpEpdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpGEpEpd tables.')
mcsMgrFrf5EpGEpEpdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdProvTable.setDescription('This group contains the provisionable attributes of the FRF.5 End Point.')
mcsMgrFrf5EpGEpEpdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpEpdIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdProvEntry.setDescription('An entry in the mcsMgrFrf5EpGEpEpdProvTable.')
mcsMgrFrf5EpGEpEpdRemoteConnectionIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 3), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRemoteConnectionIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdRemoteConnectionIdentifier.setDescription('This attribute specifies the remote connection identifier. It either represents the VPI.VCI logical channel number assignment of a remote ATM interface, or the Endpoint.Frf5EndPointGroup instances of a remote Passport FRF.5 EndPoint.')
mcsMgrFrf5EpGEpEpdConnectionTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdConnectionTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdConnectionTransferPriority.setDescription('This attribute specifies the transfer priority used to establish the ATM connection. The EndPoint references the ModuleData FrameRelayService AtmNetworking TransferPriority/n component to determine the ATM service category to be used by the connection. This attribute is also used to determine which EndPoint within an Frf5EndPointGroup is to multiplex a particular FrAtm Dlci. DESCRIPTION')
mcsMgrFrf5EpGEpEpdCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCommittedInformationRate.setDescription('This attribute specifies the committed information rate (CIR), and represents the rate at which the network FRF.5 ATM VCC agrees to transfer information under normal conditions. A conservative CIR value would be the sum of the CIRs of all the individual FrAtm Dlcis multiplexed by the VCC. The cir is converted into ATM service parameters according to the conversion policy specified by the connectionTransferPriority attribute. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpEpdExcessInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdExcessInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdExcessInformationRate.setDescription('This attribute specifies the excess information rate (EIR), and represents the rate at which the network FRF.5 ATM VCC attempts to transfer information. A conservative EIR value would be the sum of the EIRs of all the individual FrAtm Dlcis multiplexed by the VCC. The eir is converted into ATM service parameters according to the conversion policy specified by the connectionTransferPriority attribute. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpEpdCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(16000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCommittedBurstSize.setDescription('This attribute specifies the committed burst size (Bc), and represents the amount of data that the network FRF.5 ATM VCC agrees to transfer under normal conditions. A conservative Bc value would be the sum of the Bcs of all the individual FrAtm Dlcis multiplexed by the VCC. The bc is converted into ATM service parameters according to the conversion policy specified by the connectionTransferPriority attribute. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpEpdType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1))).clone('master')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdType.setDescription('This attribute specifies the FRF.5 End Point type. If the value is provisioned as master, this End Point is responsible for initiating the SPVC call to set up the FRF.5 ATM VCC. If the value is provisioned as slave, this End Point receives call setup requests from a master remote end.')
mcsMgrFrf5EpGEpEpdAccessRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(1536000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdAccessRate.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdAccessRate.setDescription("This attribute represents the access rate of the FRF.5 EndPoint. A conservative value would be the sum of the access rates of all the FrAtms' that have DLCIs multiplexed by the VCC. The access rate is converted into ATM service parameters when conversion policies 3, 4 and 5 are used. For policy 6, this attribute is ignored.")
mcsMgrFrf5EpGEpEpdExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdExcessBurstSize.setDescription('This attribute specifies the excess burst size (Be), and represents the amount of uncommitted data that the network FRF.5 ATM VCC agrees to transfer under normal conditions. A conservative Be value would be the sum of the Bes of all the individual FrAtm Dlcis multiplexed by the VCC. The be is converted into ATM service parameters according to the conversion policy specified by the connectionTransferPriority attribute. The conversion policy is defined under the ModuleData FrameRelayService AtmNetworking TransferPriority/n component.')
mcsMgrFrf5EpGEpEpdCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 11), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mcsMgrFrf5EpGEpEpdCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpEpdIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCidDataEntry.setDescription('An entry in the mcsMgrFrf5EpGEpEpdCidDataTable.')
mcsMgrFrf5EpGEpEpdCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpEpdCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mcsMgrFrf5EpGEpDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4))
mcsMgrFrf5EpGEpDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mcsMgrFrf5EpGEpDlci components.')
mcsMgrFrf5EpGEpDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpDlciIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpGEpDlci component.')
mcsMgrFrf5EpGEpDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpGEpDlci components. These components cannot be added nor deleted.')
mcsMgrFrf5EpGEpDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGEpDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpGEpDlci tables.')
mcsMgrFrf5EpGEpDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 1007), ValueRangeConstraint(1022, 1022), )))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpGEpDlci tables.')
mcsMgrFrf5EpGEpDlciOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for the FRF.5 DLCI.')
mcsMgrFrf5EpGEpDlciOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpDlciIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciOperEntry.setDescription('An entry in the mcsMgrFrf5EpGEpDlciOperTable.')
mcsMgrFrf5EpGEpDlciABitStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitStatusToIf.setDescription('This attribute indicates the most recent A-bit status sent to the ATM VCC. If the value is inactive, the reason for the LMI failure is given by the aBitReasonToNetwork.')
mcsMgrFrf5EpGEpDlciABitReasonToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("remoteLmiError", 3), ("localLinkDown", 4), ("remoteLinkDown", 5), ("pvcDown", 6))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitReasonToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitReasonToIf.setDescription('This attribute indicates the reason for the latest inactive A-bit status sent to the ATM VCC. The value is notApplicable when the aBitStatusToNetwork is active. The value is remoteUserSignaled if the FrAtm originating the A-Bit status has detected that the virtual circuit is down at the remote network through the LMI protocol. The FrAtm must be running network site LMI protocol for this A-Bit status reason to be sent. The value is localLmiError if the LMI protocol is down at this Ep. The value is remoteLmiError if the LMI protocol is down at the FrAtm originating this A-Bit status reason. The value is localLinkDown if the physical interface is disabled at this Ep. The value is pvcDown if no A-Bit status has been sent to this Ep (i.e., no A-Bit status has been relayed from the FrAtm). The value is remoteLinkDown if the physical interface is disabled at the FrAtm originating this A-Bit status reason.')
mcsMgrFrf5EpGEpDlciABitStatusFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitStatusFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitStatusFromIf.setDescription('This attribute indicates the most recent A-bit status received from the ATM VCC. If the value is inactive, the reason for the LMI failure is given by the aBitReasonFromNetwork.')
mcsMgrFrf5EpGEpDlciABitReasonFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignalled", 1), ("localLmiError", 2), ("localLinkDown", 4), ("missingFromLmiReport", 7))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitReasonFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciABitReasonFromIf.setDescription('This attributes indicates the reason for the latest inactive A-bit status received from the ATM VCC. The value is notApplicable when the aBitStatusFromNetwork is active. The value is remoteUserSignaled if the remote FRF.5 End Point originating the A-Bit status has detected that the virtual circuit is down at the remote network through the LMI protocol. The remote FRF.5 End Point must be running network site LMI protocol for this A-Bit status reason to be sent. The value is localLmiError if the LMI protocol is down at this Ep. The value is localLinkDown if the physical interface is disabled at this Ep. The value is missingFromLmiReport if the remote FRF.5 End Point did not provide a reason along with the inactive A-Bit status.')
mcsMgrFrf5EpGEpDlciAccessConnectionComponent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 4, 10, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 23))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciAccessConnectionComponent.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpDlciAccessConnectionComponent.setDescription('This attribute identifies the FrAtm Dlci to which this Dlci component is bound.')
mcsMgrFrf5EpGEpAtmCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5))
mcsMgrFrf5EpGEpAtmConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 1), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConRowStatusTable.setDescription('This entry controls the addition and deletion of mcsMgrFrf5EpGEpAtmCon components.')
mcsMgrFrf5EpGEpAtmConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpAtmConIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConRowStatusEntry.setDescription('A single entry in the table represents a single mcsMgrFrf5EpGEpAtmCon component.')
mcsMgrFrf5EpGEpAtmConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConRowStatus.setDescription('This variable is used as the basis for SNMP naming of mcsMgrFrf5EpGEpAtmCon components. These components cannot be added nor deleted.')
mcsMgrFrf5EpGEpAtmConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mcsMgrFrf5EpGEpAtmConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConStorageType.setDescription('This variable represents the storage type value for the mcsMgrFrf5EpGEpAtmCon tables.')
mcsMgrFrf5EpGEpAtmConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConIndex.setDescription('This variable represents the index for the mcsMgrFrf5EpGEpAtmCon tables.')
mcsMgrFrf5EpGEpAtmConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 10), )
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConOperTable.setDescription('This attribute group contains the operational attributes for the NapAtmConnection component.')
mcsMgrFrf5EpGEpAtmConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-McsMgrMIB", "mcsMgrIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpIndex"), (0, "Nortel-Magellan-Passport-Frf5EpMIB", "mcsMgrFrf5EpGEpAtmConIndex"))
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConOperEntry.setDescription('An entry in the mcsMgrFrf5EpGEpAtmConOperTable.')
mcsMgrFrf5EpGEpAtmConNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 122, 14, 3, 5, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mcsMgrFrf5EpGEpAtmConNextHop.setDescription('This attribute shows the component name of the AtmIf Vcc Ep or AtmCon component to which this switched connection is established.')
frf5EpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 1))
frf5EpGroupBD = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 1, 4))
frf5EpGroupBD02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 1, 4, 3))
frf5EpGroupBD02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 1, 4, 3, 2))
frf5EpCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 3))
frf5EpCapabilitiesBD = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 3, 4))
frf5EpCapabilitiesBD02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 3, 4, 3))
frf5EpCapabilitiesBD02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 121, 3, 4, 3, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-Frf5EpMIB", mcsMgrFrf5EpGEpEpdType=mcsMgrFrf5EpGEpEpdType, mcsMgrFrf5EpGEpLmiPsiTable=mcsMgrFrf5EpGEpLmiPsiTable, mcsMgrFrf5EpGEpEpdCustomerIdentifier=mcsMgrFrf5EpGEpEpdCustomerIdentifier, mcsMgrFrf5EpGEpEpdCidDataEntry=mcsMgrFrf5EpGEpEpdCidDataEntry, frf5EpGroupBD02A=frf5EpGroupBD02A, mcsMgrFrf5EpGAddrAddrPreTable=mcsMgrFrf5EpGAddrAddrPreTable, mcsMgrFrf5EpGEpLmiFullStatusToInterface=mcsMgrFrf5EpGEpLmiFullStatusToInterface, mcsMgrFrf5EpGEpLmiProcedures=mcsMgrFrf5EpGEpLmiProcedures, mcsMgrFrf5EpGAddrComponentName=mcsMgrFrf5EpGAddrComponentName, mcsMgrFrf5EpGEpEpdRowStatusTable=mcsMgrFrf5EpGEpEpdRowStatusTable, mcsMgrFrf5EpGEpDlciOperEntry=mcsMgrFrf5EpGEpDlciOperEntry, mcsMgrFrf5EpGEpAlarmStatus=mcsMgrFrf5EpGEpAlarmStatus, mcsMgrFrf5EpGEpPeakCellRate01=mcsMgrFrf5EpGEpPeakCellRate01, mcsMgrFrf5EpGEpMaximumBurstSize0=mcsMgrFrf5EpGEpMaximumBurstSize0, mcsMgrFrf5EpGEpOperTable=mcsMgrFrf5EpGEpOperTable, mcsMgrFrf5EpGEpDlciRowStatus=mcsMgrFrf5EpGEpDlciRowStatus, mcsMgrFrf5EpGAddrCommentText=mcsMgrFrf5EpGAddrCommentText, mcsMgrFrf5EpGEpLmiAdminState=mcsMgrFrf5EpGEpLmiAdminState, mcsMgrFrf5EpGEpLmiKeepAliveStatusEnqFromInterface=mcsMgrFrf5EpGEpLmiKeepAliveStatusEnqFromInterface, mcsMgrFrf5EpGEpLmi=mcsMgrFrf5EpGEpLmi, mcsMgrFrf5EpGEpLmiErrorEventThreshold=mcsMgrFrf5EpGEpLmiErrorEventThreshold, mcsMgrFrf5EpGEpUnknownStatus=mcsMgrFrf5EpGEpUnknownStatus, mcsMgrFrf5EpGEpStateEntry=mcsMgrFrf5EpGEpStateEntry, mcsMgrFrf5EpGStorageType=mcsMgrFrf5EpGStorageType, mcsMgrFrf5EpGEpEpdRowStatusEntry=mcsMgrFrf5EpGEpEpdRowStatusEntry, mcsMgrFrf5EpGEpDlciIndex=mcsMgrFrf5EpGEpDlciIndex, mcsMgrFrf5EpGEpLmiNniParmsEntry=mcsMgrFrf5EpGEpLmiNniParmsEntry, mcsMgrFrf5EpGAddrRowStatus=mcsMgrFrf5EpGAddrRowStatus, mcsMgrFrf5EpGEpLastVccClearCause=mcsMgrFrf5EpGEpLastVccClearCause, mcsMgrFrf5EpGAddrIndex=mcsMgrFrf5EpGAddrIndex, mcsMgrFrf5EpGEpSustainedCellRate01=mcsMgrFrf5EpGEpSustainedCellRate01, mcsMgrFrf5EpGEpAtmConRowStatusTable=mcsMgrFrf5EpGEpAtmConRowStatusTable, mcsMgrFrf5EpGEpLmiIndex=mcsMgrFrf5EpGEpLmiIndex, frf5EpCapabilitiesBD02A=frf5EpCapabilitiesBD02A, mcsMgrFrf5EpGEpAtmConRowStatusEntry=mcsMgrFrf5EpGEpAtmConRowStatusEntry, mcsMgrFrf5EpGEpEpdExcessInformationRate=mcsMgrFrf5EpGEpEpdExcessInformationRate, frf5EpGroupBD=frf5EpGroupBD, mcsMgrFrf5EpGEpEpdConnectionTransferPriority=mcsMgrFrf5EpGEpEpdConnectionTransferPriority, mcsMgrFrf5EpGEpLmiProtocolErrors=mcsMgrFrf5EpGEpLmiProtocolErrors, mcsMgrFrf5EpGEpRowStatusTable=mcsMgrFrf5EpGEpRowStatusTable, mcsMgrFrf5EpGEpLmiFullStatusEnqToIf=mcsMgrFrf5EpGEpLmiFullStatusEnqToIf, mcsMgrFrf5EpGEpLmiSide=mcsMgrFrf5EpGEpLmiSide, mcsMgrFrf5EpGEpType=mcsMgrFrf5EpGEpType, mcsMgrFrf5EpGEpLmiStateEntry=mcsMgrFrf5EpGEpLmiStateEntry, mcsMgrFrf5EpGEpEpdCommittedInformationRate=mcsMgrFrf5EpGEpEpdCommittedInformationRate, mcsMgrFrf5EpGEpConnectionTransferPriority=mcsMgrFrf5EpGEpConnectionTransferPriority, mcsMgrFrf5EpGEpComponentName=mcsMgrFrf5EpGEpComponentName, mcsMgrFrf5EpGEpDlciRowStatusEntry=mcsMgrFrf5EpGEpDlciRowStatusEntry, mcsMgrFrf5EpGEpLmiPollingVerifTimeouts=mcsMgrFrf5EpGEpLmiPollingVerifTimeouts, mcsMgrFrf5EpGEpLmiParmsTable=mcsMgrFrf5EpGEpLmiParmsTable, mcsMgrFrf5EpGEpLmiStatsTable=mcsMgrFrf5EpGEpLmiStatsTable, mcsMgrFrf5EpGEpDlciOperTable=mcsMgrFrf5EpGEpDlciOperTable, frf5EpCapabilities=frf5EpCapabilities, mcsMgrFrf5EpGEpEpdCommittedBurstSize=mcsMgrFrf5EpGEpEpdCommittedBurstSize, mcsMgrFrf5EpGEpSustainedCellRate0=mcsMgrFrf5EpGEpSustainedCellRate0, mcsMgrFrf5EpGEpLmiRowStatus=mcsMgrFrf5EpGEpLmiRowStatus, mcsMgrFrf5EpG=mcsMgrFrf5EpG, mcsMgrFrf5EpGEpAvailabilityStatus=mcsMgrFrf5EpGEpAvailabilityStatus, mcsMgrFrf5EpGEpMaximumBurstSize01=mcsMgrFrf5EpGEpMaximumBurstSize01, mcsMgrFrf5EpGEpLastVccCauseDiag=mcsMgrFrf5EpGEpLastVccCauseDiag, mcsMgrFrf5EpGRowStatus=mcsMgrFrf5EpGRowStatus, mcsMgrFrf5EpGEpLmiNetworkSideEventHistory=mcsMgrFrf5EpGEpLmiNetworkSideEventHistory, mcsMgrFrf5EpGEpEpdCidDataTable=mcsMgrFrf5EpGEpEpdCidDataTable, mcsMgrFrf5EpGAddrAddrPreValue=mcsMgrFrf5EpGAddrAddrPreValue, mcsMgrFrf5EpGEpAdminState=mcsMgrFrf5EpGEpAdminState, mcsMgrFrf5EpGAddrProvTable=mcsMgrFrf5EpGAddrProvTable, mcsMgrFrf5EpGEp=mcsMgrFrf5EpGEp, mcsMgrFrf5EpGEpLmiPsiEntry=mcsMgrFrf5EpGEpLmiPsiEntry, mcsMgrFrf5EpGAddrAddrPreRowStatus=mcsMgrFrf5EpGAddrAddrPreRowStatus, mcsMgrFrf5EpGEpEpdIndex=mcsMgrFrf5EpGEpEpdIndex, mcsMgrFrf5EpGEpLmiUnexpectedReports=mcsMgrFrf5EpGEpLmiUnexpectedReports, mcsMgrFrf5EpGEpEpdProvTable=mcsMgrFrf5EpGEpEpdProvTable, mcsMgrFrf5EpGEpLmiUnexpectedIes=mcsMgrFrf5EpGEpLmiUnexpectedIes, mcsMgrFrf5EpGEpLmiParmsEntry=mcsMgrFrf5EpGEpLmiParmsEntry, frf5EpMIB=frf5EpMIB, mcsMgrFrf5EpGEpEpdComponentName=mcsMgrFrf5EpGEpEpdComponentName, mcsMgrFrf5EpGAddr=mcsMgrFrf5EpGAddr, mcsMgrFrf5EpGEpAtmConNextHop=mcsMgrFrf5EpGEpAtmConNextHop, mcsMgrFrf5EpGEpLmiLinkVerificationTimer=mcsMgrFrf5EpGEpLmiLinkVerificationTimer, mcsMgrFrf5EpGEpLmiStorageType=mcsMgrFrf5EpGEpLmiStorageType, mcsMgrFrf5EpGEpRowStatus=mcsMgrFrf5EpGEpRowStatus, mcsMgrFrf5EpGEpLmiEventCount=mcsMgrFrf5EpGEpLmiEventCount, mcsMgrFrf5EpGAddrProvEntry=mcsMgrFrf5EpGAddrProvEntry, mcsMgrFrf5EpGEpDlciComponentName=mcsMgrFrf5EpGEpDlciComponentName, mcsMgrFrf5EpGIndex=mcsMgrFrf5EpGIndex, mcsMgrFrf5EpGEpAtmConOperTable=mcsMgrFrf5EpGEpAtmConOperTable, mcsMgrFrf5EpGEpAtmCon=mcsMgrFrf5EpGEpAtmCon, mcsMgrFrf5EpGEpLmiStatusSequenceErrors=mcsMgrFrf5EpGEpLmiStatusSequenceErrors, mcsMgrFrf5EpGEpAvgFrameSize=mcsMgrFrf5EpGEpAvgFrameSize, mcsMgrFrf5EpGEpAtmConRowStatus=mcsMgrFrf5EpGEpAtmConRowStatus, frf5EpCapabilitiesBD=frf5EpCapabilitiesBD, mcsMgrFrf5EpGEpLmiProtocolStatus=mcsMgrFrf5EpGEpLmiProtocolStatus, mcsMgrFrf5EpGEpLmiUserSideEventHistory=mcsMgrFrf5EpGEpLmiUserSideEventHistory, mcsMgrFrf5EpGEpEpdProvEntry=mcsMgrFrf5EpGEpEpdProvEntry, mcsMgrFrf5EpGEpLmiRowStatusTable=mcsMgrFrf5EpGEpLmiRowStatusTable, mcsMgrFrf5EpGEpLmiUsageState=mcsMgrFrf5EpGEpLmiUsageState, mcsMgrFrf5EpGEpStateTable=mcsMgrFrf5EpGEpStateTable, mcsMgrFrf5EpGAddrStorageType=mcsMgrFrf5EpGAddrStorageType, frf5EpGroupBD02=frf5EpGroupBD02, frf5EpCapabilitiesBD02=frf5EpCapabilitiesBD02, mcsMgrFrf5EpGEpDlciStorageType=mcsMgrFrf5EpGEpDlciStorageType, mcsMgrFrf5EpGEpAtmConIndex=mcsMgrFrf5EpGEpAtmConIndex, mcsMgrFrf5EpGEpAtmConOperEntry=mcsMgrFrf5EpGEpAtmConOperEntry, mcsMgrFrf5EpGEpStandbyStatus=mcsMgrFrf5EpGEpStandbyStatus, mcsMgrFrf5EpGEpLmiOperationalState=mcsMgrFrf5EpGEpLmiOperationalState, mcsMgrFrf5EpGEpLmiSequenceErrors=mcsMgrFrf5EpGEpLmiSequenceErrors, mcsMgrFrf5EpGAddrRowStatusTable=mcsMgrFrf5EpGAddrRowStatusTable, mcsMgrFrf5EpGEpDlciRowStatusTable=mcsMgrFrf5EpGEpDlciRowStatusTable, mcsMgrFrf5EpGEpTrafficParmConversionPolicy=mcsMgrFrf5EpGEpTrafficParmConversionPolicy, mcsMgrFrf5EpGEpLmiFullStatusPollingCycles=mcsMgrFrf5EpGEpLmiFullStatusPollingCycles, mcsMgrFrf5EpGEpEpdRowStatus=mcsMgrFrf5EpGEpEpdRowStatus, mcsMgrFrf5EpGEpDlci=mcsMgrFrf5EpGEpDlci, mcsMgrFrf5EpGEpUsageState=mcsMgrFrf5EpGEpUsageState, mcsMgrFrf5EpGEpControlStatus=mcsMgrFrf5EpGEpControlStatus, mcsMgrFrf5EpGEpLmiNoStatusReportCount=mcsMgrFrf5EpGEpLmiNoStatusReportCount, mcsMgrFrf5EpGEpProceduralStatus=mcsMgrFrf5EpGEpProceduralStatus, mcsMgrFrf5EpGEpLmiKeepAliveEnqToIf=mcsMgrFrf5EpGEpLmiKeepAliveEnqToIf, mcsMgrFrf5EpGEpLmiStatsEntry=mcsMgrFrf5EpGEpLmiStatsEntry, mcsMgrFrf5EpGAddrRemoteAddress=mcsMgrFrf5EpGAddrRemoteAddress, mcsMgrFrf5EpGEpDlciABitStatusToIf=mcsMgrFrf5EpGEpDlciABitStatusToIf, mcsMgrFrf5EpGEpAtmConComponentName=mcsMgrFrf5EpGEpAtmConComponentName, mcsMgrFrf5EpGComponentName=mcsMgrFrf5EpGComponentName, mcsMgrFrf5EpGEpIndex=mcsMgrFrf5EpGEpIndex, mcsMgrFrf5EpGAddrRowStatusEntry=mcsMgrFrf5EpGAddrRowStatusEntry, mcsMgrFrf5EpGEpStorageType=mcsMgrFrf5EpGEpStorageType, mcsMgrFrf5EpGEpLmiKeepAliveStatusToInterface=mcsMgrFrf5EpGEpLmiKeepAliveStatusToInterface, mcsMgrFrf5EpGEpLmiFullStatusEnqFromInterface=mcsMgrFrf5EpGEpLmiFullStatusEnqFromInterface, mcsMgrFrf5EpGRowStatusTable=mcsMgrFrf5EpGRowStatusTable, frf5EpGroup=frf5EpGroup, mcsMgrFrf5EpGEpRowStatusEntry=mcsMgrFrf5EpGEpRowStatusEntry, mcsMgrFrf5EpGEpEpd=mcsMgrFrf5EpGEpEpd, mcsMgrFrf5EpGEpLmiAsyncStatusReport=mcsMgrFrf5EpGEpLmiAsyncStatusReport, mcsMgrFrf5EpGEpLmiCheckPointTimer=mcsMgrFrf5EpGEpLmiCheckPointTimer, mcsMgrFrf5EpGEpLmiStateTable=mcsMgrFrf5EpGEpLmiStateTable, mcsMgrFrf5EpGEpOperEntry=mcsMgrFrf5EpGEpOperEntry, mcsMgrFrf5EpGEpLmiRowStatusEntry=mcsMgrFrf5EpGEpLmiRowStatusEntry, mcsMgrFrf5EpGEpEpdExcessBurstSize=mcsMgrFrf5EpGEpEpdExcessBurstSize, mcsMgrFrf5EpGEpEpdRemoteConnectionIdentifier=mcsMgrFrf5EpGEpEpdRemoteConnectionIdentifier, mcsMgrFrf5EpGEpEpdAccessRate=mcsMgrFrf5EpGEpEpdAccessRate, mcsMgrFrf5EpGRowStatusEntry=mcsMgrFrf5EpGRowStatusEntry, mcsMgrFrf5EpGEpOperationalState=mcsMgrFrf5EpGEpOperationalState, mcsMgrFrf5EpGEpServiceCategory=mcsMgrFrf5EpGEpServiceCategory, mcsMgrFrf5EpGEpLmiComponentName=mcsMgrFrf5EpGEpLmiComponentName, mcsMgrFrf5EpGEpDlciABitStatusFromIf=mcsMgrFrf5EpGEpDlciABitStatusFromIf, mcsMgrFrf5EpGEpDlciABitReasonToIf=mcsMgrFrf5EpGEpDlciABitReasonToIf, mcsMgrFrf5EpGEpLmiNniParmsTable=mcsMgrFrf5EpGEpLmiNniParmsTable, mcsMgrFrf5EpGEpEpdStorageType=mcsMgrFrf5EpGEpEpdStorageType, mcsMgrFrf5EpGAddrAddrPreEntry=mcsMgrFrf5EpGAddrAddrPreEntry, mcsMgrFrf5EpGEpAtmConStorageType=mcsMgrFrf5EpGEpAtmConStorageType, mcsMgrFrf5EpGEpDlciABitReasonFromIf=mcsMgrFrf5EpGEpDlciABitReasonFromIf, mcsMgrFrf5EpGEpDlciAccessConnectionComponent=mcsMgrFrf5EpGEpDlciAccessConnectionComponent)

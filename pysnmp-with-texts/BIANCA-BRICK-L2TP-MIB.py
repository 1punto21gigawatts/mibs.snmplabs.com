#
# PySNMP MIB module BIANCA-BRICK-L2TP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-L2TP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
DisplayString, = mibBuilder.importSymbols("RFC1158-MIB", "DisplayString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter64, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Gauge32, Counter32, enterprises, IpAddress, TimeTicks, NotificationType, ModuleIdentity, ObjectIdentity, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter64", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Gauge32", "Counter32", "enterprises", "IpAddress", "TimeTicks", "NotificationType", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
vpn = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 23))
l2tp = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 23, 8))
l2tpGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 10))
l2tpGlobUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 10, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1701)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpGlobUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpGlobUdpPort.setDescription('The UDP port which is monitored by L2TP for tunnel establishment requests received from remote hosts.')
l2tpGlobPortUsage = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 10, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("single", 1), ("floating", 2))).clone('floating')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpGlobPortUsage.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpGlobPortUsage.setDescription("This object specifies whether L2TP uses only one UDP port (which number is defined by l2tpGlobUdpPort), or if it allocates a new available port, to send messages to the remote equipment. Choosing 'single' makes it sometimes easier to process L2TP through NAT since L2TP traffic can be classified based on the UDP port number. Choosing 'floating' selects the behavior which is recommended in RFC2331. Possible values: single(1), -- L2TP uses the UDP port defined by l2tpGlobUdpPort -- to send messages to the remote equipment. floating(2) -- L2TP allocates a new port to send messages to -- the remote equipment (default).")
l2tpTunnelProfileTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20), )
if mibBuilder.loadTexts: l2tpTunnelProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileTable.setDescription('This table contains profile information for L2TP tunnels.')
l2tpTunnelProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10), ).setIndexNames((0, "BIANCA-BRICK-L2TP-MIB", "l2tpTunnelProfileIndex"))
if mibBuilder.loadTexts: l2tpTunnelProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileEntry.setDescription('An entry in the l2tpTunnelProfileTable.')
l2tpTunnelProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileIndex.setDescription('The unique index for this entry.')
l2tpTunnelProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileName.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileName.setDescription('The friendly name for this entry.')
l2tpTunnelProfileRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteIpAddress.setDescription("The main remote IP address for the tunnel. Only meaningful in LAC mode. If l2tpTunnelProfileRadiusAssignment is set to 'enabled', this object is ignored and the L2TP daemon will ask the Radius daemon to send a request for the main and backup remote IP addresses.")
l2tpTunnelProfileRemoteIpAddressBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteIpAddressBackup.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteIpAddressBackup.setDescription("The backup remote IP address for the tunnel. Only meaningful in LAC mode. If l2tpTunnelProfileRadiusAssignment is set to 'enabled', this object is ignored and the L2TP daemon will ask the Radius daemon to send a request for the main and backup remote IP addresses.")
l2tpTunnelProfileRemoteUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1701)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteUdpPort.setDescription('The remote UDP port number for the tunnel. Only meaningful in LAC mode.')
l2tpTunnelProfileRemoteHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteHostname.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileRemoteHostname.setDescription('The name of the remote host. Use an empty string for default profile.')
l2tpTunnelProfileLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 50), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileLocalIpAddress.setDescription('The local IP address for the tunnel. If this value is set to 0, the IP address of the egress interface will be used in outgoing L2TP packets.')
l2tpTunnelProfileLocalUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileLocalUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileLocalUdpPort.setDescription('The local UDP port number for the tunnel. Only meaningful in LAC mode. If this value is set to 0 (zero), the port number is allocated dynamically.')
l2tpTunnelProfileLocalHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 70), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileLocalHostname.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileLocalHostname.setDescription('The name of the local host.')
l2tpTunnelProfilePassword = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 80), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfilePassword.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfilePassword.setDescription('The password used for tunnel authentication.')
l2tpTunnelProfileReceiveWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 90), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileReceiveWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileReceiveWindowSize.setDescription('The received window size used by L2TP on the local side of this tunnel. Currently, the only supported value is 1.')
l2tpTunnelProfileHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileHelloInterval.setDescription('The interval in seconds between two consecutive hello requests sent by L2TP during the tunnel life. If this object is set to 0 (zero), no hello requests are sent by L2TP on this tunnel.')
l2tpTunnelProfileSessionDataSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delete", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileSessionDataSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileSessionDataSequencing.setDescription('This object specifies if sequence numbers are used on the data channel of sessions supported by this tunnel. Additionally, if this object is set to delete (1), the entry is marked for discard.')
l2tpTunnelProfileMinRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 120), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileMinRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileMinRetryTime.setDescription('The initial interval in seconds between two consecutive attempts to send an L2TP control packet. The value of this interval is doubled with each new attempt, until the maximum value defined in l2tpTunnelProfileMaxRetryTime is reached.')
l2tpTunnelProfileMaxRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 130), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 255)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileMaxRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileMaxRetryTime.setDescription('The maximum interval in seconds between two consecutive attempts to send an L2TP control packet.')
l2tpTunnelProfileMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 140), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileMaxRetries.setDescription('The maximum number of retries to send an L2TP control packet. The total number of attempts will be one more than this value.')
l2tpTunnelProfileRadiusAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 150), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileRadiusAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileRadiusAssignment.setDescription('This object enables/disables the use of Radius for requesting main and backup remote IP addresses. Only meaningful in LAC mode.')
l2tpTunnelProfileRadiusGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 20, 10, 160), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelProfileRadiusGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelProfileRadiusGroupId.setDescription('Determines the logical RADIUS server group to be addressed for sending the RADIUS Access-Request messages. Only meaningful in LAC mode. See also radiusSrvGroupId.')
l2tpTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30), )
if mibBuilder.loadTexts: l2tpTunnelTable.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelTable.setDescription('This table contains information for L2TP tunnels.')
l2tpTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10), ).setIndexNames((0, "BIANCA-BRICK-L2TP-MIB", "l2tpTunnelLocalTunnelId"))
if mibBuilder.loadTexts: l2tpTunnelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelEntry.setDescription('Entries in this table are created by the system.')
l2tpTunnelRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelRemoteIpAddress.setDescription('The remote IP address for the tunnel.')
l2tpTunnelRemoteUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelRemoteUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelRemoteUdpPort.setDescription('The remote UDP port number for the tunnel.')
l2tpTunnelRemoteTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelRemoteTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelRemoteTunnelId.setDescription('The ID used by the remote end for the tunnel.')
l2tpTunnelRemoteReceiveWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelRemoteReceiveWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelRemoteReceiveWindowSize.setDescription('The receive window size used by L2TP on the remote side of this tunnel.')
l2tpTunnelRemoteHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelRemoteHostname.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelRemoteHostname.setDescription('The name of the remote host.')
l2tpTunnelRemoteVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 50), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelRemoteVendorName.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelRemoteVendorName.setDescription('The vendor name of the remote host L2TP layer.')
l2tpTunnelLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 60), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelLocalIpAddress.setDescription('The local IP address for the tunnel.')
l2tpTunnelLocalUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelLocalUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelLocalUdpPort.setDescription('The local UDP port number for the tunnel.')
l2tpTunnelLocalTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 80), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelLocalTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelLocalTunnelId.setDescription('The ID used by the local end for the tunnel.')
l2tpTunnelLocalReceiveWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 85), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelLocalReceiveWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelLocalReceiveWindowSize.setDescription('The receive window size used by L2TP on the local side of this tunnel. Currently, the only supported value is 1.')
l2tpTunnelLocalHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 90), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelLocalHostname.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelLocalHostname.setDescription('The name of the local host.')
l2tpTunnelPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 100), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpTunnelPassword.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelPassword.setDescription('The password used for tunnel authentication.')
l2tpTunnelHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 120), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelHelloInterval.setDescription('The interval in seconds between two consecutive hello requests sent by L2TP during the tunnel life. If this object is set to 0 (zero), no hello requests are sent by L2TP on this tunnel.')
l2tpTunnelSessionDataSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 130), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelSessionDataSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelSessionDataSequencing.setDescription('This object specifies if sequence numbers are used on the data channel of sessions supported by this tunnel.')
l2tpTunnelMinRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 140), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelMinRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelMinRetryTime.setDescription('The initial interval in seconds between two consecutive attempts to send an L2TP control packet. The value of this interval is doubled with each new attempt, until the maximum value defined in l2tpTunnelProfileMaxRetryTime is reached.')
l2tpTunnelMaxRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 150), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 255)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelMaxRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelMaxRetryTime.setDescription('The maximum interval in seconds between two consecutive attempts to send an L2TP control packet.')
l2tpTunnelMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 160), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelMaxRetries.setDescription('The maximum number of retries to send an L2TP control packet. The total number of attempts will be one more than this value.')
l2tpTunnelState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 30, 10, 170), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 1), ("waitctlreply", 2), ("waitctlconn", 3), ("established", 4), ("shutdown", 5))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpTunnelState.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpTunnelState.setDescription('The current state of the tunnel as specified in RFC2661. Selecting shutdown(5) value results in tunnel hangup. Any other value is ignored.')
l2tpSessionTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40), )
if mibBuilder.loadTexts: l2tpSessionTable.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionTable.setDescription('This Table contains information for L2TP sessions.')
l2tpSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10), ).setIndexNames((0, "BIANCA-BRICK-L2TP-MIB", "l2tpSessionLocalSessionId"))
if mibBuilder.loadTexts: l2tpSessionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionEntry.setDescription('Entries in this table are created by the system.')
l2tpSessionRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionRemoteIpAddress.setDescription('The remote IP address for the tunnel.')
l2tpSessionRemoteUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionRemoteUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionRemoteUdpPort.setDescription('The remote UDP port number for the tunnel.')
l2tpSessionRemoteTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionRemoteTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionRemoteTunnelId.setDescription('The ID used by the remote end for the tunnel.')
l2tpSessionRemoteSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionRemoteSessionId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionRemoteSessionId.setDescription('The ID used by the remote end for the session.')
l2tpSessionRemoteHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 50), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionRemoteHostname.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionRemoteHostname.setDescription('The name of the remote host.')
l2tpSessionLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 60), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionLocalIpAddress.setDescription('The local IP address for the tunnel.')
l2tpSessionLocalUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionLocalUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionLocalUdpPort.setDescription('The local UDP port number for the tunnel.')
l2tpSessionLocalTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 80), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionLocalTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionLocalTunnelId.setDescription('The ID used by the local end for the tunnel.')
l2tpSessionLocalSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 90), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionLocalSessionId.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionLocalSessionId.setDescription('The ID used by the local end for the session.')
l2tpSessionLocalHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 100), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionLocalHostname.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionLocalHostname.setDescription('The name of the local host.')
l2tpSessionCallSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 110), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionCallSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionCallSerialNumber.setDescription('The call serial number for the session.')
l2tpSessionDataSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpSessionDataSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionDataSequencing.setDescription('This object specifies if sequence numbers are used on the data channel of the session.')
l2tpSessionState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 130), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("idle", 1), ("waittunnel", 2), ("waitcsanswer", 3), ("waitreply", 4), ("waitconnect", 5), ("established", 6), ("shutdown", 7))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2tpSessionState.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionState.setDescription('The current state of the session as specified in RFC2661. Selecting shutdown(7) value results in session hangup. Any other value is ignored.')
l2tpSessionInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 140), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionInfo.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionInfo.setDescription('Info on the state of the session.')
l2tpSessionClientPPPCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 150), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionClientPPPCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionClientPPPCrcErrors.setDescription('The number of PPP CRC errors detected by the LAC while communicating with the PPP client. This value is only significant in L2TP-LNS mode.')
l2tpSessionClientPPPFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 160), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionClientPPPFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionClientPPPFramingErrors.setDescription('The number of PPP framing errors detected by the LAC while communicating with the PPP client. This value is only significant in L2TP-LNS mode.')
l2tpSessionClientPPPHardwareOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 170), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionClientPPPHardwareOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionClientPPPHardwareOverruns.setDescription('The number of PPP hardware overruns detected by the LAC while communicating with the PPP client. This value is only significant in L2TP-LNS mode.')
l2tpSessionClientPPPBufferOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 180), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionClientPPPBufferOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionClientPPPBufferOverruns.setDescription('The number of PPP buffer overruns detected by the LAC while communicating with the PPP client. This value is only significant in L2TP-LNS mode.')
l2tpSessionClientPPPTimeoutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 190), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionClientPPPTimeoutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionClientPPPTimeoutErrors.setDescription('The number of PPP timeout errors detected by the LAC while communicating with the PPP client. This value is only significant in L2TP-LNS mode.')
l2tpSessionClientPPPAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 8, 40, 10, 200), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2tpSessionClientPPPAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: l2tpSessionClientPPPAlignmentErrors.setDescription('The number of PPP alignment errors detected by the LAC while communicating with the PPP client. This value is only significant in L2TP-LNS mode.')
mibBuilder.exportSymbols("BIANCA-BRICK-L2TP-MIB", l2tpTunnelLocalUdpPort=l2tpTunnelLocalUdpPort, l2tpSessionInfo=l2tpSessionInfo, l2tpTunnelRemoteIpAddress=l2tpTunnelRemoteIpAddress, l2tpTunnelRemoteVendorName=l2tpTunnelRemoteVendorName, l2tpTunnelLocalIpAddress=l2tpTunnelLocalIpAddress, l2tpSessionClientPPPAlignmentErrors=l2tpSessionClientPPPAlignmentErrors, l2tpTunnelState=l2tpTunnelState, l2tpSessionRemoteIpAddress=l2tpSessionRemoteIpAddress, l2tpSessionClientPPPTimeoutErrors=l2tpSessionClientPPPTimeoutErrors, l2tpTunnelProfileMinRetryTime=l2tpTunnelProfileMinRetryTime, l2tpTunnelProfileHelloInterval=l2tpTunnelProfileHelloInterval, l2tpSessionLocalTunnelId=l2tpSessionLocalTunnelId, l2tpTunnelProfileEntry=l2tpTunnelProfileEntry, l2tpTunnelMaxRetryTime=l2tpTunnelMaxRetryTime, l2tpTunnelProfileRemoteUdpPort=l2tpTunnelProfileRemoteUdpPort, bintec=bintec, l2tpSessionRemoteUdpPort=l2tpSessionRemoteUdpPort, l2tpSessionCallSerialNumber=l2tpSessionCallSerialNumber, l2tpGlobPortUsage=l2tpGlobPortUsage, l2tpTunnelProfileRemoteHostname=l2tpTunnelProfileRemoteHostname, l2tpGlobals=l2tpGlobals, l2tpTunnelTable=l2tpTunnelTable, l2tpSessionRemoteTunnelId=l2tpSessionRemoteTunnelId, l2tpTunnelProfileRemoteIpAddressBackup=l2tpTunnelProfileRemoteIpAddressBackup, l2tpTunnelRemoteTunnelId=l2tpTunnelRemoteTunnelId, bibo=bibo, l2tp=l2tp, l2tpTunnelPassword=l2tpTunnelPassword, l2tpSessionRemoteSessionId=l2tpSessionRemoteSessionId, l2tpSessionLocalSessionId=l2tpSessionLocalSessionId, l2tpTunnelProfileTable=l2tpTunnelProfileTable, l2tpSessionClientPPPFramingErrors=l2tpSessionClientPPPFramingErrors, l2tpSessionTable=l2tpSessionTable, l2tpTunnelProfileName=l2tpTunnelProfileName, l2tpTunnelProfileMaxRetryTime=l2tpTunnelProfileMaxRetryTime, l2tpSessionClientPPPCrcErrors=l2tpSessionClientPPPCrcErrors, l2tpSessionClientPPPBufferOverruns=l2tpSessionClientPPPBufferOverruns, l2tpTunnelProfilePassword=l2tpTunnelProfilePassword, l2tpTunnelProfileIndex=l2tpTunnelProfileIndex, l2tpTunnelEntry=l2tpTunnelEntry, l2tpTunnelProfileSessionDataSequencing=l2tpTunnelProfileSessionDataSequencing, l2tpTunnelMinRetryTime=l2tpTunnelMinRetryTime, l2tpTunnelRemoteReceiveWindowSize=l2tpTunnelRemoteReceiveWindowSize, l2tpTunnelProfileMaxRetries=l2tpTunnelProfileMaxRetries, l2tpTunnelProfileRadiusGroupId=l2tpTunnelProfileRadiusGroupId, l2tpSessionLocalIpAddress=l2tpSessionLocalIpAddress, l2tpTunnelMaxRetries=l2tpTunnelMaxRetries, l2tpTunnelRemoteHostname=l2tpTunnelRemoteHostname, l2tpSessionEntry=l2tpSessionEntry, l2tpSessionClientPPPHardwareOverruns=l2tpSessionClientPPPHardwareOverruns, vpn=vpn, l2tpTunnelLocalReceiveWindowSize=l2tpTunnelLocalReceiveWindowSize, l2tpTunnelProfileRemoteIpAddress=l2tpTunnelProfileRemoteIpAddress, l2tpTunnelLocalHostname=l2tpTunnelLocalHostname, l2tpTunnelSessionDataSequencing=l2tpTunnelSessionDataSequencing, l2tpSessionLocalHostname=l2tpSessionLocalHostname, l2tpSessionDataSequencing=l2tpSessionDataSequencing, l2tpSessionState=l2tpSessionState, l2tpTunnelHelloInterval=l2tpTunnelHelloInterval, l2tpGlobUdpPort=l2tpGlobUdpPort, l2tpTunnelProfileReceiveWindowSize=l2tpTunnelProfileReceiveWindowSize, l2tpTunnelProfileRadiusAssignment=l2tpTunnelProfileRadiusAssignment, l2tpTunnelLocalTunnelId=l2tpTunnelLocalTunnelId, l2tpSessionLocalUdpPort=l2tpSessionLocalUdpPort, l2tpSessionRemoteHostname=l2tpSessionRemoteHostname, l2tpTunnelProfileLocalHostname=l2tpTunnelProfileLocalHostname, l2tpTunnelProfileLocalUdpPort=l2tpTunnelProfileLocalUdpPort, l2tpTunnelProfileLocalIpAddress=l2tpTunnelProfileLocalIpAddress, l2tpTunnelRemoteUdpPort=l2tpTunnelRemoteUdpPort)

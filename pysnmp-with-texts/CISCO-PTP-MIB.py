#
# PySNMP MIB module CISCO-PTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-PTP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:10:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndexOrZero, = mibBuilder.importSymbols("CISCO-TC", "InterfaceIndexOrZero")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
ModuleIdentity, NotificationType, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ObjectIdentity, Bits, Integer32, Gauge32, TimeTicks, iso, IpAddress, Counter32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "NotificationType", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ObjectIdentity", "Bits", "Integer32", "Gauge32", "TimeTicks", "iso", "IpAddress", "Counter32", "Unsigned32")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
ciscoPtpMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 760))
ciscoPtpMIB.setRevisions(('2011-01-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoPtpMIB.setRevisionsDescriptions(('Initial Version',))
if mibBuilder.loadTexts: ciscoPtpMIB.setLastUpdated('201101280000Z')
if mibBuilder.loadTexts: ciscoPtpMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoPtpMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-<list>@cisco.com')
if mibBuilder.loadTexts: ciscoPtpMIB.setDescription("The MIB module for PTPv2 (IEEE1588 - 2008) Overview of PTPv2 (IEEE 1588-2008) This IEEE standard defines a protocol enabling precise synchronization of clocks in measurement and control systems implemented with packet-based networks, the IEEE Standard PTPv2 1588 (2008). This MIB does not address the standard IEEE 1588 (2002). The protocol is applicable to network elements communicating using IP. The protocol enables heterogeneous systems that include clocks of various inherent precision, resolution, and stability to synchronize to a grandmaster clock. The protocol supports system-wide synchronization accuracy in the sub-microsecond range with minimal network and local clock computing resources. The standard uses UDP/IP. It includes formal mechanisms for message extensions, higher sampling rates, correction for asymmetry, a clock type to reduce error accumulation in large topologies, and specifications on how to incorporate the resulting additional data into the synchronization protocol. The standard defines conformance and management capability also. MIB description This MIB is to support the Precision Timing Protocol (PTP) feature of Cisco System devices. Acronyms: ARB arbitrary BMC best master clock CAN Controller Area Network CP Communication Profile [according to IEC 61784-1:200710] CPF Communication Profile Family [according to IEC 61784-1:2007] DS Differentiated Service E2E End-to-End E2ETC End-to-End Transparent Clock EUI Extended Unique Identifier. FFO Fractional Frequency Offset GPS Global Positioning System IANA Internet Assigned Numbers Authority ICV Integrity Check Value ID Identification IPv4 Internet Protocol version 4 IPv6 Internet Protocol version 6 JD Julian Date JDN Julian Day Number MAC Media Access Control [according to IEEE Std 802.3-2005] MJD Modified Julian Day NIST National Institute of Standards and Technology (see www.nist.gov) NTP Network Time Protocol (see IETF RFC 1305 [B7]) OUI Organizational Unique Identifier(allocated by the IEEE) P2P Peer-to-Peer P2PTC Peer-To-Peer Transparent Clock PHY physical layer [according to IEEE Std 802.3-2005] POSIX Portable Operating System Interface (see ISO/IEC 9945:2003) PPS Pulse per Second PTP Precision Time Protocol SA Security Associations SNTP Simple Network Time Protocol SOF Start of Frame TAI International Atomic Time TC Traffic Class TC Transparent Clock TLV Type, Length, Value [according to IEEE Std 802.1AB] ToD Time of Day Synchronization ToS Type of Service UCMM UnConnect Message Manager UDP/IP User Datagram Protocol UTC Coordinated Universal Time References: [1] Precision clock synchronization protocol for networked measurement and control systems - IEC 61588 IEEE 1588(tm) Edition 2.0 2009-02 Definitions from [1] section 3.1 Accuracy: The mean of the time or frequency error between the clock under test and a perfect reference clock, over an ensemble of measurements. Stability is a measure of how the mean varies with respect to variables such as time, temperature, and so on. The precision is a measure of the deviation of the error from the mean. Atomic process: A process is atomic if the values of all inputs to the process are not permitted to change until all of the results of the process are instantiated, and the outputs of the process are not visible to other processes until the processing of each output is complete. Boundary clock: A clock that has multiple Precision Time Protocol(PTP) ports in a domain and maintains the timescale used in the domain. It may serve as the source of time, i.e., be a master clock, and may synchronize to another clock, i.e., be a slave clock. Boundary node clock: A clock that has multiple Precision Time Protocol(PTP) ports in a domain and maintains the timescale used in the domain. It differs from the boundary clock in that the clock roles can change. Clock: A node participating in the Precision Time Protocol (PTP) that is capable of providing a measurement of the passage of time since a defined epoch. Domain: A logical grouping of clocks that synchronize to each other using the protocol, but that are not necessarily synchronized to clocks in another domain. End-to-end transparent clock: A transparent clock that supports the use of the end-to-end delay measurement mechanism between slave clocks and the master clock. Each node must measure the residence time of PTP event messages and accumulate it in Correction Field. Epoch: The origin of a timescale. Event: An abstraction of the mechanism by which signals or conditions are generated and represented. Foreign master: An ordinary or boundary clock sending Announce messages to another clock that is not the current master recognized by the other clock. Grandmaster clock: Within a domain, a clock that is the ultimate source of time for clock synchronization using the protocol. Holdover: A clock previously synchronized/syntonized to another clock (normally a primary reference or a master clock) but now free-running based on its own internal oscillator, whose frequency is being adjusted using data acquired while it had been synchronized/syntonized to the other clock. It is said to be in holdover or in the holdover mode, as long as it is within its accuracy requirements. Link: A network segment between two Precision Time Protocol ports supporting the peer delay mechanism of this standard. The peer delay mechanism is designed to measure the propagation time over such a link. Management node: A device that configures and monitors clocks. Master clock: In the context of a single Precision Time Protocol communication path, a clock that is the source of time to which all other clocks on that path synchronize. Message timestamp point: A point within a Precision Time Protocol event message serving as a reference point in the message. A timestamp is defined by the instant a message timestamp point passes the reference plane of a clock. Multicast communication: A communication model in which each Precision Time Protocol message sent from any PTP port is capable of being received and processed by all PTP ports on the same PTP communication path. Node: A device that can issue or receive Precision Time Protocol communications on a network. One-step clock: A clock that provides time information using a single event message. On-pass support: Indicates that each node in the synchronization chain from master to slave can support IEEE-1588. Ordinary clock: A clock that has a single Precision Time Protocol port in a domain and maintains the timescale used in the domain. It may serve as a source of time, i.e., be a master clock, or may synchronize to another clock, i.e., be a slave clock. Parent clock: The master clock to which a clock is synchronized. Peer-to-peer transparent clock: A transparent clock that, in addition to providing Precision Time Protocol event transit time information, also provides corrections for the propagation delay of the link connected to the port receiving the PTP event message. In the presence of peer-to-peer transparent clocks, delay measurements between slave clocks and the master clock are performed using the peer-to-peer delay measurement mechanism. Phase change rate: The observed rate of change in the measured time with respect to the reference time. The phase change rate is equal to the fractional frequency offset between the measured frequency and the reference frequency. PortNumber: An index identifying a specific Precision Time Protocol port on a PTP node. Primary reference: A source of time and or frequency that is traceable to international standards. Profile: The set of allowed Precision Time Protocol features applicable to a device. Precision Time Protocol communication: Information used in the operation of the protocol, transmitted in a PTP message over a PTP communication path. Precision Time Protocol communication path: The signaling path portion of a particular network enabling direct communication among ordinary and boundary clocks. Precision Time Protocol node: PTP ordinary, boundary, or transparent clock or a device that generates or parses PTP messages. Precision Time Protocol port: A logical access point of a clock for PTP communications to the communications network. Recognized standard time source: A recognized standard time source is a source external to Precision Time Protocol that provides time and/or frequency as appropriate that is traceable to the international standards laboratories maintaining clocks that form the basis for the International Atomic Time and Universal Coordinated Time timescales. Examples of these are Global Positioning System, NTP, and National Institute of Standards and Technology (NIST) timeservers. Requestor: The port implementing the peer-to-peer delay mechanism that initiates the mechanism by sending a Pdelay_Req message. Responder: The port responding to the receipt of a Pdelay_Req message as part of the operation of the peer-to-peer delay mechanism. Synchronized clocks: Two clocks are synchronized to a specified uncertainty if they have the same epoch and their measurements of the time of a single event at an arbitrary time differ by no more than that uncertainty. Syntonized clocks: Two clocks are syntonized if the duration of the second is the same on both, which means the time as measured by each advances at the same rate. They may or may not share the same epoch. Time of Day: Timeout: A mechanism for terminating requested activity that, at least from the requester's perspective, does not complete within the specified time. Timescale: A linear measure of time from an epoch. Traceability: A property of the result of a measurement or the value of a standard whereby it can be related to stated references, usually national or international standards, through an unbroken chain of comparisons all having stated uncertainties. Translation device: A boundary clock or, in some cases, a transparent clock that translates the protocol messages between regions implementing different transport and messaging protocols, between different versions of IEEE Std 1588-2008/IEC 61588:2009, or different Precision Time Protocol profiles. transparent clock: A device that measures the time taken for a Precision Time Protocol event message to transit the device and provides this information to clocks receiving this PTP event message. Two-step clock: A clock that provides time information using the combination of an event message and a subsequent general message. The below table specifies the object formats of the various textual conventions used. Data type mapping Textual Convention SYNTAX -------------------- ------------------ --------------------- 5.3.2 TimeInterval ClockTimeInterval OCTET STRING(SIZE(1..255)) 5.3.3 Timestamp ClockTimestamp OCTET STRING(SIZE(6)) 5.3.4 ClockIdentity ClockIdentity OCTET STRING(SIZE(1..255)) 5.3.5 PortIdentity ClockPortNumber INTEGER(1..65535) 5.3.7 ClockQuality ClockQualityClassType Simple master-slave hierarchy [1] section 6.6.2.4 --------------- - Ordinary - - Clock(1) - - GrandMaster - -------M------- | 1 | -------S------------------------------- - Boundary - - Clock(1) - --------------M------------------M----- | | 2 3 | | -----S------ -------S------------------ - Ordinary - - Boundary - - Clock(2) - - Clock(2) - ------------ -----M-------------M------ | | 4 5 | | -----S------ -----S------ - Ordinary - - Ordinary - - Clock(3) - - Clock(4) - ------------ ------------ Grandmaster Boundary Clock(0-N) Ordinary Clocks(0-N) Ordinary Clocks(0-N) Relationship cardinality PTP system 1 : N PTP Clock PTP Clock 1 : 1 Domain PTP Clock 1 : N PTP Ports PTP Port N : N Physical Port (interface in IF-MIB) Transparent clock diagram from section 6.7.1.3 of [1] +----------------------------+ | Boundary clock - 1 | +----------------------------+ | | | | +-- A --+ B | | +---------------------+ | | Ordinary clock - 1| | +---------------------+ | +----------------------+ +--------------+ | End-to-end | | Ordinary |------------------| transparent clock- | | clock 1-1 | | 1 - 1 | +--------------+ +----------------------+ | | C | | +----------------------+ +--------------+ | End-to-end | | Ordinary |------------------| transparent clock- | | clock 1-2 | | 1 - 2 | +--------------+ +----------------------+ The MIB refers to the sections of the IEEE 1588 standard for reference. Throughout the MIB various secions from the standard are referenced")
class ClockDomainType(TextualConvention, Unsigned32):
    reference = 'Section 7.1 Domains and Table 2 of [1]'
    description = 'The Domain is identified by an integer, the domainNumber, in the range of 0 to 255. An integer value that is used to assign each PTP device to a particular domain. The following values define the valid domains. [1] Section 7.1 Domains Table 2 Value definition. --------- ------------------- 0 Default domain 1 Alternate domain 1 2 Alternate domain 2 3 Alternate domain 3 4 - 127 User-defined domains 128 - 255 Reserved'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class ClockIdentity(TextualConvention, OctetString):
    reference = 'Section 7.5.2.2.1 from [1]'
    description = 'The clock Identity is an 8-octet array and will be presented in the form of a character array. The value of the ClockIdentity should be taken from the IEEE EUI-64 individual assigned numbers as indicated in Section 7.5.2.2.2 of [1]. The EUI-64 address is divided into the following fields. OUI byte[0-2] Extension identifier bytes:[3-7] The clock identifier can be constructed from existing EUI-48 assignments and here is an abbreviated example extracted from section 7.5.2.2.2 [1]. Company EUI-48 = 0xACDE4823456716 EUI-64 = ACDE48FFFE23456716 It is important to note the IEEE Registration Authority has deprecated the use of MAC-48 in any new design.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class ClockIntervalBase2(TextualConvention, Integer32):
    reference = 'Section 7.7.2.1 General interval specification of [1]'
    description = 'The interval included in message types Announce, Sync, Delay_Req, and Pdelay_Req as indicated in section 7.7.2.1 of [1]. The mean time interval between successive messages shall be represented as the logarithm to the base 2 of this time interval measured in seconds on the local clock of the device sending the message. The values of these logarithmic attributes shall be selected from integers in the range -128 to 127 subject to further limits established in an applicable PTP profile.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-128, 127)

class ClockMechanismType(TextualConvention, Integer32):
    reference = 'Sections 8.2.5.4.4, 6.6.4 and 7.4.2 of [1].'
    description = 'The clock type based on whether End to End or peer to peer mechanisms are used. The mechanism used to calculate the Mean Path Delay as indicated in Table 9 of IEEE 1588-2008. Delay mechanism Value(hex) Specification E2E 01 The port is configured to use the delay request-response mechanism. P2P 02 The port is configured to use the peer delay mechanism. DISABLED FE The port does not implement the delay mechanism.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 254))
    namedValues = NamedValues(("e2e", 1), ("p2p", 2), ("disabled", 254))

class ClockInstanceType(TextualConvention, Unsigned32):
    description = 'The instance of the Clock of a given clock type in a given domain.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class ClockPortNumber(TextualConvention, Unsigned32):
    reference = 'Section 7.5.2.3 Port Number and 5.3.5 of [1]'
    description = 'An index identifying a specific Precision Time Protocol (PTP) port on a PTP node.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class ClockPortState(TextualConvention, Integer32):
    reference = 'Section 8.2.5.3.1 portState and 9.2.5 of [1]'
    description = 'This is the value of the current state of the protocol engine associated with this port. Port state Value Description ----------------------------------------------------------- initializing 1 In this state a port initializes its data sets, hardware, and communication facilities. faulty 2 The fault state of the protocol. disabled 3 The port shall not place any messages on its communication path. listening 4 The port is waiting for the announceReceiptTimeout to expire or to receive an Announce message from a master. preMaster 5 The port shall behave in all respects as though it were in the MASTER state except that it shall not place any messages on its communication path except for Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, signaling, or management messages. master 6 The port is behaving as a master port. passive 7 The port shall not place any messages on its communication path except for Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, or signaling messages, or management messages that are a required response to another management message uncalibrated 8 The local port is preparing to synchronize to the master port. slave 9 The port is synchronizing to the selected master port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("preMaster", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9))

class ClockProfileType(TextualConvention, Integer32):
    reference = 'Section 3.1.30 and 19.3 PTP profiles of [1]'
    description = 'Clock Profile used. From [1] section 3.1.30, Profile is the set of allowed Precision Time Protocol (PTP) features applicable to a device.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("default", 1), ("telecom", 2), ("vendorspecific", 3))

class ClockQualityAccuracyType(TextualConvention, Integer32):
    reference = 'Section 5.3.7, 7.6.2.5 and Table 6 of [1]'
    description = 'The ClockQuality as specified in section 5.3.7, 7.6.2.5 and Table 6 of [1]. The following values are not represented in the enumerated values. 0x01-0x1F Reserved 0x32-0x7F Reserved It is important to note that section 7.1.1 RFC2578 allows for gaps and enumerate values to start with zero when indicated by the protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254, 255))
    namedValues = NamedValues(("reserved00", 1), ("nanoSecond25", 32), ("nanoSecond100", 33), ("nanoSecond250", 34), ("microSec1", 35), ("microSec2dot5", 36), ("microSec10", 37), ("microSec25", 38), ("microSec100", 39), ("microSec250", 40), ("milliSec1", 41), ("milliSec2dot5", 42), ("milliSec10", 43), ("milliSec25", 44), ("milliSec100", 45), ("milliSec250", 46), ("second1", 47), ("second10", 48), ("secondGreater10", 49), ("unknown", 254), ("reserved255", 255))

class ClockQualityClassType(TextualConvention, Unsigned32):
    reference = 'section 5.3.7, 7.6.2.4 and Table 5 of [1].'
    description = 'The ClockQuality as specified in section 5.3.7, 7.6.2.4 and Table 5 of [1]. Value Description ------ ---------------------------------------------------------- 0 Reserved to enable compatibility with future versions. 1-5 Reserved 6 Shall designate a clock that is synchronized to a primary reference time source. The timescale distributed shall be PTP. A clockClass 6 clock shall not be a slave to another clock in the domain. 7 Shall designate a clock that has previously been designated as clockClass 6 but that has lost the ability to synchronize to a primary reference time source and is in holdover mode and within holdover specifications. The timescale distributed shall be PTP. A clockClass 7 clock shall not be a slave to another clock in the domain. 8 Reserved. 9-10 Reserved to enable compatibility with future versions. 11-12 Reserved. 13 Shall designate a clock that is synchronized to an application-specific source of time. The timescale distributed shall be ARB. A clockClass 13 clock shall not be a slave to another clock in the domain. 14 Shall designate a clock that has previously been designated as clockClass 13 but that has lost the ability to synchronize to an application-specific source of time and is in holdover mode and within holdover specifications. The timescale distributed shall be ARB. A clockClass 14 clock shall not be a slave to another clock in the domain. 15-51 Reserved. 52 Degradation alternative A for a clock of clockClass 7 that is not within holdover specification. A clock of clockClass 52 shall not be a slave to another clock in the domain. 53-57 Reserved. 58 Degradation alternative A for a clock of clockClass 14 that is not within holdover specification. A clock of clockClass 58 shall not be a slave to another clock in the domain. 59-67 Reserved. 68-122 For use by alternate PTP profiles. 123-127 Reserved. 128-132 Reserved. 133-170 For use by alternate PTP profiles. 171-186 Reserved. 187 Degradation alternative B for a clock of clockClass 7 that is not within holdover specification. A clock of clockClass 187 may be a slave to another clock in the domain. 188-192 Reserved. 193 Degradation alternative B for a clock of clockClass 14 that is not within holdover specification. A clock of clockClass 193 may be a slave to another clock in the domain. 194-215 Reserved. 216-232 For use by alternate PTP profiles. 233-247 Reserved. 248 Default. This clockClass shall be used if none of the other clockClass definitions apply. 249-250 Reserved. 251 Reserved for version 1 compatibility; see Clause 18. 252-254 Reserved. 255 Shall be the clockClass of a slave-only clock; see 9.2.2.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class ClockRoleType(TextualConvention, Integer32):
    description = 'The Clock Role. The protocol generates a Master Slave relationship among the clocks in the system. Clock Role Value Description -------------------------------------------------------------- Master clock 1 A clock that is the source of time to which all other clocks on that path synchronize. Slave clock 2 A clock which synchronizes to another clock (master).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("master", 1), ("slave", 2))

class ClockStateType(TextualConvention, Integer32):
    description = 'The clock state returned by PTP engine. Clock State Value Description -------------------------------------------------------------- Freerun state 1 Applies to a slave device that is not locked to a master. This is the initial state a slave starts out with when it is not getting any PTP packets from the master or because of some other input error (erroneous packets, etc). Holdover state 2 In this state the slave device is locked to a master but communication with the master is lost or the timestamps in the ptp packets are incorrect. But since the slave was locked to the master, it can run with the same accuracy for sometime. The slave can continue to operate in this state for some time. If communication with the master is not restored for a while, the device is moved to the FREERUN state. Acquiring state 3 The slave device is receiving packets from a master and is trying to acquire a lock. Freq_locked state 4 Slave device is locked to the Master with respect to frequency, but not phase aligned Phase_aligned state 5 Locked to the master with respect to frequency and phase.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("freerun", 1), ("holdover", 2), ("acquiring", 3), ("frequencyLocked", 4), ("phaseAligned", 5))

class ClockTimeSourceType(TextualConvention, Integer32):
    reference = 'section 5.3.7, 7.6.2.6 and Table 7 of [1].'
    description = 'The ClockQuality as specified in section 5.3.7, 7.6.2.6 and Table 7 of [1]. The following values are not represented in the enumerated values. 0xF0-0xFE For use by alternate PTP profiles 0xFF Reserved It is important to note that section 7.1.1 RFC2578 allows for gaps and enumerate values to start with zero when indicated by the protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 96, 144, 160))
    namedValues = NamedValues(("atomicClock", 16), ("gps", 32), ("terrestrialRadio", 48), ("ptp", 64), ("ntp", 80), ("handSet", 96), ("other", 144), ("internalOsillator", 160))

class ClockTimeInterval(TextualConvention, OctetString):
    reference = 'Section 5.3.2 and setion 7.7.2.1 Timer interval specification of [1]'
    description = 'This textual convention corresponds to the TimeInterval structure indicated in section 5.3.2 of [1]. It will be presented in the form of a character array. The TimeInterval type represents time intervals. struct TimeInterval { Integer64 scaledNanoseconds; }; The scaledNanoseconds member is the time interval expressed in units of nanoseconds and multiplied by 2**16. Positive or negative time intervals outside the maximum range of this data type shall be encoded as the largest positive and negative values of the data type, respectively. For example, 2.5 ns is expressed as 0000 0000 0002 8000 in Base16.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class ClockTxModeType(TextualConvention, Integer32):
    description = 'Transmission mode. unicast. Using unicast commnuication channel. multicast. Using Multicast communication channel. multicast-mix. Using multicast-unicast communication channel'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unicast", 1), ("multicast", 2), ("multicastmix", 3))

class ClockType(TextualConvention, Integer32):
    reference = 'section 6.5.1 of [1].'
    description = 'The clock types as defined in the MIB module description.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ordinaryClock", 1), ("boundaryClock", 2), ("transparentClock", 3), ("boundaryNode", 4))

ciscoPtpMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 0))
ciscoPtpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 1))
ciscoPtpMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 2))
ciscoPtpMIBSystemInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1))
ciscoPtpMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 1))
ciscoPtpMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2))
ciscoPtpMIBCompliances1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 1, 1)).setObjects(("CISCO-PTP-MIB", "ciscoPtpMIBSystemInfoGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBCompliances1 = ciscoPtpMIBCompliances1.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBCompliances1.setDescription('Compliance statement for agents that provide read-only support for CISCO-PTP-MIB. Such devices can only be monitored using this MIB module. The Module is implemented with support for read-only. In other words, only monitoring is available by implementing this MODULE-COMPLIANCE.')
ciscoPtpMIBCompliances2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 1, 2)).setObjects(("CISCO-PTP-MIB", "ciscoPtpMIBClockCurrentDSGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockParentDSGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockDefaultDSGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockRunningGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockTimepropertiesGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBCompliances2 = ciscoPtpMIBCompliances2.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBCompliances2.setDescription('Compliance statement for agents that provide read-only support for CISCO-PTP-MIB. Such devices can only be monitored using this MIB module. The Module is implemented with support for read-only. In other words, only monitoring is available by implementing this MODULE-COMPLIANCE.')
ciscoPtpMIBCompliances3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 1, 3)).setObjects(("CISCO-PTP-MIB", "ciscoPtpMIBClockPortGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockPortDSGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockPortRunningGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockPortAssociateGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBCompliances3 = ciscoPtpMIBCompliances3.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBCompliances3.setDescription('Compliance statement for agents that provide read-only support for CISCO-PTP-MIB. Such devices can only be monitored using this MIB module. The Module is implemented with support for read-only. In other words, only monitoring is available by implementing this MODULE-COMPLIANCE.')
ciscoPtpMIBCompliances4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 1, 4)).setObjects(("CISCO-PTP-MIB", "ciscoPtpMIBClockTranparentDSGroup"), ("CISCO-PTP-MIB", "ciscoPtpMIBClockPortTransDSGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBCompliances4 = ciscoPtpMIBCompliances4.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBCompliances4.setDescription('Compliance statement for agents that provide read-only support for CISCO-PTP-MIB. Such devices can only be monitored using this MIB module. The Module is implemented with support for read-only. In other words, only monitoring is available by implementing this MODULE-COMPLIANCE.')
ciscoPtpMIBSystemInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 1)).setObjects(("CISCO-PTP-MIB", "cPtpSystemDomainTotals"), ("CISCO-PTP-MIB", "cPtpDomainClockPortsTotal"), ("CISCO-PTP-MIB", "cPtpDomainClockPortPhysicalInterfacesTotal"), ("CISCO-PTP-MIB", "cPtpClockInput1ppsEnabled"), ("CISCO-PTP-MIB", "cPtpClockOutput1ppsEnabled"), ("CISCO-PTP-MIB", "cPtpClockOutput1ppsOffsetEnabled"), ("CISCO-PTP-MIB", "cPtpClockInputFrequencyEnabled"), ("CISCO-PTP-MIB", "cPtpClockTODEnabled"), ("CISCO-PTP-MIB", "cPtpClockOutput1ppsOffsetValue"), ("CISCO-PTP-MIB", "cPtpClockOutput1ppsOffsetNegative"), ("CISCO-PTP-MIB", "cPtpSystemProfile"), ("CISCO-PTP-MIB", "cPtpClockInput1ppsInterface"), ("CISCO-PTP-MIB", "cPtpClockOutput1ppsInterface"), ("CISCO-PTP-MIB", "cPtpClockTODInterface"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBSystemInfoGroup = ciscoPtpMIBSystemInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBSystemInfoGroup.setDescription('Group which aggregates objects describing system-wide information')
ciscoPtpMIBClockCurrentDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 2)).setObjects(("CISCO-PTP-MIB", "cPtpClockCurrentDSStepsRemoved"), ("CISCO-PTP-MIB", "cPtpClockCurrentDSOffsetFromMaster"), ("CISCO-PTP-MIB", "cPtpClockCurrentDSMeanPathDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockCurrentDSGroup = ciscoPtpMIBClockCurrentDSGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockCurrentDSGroup.setDescription('Group which aggregates objects describing PTP Current Dataset information')
ciscoPtpMIBClockParentDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 3)).setObjects(("CISCO-PTP-MIB", "cPtpClockParentDSParentPortIdentity"), ("CISCO-PTP-MIB", "cPtpClockParentDSParentStats"), ("CISCO-PTP-MIB", "cPtpClockParentDSOffset"), ("CISCO-PTP-MIB", "cPtpClockParentDSClockPhChRate"), ("CISCO-PTP-MIB", "cPtpClockParentDSGMClockIdentity"), ("CISCO-PTP-MIB", "cPtpClockParentDSGMClockPriority1"), ("CISCO-PTP-MIB", "cPtpClockParentDSGMClockPriority2"), ("CISCO-PTP-MIB", "cPtpClockParentDSGMClockQualityClass"), ("CISCO-PTP-MIB", "cPtpClockParentDSGMClockQualityAccuracy"), ("CISCO-PTP-MIB", "cPtpClockParentDSGMClockQualityOffset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockParentDSGroup = ciscoPtpMIBClockParentDSGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockParentDSGroup.setDescription('Group which aggregates objects describing PTP Parent Dataset information')
ciscoPtpMIBClockDefaultDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 4)).setObjects(("CISCO-PTP-MIB", "cPtpClockDefaultDSTwoStepFlag"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSClockIdentity"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSPriority1"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSPriority2"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSSlaveOnly"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSQualityClass"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSQualityAccuracy"), ("CISCO-PTP-MIB", "cPtpClockDefaultDSQualityOffset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockDefaultDSGroup = ciscoPtpMIBClockDefaultDSGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockDefaultDSGroup.setDescription('Group which aggregates objects describing PTP Default Dataset information')
ciscoPtpMIBClockRunningGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 5)).setObjects(("CISCO-PTP-MIB", "cPtpClockRunningState"), ("CISCO-PTP-MIB", "cPtpClockRunningPacketsSent"), ("CISCO-PTP-MIB", "cPtpClockRunningPacketsReceived"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockRunningGroup = ciscoPtpMIBClockRunningGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockRunningGroup.setDescription('Group which aggregates objects describing PTP running state information')
ciscoPtpMIBClockTimepropertiesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 6)).setObjects(("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSCurrentUTCOffsetValid"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSCurrentUTCOffset"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSLeap59"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSLeap61"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSTimeTraceable"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSFreqTraceable"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSPTPTimescale"), ("CISCO-PTP-MIB", "cPtpClockTimePropertiesDSSource"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockTimepropertiesGroup = ciscoPtpMIBClockTimepropertiesGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockTimepropertiesGroup.setDescription('Group which aggregates objects describing PTP Time Properties information')
ciscoPtpMIBClockTranparentDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 7)).setObjects(("CISCO-PTP-MIB", "cPtpClockTransDefaultDSClockIdentity"), ("CISCO-PTP-MIB", "cPtpClockTransDefaultDSNumOfPorts"), ("CISCO-PTP-MIB", "cPtpClockTransDefaultDSDelay"), ("CISCO-PTP-MIB", "cPtpClockTransDefaultDSPrimaryDomain"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockTranparentDSGroup = ciscoPtpMIBClockTranparentDSGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockTranparentDSGroup.setDescription('Group which aggregates objects describing PTP Transparent Dataset information')
ciscoPtpMIBClockPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 8)).setObjects(("CISCO-PTP-MIB", "cPtpClockPortName"), ("CISCO-PTP-MIB", "cPtpClockPortSyncOneStep"), ("CISCO-PTP-MIB", "cPtpClockPortCurrentPeerAddress"), ("CISCO-PTP-MIB", "cPtpClockPortNumOfAssociatedPorts"), ("CISCO-PTP-MIB", "cPtpClockPortCurrentPeerAddressType"), ("CISCO-PTP-MIB", "cPtpClockPortRole"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockPortGroup = ciscoPtpMIBClockPortGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockPortGroup.setDescription('Group which aggregates objects describing information for a given PTP Port.')
ciscoPtpMIBClockPortDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 9)).setObjects(("CISCO-PTP-MIB", "cPtpClockPortDSName"), ("CISCO-PTP-MIB", "cPtpClockPortDSPortIdentity"), ("CISCO-PTP-MIB", "cPtpClockPortDSAnnouncementInterval"), ("CISCO-PTP-MIB", "cPtpClockPortDSAnnounceRctTimeout"), ("CISCO-PTP-MIB", "cPtpClockPortDSSyncInterval"), ("CISCO-PTP-MIB", "cPtpClockPortDSMinDelayReqInterval"), ("CISCO-PTP-MIB", "cPtpClockPortDSPeerDelayReqInterval"), ("CISCO-PTP-MIB", "cPtpClockPortDSDelayMech"), ("CISCO-PTP-MIB", "cPtpClockPortDSPeerMeanPathDelay"), ("CISCO-PTP-MIB", "cPtpClockPortDSGrantDuration"), ("CISCO-PTP-MIB", "cPtpClockPortDSPTPVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockPortDSGroup = ciscoPtpMIBClockPortDSGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockPortDSGroup.setDescription('Group which aggregates objects describing PTP Port Dataset information')
ciscoPtpMIBClockPortRunningGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 10)).setObjects(("CISCO-PTP-MIB", "cPtpClockPortRunningName"), ("CISCO-PTP-MIB", "cPtpClockPortRunningState"), ("CISCO-PTP-MIB", "cPtpClockPortRunningRole"), ("CISCO-PTP-MIB", "cPtpClockPortRunningInterfaceIndex"), ("CISCO-PTP-MIB", "cPtpClockPortRunningIPversion"), ("CISCO-PTP-MIB", "cPtpClockPortRunningEncapsulationType"), ("CISCO-PTP-MIB", "cPtpClockPortRunningTxMode"), ("CISCO-PTP-MIB", "cPtpClockPortRunningRxMode"), ("CISCO-PTP-MIB", "cPtpClockPortRunningPacketsReceived"), ("CISCO-PTP-MIB", "cPtpClockPortRunningPacketsSent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockPortRunningGroup = ciscoPtpMIBClockPortRunningGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockPortRunningGroup.setDescription('Group which aggregates objects describing PTP running interface information')
ciscoPtpMIBClockPortTransDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 11)).setObjects(("CISCO-PTP-MIB", "cPtpClockPortTransDSPortIdentity"), ("CISCO-PTP-MIB", "cPtpClockPortTransDSlogMinPdelayReqInt"), ("CISCO-PTP-MIB", "cPtpClockPortTransDSFaultyFlag"), ("CISCO-PTP-MIB", "cPtpClockPortTransDSPeerMeanPathDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockPortTransDSGroup = ciscoPtpMIBClockPortTransDSGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockPortTransDSGroup.setDescription('Group which aggregates objects describing PTP TransparentDS Dataset information')
ciscoPtpMIBClockPortAssociateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 760, 2, 2, 12)).setObjects(("CISCO-PTP-MIB", "cPtpClockPortAssociatePacketsSent"), ("CISCO-PTP-MIB", "cPtpClockPortAssociatePacketsReceived"), ("CISCO-PTP-MIB", "cPtpClockPortAssociateAddress"), ("CISCO-PTP-MIB", "cPtpClockPortAssociateAddressType"), ("CISCO-PTP-MIB", "cPtpClockPortAssociateInErrors"), ("CISCO-PTP-MIB", "cPtpClockPortAssociateOutErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPtpMIBClockPortAssociateGroup = ciscoPtpMIBClockPortAssociateGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPtpMIBClockPortAssociateGroup.setDescription('Group which aggregates objects describing information on peer PTP ports for a given PTP clock-port.')
ciscoPtpMIBClockInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2))
cPtpSystemTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 1), )
if mibBuilder.loadTexts: cPtpSystemTable.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemTable.setDescription('Table of count information about the PTP system for all domains.')
cPtpSystemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpInstanceIndex"))
if mibBuilder.loadTexts: cPtpSystemEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemEntry.setDescription('An entry in the table, containing count information about a single domain. New row entries are added when the PTP clock for this domain is configured, while the unconfiguration of the PTP clock removes it.')
cPtpDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 1, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices. The Clock Domain is a logical group of clocks and devices that synchronize with each other using the PTP protocol. 0 Default domain 1 Alternate domain 1 2 Alternate domain 2 3 Alternate domain 3 4 - 127 User-defined domains 128 - 255 Reserved')
cPtpInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 1, 1, 2), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpInstanceIndex.setDescription('This object specifies the instance of the Clock for this domain.')
cPtpDomainClockPortsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 1, 1, 3), Gauge32()).setUnits('ptp ports').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpDomainClockPortsTotal.setStatus('current')
if mibBuilder.loadTexts: cPtpDomainClockPortsTotal.setDescription('This object specifies the total number of clock ports configured within a domain.')
cPtpDomainClockPortPhysicalInterfacesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 1, 1, 4), Gauge32()).setUnits('physical ports').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpDomainClockPortPhysicalInterfacesTotal.setStatus('current')
if mibBuilder.loadTexts: cPtpDomainClockPortPhysicalInterfacesTotal.setDescription('This object specifies the total number of clock port Physical interfaces configured within a domain instance for PTP communications.')
cPtpSystemDomainTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 2), )
if mibBuilder.loadTexts: cPtpSystemDomainTable.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemDomainTable.setDescription('Table of information about the PTP system for all clock modes -- ordinary, boundary or transparent.')
cPtpSystemDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpSystemDomainClockTypeIndex"))
if mibBuilder.loadTexts: cPtpSystemDomainEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemDomainEntry.setDescription('An entry in the table, containing information about a single clock mode for the PTP system. A row entry gets added when PTP clocks are configured on the router.')
cPtpSystemDomainClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 2, 1, 1), ClockType())
if mibBuilder.loadTexts: cPtpSystemDomainClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemDomainClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpSystemDomainTotals = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 2, 1, 2), Gauge32()).setUnits('domains').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpSystemDomainTotals.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemDomainTotals.setDescription('This object specifies the total number of PTP domains for this particular clock type configured in this node.')
cPtpClockNodeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3), )
if mibBuilder.loadTexts: cPtpClockNodeTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockNodeTable.setDescription('Table of information about the PTP system for a given domain.')
cPtpClockNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockNodeEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockNodeEntry.setDescription('An entry in the table, containing information about a single domain. A entry is added when a new PTP clock domain is configured on the router.')
cPtpClockDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockInstanceIndex.setDescription('This object specifies the instance of the Clock for this clock type for the given domain.')
cPtpClockInput1ppsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockInput1ppsEnabled.setStatus('current')
if mibBuilder.loadTexts: cPtpClockInput1ppsEnabled.setDescription('This object specifies whether the node is enabled for PTP input clocking using the 1pps interface.')
cPtpClockInputFrequencyEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockInputFrequencyEnabled.setStatus('current')
if mibBuilder.loadTexts: cPtpClockInputFrequencyEnabled.setDescription('This object specifies whether enabled for Frequency input using the 1.544 Mhz, 2.048 Mhz, or 10Mhz timing interface.')
cPtpClockTODEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTODEnabled.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTODEnabled.setDescription('This object specifies whether the node is enabled for TOD.')
cPtpClockOutput1ppsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockOutput1ppsEnabled.setStatus('current')
if mibBuilder.loadTexts: cPtpClockOutput1ppsEnabled.setDescription('This object specifies whether the node is enabled for PTP input clocking using the 1pps interface.')
cPtpClockOutput1ppsOffsetEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetEnabled.setReference('section 11 Clock offset, path delay, residence time, and asymmetry corrections of [1]')
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetEnabled.setStatus('current')
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetEnabled.setDescription('This object specifies whether an offset is configured in order to compensate for a known phase error such as network asymmetry.')
cPtpClockOutput1ppsOffsetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetValue.setStatus('current')
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetValue.setDescription('This object specifies the fixed offset value configured to be added for the 1pps output.')
cPtpClockOutput1ppsOffsetNegative = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetNegative.setStatus('current')
if mibBuilder.loadTexts: cPtpClockOutput1ppsOffsetNegative.setDescription('This object specifies whether the added (fixed) offset to the 1pps output is negative or not. When object returns TRUE the offset is negative and when object returns FALSE the offset is positive.')
cPtpClockInput1ppsInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockInput1ppsInterface.setStatus('current')
if mibBuilder.loadTexts: cPtpClockInput1ppsInterface.setDescription('This object specifies the 1pps interface used for PTP input clocking.')
cPtpClockOutput1ppsInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockOutput1ppsInterface.setStatus('current')
if mibBuilder.loadTexts: cPtpClockOutput1ppsInterface.setDescription('This object specifies the 1pps interface used for PTP output clocking.')
cPtpClockTODInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 3, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTODInterface.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTODInterface.setDescription('This object specifies the interface used for PTP TOD.')
cPtpSystemProfile = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 1, 4), ClockProfileType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpSystemProfile.setReference('Section 19.3 PTP profiles of [1]')
if mibBuilder.loadTexts: cPtpSystemProfile.setStatus('current')
if mibBuilder.loadTexts: cPtpSystemProfile.setDescription('This object specifies the PTP Profile implemented on the system.')
cPtpClockCurrentDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1), )
if mibBuilder.loadTexts: cPtpClockCurrentDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSTable.setDescription('Table of information about the PTP clock Current Datasets for all domains.')
cPtpClockCurrentDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockCurrentDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockCurrentDSClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockCurrentDSInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockCurrentDSEntry.setReference('1588 Version 2.0 Section 8.2.2 currentDS data set member specifications of [1]')
if mibBuilder.loadTexts: cPtpClockCurrentDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSEntry.setDescription('An entry in the table, containing information about a single PTP clock Current Datasets for a domain.')
cPtpClockCurrentDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockCurrentDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockCurrentDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockCurrentDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockCurrentDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockCurrentDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockCurrentDSStepsRemoved = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1, 4), Counter32()).setUnits('steps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockCurrentDSStepsRemoved.setReference('1588 Version 2.0 Section 8.2.2.2 stepsRemoved')
if mibBuilder.loadTexts: cPtpClockCurrentDSStepsRemoved.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSStepsRemoved.setDescription('The current clock dataset StepsRemoved value. This object specifies the distance measured by the number of Boundary clocks between the local clock and the Foreign master as indicated in the stepsRemoved field of Announce messages.')
cPtpClockCurrentDSOffsetFromMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1, 5), ClockTimeInterval()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockCurrentDSOffsetFromMaster.setReference('1588 Version 2.0 Section 8.2.2.3 of [1]')
if mibBuilder.loadTexts: cPtpClockCurrentDSOffsetFromMaster.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSOffsetFromMaster.setDescription('This object specifies the current clock dataset ClockOffset value. The value of the computation of the offset in time between a slave and a master clock.')
cPtpClockCurrentDSMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 1, 1, 6), ClockTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockCurrentDSMeanPathDelay.setReference('1588 Version 2.0 Section 8.2.2.4 mean path delay')
if mibBuilder.loadTexts: cPtpClockCurrentDSMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: cPtpClockCurrentDSMeanPathDelay.setDescription('This object specifies the current clock dataset MeanPathDelay value. The mean path delay between a pair of ports as measure by the delay request-response mechanism.')
cPtpClockParentDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2), )
if mibBuilder.loadTexts: cPtpClockParentDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSTable.setDescription('Table of information about the PTP clock Parent Datasets for all domains.')
cPtpClockParentDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockParentDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockParentDSClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockParentDSInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockParentDSEntry.setReference('Section 8.2.3 parentDS data set member specifications of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSEntry.setDescription('An entry in the table, containing information about a single PTP clock Parent Datasets for a domain.')
cPtpClockParentDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockParentDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockParentDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockParentDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockParentDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockParentDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockParentDSParentPortIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSParentPortIdentity.setReference('section 8.2.3.2 parentDS.parentPortIdentity of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSParentPortIdentity.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSParentPortIdentity.setDescription('This object specifies the value of portIdentity of the port on the master that issues the Sync messages used in synchronizing this clock.')
cPtpClockParentDSParentStats = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSParentStats.setReference('section 8.2.3.3 parentDS.parentStats of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSParentStats.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSParentStats.setDescription('This object specifies the Parent Dataset ParentStats value. This value indicates whether the values of ParentDSOffset and ParentDSClockPhChRate have been measured and are valid. A TRUE value shall indicate valid data.')
cPtpClockParentDSOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 6), ClockIntervalBase2().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSOffset.setReference('section 8.2.3.4 parentDS.observedParentOffsetScaledLogVariance [1]')
if mibBuilder.loadTexts: cPtpClockParentDSOffset.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSOffset.setDescription('This object specifies the Parent Dataset ParentOffsetScaledLogVariance value. This value is the variance of the parent clocks phase as measured by the local clock.')
cPtpClockParentDSClockPhChRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSClockPhChRate.setReference('section 8.2.3.5 parentDS.observedParentClockPhaseChangeRate of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSClockPhChRate.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSClockPhChRate.setDescription("This object specifies the clock's parent dataset ParentClockPhaseChangeRate value. This value is an estimate of the parent clocks phase change rate as measured by the slave clock.")
cPtpClockParentDSGMClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 8), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSGMClockIdentity.setReference('section 8.2.3.6 parentDS.grandmasterIdentity of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockIdentity.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockIdentity.setDescription('This object specifies the parent dataset Grandmaster clock identity.')
cPtpClockParentDSGMClockPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSGMClockPriority1.setReference('section 8.2.3.8 parentDS.grandmasterPriority1 of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockPriority1.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockPriority1.setDescription('This object specifies the parent dataset Grandmaster clock priority1.')
cPtpClockParentDSGMClockPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSGMClockPriority2.setReference('section 8.2.3.9 parentDS.grandmasterPriority2 of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockPriority2.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockPriority2.setDescription('This object specifies the parent dataset grandmaster clock priority2.')
cPtpClockParentDSGMClockQualityClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 11), ClockQualityClassType().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityClass.setReference('section 8.2.3.7 parentDS.grandmasterClockQuality of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityClass.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityClass.setDescription('This object specifies the parent dataset grandmaster clock quality class.')
cPtpClockParentDSGMClockQualityAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 12), ClockQualityAccuracyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityAccuracy.setReference('section 8.2.3.7 parentDS.grandmasterClockQuality of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityAccuracy.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityAccuracy.setDescription('This object specifies the parent dataset grandmaster clock quality accuracy.')
cPtpClockParentDSGMClockQualityOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 2, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityOffset.setReference('section 8.2.3.7 parentDS.grandmasterClockQuality of [1]')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityOffset.setStatus('current')
if mibBuilder.loadTexts: cPtpClockParentDSGMClockQualityOffset.setDescription('This object specifies the parent dataset grandmaster clock quality offset.')
cPtpClockDefaultDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3), )
if mibBuilder.loadTexts: cPtpClockDefaultDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSTable.setDescription('Table of information about the PTP clock Default Datasets for all domains.')
cPtpClockDefaultDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockDefaultDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockDefaultDSClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockDefaultDSInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockDefaultDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSEntry.setDescription('An entry in the table, containing information about a single PTP clock Default Datasets for a domain.')
cPtpClockDefaultDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockDefaultDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockDefaultDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockDefaultDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockDefaultDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockDefaultDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockDefaultDSTwoStepFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSTwoStepFlag.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSTwoStepFlag.setDescription('This object specifies whether the Two Step process is used.')
cPtpClockDefaultDSClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 5), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSClockIdentity.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSClockIdentity.setDescription('This object specifies the default Datasets clock identity.')
cPtpClockDefaultDSPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSPriority1.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSPriority1.setDescription('This object specifies the default Datasets clock Priority1.')
cPtpClockDefaultDSPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSPriority2.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSPriority2.setDescription('This object specifies the default Datasets clock Priority2.')
cPtpClockDefaultDSSlaveOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSSlaveOnly.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSSlaveOnly.setDescription('Whether the SlaveOnly flag is set.')
cPtpClockDefaultDSQualityClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 9), ClockQualityClassType().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSQualityClass.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSQualityClass.setDescription('This object specifies the default dataset Quality Class.')
cPtpClockDefaultDSQualityAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 10), ClockQualityAccuracyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSQualityAccuracy.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSQualityAccuracy.setDescription('This object specifies the default dataset Quality Accurarcy.')
cPtpClockDefaultDSQualityOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockDefaultDSQualityOffset.setStatus('current')
if mibBuilder.loadTexts: cPtpClockDefaultDSQualityOffset.setDescription('This object specifies the default dataset Quality offset.')
cPtpClockRunningTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4), )
if mibBuilder.loadTexts: cPtpClockRunningTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningTable.setDescription('Table of information about the PTP clock Running Datasets for all domains.')
cPtpClockRunningEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockRunningDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockRunningClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockRunningInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockRunningEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningEntry.setDescription('An entry in the table, containing information about a single PTP clock running Datasets for a domain.')
cPtpClockRunningDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockRunningDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockRunningClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockRunningClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockRunningInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockRunningInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockRunningState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1, 4), ClockStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockRunningState.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningState.setDescription('This object specifies the Clock state returned by PTP engine which was described earlier. Freerun state. Applies to a slave device that is not locked to a master. This is the initial state a slave starts out with when it is not getting any PTP packets from the master or because of some other input error (erroneous packets, etc). Holdover state. In this state the slave device is locked to a master but communication with the master is lost or the timestamps in the ptp packets are incorrect. But since the slave was locked to the master, it can run with the same accuracy for sometime. The slave can continue to operate in this state for some time. If communication with the master is not restored for a while, the device is moved to the FREERUN state. Acquiring state. The slave device is receiving packets from a master and is trying to acquire a lock. Freq_locked state. Slave device is locked to the Master with respect to frequency, but not phase aligned Phase_aligned state. Locked to the master with respect to frequency and phase.')
cPtpClockRunningPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockRunningPacketsSent.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningPacketsSent.setDescription('This object specifies the total number of all packet Unicast and multicast that have been sent out for this clock in this domain for this type.')
cPtpClockRunningPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockRunningPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: cPtpClockRunningPacketsReceived.setDescription('This object specifies the total number of all packet Unicast and multicast that have been received for this clock in this domain for this type.')
cPtpClockTimePropertiesDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5), )
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSTable.setDescription('Table of information about the PTP clock Timeproperties Datasets for all domains.')
cPtpClockTimePropertiesDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockTimePropertiesDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockTimePropertiesDSClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockTimePropertiesDSInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSEntry.setReference('Section 8.2.4 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSEntry.setDescription('An entry in the table, containing information about a single PTP clock timeproperties Datasets for a domain.')
cPtpClockTimePropertiesDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockTimePropertiesDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockTimePropertiesDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockTimePropertiesDSCurrentUTCOffsetValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSCurrentUTCOffsetValid.setReference('Section 8.2.4.2 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSCurrentUTCOffsetValid.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSCurrentUTCOffsetValid.setDescription('This object specifies the timeproperties dataset value of whether current UTC offset is valid.')
cPtpClockTimePropertiesDSCurrentUTCOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSCurrentUTCOffset.setReference('Section 8.2.4.3 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSCurrentUTCOffset.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSCurrentUTCOffset.setDescription('This object specifies the timeproperties dataset value of current UTC offset. In PTP systems whose epoch is the PTP epoch, the value of timePropertiesDS.currentUtcOffset is the offset between TAI and UTC; otherwise the value has no meaning. The value shall be in units of seconds. The initialization value shall be selected as follows: a) If the timePropertiesDS.ptpTimescale (see 8.2.4.8) is TRUE, the value is the value obtained from a primary reference if the value is known at the time of initialization, else. b) The value shall be the current number of leap seconds (7.2.3) when the node is designed.')
cPtpClockTimePropertiesDSLeap59 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSLeap59.setReference('Section 8.2.4.4 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSLeap59.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSLeap59.setDescription('This object specifies the Leap59 value in the clock Current Dataset.')
cPtpClockTimePropertiesDSLeap61 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSLeap61.setReference('Section 8.2.4.5 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSLeap61.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSLeap61.setDescription('This object specifies the Leap61 value in the clock Current Dataset.')
cPtpClockTimePropertiesDSTimeTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSTimeTraceable.setReference('Section 8.2.4.6 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSTimeTraceable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSTimeTraceable.setDescription('This object specifies the Timetraceable value in the clock Current Dataset.')
cPtpClockTimePropertiesDSFreqTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSFreqTraceable.setReference('Section 8.2.4.7 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSFreqTraceable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSFreqTraceable.setDescription('This object specifies the Frequency Traceable value in the clock Current Dataset.')
cPtpClockTimePropertiesDSPTPTimescale = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSPTPTimescale.setReference('Section 8.2.4.8 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSPTPTimescale.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSPTPTimescale.setDescription('This object specifies the PTP Timescale value in the clock Current Dataset.')
cPtpClockTimePropertiesDSSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 5, 1, 11), ClockTimeSourceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSSource.setReference('Section 8.2.4.9 of [1]')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSSource.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTimePropertiesDSSource.setDescription('This object specifies the Timesource value in the clock Current Dataset.')
cPtpClockTransDefaultDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6), )
if mibBuilder.loadTexts: cPtpClockTransDefaultDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSTable.setDescription('Table of information about the PTP Transparent clock Default Datasets for all domains.')
cPtpClockTransDefaultDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockTransDefaultDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockTransDefaultDSInstanceIndex"))
if mibBuilder.loadTexts: cPtpClockTransDefaultDSEntry.setReference('Section 8.3.2 of [1]')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSEntry.setDescription('An entry in the table, containing information about a single PTP Transparent clock Default Datasets for a domain.')
cPtpClockTransDefaultDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockTransDefaultDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockTransDefaultDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1, 2), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockTransDefaultDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockTransDefaultDSClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1, 3), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTransDefaultDSClockIdentity.setReference('Section 8.3.2.2.1 of [1]')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSClockIdentity.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSClockIdentity.setDescription('This object specifies the value of the clockIdentity attribute of the local clock.')
cPtpClockTransDefaultDSNumOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTransDefaultDSNumOfPorts.setReference('Section 8.3.2.2.2 of [1]')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSNumOfPorts.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSNumOfPorts.setDescription('This object specifies the number of PTP ports of the device.')
cPtpClockTransDefaultDSDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1, 5), ClockMechanismType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTransDefaultDSDelay.setReference('Section 8.3.2.3.1 of [1]')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSDelay.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSDelay.setDescription('This object, if the transparent clock is an end-to-end transparent clock, has the value shall be E2E; If the transparent clock is a peer-to-peer transparent clock, the value shall be P2P.')
cPtpClockTransDefaultDSPrimaryDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockTransDefaultDSPrimaryDomain.setReference('Section 8.3.2.3.2 of [1]')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSPrimaryDomain.setStatus('current')
if mibBuilder.loadTexts: cPtpClockTransDefaultDSPrimaryDomain.setDescription('This object specifies the value of the primary syntonization domain. The initialization value shall be 0.')
cPtpClockPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7), )
if mibBuilder.loadTexts: cPtpClockPortTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTable.setDescription('Table of information about the clock ports for a particular domain.')
cPtpClockPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockPortDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortClockInstanceIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortTablePortNumberIndex"))
if mibBuilder.loadTexts: cPtpClockPortEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortEntry.setDescription('An entry in the table, containing information about a single clock port.')
cPtpClockPortDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockPortDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockPortClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockPortClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockPortClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockPortClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockPortTablePortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 4), ClockPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cPtpClockPortTablePortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTablePortNumberIndex.setDescription('This object specifies the PTP Portnumber for this port.')
cPtpClockPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortName.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortName.setDescription('This object specifies the PTP clock port name configured on the router.')
cPtpClockPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 6), ClockRoleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRole.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRole.setDescription('This object describes the current role (slave/master) of the port.')
cPtpClockPortSyncOneStep = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortSyncOneStep.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortSyncOneStep.setDescription('This object specifies that one-step clock operation between the PTP master and slave device is enabled.')
cPtpClockPortCurrentPeerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortCurrentPeerAddressType.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortCurrentPeerAddressType.setDescription("This object specifies the current peer's network address used for PTP communication. Based on the scenario and the setup involved, the values might look like these - Scenario Value ------------------- ---------------- Single Master master port Multiple Masters selected master port Single Slave slave port Multiple Slaves <empty> (In relevant setups, information on available slaves and available masters will be available through cPtpClockPortAssociateTable)")
cPtpClockPortCurrentPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortCurrentPeerAddress.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortCurrentPeerAddress.setDescription("This object specifies the current peer's network address used for PTP communication. Based on the scenario and the setup involved, the values might look like these - Scenario Value ------------------- ---------------- Single Master master port Multiple Masters selected master port Single Slave slave port Multiple Slaves <empty> (In relevant setups, information on available slaves and available masters will be available through cPtpClockPortAssociateTable)")
cPtpClockPortNumOfAssociatedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 7, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortNumOfAssociatedPorts.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortNumOfAssociatedPorts.setDescription('This object specifies - For a master port - the number of PTP slave sessions (peers) associated with this PTP port. For a slave port - the number of masters available to this slave port (might or might not be peered).')
cPtpClockPortDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8), )
if mibBuilder.loadTexts: cPtpClockPortDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSTable.setDescription('Table of information about the clock ports dataset for a particular domain.')
cPtpClockPortDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockPortDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortDSClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortDSClockInstanceIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortDSPortNumberIndex"))
if mibBuilder.loadTexts: cPtpClockPortDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSEntry.setDescription('An entry in the table, containing port dataset information for a single clock port.')
cPtpClockPortDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockPortDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockPortDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockPortDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockPortDSClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockPortDSClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockPortDSPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 4), ClockPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cPtpClockPortDSPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSPortNumberIndex.setDescription('This object specifies the PTP portnumber associated with this PTP port.')
cPtpClockPortDSName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSName.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSName.setDescription('This object specifies the PTP clock port name.')
cPtpClockPortDSPortIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSPortIdentity.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSPortIdentity.setDescription('This object specifies the PTP clock port Identity.')
cPtpClockPortDSAnnouncementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSAnnouncementInterval.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSAnnouncementInterval.setDescription('This object specifies the Announce message transmission interval associated with this clock port.')
cPtpClockPortDSAnnounceRctTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSAnnounceRctTimeout.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSAnnounceRctTimeout.setDescription('This object specifies the Announce receipt timeout associated with this clock port.')
cPtpClockPortDSSyncInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSSyncInterval.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSSyncInterval.setDescription('This object specifies the Sync message transmission interval.')
cPtpClockPortDSMinDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSMinDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSMinDelayReqInterval.setDescription('This object specifies the Delay_Req message transmission interval.')
cPtpClockPortDSPeerDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSPeerDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSPeerDelayReqInterval.setDescription('This object specifies the Pdelay_Req message transmission interval.')
cPtpClockPortDSDelayMech = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 12), ClockMechanismType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSDelayMech.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSDelayMech.setDescription('This object specifies the delay mechanism used. If the clock is an end-to-end clock, the value of the is e2e, else if the clock is a peer to-peer clock, the value shall be p2p.')
cPtpClockPortDSPeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 13), ClockTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSPeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSPeerMeanPathDelay.setDescription('This object specifies the peer meanPathDelay.')
cPtpClockPortDSGrantDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSGrantDuration.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSGrantDuration.setDescription('This object specifies the grant duration allocated by the master.')
cPtpClockPortDSPTPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 8, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortDSPTPVersion.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortDSPTPVersion.setDescription('This object specifies the PTP version being used.')
cPtpClockPortRunningTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9), )
if mibBuilder.loadTexts: cPtpClockPortRunningTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningTable.setDescription('Table of information about the clock ports running dataset for a particular domain.')
cPtpClockPortRunningEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockPortRunningDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortRunningClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortRunningClockInstanceIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortRunningPortNumberIndex"))
if mibBuilder.loadTexts: cPtpClockPortRunningEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningEntry.setDescription('An entry in the table, containing runing dataset information about a single clock port.')
cPtpClockPortRunningDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockPortRunningDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockPortRunningClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockPortRunningClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual convention description.')
cPtpClockPortRunningClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockPortRunningClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockPortRunningPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 4), ClockPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cPtpClockPortRunningPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningPortNumberIndex.setDescription('This object specifies the PTP portnumber associated with this clock port.')
cPtpClockPortRunningName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningName.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningName.setDescription('This object specifies the PTP clock port name.')
cPtpClockPortRunningState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 6), ClockPortState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningState.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningState.setDescription('This object specifies the port state returned by PTP engine. initializing - In this state a port initializes its data sets, hardware, and communication facilities. faulty - The fault state of the protocol. disabled - The port shall not place any messages on its communication path. listening - The port is waiting for the announceReceiptTimeout to expire or to receive an Announce message from a master. preMaster - The port shall behave in all respects as though it were in the MASTER state except that it shall not place any messages on its communication path except for Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, signaling, or management messages. master - The port is behaving as a master port. passive - The port shall not place any messages on its communication path except for Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, or signaling messages, or management messages that are a required response to another management message uncalibrated - The local port is preparing to synchronize to the master port. slave - The port is synchronizing to the selected master port.')
cPtpClockPortRunningRole = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 7), ClockRoleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningRole.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningRole.setDescription('This object specifies the Clock Role.')
cPtpClockPortRunningInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningInterfaceIndex.setDescription('This object specifies the interface on the router being used by the PTP Clock for PTP communication.')
cPtpClockPortRunningIPversion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningIPversion.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningIPversion.setDescription('This object specifirst the IP version being used for PTP communication (the mapping used).')
cPtpClockPortRunningEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningEncapsulationType.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningEncapsulationType.setDescription('This object specifies the type of encapsulation if the interface is adding extra layers (eg. VLAN, Pseudowire encapsulation...) for the PTP messages.')
cPtpClockPortRunningTxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 11), ClockTxModeType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningTxMode.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningTxMode.setDescription('This object specifies the clock transmission mode as unicast: Using unicast commnuication channel. multicast: Using Multicast communication channel. multicast-mix: Using multicast-unicast communication channel')
cPtpClockPortRunningRxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 12), ClockTxModeType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningRxMode.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningRxMode.setDescription('This object specifie the clock receive mode as unicast: Using unicast commnuication channel. multicast: Using Multicast communication channel. multicast-mix: Using multicast-unicast communication channel')
cPtpClockPortRunningPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 13), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningPacketsReceived.setDescription('This object specifies the packets received on the clock port (cummulative).')
cPtpClockPortRunningPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 9, 1, 14), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortRunningPacketsSent.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortRunningPacketsSent.setDescription('This object specifies the packets sent on the clock port (cummulative).')
cPtpClockPortTransDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10), )
if mibBuilder.loadTexts: cPtpClockPortTransDSTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSTable.setDescription('Table of information about the Transparent clock ports running dataset for a particular domain.')
cPtpClockPortTransDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockPortTransDSDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortTransDSInstanceIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortTransDSPortNumberIndex"))
if mibBuilder.loadTexts: cPtpClockPortTransDSEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSEntry.setDescription('An entry in the table, containing clock port Transparent dataset information about a single clock port')
cPtpClockPortTransDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockPortTransDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSDomainIndex.setDescription('This object specifies the domain number used to create logical group of PTP devices.')
cPtpClockPortTransDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 2), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cPtpClockPortTransDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockPortTransDSPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 3), ClockPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cPtpClockPortTransDSPortNumberIndex.setReference('Section 7.5.2 Port Identity of [1]')
if mibBuilder.loadTexts: cPtpClockPortTransDSPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSPortNumberIndex.setDescription('This object specifies the PTP port number associated with this port.')
cPtpClockPortTransDSPortIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 4), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortTransDSPortIdentity.setReference('Section 8.3.3.2.1 of [1]')
if mibBuilder.loadTexts: cPtpClockPortTransDSPortIdentity.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSPortIdentity.setDescription('This object specifies the value of the PortIdentity attribute of the local port.')
cPtpClockPortTransDSlogMinPdelayReqInt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortTransDSlogMinPdelayReqInt.setReference('Section 8.3.3.3.1 of [1]')
if mibBuilder.loadTexts: cPtpClockPortTransDSlogMinPdelayReqInt.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSlogMinPdelayReqInt.setDescription('This object specifies the value of the logarithm to the base 2 of the minPdelayReqInterval.')
cPtpClockPortTransDSFaultyFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortTransDSFaultyFlag.setReference('Section 8.3.3.3.2 of [1]')
if mibBuilder.loadTexts: cPtpClockPortTransDSFaultyFlag.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSFaultyFlag.setDescription('This object specifies the value TRUE if the port is faulty and FALSE if the port is operating normally.')
cPtpClockPortTransDSPeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 10, 1, 7), ClockTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortTransDSPeerMeanPathDelay.setReference('Section 8.3.3.3.3 of [1]')
if mibBuilder.loadTexts: cPtpClockPortTransDSPeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortTransDSPeerMeanPathDelay.setDescription('This object specifies, (if the delayMechanism used is P2P) the value is the estimate of the current one-way propagation delay, i.e., <meanPathDelay> on the link attached to this port computed using the peer delay mechanism. If the value of the delayMechanism used is E2E, then the value will be zero.')
cPtpClockPortAssociateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11), )
if mibBuilder.loadTexts: cPtpClockPortAssociateTable.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociateTable.setDescription("Table of information about a given port's associated ports. For a master port - multiple slave ports which have established sessions with the current master port. For a slave port - the list of masters available for a given slave port. Session information (pkts, errors) to be displayed based on availability and scenario.")
cPtpClockPortAssociateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1), ).setIndexNames((0, "CISCO-PTP-MIB", "cPtpClockPortCurrentDomainIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortCurrentClockTypeIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortCurrentClockInstanceIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortCurrentPortNumberIndex"), (0, "CISCO-PTP-MIB", "cPtpClockPortAssociatePortIndex"))
if mibBuilder.loadTexts: cPtpClockPortAssociateEntry.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociateEntry.setDescription('An entry in the table, containing information about a single associated port for the given clockport.')
cPtpClockPortCurrentDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 1), ClockDomainType())
if mibBuilder.loadTexts: cPtpClockPortCurrentDomainIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortCurrentDomainIndex.setDescription("This object specifies the given port's domain number.")
cPtpClockPortCurrentClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 2), ClockType())
if mibBuilder.loadTexts: cPtpClockPortCurrentClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortCurrentClockTypeIndex.setDescription("This object specifies the given port's clock type.")
cPtpClockPortCurrentClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 3), ClockInstanceType())
if mibBuilder.loadTexts: cPtpClockPortCurrentClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortCurrentClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock type in the given domain.')
cPtpClockPortCurrentPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 4), ClockPortNumber())
if mibBuilder.loadTexts: cPtpClockPortCurrentPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortCurrentPortNumberIndex.setDescription('This object specifies the PTP Port Number for the given port.')
cPtpClockPortAssociatePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cPtpClockPortAssociatePortIndex.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociatePortIndex.setDescription("This object specifies the associated port's serial number in the current port's context.")
cPtpClockPortAssociateAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortAssociateAddressType.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociateAddressType.setDescription("This object specifies the peer port's network address type used for PTP communication.")
cPtpClockPortAssociateAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortAssociateAddress.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociateAddress.setDescription("This object specifies the peer port's network address used for PTP communication.")
cPtpClockPortAssociatePacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 8), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortAssociatePacketsSent.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociatePacketsSent.setDescription('The number of packets sent to this peer port from the current port.')
cPtpClockPortAssociatePacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 9), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortAssociatePacketsReceived.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociatePacketsReceived.setDescription('The number of packets received from this peer port by the current port.')
cPtpClockPortAssociateInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 10), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortAssociateInErrors.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociateInErrors.setDescription('This object specifies the input errors associated with the peer port.')
cPtpClockPortAssociateOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 760, 1, 2, 11, 1, 11), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cPtpClockPortAssociateOutErrors.setStatus('current')
if mibBuilder.loadTexts: cPtpClockPortAssociateOutErrors.setDescription('This object specifies the output errors associated with the peer port.')
mibBuilder.exportSymbols("CISCO-PTP-MIB", ciscoPtpMIBClockPortDSGroup=ciscoPtpMIBClockPortDSGroup, cPtpClockParentDSInstanceIndex=cPtpClockParentDSInstanceIndex, cPtpClockPortRunningState=cPtpClockPortRunningState, ciscoPtpMIBGroups=ciscoPtpMIBGroups, cPtpClockNodeTable=cPtpClockNodeTable, cPtpClockPortDSGrantDuration=cPtpClockPortDSGrantDuration, cPtpClockPortDSPortNumberIndex=cPtpClockPortDSPortNumberIndex, cPtpSystemProfile=cPtpSystemProfile, cPtpClockPortRunningTable=cPtpClockPortRunningTable, ClockIdentity=ClockIdentity, ciscoPtpMIBClockTimepropertiesGroup=ciscoPtpMIBClockTimepropertiesGroup, cPtpClockParentDSGMClockPriority2=cPtpClockParentDSGMClockPriority2, cPtpClockPortTransDSPortIdentity=cPtpClockPortTransDSPortIdentity, cPtpClockTransDefaultDSNumOfPorts=cPtpClockTransDefaultDSNumOfPorts, cPtpClockPortDSAnnounceRctTimeout=cPtpClockPortDSAnnounceRctTimeout, ciscoPtpMIBCompliances=ciscoPtpMIBCompliances, cPtpClockTimePropertiesDSEntry=cPtpClockTimePropertiesDSEntry, cPtpClockTimePropertiesDSSource=cPtpClockTimePropertiesDSSource, cPtpClockCurrentDSEntry=cPtpClockCurrentDSEntry, cPtpClockRunningClockTypeIndex=cPtpClockRunningClockTypeIndex, ciscoPtpMIBClockDefaultDSGroup=ciscoPtpMIBClockDefaultDSGroup, cPtpClockTransDefaultDSDelay=cPtpClockTransDefaultDSDelay, cPtpClockTimePropertiesDSPTPTimescale=cPtpClockTimePropertiesDSPTPTimescale, cPtpClockParentDSGMClockPriority1=cPtpClockParentDSGMClockPriority1, cPtpClockPortName=cPtpClockPortName, ciscoPtpMIBClockCurrentDSGroup=ciscoPtpMIBClockCurrentDSGroup, cPtpClockCurrentDSInstanceIndex=cPtpClockCurrentDSInstanceIndex, cPtpClockPortDSPTPVersion=cPtpClockPortDSPTPVersion, cPtpClockDefaultDSEntry=cPtpClockDefaultDSEntry, cPtpClockCurrentDSTable=cPtpClockCurrentDSTable, cPtpClockTimePropertiesDSLeap59=cPtpClockTimePropertiesDSLeap59, cPtpClockTransDefaultDSDomainIndex=cPtpClockTransDefaultDSDomainIndex, cPtpClockParentDSGMClockQualityOffset=cPtpClockParentDSGMClockQualityOffset, cPtpClockDefaultDSTwoStepFlag=cPtpClockDefaultDSTwoStepFlag, cPtpDomainClockPortPhysicalInterfacesTotal=cPtpDomainClockPortPhysicalInterfacesTotal, cPtpClockParentDSClockPhChRate=cPtpClockParentDSClockPhChRate, cPtpClockPortTransDSDomainIndex=cPtpClockPortTransDSDomainIndex, cPtpClockCurrentDSStepsRemoved=cPtpClockCurrentDSStepsRemoved, cPtpClockPortRunningDomainIndex=cPtpClockPortRunningDomainIndex, cPtpClockPortClockInstanceIndex=cPtpClockPortClockInstanceIndex, cPtpClockPortRunningClockInstanceIndex=cPtpClockPortRunningClockInstanceIndex, cPtpClockPortRunningPacketsSent=cPtpClockPortRunningPacketsSent, cPtpClockPortRunningEncapsulationType=cPtpClockPortRunningEncapsulationType, cPtpClockPortTransDSFaultyFlag=cPtpClockPortTransDSFaultyFlag, ClockInstanceType=ClockInstanceType, cPtpClockPortAssociatePacketsReceived=cPtpClockPortAssociatePacketsReceived, cPtpDomainClockPortsTotal=cPtpDomainClockPortsTotal, cPtpClockInputFrequencyEnabled=cPtpClockInputFrequencyEnabled, ciscoPtpMIBCompliances4=ciscoPtpMIBCompliances4, cPtpClockParentDSEntry=cPtpClockParentDSEntry, ciscoPtpMIBClockPortRunningGroup=ciscoPtpMIBClockPortRunningGroup, cPtpClockPortNumOfAssociatedPorts=cPtpClockPortNumOfAssociatedPorts, cPtpClockTransDefaultDSEntry=cPtpClockTransDefaultDSEntry, cPtpClockRunningPacketsSent=cPtpClockRunningPacketsSent, cPtpClockCurrentDSMeanPathDelay=cPtpClockCurrentDSMeanPathDelay, cPtpInstanceIndex=cPtpInstanceIndex, cPtpClockPortTransDSInstanceIndex=cPtpClockPortTransDSInstanceIndex, cPtpClockTimePropertiesDSCurrentUTCOffset=cPtpClockTimePropertiesDSCurrentUTCOffset, cPtpClockOutput1ppsOffsetNegative=cPtpClockOutput1ppsOffsetNegative, cPtpClockPortRunningPortNumberIndex=cPtpClockPortRunningPortNumberIndex, ciscoPtpMIBNotifs=ciscoPtpMIBNotifs, ciscoPtpMIBCompliances2=ciscoPtpMIBCompliances2, cPtpClockTimePropertiesDSInstanceIndex=cPtpClockTimePropertiesDSInstanceIndex, cPtpClockDefaultDSPriority2=cPtpClockDefaultDSPriority2, cPtpClockTimePropertiesDSLeap61=cPtpClockTimePropertiesDSLeap61, cPtpClockCurrentDSDomainIndex=cPtpClockCurrentDSDomainIndex, ciscoPtpMIBClockTranparentDSGroup=ciscoPtpMIBClockTranparentDSGroup, cPtpClockPortDSMinDelayReqInterval=cPtpClockPortDSMinDelayReqInterval, cPtpClockPortAssociateEntry=cPtpClockPortAssociateEntry, ClockType=ClockType, cPtpClockRunningPacketsReceived=cPtpClockRunningPacketsReceived, cPtpClockNodeEntry=cPtpClockNodeEntry, cPtpClockPortAssociateTable=cPtpClockPortAssociateTable, cPtpClockPortCurrentDomainIndex=cPtpClockPortCurrentDomainIndex, ciscoPtpMIBSystemInfoGroup=ciscoPtpMIBSystemInfoGroup, cPtpClockPortCurrentPeerAddress=cPtpClockPortCurrentPeerAddress, PYSNMP_MODULE_ID=ciscoPtpMIB, ciscoPtpMIBClockRunningGroup=ciscoPtpMIBClockRunningGroup, cPtpClockPortDSPeerDelayReqInterval=cPtpClockPortDSPeerDelayReqInterval, cPtpClockDefaultDSPriority1=cPtpClockDefaultDSPriority1, cPtpClockTransDefaultDSPrimaryDomain=cPtpClockTransDefaultDSPrimaryDomain, cPtpClockTimePropertiesDSClockTypeIndex=cPtpClockTimePropertiesDSClockTypeIndex, cPtpClockOutput1ppsEnabled=cPtpClockOutput1ppsEnabled, cPtpClockTimePropertiesDSCurrentUTCOffsetValid=cPtpClockTimePropertiesDSCurrentUTCOffsetValid, cPtpClockPortDSTable=cPtpClockPortDSTable, cPtpSystemEntry=cPtpSystemEntry, cPtpClockTransDefaultDSClockIdentity=cPtpClockTransDefaultDSClockIdentity, ciscoPtpMIBConformance=ciscoPtpMIBConformance, ClockTimeSourceType=ClockTimeSourceType, cPtpClockTimePropertiesDSDomainIndex=cPtpClockTimePropertiesDSDomainIndex, cPtpSystemDomainTotals=cPtpSystemDomainTotals, ClockIntervalBase2=ClockIntervalBase2, cPtpClockPortAssociateOutErrors=cPtpClockPortAssociateOutErrors, cPtpClockPortTransDSTable=cPtpClockPortTransDSTable, cPtpClockDomainIndex=cPtpClockDomainIndex, cPtpClockPortDSClockTypeIndex=cPtpClockPortDSClockTypeIndex, cPtpClockPortDSAnnouncementInterval=cPtpClockPortDSAnnouncementInterval, cPtpClockParentDSParentPortIdentity=cPtpClockParentDSParentPortIdentity, cPtpClockTransDefaultDSInstanceIndex=cPtpClockTransDefaultDSInstanceIndex, cPtpClockInput1ppsEnabled=cPtpClockInput1ppsEnabled, cPtpClockPortDSDelayMech=cPtpClockPortDSDelayMech, cPtpClockParentDSGMClockIdentity=cPtpClockParentDSGMClockIdentity, cPtpSystemDomainEntry=cPtpSystemDomainEntry, ciscoPtpMIBClockPortAssociateGroup=ciscoPtpMIBClockPortAssociateGroup, cPtpClockCurrentDSOffsetFromMaster=cPtpClockCurrentDSOffsetFromMaster, cPtpClockCurrentDSClockTypeIndex=cPtpClockCurrentDSClockTypeIndex, ciscoPtpMIBObjects=ciscoPtpMIBObjects, cPtpClockPortDSDomainIndex=cPtpClockPortDSDomainIndex, cPtpClockRunningState=cPtpClockRunningState, cPtpClockTimePropertiesDSTable=cPtpClockTimePropertiesDSTable, cPtpClockPortSyncOneStep=cPtpClockPortSyncOneStep, cPtpClockPortRunningClockTypeIndex=cPtpClockPortRunningClockTypeIndex, ciscoPtpMIBClockPortGroup=ciscoPtpMIBClockPortGroup, cPtpClockInput1ppsInterface=cPtpClockInput1ppsInterface, cPtpSystemDomainTable=cPtpSystemDomainTable, cPtpClockTransDefaultDSTable=cPtpClockTransDefaultDSTable, cPtpClockPortAssociatePacketsSent=cPtpClockPortAssociatePacketsSent, cPtpClockPortDSEntry=cPtpClockPortDSEntry, cPtpClockPortDSPortIdentity=cPtpClockPortDSPortIdentity, ClockPortNumber=ClockPortNumber, cPtpClockOutput1ppsOffsetValue=cPtpClockOutput1ppsOffsetValue, cPtpClockPortCurrentClockInstanceIndex=cPtpClockPortCurrentClockInstanceIndex, cPtpClockDefaultDSInstanceIndex=cPtpClockDefaultDSInstanceIndex, cPtpClockPortAssociateAddress=cPtpClockPortAssociateAddress, ClockRoleType=ClockRoleType, cPtpClockPortAssociateInErrors=cPtpClockPortAssociateInErrors, cPtpClockParentDSTable=cPtpClockParentDSTable, cPtpClockDefaultDSDomainIndex=cPtpClockDefaultDSDomainIndex, cPtpClockPortRunningTxMode=cPtpClockPortRunningTxMode, cPtpClockDefaultDSQualityClass=cPtpClockDefaultDSQualityClass, cPtpSystemTable=cPtpSystemTable, cPtpClockPortCurrentPortNumberIndex=cPtpClockPortCurrentPortNumberIndex, cPtpClockPortTransDSPortNumberIndex=cPtpClockPortTransDSPortNumberIndex, cPtpClockTypeIndex=cPtpClockTypeIndex, cPtpClockRunningInstanceIndex=cPtpClockRunningInstanceIndex, ciscoPtpMIBClockParentDSGroup=ciscoPtpMIBClockParentDSGroup, ClockQualityAccuracyType=ClockQualityAccuracyType, cPtpSystemDomainClockTypeIndex=cPtpSystemDomainClockTypeIndex, cPtpClockPortTable=cPtpClockPortTable, cPtpClockPortDSPeerMeanPathDelay=cPtpClockPortDSPeerMeanPathDelay, cPtpClockPortTablePortNumberIndex=cPtpClockPortTablePortNumberIndex, cPtpClockRunningEntry=cPtpClockRunningEntry, cPtpClockPortDSSyncInterval=cPtpClockPortDSSyncInterval, ciscoPtpMIBClockInfo=ciscoPtpMIBClockInfo, ClockStateType=ClockStateType, cPtpClockTimePropertiesDSTimeTraceable=cPtpClockTimePropertiesDSTimeTraceable, cPtpClockParentDSOffset=cPtpClockParentDSOffset, ClockPortState=ClockPortState, cPtpClockPortRunningName=cPtpClockPortRunningName, ciscoPtpMIBClockPortTransDSGroup=ciscoPtpMIBClockPortTransDSGroup, cPtpClockDefaultDSClockTypeIndex=cPtpClockDefaultDSClockTypeIndex, ClockMechanismType=ClockMechanismType, cPtpClockOutput1ppsInterface=cPtpClockOutput1ppsInterface, cPtpClockRunningTable=cPtpClockRunningTable, cPtpClockPortDSClockInstanceIndex=cPtpClockPortDSClockInstanceIndex, cPtpClockDefaultDSTable=cPtpClockDefaultDSTable, cPtpClockPortRunningRxMode=cPtpClockPortRunningRxMode, cPtpClockPortTransDSEntry=cPtpClockPortTransDSEntry, cPtpClockDefaultDSQualityAccuracy=cPtpClockDefaultDSQualityAccuracy, cPtpClockPortClockTypeIndex=cPtpClockPortClockTypeIndex, cPtpClockParentDSParentStats=cPtpClockParentDSParentStats, cPtpClockPortEntry=cPtpClockPortEntry, cPtpClockPortRunningRole=cPtpClockPortRunningRole, cPtpClockPortTransDSlogMinPdelayReqInt=cPtpClockPortTransDSlogMinPdelayReqInt, cPtpClockInstanceIndex=cPtpClockInstanceIndex, ClockTimeInterval=ClockTimeInterval, cPtpClockRunningDomainIndex=cPtpClockRunningDomainIndex, cPtpClockDefaultDSSlaveOnly=cPtpClockDefaultDSSlaveOnly, cPtpClockParentDSGMClockQualityAccuracy=cPtpClockParentDSGMClockQualityAccuracy, cPtpClockParentDSClockTypeIndex=cPtpClockParentDSClockTypeIndex, cPtpClockPortRunningInterfaceIndex=cPtpClockPortRunningInterfaceIndex, cPtpClockTODInterface=cPtpClockTODInterface, cPtpDomainIndex=cPtpDomainIndex, cPtpClockPortRunningIPversion=cPtpClockPortRunningIPversion, ClockDomainType=ClockDomainType, cPtpClockParentDSGMClockQualityClass=cPtpClockParentDSGMClockQualityClass, cPtpClockPortTransDSPeerMeanPathDelay=cPtpClockPortTransDSPeerMeanPathDelay, ciscoPtpMIBCompliances3=ciscoPtpMIBCompliances3, cPtpClockPortDomainIndex=cPtpClockPortDomainIndex, cPtpClockPortRole=cPtpClockPortRole, cPtpClockTimePropertiesDSFreqTraceable=cPtpClockTimePropertiesDSFreqTraceable, ciscoPtpMIBCompliances1=ciscoPtpMIBCompliances1, cPtpClockPortCurrentClockTypeIndex=cPtpClockPortCurrentClockTypeIndex, cPtpClockOutput1ppsOffsetEnabled=cPtpClockOutput1ppsOffsetEnabled, ClockQualityClassType=ClockQualityClassType, ciscoPtpMIB=ciscoPtpMIB, cPtpClockPortAssociateAddressType=cPtpClockPortAssociateAddressType, cPtpClockPortRunningPacketsReceived=cPtpClockPortRunningPacketsReceived, ClockProfileType=ClockProfileType, ciscoPtpMIBSystemInfo=ciscoPtpMIBSystemInfo, cPtpClockPortCurrentPeerAddressType=cPtpClockPortCurrentPeerAddressType, cPtpClockPortDSName=cPtpClockPortDSName, cPtpClockPortAssociatePortIndex=cPtpClockPortAssociatePortIndex, cPtpClockTODEnabled=cPtpClockTODEnabled, cPtpClockDefaultDSQualityOffset=cPtpClockDefaultDSQualityOffset, cPtpClockPortRunningEntry=cPtpClockPortRunningEntry, cPtpClockParentDSDomainIndex=cPtpClockParentDSDomainIndex, ClockTxModeType=ClockTxModeType, cPtpClockDefaultDSClockIdentity=cPtpClockDefaultDSClockIdentity)

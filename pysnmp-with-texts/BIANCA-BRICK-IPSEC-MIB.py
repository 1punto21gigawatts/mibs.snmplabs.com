#
# PySNMP MIB module BIANCA-BRICK-IPSEC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-IPSEC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, NotificationType, Counter64, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Unsigned32, Gauge32, Integer32, ObjectIdentity, Counter32, MibIdentifier, Bits, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "Counter64", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Unsigned32", "Gauge32", "Integer32", "ObjectIdentity", "Counter32", "MibIdentifier", "Bits", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
class DisplayString(OctetString):
    pass

class HexValue(Integer32):
    pass

ipsec = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 26))
ipsecGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 26, 1))
ipsecGlobPeerIndex = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobPeerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobPeerIndex.setDescription('Index of first IPsec peer in ipsecPeerTable. If this object is set to a Value <= 0, IPSec is switched explicitly off. If the peer referenced by this object does not exist in the table, all packets will be dropped.')
ipsecGlobDefaultAuthMethod = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pre-sh-key", 1), ("dss-sig", 2), ("rsa-sig", 3), ("rsa-enc", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultAuthMethod.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultAuthMethod.setDescription("The authentication method used by default. If the ipsecPeerAuthMethod field of an ipsecPeerEntry is set to 'default', this value is assumed. Possible values: pre-sh-key(1), -- Authentication using pre shared keys dss-sig(2), -- Authentication using DSS signatures rsa-sig(3), -- Authentication using RSA signatures rsa-enc(4) -- Authentication using RSA encryption.")
ipsecGlobDefaultCertificate = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultCertificate.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultCertificate.setDescription('The index of the default certificate in the certTable used for local authentication for ike keyed rules with non pre-shared-key authentication. This may be overwritten by the certificate specified for the individual ipsec peers.')
ipsecGlobDefaultLocalId = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultLocalId.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultLocalId.setDescription('The default ID used for local authentication for ike keyed rules. If this is an empty or invaid id string one of the subject alternative names or the subject name from the default certificate is used. This does not relpace an empty local id string for an IPsec peer with a valid certificate. The subject name or one of the subject alternative names from this certificate is used then')
ipsecGlobDefaultIpsecProposal = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultIpsecProposal.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultIpsecProposal.setDescription('Index of default ipsec proposal used for traffic entries with empty ipsec proposal, defined for peers with empty default ipsec proposal.')
ipsecGlobDefaultIkeProposal = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultIkeProposal.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultIkeProposal.setDescription('Index of default ike proposal used for peers with empty default ike proposal.')
ipsecGlobDefaultIpsecLifeTime = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultIpsecLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultIpsecLifeTime.setDescription("Index of default lifetime for ike SA's in ipsecLifeTimeTable. This lifetime is used, when there is no valid lifetime entry specified for an IPsec peer entry.")
ipsecGlobDefaultIkeLifeTime = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultIkeLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultIkeLifeTime.setDescription("Index of default lifetime for ipsec SA's in ipsecLifeTimeTable. This lifetime is used, when there is no valid lifetime entry specified for an IPsec SA, its traffic entry and its peer entry.")
ipsecGlobDefaultIkeGroup = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultIkeGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultIkeGroup.setDescription('Index of default IKE group used for peer entries with empty or invalid ike group. Possible values: 1 (768 bit MODP), 2 (1024 bit MODP), 5 (1536 bit MODP).')
ipsecGlobMaxSysLogLevel = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg", 1), ("alert", 2), ("crit", 3), ("err", 4), ("warning", 5), ("notice", 6), ("info", 7), ("debug", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobMaxSysLogLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobMaxSysLogLevel.setDescription('Maximum level for syslog messages issued by IPSec. All messages with a level higher than this value are suppressed, independently from other global syslog level settings. Possible settings: emerg(1), alert(2), crit(3), err(4), warning(5), notice(6), info(7), debug(8).')
ipsecGlobDefaultGranularity = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("coarse", 2), ("ip", 3), ("proto", 4), ("port", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultGranularity.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultGranularity.setDescription('This object specifies the default granularity used for IPSEC SA negotiation. Possible values: coarse(2), -- Create only one SA for each Traffic entry ip(3), -- Create one SA for each host proto(4), -- Create one SA for each protocol and host port(5) -- Create one SA for each port and host.')
ipsecGlobDefaultPh1Mode = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("id-protect", 1), ("aggressive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultPh1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultPh1Mode.setDescription('This object specifies the default exchange mode used for IKE SA negotiation. Possible values: id-protect(1), -- Use identity protection (main) mode aggressive(2) -- Use aggressive mode.')
ipsecGlobDefaultPfsGroup = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobDefaultPfsGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobDefaultPfsGroup.setDescription('This object specifies the PFS group to use. PFS is done only for phase 2, i.e. the Phase 1 SAs are not deleted after phase 2 negotiation is completed. Note however, that if the peer has configured PFS for identity and destroys phase 1 SAs, this side will also destroy them when notified. Possible values: 0 (no PFS) 1 (768 bit MODP), 2 (1024 bit MODP), 5 (1536 bit MODP).')
ipsecGlobIkePort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobIkePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobIkePort.setDescription('This object specifies the port the IKE key management service listens to.')
ipsecGlobMaxRetries = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobMaxRetries.setDescription('This object specifies the maximum number of retries sent by IKE for one message.')
ipsecGlobRetryTimeout0milli = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobRetryTimeout0milli.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobRetryTimeout0milli.setDescription('This object specifies the period of time in milliseconds before an IKE message is repeated for the first time if the answer is missing. After each retry, this timeout is increased up to the value specified in ipsecGlobRetryTimeoutMaxsec.')
ipsecGlobRetryTimeoutMaxsec = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobRetryTimeoutMaxsec.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobRetryTimeoutMaxsec.setDescription('This object specifies the maximum period of time in seconds before an IKE message is repeated if the answer is missing. The retry timeout is not increased beyond this limit.')
ipsecGlobMaxNegotiationTimeoutsec = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobMaxNegotiationTimeoutsec.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobMaxNegotiationTimeoutsec.setDescription('This object specifies the maximum number of seconds after which a negotiation is canceled if it is not finished.')
ipsecGlobMaxIkeSas = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobMaxIkeSas.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobMaxIkeSas.setDescription('This object specifies the maximum number of simultaneous ISAKMP Security associations allowed. If this limit is reached, the entries are removed from the database, starting with the ones that will expire very soon. If that is not enough, the entries are deleted in reverse LRU order.')
ipsecGlobAntiCloggingLength = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobAntiCloggingLength.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobAntiCloggingLength.setDescription('This object specifies the length in bits of the local secret used for ISAKMP anti-clogging cookies.')
ipsecGlobAntiCloggingHash = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("md5", 3), ("sha1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobAntiCloggingHash.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobAntiCloggingHash.setDescription('This object specifies the algorithm which is used for creating anti-clogging-tokens. Possible values: md5(3), -- MD5 hash algorithm sha1(4) -- SHA hash algorithm.')
ipsecGlobLocalSecretPeriodsec = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobLocalSecretPeriodsec.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobLocalSecretPeriodsec.setDescription('This object specifies the period of time in seconds after which a new secret for creating local anti-clogging tokens is created. The previous secret is remembered, so that the anti-clogging tokens created with the previous secret are also recognized as valid. After the local secret is recreated again, the old tokens are not recognized anymore and all IKE packets belonging to the old security associations are discarded. This means that the maximum lifetime of an ISAKMP SA is twice the value of this timer.')
ipsecGlobIgnoreCrPayloads = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobIgnoreCrPayloads.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobIgnoreCrPayloads.setDescription('This object specifies whether certificate request payloads should be ignored by IKE. Possible values: true(1), -- ignore all certificate requests false(2) -- process certificate request payloads.')
ipsecGlobNoCrPayloads = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobNoCrPayloads.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobNoCrPayloads.setDescription('This object specifies whether IKE should suppress certificate requests. Possible values: true(1), -- suppress certificate requests false(2) -- send certificate requests.')
ipsecGlobNoKeyHashPayloads = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobNoKeyHashPayloads.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobNoKeyHashPayloads.setDescription('This object specifies whether IKE should suppress key hash payloads. Possible values: true(1), -- suppress key hash payloads false(2) -- send key hash payloads.')
ipsecGlobNoCrls = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobNoCrls.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobNoCrls.setDescription('This object specifies whether IKE should send certificate revocation lists. Possible values: true(1), -- do not send certificate revocation lists false(2) -- send certificate revocation lists.')
ipsecGlobSendFullCertChains = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobSendFullCertChains.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobSendFullCertChains.setDescription('This object specifies whether IKE should send full certificate chains. Possible values: true(1), -- send full certificate chains false(2) -- do not send full certificate chains.')
ipsecGlobTrustIcmpMsg = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobTrustIcmpMsg.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobTrustIcmpMsg.setDescription('This object specifies whether IKE should trust icmp port and host unreachable error messages. ICMP port and host unreachable messages are only trusted if there have not yet been received any datagrams from the remote host in this negotiation. This means, if the local side receives an ICMP port or host unreachable message as the first response to the initial packet of a new phase 1 negotiation, it cancels the negotiation immediately. Possible values: true(1), -- trust ICMP messages false(2) -- do not trust ICMP messages.')
ipsecGlobSpiSize = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobSpiSize.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobSpiSize.setDescription('A compatibility flag that specifies the length of the SPI in bytes, which is used when an ISAKMP SA SPI (Cookie) is sent to the remote peer. This field takes effect only if ipsecGlobZeroIsakmpCookies is true.')
ipsecGlobZeroIsakmpCookies = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobZeroIsakmpCookies.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobZeroIsakmpCookies.setDescription('This object specifies whether zeroed ISAKMP cookies should be sent. Possible Values: true(1), -- send zero cookies in ISAKMP messages false(2) -- send ISAKMP cookies.')
ipsecGlobMaxKeyLength = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobMaxKeyLength.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobMaxKeyLength.setDescription('This object specifies the maximum length of an encryption key (in bits) that is accepted from the remote end. This limit prevents denial of service attacks where the attacker asks for a huge key for an encryption algorithm that allows variable length keys.')
ipsecGlobNoInitialContact = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobNoInitialContact.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobNoInitialContact.setDescription("Do not send IKE initial contact messages in IKE negotiations even if no SA's exist with a peer. Possible values: true(1), -- do not send initial contact messages false(2) -- send initial comntact messages if appropriate.")
ipsecGlobalsContinued = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 26, 11))
ipsecGlobContPreIpsecRules = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 11, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobContPreIpsecRules.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobContPreIpsecRules.setDescription('This object specifies an index in the IPsec traffic table containing a list of traffic definitions which has to be considered prior to the traffic lists of the IPSec peers in IPSec traffic processing. It may contain either pass or drop entries (protect entries are ignored, if erroneously configured).')
ipsecGlobContDefaultRule = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("drop", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecGlobContDefaultRule.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecGlobContDefaultRule.setDescription('This object specifies how to treat packets which do not match any entry in the traffic lists of the active peers. Possible values: drop(1), -- drop all packets pass(2) -- allow all packets pass plain.')
ipsecPublicKeyTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 2), )
if mibBuilder.loadTexts: ipsecPublicKeyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPublicKeyTable.setDescription("This table contains the list of public key pairs and ID's used with IPSec.")
ipsecPubKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 2, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ipsecPubKeyAlgorithm"), (0, "BIANCA-BRICK-IPSEC-MIB", "ipsecPubKeyKeyLength"))
if mibBuilder.loadTexts: ipsecPubKeyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPubKeyEntry.setDescription('This object contains a key pair for a certain public key algorithm and the ids used together with this key.')
ipsecPubKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecPubKeyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPubKeyIndex.setDescription('A unique index for this entry.')
ipsecPubKeyDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPubKeyDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPubKeyDescription.setDescription('An optional description for this key.')
ipsecPubKeyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("rsa", 2), ("dsa", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecPubKeyAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPubKeyAlgorithm.setDescription('This object specifies the algorithm for which the key is used. Possible values: rsa(2), -- The RSA encryption algorithm dsa(3) -- The digital signature algorithm.')
ipsecPubKeyKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecPubKeyKeyLength.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPubKeyKeyLength.setDescription('The size of the public and private keys in bits.')
ipsecSaTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 3), )
if mibBuilder.loadTexts: ipsecSaTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaTable.setDescription('This table contains the list of currently active IPSec security associations.')
ipsecSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ipsecSaIndex"))
if mibBuilder.loadTexts: ipsecSaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaEntry.setDescription('This object contains an IPSec security association.')
ipsecSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaIndex.setDescription('A unique index for this entry.')
ipsecSaState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alive", 1), ("expired", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecSaState.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaState.setDescription('The current state of the security association Possible values: alive(1), -- The SA is alive and will eventually be rekeyed expired(2), -- The SA is expired and will not be rekeyed delete (3) -- mark this sa for deletion.')
ipsecSaCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("ike", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaCreator.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaCreator.setDescription('This object specifies how the SA was created Possible values: manual(1), -- A manually keyed IPSec SA ike(2) -- An automatically keyed SA created by IKE.')
ipsecSaDir = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDir.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaDir.setDescription('This object specifies whether the SA is used for inbound or outbound processing. Possible values: inbound(1), -- An inbound security association outbound(2) -- An outbound security association.')
ipsecSaMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tunnel", 1), ("transport", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaMode.setDescription('This object specifies whether the SA is in tunnel or transport mode. Possible values: tunnel(1), -- A tunnel mode SA transport(2) -- A transport mode SA.')
ipsecSaSecProto = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(50, 51, 108))).clone(namedValues=NamedValues(("esp", 50), ("ah", 51), ("ipcomp", 108)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSecProto.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSecProto.setDescription('This object specifies the security protocol applied by this SA. Possible values: esp(50), -- Encapsulating Security Payload ah(51), -- Authentication Header ipcomp(108) -- Internet Payload Compression Protocol.')
ipsecSaLocalIp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaLocalIp.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaLocalIp.setDescription('The local IP address of the outer packet header. For transport mode SAs, this address is the same as the ipsecSaSrcAddress.')
ipsecSaPeerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaPeerIp.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaPeerIp.setDescription('The destination IP address of the outer packet header. For transport mode SAs, this address is the same as the ipsecSaDstAddress.')
ipsecSaSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSrcAddress.setDescription('The address of the source network this SA covers (if the SrcRange field is nonzero, this is the first address of a range of addresses).')
ipsecSaSrcMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSrcMaskLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSrcMaskLen.setDescription('The mask length of the source network this SA covers (only meaningful, if the SrcRange field is zero).')
ipsecSaSrcRange = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSrcRange.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSrcRange.setDescription('The last address of a range of source addresses (starting with SrcAddress) this SA covers. Overrides SrcMaskLen.')
ipsecSaDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDstAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaDstAddress.setDescription('The address of the destination network this SA covers (if the DstRange field is nonzero, this is the first address of a range of addresses).')
ipsecSaDstMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDstMaskLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaDstMaskLen.setDescription('The mask length of the destination network this SA covers (only meaningful, if the DstRange field is zero).')
ipsecSaDstRange = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDstRange.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaDstRange.setDescription('The last address of a range of destination addresses (starting with DstAddress) this SA covers. Overrides DstMaskLen.')
ipsecSaSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 17), HexValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSpi.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSpi.setDescription('The Security Parameters Index of this SA.')
ipsecSaAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 6))).clone(namedValues=NamedValues(("none", 2), ("md5-96", 4), ("sha1-96", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAuthAlg.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaAuthAlg.setDescription('The hash algorithm used, if any. Possible Values: none(2), -- No hash algorithm applied md5-96(4), -- The MD5 hash algorithm sha1-96(6) -- The Secure Hash Algorithm.')
ipsecSaEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("des-cbc", 2), ("des3-cbc", 3), ("blowfish-cbc", 4), ("cast128-cbc", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEncAlg.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaEncAlg.setDescription('The encryption algorithm used, if any. Possible Values: none(1), -- No encryption applied des-cbc(2), -- DES in CBC mode des3-cbc(3), -- Triple DES in CBC mode blowfish-cbc(4), -- Blowfish in CBC mode cast128-cbc(5) -- CAST with 128 bit key in CBC mode.')
ipsecSaAuthKeyLen = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAuthKeyLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaAuthKeyLen.setDescription('The length of the key used for authentication, if any.')
ipsecSaEncKeyLen = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaEncKeyLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaEncKeyLen.setDescription('The length of the key used for encryption, if any.')
ipsecSaLifeSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaLifeSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaLifeSeconds.setDescription('The period in seconds after which this SA will be destroyed.')
ipsecSaLifeKBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaLifeKBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaLifeKBytes.setDescription('The amount of data allowed to be protected by this SA until it is destroyed.')
ipsecSaProto = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255), SingleValueConstraint())).clone(namedValues=NamedValues(("icmp", 1), ("igmp", 2), ("ggp", 3), ("ipip", 4), ("st", 5), ("tcp", 6), ("cbt", 7), ("egp", 8), ("igp", 9), ("bbn", 10), ("nvp", 11), ("pup", 12), ("argus", 13), ("emcon", 14), ("xnet", 15), ("chaos", 16), ("udp", 17), ("mux", 18), ("dcn", 19), ("hmp", 20), ("prm", 21), ("xns", 22), ("trunk1", 23), ("trunk2", 24), ("leaf1", 25), ("leaf2", 26), ("rdp", 27), ("irtp", 28), ("isotp4", 29), ("netblt", 30), ("mfe", 31), ("merit", 32), ("sep", 33), ("pc3", 34), ("idpr", 35), ("xtp", 36), ("ddp", 37), ("idprc", 38), ("tp", 39), ("il", 40), ("ipv6", 41), ("sdrp", 42), ("ipv6route", 43), ("ipv6frag", 44), ("idrp", 45), ("rsvp", 46), ("gre", 47), ("mhrp", 48), ("bna", 49), ("esp", 50), ("ah", 51), ("inlsp", 52), ("swipe", 53), ("narp", 54), ("mobile", 55), ("tlsp", 56), ("skip", 57), ("ipv6icmp", 58), ("ipv6nonxt", 59), ("ipv6opts", 60), ("ipproto-61", 61), ("cftp", 62), ("local", 63), ("sat", 64), ("kryptolan", 65), ("rvd", 66), ("ippc", 67), ("distfs", 68), ("satmon", 69), ("visa", 70), ("ipcv", 71), ("cpnx", 72), ("cphb", 73), ("wsn", 74), ("pvp", 75), ("brsatmon", 76), ("sunnd", 77), ("wbmon", 78), ("wbexpak", 79), ("isoip", 80), ("vmtp", 81), ("securevmtp", 82), ("vines", 83), ("ttp", 84), ("nsfnet", 85), ("dgp", 86), ("tcf", 87), ("eigrp", 88), ("ospfigp", 89), ("sprite", 90), ("larp", 91), ("mtp", 92), ("ax25", 93), ("ipwip", 94), ("micp", 95), ("scc", 96), ("etherip", 97), ("encap", 98), ("encrypt", 99), ("gmtp", 100), ("ifmp", 101), ("pnni", 102), ("pim", 103), ("aris", 104), ("scps", 105), ("qnx", 106), ("an", 107), ("ippcp", 108), ("snp", 109), ("compaq", 110), ("ipxip", 111), ("vrrp", 112), ("pgm", 113), ("hop0", 114), ("l2tp", 115), ("ipproto-116", 116), ("ipproto-117", 117), ("ipproto-118", 118), ("ipproto-119", 119), ("ipproto-120", 120), ("ipproto-121", 121), ("ipproto-122", 122), ("ipproto-123", 123), ("ipproto-124", 124), ("ipproto-125", 125), ("ipproto-126", 126), ("ipproto-127", 127), ("ipproto-128", 128), ("ipproto-129", 129), ("ipproto-130", 130), ("ipproto-131", 131), ("ipproto-132", 132), ("ipproto-133", 133), ("ipproto-134", 134), ("ipproto-135", 135), ("ipproto-136", 136), ("ipproto-137", 137), ("ipproto-138", 138), ("ipproto-139", 139), ("ipproto-140", 140), ("ipproto-141", 141), ("ipproto-142", 142), ("ipproto-143", 143), ("ipproto-144", 144), ("ipproto-145", 145), ("ipproto-146", 146), ("ipproto-147", 147), ("ipproto-148", 148), ("ipproto-149", 149), ("ipproto-150", 150), ("ipproto-151", 151), ("ipproto-152", 152), ("ipproto-153", 153), ("ipproto-154", 154), ("ipproto-155", 155), ("ipproto-156", 156), ("ipproto-157", 157), ("ipproto-158", 158), ("ipproto-159", 159), ("ipproto-160", 160), ("ipproto-161", 161), ("ipproto-162", 162), ("ipproto-163", 163), ("ipproto-164", 164), ("ipproto-165", 165), ("ipproto-166", 166), ("ipproto-167", 167), ("ipproto-168", 168), ("ipproto-169", 169), ("ipproto-170", 170), ("ipproto-171", 171), ("ipproto-172", 172), ("ipproto-173", 173), ("ipproto-174", 174), ("ipproto-175", 175), ("ipproto-176", 176), ("ipproto-177", 177), ("ipproto-178", 178), ("ipproto-179", 179), ("ipproto-180", 180), ("ipproto-181", 181), ("ipproto-182", 182), ("ipproto-183", 183), ("ipproto-184", 184), ("ipproto-185", 185), ("ipproto-186", 186), ("ipproto-187", 187), ("ipproto-188", 188), ("ipproto-189", 189), ("ipproto-190", 190), ("ipproto-191", 191), ("ipproto-192", 192), ("ipproto-193", 193), ("ipproto-194", 194), ("ipproto-195", 195), ("ipproto-196", 196), ("ipproto-197", 197), ("ipproto-198", 198), ("ipproto-199", 199), ("ipproto-200", 200), ("ipproto-201", 201), ("ipproto-202", 202), ("ipproto-203", 203), ("ipproto-204", 204), ("ipproto-205", 205), ("ipproto-206", 206), ("ipproto-207", 207), ("ipproto-208", 208), ("ipproto-209", 209), ("ipproto-210", 210), ("ipproto-211", 211), ("ipproto-212", 212), ("ipproto-213", 213), ("ipproto-214", 214), ("ipproto-215", 215), ("ipproto-216", 216), ("ipproto-217", 217), ("ipproto-218", 218), ("ipproto-219", 219), ("ipproto-220", 220), ("ipproto-221", 221), ("ipproto-222", 222), ("ipproto-223", 223), ("ipproto-224", 224), ("ipproto-225", 225), ("ipproto-226", 226), ("ipproto-227", 227), ("ipproto-228", 228), ("ipproto-229", 229), ("ipproto-230", 230), ("ipproto-231", 231), ("ipproto-232", 232), ("ipproto-233", 233), ("ipproto-234", 234), ("ipproto-235", 235), ("ipproto-236", 236), ("ipproto-237", 237), ("ipproto-238", 238), ("ipproto-239", 239), ("ipproto-240", 240), ("ipproto-241", 241), ("ipproto-242", 242), ("ipproto-243", 243), ("ipproto-244", 244), ("ipproto-245", 245), ("ipproto-246", 246), ("ipproto-247", 247), ("ipproto-248", 248), ("ipproto-249", 249), ("ipproto-250", 250), ("ipproto-251", 251), ("ipproto-252", 252), ("ipproto-253", 253), ("ipproto-254", 254), ("dont-verify", 255)) + NamedValues())).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaProto.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaProto.setDescription('The protocol this SA covers.')
ipsecSaSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSrcPort.setDescription('The source port this SA covers, 0 for any.')
ipsecSaDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDstPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaDstPort.setDescription('The destination port this SA covers, 0 for any.')
ipsecSaSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaSeconds.setDescription('The number of seconds since this SA was created.')
ipsecSaBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaBytes.setDescription('The amount of data in kilobytes protected by this SA.')
ipsecSaPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaPackets.setDescription('The number of packets protected by this SA.')
ipsecSaReplayErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaReplayErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaReplayErrors.setDescription('The number of replayed packets detected for this SA.')
ipsecSaRecvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaRecvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaRecvErrors.setDescription('The number of receive errors (replayed packets not counted) detected for this SA.')
ipsecSaDecryptErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 3, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDecryptErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecSaDecryptErrors.setDescription('The number of decryption errors (ESP only) detected for this SA.')
ikeSaTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 4), )
if mibBuilder.loadTexts: ikeSaTable.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaTable.setDescription('This table contains the list of currently active IKE security associations.')
ikeSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ikeSaIndex"))
if mibBuilder.loadTexts: ikeSaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaEntry.setDescription('This object contains an IKE security association.')
ikeSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaIndex.setDescription('A unique index for this entry.')
ikeSaState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("negotiating", 1), ("established", 2), ("waiting-for-remove", 3), ("delete", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeSaState.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaState.setDescription('This object specifies the state of the SA. Possible values: negotiating(1), -- the SA is still being negotiated established(2), -- the SA negotiation is finished waiting-for-remove(3), -- the SA is waiting for removal delete(7) -- mark the SA for deletion.')
ikeSaXchType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 256))).clone(namedValues=NamedValues(("base", 1), ("id-protect", 2), ("authentication-only", 3), ("aggressive", 4), ("info", 5), ("quick", 32), ("new-group", 33), ("any", 256)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaXchType.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaXchType.setDescription('The exchange mode used to create the SA. Possible values: base(1), -- IKE base mode mode id-protect(2), -- IKE identity protection -- (oakley main mode) authentication-only(3), -- Authentication only mode aggressive(4), -- IKE (oakley) aggressive mode info(5), -- IKE informational exchange mode quick(32), -- IKE quick mode new-group(33), -- IKE new group mode any(256) -- Other mode.')
ikeSaAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pre-sh-key", 1), ("dss-sig", 2), ("rsa-sig", 3), ("rsa-enc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaAuthMethod.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaAuthMethod.setDescription('The authenticatin method used when negotiating this SA. Possible values: pre-sh-key(1), -- Authentication using pre shared keys dss-sig(2), -- Authentication using DSS signatures rsa-sig(3), -- Authentication using RSA signatures rsa-enc(4) -- Authentication using RSA encryption.')
ikeSaAlgs = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaAlgs.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaAlgs.setDescription('The names of the encryption and hash algorithm and of the prf.')
ikeSaRole = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("initiator", 1), ("responder", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaRole.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaRole.setDescription('This object specifies by which side the SA negotiation was initiated. Possible values: true(1), -- this end initiated the SA negotiation false(2) -- the remote end initiated the SA negotiation.')
ikeSaLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaLocalId.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaLocalId.setDescription('The local ID used for authentication.')
ikeSaRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaRemoteId.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaRemoteId.setDescription('The remote ID used for authentication.')
ikeSaRemoteIp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaRemoteIp.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaRemoteIp.setDescription('The remote IP address used in the IKE communication.')
ikeSaCookieI = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaCookieI.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaCookieI.setDescription('The cookie of the initiator.')
ikeSaCookieR = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaCookieR.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaCookieR.setDescription('The cookie of the responder.')
ikeSaTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaTimes.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaTimes.setDescription('The creation time and last used time of the SA in human readable format.')
ikeSaNumCerts = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaNumCerts.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaNumCerts.setDescription('The number of certificates received from the remote side when negotiating this SA.')
ikeSaNumNegotiations = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaNumNegotiations.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaNumNegotiations.setDescription('This object specifies the number of currently active negotiations for this SA.')
ikeSaBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaBytes.setDescription('Number of bytes transmitted using this SA.')
ikeSaMajVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaMajVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaMajVersion.setDescription('The IKE major version number.')
ikeSaMinVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 4, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeSaMinVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ikeSaMinVersion.setDescription('The IKE minor version number.')
ipsecPeerTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 5), )
if mibBuilder.loadTexts: ipsecPeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerTable.setDescription('This table contains the list of IPSec peers.')
ipsecPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ipsecPeerTrafficList"))
if mibBuilder.loadTexts: ipsecPeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerEntry.setDescription('This object contains the description of an IPSec peer.')
ipsecPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecPeerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerIndex.setDescription('A unique index identifying this entry.')
ipsecPeerNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerNextIndex.setDescription('The index of the next peer in hierarchy.')
ipsecPeerDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerDescription.setDescription('An optional description for this peer.')
ipsecPeerPeerIds = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerPeerIds.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerPeerIds.setDescription('The IDs of the peer which are accepted for authentication.')
ipsecPeerPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerPeerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerPeerAddress.setDescription('The IP-address of the peer.')
ipsecPeerLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerLocalId.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerLocalId.setDescription('The local ID used for authentication.')
ipsecPeerLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerLocalAddress.setDescription('The local address used for IPSec encrypted packets.')
ipsecPeerLocalCert = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerLocalCert.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerLocalCert.setDescription('The index of the certificate used for local authentication in the certTable. Only useful for automatically keyed traffic with dsa or rsa authentication.')
ipsecPeerIkeProposals = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerIkeProposals.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerIkeProposals.setDescription('The index of the first IKE proposal which may be used for IKE SA negotiation with this peer.')
ipsecPeerTrafficList = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerTrafficList.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerTrafficList.setDescription('This object specifies the first entry of possibly a chain of traffic entries from the ipsecTrafficTable which should be protected with IPSec using this peer.')
ipsecPeerAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 14, 15))).clone(namedValues=NamedValues(("pre-sh-key", 1), ("dss-sig", 2), ("rsa-sig", 3), ("rsa-enc", 4), ("default", 14), ("delete", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerAuthMethod.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerAuthMethod.setDescription('The authentication method used. Possible values: pre-sh-key(1), -- Authentication using pre shared keys dss-sig(2), -- Authentication using DSS signatures rsa-sig(3), -- Authentication using RSA signatures rsa-enc(4), -- Authentication using RSA encryption default(14), -- Use the default settings from the -- ipsecGlobals table delete(15) -- mark this entry for deletion.')
ipsecPeerPreSharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 21), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerPreSharedKey.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerPreSharedKey.setDescription('The pre-shared-key used with this peer, if pre-shared-keys are used for authentication. This field serves only as an input field and its contents are replaced with a single asterisk immediately after it is set.')
ipsecPeerIkeGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerIkeGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerIkeGroup.setDescription('The Group used for Diffie Hellman key agreement algorithm. Possible values: 0: use default value from ipsecGlobals table 1: a 768-bit MODP group 2: a 1024-bit MODP group 3: a GF[2^155] group 4: a GF[2^185] group 5: a 1536-bit MODP group')
ipsecPeerPfsGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerPfsGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerPfsGroup.setDescription('The Diffie Hellman group used for additional Perfect Forward Secrecy (PFS) DH exponentiations. Possible values: -1: explicitly do not use PFS (overrides ipsecGlob2DefaultPfsGroup), 0: use default value from ipsecGlob2DefaultPfsGroup, 1: a 768-bit MODP group, 2: a 1024-bit MODP group, 5: a 1536-bit MODP group.')
ipsecPeerPh1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("id-protect", 1), ("aggressive", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerPh1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerPh1Mode.setDescription('This object specifies the exchange mode used for IKE SA negotiation. Possible values: id-protect(1), -- Use identity protection (main) mode aggressive(2), -- Use aggressive mode default(3) -- Use default settings from the -- ipsecGlobalsTable.')
ipsecPeerIkeLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerIkeLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerIkeLifeTime.setDescription('This object specifies an index in the ipsecLifeTimeTable. If the lifetime pointed to by this index does not exist or is inappropriate, the default lifetime from the ipsecGlobalsTable is used.')
ipsecPeerIpsecLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerIpsecLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerIpsecLifeTime.setDescription('This object specifies an index in the ipsecLifeTimeTable. This lifetime overwrites the lifetimes specified for all traffic entries and their proposals referenced by this peer entry. If the lifetime pointed to by this index does not exist or is inappropriate, the default lifetime from the ipsecGlobalsTable is used.')
ipsecPeerKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerKeepAlive.setDescription("This object specifies whether IKE SA's with this peer are rekeyed even if there was no data transferred over them. Possible values: true(1), -- rekey SA's even if no data was transferred false(2) -- do not rekey SA's if no data was transferred.")
ipsecPeerGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("default", 1), ("coarse", 2), ("ip", 3), ("proto", 4), ("port", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerGranularity.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerGranularity.setDescription("This object specifies the granularity with which SA's with this peer are created. Possible values: default(1), -- use the setting from the ipsecGlobalsTable coarse(2), -- Create only one SA for each Traffic entry ip(3), -- Create one SA for each host proto(4), -- Create one SA for each protocol and host port(5) -- Create one SA for each port and host.")
ipsecPeerDontVerifyPad = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerDontVerifyPad.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerDontVerifyPad.setDescription('This object is a compatibility option for older ipsec implementations. It enables or disables an old way of ESP padding (no self describing padding). Possible values: false(1), -- normal, self-describing ESP padding true(2) -- old style ESP padding.')
ipsecPeerDefaultIpsecProposals = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPeerDefaultIpsecProposals.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerDefaultIpsecProposals.setDescription('The index of the default IPSec proposal used for encrypting all the traffic bound to the (optional) logical interface created for this peer.')
ipsecPeerPreSharedKeyData = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 5, 1, 63), OctetString())
if mibBuilder.loadTexts: ipsecPeerPreSharedKeyData.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPeerPreSharedKeyData.setDescription('Field used for storing the pre-shared-key permanently.')
ikeProposalTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 6), )
if mibBuilder.loadTexts: ikeProposalTable.setStatus('mandatory')
if mibBuilder.loadTexts: ikeProposalTable.setDescription('This table contains the list of IKE proposals. The entries may be concatenated on a logical or basis using the NextChoice field to choices of multiple proposals.')
ikeProposalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 6, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ikePropEncAlg"))
if mibBuilder.loadTexts: ikeProposalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ikeProposalEntry.setDescription('This object contains an IKE proposal, i.e. the encryption algorithm and the hash algorithm used to protect traffic sent over an IKE SA.')
ikePropIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikePropIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ikePropIndex.setDescription('A unique index identifying this entry.')
ikePropNextChoice = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikePropNextChoice.setStatus('mandatory')
if mibBuilder.loadTexts: ikePropNextChoice.setDescription('This object specifies the index of the next proposal of a choice of proposals. If this object is 0, this marks the end of a proposal chain.')
ikePropDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 6, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikePropDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ikePropDescription.setDescription('An optional textual description of the proposal chain beginning at this entry.')
ikePropEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("des-cbc", 2), ("des3-cbc", 3), ("blowfish-cbc", 4), ("cast128-cbc", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikePropEncAlg.setStatus('mandatory')
if mibBuilder.loadTexts: ikePropEncAlg.setDescription('This object specifies the encryption algorithm used to protect traffic sent over an IKE SA. Possible values: none(1), -- No encryption applied des-cbc(2), -- DES in CBC mode des3-cbc(3), -- Triple DES in CBC mode blowfish-cbc(4), -- Blowfish in CBC mode cast128-cbc(5) -- CAST in CBC mode with 128 bit key.')
ikePropHashAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("none", 2), ("md5", 3), ("sha1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikePropHashAlg.setStatus('mandatory')
if mibBuilder.loadTexts: ikePropHashAlg.setDescription('This object specifies the hash algorithm used to protect traffic sent over an IKE SA. Possible values: delete(1), -- Delete this entry none(2), -- No hash algorithm md5(3), -- The MD5 hash algorithm sha1(4), -- The Secure Hash Algorithm.')
ipsecTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 7), )
if mibBuilder.loadTexts: ipsecTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrafficTable.setDescription('This table contains lists of Traffic and the actions which should be applied to it, together with the necessary parameters.')
ipsecTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ipsecTrProto"))
if mibBuilder.loadTexts: ipsecTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrafficEntry.setDescription('This object contains a description of a type of IP traffic and the action which should be applied to it together with the necessary parameters.')
ipsecTrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrIndex.setDescription('A unique index identifying this entry.')
ipsecTrNextIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrNextIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrNextIndex.setDescription('This object specifies the index of the next traffic entry in hierarchy.')
ipsecTrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrDescription.setDescription('An optional human readable description for this traffic entry.')
ipsecTrLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrLocalAddress.setDescription('The source IP-address of this traffic entry. It maybe either a single address, a network address (in combination with ipsecTrSrcMask), or the first address of an address range (in combination with ipsecTrLocalRange).')
ipsecTrLocalMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrLocalMaskLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrLocalMaskLen.setDescription('The length of the network mask for a source network.')
ipsecTrLocalRange = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrLocalRange.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrLocalRange.setDescription('The last address of a source address range. If this field is nonzero, the ipsecTrLocalMaskLen field is ignored and the source is considered as a range of addresses beginning with ipsecTrLocalAddress and ending with ipsecTrLocalRange.')
ipsecTrRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrRemoteAddress.setDescription('The destination IP-address of this traffic entry. It maybe either a single address, a network address (in combination with ipsecTrDstMask), or the first address of an address range (in combination with ipsecTrRemoteRange).')
ipsecTrRemoteMaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrRemoteMaskLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrRemoteMaskLen.setDescription('The length of the network mask for a destination network.')
ipsecTrRemoteRange = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrRemoteRange.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrRemoteRange.setDescription('The last address of a destination address range. If this field is nonzero, the ipsecTrRemoteMaskLen field is ignored and the source is considered as a range of addresses beginning with ipsecTrRemoteAddress and ending with ipsecTrRemoteRange.')
ipsecTrProto = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255), SingleValueConstraint())).clone(namedValues=NamedValues(("icmp", 1), ("igmp", 2), ("ggp", 3), ("ipip", 4), ("st", 5), ("tcp", 6), ("cbt", 7), ("egp", 8), ("igp", 9), ("bbn", 10), ("nvp", 11), ("pup", 12), ("argus", 13), ("emcon", 14), ("xnet", 15), ("chaos", 16), ("udp", 17), ("mux", 18), ("dcn", 19), ("hmp", 20), ("prm", 21), ("xns", 22), ("trunk1", 23), ("trunk2", 24), ("leaf1", 25), ("leaf2", 26), ("rdp", 27), ("irtp", 28), ("isotp4", 29), ("netblt", 30), ("mfe", 31), ("merit", 32), ("sep", 33), ("pc3", 34), ("idpr", 35), ("xtp", 36), ("ddp", 37), ("idprc", 38), ("tp", 39), ("il", 40), ("ipv6", 41), ("sdrp", 42), ("ipv6route", 43), ("ipv6frag", 44), ("idrp", 45), ("rsvp", 46), ("gre", 47), ("mhrp", 48), ("bna", 49), ("esp", 50), ("ah", 51), ("inlsp", 52), ("swipe", 53), ("narp", 54), ("mobile", 55), ("tlsp", 56), ("skip", 57), ("ipv6icmp", 58), ("ipv6nonxt", 59), ("ipv6opts", 60), ("ipproto-61", 61), ("cftp", 62), ("local", 63), ("sat", 64), ("kryptolan", 65), ("rvd", 66), ("ippc", 67), ("distfs", 68), ("satmon", 69), ("visa", 70), ("ipcv", 71), ("cpnx", 72), ("cphb", 73), ("wsn", 74), ("pvp", 75), ("brsatmon", 76), ("sunnd", 77), ("wbmon", 78), ("wbexpak", 79), ("isoip", 80), ("vmtp", 81), ("securevmtp", 82), ("vines", 83), ("ttp", 84), ("nsfnet", 85), ("dgp", 86), ("tcf", 87), ("eigrp", 88), ("ospfigp", 89), ("sprite", 90), ("larp", 91), ("mtp", 92), ("ax25", 93), ("ipwip", 94), ("micp", 95), ("scc", 96), ("etherip", 97), ("encap", 98), ("encrypt", 99), ("gmtp", 100), ("ifmp", 101), ("pnni", 102), ("pim", 103), ("aris", 104), ("scps", 105), ("qnx", 106), ("an", 107), ("ippcp", 108), ("snp", 109), ("compaq", 110), ("ipxip", 111), ("vrrp", 112), ("pgm", 113), ("hop0", 114), ("l2tp", 115), ("ipproto-116", 116), ("ipproto-117", 117), ("ipproto-118", 118), ("ipproto-119", 119), ("ipproto-120", 120), ("ipproto-121", 121), ("ipproto-122", 122), ("ipproto-123", 123), ("ipproto-124", 124), ("ipproto-125", 125), ("ipproto-126", 126), ("ipproto-127", 127), ("ipproto-128", 128), ("ipproto-129", 129), ("ipproto-130", 130), ("ipproto-131", 131), ("ipproto-132", 132), ("ipproto-133", 133), ("ipproto-134", 134), ("ipproto-135", 135), ("ipproto-136", 136), ("ipproto-137", 137), ("ipproto-138", 138), ("ipproto-139", 139), ("ipproto-140", 140), ("ipproto-141", 141), ("ipproto-142", 142), ("ipproto-143", 143), ("ipproto-144", 144), ("ipproto-145", 145), ("ipproto-146", 146), ("ipproto-147", 147), ("ipproto-148", 148), ("ipproto-149", 149), ("ipproto-150", 150), ("ipproto-151", 151), ("ipproto-152", 152), ("ipproto-153", 153), ("ipproto-154", 154), ("ipproto-155", 155), ("ipproto-156", 156), ("ipproto-157", 157), ("ipproto-158", 158), ("ipproto-159", 159), ("ipproto-160", 160), ("ipproto-161", 161), ("ipproto-162", 162), ("ipproto-163", 163), ("ipproto-164", 164), ("ipproto-165", 165), ("ipproto-166", 166), ("ipproto-167", 167), ("ipproto-168", 168), ("ipproto-169", 169), ("ipproto-170", 170), ("ipproto-171", 171), ("ipproto-172", 172), ("ipproto-173", 173), ("ipproto-174", 174), ("ipproto-175", 175), ("ipproto-176", 176), ("ipproto-177", 177), ("ipproto-178", 178), ("ipproto-179", 179), ("ipproto-180", 180), ("ipproto-181", 181), ("ipproto-182", 182), ("ipproto-183", 183), ("ipproto-184", 184), ("ipproto-185", 185), ("ipproto-186", 186), ("ipproto-187", 187), ("ipproto-188", 188), ("ipproto-189", 189), ("ipproto-190", 190), ("ipproto-191", 191), ("ipproto-192", 192), ("ipproto-193", 193), ("ipproto-194", 194), ("ipproto-195", 195), ("ipproto-196", 196), ("ipproto-197", 197), ("ipproto-198", 198), ("ipproto-199", 199), ("ipproto-200", 200), ("ipproto-201", 201), ("ipproto-202", 202), ("ipproto-203", 203), ("ipproto-204", 204), ("ipproto-205", 205), ("ipproto-206", 206), ("ipproto-207", 207), ("ipproto-208", 208), ("ipproto-209", 209), ("ipproto-210", 210), ("ipproto-211", 211), ("ipproto-212", 212), ("ipproto-213", 213), ("ipproto-214", 214), ("ipproto-215", 215), ("ipproto-216", 216), ("ipproto-217", 217), ("ipproto-218", 218), ("ipproto-219", 219), ("ipproto-220", 220), ("ipproto-221", 221), ("ipproto-222", 222), ("ipproto-223", 223), ("ipproto-224", 224), ("ipproto-225", 225), ("ipproto-226", 226), ("ipproto-227", 227), ("ipproto-228", 228), ("ipproto-229", 229), ("ipproto-230", 230), ("ipproto-231", 231), ("ipproto-232", 232), ("ipproto-233", 233), ("ipproto-234", 234), ("ipproto-235", 235), ("ipproto-236", 236), ("ipproto-237", 237), ("ipproto-238", 238), ("ipproto-239", 239), ("ipproto-240", 240), ("ipproto-241", 241), ("ipproto-242", 242), ("ipproto-243", 243), ("ipproto-244", 244), ("ipproto-245", 245), ("ipproto-246", 246), ("ipproto-247", 247), ("ipproto-248", 248), ("ipproto-249", 249), ("ipproto-250", 250), ("ipproto-251", 251), ("ipproto-252", 252), ("ipproto-253", 253), ("ipproto-254", 254), ("dont-verify", 255)) + NamedValues())).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrProto.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrProto.setDescription('The transport protocol defined for this entry.')
ipsecTrLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrLocalPort.setDescription('The source port defined for this traffic entry.')
ipsecTrRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrRemotePort.setDescription('The destination port defined for this traffic entry.')
ipsecTrAction = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("delete", 1), ("always-plain", 2), ("pass", 3), ("protect", 4), ("drop", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrAction.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrAction.setDescription('The action to be applied to traffic matching this entry. Possible values: delete(1), -- Delete this entry always-plain(2), -- Forward the packets without -- protection even if there is a -- matching SA and independent from -- the position of the traffic entry -- in the list. pass(3), -- Forward the packets without -- protection protect(4), -- Protect the traffic as specified -- in the proposal. Drop unprotected -- traffic of this kind. drop(5) -- Drop all packets matching this -- traffic entry.')
ipsecTrProposal = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrProposal.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrProposal.setDescription('This object specifies an index in the ipsecProposalTable. This may be the first proposal of possibly a choice of multiple, optionally nested proposals which is to be offered with IKE (automatic keying) or a manual proposal (manual keying).')
ipsecTrForceTunnelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrForceTunnelMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrForceTunnelMode.setDescription('This object specifies the strategy when transport mode is used. By default, the system always uses transport mode, if possible. If this variable is set to true, always tunnel mode will be used for this traffic entry, even if source and destination address match the tunnel endpoints. Possible values: true(1), -- Use tunnel mode even if transport mode is possible false(2) -- Use transport mode whenever possible.')
ipsecTrLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrLifeTime.setDescription('This object specifies an index in the ipsecLifeTimeTable. This lifetime overwrites the lifetimes specified for all proposals referenced by this traffic entry. It may itself be overwritten by an explicit lifetime specified for the peer entry referencing this traffic entry. If the lifetime pointed to by this index does not exist or is inappropriate, the default lifetime from the ipsecGlobalsTable is used.')
ipsecTrGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("default", 1), ("coarse", 2), ("ip", 3), ("proto", 4), ("port", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrGranularity.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrGranularity.setDescription("This object specifies the granularity with which SA's must be created for this kind of traffic. Possible values: default(1), -- use the setting from the ipsecPeerTable coarse(2), -- Create only one SA for each Traffic entry ip(3), -- Create one SA for each host proto(4), -- Create one SA for each protocol and host port(5) -- Create one SA for each port and host.")
ipsecTrKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 7, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecTrKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecTrKeepAlive.setDescription("This object specifies whether SA's created for this kind of traffic should be rekeyed on expiration of soft lifetimes even if there has not been sent any traffic over them. Possible values: true(1), -- rekey SA's even if no data was transferred false(2), -- do not rekey SA's if no data was transferred default(3) -- use the default setting from the peer entry -- referencing this traffic entry.")
ipsecProposalTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 8), )
if mibBuilder.loadTexts: ipsecProposalTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecProposalTable.setDescription("This table contains the list of IPSec proposals. The entries may be concatenated on a logical 'or' or a logical 'and' basis -depending on the setting of the 'BoolOp' field- using the 'Next' field. This makes the configuration of multiple choices of proposal bundles possible. Possible concatenation: (proposal1 or propsal2 or ... proposaln) and (proposal1 or propsal2 or ... proposaln) and : : (proposal1 or propsal2 or ... proposaln) This table also includes manually keyed security associations, which may not be concatenated to choices with BoolOp set to 'or'")
ipsecProposalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ipsecPropProto"))
if mibBuilder.loadTexts: ipsecProposalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecProposalEntry.setDescription('This object contains an IPSec proposal, i.e. a proposed set of security parameters applied to traffic sent over an IPSec security association.')
ipsecPropIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecPropIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropIndex.setDescription('A unique index for this entry.')
ipsecPropNext = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropNext.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropNext.setDescription('The index of the next Proposal in the actual chain.')
ipsecPropBoolOp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delete", 1), ("or", 2), ("and", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropBoolOp.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropBoolOp.setDescription("This object specifies how the proposal referenced by Next should be concatenated. Possible values: delete(1), -- Delete this entry or(2), -- Concatenation with logical 'or' and(3) -- Concatenation with logical 'and'.")
ipsecPropDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropDescription.setDescription('An optional human readable description for this proposal.')
ipsecPropProto = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("esp", 1), ("ah", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropProto.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropProto.setDescription('The security protocol to apply. Possible values: esp(1), -- Encapsulating Security Payload ah(2) -- Authentication Header.')
ipsecPropEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("des-cbc", 2), ("des3-cbc", 3), ("blowfish-cbc", 4), ("cast128-cbc", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropEncAlg.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropEncAlg.setDescription('The encryption algorithm to apply, if any. Possible values: none(1), -- No encryption applied des-cbc(2), -- DES in CBC mode des3-cbc(3), -- Triple DES in CBC mode blowfish(4), -- Blowfish in CBC mode cast128-cbc(5) -- CAST with 128 bit key in CBC mode.')
ipsecPropAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 6))).clone(namedValues=NamedValues(("none", 2), ("md5-96", 4), ("sha1-96", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropAuthAlg.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropAuthAlg.setDescription('The hmac algorithm to use for authentication, if any. Possible values: none(2), -- No hmac md5-96(4), -- Use the MD5 hash algorithm with 96 bit -- output sha1-96(6) -- Use the Secure Hash Algorithm with 96 bit -- output.')
ipsecPropLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropLifeTime.setDescription('The index in the ipsecLifeTimeTable containing the lifetime values ued for an SA created from this proposal. This field may be overwritten by an explicit lifetime specified for the traffic entry which references this proposal entry, or by an explicit lifetime specified for the peer entry referencing that traffic entry. If this field is empty or points to a nonexistent or inappropriate lifetime entry, the default life time from the ipsecGlobalsTable is used.')
ipsecPropInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 11), HexValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropInSpi.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropInSpi.setDescription("This object specifies the Security Parameters Index (SPI) which should be used for the inbound SA of a manually keyed Proposal. The SPI is used to distinguish between multiple IPSec connections to the same peer with the same security protocol. The outbound SPI of the remote sides' corresponding proposal entry has to be equal to this value. This object is ignored for automatically keyed SAs, as it is chosen randomly by the initiator.")
ipsecPropOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 12), HexValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropOutSpi.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropOutSpi.setDescription("This object specifies the Security Parameters Index (SPI) which should be used for the outbound SA of a manually keyed Proposal. The SPI is used to distinguish between multiple IPSec connections to the same peer with the same security protocol. The inbound SPI of the remote sides' corresponding proposal entry has to be equal to this value. This object is ignored for automatically keyed SAs, as it is chosen randomly by the initiator.")
ipsecPropEncKeyIn = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropEncKeyIn.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropEncKeyIn.setDescription('This object serves as an input field for the inbound encryption key used with manually keyed SAs. Its contents are reset to a single asterisk immediately after the set operation (or input via the console). It is not evaluated for automatic proposals or for proposals which do not require an encryption key.')
ipsecPropEncKeyOut = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropEncKeyOut.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropEncKeyOut.setDescription('This object serves as an input field for the outbound encryption key used with manually keyed SAs. Its contents are reset to a single asterisk immediately after the set operation (or input via the console). It is not evaluated for automatic proposals or for proposals which do not require an encryption key.')
ipsecPropAuthKeyIn = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 17), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropAuthKeyIn.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropAuthKeyIn.setDescription('This object serves as an input field for the inbound authentication key used with manually keyed SAs. Its contents are reset to a single asterisk immediately after the set operation (or input via the console). It is not evaluated for automatic proposals or for proposals which do not require an authentication key.')
ipsecPropAuthKeyOut = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecPropAuthKeyOut.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropAuthKeyOut.setDescription('This object serves as an input field for the outbound authentication key used with manually keyed SAs. Its contents are reset to a single asterisk immediately after the set operation (or input via the console). It is not evaluated for automatic proposals or for proposals which do not require an authentication key.')
ipsecPropEncKeyDataIn = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 33), OctetString())
if mibBuilder.loadTexts: ipsecPropEncKeyDataIn.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropEncKeyDataIn.setDescription('')
ipsecPropEncKeyDataOut = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 34), OctetString())
if mibBuilder.loadTexts: ipsecPropEncKeyDataOut.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropEncKeyDataOut.setDescription('')
ipsecPropAuthKeyDataIn = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 35), OctetString())
if mibBuilder.loadTexts: ipsecPropAuthKeyDataIn.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropAuthKeyDataIn.setDescription('')
ipsecPropAuthKeyDataOut = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 8, 1, 36), OctetString())
if mibBuilder.loadTexts: ipsecPropAuthKeyDataOut.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecPropAuthKeyDataOut.setDescription('')
ipsecLifeTimeTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 26, 9), )
if mibBuilder.loadTexts: ipsecLifeTimeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeTimeTable.setDescription('This table contains the list of defined lifetimes for IPsec and IKE SAs.')
ipsecLifeTimeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1), ).setIndexNames((0, "BIANCA-BRICK-IPSEC-MIB", "ipsecLifeType"))
if mibBuilder.loadTexts: ipsecLifeTimeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeTimeEntry.setDescription("This object contains a lifetime, i.e. the soft and hard expiry limits for IPsec and IKE SA's.")
ipsecLifeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecLifeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeIndex.setDescription('A unique index identifying this entry.')
ipsecLifeType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("generic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecLifeType.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeType.setDescription('This object specifies the type of a lifetime entry.')
ipsecLifeSoftKb = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecLifeSoftKb.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeSoftKb.setDescription('The maximum amount of data (in KB) which may be protected by an SA before it is refreshed.')
ipsecLifeSoftSec = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecLifeSoftSec.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeSoftSec.setDescription('The maximum time (in seconds) after which an SA will be refreshed,.')
ipsecLifeHardKb = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecLifeHardKb.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeHardKb.setDescription('The maximum amount of data (in KB) which may be protected by an SA before it is deleted.')
ipsecLifeHardSec = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 26, 9, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipsecLifeHardSec.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecLifeHardSec.setDescription('The maximum time (in seconds) after which an SA will be refreshed,.')
ipsecStats = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 26, 10))
ipsecStatsCurrentIkeSas = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsCurrentIkeSas.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsCurrentIkeSas.setDescription("Current number of IKE SA's.")
ipsecStatsCurrentIpsecSas = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsCurrentIpsecSas.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsCurrentIpsecSas.setDescription("Current number of IPSec SA's.")
ipsecStatsIp = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsIp.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsIp.setDescription('Number of IP packets processed.')
ipsecStatsNonIp = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsNonIp.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsNonIp.setDescription('Number of non-IP packets processed.')
ipsecStatsAh = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsAh.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsAh.setDescription('Number of AH packets processed.')
ipsecStatsEsp = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsEsp.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsEsp.setDescription('Number of ESP packets processed.')
ipsecStatsDrop = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsDrop.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsDrop.setDescription('Number of packets dropped.')
ipsecStatsPass = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsPass.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsPass.setDescription('Number of packets passed plain.')
ipsecStatsTrig = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsTrig.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsTrig.setDescription('Number of packets which triggered an IKE negotiation.')
ipsecStatsFragPkt = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsFragPkt.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsFragPkt.setDescription('Number of partial packets currently being reassembled.')
ipsecStatsFragBytes = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsFragBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsFragBytes.setDescription('Total size of the partial packets currently being reassembled.')
ipsecStatsFragNonfirst = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 26, 10, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecStatsFragNonfirst.setStatus('mandatory')
if mibBuilder.loadTexts: ipsecStatsFragNonfirst.setDescription('Number of non-first fragments currently queued.')
mibBuilder.exportSymbols("BIANCA-BRICK-IPSEC-MIB", ipsecGlobContDefaultRule=ipsecGlobContDefaultRule, ipsecSaEncKeyLen=ipsecSaEncKeyLen, bintec=bintec, ipsecGlobDefaultIkeLifeTime=ipsecGlobDefaultIkeLifeTime, ikePropEncAlg=ikePropEncAlg, ikeSaState=ikeSaState, ipsecSaIndex=ipsecSaIndex, ipsecPropNext=ipsecPropNext, ipsecPropLifeTime=ipsecPropLifeTime, ipsecGlobNoKeyHashPayloads=ipsecGlobNoKeyHashPayloads, ipsecPeerAuthMethod=ipsecPeerAuthMethod, ipsecTrRemotePort=ipsecTrRemotePort, ipsecSaAuthKeyLen=ipsecSaAuthKeyLen, ikeSaRemoteIp=ikeSaRemoteIp, ikePropDescription=ikePropDescription, dod=dod, ipsecGlobDefaultAuthMethod=ipsecGlobDefaultAuthMethod, ipsecGlobRetryTimeoutMaxsec=ipsecGlobRetryTimeoutMaxsec, ipsecSaDstMaskLen=ipsecSaDstMaskLen, org=org, ipsecSaDstPort=ipsecSaDstPort, ikeSaTimes=ikeSaTimes, ikeSaXchType=ikeSaXchType, ipsecSaReplayErrors=ipsecSaReplayErrors, ipsecPeerLocalCert=ipsecPeerLocalCert, ikeSaTable=ikeSaTable, ipsecSaBytes=ipsecSaBytes, ikeSaNumNegotiations=ikeSaNumNegotiations, ikePropIndex=ikePropIndex, ipsecSaPackets=ipsecSaPackets, ipsecGlobMaxIkeSas=ipsecGlobMaxIkeSas, ipsecPropAuthKeyOut=ipsecPropAuthKeyOut, ipsecProposalEntry=ipsecProposalEntry, ipsecGlobDefaultIpsecLifeTime=ipsecGlobDefaultIpsecLifeTime, ipsecSaCreator=ipsecSaCreator, ipsecSaSrcAddress=ipsecSaSrcAddress, ipsecStatsNonIp=ipsecStatsNonIp, ipsecGlobContPreIpsecRules=ipsecGlobContPreIpsecRules, ipsecStatsPass=ipsecStatsPass, ipsecGlobDefaultLocalId=ipsecGlobDefaultLocalId, ipsecPropInSpi=ipsecPropInSpi, ipsecSaSeconds=ipsecSaSeconds, ipsecSaSecProto=ipsecSaSecProto, ipsecTrProposal=ipsecTrProposal, ipsecStatsDrop=ipsecStatsDrop, ipsecGlobMaxKeyLength=ipsecGlobMaxKeyLength, ikeProposalEntry=ikeProposalEntry, ikeSaCookieI=ikeSaCookieI, ikeSaIndex=ikeSaIndex, ipsecSaDir=ipsecSaDir, ipsecGlobMaxRetries=ipsecGlobMaxRetries, ipsecPeerIpsecLifeTime=ipsecPeerIpsecLifeTime, ipsecSaState=ipsecSaState, ipsecLifeIndex=ipsecLifeIndex, ipsecLifeHardKb=ipsecLifeHardKb, ipsecGlobMaxNegotiationTimeoutsec=ipsecGlobMaxNegotiationTimeoutsec, ipsecGlobRetryTimeout0milli=ipsecGlobRetryTimeout0milli, ipsecStatsEsp=ipsecStatsEsp, ipsecStatsFragPkt=ipsecStatsFragPkt, ipsecPropProto=ipsecPropProto, ipsecPeerPreSharedKeyData=ipsecPeerPreSharedKeyData, HexValue=HexValue, ipsecLifeTimeTable=ipsecLifeTimeTable, ipsecPeerPeerAddress=ipsecPeerPeerAddress, ipsecPropIndex=ipsecPropIndex, ikeSaLocalId=ikeSaLocalId, ipsecSaMode=ipsecSaMode, ipsecPeerPfsGroup=ipsecPeerPfsGroup, ipsecPeerDefaultIpsecProposals=ipsecPeerDefaultIpsecProposals, ipsecTrKeepAlive=ipsecTrKeepAlive, ipsecPeerPreSharedKey=ipsecPeerPreSharedKey, ipsecTrLocalRange=ipsecTrLocalRange, ipsecPubKeyAlgorithm=ipsecPubKeyAlgorithm, ipsecProposalTable=ipsecProposalTable, enterprises=enterprises, ipsecTrLocalPort=ipsecTrLocalPort, ipsecPeerIndex=ipsecPeerIndex, ipsecSaTable=ipsecSaTable, ikeSaNumCerts=ikeSaNumCerts, ipsecPeerGranularity=ipsecPeerGranularity, ipsecGlobDefaultIpsecProposal=ipsecGlobDefaultIpsecProposal, ipsecPropEncKeyDataIn=ipsecPropEncKeyDataIn, ipsecStatsIp=ipsecStatsIp, ipsecPeerDescription=ipsecPeerDescription, ikeSaMinVersion=ikeSaMinVersion, ipsecPubKeyKeyLength=ipsecPubKeyKeyLength, ipsecGlobMaxSysLogLevel=ipsecGlobMaxSysLogLevel, ipsecGlobSendFullCertChains=ipsecGlobSendFullCertChains, ipsecSaPeerIp=ipsecSaPeerIp, ipsecTrLifeTime=ipsecTrLifeTime, private=private, ipsecGlobDefaultGranularity=ipsecGlobDefaultGranularity, ikeSaAlgs=ikeSaAlgs, ipsecPeerLocalAddress=ipsecPeerLocalAddress, ikePropNextChoice=ikePropNextChoice, ipsecPropEncKeyDataOut=ipsecPropEncKeyDataOut, ipsecGlobLocalSecretPeriodsec=ipsecGlobLocalSecretPeriodsec, ipsecGlobalsContinued=ipsecGlobalsContinued, ipsecSaDstRange=ipsecSaDstRange, ipsecTrRemoteAddress=ipsecTrRemoteAddress, ipsecSaAuthAlg=ipsecSaAuthAlg, ipsecStatsCurrentIkeSas=ipsecStatsCurrentIkeSas, ipsecSaLifeSeconds=ipsecSaLifeSeconds, ipsecSaDstAddress=ipsecSaDstAddress, ipsecLifeHardSec=ipsecLifeHardSec, ipsecPeerDontVerifyPad=ipsecPeerDontVerifyPad, bibo=bibo, ipsecStatsAh=ipsecStatsAh, ipsecGlobAntiCloggingLength=ipsecGlobAntiCloggingLength, ipsecSaRecvErrors=ipsecSaRecvErrors, ipsecPublicKeyTable=ipsecPublicKeyTable, ikeSaBytes=ikeSaBytes, ipsecPeerIkeGroup=ipsecPeerIkeGroup, ipsecPeerPeerIds=ipsecPeerPeerIds, ipsecPropAuthKeyDataOut=ipsecPropAuthKeyDataOut, ipsecSaSrcRange=ipsecSaSrcRange, ipsecLifeType=ipsecLifeType, ipsecPeerIkeProposals=ipsecPeerIkeProposals, ikeSaMajVersion=ikeSaMajVersion, ipsecPropEncKeyOut=ipsecPropEncKeyOut, ipsecLifeSoftKb=ipsecLifeSoftKb, ipsecPubKeyDescription=ipsecPubKeyDescription, ipsecPropAuthKeyIn=ipsecPropAuthKeyIn, ikeSaCookieR=ikeSaCookieR, ipsecPeerPh1Mode=ipsecPeerPh1Mode, ikeSaRemoteId=ikeSaRemoteId, ipsecStatsFragNonfirst=ipsecStatsFragNonfirst, ipsecSaSpi=ipsecSaSpi, ipsecStats=ipsecStats, ipsecPeerNextIndex=ipsecPeerNextIndex, ipsecTrIndex=ipsecTrIndex, DisplayString=DisplayString, ipsecGlobIgnoreCrPayloads=ipsecGlobIgnoreCrPayloads, ipsecSaSrcMaskLen=ipsecSaSrcMaskLen, ipsecStatsFragBytes=ipsecStatsFragBytes, ipsecPeerTrafficList=ipsecPeerTrafficList, ipsecSaEncAlg=ipsecSaEncAlg, ipsecPeerTable=ipsecPeerTable, ipsec=ipsec, ipsecGlobNoCrls=ipsecGlobNoCrls, ipsecPropAuthKeyDataIn=ipsecPropAuthKeyDataIn, ipsecGlobPeerIndex=ipsecGlobPeerIndex, ipsecPeerKeepAlive=ipsecPeerKeepAlive, ipsecGlobSpiSize=ipsecGlobSpiSize, ipsecTrafficTable=ipsecTrafficTable, ipsecPropEncAlg=ipsecPropEncAlg, ipsecTrGranularity=ipsecTrGranularity, ikeSaAuthMethod=ikeSaAuthMethod, ipsecTrProto=ipsecTrProto, ipsecGlobTrustIcmpMsg=ipsecGlobTrustIcmpMsg, ipsecGlobZeroIsakmpCookies=ipsecGlobZeroIsakmpCookies, ipsecLifeSoftSec=ipsecLifeSoftSec, ipsecGlobDefaultCertificate=ipsecGlobDefaultCertificate, ipsecSaLifeKBytes=ipsecSaLifeKBytes, ipsecGlobDefaultIkeProposal=ipsecGlobDefaultIkeProposal, ipsecTrNextIndex=ipsecTrNextIndex, ipsecStatsCurrentIpsecSas=ipsecStatsCurrentIpsecSas, ipsecSaSrcPort=ipsecSaSrcPort, ipsecGlobals=ipsecGlobals, ipsecSaLocalIp=ipsecSaLocalIp, ipsecGlobDefaultIkeGroup=ipsecGlobDefaultIkeGroup, ipsecTrafficEntry=ipsecTrafficEntry, ikePropHashAlg=ikePropHashAlg, ipsecPeerLocalId=ipsecPeerLocalId, ipsecTrForceTunnelMode=ipsecTrForceTunnelMode, internet=internet, ipsecTrRemoteRange=ipsecTrRemoteRange, ipsecGlobDefaultPh1Mode=ipsecGlobDefaultPh1Mode, ikeProposalTable=ikeProposalTable, ipsecPropBoolOp=ipsecPropBoolOp, ipsecPubKeyIndex=ipsecPubKeyIndex, ipsecTrRemoteMaskLen=ipsecTrRemoteMaskLen, ipsecTrDescription=ipsecTrDescription, ikeSaRole=ikeSaRole, ipsecSaDecryptErrors=ipsecSaDecryptErrors, ipsecLifeTimeEntry=ipsecLifeTimeEntry, ipsecTrLocalAddress=ipsecTrLocalAddress, ipsecPropAuthAlg=ipsecPropAuthAlg, ipsecPropOutSpi=ipsecPropOutSpi, ipsecStatsTrig=ipsecStatsTrig, ipsecPropEncKeyIn=ipsecPropEncKeyIn, ipsecGlobNoInitialContact=ipsecGlobNoInitialContact, ipsecGlobDefaultPfsGroup=ipsecGlobDefaultPfsGroup, ipsecTrAction=ipsecTrAction, ipsecPropDescription=ipsecPropDescription, ipsecSaProto=ipsecSaProto, ipsecGlobIkePort=ipsecGlobIkePort, ipsecSaEntry=ipsecSaEntry, ipsecPeerEntry=ipsecPeerEntry, ipsecTrLocalMaskLen=ipsecTrLocalMaskLen, ipsecPubKeyEntry=ipsecPubKeyEntry, ipsecPeerIkeLifeTime=ipsecPeerIkeLifeTime, ipsecGlobAntiCloggingHash=ipsecGlobAntiCloggingHash, ipsecGlobNoCrPayloads=ipsecGlobNoCrPayloads, ikeSaEntry=ikeSaEntry)

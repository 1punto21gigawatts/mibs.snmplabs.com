#
# PySNMP MIB module CISCO-IETF-IP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IETF-IP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:21 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
InterfaceIndex, ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex", "InterfaceIndexOrZero")
InetAddressType, InetAddressPrefixLength, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddressPrefixLength", "InetAddress")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Unsigned32, ModuleIdentity, Counter64, Gauge32, iso, ObjectIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, Integer32, MibIdentifier, IpAddress, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ModuleIdentity", "Counter64", "Gauge32", "iso", "ObjectIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "Integer32", "MibIdentifier", "IpAddress", "Bits")
PhysAddress, TextualConvention, DisplayString, TruthValue, RowPointer, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString", "TruthValue", "RowPointer", "TimeStamp")
ciscoIetfIpMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 86))
ciscoIetfIpMIB.setRevisions(('2002-03-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoIetfIpMIB.setRevisionsDescriptions(('The initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoIetfIpMIB.setLastUpdated('200203040000Z')
if mibBuilder.loadTexts: ciscoIetfIpMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIetfIpMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Phone: +1 800 553-NETS Email: cs-ipv6@cisco.com')
if mibBuilder.loadTexts: ciscoIetfIpMIB.setDescription('The MIB module for managing IP and ICMP implementations, but excluding the management of IP routes.')
ciscoIetfIpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 1))
cIp = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1))
cIpv6 = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2))
cIcmp = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3))
class Ipv6AddrIfIdentifier(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 address interface identifiers. This is a binary string of up to 8 octets in network byte-order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 8)

class ScopeId(TextualConvention, Unsigned32):
    description = 'A Scope Identifier identifies an instance of a specific scope. The scope identifier MUST disambiguate identical address values. For link-local addresses, the scope identifier will typically be the interface index (ifIndex as defined in the IF-MIB) of the interface on which the address is configured. The scope identifier may contain the special value 0 which refers to the default scope. The default scope may be used in cases where the valid scope identifier is not known (e.g., a management application needs to write a site-local InetAddressIPv6 address without knowing the site identifier value). The default scope SHOULD NOT be used as an easy way out in cases where the scope identifier for a non-global IPv6 address is known.'
    status = 'current'

cIpv6Forwarding = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("notForwarding", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpv6Forwarding.setStatus('current')
if mibBuilder.loadTexts: cIpv6Forwarding.setDescription('The indication of whether this entity is acting as an IPv6 router in respect to the forwarding of datagrams received by, but not addressed to, this entity. IPv6 routers forward datagrams. IPv6 hosts do not (except those source-routed via the host).')
cIpv6DefaultHopLimit = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpv6DefaultHopLimit.setStatus('current')
if mibBuilder.loadTexts: cIpv6DefaultHopLimit.setDescription('The default value inserted into the Hop Limit field of the IPv6 header of datagrams originated at this entity, whenever a Hop Limit value is not supplied by the transport layer protocol.')
cIpv6InterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3), )
if mibBuilder.loadTexts: cIpv6InterfaceTable.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceTable.setDescription('The table containing per-interface IPv6-specific information.')
cIpv6InterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-IETF-IP-MIB", "cIpv6InterfaceIfIndex"))
if mibBuilder.loadTexts: cIpv6InterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceEntry.setDescription('An entry containing IPv6-specific information for a given interface.')
cIpv6InterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: cIpv6InterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceIfIndex.setDescription('The interface for which this row contains IPv6-specific information.')
cIpv6InterfaceEffectiveMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1, 2), Unsigned32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6InterfaceEffectiveMtu.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceEffectiveMtu.setDescription('The size of the largest IPv6 packet which can be sent/received on the interface, specified in octets.')
cIpv6InterfaceReasmMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6InterfaceReasmMaxSize.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceReasmMaxSize.setDescription('The size of the largest IPv6 datagram which this entity can re-assemble from incoming IPv6 fragmented datagrams received on this interface.')
cIpv6InterfaceIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1, 4), Ipv6AddrIfIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpv6InterfaceIdentifier.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceIdentifier.setDescription('The Interface Identifier for this interface that is (at least) unique on the link this interface is attached to. The Interface Identifier is combined with an address prefix to form an interface address. By default, the Interface Identifier is autoconfigured according to the rules of the link type this interface is attached to.')
cIpv6InterfaceIdentifierLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setUnits('bits').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpv6InterfaceIdentifierLength.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfaceIdentifierLength.setDescription('The length of the Interface Identifier in bits.')
cIpv6InterfacePhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 2, 3, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6InterfacePhysicalAddress.setStatus('current')
if mibBuilder.loadTexts: cIpv6InterfacePhysicalAddress.setDescription("The interface's physical address. For example, for an IPv6 interface attached to an 802.x link, this object normally contains a MAC address. Note that in some cases this address may differ from the address of the interface's protocol sub-layer. The interface's media-specific MIB must define the bit and byte ordering and the format of the value of this object. For interfaces which do not have such an address (e.g., a serial line), this object should contain an octet string of zero length.")
cIpAddressPfxTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1), )
if mibBuilder.loadTexts: cIpAddressPfxTable.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxTable.setDescription('Inet prefix table.')
cIpAddressPfxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-IETF-IP-MIB", "cIpAddressPfxIfIndex"), (0, "CISCO-IETF-IP-MIB", "cIpAddressPfxType"), (0, "CISCO-IETF-IP-MIB", "cIpAddressPfxPfx"), (0, "CISCO-IETF-IP-MIB", "cIpAddressPfxLength"))
if mibBuilder.loadTexts: cIpAddressPfxEntry.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxEntry.setDescription('Inet prefix entry.')
cIpAddressPfxIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: cIpAddressPfxIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxIfIndex.setDescription('The interface on which this prefix is configured.')
cIpAddressPfxType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 2), InetAddressType())
if mibBuilder.loadTexts: cIpAddressPfxType.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxType.setDescription('The address type of cIpAddressPfxPfx. Only IPv4 and IPv6 addresses are expected.')
cIpAddressPfxPfx = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 36)))
if mibBuilder.loadTexts: cIpAddressPfxPfx.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxPfx.setDescription('The address prefix. Bits after cIpAddressPfxLength must be zero.')
cIpAddressPfxLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 4), InetAddressPrefixLength())
if mibBuilder.loadTexts: cIpAddressPfxLength.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxLength.setDescription('The prefix length associated with this prefix.')
cIpAddressPfxOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("manual", 2), ("wellknown", 3), ("dhcp", 4), ("routeradv", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressPfxOrigin.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxOrigin.setDescription('The origin of this prefix. manual(2) indicates a prefix that was manually configured. wellknown(3) indicates a well-known prefix, e.g. 169.254/16 for IPv4 autoconfiguration or fe80::/10 for IPv6 link-local addresses. dhcp(4) indicates a prefix that was assigned by a DHCP server. routeradv(5) indicates a prefix learned from a router advertisement.')
cIpAddressPfxOnLinkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressPfxOnLinkFlag.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxOnLinkFlag.setDescription("This object has the value 'true(1)', if this prefix can be used for on-link determination and the value 'false(2)' otherwise.")
cIpAddressPfxAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressPfxAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxAutonomousFlag.setDescription('Autonomous address configuration flag. When true(1), indicates that this prefix can be used for autonomous address configuration (i.e. can be used to form a local interface address). If false(2), it is not used to autoconfigure a local interface address.')
cIpAddressPfxAdvPfdLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 8), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressPfxAdvPfdLifetime.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxAdvPfdLifetime.setDescription('The length of time in seconds that this prefix will remain preferred, i.e. time until deprecation. A value of 4,294,967,295 represents infinity. The address generated from a deprecated prefix should no longer be used as a source address in new communications, but packets received on such an interface are processed as expected.')
cIpAddressPfxAdvValidLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 1, 1, 9), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressPfxAdvValidLifetime.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPfxAdvValidLifetime.setDescription('The length of time in seconds that this prefix will remain valid, i.e. time until invalidation. A value of 4,294,967,295 represents infinity. The address generated from an invalidated prefix should not appear as the destination or source address of a packet.')
cIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2), )
if mibBuilder.loadTexts: cIpAddressTable.setStatus('current')
if mibBuilder.loadTexts: cIpAddressTable.setDescription('Inet address table.')
cIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-IETF-IP-MIB", "cIpAddressAddrType"), (0, "CISCO-IETF-IP-MIB", "cIpAddressAddr"))
if mibBuilder.loadTexts: cIpAddressEntry.setStatus('current')
if mibBuilder.loadTexts: cIpAddressEntry.setDescription('Inet addr entry.')
cIpAddressAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cIpAddressAddrType.setStatus('current')
if mibBuilder.loadTexts: cIpAddressAddrType.setDescription('The address type of cIpAddressAddr.')
cIpAddressAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 36)))
if mibBuilder.loadTexts: cIpAddressAddr.setStatus('current')
if mibBuilder.loadTexts: cIpAddressAddr.setDescription("The IP address to which this entry's addressing information pertains.")
cIpAddressIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpAddressIfIndex.setDescription("The index value which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value of the IF-MIB's ifIndex.")
cIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unicast", 1), ("anycast", 2), ("broadcast", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressType.setStatus('current')
if mibBuilder.loadTexts: cIpAddressType.setDescription('The type of address. broadcast(3) is not a valid value for IPv6 addresses.')
cIpAddressPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressPrefix.setStatus('current')
if mibBuilder.loadTexts: cIpAddressPrefix.setDescription('A pointer to the row in the prefix table to which this address belongs. May be { 0 0 } if there is no such row.')
cIpAddressOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("manual", 2), ("wellknown", 3), ("dhcp", 4), ("linklayer", 5), ("random", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressOrigin.setStatus('current')
if mibBuilder.loadTexts: cIpAddressOrigin.setDescription('The origin of the address. manual(2) indicates that the address was manually configured. wellknown(3) indicates an address constructed from a well-known value, e.g. an IANA-assigned anycast address. dhcp(4) indicates an address that was assigned to this system by a DHCP server. linklayer(5) indicates an address created by IPv6 stateless autoconfiguration. random(6) indicates an address chosen by random, e.g. an IPv4 address within 169.254/16, or an RFC 3041 privacy address.')
cIpAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("preferred", 1), ("deprecated", 2), ("invalid", 3), ("inaccessible", 4), ("unknown", 5), ("tentative", 6), ("duplicate", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpAddressStatus.setStatus('current')
if mibBuilder.loadTexts: cIpAddressStatus.setDescription('Address status. The preferred(1) state indicates that this is a valid address that can appear as the destination or source address of a packet. The deprecated(2) state indicates that this is a valid but deprecated address that should no longer be used as a source address in new communications, but packets addressed to such an address are processed as expected. The invalid(3) state indicates that this is not valid address which should not appear as the destination or source address of a packet. The inaccessible(4) state indicates that the address is not accessible because the interface to which this address is assigned is not operational. The tentative(6) state indicates the uniqueness of the address on the link is being verified. The duplicate(7) state indicates the address has been determined to be non-unique on the link and so must not be used. In the absence of other information, an IPv4 address is always preferred(1).')
cInetNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3), )
if mibBuilder.loadTexts: cInetNetToMediaTable.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaTable.setDescription("The IP Address Translation table used for mapping from IP addresses to physical addresses. The Address Translation tables contain the IP address to 'physical' address equivalences. Some interfaces do not use translation tables for determining address equivalences (e.g., DDN-X.25 has an algorithmic method); if all interfaces are of this type, then the Address Translation table is empty, i.e., has zero entries.")
cInetNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-IETF-IP-MIB", "cInetNetToMediaNetAddressType"), (0, "CISCO-IETF-IP-MIB", "cInetNetToMediaNetAddress"))
if mibBuilder.loadTexts: cInetNetToMediaEntry.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaEntry.setDescription("Each entry contains one IP address to `physical' address equivalence.")
cInetNetToMediaNetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cInetNetToMediaNetAddressType.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaNetAddressType.setDescription('The type of cInetNetToMediaNetAddress.')
cInetNetToMediaNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 36)))
if mibBuilder.loadTexts: cInetNetToMediaNetAddress.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaNetAddress.setDescription("The IP Address corresponding to the media-dependent `physical' address.")
cInetNetToMediaPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1, 3), PhysAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cInetNetToMediaPhysAddress.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaPhysAddress.setDescription("The media-dependent `physical' address.")
cInetNetToMediaLastUpdated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetNetToMediaLastUpdated.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaLastUpdated.setDescription('The value of sysUpTime at the time this entry was last updated. If this entry was updated prior to the last re- initialization of the local network management subsystem, then this object contains a zero value.')
cInetNetToMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4), ("local", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cInetNetToMediaType.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaType.setDescription("The type of mapping. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the cInetNetToMediaTable. That is, it effectively disassociates the interface identified with said entry from the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant cInetNetToMediaType object. The 'dynamic(3)' type indicates that the IP address to physical addresses mapping has been dynamically resolved using e.g. IPv4 ARP or the IPv6 Neighbor Discovery protocol. The 'static(4)' type indicates that the mapping has been statically configured. The 'local(5)' type indicates that the mapping is provided for an entity's own interface address.")
cInetNetToMediaState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("reachable", 1), ("stale", 2), ("delay", 3), ("probe", 4), ("invalid", 5), ("unknown", 6), ("incomplete", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetNetToMediaState.setReference('RFC2461')
if mibBuilder.loadTexts: cInetNetToMediaState.setStatus('current')
if mibBuilder.loadTexts: cInetNetToMediaState.setDescription('The Neighbor Unreachability Detection [3] state for the interface when the address mapping in this entry is used. If Neighbor Unreachability Detection is not in use (e.g. for IPv4), this object is always unknown(6).')
cIpv6ScopeIdTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4), )
if mibBuilder.loadTexts: cIpv6ScopeIdTable.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdTable.setDescription('The table used to describe IPv6 unicast and multicast scope zones.')
cIpv6ScopeIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-IETF-IP-MIB", "cIpv6ScopeIdIfIndex"))
if mibBuilder.loadTexts: cIpv6ScopeIdEntry.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdEntry.setDescription('Each entry contains the list of scope identifiers on a given interface.')
cIpv6ScopeIdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: cIpv6ScopeIdIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdIfIndex.setDescription('The interface to which these scopes belong.')
cIpv6ScopeIdLinkLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 2), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdLinkLocal.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdLinkLocal.setDescription('The Scope Identifier for the link-local scope on this interface.')
cIpv6ScopeIdSubnetLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 3), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdSubnetLocal.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdSubnetLocal.setDescription('The Scope Identifier for the subnet-local scope on this interface.')
cIpv6ScopeIdAdminLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 4), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdAdminLocal.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdAdminLocal.setDescription('The Scope Identifier for the admin-local scope on this interface.')
cIpv6ScopeIdSiteLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 5), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdSiteLocal.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdSiteLocal.setDescription('The Scope Identifier for the site-local scope on this interface.')
cIpv6ScopeId6 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 6), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeId6.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeId6.setDescription('The Scope Identifier for scope 6 on this interface.')
cIpv6ScopeId7 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 7), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeId7.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeId7.setDescription('The Scope Identifier for scope 7 on this interface.')
cIpv6ScopeIdOrganizationLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 8), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdOrganizationLocal.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdOrganizationLocal.setDescription('The Scope Identifier for the orgainzation-local scope on this interface.')
cIpv6ScopeId9 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 9), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeId9.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeId9.setDescription('The Scope Identifier for scope 9 on this interface.')
cIpv6ScopeIdA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 10), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdA.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdA.setDescription('The Scope Identifier for scope A on this interface.')
cIpv6ScopeIdB = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 11), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdB.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdB.setDescription('The Scope Identifier for scope B on this interface.')
cIpv6ScopeIdC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 12), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdC.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdC.setDescription('The Scope Identifier for scope C on this interface.')
cIpv6ScopeIdD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 1, 4, 1, 13), ScopeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpv6ScopeIdD.setStatus('current')
if mibBuilder.loadTexts: cIpv6ScopeIdD.setDescription('The Scope Identifier for scope D on this interface.')
cInetIcmpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1), )
if mibBuilder.loadTexts: cInetIcmpTable.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpTable.setDescription('The table of generic ICMP counters. These counters may be kept per-interface and/or system-wide.')
cInetIcmpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-IETF-IP-MIB", "cInetIcmpAFType"), (0, "CISCO-IETF-IP-MIB", "cInetIcmpIfIndex"))
if mibBuilder.loadTexts: cInetIcmpEntry.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpEntry.setDescription('A conceptual row in the inetIcmpTable. A row with an inetIcmpIfIndex value of zero indicates a system-wide value; a row with a non-zero inetIcmpIfIndex indicates an interface-specific value. A system may provide both system-wide and interface-specific values, in which case it is important to note that the system-wide value may not be equal to the sum of the interface-specific value across all interfaces due to e.g. dynamic interface creation/deletion.')
cInetIcmpAFType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cInetIcmpAFType.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpAFType.setDescription('The IP address family of the statistics.')
cInetIcmpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1, 2), InterfaceIndexOrZero())
if mibBuilder.loadTexts: cInetIcmpIfIndex.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpIfIndex.setDescription('The ifindex of the interface, or zero for system-wide stats.')
cInetIcmpInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetIcmpInMsgs.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpInMsgs.setDescription('The total number of ICMP messages which the entity received. Note that this counter includes all those counted by cInetIcmpInErrors.')
cInetIcmpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetIcmpInErrors.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpInErrors.setDescription('The number of ICMP messages which the entity received but determined as having ICMP-specific errors (bad ICMP checksums, bad length, etc.).')
cInetIcmpOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetIcmpOutMsgs.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpOutMsgs.setDescription('The total number of ICMP messages which the entity received. Note that this counter includes all those counted by inetIcmpOutErrors.')
cInetIcmpOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetIcmpOutErrors.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpOutErrors.setDescription("The number of ICMP messages which this entity did not send due to problems discovered within ICMP such as a lack of buffers. This value should not include errors discovered outside the ICMP layer such as the inability of IP to route the resultant datagram. In some implementations there may be no types of error which contribute to this counter's value.")
cInetIcmpMsgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2), )
if mibBuilder.loadTexts: cInetIcmpMsgTable.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgTable.setDescription('The table of per-message ICMP counters. These counters may be kept per-interface and/or system-wide.')
cInetIcmpMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-IETF-IP-MIB", "cInetIcmpMsgAFType"), (0, "CISCO-IETF-IP-MIB", "cInetIcmpMsgIfIndex"), (0, "CISCO-IETF-IP-MIB", "cInetIcmpMsgType"), (0, "CISCO-IETF-IP-MIB", "cInetIcmpMsgCode"))
if mibBuilder.loadTexts: cInetIcmpMsgEntry.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgEntry.setDescription("A conceptual row in the inetIcmpMsgTable. A row with an inetIcmpMsgIfIndex value of zero indicates a system-wide value; a row with a non-zero cInetIcmpMsgIfIndex indicates an interface-specific value. A system may provide both system-wide and interface-specific values, in which case it is important to note that the system-wide value may not be equal to the sum of the interface-specific values across all interfaces due to e.g. dynamic interface creation/deletion. If the system keeps track of individual ICMP code values (e.g. destination unreachable, code administratively prohibited), it creates several rows for each inetIcmpMsgType, each with an appropriate value of cInetIcmpMsgCode. A row with the special value of cInetIcmpMsgCode, 256, counts all packets with type cInetIcmpMsgType that aren't counted in rows with a value of cInetIcmpMsgCode other than 256.")
cInetIcmpMsgAFType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cInetIcmpMsgAFType.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgAFType.setDescription('The IP address family of the statistics.')
cInetIcmpMsgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1, 2), InterfaceIndexOrZero())
if mibBuilder.loadTexts: cInetIcmpMsgIfIndex.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgIfIndex.setDescription('The ifindex of the interface, or zero for system-wide stats.')
cInetIcmpMsgType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: cInetIcmpMsgType.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgType.setDescription('The ICMP type field of the message type being counted by this row.')
cInetIcmpMsgCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)))
if mibBuilder.loadTexts: cInetIcmpMsgCode.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgCode.setDescription('The ICMP code field of the message type being counted by this row, or the special value 256 if no specific ICMP code is counted by this row.')
cInetIcmpMsgInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetIcmpMsgInPkts.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgInPkts.setDescription('The number of input packets for this AF, ifindex, type, code.')
cInetIcmpMsgOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 86, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cInetIcmpMsgOutPkts.setStatus('current')
if mibBuilder.loadTexts: cInetIcmpMsgOutPkts.setDescription('The number of output packets for this AF, ifindex, type, code.')
ciscoIpMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 2))
ciscoIpMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 1))
ciscoIpMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2))
ciscoIpMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 1, 1)).setObjects(("CISCO-IETF-IP-MIB", "ciscoIpAddressPfxGroup"), ("CISCO-IETF-IP-MIB", "ciscoIpAddressGroup"), ("CISCO-IETF-IP-MIB", "ciscoInetNetToMediaGroup"), ("CISCO-IETF-IP-MIB", "ciscoInetIcmpGroup"), ("CISCO-IETF-IP-MIB", "ciscoInetIcmpMsgGroup"), ("CISCO-IETF-IP-MIB", "ciscoIpv6GeneralGroup"), ("CISCO-IETF-IP-MIB", "ciscoIpv6InterfaceGroup"), ("CISCO-IETF-IP-MIB", "ciscoIpv6ScopeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpMIBCompliance = ciscoIpMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoIpMIBCompliance.setDescription('The compliance statement for systems which implement IPv6 OR IPv4.')
ciscoIpAddressPfxGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 1)).setObjects(("CISCO-IETF-IP-MIB", "cIpAddressPfxOrigin"), ("CISCO-IETF-IP-MIB", "cIpAddressPfxOnLinkFlag"), ("CISCO-IETF-IP-MIB", "cIpAddressPfxAutonomousFlag"), ("CISCO-IETF-IP-MIB", "cIpAddressPfxAdvPfdLifetime"), ("CISCO-IETF-IP-MIB", "cIpAddressPfxAdvValidLifetime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpAddressPfxGroup = ciscoIpAddressPfxGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpAddressPfxGroup.setDescription('The ip version independent address prefix group of entries providing for basic management of IP prefixes.')
ciscoIpAddressGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 2)).setObjects(("CISCO-IETF-IP-MIB", "cIpAddressIfIndex"), ("CISCO-IETF-IP-MIB", "cIpAddressType"), ("CISCO-IETF-IP-MIB", "cIpAddressPrefix"), ("CISCO-IETF-IP-MIB", "cIpAddressOrigin"), ("CISCO-IETF-IP-MIB", "cIpAddressStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpAddressGroup = ciscoIpAddressGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpAddressGroup.setDescription('The ip version independent address group of entries providing for basic management of IP addresses.')
ciscoInetNetToMediaGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 3)).setObjects(("CISCO-IETF-IP-MIB", "cInetNetToMediaPhysAddress"), ("CISCO-IETF-IP-MIB", "cInetNetToMediaLastUpdated"), ("CISCO-IETF-IP-MIB", "cInetNetToMediaType"), ("CISCO-IETF-IP-MIB", "cInetNetToMediaState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoInetNetToMediaGroup = ciscoInetNetToMediaGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoInetNetToMediaGroup.setDescription('The group of entries providing IP address to physical address mapping.')
ciscoInetIcmpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 4)).setObjects(("CISCO-IETF-IP-MIB", "cInetIcmpInMsgs"), ("CISCO-IETF-IP-MIB", "cInetIcmpInErrors"), ("CISCO-IETF-IP-MIB", "cInetIcmpOutMsgs"), ("CISCO-IETF-IP-MIB", "cInetIcmpOutErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoInetIcmpGroup = ciscoInetIcmpGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoInetIcmpGroup.setDescription('The group of entries providing version independent per-interface ICMP specific counters.')
ciscoInetIcmpMsgGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 5)).setObjects(("CISCO-IETF-IP-MIB", "cInetIcmpMsgInPkts"), ("CISCO-IETF-IP-MIB", "cInetIcmpMsgOutPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoInetIcmpMsgGroup = ciscoInetIcmpMsgGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoInetIcmpMsgGroup.setDescription('The group of entries providing version independent per-interface ICMP msg type specific counters.')
ciscoIpv6GeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 6)).setObjects(("CISCO-IETF-IP-MIB", "cIpv6Forwarding"), ("CISCO-IETF-IP-MIB", "cIpv6DefaultHopLimit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpv6GeneralGroup = ciscoIpv6GeneralGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpv6GeneralGroup.setDescription('The IPv6 group of objects providing for basic management of IPv6 entities.')
ciscoIpv6InterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 7)).setObjects(("CISCO-IETF-IP-MIB", "cIpv6InterfaceEffectiveMtu"), ("CISCO-IETF-IP-MIB", "cIpv6InterfaceReasmMaxSize"), ("CISCO-IETF-IP-MIB", "cIpv6InterfaceIdentifier"), ("CISCO-IETF-IP-MIB", "cIpv6InterfaceIdentifierLength"), ("CISCO-IETF-IP-MIB", "cIpv6InterfacePhysicalAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpv6InterfaceGroup = ciscoIpv6InterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpv6InterfaceGroup.setDescription('The IPv6 group of objects providing IPv6 interface specific statistics.')
ciscoIpv6ScopeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 86, 2, 2, 8)).setObjects(("CISCO-IETF-IP-MIB", "cIpv6ScopeIdLinkLocal"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdSubnetLocal"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdAdminLocal"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdSiteLocal"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeId6"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeId7"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdOrganizationLocal"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeId9"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdA"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdB"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdC"), ("CISCO-IETF-IP-MIB", "cIpv6ScopeIdD"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpv6ScopeGroup = ciscoIpv6ScopeGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpv6ScopeGroup.setDescription('The group of objects for managing IPv6 scope zones.')
mibBuilder.exportSymbols("CISCO-IETF-IP-MIB", cIpAddressPfxTable=cIpAddressPfxTable, cInetIcmpMsgIfIndex=cInetIcmpMsgIfIndex, cIpAddressPfxPfx=cIpAddressPfxPfx, cIpAddressPfxAdvPfdLifetime=cIpAddressPfxAdvPfdLifetime, cIpv6InterfaceEffectiveMtu=cIpv6InterfaceEffectiveMtu, cIpv6InterfaceIdentifier=cIpv6InterfaceIdentifier, cIpv6=cIpv6, cIpAddressPfxOnLinkFlag=cIpAddressPfxOnLinkFlag, cInetIcmpMsgAFType=cInetIcmpMsgAFType, cIpv6ScopeIdEntry=cIpv6ScopeIdEntry, cInetNetToMediaLastUpdated=cInetNetToMediaLastUpdated, cIpv6Forwarding=cIpv6Forwarding, ciscoInetNetToMediaGroup=ciscoInetNetToMediaGroup, cInetIcmpOutErrors=cInetIcmpOutErrors, PYSNMP_MODULE_ID=ciscoIetfIpMIB, cInetIcmpTable=cInetIcmpTable, cIpv6ScopeIdSiteLocal=cIpv6ScopeIdSiteLocal, ciscoIpv6GeneralGroup=ciscoIpv6GeneralGroup, cIpAddressStatus=cIpAddressStatus, ciscoIpMIBCompliance=ciscoIpMIBCompliance, cIcmp=cIcmp, ciscoIpMIBConformance=ciscoIpMIBConformance, cIpv6ScopeIdB=cIpv6ScopeIdB, ciscoIpAddressGroup=ciscoIpAddressGroup, cInetIcmpMsgTable=cInetIcmpMsgTable, cIpv6ScopeId9=cIpv6ScopeId9, cIpv6ScopeId6=cIpv6ScopeId6, ciscoInetIcmpGroup=ciscoInetIcmpGroup, cIpv6InterfaceIdentifierLength=cIpv6InterfaceIdentifierLength, cIpAddressTable=cIpAddressTable, cInetIcmpInMsgs=cInetIcmpInMsgs, cIpAddressPfxLength=cIpAddressPfxLength, cIpv6InterfacePhysicalAddress=cIpv6InterfacePhysicalAddress, cIpAddressPfxEntry=cIpAddressPfxEntry, cIpAddressPfxOrigin=cIpAddressPfxOrigin, cIpAddressPfxAdvValidLifetime=cIpAddressPfxAdvValidLifetime, cInetNetToMediaNetAddressType=cInetNetToMediaNetAddressType, cInetIcmpMsgOutPkts=cInetIcmpMsgOutPkts, ciscoIpv6ScopeGroup=ciscoIpv6ScopeGroup, cInetIcmpAFType=cInetIcmpAFType, cInetNetToMediaNetAddress=cInetNetToMediaNetAddress, cIpv6ScopeIdLinkLocal=cIpv6ScopeIdLinkLocal, cIp=cIp, ciscoIetfIpMIB=ciscoIetfIpMIB, ScopeId=ScopeId, cIpAddressOrigin=cIpAddressOrigin, cIpv6InterfaceTable=cIpv6InterfaceTable, Ipv6AddrIfIdentifier=Ipv6AddrIfIdentifier, cIpv6ScopeIdIfIndex=cIpv6ScopeIdIfIndex, cIpAddressAddr=cIpAddressAddr, ciscoInetIcmpMsgGroup=ciscoInetIcmpMsgGroup, cIpv6ScopeId7=cIpv6ScopeId7, cIpv6InterfaceIfIndex=cIpv6InterfaceIfIndex, cInetIcmpMsgInPkts=cInetIcmpMsgInPkts, cInetIcmpMsgCode=cInetIcmpMsgCode, cInetIcmpOutMsgs=cInetIcmpOutMsgs, ciscoIpAddressPfxGroup=ciscoIpAddressPfxGroup, cIpv6InterfaceReasmMaxSize=cIpv6InterfaceReasmMaxSize, cIpAddressPfxIfIndex=cIpAddressPfxIfIndex, cIpv6DefaultHopLimit=cIpv6DefaultHopLimit, cIpv6InterfaceEntry=cIpv6InterfaceEntry, ciscoIpMIBCompliances=ciscoIpMIBCompliances, cInetIcmpIfIndex=cInetIcmpIfIndex, cIpAddressIfIndex=cIpAddressIfIndex, cIpAddressPfxAutonomousFlag=cIpAddressPfxAutonomousFlag, cIpAddressPfxType=cIpAddressPfxType, cInetIcmpMsgType=cInetIcmpMsgType, ciscoIetfIpMIBObjects=ciscoIetfIpMIBObjects, cInetNetToMediaEntry=cInetNetToMediaEntry, cInetNetToMediaState=cInetNetToMediaState, cIpAddressPrefix=cIpAddressPrefix, cIpv6ScopeIdSubnetLocal=cIpv6ScopeIdSubnetLocal, cIpAddressAddrType=cIpAddressAddrType, cInetNetToMediaPhysAddress=cInetNetToMediaPhysAddress, cIpv6ScopeIdAdminLocal=cIpv6ScopeIdAdminLocal, ciscoIpMIBGroups=ciscoIpMIBGroups, cIpv6ScopeIdA=cIpv6ScopeIdA, cIpAddressType=cIpAddressType, cInetNetToMediaType=cInetNetToMediaType, ciscoIpv6InterfaceGroup=ciscoIpv6InterfaceGroup, cInetNetToMediaTable=cInetNetToMediaTable, cInetIcmpInErrors=cInetIcmpInErrors, cIpv6ScopeIdTable=cIpv6ScopeIdTable, cInetIcmpMsgEntry=cInetIcmpMsgEntry, cIpAddressEntry=cIpAddressEntry, cIpv6ScopeIdOrganizationLocal=cIpv6ScopeIdOrganizationLocal, cInetIcmpEntry=cInetIcmpEntry, cIpv6ScopeIdC=cIpv6ScopeIdC, cIpv6ScopeIdD=cIpv6ScopeIdD)

#
# PySNMP MIB module IBM-ENETDISPATCHER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-ENETDISPATCHER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:50:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Unsigned32, NotificationType, MibIdentifier, TimeTicks, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter64, ModuleIdentity, Gauge32, ObjectIdentity, Integer32, Bits, Counter32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Unsigned32", "NotificationType", "MibIdentifier", "TimeTicks", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter64", "ModuleIdentity", "Gauge32", "ObjectIdentity", "Integer32", "Bits", "Counter32", "iso")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
dispatcherMib = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1))
dispatcherMibTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 0))
dispatcherMibAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 1))
dispatcherMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2))
dispatcherMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3))
indStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1))
indConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2))
indExecStatObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1))
indHiAvailStatObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 6))
indExecCnfgObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 1))
indClstrCnfgTable = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 2))
indPortCnfgTable = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 3))
indSrvrCnfgTable = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 4))
indHiAvailCnfgObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 6))
indReachCnfgTable = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 7))
indMngrCnfgObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10))
indMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 1))
indMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2))
indMibStatGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1))
indMibCnfgGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 2))
class Percentages(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 100)

class GaugeNeg1(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-1, 2147483647)

esNonForAddr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esNonForAddr.setStatus('mandatory')
if mibBuilder.loadTexts: esNonForAddr.setDescription('Non forwarding address, any packet sent to this address will be handled by the Network Dispatcher machine itself and will not be forwarded')
esVersion = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esVersion.setStatus('mandatory')
if mibBuilder.loadTexts: esVersion.setDescription('The version of the executor')
esNumClust = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esNumClust.setStatus('mandatory')
if mibBuilder.loadTexts: esNumClust.setDescription('Current number of clusters')
esTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esTotalPkts.setDescription('Total number of packets received by the executor since it started.')
esTooShortPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esTooShortPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esTooShortPkts.setDescription('Total number of packets discarded by the executor, since the executor started, because the packet headers were too short.')
esNonForPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esNonForPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esNonForPkts.setDescription('Total number of packets sent to the non forwarding address since the executor started.')
esClstrDscrdPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esClstrDscrdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esClstrDscrdPkts.setDescription('Total number of packets discarded by the executor since the executor started, which were forwarded to a cluster, but were discarded because either: -the port did not exist, or -the port existed but had no servers')
esClstrErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esClstrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esClstrErrPkts.setDescription('Total number of packets not sent, since the executor started, because of a network adapter failure')
esClstrLocalPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esClstrLocalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esClstrLocalPkts.setDescription('Total number of packets since the executor started, not for the non forwarding address, or any cluster, but to be processed locally, by the Network Dispatcher machine')
esClstrOwnAddrPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esClstrOwnAddrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esClstrOwnAddrPkts.setDescription('Total number of packets since the executor started, explicitly forwarded to a server located on the Network Dispatcher machine')
esClstrForPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esClstrForPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esClstrForPkts.setDescription('Total number of packets since the executor started, forwarded to any cluster')
esForErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esForErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esForErrPkts.setDescription('Total number of packets with forwarding errors since the executor started. The following are the scenarios which affect this counter: -There was an error extracting an encapsulated packet which came in from a wide area Network Dispatcher -An attempt to forward the packet to either a local or remote server failed.')
esNotClstrPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esNotClstrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: esNotClstrPkts.setDescription('Total number of packets not addressed to any active cluster and port, since the executor started')
esHashBkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esHashBkts.setStatus('mandatory')
if mibBuilder.loadTexts: esHashBkts.setDescription('Current number of occupied hash buckets. Hash buckets correspond to IP address/port pairs. If this number is very low, it may indicate that the servers are getting many hits from a small number of clients. This number gives an indication of the client pool diversity.')
esStartTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: esStartTime.setDescription('The time when the executor was started, in seconds from January 1, 1970')
indClstrStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2), )
if mibBuilder.loadTexts: indClstrStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: indClstrStatTable.setDescription('A list of cluster table entries. The number of entries should equal the current number of clusters, esNumClust. The cluster table has a row for each cluster, Each row has information about the current status of that cluster.')
indClstrStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "csAddr"))
if mibBuilder.loadTexts: indClstrStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indClstrStatEntry.setDescription('A cluster table entry describing current status of the cluster. The cluster table has a row for each cluster. Rows in this table can not be created or deleted via SNMP commands')
csAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: csAddr.setStatus('mandatory')
if mibBuilder.loadTexts: csAddr.setDescription('The cluster address in dotted decimal format')
csNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: csNumPorts.setDescription('The current number of ports for this cluster')
csActiveSYNs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csActiveSYNs.setStatus('mandatory')
if mibBuilder.loadTexts: csActiveSYNs.setDescription('TH_SYNs on active connection. This variable indicates the number of requests for new connections, where those new connections are the same as current active connections, those not in FIN state. A high rate of growth in this variable could indicate slow or no response from servers in this cluster.')
csDroppedFINs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csDroppedFINs.setStatus('mandatory')
if mibBuilder.loadTexts: csDroppedFINs.setDescription('FINs dropped due to no connection. Rapid increase in this variable could indicate that the staletimeout is too low. Any percentage greater than 1% of total packets forwarded could indicate a problem.')
csDroppedACKs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csDroppedACKs.setStatus('mandatory')
if mibBuilder.loadTexts: csDroppedACKs.setDescription('ACKSs dropped due to no connection. Rapid increase in this variable could indicate that the staletimeout is too low. Any percentage greater than 1% of total packets forwarded could indicate a problem.')
csDroppedRSTs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csDroppedRSTs.setStatus('mandatory')
if mibBuilder.loadTexts: csDroppedRSTs.setDescription('RSTs dropped due to no connection. Rapid increase in this variable could indicate that the staletimeout is too low. Any percentage greater than 1% of total packets forwarded could indicate a problem.')
csDroppedPKTs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csDroppedPKTs.setStatus('mandatory')
if mibBuilder.loadTexts: csDroppedPKTs.setDescription('PKTSs dropped due to no connection. Rapid increase in this variable could indicate that the staletimeout is too low. Any percentage greater than 1% of total packets forwarded could indicate a problem.')
csNonExistingPKTs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csNonExistingPKTs.setStatus('deprecated')
if mibBuilder.loadTexts: csNonExistingPKTs.setDescription('This variable has no meaning and is deprecated')
indPortStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 3), )
if mibBuilder.loadTexts: indPortStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: indPortStatTable.setDescription('A list of port table entries. The number of entries equals the sum of the number of ports for each cluster. Each row in the table provides current status information for a port.')
indPortStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 3, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "csAddr"), (0, "IBM-ENETDISPATCHER-MIB", "psNum"))
if mibBuilder.loadTexts: indPortStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indPortStatEntry.setDescription('A port entry describing current status of the port. The port table has an entry for each cluster, port combination. Rows in this table can not be created or deleted via SNMP commands')
psNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: psNum.setStatus('mandatory')
if mibBuilder.loadTexts: psNum.setDescription('Number of this port')
psNumServers = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psNumServers.setStatus('mandatory')
if mibBuilder.loadTexts: psNumServers.setDescription('Current number of servers on this port')
psNumNodesDown = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psNumNodesDown.setStatus('mandatory')
if mibBuilder.loadTexts: psNumNodesDown.setDescription('Number of down servers')
indSrvrStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4), )
if mibBuilder.loadTexts: indSrvrStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: indSrvrStatTable.setDescription('A list of server table entries. The number of entries equals the sum of the number of servers for each port. Each server table entry provides current status information about the port.')
indSrvrStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "csAddr"), (0, "IBM-ENETDISPATCHER-MIB", "psNum"), (0, "IBM-ENETDISPATCHER-MIB", "ssAddr"))
if mibBuilder.loadTexts: indSrvrStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indSrvrStatEntry.setDescription('A server entry describing current status of the server. There is a row in the server table for each cluster, port, server combination. Rows in this table can not be created or deleted via SNMP commands')
ssAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 1), IpAddress())
if mibBuilder.loadTexts: ssAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ssAddr.setDescription('Server address in dotted decimal notation')
ssActiveConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssActiveConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssActiveConns.setDescription('Current active connections for this server')
ssNewConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssNewConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssNewConns.setDescription('Change in the number of total connections over the last interval.')
ssTotalConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssTotalConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssTotalConns.setDescription('Total connections for this server, since the server was added to the currently running executor')
ssTotalTcpConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssTotalTcpConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssTotalTcpConns.setDescription('Total TCP connections for this server, since the server was added to the currently running executor. ssTotalTcpConns plus ssTotalUdpConns equals ssTotalConns.')
ssTotalUdpConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssTotalUdpConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssTotalUdpConns.setDescription('Total UDP connections for this server, since the server was added to the currently running executor. ssTotalTcpConns plus ssTotalUdpConns equals ssTotalConns.')
ssFinConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssFinConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssFinConns.setDescription('Current number of connections in FIN state')
ssCompleteConns = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssCompleteConns.setStatus('mandatory')
if mibBuilder.loadTexts: ssCompleteConns.setDescription('Total number of completed connections for this server, since the server was added to the currently running executor.')
ssWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 9), GaugeNeg1()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssWeight.setStatus('mandatory')
if mibBuilder.loadTexts: ssWeight.setDescription('Current weight for this server. When the weight is zero the executor will no longer forward packets to this server. A weight of -1 indicates that the Network Dispatcher administrator has explicitly marked the server down.')
ssSavedWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 10), GaugeNeg1()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSavedWeight.setStatus('mandatory')
if mibBuilder.loadTexts: ssSavedWeight.setDescription('Weight the server had when marked down. This weight will be restored when the server is marked up.')
ssPortLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 11), GaugeNeg1()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssPortLoad.setStatus('mandatory')
if mibBuilder.loadTexts: ssPortLoad.setDescription('Number of milliseconds an advisor took to complete a protocol specific request to the server. If the value is -1, the advisor could not complete the request to the server.')
ssSystemLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSystemLoad.setStatus('mandatory')
if mibBuilder.loadTexts: ssSystemLoad.setDescription('This value is the number that the ISS agent provides to the ISS monitor for this server. The variable is only valid if ISS is monitoring an ISS agent on this server. Otherwise, the value has no meaning.')
ssActiveConnsWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssActiveConnsWeight.setStatus('mandatory')
if mibBuilder.loadTexts: ssActiveConnsWeight.setDescription('The weight calculated by the manager for the active connections measurement')
ssNewConnsWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssNewConnsWeight.setStatus('mandatory')
if mibBuilder.loadTexts: ssNewConnsWeight.setDescription('The weight calculated by the manager for the new connections measurement')
ssPortLoadWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssPortLoadWeight.setStatus('mandatory')
if mibBuilder.loadTexts: ssPortLoadWeight.setDescription('The weight calculated by the manager for the port load measurement')
ssSystemLoadWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 4, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ssSystemLoadWeight.setStatus('mandatory')
if mibBuilder.loadTexts: ssSystemLoadWeight.setDescription('The weight calculated by the manager for the system load measurement')
indRulesStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 5), )
if mibBuilder.loadTexts: indRulesStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: indRulesStatTable.setDescription('A list of rule table entries. There is no limit on the number of rules. The number of entries is the same as the number of entries in the indRulesCnfgTable. Each status entry provides current status information about the rule.')
indRulesStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 5, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "csAddr"), (0, "IBM-ENETDISPATCHER-MIB", "psNum"), (0, "IBM-ENETDISPATCHER-MIB", "rcIndex"))
if mibBuilder.loadTexts: indRulesStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indRulesStatEntry.setDescription('A rule table entry describing the current status of a rule. There is a one to one correspondence between rows of this table and rows in the IndRulesCnfgTable. Rows in this table can not be created or deleted via SNMP commands')
rsTimesFired = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTimesFired.setStatus('mandatory')
if mibBuilder.loadTexts: rsTimesFired.setDescription('The total number of times this rule has fired')
rsNumSrvrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsNumSrvrs.setStatus('mandatory')
if mibBuilder.loadTexts: rsNumSrvrs.setDescription('The number of servers which this rule services.')
hasPrimary = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("backup", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hasPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: hasPrimary.setDescription('Indicates whether this machine is the primary or backup machine. -primary (0) -backup (1)')
hasPort = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hasPort.setStatus('mandatory')
if mibBuilder.loadTexts: hasPort.setDescription('Port used by both primary and backup Network Dispatcher machines for heartbeat messages.')
hasState = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 0), ("listen", 1), ("active", 2), ("standby", 3), ("preempt", 4), ("elect", 5), ("noExec", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hasState.setStatus('mandatory')
if mibBuilder.loadTexts: hasState.setDescription('Status of this Network Dispatcher machine. -idle, (0) this machine is routing packets and is not trying to establish contact with its partner Network Dispatcher -listen, (1) high availability has just started and network dispatcher is listening for partner, -active, (2) this machine is routing packets. -standby,(3) this machine is monitoring the active machine. -preempt,(4) transitory state during switch from primary to backup -elect, (5) network dispatcher is negotiating with partner for who will primary or backup -no_exec,(6) the executor is not running')
hasSubState = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notSynchronized", 0), ("synchronized", 1), ("syncIn", 2), ("syncOut", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hasSubState.setStatus('mandatory')
if mibBuilder.loadTexts: hasSubState.setDescription('High Availability sub state: Synchronized and notSynchronized are normal, synchIn and synchOut are transitory. If the Network Dispatcher machine appears to be stuck (for more than a minute), in a transitory state then that indicates a problem. If HighAvailability should be running and the substate is notSynchronized, then that indicates a problem. If High Availability is not running and the hasState is idle, then all subState data is meaningless and should be ignored. notSynchronized (0), network dispatcher is not in conact with partner machine synchronized (1), network dispatcher is in contact with partner machine sync-in (2), network dispatcher is going into standby state sync-out (3), network dispatcher is going into active state')
indReachStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 7), )
if mibBuilder.loadTexts: indReachStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: indReachStatTable.setDescription('A list of reach table entries. The number of entries is typically less than 10, with a maximum of 32.')
indReachStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 7, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "rsAddr"))
if mibBuilder.loadTexts: indReachStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indReachStatEntry.setDescription('A reach table entry includes the address being pinged, and whether the ping of that address was successful. Rows in this table can not be created or deleted via SNMP commands')
rsAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 7, 1, 1), IpAddress())
if mibBuilder.loadTexts: rsAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsAddr.setDescription('The address the reach advisor pings.')
rsPingAble = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("reachable", 1), ("unreachable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPingAble.setStatus('mandatory')
if mibBuilder.loadTexts: rsPingAble.setDescription('Whether this reach address (rsAddr) responded to a ping. unknown (0), the rsAddr is unknown, possibly because the reach advisor is not started. reachable (1), the rsAddr was pinged successfully unreachable (2) the rsAddr was not pinged successfully')
indRulesCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5), )
if mibBuilder.loadTexts: indRulesCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: indRulesCnfgTable.setDescription('A list of rule config table entries There is no limit to the number of rule entries. Each rule table row describes rule configuration information.')
indRulesCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "csAddr"), (0, "IBM-ENETDISPATCHER-MIB", "psNum"), (0, "IBM-ENETDISPATCHER-MIB", "rcIndex"))
if mibBuilder.loadTexts: indRulesCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indRulesCnfgEntry.setDescription('A rule config table entry has information about the current configuration of the rule. Rows in this table can not be created or destroyed via SNMP commands.')
rcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rcIndex.setDescription('A unique number assigned to each rule in a cluster, port combination')
rcName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcName.setStatus('mandatory')
if mibBuilder.loadTexts: rcName.setDescription('The user defined name of the rule. Rule names are not necessarily unique.')
rcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("true", 0), ("ip", 1), ("port", 2), ("time", 3), ("connection", 4), ("active", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcType.setStatus('mandatory')
if mibBuilder.loadTexts: rcType.setDescription('The type of rule true (0), rules of this type are always true ip (1), the rule is based on the client IP address port (2), the rule is based on the client port time (3), the rule is based on the time of day connection (4), the rule is based on the number of connections per second for the port active (5) the rule is based on the number total active connections for the port')
rcBeginRange = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcBeginRange.setStatus('mandatory')
if mibBuilder.loadTexts: rcBeginRange.setDescription('The lower value in the range used to determine if the rule is true or not. The data is meaningless for rule type 0.')
rcEndRange = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcEndRange.setStatus('mandatory')
if mibBuilder.loadTexts: rcEndRange.setDescription('The higher value in the range used to determine if the rule is true or not. The data is meaningless for rule type 0.')
rcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rcPriority.setDescription('The rule priority. Lower numbers are a higher priority. Rule priority determines the order in which rules are evaluated.')
rcSrvrList = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 5, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcSrvrList.setStatus('mandatory')
if mibBuilder.loadTexts: rcSrvrList.setDescription('The list of servers this rule services. The server addresses are represented as strings in dotted decimal notation, separated by plus signs. For example, 37.44.24.13+12.23.54.76+9.67.127.82')
indHrtBeatCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 8), )
if mibBuilder.loadTexts: indHrtBeatCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: indHrtBeatCnfgTable.setDescription('A list of heartBeat Table entries. The number of entries is usually less than the number of interface cards in the Network Dispatcher machine. The maximum is 32. The heart beat table lists each of the monitoring and responding heartbeat pairs.')
indHrtBeatCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 8, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "hbcSrcAddr"), (0, "IBM-ENETDISPATCHER-MIB", "hbcDestAddr"))
if mibBuilder.loadTexts: indHrtBeatCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indHrtBeatCnfgEntry.setDescription('A indHrtBeatCnfg entry describing the monitoring and responding addresses. Each heart beat source address and heart beat destination address pair is unique. Rows in this table can not be created or deleted via SNMP commands')
hbcSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 8, 1, 1), IpAddress())
if mibBuilder.loadTexts: hbcSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hbcSrcAddr.setDescription('Address from which Network Dispatcher machine issues heartbeat monitoring to its partner')
hbcDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 8, 1, 2), IpAddress())
if mibBuilder.loadTexts: hbcDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hbcDestAddr.setDescription("Address of Network Dispatcher machine who's status is being monitored.")
hbcNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hbcNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hbcNumber.setDescription('An integer number assigned to the heart beat pair.')
indAdvsrCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 9), )
if mibBuilder.loadTexts: indAdvsrCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: indAdvsrCnfgTable.setDescription('A list of advisor config table entries. The number of entries equals the number of ports times the number of advisors. Each advisor table row describes the current status of the advisor, port combination.')
indAdvsrCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 9, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "acPort"))
if mibBuilder.loadTexts: indAdvsrCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indAdvsrCnfgEntry.setDescription('An advisor entry describing current configuration of the Advisor. There is an advisor table entry for each advisor, port combination. Rows in this table can not be created or deleted via SNMP commands')
acPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: acPort.setStatus('mandatory')
if mibBuilder.loadTexts: acPort.setDescription('Number of the port that the advisor is monitoring')
acName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 9, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acName.setStatus('mandatory')
if mibBuilder.loadTexts: acName.setDescription('Name of the advisor. Some of the possible values are: FTP, HTTP, NNTP, POP3, SMTP, SSL, Telnet. and custom advisor names.')
acVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 9, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acVersion.setStatus('mandatory')
if mibBuilder.loadTexts: acVersion.setDescription('Current version of the advisor')
mcInterval = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mcInterval.setDescription('How often the manager will update server weights, in seconds.')
mcRefresh = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcRefresh.setStatus('mandatory')
if mibBuilder.loadTexts: mcRefresh.setDescription('Number of manager intervals (mcInterval) before querying the executor for a refresh of information about new and active connections')
mcActiveProp = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 3), Percentages()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcActiveProp.setStatus('mandatory')
if mibBuilder.loadTexts: mcActiveProp.setDescription('Number from 0 to 100 representing the relative importance of active connections. This number is used by the manager, in calculating server weights. The sum of mcActiveProp, mcNewProp, mcPortProp, and mcSystemProp, must be 100')
mcNewProp = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 4), Percentages()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcNewProp.setStatus('mandatory')
if mibBuilder.loadTexts: mcNewProp.setDescription('Number from 0 to 100 representing the relative importance of new connections. This number is used by the manager, in calculating server weights. The sum of mcActiveProp, mcNewProp, mcPortProp, and mcSystemProp, must be 100')
mcPortProp = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 5), Percentages()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcPortProp.setStatus('mandatory')
if mibBuilder.loadTexts: mcPortProp.setDescription('Number from 0 to 100 representing the relative importance of port advisor information. This number is used by the manager, in calculating server weights. The sum of mcActiveProp, mcNewProp, mcPortProp, and mcSystemProp, must be 100')
mcSystemProp = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 6), Percentages()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcSystemProp.setStatus('mandatory')
if mibBuilder.loadTexts: mcSystemProp.setDescription('Number from 0 to 100 representing the relative importance of the information from system metrics, such as ISS. This number is used by the manager, in calculating server weights. The sum of mcActiveProp, mcNewProp, mcPortProp, and mcSystemProp, must be 100')
mcSensitivity = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 7), Percentages()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: mcSensitivity.setDescription('Minimum sensitivity to weight updates. This setting defines when the manager should change its weighting for the server based on external information')
mcSmoothing = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 8), Percentages()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcSmoothing.setStatus('mandatory')
if mibBuilder.loadTexts: mcSmoothing.setDescription('Index that smoothes the variations in weight when load balancing. Smoothing can reduce the changes in weights from interval to interval. The higher the smoothing value the less the weight will change from interval to interval. 1.5 is a typical value. 4, for example, is a high smoothhing value and would reduce the change in weight from interval to interval to almost nothing. The value is a percentage. For example a value of 155 should be treated as 1.55 by managing applications.')
mcVersion = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 10, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mcVersion.setDescription('The version of the manager')
indAllSrvrsCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 11), )
if mibBuilder.loadTexts: indAllSrvrsCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: indAllSrvrsCnfgTable.setDescription('A list of all servers table entries. The number of entries equals the number of different servers configured.')
indAllSrvrsCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 11, 1), ).setIndexNames((0, "IBM-ENETDISPATCHER-MIB", "ascAddr"))
if mibBuilder.loadTexts: indAllSrvrsCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: indAllSrvrsCnfgEntry.setDescription('An all servers table entry describing operational aspects of servers. This table is a list of all the servers currently configured in Network Dispatcher. Rows in this table can not be created or deleted via SNMP')
ascAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 11, 1, 1), IpAddress())
if mibBuilder.loadTexts: ascAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ascAddr.setDescription('The IP Address of the server in dotted decimal format')
ascQuiesced = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 11, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascQuiesced.setStatus('mandatory')
if mibBuilder.loadTexts: ascQuiesced.setDescription('True if this server has been quiesced, false otherwise. When a server is quiesced, no more connections are sent to the server. A server can be quiesced via the ndcontrol manager quiesce command. True=1, False=2.')
ascInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 2, 2, 11, 1, 3), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ascInstances.setDescription('The current number of times this server, ascAddr, is in the configuration.')
indHighAvailStatus = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 144, 1) + (0,1)).setObjects(("IBM-ENETDISPATCHER-MIB", "hasState"))
if mibBuilder.loadTexts: indHighAvailStatus.setDescription('This trap announces that the value of the high availability status state (hasState) variable has changed. The possible values of hasState and their respective meanings are: -idle, (0) this machine is routing packets and is not trying to establish contact with its partner Network Dispatcher -listen, (1) high availability has just started and network dispatcher is listening for partner, -active, (2) this machine is routing packets. -standby,(3) this machine is monitoring the active machine. -preempt,(4) transitory state during switch from primary to backup -elect, (5) network dispatcher is negotiating with partner for who will primary or backup -no_exec,(6) the executor is not running')
indSrvrGoneDown = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 144, 1) + (0,2)).setObjects(("IBM-ENETDISPATCHER-MIB", "ssActiveConns"))
if mibBuilder.loadTexts: indSrvrGoneDown.setDescription('This trap announces that the weight for the server specified by the csAddr, psNum, ssAddr portion of the Object Identifier has gone to zero, The last known number of active connections for the server is sent in the trap. This trap indicates that, as far as Network Dispatcher can determine, the specified server has gone down.')
indMibExecStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 1))
indMibClstrStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 2))
indMibPortStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 3))
indMibSrvrStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 4))
indMibRulesStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 5))
indMibHiAvailStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 6))
indMibReachStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 1, 7))
indMibRulesCnfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 2, 5))
indMibHrtBeatCnfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 2, 8))
indMibAdvsrCnfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 2, 9))
indMibMngrCnfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 2, 10))
indMibAllSrvrsCnfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 2, 2, 11))
indMibCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 144, 1, 3, 1, 1))
mibBuilder.exportSymbols("IBM-ENETDISPATCHER-MIB", ssSystemLoadWeight=ssSystemLoadWeight, indRulesStatEntry=indRulesStatEntry, dispatcherMibAdmin=dispatcherMibAdmin, csDroppedRSTs=csDroppedRSTs, ssPortLoad=ssPortLoad, mcNewProp=mcNewProp, dispatcherMibConformance=dispatcherMibConformance, dispatcherMibObjects=dispatcherMibObjects, esClstrLocalPkts=esClstrLocalPkts, indMibPortStatGroup=indMibPortStatGroup, indMibCnfgGroups=indMibCnfgGroups, esClstrDscrdPkts=esClstrDscrdPkts, hbcNumber=hbcNumber, ssTotalTcpConns=ssTotalTcpConns, csAddr=csAddr, indMibRulesStatGroup=indMibRulesStatGroup, indMngrCnfgObjects=indMngrCnfgObjects, indSrvrGoneDown=indSrvrGoneDown, ssAddr=ssAddr, ssNewConns=ssNewConns, mcInterval=mcInterval, dispatcherMibTraps=dispatcherMibTraps, mcSensitivity=mcSensitivity, indPortCnfgTable=indPortCnfgTable, rcPriority=rcPriority, mcSystemProp=mcSystemProp, indClstrStatTable=indClstrStatTable, hasPort=hasPort, ssActiveConns=ssActiveConns, indMibExecStatGroup=indMibExecStatGroup, psNumNodesDown=psNumNodesDown, mcRefresh=mcRefresh, esNonForPkts=esNonForPkts, indReachStatTable=indReachStatTable, rcType=rcType, rsTimesFired=rsTimesFired, acVersion=acVersion, indHrtBeatCnfgEntry=indHrtBeatCnfgEntry, ssTotalUdpConns=ssTotalUdpConns, indMibMngrCnfgGroup=indMibMngrCnfgGroup, indMibCompliance=indMibCompliance, esNumClust=esNumClust, indMibStatGroups=indMibStatGroups, indRulesCnfgTable=indRulesCnfgTable, hbcDestAddr=hbcDestAddr, indMibAllSrvrsCnfgGroup=indMibAllSrvrsCnfgGroup, indExecStatObjects=indExecStatObjects, indRulesStatTable=indRulesStatTable, ssNewConnsWeight=ssNewConnsWeight, indMibHrtBeatCnfgGroup=indMibHrtBeatCnfgGroup, indAdvsrCnfgEntry=indAdvsrCnfgEntry, hasState=hasState, indAllSrvrsCnfgEntry=indAllSrvrsCnfgEntry, indHighAvailStatus=indHighAvailStatus, esClstrOwnAddrPkts=esClstrOwnAddrPkts, rsNumSrvrs=rsNumSrvrs, ssFinConns=ssFinConns, ssCompleteConns=ssCompleteConns, csDroppedPKTs=csDroppedPKTs, esStartTime=esStartTime, indExecCnfgObjects=indExecCnfgObjects, indMibGroups=indMibGroups, csDroppedFINs=csDroppedFINs, indHrtBeatCnfgTable=indHrtBeatCnfgTable, esNotClstrPkts=esNotClstrPkts, rcBeginRange=rcBeginRange, indReachCnfgTable=indReachCnfgTable, indAdvsrCnfgTable=indAdvsrCnfgTable, mcSmoothing=mcSmoothing, mcActiveProp=mcActiveProp, csDroppedACKs=csDroppedACKs, indReachStatEntry=indReachStatEntry, psNumServers=psNumServers, indMibCompliances=indMibCompliances, indAllSrvrsCnfgTable=indAllSrvrsCnfgTable, indSrvrCnfgTable=indSrvrCnfgTable, esClstrErrPkts=esClstrErrPkts, indClstrCnfgTable=indClstrCnfgTable, ssActiveConnsWeight=ssActiveConnsWeight, rcIndex=rcIndex, mcVersion=mcVersion, ssSystemLoad=ssSystemLoad, ascInstances=ascInstances, indHiAvailStatObjects=indHiAvailStatObjects, esTooShortPkts=esTooShortPkts, indMibSrvrStatGroup=indMibSrvrStatGroup, rcName=rcName, ssWeight=ssWeight, dispatcherMib=dispatcherMib, indRulesCnfgEntry=indRulesCnfgEntry, indMibHiAvailStatGroup=indMibHiAvailStatGroup, indMibClstrStatGroup=indMibClstrStatGroup, GaugeNeg1=GaugeNeg1, esHashBkts=esHashBkts, indClstrStatEntry=indClstrStatEntry, esClstrForPkts=esClstrForPkts, csNonExistingPKTs=csNonExistingPKTs, indSrvrStatTable=indSrvrStatTable, esNonForAddr=esNonForAddr, acName=acName, psNum=psNum, rcEndRange=rcEndRange, indHiAvailCnfgObjects=indHiAvailCnfgObjects, csActiveSYNs=csActiveSYNs, indConfig=indConfig, hasPrimary=hasPrimary, esTotalPkts=esTotalPkts, esForErrPkts=esForErrPkts, indPortStatTable=indPortStatTable, indPortStatEntry=indPortStatEntry, ssTotalConns=ssTotalConns, indStatus=indStatus, ascAddr=ascAddr, acPort=acPort, rsPingAble=rsPingAble, hasSubState=hasSubState, indMibRulesCnfgGroup=indMibRulesCnfgGroup, esVersion=esVersion, indMibReachStatGroup=indMibReachStatGroup, ssSavedWeight=ssSavedWeight, Percentages=Percentages, rcSrvrList=rcSrvrList, hbcSrcAddr=hbcSrcAddr, indMibAdvsrCnfgGroup=indMibAdvsrCnfgGroup, rsAddr=rsAddr, mcPortProp=mcPortProp, ascQuiesced=ascQuiesced, ssPortLoadWeight=ssPortLoadWeight, indSrvrStatEntry=indSrvrStatEntry, csNumPorts=csNumPorts)

#
# PySNMP MIB module HH3C-NPV-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-NPV-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
Hh3cFcVsanIndex, = mibBuilder.importSymbols("HH3C-FC-TC-MIB", "Hh3cFcVsanIndex")
hh3cVsanIndex, hh3cSan = mibBuilder.importSymbols("HH3C-VSAN-MIB", "hh3cVsanIndex", "hh3cSan")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Integer32, Counter32, Bits, TimeTicks, Counter64, NotificationType, Gauge32, MibIdentifier, ModuleIdentity, Unsigned32, ObjectIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Integer32", "Counter32", "Bits", "TimeTicks", "Counter64", "NotificationType", "Gauge32", "MibIdentifier", "ModuleIdentity", "Unsigned32", "ObjectIdentity", "IpAddress")
RowStatus, TimeStamp, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeStamp", "DisplayString", "TextualConvention")
hh3cNpv = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6))
hh3cNpv.setRevisions(('2013-04-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cNpv.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: hh3cNpv.setLastUpdated('201304020000Z')
if mibBuilder.loadTexts: hh3cNpv.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cNpv.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085')
if mibBuilder.loadTexts: hh3cNpv.setDescription('This MIB module is for the management of N_Port Virtualization or NPV within the framework of N_Port virtualization(NPV) architecture. N_Port virtualization reduces the number of Fibre Channel domain IDs in SANs(Storage Aera Network). Switches operating in the NPV mode do not join a fabric; rather, they pass traffic between NPV core switch links and end-devices, which eliminates the domain IDs for these edge switches. NPV core switch is a fibre channel edge switch connected to one or more NPV devices.')
class Hh3cNpvIfIndexList(TextualConvention, OctetString):
    description = "This textual convention defines a list of 'ifIndex'. Each 4 octets within this value are combined together to represent the 'ifIndex' of a particular port in the module. For example, the first 4 octets (byte 1, byte 2, byte 3 and byte 4) represent the 'ifIndex' of one interface, while the second 4 octets (byte 5, byte 6, byte 7 and byte 8) represent the 'ifIndex' for another interface in the module, and so on."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 65535)

hh3cNpvMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1))
hh3cNpvConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1))
hh3cNpvGlobalObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 1))
hh3cNpvLoadbalanceVsan = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 1, 1), Hh3cFcVsanIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cNpvLoadbalanceVsan.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvLoadbalanceVsan.setDescription('Used to trigger a load-banlancing in the specified VSAN (Virtual Storage Area Network). When the hh3cNpvLoadbalanceVsan is set to a specific VSAN, a disruptive load-balancing process will be initiated in the VSAN so that all nodes in the VSAN will re-login to the core switch. This load-balancing process redistributes downlink traffic across all uplink interfaces for better load balancing, but it causes traffic interruption.')
hh3cNpvTrafficMapConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 2), )
if mibBuilder.loadTexts: hh3cNpvTrafficMapConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvTrafficMapConfigTable.setDescription('A table containing information on the assignment of traffic map interfaces to an interface.')
hh3cNpvTrafficMapConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HH3C-VSAN-MIB", "hh3cVsanIndex"))
if mibBuilder.loadTexts: hh3cNpvTrafficMapConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvTrafficMapConfigEntry.setDescription("An entry in the hh3cNpvTrafficMapConfigTable. This table contains entries for each of the interfaces which has been assigned a set of interfaces for traffic mapping in the VSAN. Traffic mapping is a technique used in NPV device to restrict the usage of external interface(s) for forwarding the traffic from server interface to the fibre channel fabric. If an interface comes up as a server interface and finds a corresponding entry in this table, then the switch software will assign a valid external interface from this list, if any. Once assigned, that assigned external interface will be used for forwarding the traffic from the server interface to the fibre channel fabric. If an interface comes up as a server interface and finds an entry in this table, but with no valid list of external interfaces, then the switch software keeps the server interface in operationally down state until at least one of the interface in the list becomes a valid external interface. If an interface comes up as a server interface and it can not find an entry in this table, then any of the available external interfaces can be assigned to that server interface. Entries in this table can be created or destroyed via hh3cNpvTrafficMapRowStatus object. Columnar objects can be modified when the corresponding hh3cNpvTrafficMapRowStatus is 'active'.")
hh3cNpvTrafficMapExternalIfIndexList = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 2, 1, 1), Hh3cNpvIfIndexList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cNpvTrafficMapExternalIfIndexList.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvTrafficMapExternalIfIndexList.setDescription('The list of external interfaces which the traffic needs to be mapped to. This object is a list of interfaces presented as an octet string of interface indices or ifindex-es. The list should contain at least one interface and at most all the interfaces in the switch up to 16384 interfaces. The 16384 interfaces max-limit is due to the size of this object. Specifying this object is mandatory for the creation of a row in hh3cNpvTrafficMapConfigTable.')
hh3cNpvTrafficMapLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 2, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNpvTrafficMapLastChange.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvTrafficMapLastChange.setDescription('The value of sysUpTime at the time of the latest change to this traffic map entry. When there has not been any change to the traffic map entry, the value of this field will be that of the entry creation time.')
hh3cNpvTrafficMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cNpvTrafficMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvTrafficMapRowStatus.setDescription("The status of this conceptual row. The row can be made 'active' only if value of corresponding instance of hh3cNpvTrafficMapExternalIfIndexList is provided.")
hh3cNpvServerIfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 3), )
if mibBuilder.loadTexts: hh3cNpvServerIfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvServerIfTable.setDescription('This table contains, one entry for each server interface(FC-port configured in F-port mode) in this VSAN in the Fabric element. Each entry contains NPV related information like external interface assigned for the server interface in the VSAN.')
hh3cNpvServerIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HH3C-VSAN-MIB", "hh3cVsanIndex"))
if mibBuilder.loadTexts: hh3cNpvServerIfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvServerIfEntry.setDescription('An entry in the hh3cNpvServerIfTable, containing NPV related parameters established by a server interface indicated by ifIndex.')
hh3cNpvExternalIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 127, 6, 1, 1, 3, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cNpvExternalIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cNpvExternalIfIndex.setDescription('This value of this object is the external interface assigned for the server interface associated with the server interface.')
mibBuilder.exportSymbols("HH3C-NPV-MIB", hh3cNpvTrafficMapConfigEntry=hh3cNpvTrafficMapConfigEntry, hh3cNpvServerIfTable=hh3cNpvServerIfTable, hh3cNpvGlobalObjects=hh3cNpvGlobalObjects, hh3cNpvTrafficMapLastChange=hh3cNpvTrafficMapLastChange, hh3cNpvServerIfEntry=hh3cNpvServerIfEntry, hh3cNpvLoadbalanceVsan=hh3cNpvLoadbalanceVsan, hh3cNpvTrafficMapConfigTable=hh3cNpvTrafficMapConfigTable, hh3cNpvTrafficMapExternalIfIndexList=hh3cNpvTrafficMapExternalIfIndexList, hh3cNpvMibObjects=hh3cNpvMibObjects, hh3cNpvConfiguration=hh3cNpvConfiguration, Hh3cNpvIfIndexList=Hh3cNpvIfIndexList, hh3cNpv=hh3cNpv, hh3cNpvExternalIfIndex=hh3cNpvExternalIfIndex, hh3cNpvTrafficMapRowStatus=hh3cNpvTrafficMapRowStatus, PYSNMP_MODULE_ID=hh3cNpv)

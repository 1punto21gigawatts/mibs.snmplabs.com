#
# PySNMP MIB module INTEL-S500-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INTEL-S500-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:54:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
mib2ext, = mibBuilder.importSymbols("INTEL-GEN-MIB", "mib2ext")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, ObjectIdentity, IpAddress, NotificationType, NotificationType, MibIdentifier, Integer32, ModuleIdentity, TimeTicks, Bits, Unsigned32, Counter64, Counter32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "ObjectIdentity", "IpAddress", "NotificationType", "NotificationType", "MibIdentifier", "Integer32", "ModuleIdentity", "TimeTicks", "Bits", "Unsigned32", "Counter64", "Counter32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
s500 = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10))
module = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 1))
ports = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 2))
statistic = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 3))
adaptiveForwardMode = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 4))
chipSets = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 5))
smu = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 6))
permanentEntries = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 7))
matrix = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 8))
mediamodules = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 10, 9))
defaultSwitchMode = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("cutThrough", 2), ("fragmentFree", 3), ("storeAndForward", 4), ("adaptive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultSwitchMode.setStatus('mandatory')
if mibBuilder.loadTexts: defaultSwitchMode.setDescription("Default switch mode. This is used by the object portSwitchMode when it's value is default(1)")
defaultFlowControlMode = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultFlowControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: defaultFlowControlMode.setDescription("Default Flow Control mode. This is used by the object portConfFlowControl when it's value is default(1)")
smuMaster = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuMaster.setStatus('mandatory')
if mibBuilder.loadTexts: smuMaster.setDescription('OBSOLETE')
localManagementTimeout = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localManagementTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: localManagementTimeout.setDescription("The time (in minutes) that has elapsed before a local management session (telnet or serial) closes when it has not been used. The value '0' means no timeout.")
temperatureLevel = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("high", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: temperatureLevel.setStatus('mandatory')
if mibBuilder.loadTexts: temperatureLevel.setDescription('temperatureLevel values: normal(1) : Temperature normal high(2) : Temperature high. Check air circulation critical(3): Temperature critical. Shut down in 30 seconds')
redundantPowerSupplyStatus = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundantPowerSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: redundantPowerSupplyStatus.setDescription('Status for redundant power supply: notPresent(1): RPS not connected or failed. (It may be present but not plugged in or damaged etc.) present(2): RPS not active. (It may be present, connected, in perfect health, but just not being used.) active(3): RPS active')
portMirroring = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portMirroring.setStatus('mandatory')
if mibBuilder.loadTexts: portMirroring.setDescription('enable(1): Enabling of port mirroring. This is only possible if RMON is disabled. disable(2): Disabling of port mirroring. RMON can only be enabled if port mirroring is disabled')
disableRmon = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("destroyAll", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: disableRmon.setStatus('mandatory')
if mibBuilder.loadTexts: disableRmon.setDescription('destroyAll(1): Disable RMON and destroy all probes. This is necessary for enabling port mirroring')
isRmonActive = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isRmonActive.setStatus('mandatory')
if mibBuilder.loadTexts: isRmonActive.setDescription('enabled(1): RMON is enabled disabled(2): RMON is disabled')
switchTotalTraffic = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchTotalTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: switchTotalTraffic.setDescription('Total switch traffic measured in octets')
bufferPoolUsed = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bufferPoolUsed.setStatus('mandatory')
if mibBuilder.loadTexts: bufferPoolUsed.setDescription('Total switch buffer pool usage. (percentage between 0 and 100)')
featuresBitFlag = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: featuresBitFlag.setStatus('mandatory')
if mibBuilder.loadTexts: featuresBitFlag.setDescription('Bit field index from bit 1 to 32. If an bit is set, the switch supports the related feature. BIT 1: Distributed VLAN BIT 2: Layer 3 switching BIT 3: Diagnostics BIT 4: RSVP BIT 5: IP multicast BIT 6: IP filtering BIT 7: ATM STP BIT 8: Port trunking BIT 9: Port mirroring BIT 10: VLAN stacking BIT 11: Forwarding of learn packets BIT 12: IGMP pruning BIT 13: ToS BIT 14: Bulk En-/Disable STP BIT 15: VLAN table flush BIT 16: Transparent Cache BIT 17: Compressed Stack')
switchBw = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchBw.setStatus('mandatory')
if mibBuilder.loadTexts: switchBw.setDescription('Max switch BW. (Mbits per second)')
ownMatrixAttachmentPort = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ownMatrixAttachmentPort.setStatus('mandatory')
if mibBuilder.loadTexts: ownMatrixAttachmentPort.setDescription('Returns the port number of the Matrix port the switch is attached to. NB: will return 50 for a switch not connected to a Matrix Module')
stackCrc = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackCrc.setStatus('mandatory')
if mibBuilder.loadTexts: stackCrc.setDescription('checksum for stack specific parameters If a parameter is unavailable 0 is returned ')
portSnmpPort = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSnmpPort.setStatus('mandatory')
if mibBuilder.loadTexts: portSnmpPort.setDescription('Returns the port which this SNMP request went through. This gives the port on which the SNMP management system is connected.')
portLastChange = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: portLastChange.setDescription('The value of sysUpTime after any interface has changed state')
portInfoTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 3), )
if mibBuilder.loadTexts: portInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoTable.setDescription('Port information table which includes all ports.')
portInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 3, 1), ).setIndexNames((0, "INTEL-S500-MIB", "portInfoChassisIndex"), (0, "INTEL-S500-MIB", "portInfoModuleIndex"), (0, "INTEL-S500-MIB", "portInfoIndex"))
if mibBuilder.loadTexts: portInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoEntry.setDescription('Contains the type of interface .')
portInfoChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoChassisIndex.setDescription('Chassis index')
portInfoModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoModuleIndex.setDescription('Module index')
portInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoIndex.setDescription('An index value that uniquely identifies an interface. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
portInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 10, 11))).clone(namedValues=NamedValues(("hundredbasetx", 1), ("hundredbasefx", 2), ("core", 3), ("internal", 4), ("layer3link", 5), ("gigabasesx", 10), ("gigabaselx", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoType.setDescription('The type of Physical interface at the port.')
portConfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4), )
if mibBuilder.loadTexts: portConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: portConfTable.setDescription('Port configuration and status table.')
portConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1), ).setIndexNames((0, "INTEL-S500-MIB", "portConfChassisIndex"), (0, "INTEL-S500-MIB", "portConfModuleIndex"), (0, "INTEL-S500-MIB", "portConfIndex"))
if mibBuilder.loadTexts: portConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portConfEntry.setDescription('An entry containing the objects for configuration and status of a port.')
portConfChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portConfChassisIndex.setDescription('Chassis index')
portConfModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portConfModuleIndex.setDescription('Module index')
portConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portConfIndex.setDescription('An index value that uniquely identifies an interface. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
portConfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: portConfDescr.setDescription('User configurable description of the port.')
portConfLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfLocation.setStatus('mandatory')
if mibBuilder.loadTexts: portConfLocation.setDescription('User configurable location of the port.')
portConfConfigSwitchMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 99))).clone(namedValues=NamedValues(("default", 1), ("cutThrough", 2), ("fragmentFree", 3), ("storeAndForward", 4), ("adaptive", 5), ("notAvailable", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfConfigSwitchMode.setStatus('mandatory')
if mibBuilder.loadTexts: portConfConfigSwitchMode.setDescription('Port Switch mode. If set to default(1) the value from defaultSwitchMode is used.')
portConfFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 99))).clone(namedValues=NamedValues(("default", 1), ("enable", 2), ("disable", 3), ("notAvailable", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: portConfFlowControl.setDescription('Port Flow Control mode. If set to default(1) the value from defaultFlowControlMode is used.')
portConfSpeedSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("speed10Mbit", 1), ("speed100Mbit", 2), ("speed10And100Mbit", 3), ("speed10And100AndAutoMbit", 4), ("speed155Mbit", 5), ("speed1Gbit", 6), ("speed1AndAutoGbit", 7), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfSpeedSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portConfSpeedSupported.setDescription('The possible speeds of a port')
portConfDuplexSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 7, 99))).clone(namedValues=NamedValues(("half", 1), ("full", 2), ("halfAndFull", 3), ("auto", 4), ("autoAndFull", 6), ("autoAndHalfAndFull", 7), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfDuplexSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portConfDuplexSupported.setDescription('The possible duplex modes of a port')
portConfConfigSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("speed10Mbit", 1), ("speed100Mbit", 2), ("speed1Gbit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfConfigSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portConfConfigSpeed.setDescription('The configured speed for a port')
portConfConfigDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half", 1), ("full", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfConfigDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: portConfConfigDuplex.setDescription('The configured duplex mode for a port')
portConfConfigAutoNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfConfigAutoNeg.setStatus('mandatory')
if mibBuilder.loadTexts: portConfConfigAutoNeg.setDescription('The configured auto-negotiation for a port')
portConfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 99))).clone(namedValues=NamedValues(("speed10Mbit", 1), ("speedAutoDetect10Mbit", 2), ("speed100Mbit", 3), ("speedAutoDetect100Mbit", 4), ("speed1Gbit", 5), ("speedAutoDetect1Gbit", 6), ("speed155Mbit", 7), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portConfSpeed.setDescription('The current speed for a port')
portConfDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99))).clone(namedValues=NamedValues(("half", 1), ("autoDetectHalf", 2), ("full", 3), ("autoDetectFull", 4), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: portConfDuplex.setDescription('The current duplex mode for a port')
portConfAutoNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 99))).clone(namedValues=NamedValues(("manual", 1), ("auto", 2), ("failed", 3), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfAutoNeg.setStatus('mandatory')
if mibBuilder.loadTexts: portConfAutoNeg.setDescription('The currect auto-negotiation for a port')
portConfSwitchMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 99))).clone(namedValues=NamedValues(("cutThrough", 1), ("adaptiveCutThrough", 2), ("fragmentFree", 3), ("adaptiveFragmentFree", 4), ("storeAndForward", 5), ("adaptiveStoreAndForward", 6), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfSwitchMode.setStatus('mandatory')
if mibBuilder.loadTexts: portConfSwitchMode.setDescription('Current forwarding mode of the port.')
portConfTrunkSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99))).clone(namedValues=NamedValues(("trunkWidthTwo", 1), ("trunkWidthFour", 2), ("trunkMaster", 3), ("trunkSlave", 4), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfTrunkSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portConfTrunkSupported.setDescription('The types of port trunking available for the actual port. A trunk consists of a number ports sitting next to each other. The first port is selected as master for the trunk, the following as slaves. trunkWidthTwo(1): Port is available as master for 2 port trunking. trunkWidthFour(2): Port is available as master for 4 port trunking. trunkMaster(3): Port is master in a trunk. trunkSlave(4): Port is slave in a trunk. notAvailable(99): Port is not available for trunking.')
portConfTrunkConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("trunkWidthTwo", 1), ("trunkWidthFour", 2), ("disable", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfTrunkConfig.setStatus('mandatory')
if mibBuilder.loadTexts: portConfTrunkConfig.setDescription('The size of the actual trunk. 0 means trunkWidthTwo(1): This port is member of a 2 port trunk. trunkWidthFour(2):This port is member of a 4 port trunk. disable(99): This port is not trunked')
portConfTrunkName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfTrunkName.setStatus('mandatory')
if mibBuilder.loadTexts: portConfTrunkName.setDescription('Trunk name')
portConfMirrorSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 99))).clone(namedValues=NamedValues(("mirrorSourceOnly", 1), ("mirrorDestinationOnly", 2), ("mirrorSourceOrDestination", 3), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfMirrorSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portConfMirrorSupported.setDescription('Which mode of port mirroring does the port support. mirrorSourceOnly(1): Port can only be used as source for mirroring mirrorDestinationOnly(2): Port can only be used as destination for mirroring mirrorSourceOrDestination(3): Port can be used as source or destination notAvailable(99): Port can not be used for mirroring')
portConfMirrorConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("mirrorSource", 1), ("mirrorDestination", 2), ("disabled", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portConfMirrorConfig.setStatus('mandatory')
if mibBuilder.loadTexts: portConfMirrorConfig.setDescription('The configured port mirroring for the actual port. mirrorSource(1): Port is source for mirroring mirrorDestination(2): Port is destination for mirroring disabled(99): Port is not mirrored')
portConfVlanSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99))).clone(namedValues=NamedValues(("enabled", 1), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConfVlanSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portConfVlanSupported.setDescription('Describes if the port can be used as a port rule in the VLAN configuration. enabled(1): Port can be used in port VLANs notAvailable(99): Port can not be used in port VLANs')
portAllSpanningTreeMode = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("allEnabled", 1), ("allDisabled", 2), ("mixed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAllSpanningTreeMode.setStatus('mandatory')
if mibBuilder.loadTexts: portAllSpanningTreeMode.setDescription('Enable or Disable Spanning Tree Protocol for all ports on switch. SET is only allowed with value allEnabled(1) or allDisabled(2).')
txStatTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1), )
if mibBuilder.loadTexts: txStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: txStatTable.setDescription('Transmit statistics table.')
txStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1), ).setIndexNames((0, "INTEL-S500-MIB", "txStatIndex"))
if mibBuilder.loadTexts: txStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: txStatEntry.setDescription('An entry containing objects for transmit statistics.')
txStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: txStatIndex.setDescription('An index value that uniquely identifies an interface. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
txUCPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUCPkts64Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txUCPkts64Octets.setDescription('64 byte unicast packets transmitted')
txUCPkts65To127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUCPkts65To127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txUCPkts65To127Octets.setDescription('65 to 127 byte unicast packets transmitted')
txUCPkts128To255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUCPkts128To255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txUCPkts128To255Octets.setDescription('128 to 255 byte unicast packets transmitted')
txUCPkts256To511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUCPkts256To511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txUCPkts256To511Octets.setDescription('256 to 511 byte unicast packets transmitted')
txUCPkts512To1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUCPkts512To1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txUCPkts512To1023Octets.setDescription('512 to 1023 byte unicast packets transmitted')
txUCPkts1024To1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUCPkts1024To1518Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txUCPkts1024To1518Octets.setDescription('1024 to 1518 byte unicast packets transmitted')
txMCPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMCPkts64Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txMCPkts64Octets.setDescription('64 byte multicast packets transmitted')
txMCPkts65To127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMCPkts65To127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txMCPkts65To127Octets.setDescription('65 to 127 byte multicast packets transmitted')
txMCPkts128To255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMCPkts128To255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txMCPkts128To255Octets.setDescription('128 to 255 byte multicast packets transmitted')
txMCPkts256To511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMCPkts256To511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txMCPkts256To511Octets.setDescription('256 to 511 byte multicast packets transmitted')
txMCPkts512To1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMCPkts512To1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txMCPkts512To1023Octets.setDescription('512 to 1023 byte multicast packets transmitted')
txMCPkts1024To1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMCPkts1024To1518Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txMCPkts1024To1518Octets.setDescription('1024 to 1518 byte multicast packets transmitted')
txBCPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBCPkts64Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txBCPkts64Octets.setDescription('64 byte broadcast packets transmitted')
txBCPkts65To127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBCPkts65To127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txBCPkts65To127Octets.setDescription('65 to 127 byte broadcast packets transmitted')
txBCPkts128To255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBCPkts128To255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txBCPkts128To255Octets.setDescription('128 to 255 byte broadcast packets transmitted')
txBCPkts256To511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBCPkts256To511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txBCPkts256To511Octets.setDescription('256 to 511 byte broadcast packets transmitted')
txBCPkts512To1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBCPkts512To1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txBCPkts512To1023Octets.setDescription('512 to 1023 byte broadcast packets transmitted')
txBCPkts1024To1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBCPkts1024To1518Octets.setStatus('mandatory')
if mibBuilder.loadTexts: txBCPkts1024To1518Octets.setDescription('1024 to 1518 byte broadcast packets transmitted')
txOctetsIllegalAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctetsIllegalAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: txOctetsIllegalAddrType.setDescription('Internal error -- not possible. Always zero.')
tx1ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx1ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx1ArbitFrameDelay.setDescription('Tx packets delayed less than 1 slot time (due to NIMBUS overload).')
tx2ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx2ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx2ArbitFrameDelay.setDescription('Tx packets delayed between 1 and 2 slot times (due to NIMBUS overload)')
tx3ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx3ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx3ArbitFrameDelay.setDescription('Tx packets delayed between 2 and 4 slot times (due to NIMBUS overload)')
tx4ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx4ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx4ArbitFrameDelay.setDescription('Tx packets delayed between 4 and 8 slot times (due to NIMBUS overload)')
tx5ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx5ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx5ArbitFrameDelay.setDescription('Tx packets delayed between 8 and 16 slot times (due to NIMBUS overload)')
tx6ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx6ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx6ArbitFrameDelay.setDescription('Tx packets delayed between 16 and 32 slot times (due to NIMBUS overload)')
tx7ArbitFrameDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tx7ArbitFrameDelay.setStatus('mandatory')
if mibBuilder.loadTexts: tx7ArbitFrameDelay.setDescription('Tx packets delayed more than 32 slot times (due to NIMBUS overload)')
txDeferreds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDeferreds.setStatus('mandatory')
if mibBuilder.loadTexts: txDeferreds.setDescription('Half duplex: Tx packet delayed, due to receiving a packet. Full duplex: Tx packet delayed, due to receiving of a MAC pause control frame.')
txOctetsHis = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctetsHis.setStatus('mandatory')
if mibBuilder.loadTexts: txOctetsHis.setDescription('Upper part of a 64 bit octet transmitted counter')
txOctetsLos = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctetsLos.setStatus('mandatory')
if mibBuilder.loadTexts: txOctetsLos.setDescription('Lower part of a 64 bit octet transmitted counter')
txOctetsOutOfRange = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctetsOutOfRange.setStatus('mandatory')
if mibBuilder.loadTexts: txOctetsOutOfRange.setDescription('Internal error')
txExcessiveDeferralsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txExcessiveDeferralsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: txExcessiveDeferralsErrors.setDescription('Maximum deferral should be the duration of a maximum length packet, if no errors on the net. Excessive deferral is indicated if deferral duration is more than approximately 49 maximum packets.')
txNiaUnderRunAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txNiaUnderRunAborts.setStatus('mandatory')
if mibBuilder.loadTexts: txNiaUnderRunAborts.setDescription('Internal discard')
txExcessiveLengthDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txExcessiveLengthDrops.setStatus('mandatory')
if mibBuilder.loadTexts: txExcessiveLengthDrops.setDescription('Tx packets discarded due to too long packets (Only possible if receiving too long packets are allowed)')
txLinkDownEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txLinkDownEvents.setStatus('mandatory')
if mibBuilder.loadTexts: txLinkDownEvents.setDescription('No link pulses are received. Usually this means that the cable is removed.')
txAllCounterPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(127, 127)).setFixedLength(127)).setMaxAccess("readonly")
if mibBuilder.loadTexts: txAllCounterPackets.setStatus('mandatory')
if mibBuilder.loadTexts: txAllCounterPackets.setDescription('A collection of all counters for byte and packet counters. This object is needed to optimize SNMP traffic. The counters in this string are: txStatIndex INTEGER txOctetsHis Counter txOctetsLos Counter txUCPkts64Octets Counter txUCPkts65To127Octets Counter txUCPkts128To255Octets Counter txUCPkts256To511Octets Counter txUCPkts512To1023Octets Counter txUCPkts1024To1518Octets Counter txMCPkts64Octets Counter txMCPkts65To127Octets Counter txMCPkts128To255Octets Counter txMCPkts256To511Octets Counter txMCPkts512To1023Octets Counter txMCPkts1024To1518Octets Counter txBCPkts64Octets Counter txBCPkts65To127Octets Counter txBCPkts128To255Octets Counter txBCPkts256To511Octets Counter txBCPkts512To1023Octets Counter txBCPkts1024To1518Octets Counter The values are represented in the OCTET STRING in the listed order, each value stored as a 32 bits big engine value.')
txAllCounterOthers = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 1, 1, 38), OctetString().subtype(subtypeSpec=ValueSizeConstraint(127, 127)).setFixedLength(127)).setMaxAccess("readonly")
if mibBuilder.loadTexts: txAllCounterOthers.setStatus('mandatory')
if mibBuilder.loadTexts: txAllCounterOthers.setDescription('A collection of all counters -- other than for byte and packet counters. This object is needed to optimize SNMP traffic. The counters in this string are: txStatIndex INTEGER txDeferreds Counter txExcessiveDeferralsErrors Counter txForwRxErrorCollision Counter txNiaUnderRunAborts Counter txLinkDownEvents Counter -- Counters from RFC1643 txCSenseErrors Counter txSQEErrors Counter txLateCollisions Counter txExcessiveCollisionErrors Counter txSingleCollisionFrames Counter txMultipleCollisionFrames Counter The values are represented in the OCTET STRING in the listed order, each value stored as a 32 bits big engine value.')
rxStatTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2), )
if mibBuilder.loadTexts: rxStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rxStatTable.setDescription('Receive statistics table.')
rxStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1), ).setIndexNames((0, "INTEL-S500-MIB", "rxStatIndex"))
if mibBuilder.loadTexts: rxStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rxStatEntry.setDescription('An entry containing objects for receive statistics.')
rxStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rxStatIndex.setDescription('An index value that uniquely identifies an interface. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
rxUCPkts64OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts64OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts64OctetsLocals.setDescription('64 byte unicast packets received which have not been forwarded')
rxUCPkts64OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts64OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts64OctetsForwardeds.setDescription('64 byte unicast packets received which have been forwarded')
rxUCPkts65To127OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts65To127OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts65To127OctetsLocals.setDescription('65 to 127 byte unicast packets received which have not been forwarded')
rxUCPkts65To127OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts65To127OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts65To127OctetsForwardeds.setDescription('65 to 127 byte unicast packets received which have been forwarded')
rxUCPkts128To255OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts128To255OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts128To255OctetsLocals.setDescription('128 to 255 byte unicast packets received which have not been forwarded')
rxUCPkts128To255OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts128To255OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts128To255OctetsForwardeds.setDescription('128 to 255 byte unicast packets received which have been forwarded')
rxUCPkts256To511OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts256To511OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts256To511OctetsLocals.setDescription('256 to 511 byte unicast packets received which have not been forwarded')
rxUCPkts256To511OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts256To511OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts256To511OctetsForwardeds.setDescription('255 to 511 byte unicast packets received which have been forwarded')
rxUCPkts512To1023OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts512To1023OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts512To1023OctetsLocals.setDescription('512 to 1023 byte unicast packets received which have not been forwarded')
rxUCPkts512To1023OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts512To1023OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts512To1023OctetsForwardeds.setDescription('512 to 1023 byte unicast packets received which has been forwarded')
rxUCPkts1024To1518OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts1024To1518OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts1024To1518OctetsLocals.setDescription('1024 to 1518 byte unicast packets received which have not been forwarded')
rxUCPkts1024To1518OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUCPkts1024To1518OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxUCPkts1024To1518OctetsForwardeds.setDescription('1024 to 1518 byte unicast packets received which have been forwarded')
rxShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxShortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxShortErrors.setDescription('Receive fragments shorter than the minimum ordinary collision fragment.')
rxRuntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxRuntErrors.setDescription('Ordinary collision fragments received.')
rxDataRateMMErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDataRateMMErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxDataRateMMErrors.setDescription('A data rate miss-match error occurs if the data rate deviation is larger than allowed. This should only occur if problems with the TX oscillator in the adapter transmitting the frame.')
rxMCPkts64OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts64OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts64OctetsLocals.setDescription('64 byte multicast packets received which have not been forwarded')
rxMCPkts64OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts64OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts64OctetsForwardeds.setDescription('64 byte multicast packets received which have been forwarded')
rxMCPkts65To127OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts65To127OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts65To127OctetsLocals.setDescription('65 to 127 byte multicast packets received which have not been forwarded')
rxMCPkts65To127OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts65To127OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts65To127OctetsForwardeds.setDescription('65 to 127 byte multicast packets received which have been forwarded')
rxMCPkts128To255OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts128To255OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts128To255OctetsLocals.setDescription('128 to 255 byte multicast packets received which have not been forwarded')
rxMCPkts128To255OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts128To255OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts128To255OctetsForwardeds.setDescription('128 to 255 byte multicast packets received which have been forwarded')
rxMCPkts256To511OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts256To511OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts256To511OctetsLocals.setDescription('256 to 511 byte multicast packets received which have not been forwarded')
rxMCPkts256To511OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts256To511OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts256To511OctetsForwardeds.setDescription('256 to 511 byte multicast packets received which have been forwarded')
rxMCPkts512To1023OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts512To1023OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts512To1023OctetsLocals.setDescription('512 to 1023 byte multicast packets received which have not been forwarded')
rxMCPkts512To1023OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts512To1023OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts512To1023OctetsForwardeds.setDescription('512 to 1023 byte multicast packets received which have been forwarded')
rxMCPkts1024To1518OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts1024To1518OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts1024To1518OctetsLocals.setDescription('1024 to 1518 byte multicast packets received which have not been forwarded')
rxMCPkts1024To1518OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMCPkts1024To1518OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxMCPkts1024To1518OctetsForwardeds.setDescription('1024 to 1518 byte multicast packets received which have been forwarded')
rxOctetsLocalHis = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctetsLocalHis.setStatus('mandatory')
if mibBuilder.loadTexts: rxOctetsLocalHis.setDescription('Upper part of a 64 bit octet received counter which has not been forwarded')
rxOctetsLocalLos = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctetsLocalLos.setStatus('mandatory')
if mibBuilder.loadTexts: rxOctetsLocalLos.setDescription('Lower part of a 64 bit octet received counter which has not been forwarded')
rxOctetsForwardedHis = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctetsForwardedHis.setStatus('mandatory')
if mibBuilder.loadTexts: rxOctetsForwardedHis.setDescription('Upper part of a 64 bit octet received counter which has been forwarded')
rxOctetsForwardedLos = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctetsForwardedLos.setStatus('mandatory')
if mibBuilder.loadTexts: rxOctetsForwardedLos.setDescription('Lower part of a 64 bit octet received counter which has been forwarded')
rxBCPkts64OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts64OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts64OctetsLocals.setDescription('64 byte broadcast packets received which have not been forwarded')
rxBCPkts64OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts64OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts64OctetsForwardeds.setDescription('64 byte broadcast packets received which have been forwarded')
rxBCPkts65To127OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts65To127OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts65To127OctetsLocals.setDescription('65 to 127 byte broadcast packets received which have not been forwarded')
rxBCPkts65To127OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts65To127OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts65To127OctetsForwardeds.setDescription('65 to 127 byte broadcast packets received which have been forwarded')
rxBCPkts128To255OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts128To255OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts128To255OctetsLocals.setDescription('128 to 255 byte broadcast packets received which have not been forwarded')
rxBCPkts128To255OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts128To255OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts128To255OctetsForwardeds.setDescription('128 to 255 byte broadcast packets received which have been forwarded')
rxBCPkts256To511OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts256To511OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts256To511OctetsLocals.setDescription('256 to 511 byte broadcast packets received which have not been forwarded')
rxBCPkts256To511OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts256To511OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts256To511OctetsForwardeds.setDescription('256 to 511 byte broadcast packets received which have been forwarded')
rxBCPkts512To1023OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts512To1023OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts512To1023OctetsLocals.setDescription('512 to 1023 byte broadcast packets received which have not been forwarded')
rxBCPkts512To1023OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts512To1023OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts512To1023OctetsForwardeds.setDescription('512 to 1023 byte broadcast packets received which have been forwarded')
rxBCPkts1024To1518OctetsLocals = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts1024To1518OctetsLocals.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts1024To1518OctetsLocals.setDescription('1024 to 1518 byte broadcast packets received which have not been forwarded')
rxBCPkts1024To1518OctetsForwardeds = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBCPkts1024To1518OctetsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: rxBCPkts1024To1518OctetsForwardeds.setDescription('1024 to 1518 byte broadcast packets received which have been forwarded')
rxFilterMACUnexp2ndPortDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFilterMACUnexp2ndPortDrops.setStatus('mandatory')
if mibBuilder.loadTexts: rxFilterMACUnexp2ndPortDrops.setDescription('MAC address has been moved from one port to another')
rxFilterIllegalMACDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFilterIllegalMACDrops.setStatus('mandatory')
if mibBuilder.loadTexts: rxFilterIllegalMACDrops.setDescription('Packet is dropped because the source MAC address is illegal (zero or broadcase)')
rxFlowCtrlPram = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFlowCtrlPram.setStatus('mandatory')
if mibBuilder.loadTexts: rxFlowCtrlPram.setDescription('Half duplex: Number of Flow Control collisions generated due to PRAM limitations. Full duplex: Number of MAC pause control frames transmitted due to PRAM limitations.')
rxFlowCtrlNimbus = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFlowCtrlNimbus.setStatus('mandatory')
if mibBuilder.loadTexts: rxFlowCtrlNimbus.setDescription('Half duplex: Number of Flow Control collisions generated due to NIMBUS overload. Full duplex: Number of MAC pause control frames transmitted due to NIMBUS overload.')
rxPramOverRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPramOverRuns.setStatus('mandatory')
if mibBuilder.loadTexts: rxPramOverRuns.setDescription('Rx packets discarded due to PRAM limitation')
rxNimbusOverRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxNimbusOverRuns.setStatus('mandatory')
if mibBuilder.loadTexts: rxNimbusOverRuns.setDescription('Rx packets discarded due to NIMBUS limitation')
rxVeryLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxVeryLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxVeryLongErrors.setDescription('Rx packets that are much too long (> 6000 bytes).')
rxLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxLongErrors.setDescription('Rx packets that are too long (> 1518 bytes)')
rxPauseMacControlReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPauseMacControlReceived.setStatus('mandatory')
if mibBuilder.loadTexts: rxPauseMacControlReceived.setDescription('Number of MAC pause control frames received')
rxUnknownMacControlFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUnknownMacControlFrame.setStatus('mandatory')
if mibBuilder.loadTexts: rxUnknownMacControlFrame.setDescription('Number of unsupported MAC control frames received')
rxPiaOutOfPoolDropErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPiaOutOfPoolDropErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxPiaOutOfPoolDropErrors.setDescription('Reception is aborted due to lack of pool memory -- the switch is overloaded.')
rxCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: rxCodeViolations.setDescription('An illegal symbol received on a 100Base-X port.')
rxJabberErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxJabberErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxJabberErrors.setDescription('Rx packets that are too long and contains CRC errors and/or dribble nibble.')
rxNiaOverRunDropErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxNiaOverRunDropErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rxNiaOverRunDropErrors.setDescription('The NIA Rx buffer goes to overrun if the nimbus is overloaded (NIA10 only).')
rxAllCounterPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 59), OctetString().subtype(subtypeSpec=ValueSizeConstraint(164, 164)).setFixedLength(164)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxAllCounterPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rxAllCounterPackets.setDescription('A collection of all counters for byte and packet counters. This object is needed to optimise SNMP traffic. The counters in this string are: rxStatIndex INTEGER rxOctetsLocalHis Counter rxOctetsLocalLos Counter rxOctetsForwardedHis Counter rxOctetsForwardedLos Counter rxUCPkts64OctetsLocals Counter rxUCPkts64OctetsForwardeds Counter rxUCPkts65To127OctetsLocals Counter rxUCPkts65To127OctetsForwardeds Counter rxUCPkts128To255OctetsLocals Counter rxUCPkts128To255OctetsForwardeds Counter rxUCPkts256To511OctetsLocals Counter rxUCPkts256To511OctetsForwardeds Counter rxUCPkts512To1023OctetsLocals Counter rxUCPkts512To1023OctetsForwardeds Counter rxUCPkts1024To1518OctetsLocals Counter rxUCPkts1024To1518OctetsForwardeds Counter rxMCPkts64OctetsLocals Counter rxMCPkts64OctetsForwardeds Counter rxMCPkts65To127OctetsLocals Counter rxMCPkts65To127OctetsForwardeds Counter rxMCPkts128To255OctetsLocals Counter rxMCPkts128To255OctetsForwardeds Counter rxMCPkts256To511OctetsLocals Counter rxMCPkts256To511OctetsForwardeds Counter rxMCPkts512To1023OctetsLocals Counter rxMCPkts512To1023OctetsForwardeds Counter rxMCPkts1024To1518OctetsLocals Counter rxMCPkts1024To1518OctetsForwardeds Counter rxBCPkts64OctetsLocals Counter rxBCPkts64OctetsForwardeds Counter rxBCPkts65To127OctetsLocals Counter rxBCPkts65To127OctetsForwardeds Counter rxBCPkts128To255OctetsLocals Counter rxBCPkts128To255OctetsForwardeds Counter rxBCPkts256To511OctetsLocals Counter rxBCPkts256To511OctetsForwardeds Counter rxBCPkts512To1023OctetsLocals Counter rxBCPkts512To1023OctetsForwardeds Counter rxBCPkts1024To1518OctetsLocals Counter rxBCPkts1024To1518OctetsForwardeds Counter The values are represented in the OCTET STRING in the listed order. Each value stored as a 32 bits big engine value.')
rxAllCounterOthers = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 2, 1, 60), OctetString().subtype(subtypeSpec=ValueSizeConstraint(48, 48)).setFixedLength(48)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxAllCounterOthers.setStatus('mandatory')
if mibBuilder.loadTexts: rxAllCounterOthers.setDescription('A collection of all counters other than for byte and packet counters. This object is needed to optimize SNMP traffic. The counters in this string are: rxStatIndex INTEGER rxShortErrors Counter rxRuntErrors Counter rxDataRateMMErrors Counter rxFilterMACUnexp2ndPortDrops Counter rxFilterIllegalMACDrops Counter rxVeryLongErrors Counter rxLongErrors Counter rxCodeViolation Counter rxJabberErrors Counter -- Counters from RFC1643 rxAlignErrors Counter rxFCSErrors Counter The values are represented in the OCTET STRING in the listed order, each value stored as a 32 bits big engine value.')
totalRxTxPackets = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalRxTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: totalRxTxPackets.setDescription('This object is used for LED control to display traffic. Values in the string are all packets transmitted and received at each port. The number and order of values equals the ifIndex, however only physical ports are included in the array. Each entry is 4 bytes. The first 4 bytes of the string is the value of portLastChange.')
totalCollisions = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 3, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: totalCollisions.setDescription('This object is used for LED control to display collision. Values in the string are the total collisions at each port. The number and order of values equals the ifIndex, however only physical ports are included in the array. Each entry is 4 bytes. The first 4 bytes of the string is the value of portLastChange.')
adaptiveForwardModeSampleTime = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveForwardModeSampleTime.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveForwardModeSampleTime.setDescription('Specify how long (in seconds) the received packets will be monitored. The resulting forwarding mode will be based on the quality of the packets')
adaptiveForwardModeRuntsOffset = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveForwardModeRuntsOffset.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveForwardModeRuntsOffset.setDescription('Specifies the minimum amount of runts during the sample time which forces the port out of cutThrough(2). The value is specified in per mill * 1000')
adaptiveForwardModeRuntsRange = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveForwardModeRuntsRange.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveForwardModeRuntsRange.setDescription('Specifies (together with adaptiveForwardModeRuntsOffset) the maximum amount of runts allowed during the sample time. This forces the port back to cutThrough(2). The value is specified in per mill * 1000')
adaptiveForwardModeCrcsOffset = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveForwardModeCrcsOffset.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveForwardModeCrcsOffset.setDescription('Specifies the maximum amount of CRC errors during the sample time. This forces the port out of Store-and-Forward. The value is specified in per mill * 1000')
adaptiveForwardModeCrcsRange = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 4, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveForwardModeCrcsRange.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveForwardModeCrcsRange.setDescription('Specifies together with adaptiveForwardModeCrcsOffset the maximum amount of CRC errors during the sample time. This forces the port out of Store-and-Forward. The value is specified in per mill * 1000')
smuModuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 1), )
if mibBuilder.loadTexts: smuModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: smuModuleTable.setDescription('Not implemented yet')
smuModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 1, 1), ).setIndexNames((0, "INTEL-S500-MIB", "smuModuleChassisIndex"), (0, "INTEL-S500-MIB", "smuModuleIndex"))
if mibBuilder.loadTexts: smuModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: smuModuleEntry.setDescription('Not implemented yet')
smuModuleChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuModuleChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smuModuleChassisIndex.setDescription('Not implemented yet')
smuModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smuModuleIndex.setDescription('Not implemented yet')
smuModuleState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: smuModuleState.setDescription('Not implemented yet')
smuPortTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2), )
if mibBuilder.loadTexts: smuPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortTable.setDescription('Not implemented yet')
smuPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1), ).setIndexNames((0, "INTEL-S500-MIB", "smuPortChassisIndex"), (0, "INTEL-S500-MIB", "smuPortModuleIndex"), (0, "INTEL-S500-MIB", "smuPortIndex"))
if mibBuilder.loadTexts: smuPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortEntry.setDescription('Not implemented yet')
smuPortChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuPortChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortChassisIndex.setDescription('Not implemented yet')
smuPortModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuPortModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortModuleIndex.setDescription('Not implemented yet')
smuPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortIndex.setDescription('Not implemented yet')
smuPortAttachedNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuPortAttachedNumber.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortAttachedNumber.setDescription('Not implemented yet')
smuPortAttachedMac = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuPortAttachedMac.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortAttachedMac.setDescription('Not implemented yet')
smuPortAttachedIp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 6, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smuPortAttachedIp.setStatus('mandatory')
if mibBuilder.loadTexts: smuPortAttachedIp.setDescription('Not implemented yet')
permanentEntriesTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 7, 1), )
if mibBuilder.loadTexts: permanentEntriesTable.setStatus('mandatory')
if mibBuilder.loadTexts: permanentEntriesTable.setDescription('')
permanentEntriesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 7, 1, 1), ).setIndexNames((0, "INTEL-S500-MIB", "permanentEntriesMACAddr"))
if mibBuilder.loadTexts: permanentEntriesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: permanentEntriesEntry.setDescription('')
permanentEntriesMACAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 7, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permanentEntriesMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: permanentEntriesMACAddr.setDescription('MAC address of permanent entry.')
permanentEntriesPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 7, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permanentEntriesPortId.setStatus('mandatory')
if mibBuilder.loadTexts: permanentEntriesPortId.setDescription('Port number for permanent entry.')
permanentEntriesCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 7, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permanentEntriesCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: permanentEntriesCreateObj.setDescription('Create a non-existant table entry. If the entry already exists, genError is returned. Format: PortId (INTEGER)')
permanentEntriesDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permanentEntriesDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: permanentEntriesDeleteObj.setDescription('Delete an existing table entry.')
matrixModuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 1), )
if mibBuilder.loadTexts: matrixModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: matrixModuleTable.setDescription('The table for general stack information')
matrixModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 1, 1), ).setIndexNames((0, "INTEL-S500-MIB", "matrixModuleIndex"))
if mibBuilder.loadTexts: matrixModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: matrixModuleEntry.setDescription('Information for a specific module slot about stackconnections, state, masterinformation')
matrixModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: matrixModuleIndex.setDescription('Slot number to retrieve information for. 1 is slot A, 2 is slot B')
matrixModuleState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("error", 3), ("back", 4), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: matrixModuleState.setDescription('State of the matrix module. If notAvailable(99) no matrix module can be seen, active(1) is indicating a running module, standby(2) is indicating a module that is ready to become active if needed in a redundant setup, error(3) indicates a stack/redundancy error, back(4) is id the SIM module is running in a back to back configuration')
matrixNumberConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixNumberConnected.setStatus('mandatory')
if mibBuilder.loadTexts: matrixNumberConnected.setDescription('The number of connected units to the matrix module')
matrixMasterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixMasterPort.setStatus('mandatory')
if mibBuilder.loadTexts: matrixMasterPort.setDescription('0 means no master available, otherwise an ifindex is returned (50->57)')
matrixPortTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2), )
if mibBuilder.loadTexts: matrixPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortTable.setDescription('Matrix module per port overview.')
matrixPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1), ).setIndexNames((0, "INTEL-S500-MIB", "matrixModuleIndex"), (0, "INTEL-S500-MIB", "matrixPortIndex"))
if mibBuilder.loadTexts: matrixPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortEntry.setDescription('Per switch of information gathered from the matrix module about the connected devices')
matrixPortModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPortModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortModuleIndex.setDescription('Slot number to retrieve information for. 1 is slot A, 2 is slot B')
matrixPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortIndex.setDescription('Index for retrieving the matrix ports')
matrixPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPort.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPort.setDescription('0 means no device is available, otherwise an ifindex is returned (50->57)')
matrixPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 99))).clone(namedValues=NamedValues(("es510", 1), ("es520", 2), ("es550T", 3), ("es550F", 4), ("gb2", 5), ("atm", 6), ("notAvailable", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPortType.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortType.setDescription('The connected device type, notAvailable(99) if unknown or none')
matrixPortMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPortMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortMajVer.setDescription('Major Version of matrix module shared memory layout supported')
matrixPortMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPortMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortMinVer.setDescription('Minor Version of matrix module shared memory layout supported')
matrixPortMac = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixPortMac.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortMac.setDescription('Mac address of the device connected to a specific matrix port. If the device does not have a mac address it will be zero')
matrixPortIp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: matrixPortIp.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortIp.setDescription('IP address of the device connected to a specific matrix port. If the device does not have an IP address it will be zero')
matrixPortSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: matrixPortSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortSubnetMask.setDescription('IP subnet mask of the device connected to a specific matrix port.')
matrixPortGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 2, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: matrixPortGateway.setStatus('mandatory')
if mibBuilder.loadTexts: matrixPortGateway.setDescription('IP gateway of the device connected to a specific matrix port.')
matrixLastChange = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 8, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: matrixLastChange.setDescription('Timestamp for last change in matrix tables on any Matrix module')
mediaModuleTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 10, 9, 1), )
if mibBuilder.loadTexts: mediaModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: mediaModuleTable.setDescription('Possible values of indices are 1..moduleMaxMediaModules')
mediaModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 10, 9, 1, 1), ).setIndexNames((0, "INTEL-S500-MIB", "mediaModuleChassisIndex"), (0, "INTEL-S500-MIB", "mediaModuleModuleIndex"), (0, "INTEL-S500-MIB", "mediaModuleIndex"))
if mibBuilder.loadTexts: mediaModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mediaModuleEntry.setDescription('Possible values of indices are 1..stackMaxChassis, 1..chassisMaxModules and 1..moduleMaxMediaModules')
moduleMode = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stackMode", 1), ("standAloneMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleMode.setStatus('mandatory')
if mibBuilder.loadTexts: moduleMode.setDescription('Hardware mode for media module. Stack mode is 1 (connected to stack), Stand alone mode is 2 (connected to switch).')
matrixAttachmentPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 10, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: matrixAttachmentPort.setStatus('mandatory')
if mibBuilder.loadTexts: matrixAttachmentPort.setDescription('Returns the port number of the Matrix port the uplink mmodule is attached to. NB: will return 50 for a uplink module not connected to a Matrix Module')
mediaModuleChange = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 10, 9, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaModuleChange.setStatus('mandatory')
if mibBuilder.loadTexts: mediaModuleChange.setDescription('The value of sysUpTime after any mediamoduletype has changed')
s500PermVioEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 10) + (0,1)).setObjects(("INTEL-S500-MIB", "portConfChassisIndex"), ("INTEL-S500-MIB", "portConfModuleIndex"), ("INTEL-S500-MIB", "portConfIndex"))
if mibBuilder.loadTexts: s500PermVioEvent.setDescription("This trap is sent when there has been a permanent entry violation. A MAC address has been detected at a port, other than the port where it has been configured as a permanent entry. The variable portIfIndex indicates the port where the MAC incorrectly has been detected. The problem can be solved by re-configuring the MAC's permanent entry, or by physically moving the MAC to the port it has been configured for.")
s500AdaptiveForwEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 10) + (0,2)).setObjects(("INTEL-S500-MIB", "portConfChassisIndex"), ("INTEL-S500-MIB", "portConfModuleIndex"), ("INTEL-S500-MIB", "portConfIndex"), ("INTEL-S500-MIB", "portConfSwitchMode"), ("INTEL-S500-MIB", "portConfSwitchMode"))
if mibBuilder.loadTexts: s500AdaptiveForwEvent.setDescription('This trap is sent when a port automatically is changing forwarding mode. This will only happen when the port has been configured to Adaptive mode. The syntax is (Portnumber, New mode, Old mode)')
s500TemperatureEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 10) + (0,3)).setObjects(("INTEL-S500-MIB", "temperatureLevel"))
if mibBuilder.loadTexts: s500TemperatureEvent.setDescription('This trap indicates that the temparature of the chassis has changed')
s500RedundantPowerSupplyEvent = NotificationType((1, 3, 6, 1, 4, 1, 343, 6, 10) + (0,4)).setObjects(("INTEL-S500-MIB", "redundantPowerSupplyStatus"))
if mibBuilder.loadTexts: s500RedundantPowerSupplyEvent.setDescription('This trap indicates that the status of the redundant power supply has changed')
mibBuilder.exportSymbols("INTEL-S500-MIB", rxUCPkts256To511OctetsForwardeds=rxUCPkts256To511OctetsForwardeds, rxBCPkts256To511OctetsForwardeds=rxBCPkts256To511OctetsForwardeds, rxMCPkts1024To1518OctetsLocals=rxMCPkts1024To1518OctetsLocals, portAllSpanningTreeMode=portAllSpanningTreeMode, rxFlowCtrlPram=rxFlowCtrlPram, adaptiveForwardModeCrcsRange=adaptiveForwardModeCrcsRange, txBCPkts65To127Octets=txBCPkts65To127Octets, totalCollisions=totalCollisions, rxMCPkts256To511OctetsForwardeds=rxMCPkts256To511OctetsForwardeds, rxUCPkts128To255OctetsForwardeds=rxUCPkts128To255OctetsForwardeds, rxFlowCtrlNimbus=rxFlowCtrlNimbus, matrixPortTable=matrixPortTable, rxMCPkts64OctetsForwardeds=rxMCPkts64OctetsForwardeds, rxFilterIllegalMACDrops=rxFilterIllegalMACDrops, module=module, permanentEntriesTable=permanentEntriesTable, adaptiveForwardModeSampleTime=adaptiveForwardModeSampleTime, localManagementTimeout=localManagementTimeout, bufferPoolUsed=bufferPoolUsed, rxMCPkts65To127OctetsLocals=rxMCPkts65To127OctetsLocals, txMCPkts1024To1518Octets=txMCPkts1024To1518Octets, rxBCPkts128To255OctetsLocals=rxBCPkts128To255OctetsLocals, rxCodeViolations=rxCodeViolations, rxUnknownMacControlFrame=rxUnknownMacControlFrame, rxUCPkts512To1023OctetsForwardeds=rxUCPkts512To1023OctetsForwardeds, portConfSpeed=portConfSpeed, matrixModuleIndex=matrixModuleIndex, smuPortEntry=smuPortEntry, mediaModuleTable=mediaModuleTable, portInfoEntry=portInfoEntry, rxOctetsForwardedLos=rxOctetsForwardedLos, rxAllCounterPackets=rxAllCounterPackets, portConfAutoNeg=portConfAutoNeg, matrixPortMac=matrixPortMac, matrixMasterPort=matrixMasterPort, portConfConfigDuplex=portConfConfigDuplex, txBCPkts256To511Octets=txBCPkts256To511Octets, rxBCPkts256To511OctetsLocals=rxBCPkts256To511OctetsLocals, totalRxTxPackets=totalRxTxPackets, s500=s500, moduleMode=moduleMode, s500TemperatureEvent=s500TemperatureEvent, tx7ArbitFrameDelay=tx7ArbitFrameDelay, portInfoType=portInfoType, portConfChassisIndex=portConfChassisIndex, rxNimbusOverRuns=rxNimbusOverRuns, rxMCPkts128To255OctetsLocals=rxMCPkts128To255OctetsLocals, portInfoIndex=portInfoIndex, smuPortIndex=smuPortIndex, txMCPkts65To127Octets=txMCPkts65To127Octets, adaptiveForwardModeCrcsOffset=adaptiveForwardModeCrcsOffset, txUCPkts65To127Octets=txUCPkts65To127Octets, portMirroring=portMirroring, rxStatEntry=rxStatEntry, rxFilterMACUnexp2ndPortDrops=rxFilterMACUnexp2ndPortDrops, permanentEntriesMACAddr=permanentEntriesMACAddr, matrixPortModuleIndex=matrixPortModuleIndex, ports=ports, rxMCPkts65To127OctetsForwardeds=rxMCPkts65To127OctetsForwardeds, rxOctetsLocalLos=rxOctetsLocalLos, rxUCPkts1024To1518OctetsForwardeds=rxUCPkts1024To1518OctetsForwardeds, rxShortErrors=rxShortErrors, rxBCPkts128To255OctetsForwardeds=rxBCPkts128To255OctetsForwardeds, rxOctetsLocalHis=rxOctetsLocalHis, portConfVlanSupported=portConfVlanSupported, smuPortChassisIndex=smuPortChassisIndex, smuModuleTable=smuModuleTable, smuPortAttachedNumber=smuPortAttachedNumber, permanentEntries=permanentEntries, txStatTable=txStatTable, rxBCPkts1024To1518OctetsForwardeds=rxBCPkts1024To1518OctetsForwardeds, matrixPortMajVer=matrixPortMajVer, portConfTrunkConfig=portConfTrunkConfig, txMCPkts64Octets=txMCPkts64Octets, portConfFlowControl=portConfFlowControl, txOctetsHis=txOctetsHis, rxBCPkts1024To1518OctetsLocals=rxBCPkts1024To1518OctetsLocals, permanentEntriesEntry=permanentEntriesEntry, portConfSwitchMode=portConfSwitchMode, txStatIndex=txStatIndex, rxMCPkts1024To1518OctetsForwardeds=rxMCPkts1024To1518OctetsForwardeds, s500RedundantPowerSupplyEvent=s500RedundantPowerSupplyEvent, portLastChange=portLastChange, smu=smu, rxPramOverRuns=rxPramOverRuns, smuPortAttachedMac=smuPortAttachedMac, rxUCPkts64OctetsForwardeds=rxUCPkts64OctetsForwardeds, rxMCPkts512To1023OctetsLocals=rxMCPkts512To1023OctetsLocals, matrixModuleEntry=matrixModuleEntry, portConfTable=portConfTable, rxPauseMacControlReceived=rxPauseMacControlReceived, featuresBitFlag=featuresBitFlag, rxBCPkts65To127OctetsLocals=rxBCPkts65To127OctetsLocals, rxBCPkts65To127OctetsForwardeds=rxBCPkts65To127OctetsForwardeds, isRmonActive=isRmonActive, txOctetsLos=txOctetsLos, smuModuleIndex=smuModuleIndex, portInfoModuleIndex=portInfoModuleIndex, permanentEntriesDeleteObj=permanentEntriesDeleteObj, mediaModuleChange=mediaModuleChange, rxStatIndex=rxStatIndex, txMCPkts512To1023Octets=txMCPkts512To1023Octets, txBCPkts512To1023Octets=txBCPkts512To1023Octets, txBCPkts128To255Octets=txBCPkts128To255Octets, txUCPkts1024To1518Octets=txUCPkts1024To1518Octets, rxStatTable=rxStatTable, rxUCPkts512To1023OctetsLocals=rxUCPkts512To1023OctetsLocals, rxOctetsForwardedHis=rxOctetsForwardedHis, mediamodules=mediamodules, tx3ArbitFrameDelay=tx3ArbitFrameDelay, s500PermVioEvent=s500PermVioEvent, txUCPkts128To255Octets=txUCPkts128To255Octets, disableRmon=disableRmon, rxBCPkts64OctetsLocals=rxBCPkts64OctetsLocals, txUCPkts64Octets=txUCPkts64Octets, rxUCPkts1024To1518OctetsLocals=rxUCPkts1024To1518OctetsLocals, temperatureLevel=temperatureLevel, stackCrc=stackCrc, smuPortModuleIndex=smuPortModuleIndex, permanentEntriesPortId=permanentEntriesPortId, switchBw=switchBw, portConfTrunkSupported=portConfTrunkSupported, matrixPort=matrixPort, permanentEntriesCreateObj=permanentEntriesCreateObj, tx5ArbitFrameDelay=tx5ArbitFrameDelay, defaultFlowControlMode=defaultFlowControlMode, tx4ArbitFrameDelay=tx4ArbitFrameDelay, rxNiaOverRunDropErrors=rxNiaOverRunDropErrors, txDeferreds=txDeferreds, portConfLocation=portConfLocation, txExcessiveDeferralsErrors=txExcessiveDeferralsErrors, txOctetsIllegalAddrType=txOctetsIllegalAddrType, portInfoTable=portInfoTable, switchTotalTraffic=switchTotalTraffic, smuPortTable=smuPortTable, portConfEntry=portConfEntry, matrixPortIndex=matrixPortIndex, matrixNumberConnected=matrixNumberConnected, matrixPortEntry=matrixPortEntry, portConfConfigSpeed=portConfConfigSpeed, rxBCPkts64OctetsForwardeds=rxBCPkts64OctetsForwardeds, rxMCPkts256To511OctetsLocals=rxMCPkts256To511OctetsLocals, matrixAttachmentPort=matrixAttachmentPort, smuModuleChassisIndex=smuModuleChassisIndex, portConfIndex=portConfIndex, portInfoChassisIndex=portInfoChassisIndex, matrixPortType=matrixPortType, txBCPkts64Octets=txBCPkts64Octets, portSnmpPort=portSnmpPort, portConfDescr=portConfDescr, rxMCPkts64OctetsLocals=rxMCPkts64OctetsLocals, tx2ArbitFrameDelay=tx2ArbitFrameDelay, ownMatrixAttachmentPort=ownMatrixAttachmentPort, adaptiveForwardMode=adaptiveForwardMode, txUCPkts512To1023Octets=txUCPkts512To1023Octets, txMCPkts128To255Octets=txMCPkts128To255Octets, txAllCounterOthers=txAllCounterOthers, txStatEntry=txStatEntry, smuPortAttachedIp=smuPortAttachedIp, rxVeryLongErrors=rxVeryLongErrors, redundantPowerSupplyStatus=redundantPowerSupplyStatus, rxMCPkts512To1023OctetsForwardeds=rxMCPkts512To1023OctetsForwardeds, txAllCounterPackets=txAllCounterPackets, rxUCPkts256To511OctetsLocals=rxUCPkts256To511OctetsLocals, rxLongErrors=rxLongErrors, rxAllCounterOthers=rxAllCounterOthers, tx1ArbitFrameDelay=tx1ArbitFrameDelay, rxUCPkts65To127OctetsLocals=rxUCPkts65To127OctetsLocals, matrix=matrix, rxBCPkts512To1023OctetsLocals=rxBCPkts512To1023OctetsLocals, txOctetsOutOfRange=txOctetsOutOfRange, portConfDuplexSupported=portConfDuplexSupported, defaultSwitchMode=defaultSwitchMode, smuMaster=smuMaster, portConfConfigAutoNeg=portConfConfigAutoNeg, portConfConfigSwitchMode=portConfConfigSwitchMode, smuModuleState=smuModuleState, matrixLastChange=matrixLastChange, rxPiaOutOfPoolDropErrors=rxPiaOutOfPoolDropErrors, adaptiveForwardModeRuntsOffset=adaptiveForwardModeRuntsOffset, matrixModuleTable=matrixModuleTable, tx6ArbitFrameDelay=tx6ArbitFrameDelay, matrixPortMinVer=matrixPortMinVer, matrixPortIp=matrixPortIp, txBCPkts1024To1518Octets=txBCPkts1024To1518Octets, matrixPortSubnetMask=matrixPortSubnetMask, portConfMirrorSupported=portConfMirrorSupported, portConfModuleIndex=portConfModuleIndex, matrixModuleState=matrixModuleState, rxUCPkts64OctetsLocals=rxUCPkts64OctetsLocals, rxMCPkts128To255OctetsForwardeds=rxMCPkts128To255OctetsForwardeds, portConfDuplex=portConfDuplex, rxRuntErrors=rxRuntErrors, rxBCPkts512To1023OctetsForwardeds=rxBCPkts512To1023OctetsForwardeds, s500AdaptiveForwEvent=s500AdaptiveForwEvent, rxUCPkts128To255OctetsLocals=rxUCPkts128To255OctetsLocals, rxJabberErrors=rxJabberErrors, chipSets=chipSets, portConfMirrorConfig=portConfMirrorConfig, txNiaUnderRunAborts=txNiaUnderRunAborts, mediaModuleEntry=mediaModuleEntry, txExcessiveLengthDrops=txExcessiveLengthDrops, portConfTrunkName=portConfTrunkName, adaptiveForwardModeRuntsRange=adaptiveForwardModeRuntsRange, matrixPortGateway=matrixPortGateway, txLinkDownEvents=txLinkDownEvents, txUCPkts256To511Octets=txUCPkts256To511Octets, statistic=statistic, portConfSpeedSupported=portConfSpeedSupported, rxDataRateMMErrors=rxDataRateMMErrors, txMCPkts256To511Octets=txMCPkts256To511Octets, rxUCPkts65To127OctetsForwardeds=rxUCPkts65To127OctetsForwardeds, smuModuleEntry=smuModuleEntry)

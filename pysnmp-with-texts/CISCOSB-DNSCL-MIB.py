#
# PySNMP MIB module CISCOSB-DNSCL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCOSB-DNSCL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:22:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
switch001, = mibBuilder.importSymbols("CISCOSB-MIB", "switch001")
dnsResConfigSbeltEntry, = mibBuilder.importSymbols("DNS-RESOLVER-MIB", "dnsResConfigSbeltEntry")
DnsNameAsIndex, dns, DnsType, DnsRespCode, DnsOpCode, DnsTime, DnsQType, DnsName, DnsQClass, DnsClass = mibBuilder.importSymbols("DNS-SERVER-MIB", "DnsNameAsIndex", "dns", "DnsType", "DnsRespCode", "DnsOpCode", "DnsTime", "DnsQType", "DnsName", "DnsQClass", "DnsClass")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, iso, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Integer32, Bits, MibIdentifier, ObjectIdentity, NotificationType, Gauge32, Counter32, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "iso", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Integer32", "Bits", "MibIdentifier", "ObjectIdentity", "NotificationType", "Gauge32", "Counter32", "IpAddress", "ModuleIdentity")
TruthValue, RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "DisplayString", "TextualConvention")
rlDnsCl = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93))
rlDnsCl.setRevisions(('2013-04-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlDnsCl.setRevisionsDescriptions(('Added MODULE-IDENTITY',))
if mibBuilder.loadTexts: rlDnsCl.setLastUpdated('201304010000Z')
if mibBuilder.loadTexts: rlDnsCl.setOrganization('Cisco Small Business')
if mibBuilder.loadTexts: rlDnsCl.setContactInfo('Postal: 170 West Tasman Drive San Jose , CA 95134-1706 USA Website: Cisco Small Business Home http://www.cisco.com/smb>;, Cisco Small Business Support Community <http://www.cisco.com/go/smallbizsupport>')
if mibBuilder.loadTexts: rlDnsCl.setDescription("The MIB module describes the private MIB for DNS supported by CISCOSB's software and products.")
rlDnsClv2DomainNameTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14), )
if mibBuilder.loadTexts: rlDnsClv2DomainNameTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNameTable.setDescription('The domain names table for DNS client ver2.')
rlDnsClv2DomainNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClv2DomainNameSource"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2DomainNameIfIndex"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2DomainNamePreference"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2DomainNameName"))
if mibBuilder.loadTexts: rlDnsClv2DomainNameEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNameEntry.setDescription('The row definition for this table.')
rlDnsClv2DomainNameSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dhcpv6", 3), ("dhcpv4", 4))).clone('static'))
if mibBuilder.loadTexts: rlDnsClv2DomainNameSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNameSource.setDescription("The domain name source. 'static' if defined by user through CLI, 'dhcpv6' or 'dhcpv4' if received by DHCP network protocol.")
rlDnsClv2DomainNameIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14, 1, 2), InterfaceIndex().clone(1))
if mibBuilder.loadTexts: rlDnsClv2DomainNameIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNameIfIndex.setDescription('The IfIndex from which the domain-name configuration was received, for static entries, value will always be 1.')
rlDnsClv2DomainNamePreference = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14, 1, 3), Integer32())
if mibBuilder.loadTexts: rlDnsClv2DomainNamePreference.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNamePreference.setDescription('This value identifies the preference of domain-name, The lower the value, the more desirable the resolver considers this domain-name in domain-search-list.')
rlDnsClv2DomainNameName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14, 1, 4), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClv2DomainNameName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNameName.setDescription('Domain-name name.')
rlDnsClv2DomainNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsClv2DomainNameRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2DomainNameRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsClv2ServersTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15), )
if mibBuilder.loadTexts: rlDnsClv2ServersTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersTable.setDescription('The DNS servers table for DNS client ver2.')
rlDnsClv2ServersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersSource"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersIfIndex"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersPreference"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersAddrType"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersInetAddr"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersSubTree"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2ServersClass"))
if mibBuilder.loadTexts: rlDnsClv2ServersEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersEntry.setDescription('The row definition for this table.')
rlDnsClv2ServersSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dhcpv6", 3), ("dhcpv4", 4))).clone('static'))
if mibBuilder.loadTexts: rlDnsClv2ServersSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersSource.setDescription('The DNS servers source. Static if defined by user through CLI, dhcpv6 or dhcpv4 if received by network protocol DHCPv6 or DHCPv4.')
rlDnsClv2ServersIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 2), InterfaceIndex().clone(1))
if mibBuilder.loadTexts: rlDnsClv2ServersIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersIfIndex.setDescription('The IfIndex from which the DNS-server configuration was received, for static entries, value will always be 1.')
rlDnsClv2ServersPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 3), Integer32())
if mibBuilder.loadTexts: rlDnsClv2ServersPreference.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersPreference.setDescription('This value identifies the preference for the name server identified in this row of the table. The lower the value, the more desirable the resolver considers this server.')
rlDnsClv2ServersAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 4), InetAddressType())
if mibBuilder.loadTexts: rlDnsClv2ServersAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersAddrType.setDescription('The address type of rlDnsClv2ServersInetAddr. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsClv2ServersInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 5), InetAddress())
if mibBuilder.loadTexts: rlDnsClv2ServersInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersInetAddr.setDescription('The IP address of the name server identified by this row of the table.')
rlDnsClv2ServersSubTree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 6), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClv2ServersSubTree.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersSubTree.setDescription('Queries sent to the name server identified by this row of the table are limited to those for names in the name subtree identified by this variable. If no such limitation applies, the value of this variable is the name of the root domain (a DNS name consisting of a single zero octet).')
rlDnsClv2ServersClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 7), DnsClass())
if mibBuilder.loadTexts: rlDnsClv2ServersClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersClass.setDescription('The class of DNS queries that will be sent to the server identified by this row of the table.')
rlDnsClv2ServersRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 15, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsClv2ServersRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ServersRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsClv2FixedTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16), )
if mibBuilder.loadTexts: rlDnsClv2FixedTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedTable.setDescription("Read-Only MIB for 'fixed' DNS names. when a DNS entry is fixed, a refresh operation is invoked periodically, to make sure the entry is kept 'warm' in the DNS cache. if the refresh operation fails, the DNSCL will enter a polling state, and will retry to resolve the entry again in constant intervals. polling-interval duration for unresolved entries is configurable by MIB scalar 'rlDnsClMinPollingInterval'.")
rlDnsClv2FixedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClv2FixedName"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2FixedType"))
if mibBuilder.loadTexts: rlDnsClv2FixedEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedEntry.setDescription('The row definition for this table.')
rlDnsClv2FixedName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClv2FixedName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedName.setDescription('DNS name of FIXED domain name')
rlDnsClv2FixedType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 2), DnsType())
if mibBuilder.loadTexts: rlDnsClv2FixedType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedType.setDescription('requested type of Resource Record for the current resolved fixed entry. for e.g - A (IPv4), AAAA (IPv6)')
rlDnsClv2FixedPrettyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 3), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2FixedPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: rlDnsClv2FixedPrettyName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedPrettyName.setDescription('Name of the RR at this row in the table. This is identical to the rlDnsClv2FixedName variable, except that character case is preserved in this variable, per DNS conventions.')
rlDnsClv2FixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("init", 1), ("ready", 2), ("resolving", 3), ("refreshing", 4), ("polling", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2FixedState.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedState.setDescription("current state of fixed entry. unresolved entries are in 'polling' state.")
rlDnsClv2FixedCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2FixedCounter.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedCounter.setDescription("Number of 'fix' requests for this DNS name & type")
rlDnsClv2FixedTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 6), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2FixedTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedTTL.setDescription('Remaining TTL of resolved fixed entry')
rlDnsClv2FixedTTRefresh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 7), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2FixedTTRefresh.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedTTRefresh.setDescription('Remaining time-to-refresh of resolved fixed entry')
rlDnsClv2FixedTTPolling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 16, 1, 8), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2FixedTTPolling.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2FixedTTPolling.setDescription('Remaining polling-interval time of unresolved fixed entry')
rlDnsClv2ClearCacheTable = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("staticOnly", 1), ("dynamicOnly", 2), ("all", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClv2ClearCacheTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2ClearCacheTable.setDescription("action MIB for clearing DNS cache tables, 'static' option will clear all statically configured hostname-to-IP mappings, 'dynamic' option will clear both negative & positive cache from dynamic (DNS) entries, 'all' will clear all entries (static & dynamic) in static, positive & negative cache.")
rlDnsClv2UnifiedCacheTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18), )
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheTable.setDescription('Unified DNS Cache Table (static,dynamic & fixed entries). This is a read-only MIB for presentation purposes.')
rlDnsClv2UnifiedCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClv2UnifiedCacheName"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2UnifiedCacheSource"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2UnifiedCacheState"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2UnifiedCacheType"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClv2UnifiedCacheIndex"))
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheEntry.setDescription('The row definition for this table.')
rlDnsClv2UnifiedCacheName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheName.setDescription('The requested domain name')
rlDnsClv2UnifiedCacheSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("fixed", 3))))
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheSource.setDescription('The cache entry source (static/dynamic/fixed).')
rlDnsClv2UnifiedCacheState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("ne", 2), ("un", 3))))
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheState.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheState.setDescription('The state of the current cache entry')
rlDnsClv2UnifiedCacheType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv6", 1), ("ipv4", 2))))
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheType.setDescription("IP address type of the Resource Record in the cache which is identified in this row of the table. for negative/unresolved entries the 'noResolution' value is returned.")
rlDnsClv2UnifiedCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 5), Integer32())
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheIndex.setDescription('A value which makes entries in the table unique when the other index values do not provide a unique index.')
rlDnsClv2UnifiedCacheInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheInetAddrType.setDescription('The INET address type of rlDnsClv2UnifiedCacheInetAddr, for e.g IPv4, IPv6, IPv6z or UNKNOWN')
rlDnsClv2UnifiedCacheInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheInetAddr.setDescription('Resolved IP Address of given Domain-Name')
rlDnsClv2UnifiedCacheTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 8), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheTTL.setDescription('Time-To-Live of RR in DNS cache. This is the initial TTL value which was received with the RR when it was originally received. for unresolved entries, will return the polling interval instead of TTL')
rlDnsClv2UnifiedCacheRemainingTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 9), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheRemainingTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCacheRemainingTTL.setDescription('Remaining TTL seconds since RR was received. For unresolved entries, will return remaining time till next retry')
rlDnsClv2UnifiedCachePrettyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 18, 1, 10), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClv2UnifiedCachePrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCachePrettyName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClv2UnifiedCachePrettyName.setDescription('Name of the RR at this row in the table. This is identical to the rlDnsClv2UnifiedCacheName variable, except that character case is preserved in this variable, per DNS conventions.')
rlDnsClMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsClMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMibVersion.setDescription("MIB's version, the current version is 1.")
rlDnsClEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClEnable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClEnable.setDescription('Enable or Disable the use of the DNS client feature.')
rlDnsClDomainNameTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 3), )
if mibBuilder.loadTexts: rlDnsClDomainNameTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameTable.setDescription('The domain names table.')
rlDnsClDomainNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 3, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClDomainNameName"))
if mibBuilder.loadTexts: rlDnsClDomainNameEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameEntry.setDescription(' The row definition for this table.')
rlDnsClDomainNameName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 3, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClDomainNameName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameName.setDescription('The domain name for this ifIndex.')
rlDnsClDomainNameOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("dhcpv6", 3))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClDomainNameOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameOwner.setDescription('The Domain Name owner. Static if Domain Name defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClDomainNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClDomainNameRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClDomainNameRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsClMaxNumOfRetransmissions = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClMaxNumOfRetransmissions.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMaxNumOfRetransmissions.setDescription('The maximum number of retransmissions for each query.')
rlDnsClMinRetransmissionInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClMinRetransmissionInterval.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMinRetransmissionInterval.setDescription('The minimum number of seconds that must elapsed before retransmission for each query.')
rlDnsClNamesTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6), )
if mibBuilder.loadTexts: rlDnsClNamesTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesTable.setDescription('The Names table.')
rlDnsClNamesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesName"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesOwner"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesIndex"))
if mibBuilder.loadTexts: rlDnsClNamesEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesEntry.setDescription(' The row definition for this table.')
rlDnsClNamesName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClNamesName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesName.setDescription('The host name.')
rlDnsClNamesOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("dhcpv6", 3))).clone('static'))
if mibBuilder.loadTexts: rlDnsClNamesOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesOwner.setDescription('The Host Name Entry owner. Static if Host Name Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClNamesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6, 1, 3), Integer32())
if mibBuilder.loadTexts: rlDnsClNamesIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsClNamesName) do not provide a unique index.')
rlDnsClNamesAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesAddr.setDescription('The host IP address')
rlDnsClNamesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 6, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsResConfigSbeltExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 7), )
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtTable.setDescription('Augmenting rlDnsResConfigSbeltTable (dns resolver safety belt table) for added info')
rlDnsResConfigSbeltExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 7, 1), )
dnsResConfigSbeltEntry.registerAugmentions(("CISCOSB-DNSCL-MIB", "rlDnsResConfigSbeltExtEntry"))
rlDnsResConfigSbeltExtEntry.setIndexNames(*dnsResConfigSbeltEntry.getIndexNames())
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtEntry.setDescription('A row of the table rlDnsResConfigSbeltTable Extended by this definition.')
rlDnsResConfigSbeltOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("dhcpv6", 3))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResConfigSbeltOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltOwner.setDescription('The DNS server Entry owner. Static if DNS server Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClNamesInetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8), )
if mibBuilder.loadTexts: rlDnsClNamesInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetTable.setDescription('The Names table.')
rlDnsClNamesInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesInetName"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesInetOwner"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesInetIndex"), (0, "CISCOSB-DNSCL-MIB", "rlDnsClNamesInetRRType"))
if mibBuilder.loadTexts: rlDnsClNamesInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetEntry.setDescription(' The row definition for this table.')
rlDnsClNamesInetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsClNamesInetName.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetName.setDescription('The host name.')
rlDnsClNamesInetOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("dhcpv6", 3))).clone('static'))
if mibBuilder.loadTexts: rlDnsClNamesInetOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetOwner.setDescription('The Host Name Entry owner. Static if Host Name Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClNamesInetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 3), Integer32())
if mibBuilder.loadTexts: rlDnsClNamesInetIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsClNamesName) do not provide a unique index.')
rlDnsClNamesInetRRType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 4), DnsType())
if mibBuilder.loadTexts: rlDnsClNamesInetRRType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetRRType.setDescription("DNS type of the Resource Record in the cache which is identified in this row of the table. The user can configure 'a' or 'aaaa' types only.")
rlDnsClNamesInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 5), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetAddrType.setDescription('The address type of rlDnsResNCacheErrInetSource. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsClNamesInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetAddr.setDescription('The host IP address')
rlDnsClNamesInetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 8, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClNamesInetRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsClNamesInetRowStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
rlDnsResConfigSbeltInetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9), )
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetTable.setDescription("Table of safety belt information used by the resolver when it hasn't got any better idea of where to send a query, such as when the resolver is booting or is a stub resolver.")
rlDnsResConfigSbeltInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsResConfigSbeltInetAddrType"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResConfigSbeltInetAddr"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResConfigSbeltInetSubTree"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResConfigSbeltInetClass"))
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetEntry.setDescription("An entry in the resolver's Sbelt table. Rows may be created or deleted at any time by the DNS resolver and by SNMP SET requests. Whether the values changed via SNMP are saved in stable storage across `reset' operations is implementation-specific.")
rlDnsResConfigSbeltInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddrType.setDescription('The address type of rlDnsResConfigSbeltInetAddr. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsResConfigSbeltInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetAddr.setDescription('The IP address of the Sbelt name server identified by this row of the table.')
rlDnsResConfigSbeltInetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 3), DnsName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetName.setDescription('The DNS name of a Sbelt nameserver identified by this row of the table. A zero-length string indicates that the name is not known by the resolver.')
rlDnsResConfigSbeltInetRecursion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("iterative", 1), ("recursive", 2), ("recursiveAndIterative", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetRecursion.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetRecursion.setDescription('Kind of queries resolver will be sending to the name server identified in this row of the table: iterative(1) indicates that resolver will be directing iterative queries to this name server (RD bit turned off). recursive(2) indicates that resolver will be directing recursive queries to this name server (RD bit turned on). recursiveAndIterative(3) indicates that the resolver will be directing both recursive and iterative queries to the server identified in this row of the table.')
rlDnsResConfigSbeltInetPref = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetPref.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetPref.setDescription('This value identifies the preference for the name server identified in this row of the table. The lower the value, the more desirable the resolver considers this server.')
rlDnsResConfigSbeltInetSubTree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 6), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetSubTree.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetSubTree.setDescription('Queries sent to the name server identified by this row of the table are limited to those for names in the name subtree identified by this variable. If no such limitation applies, the value of this variable is the name of the root domain (a DNS name consisting of a single zero octet).')
rlDnsResConfigSbeltInetClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 7), DnsClass())
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetClass.setDescription('The class of DNS queries that will be sent to the server identified by this row of the table.')
rlDnsResConfigSbeltInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 9, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetStatus.setDescription('Row status column for this row of the Sbelt table.')
rlDnsResCacheRRInetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10), )
if mibBuilder.loadTexts: rlDnsResCacheRRInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetTable.setDescription("This table contains information about all the resource records currently in the resolver's cache.")
rlDnsResCacheRRInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsResCacheRRInetName"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResCacheRRInetClass"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResCacheRRInetType"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResCacheRRInetIndex"))
if mibBuilder.loadTexts: rlDnsResCacheRRInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetEntry.setDescription("An entry in the resolvers's cache. Rows may be created only by the resolver. SNMP SET requests may be used to delete rows.")
rlDnsResCacheRRInetName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsResCacheRRInetName.setReference('RFC-1034 section 3.6.')
if mibBuilder.loadTexts: rlDnsResCacheRRInetName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetName.setDescription('Owner name of the Resource Record in the cache which is identified in this row of the table. As described in RFC-1034, the owner of the record is the domain name were the RR is found.')
rlDnsResCacheRRInetClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 2), DnsClass())
if mibBuilder.loadTexts: rlDnsResCacheRRInetClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetClass.setDescription('DNS class of the Resource Record in the cache which is identified in this row of the table.')
rlDnsResCacheRRInetType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 3), DnsType())
if mibBuilder.loadTexts: rlDnsResCacheRRInetType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetType.setDescription('DNS type of the Resource Record in the cache which is identified in this row of the table.')
rlDnsResCacheRRInetTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 4), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetTTL.setDescription('Time-To-Live of RR in DNS cache. This is the initial TTL value which was received with the RR when it was originally received.')
rlDnsResCacheRRInetElapsedTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetElapsedTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetElapsedTTL.setDescription('Elapsed seconds since RR was received.')
rlDnsResCacheRRInetSourceAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetSourceAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetSourceAddrType.setDescription('The address type of rlDnsResCacheRRInetSource. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsResCacheRRInetSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetSource.setDescription('Host from which RR was received, 0.0.0.0 if unknown.')
rlDnsResCacheRRInetData = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetData.setReference('RFC-1035 section 3.2.1.')
if mibBuilder.loadTexts: rlDnsResCacheRRInetData.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetData.setDescription('RDATA portion of a cached RR. The value is in the format defined for the particular DNS class and type of the resource record.')
rlDnsResCacheRRInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResCacheRRInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetStatus.setDescription('Status column for the resolver cache table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
rlDnsResCacheRRInetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 10), Integer32())
if mibBuilder.loadTexts: rlDnsResCacheRRInetIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsResCacheRRName, rlDnsResCacheRRClass, and rlDnsResCacheRRType) do not provide a unique index.')
rlDnsResCacheRRInetPrettyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 10, 1, 11), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResCacheRRInetPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: rlDnsResCacheRRInetPrettyName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResCacheRRInetPrettyName.setDescription('Name of the RR at this row in the table. This is identical to the rlDnsResCacheRRName variable, except that character case is preserved in this variable, per DNS conventions.')
rlDnsResNCacheErrInetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11), )
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTable.setDescription("The resolver's negative response cache. This table contains information about authoritative errors that have been cached by the resolver.")
rlDnsResNCacheErrInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1), ).setIndexNames((0, "CISCOSB-DNSCL-MIB", "rlDnsResNCacheErrInetQName"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResNCacheErrInetQClass"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResNCacheErrInetQType"), (0, "CISCOSB-DNSCL-MIB", "rlDnsResNCacheErrInetIndex"))
if mibBuilder.loadTexts: rlDnsResNCacheErrInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetEntry.setDescription("An entry in the resolver's negative response cache table. Only the resolver can create rows. SNMP SET requests may be used to delete rows.")
rlDnsResNCacheErrInetQName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQName.setReference('RFC-1034 section 3.7.1.')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQName.setDescription('QNAME associated with a cached authoritative error.')
rlDnsResNCacheErrInetQClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 2), DnsQClass())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQClass.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQClass.setDescription('DNS QCLASS associated with a cached authoritative error.')
rlDnsResNCacheErrInetQType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 3), DnsQType())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetQType.setDescription('DNS QTYPE associated with a cached authoritative error.')
rlDnsResNCacheErrInetTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 4), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTTL.setReference('RFC-1034 section 4.3.4.')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetTTL.setDescription('Time-To-Live of a cached authoritative error at the time of the error, it should not be decremented by the number of seconds since it was received. This should be the TTL as copied from the MINIMUM field of the SOA that accompanied the authoritative error, or a smaller value if the resolver implements a ceiling on negative response cache TTLs.')
rlDnsResNCacheErrInetElapsedTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetElapsedTTL.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetElapsedTTL.setDescription('Elapsed seconds since authoritative error was received.')
rlDnsResNCacheErrInetSourceAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSourceAddrType.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSourceAddrType.setDescription('The address type of rlDnsResNCacheErrInetSource. Only IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or unknown(0) if datagrams for all local IP addresses are accepted.')
rlDnsResNCacheErrInetSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSource.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetSource.setDescription('Host which sent the authoritative error, 0.0.0.0 if unknown.')
rlDnsResNCacheErrInetCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nonexistantName", 1), ("noData", 2), ("other", 3), ("unresolved", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetCode.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetCode.setDescription("The authoritative error that has been cached: nonexistantName(1) indicates an authoritative name error (RCODE = 3). noData(2) indicates an authoritative response with no error (RCODE = 0) and no relevant data. other(3) indicates some other cached authoritative error. At present, no such errors are known to exist. unresolved(4) is used for 'fixed' entries that are currently unresolved.")
rlDnsResNCacheErrInetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetStatus.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetStatus.setDescription('Status column for the resolver negative response cache table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
rlDnsResNCacheErrInetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 10), Integer32())
if mibBuilder.loadTexts: rlDnsResNCacheErrInetIndex.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetIndex.setDescription('A value which makes entries in the table unique when the other index values (rlDnsResNCacheErrQName, rlDnsResNCacheErrQClass, and rlDnsResNCacheErrQType) do not provide a unique index.')
rlDnsResNCacheErrInetPrettyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 11, 1, 11), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDnsResNCacheErrInetPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetPrettyName.setStatus('current')
if mibBuilder.loadTexts: rlDnsResNCacheErrInetPrettyName.setDescription('QNAME associated with this row in the table. This is identical to the rlDnsResNCacheErrQName variable, except that character case is preserved in this variable, per DNS conventions.')
rlDnsResConfigSbeltExtInetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 12), )
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetTable.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetTable.setDescription('Augmenting rlDnsResConfigSbeltInetTable (dns resolver safety belt table) for added info')
rlDnsResConfigSbeltExtInetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 12, 1), )
rlDnsResConfigSbeltInetEntry.registerAugmentions(("CISCOSB-DNSCL-MIB", "rlDnsResConfigSbeltExtInetEntry"))
rlDnsResConfigSbeltExtInetEntry.setIndexNames(*rlDnsResConfigSbeltInetEntry.getIndexNames())
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetEntry.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltExtInetEntry.setDescription('A row of the table rlDnsResConfigSbeltInetTable Extended by this definition.')
rlDnsResConfigSbeltInetOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("dhcpv6", 3))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetOwner.setStatus('current')
if mibBuilder.loadTexts: rlDnsResConfigSbeltInetOwner.setDescription('The DNS server Entry owner. Static if DNS server Entry defined by user, dhcp if received by boot protocol like DHCP.')
rlDnsClMinPollingInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 93, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDnsClMinPollingInterval.setStatus('current')
if mibBuilder.loadTexts: rlDnsClMinPollingInterval.setDescription('The minimum number of seconds that must elapsed between invocations of the resolving procedure for fixed DNS entries which are currently unresolved.')
mibBuilder.exportSymbols("CISCOSB-DNSCL-MIB", rlDnsResConfigSbeltInetAddr=rlDnsResConfigSbeltInetAddr, rlDnsResCacheRRInetData=rlDnsResCacheRRInetData, rlDnsClv2UnifiedCacheTable=rlDnsClv2UnifiedCacheTable, rlDnsClv2UnifiedCacheState=rlDnsClv2UnifiedCacheState, rlDnsResNCacheErrInetPrettyName=rlDnsResNCacheErrInetPrettyName, rlDnsResNCacheErrInetIndex=rlDnsResNCacheErrInetIndex, rlDnsClNamesInetName=rlDnsClNamesInetName, rlDnsClv2UnifiedCacheEntry=rlDnsClv2UnifiedCacheEntry, rlDnsClv2DomainNamePreference=rlDnsClv2DomainNamePreference, rlDnsClNamesInetTable=rlDnsClNamesInetTable, rlDnsClEnable=rlDnsClEnable, rlDnsClv2UnifiedCacheType=rlDnsClv2UnifiedCacheType, rlDnsClv2DomainNameRowStatus=rlDnsClv2DomainNameRowStatus, rlDnsResConfigSbeltInetTable=rlDnsResConfigSbeltInetTable, rlDnsClNamesEntry=rlDnsClNamesEntry, rlDnsResConfigSbeltInetSubTree=rlDnsResConfigSbeltInetSubTree, rlDnsClDomainNameEntry=rlDnsClDomainNameEntry, rlDnsClNamesInetAddr=rlDnsClNamesInetAddr, rlDnsClv2UnifiedCacheRemainingTTL=rlDnsClv2UnifiedCacheRemainingTTL, rlDnsClDomainNameRowStatus=rlDnsClDomainNameRowStatus, rlDnsClv2UnifiedCacheIndex=rlDnsClv2UnifiedCacheIndex, rlDnsClv2FixedName=rlDnsClv2FixedName, rlDnsResNCacheErrInetElapsedTTL=rlDnsResNCacheErrInetElapsedTTL, rlDnsClv2UnifiedCacheInetAddrType=rlDnsClv2UnifiedCacheInetAddrType, rlDnsResConfigSbeltExtTable=rlDnsResConfigSbeltExtTable, rlDnsResCacheRRInetClass=rlDnsResCacheRRInetClass, rlDnsResCacheRRInetIndex=rlDnsResCacheRRInetIndex, rlDnsResConfigSbeltInetOwner=rlDnsResConfigSbeltInetOwner, rlDnsResConfigSbeltInetEntry=rlDnsResConfigSbeltInetEntry, rlDnsClv2FixedPrettyName=rlDnsClv2FixedPrettyName, rlDnsResCacheRRInetPrettyName=rlDnsResCacheRRInetPrettyName, rlDnsClv2ServersClass=rlDnsClv2ServersClass, rlDnsResCacheRRInetTTL=rlDnsResCacheRRInetTTL, rlDnsClv2ServersEntry=rlDnsClv2ServersEntry, rlDnsClv2FixedTTRefresh=rlDnsClv2FixedTTRefresh, rlDnsResConfigSbeltInetAddrType=rlDnsResConfigSbeltInetAddrType, rlDnsClv2DomainNameIfIndex=rlDnsClv2DomainNameIfIndex, rlDnsClv2FixedEntry=rlDnsClv2FixedEntry, rlDnsClv2ServersSource=rlDnsClv2ServersSource, rlDnsClNamesInetIndex=rlDnsClNamesInetIndex, rlDnsClNamesName=rlDnsClNamesName, rlDnsResConfigSbeltExtEntry=rlDnsResConfigSbeltExtEntry, rlDnsClv2UnifiedCacheInetAddr=rlDnsClv2UnifiedCacheInetAddr, rlDnsClNamesInetRRType=rlDnsClNamesInetRRType, rlDnsClv2DomainNameName=rlDnsClv2DomainNameName, rlDnsClNamesOwner=rlDnsClNamesOwner, rlDnsResCacheRRInetSourceAddrType=rlDnsResCacheRRInetSourceAddrType, rlDnsResNCacheErrInetTTL=rlDnsResNCacheErrInetTTL, rlDnsResNCacheErrInetStatus=rlDnsResNCacheErrInetStatus, rlDnsResCacheRRInetType=rlDnsResCacheRRInetType, rlDnsClv2ServersSubTree=rlDnsClv2ServersSubTree, rlDnsClv2ServersIfIndex=rlDnsClv2ServersIfIndex, rlDnsClv2DomainNameSource=rlDnsClv2DomainNameSource, rlDnsResNCacheErrInetQName=rlDnsResNCacheErrInetQName, rlDnsClv2UnifiedCacheSource=rlDnsClv2UnifiedCacheSource, rlDnsResConfigSbeltExtInetEntry=rlDnsResConfigSbeltExtInetEntry, rlDnsResCacheRRInetName=rlDnsResCacheRRInetName, rlDnsCl=rlDnsCl, rlDnsResCacheRRInetTable=rlDnsResCacheRRInetTable, rlDnsClv2FixedType=rlDnsClv2FixedType, rlDnsClNamesInetRowStatus=rlDnsClNamesInetRowStatus, rlDnsClv2ServersTable=rlDnsClv2ServersTable, rlDnsResNCacheErrInetQType=rlDnsResNCacheErrInetQType, rlDnsClNamesInetOwner=rlDnsClNamesInetOwner, rlDnsClv2DomainNameTable=rlDnsClv2DomainNameTable, rlDnsResConfigSbeltOwner=rlDnsResConfigSbeltOwner, rlDnsClv2FixedTTL=rlDnsClv2FixedTTL, rlDnsResCacheRRInetElapsedTTL=rlDnsResCacheRRInetElapsedTTL, rlDnsClNamesAddr=rlDnsClNamesAddr, rlDnsResNCacheErrInetSourceAddrType=rlDnsResNCacheErrInetSourceAddrType, rlDnsResConfigSbeltInetRecursion=rlDnsResConfigSbeltInetRecursion, PYSNMP_MODULE_ID=rlDnsCl, rlDnsClMaxNumOfRetransmissions=rlDnsClMaxNumOfRetransmissions, rlDnsResCacheRRInetStatus=rlDnsResCacheRRInetStatus, rlDnsClv2FixedTTPolling=rlDnsClv2FixedTTPolling, rlDnsClNamesRowStatus=rlDnsClNamesRowStatus, rlDnsClNamesInetAddrType=rlDnsClNamesInetAddrType, rlDnsClDomainNameOwner=rlDnsClDomainNameOwner, rlDnsClNamesIndex=rlDnsClNamesIndex, rlDnsClNamesTable=rlDnsClNamesTable, rlDnsResNCacheErrInetCode=rlDnsResNCacheErrInetCode, rlDnsResNCacheErrInetQClass=rlDnsResNCacheErrInetQClass, rlDnsClMinRetransmissionInterval=rlDnsClMinRetransmissionInterval, rlDnsClDomainNameTable=rlDnsClDomainNameTable, rlDnsResCacheRRInetSource=rlDnsResCacheRRInetSource, rlDnsClv2ServersPreference=rlDnsClv2ServersPreference, rlDnsClDomainNameName=rlDnsClDomainNameName, rlDnsResNCacheErrInetTable=rlDnsResNCacheErrInetTable, rlDnsClMinPollingInterval=rlDnsClMinPollingInterval, rlDnsClv2UnifiedCachePrettyName=rlDnsClv2UnifiedCachePrettyName, rlDnsClv2FixedCounter=rlDnsClv2FixedCounter, rlDnsClv2UnifiedCacheName=rlDnsClv2UnifiedCacheName, rlDnsResNCacheErrInetEntry=rlDnsResNCacheErrInetEntry, rlDnsResConfigSbeltInetName=rlDnsResConfigSbeltInetName, rlDnsClv2UnifiedCacheTTL=rlDnsClv2UnifiedCacheTTL, rlDnsClv2FixedState=rlDnsClv2FixedState, rlDnsResCacheRRInetEntry=rlDnsResCacheRRInetEntry, rlDnsClv2ServersRowStatus=rlDnsClv2ServersRowStatus, rlDnsResNCacheErrInetSource=rlDnsResNCacheErrInetSource, rlDnsClMibVersion=rlDnsClMibVersion, rlDnsClv2ServersInetAddr=rlDnsClv2ServersInetAddr, rlDnsClv2DomainNameEntry=rlDnsClv2DomainNameEntry, rlDnsClNamesInetEntry=rlDnsClNamesInetEntry, rlDnsResConfigSbeltInetClass=rlDnsResConfigSbeltInetClass, rlDnsResConfigSbeltInetStatus=rlDnsResConfigSbeltInetStatus, rlDnsResConfigSbeltExtInetTable=rlDnsResConfigSbeltExtInetTable, rlDnsClv2FixedTable=rlDnsClv2FixedTable, rlDnsClv2ServersAddrType=rlDnsClv2ServersAddrType, rlDnsResConfigSbeltInetPref=rlDnsResConfigSbeltInetPref, rlDnsClv2ClearCacheTable=rlDnsClv2ClearCacheTable)

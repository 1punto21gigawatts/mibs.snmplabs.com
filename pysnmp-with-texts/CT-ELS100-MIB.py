#
# PySNMP MIB module CT-ELS100-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CT-ELS100-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:28:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ifOutErrors, ifInErrors = mibBuilder.importSymbols("IF-MIB", "ifOutErrors", "ifInErrors")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysObjectID, = mibBuilder.importSymbols("SNMPv2-MIB", "sysObjectID")
NotificationType, Integer32, ModuleIdentity, Unsigned32, NotificationType, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter64, TimeTicks, Gauge32, iso, ObjectIdentity, MibIdentifier, Counter32, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Integer32", "ModuleIdentity", "Unsigned32", "NotificationType", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter64", "TimeTicks", "Gauge32", "iso", "ObjectIdentity", "MibIdentifier", "Counter32", "enterprises")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
sigma = MibIdentifier((1, 3, 6, 1, 4, 1, 97))
sys = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 1))
els_100 = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8)).setLabel("els-100")
kxhw = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 1))
kxsw = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 2))
kxadmin = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 3))
kxswdis = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 4))
kxaddr = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 5))
kxif = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 6))
kxuart = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 7))
kxproto = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 8))
kxtrunk = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 9))
kxworkgroup = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 10))
kxtrapMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 11))
kxmirrorgroup = MibIdentifier((1, 3, 6, 1, 4, 1, 97, 8, 12))
sysID = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8))).clone(namedValues=NamedValues(("els-100-bridge", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysID.setStatus('mandatory')
if mibBuilder.loadTexts: sysID.setDescription('An integer which serves to identify the type of SmartStack.')
sysReset = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysReset.setStatus('mandatory')
if mibBuilder.loadTexts: sysReset.setDescription('The time, in centiseconds, before the device should reboot. A GetResponse value of zero indicates that no reboot time has been specified.')
sysTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysTrapPort.setDescription('Zero, or the UDP port number to which a second copy of SNMP traps should be sent. Valid values are zero through 65535.')
kxhwDiagCode = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxhwDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: kxhwDiagCode.setDescription("Additional diagnostics information concerning the slot's module.")
kxhwManufData = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxhwManufData.setStatus('mandatory')
if mibBuilder.loadTexts: kxhwManufData.setDescription('A 24-byte array which contains the part number, serial number and hardware revision level of this module.')
kxhwPortCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxhwPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: kxhwPortCount.setDescription('')
kxswNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswNumber.setStatus('mandatory')
if mibBuilder.loadTexts: kxswNumber.setDescription('The number of file sets. The default is 2.')
kxswFilesetTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 2, 2), )
if mibBuilder.loadTexts: kxswFilesetTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxswFilesetTable.setDescription('A list of the software file sets stored. The first file set refers to the one that was used when ELS-100 last booted. The second file set refers to the one which will be used when ELS-100 reboots or reloads any hardware module.')
kxswFilesetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxswIndex"))
if mibBuilder.loadTexts: kxswFilesetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxswFilesetEntry.setDescription('A set of objects for each file set.')
kxswIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currently-executing", 1), ("next-boot", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxswIndex.setDescription("The file set number, beginning with 1 for the first file set. This number always matches the instance of the swFiles. For example, {swIndex 2} contains the value '2'.")
kxswDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswDesc.setStatus('mandatory')
if mibBuilder.loadTexts: kxswDesc.setDescription('The description (0-255 bytes) of the software file set.')
kxswCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswCount.setStatus('mandatory')
if mibBuilder.loadTexts: kxswCount.setDescription('The number of files in the file set. This number may range from 1 to 255.')
kxswType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswType.setStatus('mandatory')
if mibBuilder.loadTexts: kxswType.setDescription('The types of the files within the file set.')
kxswSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswSizes.setStatus('mandatory')
if mibBuilder.loadTexts: kxswSizes.setDescription('An array (4 octets per file), containing the size of each of the files. Each size is encoded as a series of 4 bytes, which should be converted into a 32 bit integer.')
kxswStarts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswStarts.setStatus('mandatory')
if mibBuilder.loadTexts: kxswStarts.setDescription("An array (4 octets per file), containing the software's execution starting address of each of the files. Each address is encoded as a series of 4 bytes, which should be converted into a 32 bit integer.")
kxswBases = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswBases.setStatus('mandatory')
if mibBuilder.loadTexts: kxswBases.setDescription("An array (4 octets per file), containing the software's base loading address of each of the files. Each address is encoded as a series of 4 bytes, which should be converted into a 32 bit integer.")
kxswFlashBank = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("first-bank", 1), ("second-bank", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswFlashBank.setStatus('mandatory')
if mibBuilder.loadTexts: kxswFlashBank.setDescription('The bank number where the software file set resides.')
kxadminFatalErr = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminFatalErr.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminFatalErr.setDescription('This is a 32 byte array which contains information about the cause of the previous system reset. This will describe the circumstances which forced the system software to perform a reboot. The values in the first byte have the following meanings (0) Power failure, (1) Watchdog Timeout, (2) NMS Requested Shutdown, (3-255) Fatal Error (next byte contains the hwIndex of the module which encountered the error; remaining 30 bytes contain additional information).')
kxadminAnyPass = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminAnyPass.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminAnyPass.setDescription('The authentication password (0-24 bytes) which must match the community name in an SNMP PDU, in order for the operation to be performed. A zero length password indicates that any community name is acceptable.')
kxadminGetPass = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminGetPass.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminGetPass.setDescription('The authentication password (0-24 bytes) which must match the community name in an SNMP Get PDU (except for Debug or password parameters). A zero length password indicates that any community name is acceptable. Alternatively, it is acceptable if the community name matches configAnyPass.')
kxadminNMSIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminNMSIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminNMSIPAddr.setDescription('The address of the NMS to which Trap PDUs are to be sent. A value of zero indicates that Trap PDUs should be sent to the NMS last heard from.')
kxadminStorageFailure = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminStorageFailure.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminStorageFailure.setDescription("Whether the ELS-100's storage facility for its configuration parameters has failed (the ELS-100 may not be able to reboot after such a failure).")
kxadminAuthenticationFailure = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminAuthenticationFailure.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminAuthenticationFailure.setDescription('All nulls, or the IP source address within the last SNMP PDU which caused an SNMP authentication failure.')
kxadminNAMReceiveCongests = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminNAMReceiveCongests.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminNAMReceiveCongests.setDescription('')
kxadminArpEntries = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminArpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminArpEntries.setDescription('The number of ARP entries for all interfaces.')
kxadminArpStatics = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminArpStatics.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminArpStatics.setDescription('The number of statically defined ARP entries for all interfaces.')
kxadminArpOverflows = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminArpOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminArpOverflows.setDescription('The number of times a ARP entry could not be learned due to insufficient address table space.')
kxadminRipPreference = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminRipPreference.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminRipPreference.setDescription('The value to assign to ipRouteMetric2, when adding a RIP-learned entry to the IP Routing Table.')
kxadminRipRouteDiscards = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxadminRipRouteDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminRipRouteDiscards.setDescription('The number of times a route learned via RIP was not added to the IP Routing Table due to insufficient Routing Table space.')
kxadminRebootConfig = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-change", 1), ("tftp-config", 2), ("revert-to-defaults", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminRebootConfig.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminRebootConfig.setDescription('The configuration file that will be used when the ELS-100 reboots. This parameter is normally automatically set by the ELS-100; however, an NMS may explicitly set it to either no-change (1) or revert-to-defaults (3).')
kxadminDisableButton = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminDisableButton.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminDisableButton.setDescription('')
kxadminButtonSelection = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("led-any-activity", 1), ("led-rx-activity", 2), ("led-tx-activity", 3), ("led-any-collision", 4), ("led-programmed", 5), ("led-duplex", 6), ("led-speed", 7), ("led-mirror", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminButtonSelection.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminButtonSelection.setDescription('')
kxadminLEDProgramOption = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("program-led-any-error", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxadminLEDProgramOption.setStatus('mandatory')
if mibBuilder.loadTexts: kxadminLEDProgramOption.setDescription('')
kxswdisDesc = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 4, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswdisDesc.setStatus('mandatory')
if mibBuilder.loadTexts: kxswdisDesc.setDescription('The description (0-32 bytes) of the software set currently being downloaded, or a description of the software set last downloaded since the ELS100-16 booted.')
kxswdisAccess = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("protected", 1), ("any-software", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxswdisAccess.setStatus('mandatory')
if mibBuilder.loadTexts: kxswdisAccess.setDescription('The version of software that may be downloaded. Attempts to download other versions of software will be rejected. The value for swdisAccess is embedded within the software files that are to be distributed via TFTP. Its value may be derived from the names of the software files. The NMS operator may wish to use the following special values: protected (1) No software downloads will be accepted any-software (2) A software download of any version of new software will be accepted - this is the factory default')
kxswdisWriteStatus = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("in-progress", 1), ("success", 2), ("config-error", 3), ("flash-error", 4), ("config-and-flash-errors", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxswdisWriteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: kxswdisWriteStatus.setDescription('The status of the erase/write operation.')
kxswdisConfigIp = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 4, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxswdisConfigIp.setStatus('mandatory')
if mibBuilder.loadTexts: kxswdisConfigIp.setDescription('The IP address of the NMS (i.e., any IP host) that is allowed to use TFTP to send/retrieve the configuration file of the ELS100-16. A value of 0.0.0.0 (which is the factory specified default) prevents any NMS from obtaining access, while a value of 255.255.255.255 gives every NMS permission.')
kxswdisConfigRetryTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 4, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxswdisConfigRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: kxswdisConfigRetryTime.setDescription('The number of seconds that the ELS-100 will wait for an acknowledgment before it retransmits an unacknowledged TFTP data block. The factory specified default is 5 seconds.')
kxswdisConfigTotalTimeout = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxswdisConfigTotalTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: kxswdisConfigTotalTimeout.setDescription('The number of seconds that the ELS-100 will wait for an acknowledgment to a data block before it cancels a TFTP session. The factory specified default is 25 seconds.')
kxaddrStatics = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxaddrStatics.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrStatics.setDescription('The number of static addresses which are currently stored in the ELS100-16.')
kxaddrDynamics = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxaddrDynamics.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrDynamics.setDescription('The number of learned addresses in the address table.')
kxaddrDynamicMax = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 3), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrDynamicMax.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrDynamicMax.setDescription('The maximum number of spanning tree addresses which have been learned since the ELS100-16 was last booted (or this parameter was last reset by the NMS).')
kxaddrDynamicOverflows = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxaddrDynamicOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrDynamicOverflows.setDescription('The number times an address was not learned due to insufficient address table space.')
kxaddrFlags = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrFlags.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrFlags.setDescription('Flags to describe the use and control of this address entry. Each bit has a different meaning. The NMS must always set either entry-static, entry-none, or entry-mesh; however, for GetRequests, the NMS will see either no bits set (if the entry does not exist), or exactly one of the following bits set: entry-dynamic-local = 30, entry-dynamic-remote = 29, entry-static = 28, entry-other = 27, entry-none = 26, entry-mesh = 25, entry-statistics = 24, Bit 31 is reserved. Any combination of the restriction bits (bits 23-21) may be set for any type of entry, except entry-other or entry-mesh: entry-no-source = 23, entry-no-multi = 22, Bit 21 is reserved, Bits 20-18 are reserved. Exactly one of the special entry bits (bits 17-10) must be set for entry-other entries, and none of the bits may be set for other than entry-other entries: entry-all-lmas = 17, entry-any-lma = 16, entry-lma = 15, entry-port = 14, entry-bpdu = 13, entry-reserved = 12, Bits 11-10 are reserved for future expansion. Bits 9-0 are reserved.')
kxaddrMAC = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrMAC.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrMAC.setDescription('The MAC address for this address definition.')
kxaddrPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrPort.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrPort.setDescription('The port through which this address is connected to the ELS100 (only valid for entry-dynamic-local, entry-statistics, and entry-port entries).')
kxaddrOperation = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6))).clone(namedValues=NamedValues(("read-random", 1), ("read-next", 2), ("update", 4), ("delete", 5), ("read-block", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrOperation.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrOperation.setDescription('The operation to be performed upon the described address. The possibilities include: read-random (1), read-next (2), update (4), delete (5), read-block (6).')
kxaddrIndex = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrIndex.setDescription('The index number to be used for read-next and read-block operations. When the ELS-100 boots, addrIndex is initialized to -1.')
kxaddrNext = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrNext.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrNext.setDescription('The next value to use for addrIndex, when you use read-next or read-block operations to read the address table. When the ELS-100 boots, addrNext is initialized to -1.')
kxaddrBlockSize = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrBlockSize.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrBlockSize.setDescription('The number of addresses contained by addrBlock. This parameter is only used for dumping blocks of MAC addresses.')
kxaddrBlock = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 5, 12), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxaddrBlock.setStatus('mandatory')
if mibBuilder.loadTexts: kxaddrBlock.setDescription('A series of 0-700 octets, which represents 0-100 addresses. Each address consists of a 6 octet MAC address followed by a 1 byte port number. If the port number is zero, then the address is that of a specially configured address; otherwise, the address is a dynamically learned address. This parameter is only used for dumping blocks of MAC addresses')
kxifTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 6, 1), )
if mibBuilder.loadTexts: kxifTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxifTable.setDescription('A list of interface entries; one per port.')
kxifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxifIndex"))
if mibBuilder.loadTexts: kxifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxifEntry.setDescription('A set of objects for an interface entry.')
kxifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxifIndex.setDescription('The port number, beginning with 1 for the first port.')
kxifRxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxifRxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: kxifRxCnt.setDescription('The number of small data buffers for receiving packets.')
kxifTxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxifTxCnt.setStatus('mandatory')
if mibBuilder.loadTexts: kxifTxCnt.setDescription("The maximum size of the port's transmit queue, i.e., the number of packets that can be in the port's transmit queue, waiting to be transmitted.")
kxifThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxifThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: kxifThreshold.setDescription('Maximum number of combined receive and transmit packet hardware errors before an alarm should be generated.')
kxifThresholdTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxifThresholdTime.setStatus('mandatory')
if mibBuilder.loadTexts: kxifThresholdTime.setDescription('The time period (in seconds) to which kxifThreshold applies. A value of zero will disable the kxifThreshold alarm.')
kxifRxQueueThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxifRxQueueThresh.setStatus('mandatory')
if mibBuilder.loadTexts: kxifRxQueueThresh.setDescription('Maximum number of receive packet queue overflow errors before an alarm should be generated.')
kxifRxQueueThreshTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxifRxQueueThreshTime.setStatus('mandatory')
if mibBuilder.loadTexts: kxifRxQueueThreshTime.setDescription('The time period (in seconds) to which kxifRxQueueThresh applies. A value of zero will disable the kxifRxQueueThresh alarm.')
kxifFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxifFunction.setStatus('mandatory')
if mibBuilder.loadTexts: kxifFunction.setDescription('The current functional state (protocols which have been activated and are operational) of the port. The following values or combinations are supported: 0x0001 NMS, 0x0002 TBRIDGE, 0x0020 UNIT_NO_BPDU 0x0040 UNIT_RIP, 0x0800 UNIT_ARP,0x1000 UNIT_DUPLEX_HALF 0x2000 UNIT_DUPLEX_AUTO, 0x8000 UNIT_AUTO 0x10000 UNIT_TRUNKING , 0x40000 UNIT_SPEED_10 These values can be configured through the protoTable.')
kxifStatisticsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 6, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxifStatisticsTime.setStatus('mandatory')
if mibBuilder.loadTexts: kxifStatisticsTime.setDescription('Length of time during which statistics were collected.')
kxuartTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 7, 1), )
if mibBuilder.loadTexts: kxuartTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxuartTable.setDescription('A list of interface entries; one per UART port.')
kxuartEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 7, 1, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxuartIndex"))
if mibBuilder.loadTexts: kxuartEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxuartEntry.setDescription('A set of objects for an interface entry.')
kxuartIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxuartIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxuartIndex.setDescription("The ELS-100's port number of the port.")
kxuartBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("external-clock", 1), ("b1200-baud", 2), ("b2400-baud", 3), ("b4800-baud", 4), ("b9600-baud", 5), ("b19200-baud", 6), ("b38400-baud", 7), ("b56-kilobits", 8), ("b1544-kilobits", 9), ("b2048-kilobits", 10), ("b45-megabits", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxuartBaud.setStatus('mandatory')
if mibBuilder.loadTexts: kxuartBaud.setDescription('This is the desired baud rate. Only 1200 baud through 19,200 baud are supported by the ELS-100.')
kxuartAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 7, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxuartAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: kxuartAlignmentErrors.setDescription('Number of received packets with frame alignment errors, since the port was last enabled.')
kxuartOverrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxuartOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: kxuartOverrunErrors.setDescription('Number of received packets with data overrun errors, since the port was last enabled.')
kxprotoTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 8, 1), )
if mibBuilder.loadTexts: kxprotoTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoTable.setDescription('This table contains configuration information specifying the types of protocols used to bridge and filter frames for each port.')
kxprotoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 8, 1, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxprotoIfIndex"))
if mibBuilder.loadTexts: kxprotoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoEntry.setDescription('Each entry in this table specifies which protocols are used by a particular port in the SmartStack.')
kxprotoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxprotoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoIfIndex.setDescription("Identifies the interface (port) to which this entry's information belongs. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.")
kxprotoBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("transparent", 1), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxprotoBridge.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoBridge.setDescription('Defines the bridging method to be applied to frames received at, or destined for, this port. Ports may be configured for transparent or none. The UART may only be configured to none.')
kxprotoSuppressBpdu = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("suppressed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxprotoSuppressBpdu.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoSuppressBpdu.setDescription('Allows transmission of spanning tree protocol packets to be suppressed. If normal(1), 802.1d spanning tree packets are transmitted as usual. If suppressed(2), these packets are not transmitted. This option may be needed for interoperability with non-802.1d spanning tree protocols (e.g., DEC LanBridge 100).')
kxprotoRipListen = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxprotoRipListen.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoRipListen.setDescription('Specifies whether the port should listen for internet Routing Information Protocol (RFC-1058) packets, in order to build the routing table for the unit.')
kxprotoTrunking = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxprotoTrunking.setStatus('mandatory')
if mibBuilder.loadTexts: kxprotoTrunking.setDescription('Specifies whether SmartStack trunking protocol (an extension to the standard Spanning Tree) is to be used over this port.')
kxtrunkTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 9, 1), )
if mibBuilder.loadTexts: kxtrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkTable.setDescription('This table describes the trunking status and attributes of the interfaces that are configured for bridge trunking.')
kxtrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxtrunkIfIndex"))
if mibBuilder.loadTexts: kxtrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkEntry.setDescription('An entry exists in this table for each physical interface (port) that is configured for trunking.')
kxtrunkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkIfIndex.setDescription('Identifies a physical interface (port) which is configured for LAN trunking. The value of this variable corresponds to ifIndex, as well as most of the other port identification values in related MIBs.')
kxtrunkState = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 1), ("closed", 2), ("oneway", 3), ("joined", 4), ("perturbed", 5), ("helddown", 6), ("disabled", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkState.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkState.setDescription('If off(1) then this link has not been enabled for trunking. If closed(2) then this link has not yet received any Trunking PDUs. If oneway(3) then incoming Trunking PDUs do not indicate that our PDUs are being successfully received by the far end. If joined(4) then this link is actively participating in the trunk group. If perturbed(5) then this link is actively participating in the trunk group; however, the transmission of data packets has been temporarily stopped due to a change in membership of the group. If helddown(6) then an error has been detected and the link is being held out-of-service until the error clears. If broken(7) then this link has been configured for trunking, but the port is physically non-operational.')
kxtrunkRemoteBridgeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkRemoteBridgeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkRemoteBridgeAddr.setDescription('The MAC address portion of the bridge ID of the remote bridge.')
kxtrunkRemoteIp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkRemoteIp.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkRemoteIp.setDescription('The IP address of the remote bridge, as reported by that bridge for administrative purposes.')
kxtrunkLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("none", 1), ("in-bpdu", 2), ("multiple-bridges", 3), ("ack-lost", 4), ("standby", 5), ("too-many-groups", 6), ("no-ack", 7), ("perturbed-threshold", 8), ("self-connect", 9), ("port-moved", 10), ("multiple-lan-types", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkLastError.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkLastError.setDescription('The last reason for failure when the link is in closed, oneway, or helddown state.')
kxtrunkLinkOrdinal = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkLinkOrdinal.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkLinkOrdinal.setDescription('The position of this link within the trunk group.')
kxtrunkLinkCount = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkLinkCount.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkLinkCount.setDescription('The number of links within the trunk group.')
kxtrunkLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 9, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrunkLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrunkLastChange.setDescription('The number of seconds since kxtrunkState changed.')
kxWorkGroupNextNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxWorkGroupNextNumber.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupNextNumber.setDescription('The next available workgroup number to be used. When creating a new workgroup, it is recommended to read the value of the variable and use it to key into the workgroup table.')
kxWorkGroupCurrentCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 10, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxWorkGroupCurrentCount.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupCurrentCount.setDescription('The total number of workgroups currently defined.')
kxWorkGroupMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxWorkGroupMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupMaxCount.setDescription('The maximum number of workgroups allowed.')
kxWorkGroupTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 10, 4), )
if mibBuilder.loadTexts: kxWorkGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupTable.setDescription('This table contains work group definitions for the interfaces.')
kxWorkGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 10, 4, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxWorkGroupNumber"))
if mibBuilder.loadTexts: kxWorkGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupEntry.setDescription('Each entry in this table contains a definition of a work group.')
kxWorkGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 10, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxWorkGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupNumber.setDescription('An integer that identifies the work group, used as an index to this table.')
kxWorkGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 10, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxWorkGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupName.setDescription('A 1-16 character work group name.')
kxWorkGroupPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 10, 4, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxWorkGroupPorts.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupPorts.setDescription('A list of all ports within the group. The first octet specified ports 1-8, the second 9-16, etc.')
kxWorkGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("all", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxWorkGroupType.setStatus('mandatory')
if mibBuilder.loadTexts: kxWorkGroupType.setDescription('The type of work group: all - no additional information needs to be supplied.')
kxtrapControlTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 11, 1), )
if mibBuilder.loadTexts: kxtrapControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapControlTable.setDescription('This table contains information about the severity of each trap and whether the trap is currently enabled.')
kxtrapControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 11, 1, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxtrapIndex"))
if mibBuilder.loadTexts: kxtrapControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapControlEntry.setDescription('')
kxtrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapIndex.setDescription('The specific trap number.')
kxtrapEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEnabled.setDescription('Enable or disable the generation of this trap.')
kxtrapSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("informational", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapSeverity.setDescription('A user-definable severity, indicating the importance of the trap.')
kxtrapText = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapText.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapText.setDescription('A description of the trap.')
kxtrapSeverityControlTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 11, 2), )
if mibBuilder.loadTexts: kxtrapSeverityControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapSeverityControlTable.setDescription('This table contains information about whether a class of traps of a particular severity is enabled or disabled.')
kxtrapSeverityControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 11, 2, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxtrapSeverity"))
if mibBuilder.loadTexts: kxtrapSeverityControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapSeverityControlEntry.setDescription('')
kxtrapSeverityControlSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("informational", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapSeverityControlSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapSeverityControlSeverity.setDescription('A user-definable severity, indicating the importance of the trap.')
kxtrapSeverityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapSeverityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapSeverityEnable.setDescription('Enable or disable all traps of a given severity level.')
kxtrapIncludeText = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapIncludeText.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapIncludeText.setDescription('Whether or not a formatted text string is included in the trap PDU.')
kxtrapTime = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 11, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapTime.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapTime.setDescription('The time, in centiseconds, which should expire between the sending of traps.')
kxtrapRetry = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 11, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxtrapRetry.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapRetry.setDescription('The number of times any enterprise-specific trap is to be sent for a given event. PDUs are retried using a truncated exponential backoff: 2 seconds, 4 seconds, 8 seconds, 16 seconds, and then 32 seconds for all succeeding intervals.')
kxtrapNumber = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 11, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapNumber.setDescription('The number of traps that are in the kxtrapTable.')
kxtrapTable = MibTable((1, 3, 6, 1, 4, 1, 97, 8, 11, 7), )
if mibBuilder.loadTexts: kxtrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapTable.setDescription('This table contains the latest traps that have been generated.')
kxtrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 97, 8, 11, 7, 1), ).setIndexNames((0, "CT-ELS100-MIB", "kxtrapEntryIndex"))
if mibBuilder.loadTexts: kxtrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEntry.setDescription('')
kxtrapEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEntryIndex.setDescription('A number representing the order in which the trap occurred in time. This 32 bit number can wrap.')
kxtrapEntryTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 7, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapEntryTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEntryTimeStamp.setDescription('The time at which the trap occurred.')
kxtrapEntryText = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 7, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapEntryText.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEntryText.setDescription('A description of the trap.')
kxtrapEntryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapEntryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEntryNumber.setDescription('The specific trap number, as specified in the TRAP PDU.')
kxtrapEntrySeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 97, 8, 11, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("informational", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: kxtrapEntrySeverity.setStatus('mandatory')
if mibBuilder.loadTexts: kxtrapEntrySeverity.setDescription('A user-definable severity, indicating the importance of the trap.')
kxmirrorMode = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("tx", 2), ("rx", 3), ("rxandtx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxmirrorMode.setStatus('mandatory')
if mibBuilder.loadTexts: kxmirrorMode.setDescription('To turn off port mirroring, or turn on by specifying rx, tx, or (rxandtx) which is the type of data to be mirrored.')
kxmirrorDiagPort = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 12, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxmirrorDiagPort.setStatus('mandatory')
if mibBuilder.loadTexts: kxmirrorDiagPort.setDescription('This entry identifies the diagnostic port to which mirrored packet will be destined.')
kxmirrorTargetPortLists = MibScalar((1, 3, 6, 1, 4, 1, 97, 8, 12, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kxmirrorTargetPortLists.setStatus('mandatory')
if mibBuilder.loadTexts: kxmirrorTargetPortLists.setDescription('An octet string specifies the list of ports to be mirrored. The first octet specifies ports 1-8 and the second 9-16.')
kxPortFunctionsTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,1)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxifFunction"))
if mibBuilder.loadTexts: kxPortFunctionsTrap.setDescription('Sent whenever the current functional state (active protocols) of the port has changed.')
kxRxQueuesTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,2)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxifRxQueueThreshTime"))
if mibBuilder.loadTexts: kxRxQueuesTrap.setDescription("Sent whenever the number of times that the port's receiver has stopped receiving packets due to buffer space shortages has exceeded the port's limit.")
kxTxStormFlagTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,3)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"))
if mibBuilder.loadTexts: kxTxStormFlagTrap.setDescription('Sent whenever multicast storm protection has been invoked for the port.')
kxTxCongestsTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,4)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxadminNAMReceiveCongests"))
if mibBuilder.loadTexts: kxTxCongestsTrap.setDescription('Sent whenever packets destined for the unit itself were discarded due to lack of buffer space.')
kxTrunkStateTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,5)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxtrunkState"))
if mibBuilder.loadTexts: kxTrunkStateTrap.setDescription('A trunking state change transition has occurred. The possible transitions are: Closed-Oneway Oneway-Perturbed Perturbed-Joined Joined-Helddown Closed-Helddown Oneway-Helddown Perturbed-Helddown')
kxTrunkBridgeAddrTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,6)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxtrunkRemoteBridgeAddr"))
if mibBuilder.loadTexts: kxTrunkBridgeAddrTrap.setDescription('The associated trunking MAC address of the bridge ID of the remote bridge has changed.')
kxTrunkIPAddrTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,7)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxtrunkRemoteIp"))
if mibBuilder.loadTexts: kxTrunkIPAddrTrap.setDescription('The associated trunking IP address of the remote bridge has changed.')
kxTrunkErrorTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,8)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxtrunkLastError"))
if mibBuilder.loadTexts: kxTrunkErrorTrap.setDescription('An error has occurred in trunking.')
kxTrunkLinkOrdinalTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,9)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxtrunkLinkOrdinal"))
if mibBuilder.loadTexts: kxTrunkLinkOrdinalTrap.setDescription("The port's index in the trunking group has changed.")
kxTrunkLinkCountTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,10)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxtrunkLinkCount"))
if mibBuilder.loadTexts: kxTrunkLinkCountTrap.setDescription('The number of ports in the trunking group has changed.')
kxDiagUnitBootedTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,11)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("CT-ELS100-MIB", "kxadminFatalErr"))
if mibBuilder.loadTexts: kxDiagUnitBootedTrap.setDescription('The unit has booted. kxadminFatalErr contains information about why the unit rebooted.')
kxStorageFailureTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,12)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"))
if mibBuilder.loadTexts: kxStorageFailureTrap.setDescription("Sent if the unit's Configuration EEPROM has failed. The unit will not be able to reboot, and must be returned to the factory.")
kxIfErrorsTrap = NotificationType((1, 3, 6, 1, 2, 1, 1, 2) + (0,13)).setObjects(("CT-ELS100-MIB", "kxtrapSeverity"), ("IF-MIB", "ifInErrors"), ("IF-MIB", "ifOutErrors"))
if mibBuilder.loadTexts: kxIfErrorsTrap.setDescription("Sent whenever the number of hardware errors in received and transmitted packets has exceeded the port's limit.")
mibBuilder.exportSymbols("CT-ELS100-MIB", sys=sys, kxWorkGroupNextNumber=kxWorkGroupNextNumber, kxadminStorageFailure=kxadminStorageFailure, kxmirrorTargetPortLists=kxmirrorTargetPortLists, kxadminAnyPass=kxadminAnyPass, kxtrapSeverityControlTable=kxtrapSeverityControlTable, kxtrapEnabled=kxtrapEnabled, kxaddrDynamicMax=kxaddrDynamicMax, sysTrapPort=sysTrapPort, kxswdisConfigTotalTimeout=kxswdisConfigTotalTimeout, kxWorkGroupPorts=kxWorkGroupPorts, kxprotoIfIndex=kxprotoIfIndex, kxWorkGroupName=kxWorkGroupName, kxadminNAMReceiveCongests=kxadminNAMReceiveCongests, kxadminGetPass=kxadminGetPass, kxaddrNext=kxaddrNext, kxTrunkStateTrap=kxTrunkStateTrap, kxRxQueuesTrap=kxRxQueuesTrap, kxtrapEntryTimeStamp=kxtrapEntryTimeStamp, kxtrunkIfIndex=kxtrunkIfIndex, kxaddrFlags=kxaddrFlags, kxTrunkBridgeAddrTrap=kxTrunkBridgeAddrTrap, kxtrapTable=kxtrapTable, kxworkgroup=kxworkgroup, kxswdisConfigIp=kxswdisConfigIp, kxswFilesetEntry=kxswFilesetEntry, kxswStarts=kxswStarts, kxaddrOperation=kxaddrOperation, kxprotoSuppressBpdu=kxprotoSuppressBpdu, kxWorkGroupCurrentCount=kxWorkGroupCurrentCount, kxWorkGroupTable=kxWorkGroupTable, kxadminArpStatics=kxadminArpStatics, kxswdisDesc=kxswdisDesc, kxtrapTime=kxtrapTime, kxproto=kxproto, sigma=sigma, kxtrapSeverityControlEntry=kxtrapSeverityControlEntry, kxswFlashBank=kxswFlashBank, kxuartBaud=kxuartBaud, kxtrapSeverityEnable=kxtrapSeverityEnable, kxifTxCnt=kxifTxCnt, kxtrapEntryNumber=kxtrapEntryNumber, kxswDesc=kxswDesc, kxaddrMAC=kxaddrMAC, kxuartAlignmentErrors=kxuartAlignmentErrors, kxtrapSeverity=kxtrapSeverity, kxadminArpOverflows=kxadminArpOverflows, kxIfErrorsTrap=kxIfErrorsTrap, kxaddr=kxaddr, kxTrunkLinkCountTrap=kxTrunkLinkCountTrap, kxaddrPort=kxaddrPort, kxprotoRipListen=kxprotoRipListen, kxtrapIncludeText=kxtrapIncludeText, kxprotoTable=kxprotoTable, kxWorkGroupType=kxWorkGroupType, kxtrunkRemoteIp=kxtrunkRemoteIp, kxTxCongestsTrap=kxTxCongestsTrap, kxswdisWriteStatus=kxswdisWriteStatus, kxprotoEntry=kxprotoEntry, kxswNumber=kxswNumber, kxifThresholdTime=kxifThresholdTime, kxadminAuthenticationFailure=kxadminAuthenticationFailure, kxifTable=kxifTable, kxtrunkState=kxtrunkState, kxadminNMSIPAddr=kxadminNMSIPAddr, kxuart=kxuart, kxifRxQueueThreshTime=kxifRxQueueThreshTime, kxifRxCnt=kxifRxCnt, kxtrapEntry=kxtrapEntry, kxuartEntry=kxuartEntry, kxswdisAccess=kxswdisAccess, kxtrapText=kxtrapText, kxtrunkLinkOrdinal=kxtrunkLinkOrdinal, kxPortFunctionsTrap=kxPortFunctionsTrap, kxadminRebootConfig=kxadminRebootConfig, kxtrapEntryIndex=kxtrapEntryIndex, kxmirrorDiagPort=kxmirrorDiagPort, kxtrunkLinkCount=kxtrunkLinkCount, kxsw=kxsw, kxadminLEDProgramOption=kxadminLEDProgramOption, kxhwPortCount=kxhwPortCount, kxif=kxif, kxaddrIndex=kxaddrIndex, kxTrunkErrorTrap=kxTrunkErrorTrap, kxmirrorMode=kxmirrorMode, kxuartOverrunErrors=kxuartOverrunErrors, kxswdis=kxswdis, kxswType=kxswType, kxmirrorgroup=kxmirrorgroup, kxtrapControlEntry=kxtrapControlEntry, kxifFunction=kxifFunction, kxtrapEntryText=kxtrapEntryText, kxprotoBridge=kxprotoBridge, kxhwDiagCode=kxhwDiagCode, kxswBases=kxswBases, kxadminButtonSelection=kxadminButtonSelection, kxswdisConfigRetryTime=kxswdisConfigRetryTime, kxaddrDynamics=kxaddrDynamics, kxDiagUnitBootedTrap=kxDiagUnitBootedTrap, kxifThreshold=kxifThreshold, kxprotoTrunking=kxprotoTrunking, kxaddrBlockSize=kxaddrBlockSize, kxtrapMgt=kxtrapMgt, kxtrunkRemoteBridgeAddr=kxtrunkRemoteBridgeAddr, kxtrunkLastChange=kxtrunkLastChange, kxtrapRetry=kxtrapRetry, kxtrapControlTable=kxtrapControlTable, kxtrunk=kxtrunk, kxWorkGroupMaxCount=kxWorkGroupMaxCount, kxadminArpEntries=kxadminArpEntries, kxTxStormFlagTrap=kxTxStormFlagTrap, sysReset=sysReset, kxtrunkEntry=kxtrunkEntry, kxWorkGroupNumber=kxWorkGroupNumber, kxtrunkTable=kxtrunkTable, kxadminRipPreference=kxadminRipPreference, kxswCount=kxswCount, kxadminRipRouteDiscards=kxadminRipRouteDiscards, kxadminFatalErr=kxadminFatalErr, kxuartTable=kxuartTable, kxifRxQueueThresh=kxifRxQueueThresh, els_100=els_100, kxuartIndex=kxuartIndex, kxTrunkLinkOrdinalTrap=kxTrunkLinkOrdinalTrap, kxhw=kxhw, kxifIndex=kxifIndex, kxhwManufData=kxhwManufData, kxaddrDynamicOverflows=kxaddrDynamicOverflows, kxswFilesetTable=kxswFilesetTable, kxtrunkLastError=kxtrunkLastError, kxtrapEntrySeverity=kxtrapEntrySeverity, kxaddrBlock=kxaddrBlock, kxaddrStatics=kxaddrStatics, kxswSizes=kxswSizes, kxTrunkIPAddrTrap=kxTrunkIPAddrTrap, kxadmin=kxadmin, sysID=sysID, kxtrapNumber=kxtrapNumber, kxtrapSeverityControlSeverity=kxtrapSeverityControlSeverity, kxStorageFailureTrap=kxStorageFailureTrap, kxtrapIndex=kxtrapIndex, kxifStatisticsTime=kxifStatisticsTime, kxswIndex=kxswIndex, kxifEntry=kxifEntry, kxWorkGroupEntry=kxWorkGroupEntry, kxadminDisableButton=kxadminDisableButton)

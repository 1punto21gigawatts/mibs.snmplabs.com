#
# PySNMP MIB module CISCO-LECS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-LECS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:04:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
VciInteger, VpiInteger, AtmLaneAddress = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "VciInteger", "VpiInteger", "AtmLaneAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Integer32, MibIdentifier, Counter32, iso, Unsigned32, TimeTicks, ObjectIdentity, Bits, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter64, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "MibIdentifier", "Counter32", "iso", "Unsigned32", "TimeTicks", "ObjectIdentity", "Bits", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter64", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
TruthValue, RowStatus, TimeStamp, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC-v1", "TruthValue", "RowStatus", "TimeStamp", "DisplayString", "MacAddress")
ciscoLecsMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38))
ciscoLecsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 1))
lecs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1))
config = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2))
lecsMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2))
lecsMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2, 1))
lecsMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2, 2))
lecsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1), )
if mibBuilder.loadTexts: lecsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsTable.setDescription('The (conceptual) table containing the interface specific information of the LECS on a particular device and its associated statistics for that interface. ')
lecsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: lecsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsEntry.setDescription('An entry (conceptual row) in the lecsTable, containing information of a LECS for a particular interface. Note that deleting an entry will have the side effect of deleting corresponding entries in the lecsAtmAddrTable.')
lecsConfigTableName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsConfigTableName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigTableName.setDescription('The textual name used to identify a configuration table in use by the designated LECS. Note that this value must be a reference to an entry in the lecsConfigTblTable.')
lecsUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: lecsUpTime.setDescription(' The value of sysUpTime when this entry was created. Note that changing the value of the lecsAdminStatus will not affect the value of this object. This object is only set at row creation time ( whether it is from explicit use of SNMP, the CLI or from initialization at boot time).')
lecsInConfigReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsInConfigReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lecsInConfigReqs.setDescription(' The number of LE_CONFIGURE_REQUESTs that have been received by this LECS on this designated interface.')
lecsInConfigErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsInConfigErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lecsInConfigErrors.setDescription(' Then number of packets sent to the LECS from the lower layers but which were not correctly formatted configure requests.')
lecsOutConfigFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsOutConfigFails.setStatus('mandatory')
if mibBuilder.loadTexts: lecsOutConfigFails.setDescription(' The number of LE_CONFIGURE_RESPONSEs sent by this particular LECS whose status was other than success.')
lecsLastFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsLastFailCause.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLastFailCause.setDescription(' The cause for rejection of the last LE_CONFIGURE_REQUEST. This will be the value of the status field that was sent in the rejection LE_CONFIGURE_RESPONSE. If the config server has never issued a failed response then this object will have the value of 0.')
lecsLastFailLec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 7), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsLastFailLec.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLastFailLec.setDescription(' The ATM address of the LE client whose last configuration request was rejected. This ATM address will be for the LE client who was delivered the last LE_CONFIGURE_RESPONSE that caused the lecsOutConfigFails object to increment. This value is taken directly from the LE_CONFIGURE_REQUEST and is not guarenteed to be correctly identify a LEC.')
lecsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsOperStatus.setDescription(" This object reflects the actual state of the LECS which may differ from that of the lecsAdminStatus object. This can occur when the interface ifOperStatus is 'down' but the corresponding lecsAdminStatus is 'active'.")
lecsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAdminStatus.setDescription(' The desired state of the LECS on this interface as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the lecsOperStatus.')
lecsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsStatus.setDescription(' The status object for the lecsEntry. Note that the lecsConfigTableName must be specified at row creation time.')
lecsMasterState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsMasterState.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMasterState.setDescription(' An indication of whether the LECS is acting as the operative master or is a redundant slave.')
lecsAtmAddrTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2), )
if mibBuilder.loadTexts: lecsAtmAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrTable.setDescription(' A (conceptual) table of ATM addresses which are listened to by LECSs on this device.')
lecsAtmAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-LECS-MIB", "lecsAtmAddrIndex"))
if mibBuilder.loadTexts: lecsAtmAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrEntry.setDescription(' An entry (conceptual row) that denotes an ATM address, on a particular interface, that a LECS listens on. Note that an entry in the lecsTable must exist for the corresponding ifIndex first before any ATM addresses can be assigned to it.')
lecsAtmAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lecsAtmAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrIndex.setDescription(' An arbitrary number that uniquely corresponds to a value of lecsAtmAddrActual for a designated interface. Note that lecsAtmAddrActual could not be used for the index since it may not be known at the time of row creation (to be resolved through interaction with the switch). This value must remain constant while the device is running. It is not guarenteed to be constant between reboots of the device.')
lecsAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrSpec.setDescription(' An ATM address specified by the network or local management that, with the ATM address mask, determines a portion of the ATM address that the LECS on the designated interface will use to accept configure requests on. If this object is omitted at row creation time then the LECS will try to determine an ATM address, through ILMI, on its own. When the LECS is configured to have one ATM address (one entry in this table), modifying this object will result in the LECS reinitializing and dropping all connections to it.')
lecsAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrMask.setDescription(' A bit mask signifying what portion of the specified ATM address is relevant. If the ATM address is not specified (i.e. at row creation time), then this object defaults to all zeros (no portion of the lecsAtmAddrSpec value is relevant). If the ATM address is specified but this object omitted at row creation then this object defaults to all ones (all of the specified lecsAtmAddrSpec value is relevant). This object cannot be specified at row creation time without also specifying a value for the lecsAtmAddrSpec object. When the LECS is configured to have one ATM address (one entry in this table), modifying this object will result in the LECS reinitializing and dropping all connections to it.')
lecsAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1, 4), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrActual.setDescription(" The resulting address that the LECS is accepting configuration requests on for the designated interface. This address is the result of the specified ATM address, its mask and interaction through the ILMI with the switch. Note that this object is only valid when the corresponding lecsOperStatus is 'active'.")
lecsAtmAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("actualValueInvalid", 1), ("actualValueValid", 2), ("registeredWithSignalling", 3), ("regSigAndValid", 4), ("registeredWithIlmi", 5), ("regIlmiAndValid", 6), ("regSigandIlmi", 7), ("regSigIlmiAndValid", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsAtmAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrState.setDescription(' Once a (conceptual) row is created, the LECS, if active, goes about interacting through ILMI and registering the address with the switch. The value of this object denote what phase the current address is in. Whether the lecsAtmAddrActual is valid or not, whether the address has been registered through the ILMI and whether the address has been registered with signalling. ')
lecsAtmAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 2, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrStatus.setDescription(' The status object for the lecsAtmAddrTable.')
lecsConfigDirectConnTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3), )
if mibBuilder.loadTexts: lecsConfigDirectConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnTable.setDescription(' This (conceptual) table allows a manager to view what LE clients have established configure direct connections to the LECS over the designated interface.')
lecsConfigDirectConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-LECS-MIB", "lecsConfigDirectConnVpi"), (0, "CISCO-LECS-MIB", "lecsConfigDirectConnVci"))
if mibBuilder.loadTexts: lecsConfigDirectConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnEntry.setDescription(' An entry (conceptual row) that denotes a connection to the LECS in the form of a configure direct. It is important to note that the lecsConfigDirectConnSrc and lecsConfigDirectConnDst are only significant when the VC is a SVC. When the row represents a PVC then these two columns will be omitted from the row, resulting in a sparse table.')
lecsConfigDirectConnVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1, 1), VpiInteger())
if mibBuilder.loadTexts: lecsConfigDirectConnVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnVpi.setDescription(' The virtual path identifier of the designated connection to the LECS.')
lecsConfigDirectConnVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1, 2), VciInteger())
if mibBuilder.loadTexts: lecsConfigDirectConnVci.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnVci.setDescription(' The virtual channel identifier of the designated connection to the LECS.')
lecsConfigDirectConnVCType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfigDirectConnVCType.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnVCType.setDescription(" The type of virtual connection that the designated configure direct uses. If this object has the value 'pvc' then the lecsConfigDirectConnSrc and lecsConfigDirectConnDst will not be instantiated.")
lecsConfigDirectConnSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1, 4), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfigDirectConnSrc.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnSrc.setDescription(' The calling party ID if the VC is a SVC. If the VC is a PVC then this object shall not be instantiated for the designated VC.')
lecsConfigDirectConnDst = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfigDirectConnDst.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectConnDst.setDescription(' The address that was used by the requesting LEC to make the designated connection. The called party ID if the VC is a SVC. If the VC is a PVC then this object shall not be instantiated for the designated VC.')
lecsConfigDirectDstType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("laneClient", 1), ("laneServer", 2), ("laneConfig", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsConfigDirectDstType.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigDirectDstType.setDescription(' The type of entity on the other end of the VC.')
lecsConfigTblTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 1), )
if mibBuilder.loadTexts: lecsConfigTblTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigTblTable.setDescription(' A (conceptual) table of the configuration tables in existence on the device. Note that an entry must exist in this table before it can be used in the lecsTable, lecsElanConfigTable, lecsMacConfigTable or lecsAtmAddrConfigTable.')
lecsConfigTblEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 1, 1), ).setIndexNames((1, "CISCO-LECS-MIB", "lecsConfigTblName"))
if mibBuilder.loadTexts: lecsConfigTblEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigTblEntry.setDescription(' An entry (conceptual row) that denotes a configuration table, potentially accessible by a LECS.')
lecsConfigTblName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: lecsConfigTblName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigTblName.setDescription('The textual name used to identify a configuration table.')
lecsConfigTblDefaultElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsConfigTblDefaultElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigTblDefaultElanName.setDescription(" The ELAN name assigned to LE clients who do not specify what ELAN they wish to join when issuing a configuration request. It is important to understand when the default ELAN name will be used. If the LEC specifies an ELAN name in its configuration request and a different mapping or a conflicting mapping is present for that LEC then the default ELAN will not be used and a failure will be returned. If the LEC does not specify the ELAN name in the configuration request and there is no mapping within the LECS then the default elan name will be used and a successful reply will be returned (provided the rest of the request is valid). If there is no default ELAN specified for this configuration table then a LE client, with no mapping to any elan, will be rejected from configuration regardless of the parameters of the configuration request. The default value (''H) indicates that no default ELAN name is selected. The default ELAN cannot have an access type of closed. Attempting to set the default ELAN type to a closed ELAN will result in an error.")
lecsConfigTblStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsConfigTblStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfigTblStatus.setDescription(' The status object associated with the designated entry. Note that a value for lecsConfigTblDefaultElanName cannot be specified at row creation time (as it points to an entry in the lecsElanConfigTable which depends on this designated entry). A management station wishing to set the lecsConfigTblDefaulElanName must do so in subsequent SET requests to the now active row.')
lecsElanConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2), )
if mibBuilder.loadTexts: lecsElanConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanConfigTable.setDescription(' A (conceptual) configuration table that represents the names of the ELANs known to a LECS and their corresponding LES ATM addresses.')
lecsElanConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-LECS-MIB", "lecsConfigTblName"), (1, "CISCO-LECS-MIB", "lecsElanConfigName"))
if mibBuilder.loadTexts: lecsElanConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanConfigEntry.setDescription(' An entry (conceptual row) in the ELAN configuration table representing a mapping from an ELAN name to a LES ATM address. Note that a value of ELAN name must exist in this table before it can be used within the lecsMacConfigTable or the lecsAtmAddrConfigTable. Also note that the IMPLIED indexing of this table will not translate to the SNMPv1 SMI.')
lecsElanConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: lecsElanConfigName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanConfigName.setDescription(' The name assigned to an ELAN in this configuration entry.')
lecsElanLesAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsElanLesAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanLesAtmAddr.setDescription(' The ATM address of the LES associated with the ELAN of this entry.')
lecsElanAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("closed", 2))).clone('open')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsElanAccess.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanAccess.setDescription(" The access of the ELAN to configure requests. A 'closed' ELAN (similar to a closed user group) is prevented from being used as the default ELAN and also may not be asked for in the LE_CONFIGURE_REQUEST solely by ELAN name. As such only clients that provide an ATM address or MAC address that has been configured for the 'closed' ELAN will be given returned a successful LE_CONFIGURE_RESPONSE.")
lecsElanConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsElanConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanConfigStatus.setDescription(' This object can only be set to active once a valid value of lecsElanLesAtmAddr is filled in.')
lecsElanSegmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsElanSegmentId.setStatus('mandatory')
if mibBuilder.loadTexts: lecsElanSegmentId.setDescription(' The Segment Id for Token Ring ELANs associated with this ELAN. A value of zero indicates that a ring number is not applicable to this ELAN.')
lecsMacConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 3), )
if mibBuilder.loadTexts: lecsMacConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMacConfigTable.setDescription(' A (conceptual) table utilized by a LECS to map a registered MAC address of a LEC to an ELAN name. This table is used be the LECS to assign a LEC to an ELAN. It is, however, not mandatory for all configurable LECs to be in this table as they may opt to use the lecsAtmAddrConfigTable instead or perhaps rely on the default ELAN set in the lecsConfigTblTable. Also note that a LES may opt to use this table to determine authorization of a LEC to join an ELAN.')
lecsMacConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-LECS-MIB", "lecsConfigTblName"), (0, "CISCO-LECS-MIB", "lecsMacConfigAddress"))
if mibBuilder.loadTexts: lecsMacConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMacConfigEntry.setDescription(' An entry (conceptual row) of a mapping between a MAC address in primary utilization by a LEC and an ELAN name.')
lecsMacConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 3, 1, 1), MacAddress())
if mibBuilder.loadTexts: lecsMacConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMacConfigAddress.setDescription(' The MAC address of a to be associated with an ELAN name.')
lecsMacConfigElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsMacConfigElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMacConfigElanName.setDescription(' An ELAN name that will be returned to a LEC that provides the corresponding MAC address in a configuration request. Note that only ELAN names within the lecsElanConfigTable are acceptable values for this object. If this object is left unspecified at row creation, then it will take on the value of the lecsConfigTblDefaultElanName from the designated configuration table.')
lecsMacConfigLastUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsMacConfigLastUsed.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMacConfigLastUsed.setDescription(' The value of sysUpTime when this entry was last used to map a MAC address to an ELAN name. Managers may opt to use this object to garbage collect entries that have not been used for a prolonged period of time.')
lecsMacConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsMacConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMacConfigStatus.setDescription(" The row cannot be set to 'active' until an appropiate value exists for lecsMacConfigElanName. This may be provided by the agent if there exists a value for the lecsConfigTblDefaultElanName for the designated lecsConfigTblName.")
lecsAtmAddrConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4), )
if mibBuilder.loadTexts: lecsAtmAddrConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrConfigTable.setDescription(' This (conceptual) table is used by the LECS to map between an ATM address of a LEC and ELAN name. ')
lecsAtmAddrConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-LECS-MIB", "lecsConfigTblName"), (0, "CISCO-LECS-MIB", "lecsAtmAddrConfigAddress"), (0, "CISCO-LECS-MIB", "lecsAtmAddrConfigMask"))
if mibBuilder.loadTexts: lecsAtmAddrConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrConfigEntry.setDescription(' An entry (conceptual row) of the config table that maps between an ATM address of a LEC and ELAN name.')
lecsAtmAddrConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: lecsAtmAddrConfigAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrConfigAddress.setDescription(' An ATM Address of a LEC that when combined with an address mask is used to determine which ELAN the LE client should belong to.')
lecsAtmAddrConfigMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: lecsAtmAddrConfigMask.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrConfigMask.setDescription(' An ATM address mask associated with the LEC ATM address of this entry. Bits in this mask that are set to zero indicate that corresponding bit locations in the comparison ATM address are to be ignored for the purposes of matching. A mask of all zeros would be the trivial case of having all comparisons match while a mask of all ones indicates that the two ATM addresses must match exactly. This object is useful due to the fact that ATM addresses are a composite negotiated by the switch and connected device. Wild carding the prefix of an addresses indicates a preference of where a LEC is to join regardless of what switch it is attached from. Wildcarding the ESI and selector byte indicates that a LEC is to join a certain ELAN based on what switch it is attached to.')
lecsAtmAddrConfigElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrConfigElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrConfigElanName.setDescription(' The ELAN name to be returned to a configure request that has specified an ATM address that matches the address/mask pair in this entry. Note that only ELAN names within the lecsElanConfigTable are acceptable values for this object. If this object is left unspecified at row creation, then it will take on the value of the lecsConfigTblDefaultElanName from the designated configuration table.')
lecsAtmAddrLastUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsAtmAddrLastUsed.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrLastUsed.setDescription(' The value of sysUpTime corresponding to the time this entry was last used. The manager may opt to use this object to garbage collect entries that have not been used for a prolonged period of time.')
lecsAtmAddrConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsAtmAddrConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsAtmAddrConfigStatus.setDescription(" The status of this entry (conceptual) row in the lecsAtmAddrConfigTable. The row cannot be set to 'active' until an appropiate value exists for lecsAtmAddrConfigElanName. This may be provided by the agent if there exists a value for the lecsConfigTblDefaultElanName for the designated lecsConfigTblName.")
lecsLesConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 5), )
if mibBuilder.loadTexts: lecsLesConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLesConfigTable.setDescription(' A table of LESs servicing an ELAN.')
lecsLesConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 5, 1), ).setIndexNames((0, "CISCO-LECS-MIB", "lecsConfigTblName"), (0, "CISCO-LECS-MIB", "lecsElanConfigName"), (0, "CISCO-LECS-MIB", "lecsLesAtmAddr"))
if mibBuilder.loadTexts: lecsLesConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLesConfigEntry.setDescription(' An entry (conceptual row) in the lecsLesConfigTable.')
lecsLesAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: lecsLesAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLesAtmAddr.setDescription(' The ATM address of a LES configured to service this ELAN.')
lecsLesPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsLesPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLesPriority.setDescription(" The relative priority of the LES. The lower this number the more priority is given the LES for servicing the ELAN. Such that a higher priority LES will supersede operation of the ELAN in the presence of a lower priority LES. Note that the LECS will adjust the number entered to fit into a contiguous numbering space equalling the number of LESs defined for the particular ELAN. For example if there is one LES defined for an ELAN then that LES's priority will always be zero since there are no other LESs to contend with. Setting that LESs priority to ten (e.g.) will work but the net result will be that the priority will still be zero (as will be verified by consequent retrieval of this objects value). If a second LES is defined for this ELAN with a priority of ten (e.g.) the net result would be that the second LES will have a priority of one since it is the only other LES for that ELAN and behind in priority from the first LES. If the second LES were given a priority of zero at any time then it would keep the priority of zero and the first LES would transition to having a priority of one. Note that defining a new LES with a priority already in existance by another LES has the effect of giving the new LES the designated priority and reducing the priority (numerically increasing) of all LESs equal to and below it in rank. Likewise, deleting a LES from this table will cause LESs below it in priority (numerically greater) to move up in the table (modifying their priority value to be one less) to fill in the now empty slot. In this way a table, with at least one entry, should always contain entries with priorities including zero up to the number of entries minus one (0..(n-1)).")
lecsLesConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("notConnected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsLesConnState.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLesConnState.setDescription(' The present state of the given LES. The active(1) LES is servicing the ELAN, inactive(2) LESs are connected but not accepting joins, not-connected(3) LESs are not accounted for.')
lecsLesConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsLesConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsLesConfigStatus.setDescription(' The status of the conceptual row.')
lecsRDConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6), )
if mibBuilder.loadTexts: lecsRDConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigTable.setDescription(' A (conceptual) table utilized by a LECS to map a registered Route Descriptor of a LEC to an ELAN name. This table is used by the LECS to assign a LEC to an ELAN. It is, however, not mandatory for all configurable LECs to be in this table as they may opt to use the lecsAtmAddrConfigTable or lecsMacConfigTable instead or perhaps rely on the default ELAN set in the lecsConfigTblTable. Also note that a LES may opt to use this table to determine authorization of a LEC to join an ELAN.')
lecsRDConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6, 1), ).setIndexNames((0, "CISCO-LECS-MIB", "lecsConfigTblName"), (0, "CISCO-LECS-MIB", "lecsRDConfigSegmentId"), (0, "CISCO-LECS-MIB", "lecsRDConfigBridgeNum"))
if mibBuilder.loadTexts: lecsRDConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigEntry.setDescription(' An entry (conceptual row) of a mapping between a Route Descriptor in primary utilization by a LEC and an ELAN name.')
lecsRDConfigSegmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: lecsRDConfigSegmentId.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigSegmentId.setDescription(' The Segment ID in a Route Descriptor provided by a LEC during configuration. ')
lecsRDConfigBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: lecsRDConfigBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigBridgeNum.setDescription(' The Bridge Number in a Route Descriptor provided by a LEC during configuration. ')
lecsRDConfigElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsRDConfigElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigElanName.setDescription(' An ELAN name that will be returned to a LEC that provides the corresponding Route Descriptor in a configuration request. Note that only ELAN names within the lecsElanConfigTable are acceptable values for this object. If this object is left unspecified at row creation, then it will take on the value of the lecsConfigTblDefaultElanName from the designated configuration table.')
lecsRDConfigLastUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lecsRDConfigLastUsed.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigLastUsed.setDescription(' The value of sysUpTime when this entry was last used to map a Route Descriptor to an ELAN name. Managers may opt to use this object to garbage collect entries that have not been used for a prolonged period of time.')
lecsRDConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 38, 1, 2, 6, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsRDConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lecsRDConfigStatus.setDescription(" The row cannot be set to 'active' until an appropiate value exists for lecsRDConfigElanName. This may be provided by the agent if there exists a value for the lecsConfigTblDefaultElanName for the designated lecsConfigTblName.")
lecsMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2, 2, 1))
lecsTokenRingMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2, 2, 2))
lecsRedundancyMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2, 2, 3))
lecsMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 38, 2, 1, 1))
mibBuilder.exportSymbols("CISCO-LECS-MIB", lecsUpTime=lecsUpTime, lecsLesPriority=lecsLesPriority, lecsElanConfigEntry=lecsElanConfigEntry, lecsElanLesAtmAddr=lecsElanLesAtmAddr, lecsConfigTblEntry=lecsConfigTblEntry, lecsMacConfigStatus=lecsMacConfigStatus, lecsRDConfigBridgeNum=lecsRDConfigBridgeNum, lecsMIBGroups=lecsMIBGroups, lecsLesConfigEntry=lecsLesConfigEntry, lecsElanAccess=lecsElanAccess, lecsConfigTblTable=lecsConfigTblTable, lecsMacConfigElanName=lecsMacConfigElanName, lecsConfigDirectConnVci=lecsConfigDirectConnVci, lecsElanConfigStatus=lecsElanConfigStatus, lecsConfigTblStatus=lecsConfigTblStatus, lecsConfigDirectConnEntry=lecsConfigDirectConnEntry, lecsAtmAddrActual=lecsAtmAddrActual, lecsConfigTableName=lecsConfigTableName, lecsConfigDirectConnVpi=lecsConfigDirectConnVpi, lecsAtmAddrConfigAddress=lecsAtmAddrConfigAddress, lecsAtmAddrMask=lecsAtmAddrMask, lecsConfigDirectConnTable=lecsConfigDirectConnTable, lecsLesConfigStatus=lecsLesConfigStatus, lecsAtmAddrConfigStatus=lecsAtmAddrConfigStatus, lecsRedundancyMIBGroup=lecsRedundancyMIBGroup, lecsOperStatus=lecsOperStatus, lecsAtmAddrEntry=lecsAtmAddrEntry, lecsConfigTblName=lecsConfigTblName, lecsAtmAddrConfigElanName=lecsAtmAddrConfigElanName, lecsElanConfigName=lecsElanConfigName, lecsAtmAddrTable=lecsAtmAddrTable, lecsConfigDirectConnVCType=lecsConfigDirectConnVCType, lecsRDConfigSegmentId=lecsRDConfigSegmentId, lecsAtmAddrState=lecsAtmAddrState, ciscoLecsMIBObjects=ciscoLecsMIBObjects, lecs=lecs, lecsConfigDirectConnDst=lecsConfigDirectConnDst, lecsRDConfigTable=lecsRDConfigTable, lecsMasterState=lecsMasterState, lecsConfigDirectConnSrc=lecsConfigDirectConnSrc, lecsAtmAddrLastUsed=lecsAtmAddrLastUsed, lecsLesAtmAddr=lecsLesAtmAddr, lecsRDConfigElanName=lecsRDConfigElanName, lecsInConfigReqs=lecsInConfigReqs, lecsLesConfigTable=lecsLesConfigTable, lecsAtmAddrConfigTable=lecsAtmAddrConfigTable, lecsMacConfigAddress=lecsMacConfigAddress, lecsAdminStatus=lecsAdminStatus, lecsRDConfigStatus=lecsRDConfigStatus, lecsMIBGroup=lecsMIBGroup, lecsInConfigErrors=lecsInConfigErrors, lecsMIBCompliances=lecsMIBCompliances, lecsElanConfigTable=lecsElanConfigTable, lecsStatus=lecsStatus, lecsOutConfigFails=lecsOutConfigFails, config=config, lecsElanSegmentId=lecsElanSegmentId, lecsMacConfigTable=lecsMacConfigTable, lecsMacConfigEntry=lecsMacConfigEntry, lecsLastFailLec=lecsLastFailLec, lecsAtmAddrConfigMask=lecsAtmAddrConfigMask, lecsTokenRingMIBGroup=lecsTokenRingMIBGroup, lecsMIBConformance=lecsMIBConformance, lecsLastFailCause=lecsLastFailCause, lecsAtmAddrIndex=lecsAtmAddrIndex, lecsMacConfigLastUsed=lecsMacConfigLastUsed, lecsRDConfigLastUsed=lecsRDConfigLastUsed, lecsAtmAddrConfigEntry=lecsAtmAddrConfigEntry, ciscoLecsMIB=ciscoLecsMIB, lecsEntry=lecsEntry, lecsLesConnState=lecsLesConnState, lecsTable=lecsTable, lecsAtmAddrSpec=lecsAtmAddrSpec, lecsRDConfigEntry=lecsRDConfigEntry, lecsConfigDirectDstType=lecsConfigDirectDstType, lecsConfigTblDefaultElanName=lecsConfigTblDefaultElanName, lecsAtmAddrStatus=lecsAtmAddrStatus, lecsMIBCompliance=lecsMIBCompliance)

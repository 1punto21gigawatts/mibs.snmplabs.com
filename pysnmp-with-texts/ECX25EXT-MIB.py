#
# PySNMP MIB module ECX25EXT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ECX25EXT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:59:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, NotificationType, Counter32, Bits, Gauge32, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, IpAddress, Unsigned32, enterprises, ModuleIdentity, TimeTicks, Integer32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "Counter32", "Bits", "Gauge32", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "IpAddress", "Unsigned32", "enterprises", "ModuleIdentity", "TimeTicks", "Integer32", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
eicon = MibIdentifier((1, 3, 6, 1, 4, 1, 434))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2))
mibv2 = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2))
module = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 4))
x25ext = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5))
class EntryStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4))

class PositiveInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class DisplayString(OctetString):
    pass

class IfIndexType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class X121Address(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 17)

x25CountersTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1), )
if mibBuilder.loadTexts: x25CountersTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CountersTable.setDescription('Runtime counters table, one row per port')
x25CountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25CountPortRef"))
if mibBuilder.loadTexts: x25CountEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CountEntry.setDescription('The set of counters for one port.')
x25CountPortRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CountPortRef.setStatus('mandatory')
if mibBuilder.loadTexts: x25CountPortRef.setDescription('The Port reference on which the X25 is running.')
x25RestartReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RestartReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RestartReqTxs.setDescription('Restart request frames transmitted')
x25RestartReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RestartReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RestartReqRxs.setDescription('Restart request frames received')
x25ClearReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ClearReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ClearReqTxs.setDescription('Clear request frames transmitted ')
x25ClearReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ClearReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ClearReqRxs.setDescription('Clear request frames received')
x25ResetReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ResetReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ResetReqTxs.setDescription('Reset request frames transmitted')
x25ResetReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ResetReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ResetReqRxs.setDescription('Reset request frames received ')
x25InterrReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25InterrReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25InterrReqTxs.setDescription('Interrupt request frames transmitted ')
x25InterrReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25InterrReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25InterrReqRxs.setDescription('Interrupt request frames received ')
x25RNRsTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RNRsTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RNRsTxs.setDescription('Receiver not ready frames transmitted')
x25RNRsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RNRsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RNRsRxs.setDescription('Receiver not ready frames received')
x25REJsTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25REJsTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25REJsTxs.setDescription('Reject frames transmitted ')
x25REJsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25REJsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25REJsRxs.setDescription('Reject frames received ')
x25CallConfirmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallConfirmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallConfirmTxs.setDescription('Call confirm transmitted. ')
x25CallConfirmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallConfirmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallConfirmRxs.setDescription('Call confirm received. ')
x25RRTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RRTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RRTxs.setDescription('Receiver ready transmitted ')
x25RRRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RRRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RRRxs.setDescription('Receiver ready received ')
x25IntConfirmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25IntConfirmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25IntConfirmTxs.setDescription('Interrupt confirm transmitted')
x25IntConfirmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25IntConfirmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25IntConfirmRxs.setDescription('Interrupt confirm received')
x25ClrConfirmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ClrConfirmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ClrConfirmTxs.setDescription('Clear confirmation transmitted.')
x25ClrConfirmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ClrConfirmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ClrConfirmRxs.setDescription('Clear confirmation received.')
x25ResetConfirmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ResetConfirmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ResetConfirmTxs.setDescription('Reset confirm transmitted.')
x25ResetConfirmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ResetConfirmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25ResetConfirmRxs.setDescription('Reset confirm received.')
x25RestartConfirmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RestartConfirmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RestartConfirmTxs.setDescription('Restart confirm transmitted. ')
x25RestartConfirmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RestartConfirmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RestartConfirmRxs.setDescription('Restart confirm received. ')
x25CallReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallReqTxs.setDescription('The number of requests transmitted for a connection.')
x25CallReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallReqRxs.setDescription('The number of requests received for a connection.')
x25RegisterReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RegisterReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RegisterReqTxs.setDescription('The number of register packets sent. Register packets are used to exchange registration information.')
x25RegisterReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RegisterReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RegisterReqRxs.setDescription('The number of register packets received. ')
x25RegisterConfirmTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RegisterConfirmTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RegisterConfirmTxs.setDescription('Register confirm transmitted. ')
x25RegisterConfirmRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RegisterConfirmRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25RegisterConfirmRxs.setDescription('Register confirm received. ')
x25DataSegmentsTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DataSegmentsTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25DataSegmentsTxs.setDescription('The number of 64 bytes data blocks sent. ')
x25DataSegmentsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DataSegmentsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25DataSegmentsRxs.setDescription('The number of 64 bytes data blocks received. ')
x25CaractersTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CaractersTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25CaractersTxs.setDescription('The number of characters sent. ')
x25CaractersRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CaractersRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25CaractersRxs.setDescription('The number of characters received. ')
x25DiagnosticPktsTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DiagnosticPktsTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25DiagnosticPktsTxs.setDescription('The number of error information packets sent.')
x25DiagnosticPktsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25DiagnosticPktsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25DiagnosticPktsRxs.setDescription('The number of error information packets received.')
x25UnknownPktsTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25UnknownPktsTxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25UnknownPktsTxs.setDescription('The number of packets that could not be recognized as following the X.25 structure sent.')
x25UnknownPktsRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25UnknownPktsRxs.setStatus('mandatory')
if mibBuilder.loadTexts: x25UnknownPktsRxs.setDescription('The number of packets that could not be recognized as following the X.25 structure received.')
x25VCCallParmTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2), )
if mibBuilder.loadTexts: x25VCCallParmTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmTable.setDescription('This table contains only the objects of the Internet x25CallParmTable which are available from the EiconCard. For the complete description of x25CallParmTable, please refer to RFC1382.')
x25VCCallParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25VCCallParmPortIndex"), (0, "ECX25EXT-MIB", "x25VCCallParmVCIndex"))
if mibBuilder.loadTexts: x25VCCallParmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmEntry.setDescription('Entries of x25VCCallParmTable.')
x25VCCallParmPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25VCCallParmPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmPortIndex.setDescription('The Port reference on which the X25 is running.')
x25VCCallParmVCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25VCCallParmVCIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmVCIndex.setDescription('The number of Virtual Circuits.')
x25VCCallParmInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmInPacketSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25VCCallParmInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmInPacketSize.setDescription('The maximum receive packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE means use a default size of 128.')
x25VCCallParmOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmOutPacketSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25VCCallParmOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmOutPacketSize.setDescription('The maximum transmit packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use a default size of 128.')
x25VCCallParmInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmInWindowSize.setReference('10733 proposedWindowSize; See ISO 8208 Section 15.2.2.1.2')
if mibBuilder.loadTexts: x25VCCallParmInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmInWindowSize.setDescription('The receive window size for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use 2.')
x25VCCallParmOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmOutWindowSize.setReference('10733 proposedWindowSize; See ISO 8208 Section 15.2.2.1.2')
if mibBuilder.loadTexts: x25VCCallParmOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmOutWindowSize.setDescription('The transmit window size for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use 2.')
x25VCCallParmUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmUserData.setReference('See ISO 8208 Section 12.2.1.1.6, 12.2.1.2')
if mibBuilder.loadTexts: x25VCCallParmUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmUserData.setDescription('The call user data as placed in the packet. A zero length string indicates no call user data. If both the circuit call parameters and the PLE default have call user data defined, the data from the circuit call parameters will be used. If only the PLE has data defined, the PLE entry will be used. If neither the circuit call parameters or the PLE default entry has a value, no call user data will be sent.')
x25VCCallParmCallingNetworkFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmCallingNetworkFacilities.setReference('See ISO 8206 Section 15.1, category b')
if mibBuilder.loadTexts: x25VCCallParmCallingNetworkFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmCallingNetworkFacilities.setDescription('The calling network facilities. The facilities are encoded here exactly as encoded in the call packet. These facilities do not include the marker facility code. A zero length string in the entry for the parameter to use when establishing a circuit means use the PLE default. A zero length string in the entry for PLE default parameters indicates no default facilities.')
x25VCCallParmCalledNetworkFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25VCCallParmCalledNetworkFacilities.setReference('See ISO 8206 Section 15.1, category c')
if mibBuilder.loadTexts: x25VCCallParmCalledNetworkFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25VCCallParmCalledNetworkFacilities.setDescription('The called network facilities. The facilities are encoded here exactly as encoded in the call packet. These facilities do not include the marker facility code. A zero length string in the entry for the parameter to use when establishing a circuit means use the PLE default. A zero length string in the entry for PLE default parameters indicates no default facilities.')
x25OperTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3), )
if mibBuilder.loadTexts: x25OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperTable.setDescription('The operation parameters in use by the X.25 PLE.')
x25OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25OperIndex"))
if mibBuilder.loadTexts: x25OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperEntry.setDescription('Entries of x25OperTable.')
x25OperIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperIndex.setDescription('The ifIndex value for the X.25 interface.')
x25OperInterfaceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("dxe", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperInterfaceMode.setReference('10733 5.9 interfaceMode')
if mibBuilder.loadTexts: x25OperInterfaceMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperInterfaceMode.setDescription('Identifies DCE/DTE mode in which the interface operates. A value of dxe indicates the role will be determined by XID negotiation at the Link Layer and that negotiation has not yet taken place.')
x25OperMaxActiveCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperMaxActiveCircuits.setReference('10733 5.9 maxActiveCircuits See ISO 8208, Section 3.7')
if mibBuilder.loadTexts: x25OperMaxActiveCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperMaxActiveCircuits.setDescription('Maximum number of circuits this PLE can support.')
x25OperPacketSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modulo8", 1), ("modulo128", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperPacketSequencing.setReference('10733 extendedPacketSequencing; See ISO 8208 Section 7.1.1')
if mibBuilder.loadTexts: x25OperPacketSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperPacketSequencing.setDescription('The modulus of the packet sequence number space.')
x25OperRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 5), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperRestartTimer.setReference('10733 5.9 restartTime; See ISO 8208 Section 4.1, table 26')
if mibBuilder.loadTexts: x25OperRestartTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperRestartTimer.setDescription('The T20 restart timer in milliseconds.')
x25OperCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 6), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperCallTimer.setReference('10733 callTime; See ISO 8208 Section 5.2.1, table 26')
if mibBuilder.loadTexts: x25OperCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperCallTimer.setDescription('The T21 Call timer in milliseconds.')
x25OperResetTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 7), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperResetTimer.setReference('10733 resetTime; See ISO 8208 Section 8.1, table 26')
if mibBuilder.loadTexts: x25OperResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperResetTimer.setDescription('The T22 Reset timer in milliseconds.')
x25OperClearTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 8), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperClearTimer.setReference('10733 clearTime; See ISO 8208 Section 5.5.1, table 26')
if mibBuilder.loadTexts: x25OperClearTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperClearTimer.setDescription('The T23 Clear timer in milliseconds.')
x25OperWindowTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 9), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperWindowTimer.setReference('10733 5.10.1 windowTime (opt); See ISO 8208 Section 11.2.2, table 26')
if mibBuilder.loadTexts: x25OperWindowTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperWindowTimer.setDescription('The T24 window status transmission timer milliseconds. A value of 2147483647 indicates no window timer in use.')
x25OperDataRxmtTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 10), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperDataRxmtTimer.setReference('10733 5.10.1 dataRetransmissionTime (opt); See ISO 8208 Section 11.2.1, table 26')
if mibBuilder.loadTexts: x25OperDataRxmtTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperDataRxmtTimer.setDescription('The T25 Data Retransmission timer in milliseconds. A value of 2147483647 indicates no data retransmission timer in use.')
x25OperInterruptTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 11), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperInterruptTimer.setReference('10733 interruptTime; See ISO 8208 Section 6.8.1, table 26')
if mibBuilder.loadTexts: x25OperInterruptTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperInterruptTimer.setDescription('The T26 Interrupt timer in milliseconds. A value of 2147483647 indicates interrupts are not being used.')
x25OperRejectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 12), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperRejectTimer.setReference('10733 5.10.1 dataRejectTime (opt); See ISO 8208 Section 13.4.1, table 26')
if mibBuilder.loadTexts: x25OperRejectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperRejectTimer.setDescription('The T27 Reject retransmission timer in milliseconds. A value of 2147483647 indicates no reject timer in use.')
x25OperRegistrationRequestTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 13), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperRegistrationRequestTimer.setReference('10733 5.8.1 registrationRequestTime (opt); See ISO 8208 Section 13.1.1.1, table 26')
if mibBuilder.loadTexts: x25OperRegistrationRequestTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperRegistrationRequestTimer.setDescription('The T28 registration timer in milliseconds. A value of 2147483647 indicates no registration timer in use.')
x25OperMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 14), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperMinimumRecallTimer.setReference('10733 5.9 minimum RecallTimer')
if mibBuilder.loadTexts: x25OperMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperMinimumRecallTimer.setDescription('Minimum time interval between unsuccessful call attempts in milliseconds.')
x25OperRestartCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperRestartCount.setReference('10733 5.9 restartCount See ISO 8208 Section 4.1, table 27')
if mibBuilder.loadTexts: x25OperRestartCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperRestartCount.setDescription('The R20 restart retransmission count.')
x25OperResetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperResetCount.setReference('10733 resetCount; See section ISO 8208 8.1, table 27')
if mibBuilder.loadTexts: x25OperResetCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperResetCount.setDescription('The r22 Reset retransmission count.')
x25OperClearCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperClearCount.setReference('10733 clearCount; See ISO 8208 Section 5.5.1, table 27')
if mibBuilder.loadTexts: x25OperClearCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperClearCount.setDescription('The r23 Clear retransmission count.')
x25OperDataRxmtCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperDataRxmtCount.setReference('10733 5.10.1 dataRetransmissionCount (opt); See ISO 8208 Section 11.2.1, table 27')
if mibBuilder.loadTexts: x25OperDataRxmtCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperDataRxmtCount.setDescription('The R25 Data retransmission count. This value is undefined if the x25OperDataRxmtTimer indicates no timer in use.')
x25OperRejectCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperRejectCount.setReference('10733 5.10.1 dataRejectCount (opt)')
if mibBuilder.loadTexts: x25OperRejectCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperRejectCount.setDescription('The R27 reject retransmission count. This value is undefined if the x25OperRejectTimer indicates no timer in use.')
x25OperRegistrationRequestCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperRegistrationRequestCount.setReference('10733 5.8.1 registrationRequestCount (opt); See ISO 8208 Section 13.1.1.1, table 27')
if mibBuilder.loadTexts: x25OperRegistrationRequestCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperRegistrationRequestCount.setDescription('The R28 Registration retransmission Count. This value is undefined if the x25OperREgistrationRequestTimer indicates no timer in use.')
x25OperNumberPVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperNumberPVCs.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperNumberPVCs.setDescription('The number of PVC configured for this PLE. The PVCs use channel numbers from 1 to this number.')
x25OperDefCallParamId = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 22), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperDefCallParamId.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperDefCallParamId.setDescription('This identifies the instance of the x25CallParmIndex for the entry in the x25CallParmTable that contains the default call parameters for this PLE.')
x25OperLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 23), X121Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperLocalAddress.setReference('10733 5.9 localDTEAddress')
if mibBuilder.loadTexts: x25OperLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperLocalAddress.setDescription('The local address for this PLE subnetwork. A zero length address maybe returned by PLEs that only support PVCs.')
x25OperDataLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 24), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperDataLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperDataLinkId.setDescription('This identifies the instance of the index object in the first table of the most device specific MIB for the interface used by this PLE.')
x25OperProtocolVersionSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 3, 1, 25), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25OperProtocolVersionSupported.setReference('10733 5.9 protocolVersionSupported')
if mibBuilder.loadTexts: x25OperProtocolVersionSupported.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperProtocolVersionSupported.setDescription('Identifies the version of the X.25 protocol this interface supports. Object identifiers for common versions are defined below in the x25ProtocolVersion subtree.')
x25StatTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4), )
if mibBuilder.loadTexts: x25StatTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatTable.setDescription('Statistics information about this X.25 PLE.')
x25StatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25StatIndex"))
if mibBuilder.loadTexts: x25StatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatEntry.setDescription('Entries of the x25StatTable.')
x25StatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 1), IfIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatIndex.setDescription('The ifIndex value for the X.25 interface.')
x25StatInCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInCalls.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInCalls.setDescription('The number of incoming calls received.')
x25StatInCallRefusals = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInCallRefusals.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInCallRefusals.setDescription('The number of incoming calls refused. This includes calls refused by the PLE and by higher layers. This also includes calls cleared because of restricted fast select.')
x25StatInProviderInitiatedClears = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInProviderInitiatedClears.setReference('10733 providerInitiatedDisconnect')
if mibBuilder.loadTexts: x25StatInProviderInitiatedClears.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInProviderInitiatedClears.setDescription('The number of clear requests with a cause code other than DTE initiated.')
x25StatInRemotelyInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInRemotelyInitiatedResets.setReference('10733 remotelyInitiatedResets')
if mibBuilder.loadTexts: x25StatInRemotelyInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInRemotelyInitiatedResets.setDescription('The number of reset requests received with cause code DTE initiated.')
x25StatInProviderInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInProviderInitiatedResets.setReference('10733 ProviderInitiatedResets')
if mibBuilder.loadTexts: x25StatInProviderInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInProviderInitiatedResets.setDescription('The number of reset requests received with cause code other than DTE initiated.')
x25StatInRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInRestarts.setReference('10733 5.9 remotelyInitiatedRestarts')
if mibBuilder.loadTexts: x25StatInRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInRestarts.setDescription('The number of remotely initiated (including provider initiated) restarts experienced by the PLE excluding the restart associated with bringing up the PLE interface. This only counts restarts received when the PLE already has an established connection with the remove PLE.')
x25StatInDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInDataPackets.setReference('10733 5.9 dataPacketsReceived.')
if mibBuilder.loadTexts: x25StatInDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInDataPackets.setDescription('The number of data packets received.')
x25StatInAccusedOfProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInAccusedOfProtocolErrors.setReference('CD 10733 5.9 accusedOfProtocolError')
if mibBuilder.loadTexts: x25StatInAccusedOfProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInAccusedOfProtocolErrors.setDescription('The number of packets received containing a procedure error cause code. These include clear, reset, restart, or diagnostic packets.')
x25StatInInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInInterrupts.setReference('10733 interruptPacketsReceived')
if mibBuilder.loadTexts: x25StatInInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInInterrupts.setDescription('The number of interrupt packets received by the PLE or over the PVC/VC.')
x25StatOutCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutCallAttempts.setReference('10733 5.9 callAttempts')
if mibBuilder.loadTexts: x25StatOutCallAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutCallAttempts.setDescription('The number of calls attempted.')
x25StatOutCallFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutCallFailures.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutCallFailures.setDescription('The number of call attempts which failed. This includes calls that were cleared because of restrictive fast select.')
x25StatOutInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutInterrupts.setReference('10733 InterruptPacketsSent')
if mibBuilder.loadTexts: x25StatOutInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutInterrupts.setDescription('The number of interrupt packets send by the PLE or over the PVC/VC.')
x25StatOutDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutDataPackets.setReference('10733 dataPacketSent')
if mibBuilder.loadTexts: x25StatOutDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutDataPackets.setDescription('The number of data packets sent by this PLE.')
x25StatOutgoingCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatOutgoingCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatOutgoingCircuits.setDescription('The number of active outgoing circuits. This includes call requests sent but not yet confirmed. This does not count PVCs.')
x25StatIncomingCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatIncomingCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatIncomingCircuits.setDescription('The number of active Incoming Circuits. This includes call indications received but not yet acknowledged. This does not count PVCs.')
x25StatTwowayCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatTwowayCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatTwowayCircuits.setDescription('The number of active two-way Circuits. This includes call requests sent but not yet confirmed. This does not count PVCs.')
x25StatRestartTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatRestartTimeouts.setReference('10733 5.9 restartTimeouts')
if mibBuilder.loadTexts: x25StatRestartTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatRestartTimeouts.setDescription('The number of times the T20 restart timer expired.')
x25StatCallTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatCallTimeouts.setReference('10733 5.9 callTimeouts')
if mibBuilder.loadTexts: x25StatCallTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatCallTimeouts.setDescription('The number of times the T21 call timer expired.')
x25StatResetTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatResetTimeouts.setReference('10733 5.9 resetTimeouts')
if mibBuilder.loadTexts: x25StatResetTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatResetTimeouts.setDescription('The number of times the T22 reset timer expired.')
x25StatClearTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatClearTimeouts.setReference('10733 5.9 clearTimeouts')
if mibBuilder.loadTexts: x25StatClearTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatClearTimeouts.setDescription('The number of times the T23 clear timer expired.')
x25StatDataRxmtTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatDataRxmtTimeouts.setReference('10733 5.9 dataRetransmissionsTimerExpiries')
if mibBuilder.loadTexts: x25StatDataRxmtTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatDataRxmtTimeouts.setDescription('The number of times the T25 data timer expired.')
x25StatInterruptTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatInterruptTimeouts.setReference('10733 5.9 interruptTimerExpires')
if mibBuilder.loadTexts: x25StatInterruptTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatInterruptTimeouts.setDescription('The number of times the T26 interrupt timer expired.')
x25StatRetryCountExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatRetryCountExceededs.setReference('10733 5.9 retryCountsExceeded')
if mibBuilder.loadTexts: x25StatRetryCountExceededs.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatRetryCountExceededs.setDescription('The number of times a retry counter was exhausted.')
x25StatClearCountExceededs = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatClearCountExceededs.setReference('10733 5.9 clearCountsExceeded')
if mibBuilder.loadTexts: x25StatClearCountExceededs.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatClearCountExceededs.setDescription('The number of times the R23 clear count was exceeded.')
x25ChannelTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5), )
if mibBuilder.loadTexts: x25ChannelTable.setReference('See ISO 8208, Section 3.7')
if mibBuilder.loadTexts: x25ChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelTable.setDescription('These objects contain information about the channel number configuration in an X.25 PLE. These values are the configured values. changes in these values after the interfaces has started may not be reflected in the operating PLE.')
x25ChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25ChannelIndex"))
if mibBuilder.loadTexts: x25ChannelEntry.setReference('This provides the information available in 10733 logicalChannelAssignments.')
if mibBuilder.loadTexts: x25ChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelEntry.setDescription('Entries of x25ChannelTable.')
x25ChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 1), IfIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelIndex.setDescription('The ifIndex value for the X.25 Interface.')
x25ChannelLIC = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelLIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelLIC.setDescription('Lowest Incoming channel.')
x25ChannelHIC = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelHIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelHIC.setDescription('Highest Incoming channel. A value of zero indicates no channels in this range.')
x25ChannelLTC = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelLTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelLTC.setDescription('Lowest Two-way channel.')
x25ChannelHTC = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelHTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelHTC.setDescription('Highest Two-way channel. A value of zero indicates no channels in this range.')
x25ChannelLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelLOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelLOC.setDescription('Lowest outgoing channel.')
x25ChannelHOC = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25ChannelHOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25ChannelHOC.setDescription('Highest outgoing channel. A value of zero indicates no channels in this range.')
x25CircuitTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6), )
if mibBuilder.loadTexts: x25CircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitTable.setDescription('These objects contain general information about a specific circuit of an X.25 PLE.')
x25CircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25CircuitIndex"), (0, "ECX25EXT-MIB", "x25CircuitChannel"))
if mibBuilder.loadTexts: x25CircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitEntry.setDescription('Entries of x25CircuitTable.')
x25CircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 1), IfIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitIndex.setDescription('The ifIndex value for the X.25 Interface.')
x25CircuitChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitChannel.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitChannel.setDescription('The channel number for this circuit.')
x25CircuitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("invalid", 1), ("closed", 2), ("calling", 3), ("open", 4), ("clearing", 5), ("pvc", 6), ("pvcResetting", 7), ("startClear", 8), ("startPvcResetting", 9), ("other", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitStatus.setReference('See ISO 8208, table 33 for (p<n>) state table')
if mibBuilder.loadTexts: x25CircuitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitStatus.setDescription("This object reports the current status of the circuit. An existing instance of this object can only be set to startClear, startPvcResetting, or invalid. An instance with the value calling or open can only be set to startClear and that action will start clearing the circuit. An instance with the value PVC can only be set to startPvcResetting or invalid and that action resets the PVC or deletes the circuit respectively. The values startClear or startPvcResetting will never be returned by an agent. An attempt to set the status of an existing instance to a value other than one of these values will result in an error. A non-existing instance can be set to PVC to create a PVC if the implementation supports dynamic creation of PVCs. Some implementations may only allow creation and deletion of PVCs if the interface is down. Since the instance identifier will supply the PLE index and the channel number, setting this object alone supplies sufficient information to create the instance. All the DEFVAL clauses for the other objects of this table are appropriate for creating a PVC; PLEs creating entries for placed or accepted calls will use values appropriate for the call rather than the value of the DEFVAL clause. Two managers trying to create the same PVC can determine from the return code which manager succeeded and which failed (the failing manager fails because it can not set a value of PVC for an existing object). An entry in the closed or invalid state may be deleted or reused at the agent's convence. If the entry is kept in the closed state, the values of the parameters associated with the entry must be correct. Closed implies the values in the circuit table are correct. The value of invalid indicates the other values in the table are invalid. Many agents may never return a value of invalid because they dynamically allocate and free unused table entries. An agent for a statically configured systems can return invalid to indicate the entry has not yet been used so the counters contain no information.")
x25CircuitEstablishTime = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitEstablishTime.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitEstablishTime.setDescription('The value of sysUpTime when the channel was associated with this circuit. For outgoing SVCs, this is the time the first call packet was sent. For incoming SVCs, this is the time the call indication was received. For PVCs this is the time the PVC was able to pass data to a higher layer entity without loss of data.')
x25CircuitDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("pvc", 3))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitDirection.setReference('10733 direction')
if mibBuilder.loadTexts: x25CircuitDirection.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitDirection.setDescription('The direction of the call that established this circuit.')
x25CircuitInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInOctets.setReference('5.11 octetsReceivedCounter')
if mibBuilder.loadTexts: x25CircuitInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInOctets.setDescription('The number of octets of user data delivered to upper layer.')
x25CircuitInPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInPdus.setReference('10733 5.11 dataPacketsReceived')
if mibBuilder.loadTexts: x25CircuitInPdus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInPdus.setDescription('The number of PDUs received for this circuit.')
x25CircuitInRemotelyInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInRemotelyInitiatedResets.setReference('10733 remotelyInitiatedResets')
if mibBuilder.loadTexts: x25CircuitInRemotelyInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInRemotelyInitiatedResets.setDescription('The number of Resets received for this circuit with cause code of DTE initiated.')
x25CircuitInProviderInitiatedResets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInProviderInitiatedResets.setReference('10733 ProviderInitiatedResets')
if mibBuilder.loadTexts: x25CircuitInProviderInitiatedResets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInProviderInitiatedResets.setDescription('The number of Resets received for this circuit with cause code other than DTE initiated.')
x25CircuitInInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInInterrupts.setReference('10733 interruptPacketsReceived')
if mibBuilder.loadTexts: x25CircuitInInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInInterrupts.setDescription('The number of interrupt packets received for this circuit.')
x25CircuitOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOutOctets.setReference('10733 5.11 octetsSentCounter')
if mibBuilder.loadTexts: x25CircuitOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOutOctets.setDescription('The number of octets of user data sent for this circuit.')
x25CircuitOutPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOutPdus.setReference('10733 5.11 dataPacketsSent')
if mibBuilder.loadTexts: x25CircuitOutPdus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOutPdus.setDescription('The number of PDUs sent for this circuit.')
x25CircuitOutInterrupts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitOutInterrupts.setReference('10733 interruptPacketsSent')
if mibBuilder.loadTexts: x25CircuitOutInterrupts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOutInterrupts.setDescription('The number of interrupt packets sent on this circuit.')
x25CircuitDataRetransmissionTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitDataRetransmissionTimeouts.setReference('10733 5.11 dataRetransmissionTimerExpiries')
if mibBuilder.loadTexts: x25CircuitDataRetransmissionTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitDataRetransmissionTimeouts.setDescription('The number of times the T25 data retransmission timer expired for this circuit.')
x25CircuitResetTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitResetTimeouts.setReference('10733 5.11 resetTimeouts')
if mibBuilder.loadTexts: x25CircuitResetTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitResetTimeouts.setDescription('The number of times the T22 reset timer expired for this circuit.')
x25CircuitInterruptTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CircuitInterruptTimeouts.setReference('10733 interruptTimerExpiries')
if mibBuilder.loadTexts: x25CircuitInterruptTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitInterruptTimeouts.setDescription('The number of times the T26 Interrupt timer expired for this circuit.')
x25CircuitCallParamId = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 17), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitCallParamId.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitCallParamId.setDescription('This identifies the instance of the x25CallParmIndex for the entry in the x25CallParmTable which contains the call parameters in use with this circuit. The entry referenced must contain the values that are currently in use by the circuit rather than proposed values. A value of NULL indicates the circuit is a PVC or is using all the default parameters.')
x25CircuitCalledDteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 18), X121Address().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitCalledDteAddress.setReference('10733 calledDTEAddress')
if mibBuilder.loadTexts: x25CircuitCalledDteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitCalledDteAddress.setDescription('For incoming calls, this is the called address from the call indication packet. For outgoing calls, this is the called address from the call confirmation packet. This will be zero length for PVCs.')
x25CircuitCallingDteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 19), X121Address().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitCallingDteAddress.setReference('10733 callingDTEAddress')
if mibBuilder.loadTexts: x25CircuitCallingDteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitCallingDteAddress.setDescription('For incoming calls, this is the calling address from the call indication packet. For outgoing calls, this is the calling address from the call confirmation packet. This will be zero length for PVCs.')
x25CircuitOriginallyCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 20), X121Address().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitOriginallyCalledAddress.setReference('10733 originallyCalledAddress')
if mibBuilder.loadTexts: x25CircuitOriginallyCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitOriginallyCalledAddress.setDescription('For incoming calls, this is the address in the call Redirection or Call Deflection Notification facility if the call was deflected or redirected, otherwise it will be called address from the call indication packet. For outgoing calls, this is the address from the call request packet. This will be zero length for PVCs.')
x25CircuitDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 6, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CircuitDescr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CircuitDescr.setDescription("A descriptive string associated with this circuit. This provides a place for the agent to supply any descriptive information it knows about the use or owner of the circuit. The agent may return the process identifier and user name for the process using the circuit. Alternative the agent may return the name of the configuration entry that caused a bridge to establish the circuit. A zero length value indicates the agent doesn't have any additional information.")
x25CallParmTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7), )
if mibBuilder.loadTexts: x25CallParmTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmTable.setDescription('These objects contain the parameters that can be varied between X.25 calls. The entries in this table are independent of the PLE. There exists only one of these tables for the entire system. The indexes for the entries are independent of any PLE or any circuit. Other tables reference entries in this table. Entries in this table can be used for default PLE parameters, for parameters to use to place/answer a call, for the parameters currently in use for a circuit, or parameters that were used by a circuit. The number of references to a given set of parameters can be found in the x25CallParmRefCount object sharing the same instance identifier with the parameters. The value of this reference count also affects the access of the objects in this table. An object in this table with the same instance identifier as the instance identifier of an x25CallParmRefCount must be consider associated with that reference count. An object with an associated reference count of zero can be written (if its ACCESS clause allows it). An object with an associated reference count greater than zero can not be written (regardless of the ACCESS clause). This ensures that a set of call parameters being referenced from another table can not be modified or changed in a ways inappropriate for continued use by that table.')
x25CallParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1), ).setIndexNames((0, "ECX25EXT-MIB", "x25CallParmIndex"))
if mibBuilder.loadTexts: x25CallParmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmEntry.setDescription('Entries of x25CallParmTable.')
x25CallParmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 1), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallParmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmIndex.setDescription('A value that distinguishes this entry from another entry. Entries in this table are referenced from other objects which identify call parameters. It is impossible to know which other objects in the MIB reference entries in the table by looking at this table. Because of this, changes to parameters must be accomplished by creating a new entry in this table and then changing the referencing table to identify the new entry. Note that an agent will only use the values in this table when another table is changed to reference those values. The number of other tables that reference an index object in this table can be found in x25CallParmRefCount. The value of the reference count will affect the writability of the objects as explained above. Entries in this table which have a reference count of zero maybe deleted at the convence of the agent. Care should be taken by the agent to give the NMS sufficient time to create a reference to newly created entries. Should a Management Station not find a free index with which to create a new entry, it may feel free to delete entries with a reference count of zero. However in doing so the Management Station much realize it may impact other Management Stations.')
x25CallParmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 2), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmStatus.setDescription('The status of this call parameter entry. See RFC 1271 for details of usage.')
x25CallParmRefCount = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 3), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallParmRefCount.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmRefCount.setDescription('The number of references know by a management station to exist to this set of call parameters. This is the number of other objects that have returned a value of, and will return a value of, the index for this set of call parameters. Examples of such objects are the x25AdmnDefCallParamId, x25OperDataLinkId, or x25AdmnDefCallParamId objects defined above.')
x25CallParmInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInPacketSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25CallParmInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInPacketSize.setDescription('The maximum receive packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE means use a default size of 128.')
x25CallParmOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutPacketSize.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.1.1')
if mibBuilder.loadTexts: x25CallParmOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutPacketSize.setDescription('The maximum transmit packet size in octets for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use a default size of 128.')
x25CallParmInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInWindowSize.setReference('10733 proposedWindowSize; See ISO 8208 Section 15.2.2.1.2')
if mibBuilder.loadTexts: x25CallParmInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInWindowSize.setDescription('The receive window size for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use 2.')
x25CallParmOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutWindowSize.setReference('10733 proposedWindowSize; See ISO 8208 Section 15.2.2.1.2')
if mibBuilder.loadTexts: x25CallParmOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutWindowSize.setDescription('The transmit window size for a circuit. A size of zero for a circuit means use the PLE default size. A size of zero for the PLE default means use 2.')
x25CallParmAcceptReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("accept", 2), ("refuse", 3), ("neverAccept", 4))).clone('refuse')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmAcceptReverseCharging.setReference('10733 acceptReverseCharging')
if mibBuilder.loadTexts: x25CallParmAcceptReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmAcceptReverseCharging.setDescription('An enumeration defining if the PLE will accept or refuse charges. A value of default for a circuit means use the PLE default value. A value of neverAccept is only used for the PLE default and indicates the PLE will never accept reverse charging. A value of default for a PLE default means refuse.')
x25CallParmProposeReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("reverse", 2), ("local", 3))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmProposeReverseCharging.setReference('10733 proposedPacketSize; See ISO 8208 Section 15.2.2.6')
if mibBuilder.loadTexts: x25CallParmProposeReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmProposeReverseCharging.setDescription('An enumeration defining if the PLE should propose reverse or local charging. The value of default for a circuit means use the PLE default. The value of default for the PLE default means use local.')
x25CallParmFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("default", 1), ("notSpecified", 2), ("fastSelect", 3), ("restrictedFastResponse", 4), ("noFastSelect", 5), ("noRestrictedFastResponse", 6))).clone('noFastSelect')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmFastSelect.setReference('10733 fastSelect; Sec ISO 8208 Section 15.2.2.6')
if mibBuilder.loadTexts: x25CallParmFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmFastSelect.setDescription('Expresses preference for use of fast select facility. The value of default for a circuit is the PLE default. A value of default for the PLE means noFastSelect. A value of noFastSelect or noRestrictedFastResponse indicates a circuit may not use fast select or restricted fast response.')
x25CallParmInThruPutClasSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("tcReserved1", 1), ("tcReserved2", 2), ("tc75", 3), ("tc150", 4), ("tc300", 5), ("tc600", 6), ("tc1200", 7), ("tc2400", 8), ("tc4800", 9), ("tc9600", 10), ("tc19200", 11), ("tc48000", 12), ("tc64000", 13), ("tcReserved14", 14), ("tcReserved15", 15), ("tcReserved0", 16), ("tcNone", 17), ("tcDefault", 18))).clone('tcNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInThruPutClasSize.setReference('See ISO 8208 Section 15.2.2.2, table 18')
if mibBuilder.loadTexts: x25CallParmInThruPutClasSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInThruPutClasSize.setDescription('The incoming throughput class to negotiate. A value of tcDefault for a circuit means use the PLE default. A value of tcDefault for the PLE default means tcNone. A value of tcNone means do not negotiate throughtput class.')
x25CallParmOutThruPutClasSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("tcReserved1", 1), ("tcReserved2", 2), ("tc75", 3), ("tc150", 4), ("tc300", 5), ("tc600", 6), ("tc1200", 7), ("tc2400", 8), ("tc4800", 9), ("tc9600", 10), ("tc19200", 11), ("tc48000", 12), ("tc64000", 13), ("tcReserved14", 14), ("tcReserved15", 15), ("tcReserved0", 16), ("tcNone", 17), ("tcDefault", 18))).clone('tcNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutThruPutClasSize.setReference('See ISO 8208 Section 15.2.2.2, table 18')
if mibBuilder.loadTexts: x25CallParmOutThruPutClasSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutThruPutClasSize.setDescription('The outgoing throughput class to negotiate. A value of tcDefault for a circuit means use the PLE default. A value of tcDefault for the PLE default means use tcNone. A value of tcNone means do not negotiate throughtput class.')
x25CallParmCug = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCug.setReference('See ISO 8208 Section 15.2.2.3')
if mibBuilder.loadTexts: x25CallParmCug.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCug.setDescription('The Closed User Group to specify. This consists of two or four octets containing the characters 0 through 9. A zero length string indicates no facility requested. A string length of three containing the characters DEF for a circuit means use the PLE default, (the PLE default parameter may not reference an entry of DEF.)')
x25CallParmCugoa = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCugoa.setReference('See ISO 8208 Section 15.2.2.4')
if mibBuilder.loadTexts: x25CallParmCugoa.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCugoa.setDescription('The Closed User Group with Outgoing Access to specify. This consists of two or four octets containing the characters 0 through 9. A string length of three containing the characters DEF for a circuit means use the PLE default (the PLE default parameters may not reference an entry of DEF). A zero length string indicates no facility requested.')
x25CallParmBcug = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmBcug.setReference('See ISO 8208 Section 15.2.2.5')
if mibBuilder.loadTexts: x25CallParmBcug.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmBcug.setDescription('The Bilateral Closed User Group to specify. This consists of two octets containing the characters 0 through 9. A string length of three containing the characters DEF for a circuit means use the PLE default (the PLE default parameter may not reference an entry of DEF). A zero length string indicates no facility requested.')
x25CallParmNui = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmNui.setReference('See ISO 8208 Section 15.2.2.7')
if mibBuilder.loadTexts: x25CallParmNui.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmNui.setDescription('The Network User Identifier facility. This is binary value to be included immediately after the length field. The PLE will supply the length octet. A zero length string indicates no facility requested. This value is ignored for the PLE default parameters entry.')
x25CallParmChargingInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("noFacility", 2), ("noChargingInfo", 3), ("chargingInfo", 4))).clone('noFacility')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmChargingInfo.setReference('See ISO 8208 Section 15.2.2.8')
if mibBuilder.loadTexts: x25CallParmChargingInfo.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmChargingInfo.setDescription('The charging Information facility. A value of default for a circuit means use the PLE default. The value of default for the default PLE parameters means use noFacility. The value of noFacility means do not include a facility.')
x25CallParmRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmRpoa.setReference('See ISO 8208, section 15.2.2.9')
if mibBuilder.loadTexts: x25CallParmRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmRpoa.setDescription('The RPOA facility. The octet string contains n * 4 sequences of the characters 0-9 to specify a facility with n entries. The octet string containing the 3 characters DEF for a circuit specifies use of the PLE default (the entry for the PLE default may not contain DEF). A zero length string indicates no facility requested.')
x25CallParmTrnstDly = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65537)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmTrnstDly.setReference('See ISO 8208, Section 15.2.2.13')
if mibBuilder.loadTexts: x25CallParmTrnstDly.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmTrnstDly.setDescription('The Transit Delay Selection and Indication value. A value of 65536 indicates no facility requested. A value of 65537 for a circuit means use the PLE default (the PLE default parameters entry may not use the value 65537). The value 65535 may only be used to indicate the value in use by a circuit.')
x25CallParmCallingExt = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCallingExt.setReference('See ISO 8208 Section 15.3.2.1')
if mibBuilder.loadTexts: x25CallParmCallingExt.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCallingExt.setDescription('The Calling Extension facility. This contains one of the following: A sequence of hex digits with the value to be put in the facility. These digits will be converted to binary by the agent and put in the facility. These octets do not include the length octet. A value containing the three character DEF for a circuit means use the PLE default, (the entry for the PLE default parameters may not use the value DEF). A zero length string indicates no facility requested.')
x25CallParmCalledExt = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCalledExt.setReference('See ISO 8208 Section 15.3.2.2')
if mibBuilder.loadTexts: x25CallParmCalledExt.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCalledExt.setDescription('The Called Extension facility. This contains one of the following: A sequence of hex digits with the value to be put in the facility. These digits will be converted to binary by the agent and put in the facility. These octets do not include the length octet. A value containing the three character DEF for a circuit means use the PLE default, (the entry for the PLE default parameters may not use the value DEF). A zero length string indicates no facility requested.')
x25CallParmInMinThuPutCls = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmInMinThuPutCls.setReference('See ISO 8208 Section 15.3.2.3')
if mibBuilder.loadTexts: x25CallParmInMinThuPutCls.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmInMinThuPutCls.setDescription('The minimum input throughput Class. A value of 16 for a circuit means use the PLE default (the PLE parameters entry may not use this value). A value of 17 indicates no facility requested.')
x25CallParmOutMinThuPutCls = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmOutMinThuPutCls.setReference('See ISO 8208 Section 15.3.2.3')
if mibBuilder.loadTexts: x25CallParmOutMinThuPutCls.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmOutMinThuPutCls.setDescription('The minimum output throughput Class. A value of 16 for a circuit means use the PLE default (the PLE parameters entry may not use this value). A value of 17 indicates no facility requested.')
x25CallParmEndTrnsDly = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmEndTrnsDly.setReference('See ISO 8208 Section 15.3.2.4')
if mibBuilder.loadTexts: x25CallParmEndTrnsDly.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmEndTrnsDly.setDescription('The End-to-End Transit Delay to negotiate. An octet string of length 2, 4, or 6 contains the facility encoded as specified in ISO/IEC 8208 section 15.3.2.4. An octet string of length 3 containing the three character DEF for a circuit means use the PLE default (the entry for the PLE default can not contain the characters DEF). A zero length string indicates no facility requested.')
x25CallParmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmPriority.setReference('See ISO 8208 Section 15.3.2.5')
if mibBuilder.loadTexts: x25CallParmPriority.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmPriority.setDescription('The priority facility to negotiate. The octet string encoded as specified in ISO/IEC 8208 section 15.3.2.5. A zero length string indicates no facility requested. The entry for the PLE default parameters must be zero length.')
x25CallParmProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmProtection.setReference('See ISO 8208 Section 15.3.2.5')
if mibBuilder.loadTexts: x25CallParmProtection.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmProtection.setDescription('A string contains the following: A hex string containing the value for the protection facility. This will be converted from hex to the octets actually in the packet by the agent. The agent will supply the length field and the length octet is not contained in this string. An string containing the 3 characters DEF for a circuit means use the PLE default (the entry for the PLE default parameters may not use the value DEF). A zero length string mean no facility requested.')
x25CallParmExptData = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("noExpeditedData", 2), ("expeditedData", 3))).clone('noExpeditedData')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmExptData.setReference('See ISO 8208 Section 15.3.2.7')
if mibBuilder.loadTexts: x25CallParmExptData.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmExptData.setDescription('The Expedited Data facility to negotiate. A value of default for a circuit means use the PLE default value. The entry for the PLE default parameters may not have the value default.')
x25CallParmUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmUserData.setReference('See ISO 8208 Section 12.2.1.1.6, 12.2.1.2')
if mibBuilder.loadTexts: x25CallParmUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmUserData.setDescription('The call user data as placed in the packet. A zero length string indicates no call user data. If both the circuit call parameters and the PLE default have call user data defined, the data from the circuit call parameters will be used. If only the PLE has data defined, the PLE entry will be used. If neither the circuit call parameters or the PLE default entry has a value, no call user data will be sent.')
x25CallParmCallingNetworkFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCallingNetworkFacilities.setReference('See ISO 8206 Section 15.1, category b')
if mibBuilder.loadTexts: x25CallParmCallingNetworkFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCallingNetworkFacilities.setDescription('The calling network facilities. The facilities are encoded here exactly as encoded in the call packet. These facilities do not include the marker facility code. A zero length string in the entry for the parameter to use when establishing a circuit means use the PLE default. A zero length string in the entry for PLE default parameters indicates no default facilities.')
x25CallParmCalledNetworkFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 4, 5, 7, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallParmCalledNetworkFacilities.setReference('See ISO 8206 Section 15.1, category c')
if mibBuilder.loadTexts: x25CallParmCalledNetworkFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallParmCalledNetworkFacilities.setDescription('The called network facilities. The facilities are encoded here exactly as encoded in the call packet. These facilities do not include the marker facility code. A zero length string in the entry for the parameter to use when establishing a circuit means use the PLE default. A zero length string in the entry for PLE default parameters indicates no default facilities.')
x25Restart = NotificationType((1, 3, 6, 1, 4, 1, 434) + (0,451)).setObjects(("ECX25EXT-MIB", "x25OperIndex"))
if mibBuilder.loadTexts: x25Restart.setDescription('This trap means the X.25 PLE sent or received a restart packet. The restart that brings up the link should not send a x25Restart trap so the interface should send a linkUp trap. Sending this trap means the agent does not send a linkDown and linkUp trap.')
x25Reset = NotificationType((1, 3, 6, 1, 4, 1, 434) + (0,2)).setObjects(("ECX25EXT-MIB", "x25CircuitIndex"), ("ECX25EXT-MIB", "x25CircuitChannel"))
if mibBuilder.loadTexts: x25Reset.setDescription('If the PLE sends or receives a reset, the agent should send an x25Reset trap.')
mibBuilder.exportSymbols("ECX25EXT-MIB", x25CallParmIndex=x25CallParmIndex, x25CallParmInPacketSize=x25CallParmInPacketSize, x25RegisterConfirmRxs=x25RegisterConfirmRxs, x25RNRsTxs=x25RNRsTxs, x25Reset=x25Reset, x25ClearReqTxs=x25ClearReqTxs, x25CallParmProposeReverseCharging=x25CallParmProposeReverseCharging, x25OperResetCount=x25OperResetCount, x25CircuitInPdus=x25CircuitInPdus, x25CallParmOutPacketSize=x25CallParmOutPacketSize, x25CallParmNui=x25CallParmNui, x25DataSegmentsTxs=x25DataSegmentsTxs, x25StatInCallRefusals=x25StatInCallRefusals, x25ChannelLTC=x25ChannelLTC, x25CircuitOutInterrupts=x25CircuitOutInterrupts, x25ClrConfirmRxs=x25ClrConfirmRxs, x25CallParmTable=x25CallParmTable, x25StatOutgoingCircuits=x25StatOutgoingCircuits, x25StatOutCallFailures=x25StatOutCallFailures, x25DiagnosticPktsTxs=x25DiagnosticPktsTxs, x25OperCallTimer=x25OperCallTimer, x25CircuitEstablishTime=x25CircuitEstablishTime, x25VCCallParmTable=x25VCCallParmTable, x25CallParmOutThruPutClasSize=x25CallParmOutThruPutClasSize, x25CallParmCug=x25CallParmCug, x25StatInDataPackets=x25StatInDataPackets, x25OperNumberPVCs=x25OperNumberPVCs, x25StatTwowayCircuits=x25StatTwowayCircuits, x25StatClearTimeouts=x25StatClearTimeouts, x25REJsRxs=x25REJsRxs, x25StatInRestarts=x25StatInRestarts, x25StatOutDataPackets=x25StatOutDataPackets, x25ResetConfirmRxs=x25ResetConfirmRxs, x25CircuitCallParamId=x25CircuitCallParamId, IfIndexType=IfIndexType, x25OperEntry=x25OperEntry, x25OperMaxActiveCircuits=x25OperMaxActiveCircuits, x25OperClearTimer=x25OperClearTimer, x25UnknownPktsRxs=x25UnknownPktsRxs, x25ChannelLOC=x25ChannelLOC, x25CountersTable=x25CountersTable, x25StatIndex=x25StatIndex, x25ext=x25ext, x25CallParmEndTrnsDly=x25CallParmEndTrnsDly, x25IntConfirmTxs=x25IntConfirmTxs, x25OperDataLinkId=x25OperDataLinkId, x25StatEntry=x25StatEntry, x25CallParmPriority=x25CallParmPriority, x25OperDataRxmtTimer=x25OperDataRxmtTimer, x25VCCallParmInPacketSize=x25VCCallParmInPacketSize, x25CallReqRxs=x25CallReqRxs, x25ChannelEntry=x25ChannelEntry, module=module, x25DataSegmentsRxs=x25DataSegmentsRxs, x25CircuitEntry=x25CircuitEntry, x25OperRegistrationRequestTimer=x25OperRegistrationRequestTimer, x25ChannelTable=x25ChannelTable, x25RestartReqRxs=x25RestartReqRxs, x25ResetConfirmTxs=x25ResetConfirmTxs, x25OperPacketSequencing=x25OperPacketSequencing, x25CircuitOriginallyCalledAddress=x25CircuitOriginallyCalledAddress, x25OperClearCount=x25OperClearCount, x25CallConfirmTxs=x25CallConfirmTxs, x25VCCallParmCalledNetworkFacilities=x25VCCallParmCalledNetworkFacilities, management=management, x25CallParmFastSelect=x25CallParmFastSelect, x25OperWindowTimer=x25OperWindowTimer, x25UnknownPktsTxs=x25UnknownPktsTxs, x25OperRegistrationRequestCount=x25OperRegistrationRequestCount, x25CircuitInInterrupts=x25CircuitInInterrupts, x25OperResetTimer=x25OperResetTimer, x25CircuitDataRetransmissionTimeouts=x25CircuitDataRetransmissionTimeouts, x25RestartReqTxs=x25RestartReqTxs, x25StatResetTimeouts=x25StatResetTimeouts, x25ChannelHIC=x25ChannelHIC, x25VCCallParmOutWindowSize=x25VCCallParmOutWindowSize, x25StatCallTimeouts=x25StatCallTimeouts, x25ClearReqRxs=x25ClearReqRxs, x25ChannelHOC=x25ChannelHOC, x25InterrReqTxs=x25InterrReqTxs, EntryStatus=EntryStatus, x25RestartConfirmTxs=x25RestartConfirmTxs, x25CircuitOutOctets=x25CircuitOutOctets, x25CircuitDescr=x25CircuitDescr, x25VCCallParmEntry=x25VCCallParmEntry, x25RegisterReqRxs=x25RegisterReqRxs, x25VCCallParmInWindowSize=x25VCCallParmInWindowSize, x25REJsTxs=x25REJsTxs, x25CallConfirmRxs=x25CallConfirmRxs, x25StatDataRxmtTimeouts=x25StatDataRxmtTimeouts, x25OperTable=x25OperTable, x25RNRsRxs=x25RNRsRxs, x25CircuitCallingDteAddress=x25CircuitCallingDteAddress, PositiveInteger=PositiveInteger, x25CountPortRef=x25CountPortRef, x25CallParmAcceptReverseCharging=x25CallParmAcceptReverseCharging, x25CircuitIndex=x25CircuitIndex, x25CallParmChargingInfo=x25CallParmChargingInfo, x25OperInterruptTimer=x25OperInterruptTimer, x25OperDefCallParamId=x25OperDefCallParamId, x25StatInRemotelyInitiatedResets=x25StatInRemotelyInitiatedResets, x25StatOutCallAttempts=x25StatOutCallAttempts, x25OperProtocolVersionSupported=x25OperProtocolVersionSupported, x25VCCallParmCallingNetworkFacilities=x25VCCallParmCallingNetworkFacilities, x25StatInProviderInitiatedClears=x25StatInProviderInitiatedClears, x25CircuitChannel=x25CircuitChannel, x25CircuitStatus=x25CircuitStatus, x25InterrReqRxs=x25InterrReqRxs, x25RRRxs=x25RRRxs, x25StatInProviderInitiatedResets=x25StatInProviderInitiatedResets, x25CallParmUserData=x25CallParmUserData, DisplayString=DisplayString, x25ResetReqRxs=x25ResetReqRxs, x25CaractersTxs=x25CaractersTxs, x25CircuitInOctets=x25CircuitInOctets, x25CircuitTable=x25CircuitTable, x25RegisterConfirmTxs=x25RegisterConfirmTxs, x25CallParmRpoa=x25CallParmRpoa, x25VCCallParmVCIndex=x25VCCallParmVCIndex, x25CallParmCalledNetworkFacilities=x25CallParmCalledNetworkFacilities, x25IntConfirmRxs=x25IntConfirmRxs, x25ChannelLIC=x25ChannelLIC, x25OperRestartTimer=x25OperRestartTimer, x25CallParmRefCount=x25CallParmRefCount, x25CallParmBcug=x25CallParmBcug, x25CallParmProtection=x25CallParmProtection, x25Restart=x25Restart, x25OperDataRxmtCount=x25OperDataRxmtCount, x25CallParmCallingNetworkFacilities=x25CallParmCallingNetworkFacilities, x25StatTable=x25StatTable, x25RestartConfirmRxs=x25RestartConfirmRxs, x25StatInInterrupts=x25StatInInterrupts, x25CallParmInThruPutClasSize=x25CallParmInThruPutClasSize, x25CallParmCallingExt=x25CallParmCallingExt, x25StatInCalls=x25StatInCalls, x25CaractersRxs=x25CaractersRxs, x25ResetReqTxs=x25ResetReqTxs, x25OperRejectTimer=x25OperRejectTimer, mibv2=mibv2, x25CountEntry=x25CountEntry, x25CallParmInWindowSize=x25CallParmInWindowSize, x25CircuitCalledDteAddress=x25CircuitCalledDteAddress, x25VCCallParmPortIndex=x25VCCallParmPortIndex, x25ClrConfirmTxs=x25ClrConfirmTxs, x25CircuitOutPdus=x25CircuitOutPdus, x25CallParmOutWindowSize=x25CallParmOutWindowSize, x25OperMinimumRecallTimer=x25OperMinimumRecallTimer, x25CircuitDirection=x25CircuitDirection, x25OperLocalAddress=x25OperLocalAddress, X121Address=X121Address, x25CallParmCalledExt=x25CallParmCalledExt, x25StatRetryCountExceededs=x25StatRetryCountExceededs, x25RRTxs=x25RRTxs, x25VCCallParmOutPacketSize=x25VCCallParmOutPacketSize, x25VCCallParmUserData=x25VCCallParmUserData, x25CircuitInProviderInitiatedResets=x25CircuitInProviderInitiatedResets, x25CallParmCugoa=x25CallParmCugoa, x25CallParmOutMinThuPutCls=x25CallParmOutMinThuPutCls, x25OperRejectCount=x25OperRejectCount, x25StatClearCountExceededs=x25StatClearCountExceededs, x25CallParmEntry=x25CallParmEntry, x25OperIndex=x25OperIndex, x25StatOutInterrupts=x25StatOutInterrupts, x25ChannelIndex=x25ChannelIndex, x25StatInterruptTimeouts=x25StatInterruptTimeouts, x25StatInAccusedOfProtocolErrors=x25StatInAccusedOfProtocolErrors, eicon=eicon, x25StatRestartTimeouts=x25StatRestartTimeouts, x25OperRestartCount=x25OperRestartCount, x25CallReqTxs=x25CallReqTxs, x25ChannelHTC=x25ChannelHTC, x25CircuitResetTimeouts=x25CircuitResetTimeouts, x25CallParmExptData=x25CallParmExptData, x25DiagnosticPktsRxs=x25DiagnosticPktsRxs, x25OperInterfaceMode=x25OperInterfaceMode, x25StatIncomingCircuits=x25StatIncomingCircuits, x25CallParmStatus=x25CallParmStatus, x25CallParmTrnstDly=x25CallParmTrnstDly, x25CallParmInMinThuPutCls=x25CallParmInMinThuPutCls, x25CircuitInRemotelyInitiatedResets=x25CircuitInRemotelyInitiatedResets, x25RegisterReqTxs=x25RegisterReqTxs, x25CircuitInterruptTimeouts=x25CircuitInterruptTimeouts)

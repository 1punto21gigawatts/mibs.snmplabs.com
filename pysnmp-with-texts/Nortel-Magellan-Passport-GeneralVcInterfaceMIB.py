#
# PySNMP MIB module Nortel-Magellan-Passport-GeneralVcInterfaceMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-GeneralVcInterfaceMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:27:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
InterfaceIndex, DisplayString, Counter32, RowStatus, Unsigned32, Integer32, Gauge32, RowPointer, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "InterfaceIndex", "DisplayString", "Counter32", "RowStatus", "Unsigned32", "Integer32", "Gauge32", "RowPointer", "StorageType")
EnterpriseDateAndTime, NonReplicated, DashedHexString, AsciiString, DigitString, HexString, Hex, Link = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "EnterpriseDateAndTime", "NonReplicated", "DashedHexString", "AsciiString", "DigitString", "HexString", "Hex", "Link")
components, passportMIBs = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "components", "passportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, IpAddress, Counter32, MibIdentifier, TimeTicks, iso, Integer32, NotificationType, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, ModuleIdentity, ObjectIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "IpAddress", "Counter32", "MibIdentifier", "TimeTicks", "iso", "Integer32", "NotificationType", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "ModuleIdentity", "ObjectIdentity", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
generalVcInterfaceMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58))
gvcIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107))
gvcIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 1), )
if mibBuilder.loadTexts: gvcIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIf components.')
gvcIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"))
if mibBuilder.loadTexts: gvcIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRowStatusEntry.setDescription('A single entry in the table represents a single gvcIf component.')
gvcIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIf components. These components can be added and deleted.')
gvcIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfStorageType.setDescription('This variable represents the storage type value for the gvcIf tables.')
gvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: gvcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfIndex.setDescription('This variable represents the index for the gvcIf tables.')
gvcIfCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 30), )
if mibBuilder.loadTexts: gvcIfCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
gvcIfCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 30, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"))
if mibBuilder.loadTexts: gvcIfCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCidDataEntry.setDescription('An entry in the gvcIfCidDataTable.')
gvcIfCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 30, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
gvcIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 31), )
if mibBuilder.loadTexts: gvcIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfProvTable.setDescription('This group provides the administrative set of parameters for the GvcIf component.')
gvcIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 31, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"))
if mibBuilder.loadTexts: gvcIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfProvEntry.setDescription('An entry in the gvcIfProvTable.')
gvcIfLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 31, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLogicalProcessor.setDescription('This attribute specifies the logical processor on which the General VC Interface service is running.')
gvcIfMaxActiveLinkStation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 31, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfMaxActiveLinkStation.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfMaxActiveLinkStation.setDescription('This attribute specifies the total number of link station connections that can be active on this service instance. In total maxActiveLinkStation determines the maximum number of Lcn components which may exist at a given time. Once this number is reached no calls will be initiated or accepted by this service instance.')
gvcIfStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 32), )
if mibBuilder.loadTexts: gvcIfStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
gvcIfStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 32, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"))
if mibBuilder.loadTexts: gvcIfStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfStateEntry.setDescription('An entry in the gvcIfStateTable.')
gvcIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 32, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
gvcIfOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 32, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
gvcIfUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 32, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
gvcIfOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 33), )
if mibBuilder.loadTexts: gvcIfOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfOpTable.setDescription('This group contains the operational attributes of the GvcIf component.')
gvcIfOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 33, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"))
if mibBuilder.loadTexts: gvcIfOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfOpEntry.setDescription('An entry in the gvcIfOpTable.')
gvcIfActiveLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 33, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfActiveLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfActiveLinkStations.setDescription('This attribute indicates the number of active link station connections on this service instance at the time of the query. It includes the link stations using the Qllc, the Frame-Relay BAN and the Frame-Relay BNN connections.')
gvcIfIssueLcnClearAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 33, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfIssueLcnClearAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfIssueLcnClearAlarm.setDescription('This attribute indicates whether alarm issuing is allowed or disallowed whenever an Lcn is cleared. Alarm issuing should be allowed only for monitoring problems.')
gvcIfActiveQllcCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 33, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfActiveQllcCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfActiveQllcCalls.setDescription('This attribute indicates the number of active Qllc calls on this service instance at the time of the query. It includes incoming and outgoing calls.')
gvcIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34), )
if mibBuilder.loadTexts: gvcIfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfStatsTable.setDescription('This group contains the statistics for the GvcIf component.')
gvcIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"))
if mibBuilder.loadTexts: gvcIfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfStatsEntry.setDescription('An entry in the gvcIfStatsTable.')
gvcIfCallsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfCallsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCallsToNetwork.setDescription('This attribute counts the number of Qllc and Frame-Relay calls initiated by this interface into the subnet, including successful and failed calls. When the maximum count is exceeded the count wraps to zero.')
gvcIfCallsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfCallsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCallsFromNetwork.setDescription('This attribute counts the number of Qllc and Frame-Relay calls received from the subnet by this interface, including successful and failed calls. When the maximum count is exceeded the count wraps to zero.')
gvcIfCallsRefusedByNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfCallsRefusedByNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCallsRefusedByNetwork.setDescription('This attribute counts the number of outgoing Qllc and Frame-Relay calls refused by the subnetwork. When the maximum count is exceeded the count wraps to zero.')
gvcIfCallsRefusedByInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfCallsRefusedByInterface.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfCallsRefusedByInterface.setDescription('This attribute counts the number of incoming Qllc and Frame-Relay calls refused by the interface. When the maximum count is exceeded the count wraps to zero.')
gvcIfPeakActiveLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfPeakActiveLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfPeakActiveLinkStations.setDescription('This attribute indicates the maximum value of concurrently active link station connections since the service became active.')
gvcIfBcastFramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfBcastFramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfBcastFramesDiscarded.setDescription('This attribute counts the number of broadcast frames that have been discarded because they do not meet one of the following criterias: - the source MAC address does not match the instance of at least one SourceMACFilter component, - the destination MAC address does not match the instance of at least one DestinationMACFilter component. When the maximum count is exceeded the count wraps to zero.')
gvcIfDiscardedQllcCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 34, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDiscardedQllcCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDiscardedQllcCalls.setDescription('This attribute indicates the number of Qllc calls that are discarded because the maxActiveLinkStation threshold is exceeded. When the maximum count is exceeded the count wraps to zero.')
gvcIfDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2))
gvcIfDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1), )
if mibBuilder.loadTexts: gvcIfDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDc components.')
gvcIfDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcMacIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcSapIndex"))
if mibBuilder.loadTexts: gvcIfDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDc component.')
gvcIfDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDc components. These components can be added and deleted.')
gvcIfDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcStorageType.setDescription('This variable represents the storage type value for the gvcIfDc tables.')
gvcIfDcMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: gvcIfDcMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcMacIndex.setDescription('This variable represents an index for the gvcIfDc tables.')
gvcIfDcSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 254)))
if mibBuilder.loadTexts: gvcIfDcSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcSapIndex.setDescription('This variable represents an index for the gvcIfDc tables.')
gvcIfDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10), )
if mibBuilder.loadTexts: gvcIfDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcOptionsTable.setDescription('This group defines attributes associated with direct call. It defines complete connection in terms of path and call options. This connection can be permanent (pvc) or switched (svc). It can have facilities. The total number of bytes of facilities including the facility codes, and all of the facility data from all of the four classes of facilities: CCITT_Facilities DTE_Facilities National_Facilities International_Facilities must not exceed 512 bytes.')
gvcIfDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcMacIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcSapIndex"))
if mibBuilder.loadTexts: gvcIfDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcOptionsEntry.setDescription('An entry in the gvcIfDcOptionsTable.')
gvcIfDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcRemoteNpi.setDescription('This attribute specifies the remote Numbering Plan Indicator (Npi) used in the remoteDna.')
gvcIfDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcRemoteDna.setDescription('This attribute specifies the Data Network Address (Dna) of the remote. This is the called (destination) DTE address (Dna) to which this direct call will be sent. Initially, the called DTE address attribute must be present, that is, there must be a valid destination address. However, it may be possible in the future to configure the direct call with a mnemonic address, in which case, this attribute will contain a zero-length Dna, and the mnemonic address will be carried as one of the facilities.')
gvcIfDcUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10, 1, 8), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="C3000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcUserData.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcUserData.setDescription("This attribute contains the user data which is appended to the call request packet that is presented to the called (destination) DTE. User data can be a 0 to 128 byte string for fast select calls; otherwise, it is 0 to 16 byte string. Fast select calls are indicated as such using the X.25 ITU-T CCITT facility for 'Reverse Charging'. The length of the user data attribute is not verified during service provisioning. If more than 16 bytes of user data is specified on a call without the fast select option, then the call is cleared with a clear cause of 'local procedure error', and a diagnostic code of 39 (as defined in ITU-T (CCITT) X.25).")
gvcIfDcTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9, 255))).clone(namedValues=NamedValues(("normal", 0), ("high", 9), ("useDnaDefTP", 255))).clone('useDnaDefTP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. It can overRide the outDefaultTransferPriority provisioned in the Dna component. The transfer priority is a preference specified by an application according to its time-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. The transfer priority in Passport determines two things in use: trunk queue (among interrupting, delay, throughput), and routing metric (between delay and throughput). The following table details each transfer priority. The default of outDefaultTransferPriority is useDnaDefTP.')
gvcIfDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this DLCI. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Traffic with normal priority are discarded first than the traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority. The default of discardPriority is useDnaDefPriority.')
gvcIfDcCfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 490), )
if mibBuilder.loadTexts: gvcIfDcCfaTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcCfaTable.setDescription("This is the i'th CCITT facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 CCITT representation for facility data. The user specifies the facility code when adding, changing or deleting a facility. The upper two bits of the facility code indicate the class of facility. From the class of the facility, one can derive the number of bytes of facility data, as follows: Class A - 1 byte of fax data Class B - 2 bytes of fax data Class C - 3 bytes of fax data Class D - variable length of fax data.")
gvcIfDcCfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 490, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcMacIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcSapIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDcCfaIndex"))
if mibBuilder.loadTexts: gvcIfDcCfaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcCfaEntry.setDescription('An entry in the gvcIfDcCfaTable.')
gvcIfDcCfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 490, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ValueRangeConstraint(4, 4), ValueRangeConstraint(9, 9), ValueRangeConstraint(66, 66), ValueRangeConstraint(67, 67), ValueRangeConstraint(68, 68), ValueRangeConstraint(71, 71), ValueRangeConstraint(72, 72), ValueRangeConstraint(73, 73), ValueRangeConstraint(196, 196), ValueRangeConstraint(198, 198), )))
if mibBuilder.loadTexts: gvcIfDcCfaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcCfaIndex.setDescription('This variable represents the index for the gvcIfDcCfaTable.')
gvcIfDcCfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 490, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDcCfaValue.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcCfaValue.setDescription('This variable represents an individual value for the gvcIfDcCfaTable.')
gvcIfDcCfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 2, 490, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gvcIfDcCfaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDcCfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the gvcIfDcCfaTable.')
gvcIfRDnaMap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3))
gvcIfRDnaMapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1), )
if mibBuilder.loadTexts: gvcIfRDnaMapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfRDnaMap components.')
gvcIfRDnaMapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRDnaMapNpiIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRDnaMapDnaIndex"))
if mibBuilder.loadTexts: gvcIfRDnaMapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfRDnaMap component.')
gvcIfRDnaMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRDnaMapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfRDnaMap components. These components can be added and deleted.')
gvcIfRDnaMapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfRDnaMapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfRDnaMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfRDnaMapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapStorageType.setDescription('This variable represents the storage type value for the gvcIfRDnaMap tables.')
gvcIfRDnaMapNpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))))
if mibBuilder.loadTexts: gvcIfRDnaMapNpiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapNpiIndex.setDescription('This variable represents an index for the gvcIfRDnaMap tables.')
gvcIfRDnaMapDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 1, 1, 11), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)))
if mibBuilder.loadTexts: gvcIfRDnaMapDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapDnaIndex.setDescription('This variable represents an index for the gvcIfRDnaMap tables.')
gvcIfRDnaMapLanAdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 10), )
if mibBuilder.loadTexts: gvcIfRDnaMapLanAdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapLanAdTable.setDescription('This group defines the LAN MAC and SAP address for a given WAN NPI and DNA address.')
gvcIfRDnaMapLanAdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRDnaMapNpiIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRDnaMapDnaIndex"))
if mibBuilder.loadTexts: gvcIfRDnaMapLanAdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapLanAdEntry.setDescription('An entry in the gvcIfRDnaMapLanAdTable.')
gvcIfRDnaMapMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 10, 1, 2), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRDnaMapMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapMac.setDescription('This attribute specifies a locally or globally administered MAC address of a LAN device.')
gvcIfRDnaMapSap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 3, 10, 1, 3), Hex().subtype(subtypeSpec=ValueRangeConstraint(2, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRDnaMapSap.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRDnaMapSap.setDescription('This attribute specifies a SAP identifier on the LAN device identified by the mac.')
gvcIfLcn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4))
gvcIfLcnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 1), )
if mibBuilder.loadTexts: gvcIfLcnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of gvcIfLcn components.')
gvcIfLcnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"))
if mibBuilder.loadTexts: gvcIfLcnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfLcn component.')
gvcIfLcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfLcn components. These components cannot be added nor deleted.')
gvcIfLcnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfLcnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnStorageType.setDescription('This variable represents the storage type value for the gvcIfLcn tables.')
gvcIfLcnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: gvcIfLcnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnIndex.setDescription('This variable represents the index for the gvcIfLcn tables.')
gvcIfLcnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 11), )
if mibBuilder.loadTexts: gvcIfLcnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
gvcIfLcnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"))
if mibBuilder.loadTexts: gvcIfLcnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnStateEntry.setDescription('An entry in the gvcIfLcnStateTable.')
gvcIfLcnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
gvcIfLcnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
gvcIfLcnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
gvcIfLcnLcnCIdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 12), )
if mibBuilder.loadTexts: gvcIfLcnLcnCIdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnLcnCIdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group indicates the information about the LAN circuit.')
gvcIfLcnLcnCIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"))
if mibBuilder.loadTexts: gvcIfLcnLcnCIdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnLcnCIdEntry.setDescription('An entry in the gvcIfLcnLcnCIdTable.')
gvcIfLcnCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 12, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnCircuitId.setDescription('This attribute indicates the component name of the Vr/n Sna SnaCircuitEntry which represents this connection in the SNA DLR service. This component contains operational data about the LAN circuit.')
gvcIfLcnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 13), )
if mibBuilder.loadTexts: gvcIfLcnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational Lcn attributes.')
gvcIfLcnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"))
if mibBuilder.loadTexts: gvcIfLcnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnOperEntry.setDescription('An entry in the gvcIfLcnOperTable.')
gvcIfLcnState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("idle", 0), ("localDeviceCalling", 1), ("remoteDeviceCalling", 2), ("callUp", 3), ("serviceInitiatedClear", 4), ("localDeviceClearing", 5), ("remoteDeviceClearing", 6), ("terminating", 7), ("deviceMonitoring", 8), ("deviceMonitoringSuspended", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnState.setDescription('This attribute indicates the logical channel internal state.')
gvcIfLcnDnaMap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 13, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnDnaMap.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnDnaMap.setDescription('This attribute indicates the component name of the Ddm, Sdm or Ldev which contains the MAC address of the device being monitored by this Lcn.')
gvcIfLcnSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 13, 1, 3), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnSourceMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnSourceMac.setDescription('This attribute indicates the source MAC address inserted by this LCN in the SA field of the 802.5 frames sent to the local ring.')
gvcIfLcnVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2))
gvcIfLcnVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 1), )
if mibBuilder.loadTexts: gvcIfLcnVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of gvcIfLcnVc components.')
gvcIfLcnVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnVcIndex"))
if mibBuilder.loadTexts: gvcIfLcnVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfLcnVc component.')
gvcIfLcnVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfLcnVc components. These components cannot be added nor deleted.')
gvcIfLcnVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfLcnVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcStorageType.setDescription('This variable represents the storage type value for the gvcIfLcnVc tables.')
gvcIfLcnVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfLcnVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcIndex.setDescription('This variable represents the index for the gvcIfLcnVc tables.')
gvcIfLcnVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10), )
if mibBuilder.loadTexts: gvcIfLcnVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCadTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group represents operational call data related to General Vc. It can be displayed only for General Vc which is created by application.')
gvcIfLcnVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnVcIndex"))
if mibBuilder.loadTexts: gvcIfLcnVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCadEntry.setDescription('An entry in the gvcIfLcnVcCadTable.')
gvcIfLcnVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcType.setDescription('This attribute displays the type of call, pvc or svc. type is provided at provisioning time.')
gvcIfLcnVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
gvcIfLcnVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
gvcIfLcnVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
gvcIfLcnVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
gvcIfLcnVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
gvcIfLcnVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
gvcIfLcnVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
gvcIfLcnVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
gvcIfLcnVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
gvcIfLcnVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
gvcIfLcnVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
gvcIfLcnVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
gvcIfLcnVcLocalRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcLocalRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcLocalRxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
gvcIfLcnVcLocalTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcLocalTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcLocalTxPktSize.setDescription('This attribute displays the locally negotiated size of send packets.')
gvcIfLcnVcLocalTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcLocalTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcLocalTxWindowSize.setDescription('This attribute displays the send window size provided on incoming call packets or the default when a call request packet does not explicitly provide the window size.')
gvcIfLcnVcLocalRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcLocalRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcLocalRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets or the default when a call request does not explicitly provide the window sizes.')
gvcIfLcnVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPathReliability.setDescription('This attribute displays the path reliability.')
gvcIfLcnVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
gvcIfLcnVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
gvcIfLcnVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
gvcIfLcnVcSubnetTxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSubnetTxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSubnetTxPktSize.setDescription('This attribute displays the locally negotiated size of the data packets on this Vc.')
gvcIfLcnVcSubnetTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSubnetTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSubnetTxWindowSize.setDescription('This attribute displays the current send window size of Vc.')
gvcIfLcnVcSubnetRxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSubnetRxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSubnetRxPktSize.setDescription('This attribute displays the locally negotiated size of receive packets.')
gvcIfLcnVcSubnetRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSubnetRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSubnetRxWindowSize.setDescription('This attribute displays the receive window size provided on incoming call packets and to the default when a call request does not explicitly provide the window sizes.')
gvcIfLcnVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcMaxSubnetPktSize.setDescription('This attribute displays the maximum packet size allowed on Vc.')
gvcIfLcnVcTransferPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcTransferPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcTransferPriorityToNetwork.setDescription('This attribute displays the priority in which data is transferred to the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput.')
gvcIfLcnVcTransferPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcTransferPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcTransferPriorityFromNetwork.setDescription('This attribute displays the priority in which data is transferred from the network. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, and the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, and the routing metric is set to throughput.')
gvcIfLcnVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11), )
if mibBuilder.loadTexts: gvcIfLcnVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcIntdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
gvcIfLcnVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnVcIndex"))
if mibBuilder.loadTexts: gvcIfLcnVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcIntdEntry.setDescription('An entry in the gvcIfLcnVcIntdTable.')
gvcIfLcnVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcCallReferenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcCallReferenceNumber.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
gvcIfLcnVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
gvcIfLcnVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
gvcIfLcnVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
gvcIfLcnVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
gvcIfLcnVcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12), )
if mibBuilder.loadTexts: gvcIfLcnVcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** ... Statistics(Stats) This group defines general attributes collected by general Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods.')
gvcIfLcnVcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfLcnVcIndex"))
if mibBuilder.loadTexts: gvcIfLcnVcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcStatsEntry.setDescription('An entry in the gvcIfLcnVcStatsTable.')
gvcIfLcnVcAckStackingTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcAckStackingTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcAckStackingTimeouts.setDescription('This attribute counts the number of ack stacking timer expiries. It is used as an indicator of the acknowledgment behavior across the subnet when ack stacking is in effect. If it expires often, usually this means end users will experience longer delay. The ack stacking timer specifies how long the Vc will wait before finally sending the subnet acknowledgment. if this attribute is set to a value of 0, then the Vc will automatically return acknowledgment packets without delay. If this attribute is set to a value other than zero, then the Vc will wait for this amount of time in an attempt to piggyback the acknowledgment packet on another credit or data packet. If the Vc cannot piggyback the acknowledgment packet within this time, then the packet is returned without piggybacking.')
gvcIfLcnVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcOutOfRangeFrmFromSubnet.setDescription('This attribute counts the number of subnet frames discarded due to the sequence number being out of range. Two Categories apply for the General Vc 1) lost Acks (previous Range) 2) unexpected Packets (next Range) Vc internally maintains its own sequence number of packet order and sequencing. Due to packet retransmission, Vc may receive duplicate packets that have the same Vc internal sequence number. Only 1 copy is accepted by the Vc and other copies of the same packets are detected through this count. This attribute can be used to record the frequency of packet retransmission due to Vc and other part of the subnet.')
gvcIfLcnVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcDuplicatesFromSubnet.setDescription('This attribute counts the number of subnet packets discarded due to duplication. It is used to detect software error fault or duplication caused by retransmitting.')
gvcIfLcnVcFrmRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcFrmRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcFrmRetryTimeouts.setDescription('This attribute counts the number of frames which have retransmission time-out. If packets from Vc into the subnet are discarded by the subnet, the source Vc will not receive any acknowledgment. The retransmission timer then expires and packets will be retransmitted again. Note that the Vc idle probe may be retransmitted and is included in this count. This statistics does not show the distribution of how many times packets are retransmitted (e.g. first retransmission results in successful packet forwarding).')
gvcIfLcnVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPeakRetryQueueSize.setDescription('This attribute indicates the peak size of the retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest body of unacknowledged packets.')
gvcIfLcnVcPeakOoSeqQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPeakOoSeqQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPeakOoSeqQueueSize.setDescription('This attribute indicates the peak size of the out of sequence queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets.')
gvcIfLcnVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPeakOoSeqFrmForwarded.setDescription('This attribute indicates the peak size of the sequence packet queue. This attribute is used as an indicator of the sequencing behavior across the subnet. It records the largest body of out of sequence packets, which by the receipt of an expected packet have been transformed to expected packets. The number of times this peak is reached is not recorded as it is traffic dependent.')
gvcIfLcnVcPeakStackedAcksRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcPeakStackedAcksRx.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcPeakStackedAcksRx.setDescription('This attribute indicates the peak size of wait acks. This attribute is used as an indicator of the acknowledgment behavior across the subnet. It records the largest collective acknowledgment.')
gvcIfLcnVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcSubnetRecoveries.setDescription('This attribute counts the number of successful Vc recovery attempts. This attribute is used as an indicator of how many times the Vc path is broken but can be recovered. This attribute is useful to record the number of network path failures.')
gvcIfLcnVcWindowClosuresToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcWindowClosuresToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcWindowClosuresToSubnet.setDescription('This attribute counts the number of window closures to subnet. A packet may have been sent into the subnet but its acknowledgment from the remote Vc has not yet been received. This is a 8 bit sequence number.This number is useful in detecting whether the Vc is sending any packet into the subnet.')
gvcIfLcnVcWindowClosuresFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcWindowClosuresFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcWindowClosuresFromSubnet.setDescription('This attribute counts the number of window closures from subnet. This attribute is useful in detecting whether the Vc is receiving any packet from the subnet.')
gvcIfLcnVcWrTriggers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 4, 2, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfLcnVcWrTriggers.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfLcnVcWrTriggers.setDescription('This attribute displays the number of times the Vc stays within the W-R region. The W-R region is a value used to determined the timing of credit transmission. Should the current window size be beneath this value, the credits will be transmitted immediately. Otherwise, they will be transmitted later with actual data. The wrTriggers statistic is therefore used to analyze the flow control and credit mechanism.')
gvcIfDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5))
gvcIfDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 1), )
if mibBuilder.loadTexts: gvcIfDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDna components.')
gvcIfDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"))
if mibBuilder.loadTexts: gvcIfDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDna component.')
gvcIfDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDna components. These components can be added and deleted.')
gvcIfDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaStorageType.setDescription('This variable represents the storage type value for the gvcIfDna tables.')
gvcIfDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)))
if mibBuilder.loadTexts: gvcIfDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIndex.setDescription('This variable represents the index for the gvcIfDna tables.')
gvcIfDnaAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 11), )
if mibBuilder.loadTexts: gvcIfDnaAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaAddrTable.setDescription('This group contains attributes common to all DNAs. Every DNA used in the network is defined with this group of 2 attributes, a string of address digits and a NPI.')
gvcIfDnaAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"))
if mibBuilder.loadTexts: gvcIfDnaAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaAddrEntry.setDescription('An entry in the gvcIfDnaAddrTable.')
gvcIfDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. Address may belong to X.121 or E.164 plans.')
gvcIfDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 11, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDataNetworkAddress.setDescription('This attribute contains digits which form the unique identifier of the customer interface. It can be compared (approximation only) to telephone number where the telephone number identifies a unique telephone set. Dna digits are selected and assigned by network operators.')
gvcIfDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12), )
if mibBuilder.loadTexts: gvcIfDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaOutgoingOptionsTable.setDescription('This group defines call options of a Dna for calls which are made out of the interface represented by Dna.')
gvcIfDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"))
if mibBuilder.loadTexts: gvcIfDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaOutgoingOptionsEntry.setDescription('An entry in the gvcIfDnaOutgoingOptionsTable.')
gvcIfDnaOutDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaOutDefaultPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaOutDefaultPriority.setDescription('This attribute, if set to normal indicates that the default priority for outgoing calls (from the DTE to the network) for this particular Dna is normal priority - if the priority is not specified by the DTE. If this attribute is set to high then the default priority for outgoing calls using this particular Dna is high priority. This option can also be included in X.25 signalling, in which case it will be overruled.')
gvcIfDnaOutDefaultPathSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1))).clone('throughput')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaOutDefaultPathSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaOutDefaultPathSensitivity.setDescription('This attribute specifies the default class of routing for delay/ throughput sensitive routing for all outgoing calls (from the DTE to the network)for this particular Dna. The chosen default class of routing applies to all outgoing calls established using this Dna, and applies to the packets travelling in both directions on all outgoing calls (local to remote, and remote to local). For incoming calls, the default class of routing is chosen by the calling party (as opposed to DPN, where either end of the call can choose the default routing class). This attribute, if set to a value of throughput, indicates that the default class of routing is throughput sensitive routing. If set to a value of delay, then the default class of routing is delay sensitive routing. In the future, the class of routing sensitivity may be overridden at the calling end of the call as follows: The default class of routing sensitivity can be overridden by the DTE in the call request packet through the TDS&I (Transit Delay Selection & Indication) if the DTE supports this facility. Whether or not the DTE is permitted to signal the TDS&I facility will depend on the DTE (i.e.: TDS&I is supported in X.25 only), and will depend on whether the port is configured to permit the TDS&I facility. In Passport, the treatment of DTE facilities (for example, NUI, RPOA, and TDS&I) not fully defined yet since it is not required. At the point in time when it is required, the parameter to control whether or not the DTE is permitted to signal the TDS&I will be in a Facility Treatment component. Currently, the default is to disallow the TDS&I facility from the DTE.')
gvcIfDnaOutDefaultPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1))).clone('high')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaOutDefaultPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaOutDefaultPathReliability.setDescription('This attribute specifies the default class of routing for reliability routing for all outgoing calls (from the DTE to the network) this particular Dna. The chosen default class of routing applies to all outgoing calls established using this Dna, and applies to the packets travelling in both directions on all outgoing calls (local to remote, and remote to local). For incoming calls, the default class of routing is chosen by the calling party (as opposed to DPN, where either end of the call can choose the default routing class). This attribute, if set to a value of normal, indicates that the default class of routing is normal reliability routing. If set to a value of high, then the default class of routing is high reliability routing. High reliability is the standard choice for most DPN and Passport services. It usually indicates that packets are overflowed or retransmitted at various routing levels. Typically high reliability results in duplication and disordering of packets in the network when errors are detected or during link congestion. However, the Vc handles the duplication and disordering to ensure that packets are delivered to the DTE properly. For the Frame Relay service, duplication of packets is not desired, in which case, normal reliability may be chosen as the preferred class of routing.')
gvcIfDnaOutAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaOutAccess.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaOutAccess.setDescription("This attribute is an extension of the Closed User Group (CUG), as follows: This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) the open (non-CUG) of the network are permitted. It also permits outgoing calls to DTEs that have Incoming Access capabilities. If set to a value of disallowed, then such calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Outgoing Access' feature for Dnas in that outgoing access is granted if this attribute is set to a value of allowed.")
gvcIfDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. It can be overRide by the transferPriority provisioned in the DLCI Direct Call sub- component. The transfer priority is a preference specified by an application according to its time-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. The transfer priority in Passport determines two things in use: trunk queue (among interrupting, delay, throughput), and routing metric (between delay and throughput). The following table descibes the details of each transfer priority: The default of outDefaultTransferPriority is normal.')
gvcIfDnaTransferPriorityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 12, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaTransferPriorityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaTransferPriorityOverRide.setDescription('When this attribute is set to yes in the call request, the called end will use the calling end provisioning data on transfer priority to override its own provisioning data. If it is set no, the called end will use its own provisioning data on transfer priority. The default of outTransferPriorityOverRide is yes.')
gvcIfDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13), )
if mibBuilder.loadTexts: gvcIfDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncomingOptionsTable.setDescription('IncomingOptions defines set of options for incoming calls. These options are used for calls arriving to the interface represented by Dna. For calls originated from the interface, IncomingOptions attributes are not used.')
gvcIfDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"))
if mibBuilder.loadTexts: gvcIfDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncomingOptionsEntry.setDescription('An entry in the gvcIfDnaIncomingOptionsTable.')
gvcIfDnaIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncCalls.setDescription("This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) be made to this Dna. If set to a value of disallowed, then incoming calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for Dnas in that incoming calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) be set to a value of allowed for this Dna to be usable.")
gvcIfDnaIncHighPriorityReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaIncHighPriorityReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncHighPriorityReverseCharge.setDescription("This attribute, if set to a value of allowed indicates that incoming high priority, reverse charged calls (from the network to the DTE) be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute, together with the incNormalPriorityReverseChargeCalls attribute corresponds to the CCITT 'Reverse Charging Acceptance' feature for Dnas in that reverse charged calls are accepted if both attributes are set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
gvcIfDnaIncNormalPriorityReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaIncNormalPriorityReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncNormalPriorityReverseCharge.setDescription("This attribute, if set to a value of allowed indicates that incoming normal priority, reverse charged calls (from the network to the DTE) be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute, together with the incHighPriorityReverseChargeCalls attribute corresponds to the CCITT 'Reverse Charging Acceptance' feature for Dnas in that reverse charged calls are accepted if both attributes are set to a value of allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.")
gvcIfDnaIncIntlNormalCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaIncIntlNormalCharge.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncIntlNormalCharge.setDescription('This attribute, if set to a value of allowed indicates that incoming international normal charged calls (from the network to the DTE) be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute also currently controls access to/from the E.164 numbering plan, and if set to a value of allowed, then cross- numbering plan calls (also normal charged) allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
gvcIfDnaIncIntlReverseCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaIncIntlReverseCharge.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncIntlReverseCharge.setDescription('This attribute, if set to a value of allowed indicates that incoming international reverse charged calls (from the network to the DTE) be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute also currently controls access to/from the E.164 numbering plan, and if set to a value of allowed, then cross- numbering plan calls (also normal charged) allowed. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
gvcIfDnaIncSameService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaIncSameService.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncSameService.setDescription('This attribute, if set to a value of allowed indicates that incoming calls from the same service type (e.g.: X.25, ITI, SNA) (from the network to the DTE) be made to this Dna. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute is ignored if the corresponding attribute, incCalls is set to a value of disallowed.')
gvcIfDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaIncAccess.setDescription("This attribute is an extension of the Closed User Group (CUG), as follows: This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) the open (non-CUG) of the network are permitted. It also permits incoming calls from DTEs that have Outgoing Access capabilities. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Incoming Access' feature for Dnas in that incoming access is granted if this attribute is set to a value of allowed.")
gvcIfDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14), )
if mibBuilder.loadTexts: gvcIfDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCallOptionsTable.setDescription('CallOptions group defines additional options for calls not related directly to direction of a call.')
gvcIfDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"))
if mibBuilder.loadTexts: gvcIfDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCallOptionsEntry.setDescription('An entry in the gvcIfDnaCallOptionsTable.')
gvcIfDnaServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("gsp", 0), ("x25", 1), ("enhancedIti", 2), ("ncs", 3), ("mlti", 4), ("sm", 5), ("ici", 6), ("dsp3270", 7), ("iam", 8), ("mlhi", 9), ("term3270", 10), ("iti", 11), ("bsi", 13), ("hostIti", 14), ("x75", 15), ("hdsp3270", 16), ("api3201", 20), ("sdlc", 21), ("snaMultiHost", 22), ("redirectionServ", 23), ("trSnaTpad", 24), ("offnetNui", 25), ("gasServer", 26), ("vapServer", 28), ("vapAgent", 29), ("frameRelay", 30), ("ipiVc", 31), ("gvcIf", 32))).clone('gvcIf')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaServiceCategory.setDescription('This attribute is assigned for each different type of service within which this Dna is configured. It is placed into the Service Category attribute in the accounting record by both ends of the Vc.')
gvcIfDnaPacketSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="ff80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaPacketSizes.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaPacketSizes.setDescription('This attribute indicates the allowable packet sizes supported for call setup using this Dna. CCITT recommends that packet size 128 always be supported. Description of bits: n16(0) n32(1) n64(2) n128(3) n256(4) n512(5) n1024(6) n2048(7) n4096(8)')
gvcIfDnaDefaultRecvFrmNetworkPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n4096')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultRecvFrmNetworkPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultRecvFrmNetworkPacketSize.setDescription('This attribute indicates the default local receive packet size from network to DTE for all calls using this particular Dna.')
gvcIfDnaDefaultSendToNetworkPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n4096')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultSendToNetworkPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultSendToNetworkPacketSize.setDescription('This attribute indicates the default local send packet size from DTE to network for all calls using this particular Dna.')
gvcIfDnaDefaultRecvFrmNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultRecvFrmNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultRecvFrmNetworkThruputClass.setDescription('This attribute indicates the default receive throughput class for all calls using this particular Dna.')
gvcIfDnaDefaultSendToNetworkThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultSendToNetworkThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultSendToNetworkThruputClass.setDescription('This attribute indicates the default send throughput class for all calls using this particular Dna.')
gvcIfDnaDefaultRecvFrmNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultRecvFrmNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultRecvFrmNetworkWindowSize.setDescription('This attribute indicates the default number of data packets that can be received by the DTE from the DCE before more packets can be received. This view is oriented with respect to the DTE.')
gvcIfDnaDefaultSendToNetworkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDefaultSendToNetworkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDefaultSendToNetworkWindowSize.setDescription('This attribute indicates the number of data packets that can be transmitted from the DTE to the DCE and must be acknowledged before more packets can be transmitted.')
gvcIfDnaPacketSizeNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("endToEnd", 0), ("local", 1))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaPacketSizeNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaPacketSizeNegotiation.setDescription('This attribute, if set to local indicates that packet sizes can be negotiated locally at the interface irrespective of the remote interface. If set to endtoEnd, then local negotiation is not permitted and packet sizes are negotiated between 2 ends of Vc.')
gvcIfDnaCugFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("basic", 0), ("extended", 1))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugFormat.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugFormat.setDescription('This attribute specifies which Cug format is used when DTE signals CUG indices, basic or extended. This attribute, if set to extended indicates that the DTE signals and receives CUG indices in extended CUG format. If set to a value of basic, then the DTE signals and receives CUG indices in the basic CUG format.')
gvcIfDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator and it is an arbitrary number.')
gvcIfDnaAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaAccountCollection.setDescription('This attribute indicates that accounting records are to be collected by the network for the various reasons: billing, test, study, auditing. The last of the parameters, force, indicates that accounting records are to be collected irrespective of other collection reasons. If none of these reasons are set, then accounting will be suppressed. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
gvcIfDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 14, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaServiceExchange.setDescription('This attribute is an arbitrary number, entered by the network operator. The value of serviceExchange is included in the accounting record generated by Vc.')
gvcIfDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2))
gvcIfDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 1), )
if mibBuilder.loadTexts: gvcIfDnaCugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDnaCug components.')
gvcIfDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaCugIndex"))
if mibBuilder.loadTexts: gvcIfDnaCugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDnaCug component.')
gvcIfDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDnaCug components. These components can be added and deleted.')
gvcIfDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaCugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaCugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugStorageType.setDescription('This variable represents the storage type value for the gvcIfDnaCug tables.')
gvcIfDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: gvcIfDnaCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugIndex.setDescription('This variable represents the index for the gvcIfDnaCug tables.')
gvcIfDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10), )
if mibBuilder.loadTexts: gvcIfDnaCugCugOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugCugOptionsTable.setDescription('Attributes in this group defines ClosedUserGroup options associated with interlockCode. Dnas with the same Cug (interlockCode) make calls within this group. Various combinations which permit or prevent calls in the same Cug group are defined here.')
gvcIfDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaCugIndex"))
if mibBuilder.loadTexts: gvcIfDnaCugCugOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugCugOptionsEntry.setDescription('An entry in the gvcIfDnaCugCugOptionsTable.')
gvcIfDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugType.setDescription('This attribute specifies the Cug type - the Cug is either a national Cug, or an international Cug. International closed user groups are usually established between DTEs for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTEs for which there is no X.75 Gateway between. (National Cugs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the Cug is a national Cug, in which case, the dnic should be left at its default value since it is not part of a national Cug. If this attribute is set to international, then the Cug is an international Cug, in which case, the dnic should be set appropriately as part of the Cug interlockCode.')
gvcIfDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugDnic.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugDnic.setDescription('This attribute specifies the dnic (Data Network ID Code) the Cug by which packet networks are identified. This attribute is not applicable if the Cug is a national Cug, as specified by the Cug type attribute. There are usually 1 or 2 dnics assigned per country, for public networks. The U.S. is an exception where each BOC has a dnic. Also, a group of private networks can have its own dnic. dnic value is not an arbitrary number. It is assigned by international agreement and controlled by CCITT.')
gvcIfDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugInterlockCode.setDescription('This attribute specifies the Cug identifier of a national or international Cug call. It is an arbitrary number and it also can be called Cug in some descriptions. Interfaces (Dnas) with this number can make calls to Dnas with the same interlockCode.')
gvcIfDnaCugPreferential = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugPreferential.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugPreferential.setDescription('This attribute, if set to yes indicates that this Cug is the preferential Cug, in which case it will be used during the call establishment phase if the DTE has not explicitly specified a Cug index in the call request packet. If set to no, then this Cug is not the preferential Cug. Only one of the Cugs associated with a particular Dna can be the preferential Cug - only one Cug can have this attribute set to yes.')
gvcIfDnaCugOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugOutCalls.setDescription("This attribute, if set to allowed indicates that outgoing calls (from the DTE into the network) be made using this particular Cug. If set to a value of disallowed, then outgoing calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Outgoing Calls Barred' feature for Cugs in that outgoing calls are barred if this attribute is set to a value of disallowed.")
gvcIfDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugIncCalls.setDescription("This attribute, if set to allowed indicates that incoming calls (from the network to the DTE) be made using this particular Cug. If set to disallowed, then incoming calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for Cugs in that incoming calls are barred if this attribute is set to a value of disallowed.")
gvcIfDnaCugPrivileged = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaCugPrivileged.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaCugPrivileged.setDescription('This attribute, if set to yes indicates that this Cug is a privileged Cug. In DPN, at least one side of a call setup within a Cug must have the Cug as a privileged Cug. If set to no, then the Cug is not privileged. If both the local DTE and the remote DTE subscribe to the Cug, but it is not privileged, then the call will be cleared. This attribute is typically used for a host DTE which must accept calls from many other DTEs in which case the other DTEs cannot call one another, but can call the host. In this example, the host would have the privileged Cug, and the other DTEs would belong to the same Cug, but it would not be privileged.')
gvcIfDnaHgM = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3))
gvcIfDnaHgMRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 1), )
if mibBuilder.loadTexts: gvcIfDnaHgMRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDnaHgM components.')
gvcIfDnaHgMRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMIndex"))
if mibBuilder.loadTexts: gvcIfDnaHgMRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDnaHgM component.')
gvcIfDnaHgMRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaHgMRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDnaHgM components. These components can be added and deleted.')
gvcIfDnaHgMComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDnaHgMStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMStorageType.setDescription('This variable represents the storage type value for the gvcIfDnaHgM tables.')
gvcIfDnaHgMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDnaHgMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMIndex.setDescription('This variable represents the index for the gvcIfDnaHgM tables.')
gvcIfDnaHgMIfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 10), )
if mibBuilder.loadTexts: gvcIfDnaHgMIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMIfTable.setDescription('This group contains the interface parameters between the HuntGroupMember and the Hunt Group server.')
gvcIfDnaHgMIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMIndex"))
if mibBuilder.loadTexts: gvcIfDnaHgMIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMIfEntry.setDescription('An entry in the gvcIfDnaHgMIfTable.')
gvcIfDnaHgMAvailabilityUpdateThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaHgMAvailabilityUpdateThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMAvailabilityUpdateThreshold.setDescription('This attribute indicates the number of channels that have to be freed or occupied before the Availability Message Packet (AMP) is sent to the Hunt Group Server informing it of the status of this interface.')
gvcIfDnaHgMOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 11), )
if mibBuilder.loadTexts: gvcIfDnaHgMOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMOpTable.setDescription('This group contains the operational attributes of the HuntGroupMember component.')
gvcIfDnaHgMOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMIndex"))
if mibBuilder.loadTexts: gvcIfDnaHgMOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMOpEntry.setDescription('An entry in the gvcIfDnaHgMOpTable.')
gvcIfDnaHgMAvailabilityDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-4096, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMAvailabilityDelta.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMAvailabilityDelta.setDescription('This attribute indicates the net change in the available link station connections since the last Availability Message Packet (AMP) was sent to the Hunt Group. Once the absolute value of this attribute reaches the availabilityUpdateThreshold an AMP is sent to the host and the availabilityDelta is reset to 0. If this attribute is positive it means an increase of the number of available link station connections. If it is negative it means a decrease in the number of available link station connections.')
gvcIfDnaHgMMaxAvailableLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMMaxAvailableLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMMaxAvailableLinkStations.setDescription('This attribute indicates the maximum number of available link station connections that can be established by this HuntGroupMember.')
gvcIfDnaHgMAvailableLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMAvailableLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMAvailableLinkStations.setDescription('This attribute indicates the number of available link station connections reported to the hunt group in the Availability Message Packet (AMP). It is incremented by the application when a link station connection is freed and decremented when a link station connection is occupied.')
gvcIfDnaHgMHgAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2))
gvcIfDnaHgMHgAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 1), )
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDnaHgMHgAddr components.')
gvcIfDnaHgMHgAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDnaHgMHgAddr component.')
gvcIfDnaHgMHgAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDnaHgMHgAddr components. These components can be added and deleted.')
gvcIfDnaHgMHgAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDnaHgMHgAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrStorageType.setDescription('This variable represents the storage type value for the gvcIfDnaHgMHgAddr tables.')
gvcIfDnaHgMHgAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrIndex.setDescription('This variable represents the index for the gvcIfDnaHgMHgAddr tables.')
gvcIfDnaHgMHgAddrAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 10), )
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrAddrTable.setDescription('This group contains attributes common to all DNAs. Every DNA used in the network is defined with this group of 2 attributes. String of address digits complemented by the NPI.')
gvcIfDnaHgMHgAddrAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrAddrEntry.setDescription('An entry in the gvcIfDnaHgMHgAddrAddrTable.')
gvcIfDnaHgMHgAddrNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) the Dna that is entered. Address may belong to X.121 or E.164 plans.')
gvcIfDnaHgMHgAddrDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 3, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaHgMHgAddrDataNetworkAddress.setDescription('This attribute contains digits which form unique identifier of the customer interface. It can be compared (approximation only) telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators.')
gvcIfDnaDdm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4))
gvcIfDnaDdmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 1), )
if mibBuilder.loadTexts: gvcIfDnaDdmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDnaDdm components.')
gvcIfDnaDdmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaDdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaDdmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDnaDdm component.')
gvcIfDnaDdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDnaDdm components. These components can be added and deleted.')
gvcIfDnaDdmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDnaDdmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmStorageType.setDescription('This variable represents the storage type value for the gvcIfDnaDdm tables.')
gvcIfDnaDdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDnaDdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmIndex.setDescription('This variable represents the index for the gvcIfDnaDdm tables.')
gvcIfDnaDdmLanAdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 10), )
if mibBuilder.loadTexts: gvcIfDnaDdmLanAdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmLanAdTable.setDescription('This group defines the LAN MAC and SAP address for a given WAN NPI and DNA address.')
gvcIfDnaDdmLanAdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaDdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaDdmLanAdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmLanAdEntry.setDescription('An entry in the gvcIfDnaDdmLanAdTable.')
gvcIfDnaDdmMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 10, 1, 2), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmMac.setDescription('This attribute specifies a locally or globally administered MAC address of a LAN device.')
gvcIfDnaDdmSap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 10, 1, 3), Hex().subtype(subtypeSpec=ValueRangeConstraint(2, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmSap.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmSap.setDescription('This attribute specifies a SAP identifier on the LAN device identified by the mac.')
gvcIfDnaDdmDmoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11), )
if mibBuilder.loadTexts: gvcIfDnaDdmDmoTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDmoTable.setDescription('This group defines the device monitoring options.')
gvcIfDnaDdmDmoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaDdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaDdmDmoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDmoEntry.setDescription('An entry in the gvcIfDnaDdmDmoTable.')
gvcIfDnaDdmDeviceMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceMonitoring.setDescription('This attribute specifies wether device monitoring for the device specified in mac is enabled or disabled.')
gvcIfDnaDdmClearVcsWhenUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmClearVcsWhenUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmClearVcsWhenUnreachable.setDescription('This attribute specifies wether to clear or not existing VCs when deviceStatus changes from reachable to unreachable.')
gvcIfDnaDdmDeviceMonitoringTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceMonitoringTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceMonitoringTimer.setDescription('This attribute specifies the wait period between 2 consecutive device monitoring sequences. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDnaDdmTestResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmTestResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmTestResponseTimer.setDescription('This attribute specifies the wait period between 2 consecutive TEST commands sent during one device monitoring sequence. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDnaDdmMaximumTestRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaDdmMaximumTestRetry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmMaximumTestRetry.setDescription('This attribute specifies the maximum number of TEST commands sent during one device monitoring sequence. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDnaDdmDevOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12), )
if mibBuilder.loadTexts: gvcIfDnaDdmDevOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDevOpTable.setDescription('This group specifies the operational attributes for devices that are potentially reachable by the SNA DLR service.')
gvcIfDnaDdmDevOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaDdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaDdmDevOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDevOpEntry.setDescription('An entry in the gvcIfDnaDdmDevOpTable.')
gvcIfDnaDdmDeviceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unreachable", 0), ("reachable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceStatus.setDescription('This attribute indicates whether the local device specified by mac is reachable or unreachable from this SNA DLR interface. The device status is determined by the SNA DLR service by sending a TEST frame with the Poll bit set to the device periodically. If a TEST frame with the Final bit set is received from the device then the device status becomes reachable; otherwise the device status is unreachable. When the device status is reachable, connections to this device are accepted. When the device status is unreachable, existing connections to the device are cleared and new connections are cleared to hunt or redirection services.')
gvcIfDnaDdmActiveLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmActiveLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmActiveLinkStations.setDescription('This attribute indicates the number of active link station connections using this device mapping component. It includes the link stations using the Qllc and the Frame-Relay connections.')
gvcIfDnaDdmLastTimeUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1, 3), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmLastTimeUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmLastTimeUnreachable.setDescription('This attribute indicates the last time the deviceStatus changed from reachable to unreachable.')
gvcIfDnaDdmLastTimeReachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1, 4), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmLastTimeReachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmLastTimeReachable.setDescription('This attribute indicates the last time the deviceStatus changed from unreachable to reachable.')
gvcIfDnaDdmDeviceUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmDeviceUnreachable.setDescription('This attribute counts the number of times the deviceStatus changed from reachable to unreachable. When the maximum count is exceeded the count wraps to zero.')
gvcIfDnaDdmMonitoringLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 4, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaDdmMonitoringLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaDdmMonitoringLcn.setDescription('This attribute indicates the instance of the GvcIf/n Lcn that is reserved for monitoring the device indicated by the mac.')
gvcIfDnaSdm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5))
gvcIfDnaSdmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 1), )
if mibBuilder.loadTexts: gvcIfDnaSdmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDnaSdm components.')
gvcIfDnaSdmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaSdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaSdmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDnaSdm component.')
gvcIfDnaSdmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDnaSdm components. These components can be added and deleted.')
gvcIfDnaSdmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDnaSdmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmStorageType.setDescription('This variable represents the storage type value for the gvcIfDnaSdm tables.')
gvcIfDnaSdmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 1, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)))
if mibBuilder.loadTexts: gvcIfDnaSdmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmIndex.setDescription('This variable represents the index for the gvcIfDnaSdm tables.')
gvcIfDnaSdmLanAdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 10), )
if mibBuilder.loadTexts: gvcIfDnaSdmLanAdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmLanAdTable.setDescription('This group defines the LAN MAC and SAP address for a given WAN NPI and DNA address.')
gvcIfDnaSdmLanAdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaSdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaSdmLanAdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmLanAdEntry.setDescription('An entry in the gvcIfDnaSdmLanAdTable.')
gvcIfDnaSdmMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 10, 1, 2), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmMac.setDescription('This attribute specifies a locally or globally administered MAC address of a LAN device.')
gvcIfDnaSdmSap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 10, 1, 3), Hex().subtype(subtypeSpec=ValueRangeConstraint(2, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmSap.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmSap.setDescription('This attribute specifies a SAP identifier on the LAN device identified by the mac.')
gvcIfDnaSdmDmoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11), )
if mibBuilder.loadTexts: gvcIfDnaSdmDmoTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDmoTable.setDescription('This group defines the device monitoring options.')
gvcIfDnaSdmDmoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaSdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaSdmDmoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDmoEntry.setDescription('An entry in the gvcIfDnaSdmDmoTable.')
gvcIfDnaSdmDeviceMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceMonitoring.setDescription('This attribute specifies wether device monitoring for the device specified in mac is enabled or disabled.')
gvcIfDnaSdmClearVcsWhenUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmClearVcsWhenUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmClearVcsWhenUnreachable.setDescription('This attribute specifies wether to clear or not existing VCs when deviceStatus changes from reachable to unreachable.')
gvcIfDnaSdmDeviceMonitoringTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceMonitoringTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceMonitoringTimer.setDescription('This attribute specifies the wait period between 2 consecutive device monitoring sequences. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDnaSdmTestResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmTestResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmTestResponseTimer.setDescription('This attribute specifies the wait period between 2 consecutive TEST commands sent during one device monitoring sequence. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDnaSdmMaximumTestRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDnaSdmMaximumTestRetry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmMaximumTestRetry.setDescription('This attribute specifies the maximum number of TEST commands sent during one device monitoring sequence. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDnaSdmDevOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12), )
if mibBuilder.loadTexts: gvcIfDnaSdmDevOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDevOpTable.setDescription('This group specifies the operational attributes for devices that are potentially reachable by the SNA DLR service.')
gvcIfDnaSdmDevOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDnaSdmIndex"))
if mibBuilder.loadTexts: gvcIfDnaSdmDevOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDevOpEntry.setDescription('An entry in the gvcIfDnaSdmDevOpTable.')
gvcIfDnaSdmDeviceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unreachable", 0), ("reachable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceStatus.setDescription('This attribute indicates whether the local device specified by mac is reachable or unreachable from this SNA DLR interface. The device status is determined by the SNA DLR service by sending a TEST frame with the Poll bit set to the device periodically. If a TEST frame with the Final bit set is received from the device then the device status becomes reachable; otherwise the device status is unreachable. When the device status is reachable, connections to this device are accepted. When the device status is unreachable, existing connections to the device are cleared and new connections are cleared to hunt or redirection services.')
gvcIfDnaSdmActiveLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmActiveLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmActiveLinkStations.setDescription('This attribute indicates the number of active link station connections using this device mapping component. It includes the link stations using the Qllc and the Frame-Relay connections.')
gvcIfDnaSdmLastTimeUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1, 3), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmLastTimeUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmLastTimeUnreachable.setDescription('This attribute indicates the last time the deviceStatus changed from reachable to unreachable.')
gvcIfDnaSdmLastTimeReachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1, 4), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmLastTimeReachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmLastTimeReachable.setDescription('This attribute indicates the last time the deviceStatus changed from unreachable to reachable.')
gvcIfDnaSdmDeviceUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmDeviceUnreachable.setDescription('This attribute counts the number of times the deviceStatus changed from reachable to unreachable. When the maximum count is exceeded the count wraps to zero.')
gvcIfDnaSdmMonitoringLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 5, 5, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDnaSdmMonitoringLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDnaSdmMonitoringLcn.setDescription('This attribute indicates the instance of the GvcIf/n Lcn that is reserved for monitoring the device indicated by the mac.')
gvcIfRg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6))
gvcIfRgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 1), )
if mibBuilder.loadTexts: gvcIfRgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfRg components.')
gvcIfRgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRgIndex"))
if mibBuilder.loadTexts: gvcIfRgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfRg component.')
gvcIfRgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfRg components. These components can be added and deleted.')
gvcIfRgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfRgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfRgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfRgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgStorageType.setDescription('This variable represents the storage type value for the gvcIfRg tables.')
gvcIfRgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: gvcIfRgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgIndex.setDescription('This variable represents the index for the gvcIfRg tables.')
gvcIfRgIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 10), )
if mibBuilder.loadTexts: gvcIfRgIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
gvcIfRgIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRgIndex"))
if mibBuilder.loadTexts: gvcIfRgIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgIfEntryEntry.setDescription('An entry in the gvcIfRgIfEntryTable.')
gvcIfRgIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRgIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
gvcIfRgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfRgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
gvcIfRgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 11), )
if mibBuilder.loadTexts: gvcIfRgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgProvTable.setDescription('This group contains the provisioned attributes in the remote group component.')
gvcIfRgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRgIndex"))
if mibBuilder.loadTexts: gvcIfRgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgProvEntry.setDescription('An entry in the gvcIfRgProvTable.')
gvcIfRgLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfRgLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgLinkToProtocolPort.setDescription('This attribute specifies a two way link between this GvcIf RemoteGroup and a VirtualRouter/n ProtocolPort/name component which enables the communication between WAN addressable devices and LAN addressable devices.')
gvcIfRgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 12), )
if mibBuilder.loadTexts: gvcIfRgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
gvcIfRgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfRgIndex"))
if mibBuilder.loadTexts: gvcIfRgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgOperStatusEntry.setDescription('An entry in the gvcIfRgOperStatusTable.')
gvcIfRgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfRgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfRgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
gvcIfDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7))
gvcIfDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 1), )
if mibBuilder.loadTexts: gvcIfDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlci components.')
gvcIfDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"))
if mibBuilder.loadTexts: gvcIfDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlci component.')
gvcIfDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlci components. These components can be added and deleted.')
gvcIfDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciStorageType.setDescription('This variable represents the storage type value for the gvcIfDlci tables.')
gvcIfDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4095)))
if mibBuilder.loadTexts: gvcIfDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciIndex.setDescription('This variable represents the index for the gvcIfDlci tables.')
gvcIfDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 10), )
if mibBuilder.loadTexts: gvcIfDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
gvcIfDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"))
if mibBuilder.loadTexts: gvcIfDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciStateEntry.setDescription('An entry in the gvcIfDlciStateTable.')
gvcIfDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
gvcIfDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
gvcIfDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
gvcIfDlciAbitTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 11), )
if mibBuilder.loadTexts: gvcIfDlciAbitTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciAbitTable.setDescription('This group contains the A-Bit status information for this Data Link Connection Identifier. A-Bit status information is only applicable for PVCs. For SVCs, the values of attributes under this group are all notApplicable.')
gvcIfDlciAbitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"))
if mibBuilder.loadTexts: gvcIfDlciAbitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciAbitEntry.setDescription('An entry in the gvcIfDlciAbitTable.')
gvcIfDlciABitStatusFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciABitStatusFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciABitStatusFromNetwork.setDescription('This attribute indicates the most recent A-bit status received from the subnet. The A-bit status is part of the LMI protocol. It indicates willingness to accept data from the Protocol Port associated with this GvcIf. When an inactive status is sent out, the Frame Relay service discards any data offered from the Protocol Port. When an active status is sent out, the Frame Relay service tries to process all data offered from the Protocol Port.')
gvcIfDlciABitReasonFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("remoteLmiError", 3), ("localLinkDown", 4), ("remoteLinkDown", 5), ("pvcDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciABitReasonFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciABitReasonFromNetwork.setDescription('This attribute indicates the reason (if any) for an inactive status to be sent to the Protocol Port associated with this GvcIf. This reason is notapplicable for an active status.')
gvcIfDlciABitStatusToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciABitStatusToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciABitStatusToNetwork.setDescription('This attribute indicates the most recent A-Bit status sent from this GvcIf to the subnet.')
gvcIfDlciABitReasonToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("localLinkDown", 4), ("missingFromLmiReport", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciABitReasonToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciABitReasonToNetwork.setDescription('This attribute indicates the reason (if any) for an inactive status to be sent to the subnet from this GvcIf. This reason is not applicable for an active status.')
gvcIfDlciStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 12), )
if mibBuilder.loadTexts: gvcIfDlciStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciStatsTable.setDescription('This group contains the operational statistics for the DLCI.')
gvcIfDlciStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"))
if mibBuilder.loadTexts: gvcIfDlciStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciStatsEntry.setDescription('An entry in the gvcIfDlciStatsTable.')
gvcIfDlciFrmFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciFrmFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciFrmFromNetwork.setDescription('This attribute counts the frames received from the subnet and sent to the Protocol Port associated with this GvcIf. When the maximum count is exceeded the count wraps to zero.')
gvcIfDlciFrmToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciFrmToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciFrmToNetwork.setDescription('This attribute counts the frames sent to the subnet. When the maximum count is exceeded the count wraps to zero.')
gvcIfDlciFrmDiscardToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciFrmDiscardToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciFrmDiscardToNetwork.setDescription('This attribute counts the frames which were received from the Protocol Port and discarded due to the aBitStatusFromNetwork being in an inactive state. When this count exceeds the maximum, it wraps to zero.')
gvcIfDlciFramesWithUnknownSaps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciFramesWithUnknownSaps.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciFramesWithUnknownSaps.setDescription('This attribute counts the number of frames received from the subnet on a BNN DLCI VC containing an (lSap,rSap) pair that does not match any SapMapping component index.')
gvcIfDlciOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 13), )
if mibBuilder.loadTexts: gvcIfDlciOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciOperTable.setDescription('This group contains the Dlci operational attributes.')
gvcIfDlciOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"))
if mibBuilder.loadTexts: gvcIfDlciOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciOperEntry.setDescription('An entry in the gvcIfDlciOperTable.')
gvcIfDlciEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ban", 0), ("bnn", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciEncapsulationType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciEncapsulationType.setDescription('This attribute indicates the encapsulation type used on this Dlci. ban indicates that SNA frames exchanged on the VC are encapsulated in RFC 1490 BAN format. ban indicates that SNA frames exchanged on the VC are encapsulated in RFC 1490 BNN format.')
gvcIfDlciLocalDeviceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 13, 1, 2), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLocalDeviceMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLocalDeviceMac.setDescription('This attribute indicates the MAC of the device located on this side of the VC, normally the host device. This address is inserted in the Destination Address (DA) field of the 802.5 frames sent, typically to a Token Ring interface. This address is expected in the SA field of the frames received from the local LAN. When this attribute is not empty All Route Explorer (ARE) and Single Route Explorer (SRE) frames received from the local LAN must have the SA field matching it, otherwise they are discarded.')
gvcIfDlciRemoteDeviceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 13, 1, 3), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciRemoteDeviceMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRemoteDeviceMac.setDescription('This attribute indicates the MAC of the device located at the far end of the VC. This is normally the host device. This address is inserted in the source address (SA) field of the 802.5 frames sent typically on a token ring interface. This address is expected in the destination address (DA) field of the 802.5 frames received, typically from a token ring interface. When this attribute is defined All Route Explorer (ARE) and Single Route Explorer (SRE) frames received from the local LAN must have the DA field matching it, otherwise they are discarded.')
gvcIfDlciSpOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14), )
if mibBuilder.loadTexts: gvcIfDlciSpOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpOpTable.setDescription('This group contains the actual service parameters in use for this instance of Dlci.')
gvcIfDlciSpOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"))
if mibBuilder.loadTexts: gvcIfDlciSpOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpOpEntry.setDescription('An entry in the gvcIfDlciSpOpTable.')
gvcIfDlciRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRateEnforcement.setDescription('This attribute indicates whether rate enforcement is in use for this Dlci.')
gvcIfDlciCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciCommittedInformationRate.setDescription('This attribute indicates the current effective committed information rate (cir) in bits per second (bit/s). cir is the rate at which the network agrees to transfer data with Discard Eligiblity indication DE=0 under normal conditions. This attribute should be ignored when rateEnforcement is off.')
gvcIfDlciCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciCommittedBurstSize.setDescription('This attribute indicates the committed burst size (bc) in bits. bc is the amount of data that the network agrees to transfer under normal conditions over a measurement interval (t). bc is used for data with Discard Eligibility indication DE=0. DE=1 data does not use bc at all, excessBurstSize if is used instead. This attribute should be ignored when rateEnforcement is off.')
gvcIfDlciExcessInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciExcessInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciExcessInformationRate.setDescription('This attribute indicates the current effective excess information rate (eir) in bits per second (bit/s). eir is the rate at which the network agrees to transfer data with Discard Eligibility indication DE=1 under normal conditions. DE can be set by the user or the network. DE indication of a data frame is set to 1 by the network after cir has been exceeded while eir is still available for data transfer.')
gvcIfDlciExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciExcessBurstSize.setDescription('This attribute indicates the excess burst size (be) in bits. be is the amount of uncommitted data that the network will attempt to deliver over measurement interval (t). Data marked DE=1 by the user or by the network is accounted for here. This attribute should be ignored when rateEnforcement is off.')
gvcIfDlciMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 14, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciMeasurementInterval.setDescription('This attribute indicates the time interval (in milliseconds) over which rates and burst sizes are measured. This attribute should be ignored when rateEnforcement is off.')
gvcIfDlciDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2))
gvcIfDlciDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 1), )
if mibBuilder.loadTexts: gvcIfDlciDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlciDc components.')
gvcIfDlciDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciDcIndex"))
if mibBuilder.loadTexts: gvcIfDlciDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciDc component.')
gvcIfDlciDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciDc components. These components cannot be added nor deleted.')
gvcIfDlciDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciDc tables.')
gvcIfDlciDcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDlciDcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcIndex.setDescription('This variable represents the index for the gvcIfDlciDc tables.')
gvcIfDlciDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10), )
if mibBuilder.loadTexts: gvcIfDlciDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcOptionsTable.setDescription('Options group defines attributes associated with direct call. It defines complete connection in terms of path and call options. This connection can be permanent (PVC).')
gvcIfDlciDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciDcIndex"))
if mibBuilder.loadTexts: gvcIfDlciDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcOptionsEntry.setDescription('An entry in the gvcIfDlciDcOptionsTable.')
gvcIfDlciDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcRemoteNpi.setDescription('This attribute specifies the numbering plan used in the remoteDna.')
gvcIfDlciDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcRemoteDna.setDescription('This attribute specifies the Data Network Address (Dna) of the remote. This is the called (destination) DTE address (Dna) to which this direct call will be sent.')
gvcIfDlciDcRemoteDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcRemoteDlci.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcRemoteDlci.setDescription('This attribute specifies the remote DLCI (Logical Channel Number) - it is used only for PVCs, where attribute type is set to permanentMaster or permanentSlave or permanentBackupSlave.')
gvcIfDlciDcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("permanentMaster", 1), ("permanentSlave", 2), ("permanentBackupSlave", 3), ("permanentSlaveWithBackup", 4))).clone('permanentMaster')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcType.setDescription('This attribute specifies the type of Vc call: permanentMaster, permanentSlave, permanentSlaveWithBackup, permanentBackupSlave. If the value is set to permanentMaster, then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentSlave, permanentBackupSlave or permanentSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as permanentMaster always initiates the calls. It will attempt to call once per minute. If the value is set to permanentSlave then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote end is defined as anything else. The permanentSlave end will attempt to call once per minute. If the value is set to permanentSlaveWithBackup then a permanent connection will be established between the 2 ends . The remote end must be defined as a permanentMaster. The Connection cannot be established if the remote end is defined as anything else. The permanentSlaveWithBackup end will attempt to call once per minute. If the value is set to permanentBackupSlave then a permanent connection will be established between the 2 ends only if the permanentMaster end is disconnected from the permanentSlaveWithBackup end and a backup call is established by the redirection system. If the permanentSlaveWithBackup interface becomes visible again, the permanentBackupSlave end is disconnected and the permanentSlaveWithBackup end is reconnected to the permanentMaster end. The permanentBackupSlave end does not try to establish pvc call.')
gvcIfDlciDcTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9, 255))).clone(namedValues=NamedValues(("normal", 0), ("high", 9), ("useDnaDefTP", 255))).clone('useDnaDefTP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcTransferPriority.setDescription('This attribute specifies the transfer priority to network for the outgoing calls using this particular DLCI. It overRides the defaultTransferPriority provisioned in its associated Dna component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), and routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of transferPriority is useDnaDefTP. It means using the provisioning value under defaultTransferPriority of its associated Dna for this DLCI.')
gvcIfDlciDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this DLCI. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Traffic with normal priority is discarded first than the traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority. The default of discardPriority is useDnaDefPriority.')
gvcIfDlciDcNfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 482), )
if mibBuilder.loadTexts: gvcIfDlciDcNfaTable.setStatus('obsolete')
if mibBuilder.loadTexts: gvcIfDlciDcNfaTable.setDescription('Two explicit attributes discardPriority and transferPriority are created to replace H.01 and H.30 in the group VcsDirectCallOptionsProv of this file. The migrate escape here (DcComponent::migrateFaxEscape) propagates the old provisioning data under H.01 and H.30 into discardPriority and transferPriority. The rule of the above propagation are: 0 in H.01 is equivalent to discardPriority 0; 1 in H.01 is equivalent to discardPriority 1. And 0 in H.30 is equivalent to transferPriority normal; 1 in H.30 is equivalent to transferPriority high. Please refer to discardPriority and transferPriority for more information on how to use them.')
gvcIfDlciDcNfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 482, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciDcIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciDcNfaIndex"))
if mibBuilder.loadTexts: gvcIfDlciDcNfaEntry.setStatus('obsolete')
if mibBuilder.loadTexts: gvcIfDlciDcNfaEntry.setDescription('An entry in the gvcIfDlciDcNfaTable.')
gvcIfDlciDcNfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 482, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(48, 48), )))
if mibBuilder.loadTexts: gvcIfDlciDcNfaIndex.setStatus('obsolete')
if mibBuilder.loadTexts: gvcIfDlciDcNfaIndex.setDescription('This variable represents the index for the gvcIfDlciDcNfaTable.')
gvcIfDlciDcNfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 482, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciDcNfaValue.setStatus('obsolete')
if mibBuilder.loadTexts: gvcIfDlciDcNfaValue.setDescription('This variable represents an individual value for the gvcIfDlciDcNfaTable.')
gvcIfDlciDcNfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 2, 482, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gvcIfDlciDcNfaRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: gvcIfDlciDcNfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the gvcIfDlciDcNfaTable.')
gvcIfDlciVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3))
gvcIfDlciVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 1), )
if mibBuilder.loadTexts: gvcIfDlciVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlciVc components.')
gvcIfDlciVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciVcIndex"))
if mibBuilder.loadTexts: gvcIfDlciVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciVc component.')
gvcIfDlciVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciVc components. These components cannot be added nor deleted.')
gvcIfDlciVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciVc tables.')
gvcIfDlciVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDlciVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcIndex.setDescription('This variable represents the index for the gvcIfDlciVc tables.')
gvcIfDlciVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10), )
if mibBuilder.loadTexts: gvcIfDlciVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCadTable.setDescription('This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
gvcIfDlciVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciVcIndex"))
if mibBuilder.loadTexts: gvcIfDlciVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCadEntry.setDescription('An entry in the gvcIfDlciVcCadTable.')
gvcIfDlciVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcType.setDescription('This attribute displays the type of call, pvc,svc or spvc.')
gvcIfDlciVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
gvcIfDlciVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
gvcIfDlciVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
gvcIfDlciVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
gvcIfDlciVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
gvcIfDlciVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
gvcIfDlciVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
gvcIfDlciVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
gvcIfDlciVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
gvcIfDlciVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
gvcIfDlciVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
gvcIfDlciVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
gvcIfDlciVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPathReliability.setDescription('This attribute displays the path reliability.')
gvcIfDlciVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
gvcIfDlciVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
gvcIfDlciVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
gvcIfDlciVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
gvcIfDlciVcRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
gvcIfDlciVcRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
gvcIfDlciVcEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
gvcIfDlciVcEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
gvcIfDlciVcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
gvcIfDlciVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11), )
if mibBuilder.loadTexts: gvcIfDlciVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
gvcIfDlciVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciVcIndex"))
if mibBuilder.loadTexts: gvcIfDlciVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcIntdEntry.setDescription('An entry in the gvcIfDlciVcIntdTable.')
gvcIfDlciVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCallReferenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCallReferenceNumber.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
gvcIfDlciVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
gvcIfDlciVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
gvcIfDlciVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
gvcIfDlciVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
gvcIfDlciVcFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12), )
if mibBuilder.loadTexts: gvcIfDlciVcFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcFrdTable.setDescription('This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
gvcIfDlciVcFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciVcIndex"))
if mibBuilder.loadTexts: gvcIfDlciVcFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcFrdEntry.setDescription('An entry in the gvcIfDlciVcFrdTable.')
gvcIfDlciVcFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
gvcIfDlciVcCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
gvcIfDlciVcNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
gvcIfDlciVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
gvcIfDlciVcCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
gvcIfDlciVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
gvcIfDlciVcNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
gvcIfDlciVcFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
gvcIfDlciVcOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
gvcIfDlciVcPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
gvcIfDlciVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
gvcIfDlciVcSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
gvcIfDlciVcPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
gvcIfDlciVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
gvcIfDlciVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
gvcIfDlciVcOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
gvcIfDlciVcPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
gvcIfDlciVcDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 417), )
if mibBuilder.loadTexts: gvcIfDlciVcDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcDmepTable.setDescription('This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
gvcIfDlciVcDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 417, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciVcIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciVcDmepValue"))
if mibBuilder.loadTexts: gvcIfDlciVcDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcDmepEntry.setDescription('An entry in the gvcIfDlciVcDmepTable.')
gvcIfDlciVcDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 3, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciVcDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciVcDmepValue.setDescription('This variable represents both the value and the index for the gvcIfDlciVcDmepTable.')
gvcIfDlciSp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4))
gvcIfDlciSpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 1), )
if mibBuilder.loadTexts: gvcIfDlciSpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlciSp components.')
gvcIfDlciSpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSpIndex"))
if mibBuilder.loadTexts: gvcIfDlciSpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciSp component.')
gvcIfDlciSpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciSpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciSp components. These components can be added and deleted.')
gvcIfDlciSpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciSpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciSp tables.')
gvcIfDlciSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDlciSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpIndex.setDescription('This variable represents the index for the gvcIfDlciSp tables.')
gvcIfDlciSpParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11), )
if mibBuilder.loadTexts: gvcIfDlciSpParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpParmsTable.setDescription('This group contains the provisionable attributes for the Data Link Connection Identifier. These attributes reflect the service parameters specific to this instance of Dlci.')
gvcIfDlciSpParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSpIndex"))
if mibBuilder.loadTexts: gvcIfDlciSpParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpParmsEntry.setDescription('An entry in the gvcIfDlciSpParmsTable.')
gvcIfDlciSpRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciSpRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpRateEnforcement.setDescription('This attribute specifies whether rate enforcement is to be used on this DLCI. Turning on rate enforcement means that the data sent from the service to the virtual circuit is subjected to rate control.')
gvcIfDlciSpCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciSpCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpCommittedInformationRate.setDescription('This attribute specifies the committed information rate (cir) in bits per second (bit/s). When rateEnforcement is set to on, cir is the rate at which the network agrees to transfer information under normal conditions. This rate is measured over a measurement interval (t) that is determined internally based on cir and the committed burst size (bc). An exception to this occurs when cir is provisioned to be zero, in which case the measurement interval (t) must be provisioned explicitly. This attribute is ignored when rateEnforcement is off. If rateEnforcement is on and this attribute is 0, bc must also be 0.')
gvcIfDlciSpCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciSpCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpCommittedBurstSize.setDescription('This attribute specifies the committed burst size (bc) in bits. bc is the amount of data that a network agrees to transfer under normal conditions over a measurement interval (t). Data marked DE=1 is not accounted for in bc. This attribute is ignored when rateEnforcement is off. If rateEnforcement is on and this attribute is 0, cir must also be 0.')
gvcIfDlciSpExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciSpExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpExcessBurstSize.setDescription('This attribute specifies the excess burst size (be) in bits. be is the amount of uncommitted data that the network will attempt to deliver over measurement interval (t). Data marked DE=1 by the user or by the network is accounted for here. cir, bc, and be cannot all be 0 when rateEnforcement is on.')
gvcIfDlciSpMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 4, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciSpMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSpMeasurementInterval.setDescription('This attribute specifies the time interval (in milliseconds) over which rates and burst sizes are measured. When cir and bc are 0 and rateEnforcement is on, this attribute must be provisioned. When cir and bc are non-zero, the time interval is internally calculated. In that situation, this attribute is ignored, and is not representative of the time interval. This attribute is also ignored when rateEnforcement is off. If rateEnforcement is on and both cir and bc are 0, this field must be non-zero.')
gvcIfDlciBnn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5))
gvcIfDlciBnnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5, 1), )
if mibBuilder.loadTexts: gvcIfDlciBnnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciBnnRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlciBnn components.')
gvcIfDlciBnnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciBnnIndex"))
if mibBuilder.loadTexts: gvcIfDlciBnnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciBnnRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciBnn component.')
gvcIfDlciBnnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciBnnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciBnnRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciBnn components. These components can be added and deleted.')
gvcIfDlciBnnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciBnnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciBnnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciBnnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciBnnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciBnnStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciBnn tables.')
gvcIfDlciBnnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDlciBnnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciBnnIndex.setDescription('This variable represents the index for the gvcIfDlciBnn tables.')
gvcIfDlciLdev = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6))
gvcIfDlciLdevRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 1), )
if mibBuilder.loadTexts: gvcIfDlciLdevRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlciLdev components.')
gvcIfDlciLdevRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciLdevIndex"))
if mibBuilder.loadTexts: gvcIfDlciLdevRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciLdev component.')
gvcIfDlciLdevRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciLdev components. These components can be added and deleted.')
gvcIfDlciLdevComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciLdevStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciLdev tables.')
gvcIfDlciLdevIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDlciLdevIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevIndex.setDescription('This variable represents the index for the gvcIfDlciLdev tables.')
gvcIfDlciLdevAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 10), )
if mibBuilder.loadTexts: gvcIfDlciLdevAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevAddrTable.setDescription('This group defines the LAN MAC address.')
gvcIfDlciLdevAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciLdevIndex"))
if mibBuilder.loadTexts: gvcIfDlciLdevAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevAddrEntry.setDescription('An entry in the gvcIfDlciLdevAddrTable.')
gvcIfDlciLdevMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 10, 1, 1), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevMac.setDescription('This attribute specifies the MAC of the device located on this side of the PVC, normally the host device. This address is inserted in the Destination Address (DA) field of the 802.5 frames sent typically to a Token Ring interface.')
gvcIfDlciLdevDevOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11), )
if mibBuilder.loadTexts: gvcIfDlciLdevDevOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDevOpTable.setDescription('This group specifies the operational attributes for devices that are potentially reachable by the SNA DLR service.')
gvcIfDlciLdevDevOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciLdevIndex"))
if mibBuilder.loadTexts: gvcIfDlciLdevDevOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDevOpEntry.setDescription('An entry in the gvcIfDlciLdevDevOpTable.')
gvcIfDlciLdevDeviceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unreachable", 0), ("reachable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceStatus.setDescription('This attribute indicates whether the local device specified by mac is reachable or unreachable from this SNA DLR interface. The device status is determined by the SNA DLR service by sending a TEST frame with the Poll bit set to the device periodically. If a TEST frame with the Final bit set is received from the device then the device status becomes reachable; otherwise the device status is unreachable. When the device status is reachable, connections to this device are accepted. When the device status is unreachable, existing connections to the device are cleared and new connections are cleared to hunt or redirection services.')
gvcIfDlciLdevActiveLinkStations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevActiveLinkStations.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevActiveLinkStations.setDescription('This attribute indicates the number of active link station connections using this device mapping component. It includes the link stations using the Qllc and the Frame-Relay connections.')
gvcIfDlciLdevLastTimeUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1, 3), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevLastTimeUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevLastTimeUnreachable.setDescription('This attribute indicates the last time the deviceStatus changed from reachable to unreachable.')
gvcIfDlciLdevLastTimeReachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1, 4), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevLastTimeReachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevLastTimeReachable.setDescription('This attribute indicates the last time the deviceStatus changed from unreachable to reachable.')
gvcIfDlciLdevDeviceUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceUnreachable.setDescription('This attribute counts the number of times the deviceStatus changed from reachable to unreachable. When the maximum count is exceeded the count wraps to zero.')
gvcIfDlciLdevMonitoringLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciLdevMonitoringLcn.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevMonitoringLcn.setDescription('This attribute indicates the instance of the GvcIf/n Lcn that is reserved for monitoring the device indicated by the mac.')
gvcIfDlciLdevDmoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12), )
if mibBuilder.loadTexts: gvcIfDlciLdevDmoTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDmoTable.setDescription('This group defines the device monitoring options.')
gvcIfDlciLdevDmoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciLdevIndex"))
if mibBuilder.loadTexts: gvcIfDlciLdevDmoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDmoEntry.setDescription('An entry in the gvcIfDlciLdevDmoTable.')
gvcIfDlciLdevDeviceMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceMonitoring.setDescription('This attribute specifies wether device monitoring for the device specified in mac is enabled or disabled.')
gvcIfDlciLdevClearVcsWhenUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevClearVcsWhenUnreachable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevClearVcsWhenUnreachable.setDescription('This attribute specifies wether to clear or not existing VCs when deviceStatus changes from reachable to unreachable.')
gvcIfDlciLdevDeviceMonitoringTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceMonitoringTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevDeviceMonitoringTimer.setDescription('This attribute specifies the wait period between 2 consecutive device monitoring sequences. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDlciLdevTestResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevTestResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevTestResponseTimer.setDescription('This attribute specifies the wait period between 2 consecutive TEST commands sent during one device monitoring sequence. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDlciLdevMaximumTestRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 6, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciLdevMaximumTestRetry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciLdevMaximumTestRetry.setDescription('This attribute specifies the maximum number of TEST commands sent during one device monitoring sequence. A device monitoring sequence is characterized by one of the following: up to maxTestRetry TEST commands sent and a TEST response received or up to maxTestRetry of TEST commands sent and no TEST response received.')
gvcIfDlciRdev = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7))
gvcIfDlciRdevRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 1), )
if mibBuilder.loadTexts: gvcIfDlciRdevRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDlciRdev components.')
gvcIfDlciRdevRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciRdevIndex"))
if mibBuilder.loadTexts: gvcIfDlciRdevRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciRdev component.')
gvcIfDlciRdevRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciRdevRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciRdev components. These components can be added and deleted.')
gvcIfDlciRdevComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciRdevComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciRdevStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciRdevStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciRdev tables.')
gvcIfDlciRdevIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfDlciRdevIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevIndex.setDescription('This variable represents the index for the gvcIfDlciRdev tables.')
gvcIfDlciRdevAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 10), )
if mibBuilder.loadTexts: gvcIfDlciRdevAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevAddrTable.setDescription('This group defines the LAN MAC address.')
gvcIfDlciRdevAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciRdevIndex"))
if mibBuilder.loadTexts: gvcIfDlciRdevAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevAddrEntry.setDescription('An entry in the gvcIfDlciRdevAddrTable.')
gvcIfDlciRdevMac = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 7, 10, 1, 1), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDlciRdevMac.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciRdevMac.setDescription("This attribute specifies the MAC address that must be present in the Destination Address (DA) field of the 802.5 frames received (typically from a Token Ring interface) in order for the SNA DLR interface to copy them across this PVC. The MAC address in the frames is not necessarily the real MAC address of the remote device since it could be re-mapped at the remote end of the PVC using the Ddm or Sdm component or the equivalent mapping on another vendor's equipment.")
gvcIfDlciSap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8))
gvcIfDlciSapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1), )
if mibBuilder.loadTexts: gvcIfDlciSapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of gvcIfDlciSap components.')
gvcIfDlciSapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapLocalSapIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapRemoteSapIndex"))
if mibBuilder.loadTexts: gvcIfDlciSapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciSap component.')
gvcIfDlciSapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciSap components. These components cannot be added nor deleted.')
gvcIfDlciSapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciSapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciSap tables.')
gvcIfDlciSapLocalSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), ValueRangeConstraint(16, 16), ValueRangeConstraint(20, 20), ValueRangeConstraint(24, 24), ValueRangeConstraint(28, 28), ValueRangeConstraint(32, 32), ValueRangeConstraint(36, 36), ValueRangeConstraint(40, 40), ValueRangeConstraint(44, 44), ValueRangeConstraint(48, 48), ValueRangeConstraint(52, 52), ValueRangeConstraint(56, 56), ValueRangeConstraint(60, 60), ValueRangeConstraint(64, 64), ValueRangeConstraint(68, 68), ValueRangeConstraint(72, 72), ValueRangeConstraint(76, 76), ValueRangeConstraint(80, 80), ValueRangeConstraint(84, 84), ValueRangeConstraint(88, 88), ValueRangeConstraint(92, 92), ValueRangeConstraint(96, 96), ValueRangeConstraint(100, 100), ValueRangeConstraint(104, 104), ValueRangeConstraint(108, 108), ValueRangeConstraint(112, 112), ValueRangeConstraint(116, 116), ValueRangeConstraint(120, 120), ValueRangeConstraint(124, 124), ValueRangeConstraint(128, 128), ValueRangeConstraint(132, 132), ValueRangeConstraint(136, 136), ValueRangeConstraint(140, 140), ValueRangeConstraint(144, 144), ValueRangeConstraint(148, 148), ValueRangeConstraint(152, 152), ValueRangeConstraint(156, 156), ValueRangeConstraint(160, 160), ValueRangeConstraint(164, 164), ValueRangeConstraint(168, 168), ValueRangeConstraint(172, 172), ValueRangeConstraint(176, 176), ValueRangeConstraint(180, 180), ValueRangeConstraint(184, 184), ValueRangeConstraint(188, 188), ValueRangeConstraint(192, 192), ValueRangeConstraint(196, 196), ValueRangeConstraint(200, 200), ValueRangeConstraint(204, 204), ValueRangeConstraint(208, 208), ValueRangeConstraint(212, 212), ValueRangeConstraint(216, 216), ValueRangeConstraint(220, 220), ValueRangeConstraint(232, 232), ValueRangeConstraint(236, 236), ValueRangeConstraint(248, 248), ValueRangeConstraint(252, 252), )))
if mibBuilder.loadTexts: gvcIfDlciSapLocalSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapLocalSapIndex.setDescription('This variable represents an index for the gvcIfDlciSap tables.')
gvcIfDlciSapRemoteSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), ValueRangeConstraint(16, 16), ValueRangeConstraint(20, 20), ValueRangeConstraint(24, 24), ValueRangeConstraint(28, 28), ValueRangeConstraint(32, 32), ValueRangeConstraint(36, 36), ValueRangeConstraint(40, 40), ValueRangeConstraint(44, 44), ValueRangeConstraint(48, 48), ValueRangeConstraint(52, 52), ValueRangeConstraint(56, 56), ValueRangeConstraint(60, 60), ValueRangeConstraint(64, 64), ValueRangeConstraint(68, 68), ValueRangeConstraint(72, 72), ValueRangeConstraint(76, 76), ValueRangeConstraint(80, 80), ValueRangeConstraint(84, 84), ValueRangeConstraint(88, 88), ValueRangeConstraint(92, 92), ValueRangeConstraint(96, 96), ValueRangeConstraint(100, 100), ValueRangeConstraint(104, 104), ValueRangeConstraint(108, 108), ValueRangeConstraint(112, 112), ValueRangeConstraint(116, 116), ValueRangeConstraint(120, 120), ValueRangeConstraint(124, 124), ValueRangeConstraint(128, 128), ValueRangeConstraint(132, 132), ValueRangeConstraint(136, 136), ValueRangeConstraint(140, 140), ValueRangeConstraint(144, 144), ValueRangeConstraint(148, 148), ValueRangeConstraint(152, 152), ValueRangeConstraint(156, 156), ValueRangeConstraint(160, 160), ValueRangeConstraint(164, 164), ValueRangeConstraint(168, 168), ValueRangeConstraint(172, 172), ValueRangeConstraint(176, 176), ValueRangeConstraint(180, 180), ValueRangeConstraint(184, 184), ValueRangeConstraint(188, 188), ValueRangeConstraint(192, 192), ValueRangeConstraint(196, 196), ValueRangeConstraint(200, 200), ValueRangeConstraint(204, 204), ValueRangeConstraint(208, 208), ValueRangeConstraint(212, 212), ValueRangeConstraint(216, 216), ValueRangeConstraint(220, 220), ValueRangeConstraint(232, 232), ValueRangeConstraint(236, 236), ValueRangeConstraint(248, 248), ValueRangeConstraint(252, 252), )))
if mibBuilder.loadTexts: gvcIfDlciSapRemoteSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapRemoteSapIndex.setDescription('This variable represents an index for the gvcIfDlciSap tables.')
gvcIfDlciSapCircuit = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2))
gvcIfDlciSapCircuitRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1), )
if mibBuilder.loadTexts: gvcIfDlciSapCircuitRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of gvcIfDlciSapCircuit components.')
gvcIfDlciSapCircuitRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapLocalSapIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapRemoteSapIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapCircuitS1MacIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapCircuitS1SapIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapCircuitS2MacIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDlciSapCircuitS2SapIndex"))
if mibBuilder.loadTexts: gvcIfDlciSapCircuitRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDlciSapCircuit component.')
gvcIfDlciSapCircuitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSapCircuitRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDlciSapCircuit components. These components cannot be added nor deleted.')
gvcIfDlciSapCircuitComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSapCircuitComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDlciSapCircuitStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDlciSapCircuitStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitStorageType.setDescription('This variable represents the storage type value for the gvcIfDlciSapCircuit tables.')
gvcIfDlciSapCircuitS1MacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS1MacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS1MacIndex.setDescription('This variable represents an index for the gvcIfDlciSapCircuit tables.')
gvcIfDlciSapCircuitS1SapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 254)))
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS1SapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS1SapIndex.setDescription('This variable represents an index for the gvcIfDlciSapCircuit tables.')
gvcIfDlciSapCircuitS2MacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 12), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS2MacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS2MacIndex.setDescription('This variable represents an index for the gvcIfDlciSapCircuit tables.')
gvcIfDlciSapCircuitS2SapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 7, 8, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 254)))
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS2SapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDlciSapCircuitS2SapIndex.setDescription('This variable represents an index for the gvcIfDlciSapCircuit tables.')
gvcIfFrSvc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8))
gvcIfFrSvcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 1), )
if mibBuilder.loadTexts: gvcIfFrSvcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfFrSvc components.')
gvcIfFrSvcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfFrSvcIndex"))
if mibBuilder.loadTexts: gvcIfFrSvcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfFrSvc component.')
gvcIfFrSvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfFrSvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfFrSvc components. These components can be added and deleted.')
gvcIfFrSvcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfFrSvcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfFrSvcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfFrSvcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcStorageType.setDescription('This variable represents the storage type value for the gvcIfFrSvc tables.')
gvcIfFrSvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: gvcIfFrSvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcIndex.setDescription('This variable represents the index for the gvcIfFrSvc tables.')
gvcIfFrSvcProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 11), )
if mibBuilder.loadTexts: gvcIfFrSvcProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcProvisionedTable.setDescription('This group contains the provisonable parameters for the APPN service Frame Relay SVC calls.')
gvcIfFrSvcProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfFrSvcIndex"))
if mibBuilder.loadTexts: gvcIfFrSvcProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcProvisionedEntry.setDescription('An entry in the gvcIfFrSvcProvisionedTable.')
gvcIfFrSvcMaximumFrameRelaySvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3072)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfFrSvcMaximumFrameRelaySvcs.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcMaximumFrameRelaySvcs.setDescription('This attribute specifies the maximum number of concurrently active Frame Relay SVC calls that are allowed for this service. This attribute does not include the general switched virtual circuits (GSVC).')
gvcIfFrSvcRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfFrSvcRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcRateEnforcement.setDescription('This attribute specifies whether rate enforcement is to be used for new Frame Relay SVCs on this service. When rate enforcement is on the rate of data sent by the service to individual Frame Relay SVCs is controlled.')
gvcIfFrSvcMaximumCir = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000)).clone(2048000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfFrSvcMaximumCir.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcMaximumCir.setDescription('This attribute specifies the maximum rate enforcement CIR (Committed Information Rate) that is allowed for use with the Frame Relay SVCs on this service. During call setup negotiation, if the caller to this service requests a higher CIR value be used, the CIR used is reduced to the value of maximumCir.')
gvcIfFrSvcOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 12), )
if mibBuilder.loadTexts: gvcIfFrSvcOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcOperationalTable.setDescription('This group contains the operational attributes for the APPN Frame Relay SVC calls.')
gvcIfFrSvcOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfFrSvcIndex"))
if mibBuilder.loadTexts: gvcIfFrSvcOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcOperationalEntry.setDescription('An entry in the gvcIfFrSvcOperationalTable.')
gvcIfFrSvcCurrentNumberOfSvcCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 8, 12, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfFrSvcCurrentNumberOfSvcCalls.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfFrSvcCurrentNumberOfSvcCalls.setDescription('This attribute indicates the number of Frame Relay SVCs currently existing on this service. This attribute does not include the general switched virtual circuits (GSVC).')
gvcIfSMacF = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9))
gvcIfSMacFRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 1), )
if mibBuilder.loadTexts: gvcIfSMacFRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfSMacF components.')
gvcIfSMacFRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfSMacFIndex"))
if mibBuilder.loadTexts: gvcIfSMacFRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfSMacF component.')
gvcIfSMacFRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfSMacFRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfSMacF components. These components can be added and deleted.')
gvcIfSMacFComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfSMacFComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfSMacFStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfSMacFStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFStorageType.setDescription('This variable represents the storage type value for the gvcIfSMacF tables.')
gvcIfSMacFIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: gvcIfSMacFIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFIndex.setDescription('This variable represents the index for the gvcIfSMacF tables.')
gvcIfSMacFOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 11), )
if mibBuilder.loadTexts: gvcIfSMacFOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFOperTable.setDescription('This group provides the administrative set of parameters for the GvcIf component.')
gvcIfSMacFOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfSMacFIndex"))
if mibBuilder.loadTexts: gvcIfSMacFOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFOperEntry.setDescription('An entry in the gvcIfSMacFOperTable.')
gvcIfSMacFFramesMatchingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 9, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfSMacFFramesMatchingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfSMacFFramesMatchingFilter.setDescription('This attribute counts the number of frames containing a MAC address matching the instance of this component. When the maximum count is exceeded the count wraps to zero.')
gvcIfDMacF = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10))
gvcIfDMacFRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 1), )
if mibBuilder.loadTexts: gvcIfDMacFRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFRowStatusTable.setDescription('This entry controls the addition and deletion of gvcIfDMacF components.')
gvcIfDMacFRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDMacFIndex"))
if mibBuilder.loadTexts: gvcIfDMacFRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFRowStatusEntry.setDescription('A single entry in the table represents a single gvcIfDMacF component.')
gvcIfDMacFRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gvcIfDMacFRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFRowStatus.setDescription('This variable is used as the basis for SNMP naming of gvcIfDMacF components. These components can be added and deleted.')
gvcIfDMacFComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDMacFComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
gvcIfDMacFStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDMacFStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFStorageType.setDescription('This variable represents the storage type value for the gvcIfDMacF tables.')
gvcIfDMacFIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: gvcIfDMacFIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFIndex.setDescription('This variable represents the index for the gvcIfDMacF tables.')
gvcIfDMacFOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 11), )
if mibBuilder.loadTexts: gvcIfDMacFOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFOperTable.setDescription('This group provides the administrative set of parameters for the GvcIf component.')
gvcIfDMacFOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfIndex"), (0, "Nortel-Magellan-Passport-GeneralVcInterfaceMIB", "gvcIfDMacFIndex"))
if mibBuilder.loadTexts: gvcIfDMacFOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFOperEntry.setDescription('An entry in the gvcIfDMacFOperTable.')
gvcIfDMacFFramesMatchingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 107, 10, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gvcIfDMacFFramesMatchingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: gvcIfDMacFFramesMatchingFilter.setDescription('This attribute counts the number of frames containing a MAC address matching the instance of this component. When the maximum count is exceeded the count wraps to zero.')
generalVcInterfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 1))
generalVcInterfaceGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 1, 5))
generalVcInterfaceGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 1, 5, 2))
generalVcInterfaceGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 1, 5, 2, 2))
generalVcInterfaceCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 3))
generalVcInterfaceCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 3, 5))
generalVcInterfaceCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 3, 5, 2))
generalVcInterfaceCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 58, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-GeneralVcInterfaceMIB", gvcIfLcnOperTable=gvcIfLcnOperTable, gvcIfDnaDdmDmoEntry=gvcIfDnaDdmDmoEntry, gvcIfDnaHgM=gvcIfDnaHgM, gvcIfLcnVcAckStackingTimeouts=gvcIfLcnVcAckStackingTimeouts, gvcIfDlciLocalDeviceMac=gvcIfDlciLocalDeviceMac, gvcIfDcCfaIndex=gvcIfDcCfaIndex, gvcIfDnaCugInterlockCode=gvcIfDnaCugInterlockCode, gvcIfDlciVc=gvcIfDlciVc, gvcIfDlciABitReasonToNetwork=gvcIfDlciABitReasonToNetwork, gvcIfRgStorageType=gvcIfRgStorageType, gvcIfRgIfEntryTable=gvcIfRgIfEntryTable, gvcIfRDnaMapLanAdEntry=gvcIfRDnaMapLanAdEntry, gvcIfDnaIncCalls=gvcIfDnaIncCalls, gvcIfDnaCugRowStatusTable=gvcIfDnaCugRowStatusTable, gvcIfIssueLcnClearAlarm=gvcIfIssueLcnClearAlarm, gvcIfDlciRdevAddrEntry=gvcIfDlciRdevAddrEntry, gvcIfDlciSpCommittedInformationRate=gvcIfDlciSpCommittedInformationRate, gvcIfDcRowStatus=gvcIfDcRowStatus, gvcIfDlciSapCircuitComponentName=gvcIfDlciSapCircuitComponentName, gvcIfDMacFRowStatusTable=gvcIfDMacFRowStatusTable, gvcIfLcnVcSegmentsSent=gvcIfLcnVcSegmentsSent, gvcIfDlciStateEntry=gvcIfDlciStateEntry, gvcIfDlciStateTable=gvcIfDlciStateTable, gvcIfLcnVcLocalRxPktSize=gvcIfLcnVcLocalRxPktSize, gvcIfLcnVcDuplicatesFromSubnet=gvcIfLcnVcDuplicatesFromSubnet, gvcIfDnaSdmDeviceMonitoring=gvcIfDnaSdmDeviceMonitoring, gvcIfDlciVcSegmentsRx=gvcIfDlciVcSegmentsRx, gvcIfDcOptionsEntry=gvcIfDcOptionsEntry, gvcIfDiscardedQllcCalls=gvcIfDiscardedQllcCalls, gvcIfDlciDcNfaIndex=gvcIfDlciDcNfaIndex, gvcIfDnaHgMAvailabilityUpdateThreshold=gvcIfDnaHgMAvailabilityUpdateThreshold, gvcIfDlciVcFrmLossTimeouts=gvcIfDlciVcFrmLossTimeouts, gvcIfSMacFOperTable=gvcIfSMacFOperTable, gvcIfLcnStateTable=gvcIfLcnStateTable, gvcIfDnaCugComponentName=gvcIfDnaCugComponentName, gvcIfDnaCugPreferential=gvcIfDnaCugPreferential, gvcIfDlciLdevMac=gvcIfDlciLdevMac, gvcIfDlciVcNotDataXferFromSubnet=gvcIfDlciVcNotDataXferFromSubnet, gvcIfDMacFOperEntry=gvcIfDMacFOperEntry, gvcIfDcOptionsTable=gvcIfDcOptionsTable, gvcIfDlciDcRowStatusEntry=gvcIfDlciDcRowStatusEntry, gvcIfRgProvEntry=gvcIfRgProvEntry, gvcIfDlciVcNotDataXferToSubnet=gvcIfDlciVcNotDataXferToSubnet, gvcIfDlciRdevAddrTable=gvcIfDlciRdevAddrTable, gvcIfLcnVcSegmentsRx=gvcIfLcnVcSegmentsRx, gvcIfLcnVcMaxSubnetPktSize=gvcIfLcnVcMaxSubnetPktSize, gvcIfDnaHgMMaxAvailableLinkStations=gvcIfDnaHgMMaxAvailableLinkStations, gvcIfRDnaMapRowStatusEntry=gvcIfRDnaMapRowStatusEntry, gvcIfDlciSpParmsEntry=gvcIfDlciSpParmsEntry, gvcIfFrSvcRowStatusEntry=gvcIfFrSvcRowStatusEntry, gvcIfDnaHgMComponentName=gvcIfDnaHgMComponentName, gvcIfSMacFIndex=gvcIfSMacFIndex, gvcIfDlciVcCadEntry=gvcIfDlciVcCadEntry, gvcIfCallsFromNetwork=gvcIfCallsFromNetwork, gvcIfDnaDdmRowStatusEntry=gvcIfDnaDdmRowStatusEntry, gvcIfDlciLdevDeviceMonitoringTimer=gvcIfDlciLdevDeviceMonitoringTimer, gvcIfDlciBnnStorageType=gvcIfDlciBnnStorageType, gvcIfDlciLdevRowStatusTable=gvcIfDlciLdevRowStatusTable, gvcIfLcnVcSubnetRecoveries=gvcIfLcnVcSubnetRecoveries, gvcIfLcnVcIndex=gvcIfLcnVcIndex, gvcIfRgIfEntryEntry=gvcIfRgIfEntryEntry, gvcIfDlciVcPeakOoSeqFrmForwarded=gvcIfDlciVcPeakOoSeqFrmForwarded, gvcIfLcnVcCalledLcn=gvcIfLcnVcCalledLcn, gvcIfDnaDefaultRecvFrmNetworkPacketSize=gvcIfDnaDefaultRecvFrmNetworkPacketSize, gvcIfLcnRowStatusTable=gvcIfLcnRowStatusTable, gvcIfDlciLdevComponentName=gvcIfDlciLdevComponentName, gvcIfDcCfaEntry=gvcIfDcCfaEntry, gvcIfLcnVcSubnetRxPktSize=gvcIfLcnVcSubnetRxPktSize, gvcIfDnaIncomingOptionsEntry=gvcIfDnaIncomingOptionsEntry, gvcIfDnaComponentName=gvcIfDnaComponentName, gvcIfDlciRowStatus=gvcIfDlciRowStatus, gvcIfDlciComponentName=gvcIfDlciComponentName, gvcIfDlciVcState=gvcIfDlciVcState, gvcIfDlciVcPathReliability=gvcIfDlciVcPathReliability, gvcIfDlciBnn=gvcIfDlciBnn, gvcIfDlciVcEmissionPriorityFromNetwork=gvcIfDlciVcEmissionPriorityFromNetwork, gvcIfLcnVcLocalTxPktSize=gvcIfLcnVcLocalTxPktSize, gvcIfOperationalState=gvcIfOperationalState, gvcIfLcnVcWrTriggers=gvcIfLcnVcWrTriggers, gvcIfRowStatusTable=gvcIfRowStatusTable, gvcIfDlciOperationalState=gvcIfDlciOperationalState, gvcIfDnaSdmDmoEntry=gvcIfDnaSdmDmoEntry, gvcIfDlciSpStorageType=gvcIfDlciSpStorageType, gvcIfDlciLdevAddrTable=gvcIfDlciLdevAddrTable, gvcIfFrSvcMaximumCir=gvcIfFrSvcMaximumCir, gvcIfLcnVcSubnetTxPktSize=gvcIfLcnVcSubnetTxPktSize, gvcIfDlciSpRateEnforcement=gvcIfDlciSpRateEnforcement, gvcIf=gvcIf, generalVcInterfaceGroupBE01=generalVcInterfaceGroupBE01, gvcIfDnaDdm=gvcIfDnaDdm, gvcIfDMacFRowStatusEntry=gvcIfDMacFRowStatusEntry, gvcIfDlciABitReasonFromNetwork=gvcIfDlciABitReasonFromNetwork, gvcIfDlciOperTable=gvcIfDlciOperTable, gvcIfDlciVcCadTable=gvcIfDlciVcCadTable, gvcIfDlciFrmToNetwork=gvcIfDlciFrmToNetwork, generalVcInterfaceCapabilitiesBE=generalVcInterfaceCapabilitiesBE, gvcIfDnaDefaultTransferPriority=gvcIfDnaDefaultTransferPriority, gvcIfDnaHgMHgAddrAddrEntry=gvcIfDnaHgMHgAddrAddrEntry, gvcIfLcnVcPeakRetryQueueSize=gvcIfLcnVcPeakRetryQueueSize, gvcIfDnaOutgoingOptionsTable=gvcIfDnaOutgoingOptionsTable, gvcIfDlciFramesWithUnknownSaps=gvcIfDlciFramesWithUnknownSaps, gvcIfDlciSapCircuitRowStatus=gvcIfDlciSapCircuitRowStatus, gvcIfDlciUsageState=gvcIfDlciUsageState, gvcIfDcSapIndex=gvcIfDcSapIndex, gvcIfComponentName=gvcIfComponentName, gvcIfSMacFComponentName=gvcIfSMacFComponentName, gvcIfDnaSdmStorageType=gvcIfDnaSdmStorageType, gvcIfDcCfaTable=gvcIfDcCfaTable, gvcIfDlciLdevMaximumTestRetry=gvcIfDlciLdevMaximumTestRetry, gvcIfProvEntry=gvcIfProvEntry, gvcIfLcnVcFastSelectCall=gvcIfLcnVcFastSelectCall, gvcIfDlciDcRowStatusTable=gvcIfDlciDcRowStatusTable, gvcIfDnaTransferPriorityOverRide=gvcIfDnaTransferPriorityOverRide, gvcIfDlciRdevComponentName=gvcIfDlciRdevComponentName, gvcIfDlciVcPeakRetryQueueSize=gvcIfDlciVcPeakRetryQueueSize, gvcIfDlciDcDiscardPriority=gvcIfDlciDcDiscardPriority, gvcIfLcnRowStatus=gvcIfLcnRowStatus, gvcIfLcnVcIntdEntry=gvcIfLcnVcIntdEntry, gvcIfDnaIncNormalPriorityReverseCharge=gvcIfDnaIncNormalPriorityReverseCharge, gvcIfLcnVcWindowClosuresFromSubnet=gvcIfLcnVcWindowClosuresFromSubnet, generalVcInterfaceCapabilities=generalVcInterfaceCapabilities, gvcIfDnaSdmClearVcsWhenUnreachable=gvcIfDnaSdmClearVcsWhenUnreachable, gvcIfDlciExcessInformationRate=gvcIfDlciExcessInformationRate, gvcIfDnaHgMHgAddrRowStatus=gvcIfDnaHgMHgAddrRowStatus, gvcIfLcnVcCadEntry=gvcIfLcnVcCadEntry, gvcIfDnaDefaultRecvFrmNetworkThruputClass=gvcIfDnaDefaultRecvFrmNetworkThruputClass, gvcIfLcnVcIntdTable=gvcIfLcnVcIntdTable, gvcIfLcnVcRowStatusEntry=gvcIfLcnVcRowStatusEntry, gvcIfDc=gvcIfDc, gvcIfRgLinkToProtocolPort=gvcIfRgLinkToProtocolPort, gvcIfDlciSapCircuit=gvcIfDlciSapCircuit, gvcIfDnaDdmDeviceStatus=gvcIfDnaDdmDeviceStatus, gvcIfDnaDdmLanAdEntry=gvcIfDnaDdmLanAdEntry, gvcIfDMacFIndex=gvcIfDMacFIndex, generalVcInterfaceCapabilitiesBE01=generalVcInterfaceCapabilitiesBE01, gvcIfDlciLdevDmoEntry=gvcIfDlciLdevDmoEntry, gvcIfUsageState=gvcIfUsageState, gvcIfDlciVcFrdTable=gvcIfDlciVcFrdTable, gvcIfDlciStatsEntry=gvcIfDlciStatsEntry, gvcIfDnaIncIntlReverseCharge=gvcIfDnaIncIntlReverseCharge, gvcIfDlciSapCircuitS1SapIndex=gvcIfDlciSapCircuitS1SapIndex, gvcIfLcnDnaMap=gvcIfLcnDnaMap, gvcIfDnaSdmDevOpEntry=gvcIfDnaSdmDevOpEntry, gvcIfDnaHgMHgAddrNumberingPlanIndicator=gvcIfDnaHgMHgAddrNumberingPlanIndicator, gvcIfDlciOperEntry=gvcIfDlciOperEntry, gvcIfDlciVcSendSequenceNumber=gvcIfDlciVcSendSequenceNumber, gvcIfDlciSpMeasurementInterval=gvcIfDlciSpMeasurementInterval, gvcIfDnaDdmRowStatusTable=gvcIfDnaDdmRowStatusTable, gvcIfDlciAbitEntry=gvcIfDlciAbitEntry, gvcIfDnaSdmRowStatusTable=gvcIfDnaSdmRowStatusTable, gvcIfLcnVcPeakOoSeqQueueSize=gvcIfLcnVcPeakOoSeqQueueSize, gvcIfDnaRowStatus=gvcIfDnaRowStatus, gvcIfDnaOutgoingOptionsEntry=gvcIfDnaOutgoingOptionsEntry, gvcIfCallsRefusedByNetwork=gvcIfCallsRefusedByNetwork, gvcIfDlci=gvcIfDlci, gvcIfLcnVcLocalRxWindowSize=gvcIfLcnVcLocalRxWindowSize, gvcIfDlciDcNfaRowStatus=gvcIfDlciDcNfaRowStatus, gvcIfDnaHgMHgAddrRowStatusEntry=gvcIfDnaHgMHgAddrRowStatusEntry, gvcIfAdminState=gvcIfAdminState, gvcIfDnaDdmDevOpTable=gvcIfDnaDdmDevOpTable, gvcIfDnaCugRowStatusEntry=gvcIfDnaCugRowStatusEntry, gvcIfCidDataTable=gvcIfCidDataTable, gvcIfDnaHgMHgAddrAddrTable=gvcIfDnaHgMHgAddrAddrTable, gvcIfDnaDdmIndex=gvcIfDnaDdmIndex, gvcIfLcnVcComponentName=gvcIfLcnVcComponentName, gvcIfDnaDdmSap=gvcIfDnaDdmSap, gvcIfDlciLdevAddrEntry=gvcIfDlciLdevAddrEntry, gvcIfLcnVc=gvcIfLcnVc, gvcIfDlciLdevTestResponseTimer=gvcIfDlciLdevTestResponseTimer, gvcIfDlciRowStatusTable=gvcIfDlciRowStatusTable, gvcIfRgRowStatusTable=gvcIfRgRowStatusTable, gvcIfDlciLdevClearVcsWhenUnreachable=gvcIfDlciLdevClearVcsWhenUnreachable, gvcIfDnaPacketSizeNegotiation=gvcIfDnaPacketSizeNegotiation, gvcIfRgOperStatusTable=gvcIfRgOperStatusTable, gvcIfRgIndex=gvcIfRgIndex, gvcIfDlciDcIndex=gvcIfDlciDcIndex, gvcIfDnaSdmLanAdEntry=gvcIfDnaSdmLanAdEntry, gvcIfDcCfaValue=gvcIfDcCfaValue, gvcIfLcnVcPreviousState=gvcIfLcnVcPreviousState, gvcIfDlciLdevActiveLinkStations=gvcIfDlciLdevActiveLinkStations, gvcIfDlciSpOpEntry=gvcIfDlciSpOpEntry, gvcIfDnaHgMHgAddr=gvcIfDnaHgMHgAddr, gvcIfDMacFFramesMatchingFilter=gvcIfDMacFFramesMatchingFilter, gvcIfDnaDefaultRecvFrmNetworkWindowSize=gvcIfDnaDefaultRecvFrmNetworkWindowSize, gvcIfDlciAdminState=gvcIfDlciAdminState, gvcIfDnaSdmLastTimeUnreachable=gvcIfDnaSdmLastTimeUnreachable, gvcIfSMacFOperEntry=gvcIfSMacFOperEntry, gvcIfDlciSapLocalSapIndex=gvcIfDlciSapLocalSapIndex, gvcIfRDnaMap=gvcIfRDnaMap, gvcIfDlciVcRcosToNetwork=gvcIfDlciVcRcosToNetwork, gvcIfDlciLdevDeviceUnreachable=gvcIfDlciLdevDeviceUnreachable, gvcIfDcRowStatusEntry=gvcIfDcRowStatusEntry, gvcIfRgSnmpOperStatus=gvcIfRgSnmpOperStatus, gvcIfDMacFOperTable=gvcIfDMacFOperTable, gvcIfDlciSapCircuitStorageType=gvcIfDlciSapCircuitStorageType, gvcIfDlciVcCallReferenceNumber=gvcIfDlciVcCallReferenceNumber, gvcIfDnaSdmLanAdTable=gvcIfDnaSdmLanAdTable, gvcIfDnaCugIncCalls=gvcIfDnaCugIncCalls, gvcIfDlciVcOoSeqPktCntExceeded=gvcIfDlciVcOoSeqPktCntExceeded, gvcIfDlciVcElapsedTimeTillNow=gvcIfDlciVcElapsedTimeTillNow, gvcIfDlciVcSubnetRecoveries=gvcIfDlciVcSubnetRecoveries, gvcIfFrSvcOperationalTable=gvcIfFrSvcOperationalTable, gvcIfCallsRefusedByInterface=gvcIfCallsRefusedByInterface, gvcIfDlciStatsTable=gvcIfDlciStatsTable, gvcIfDlciDcRemoteDlci=gvcIfDlciDcRemoteDlci, gvcIfIndex=gvcIfIndex, gvcIfLcnUsageState=gvcIfLcnUsageState, gvcIfDlciVcPeakOoSeqPktCount=gvcIfDlciVcPeakOoSeqPktCount, gvcIfDnaSdmDmoTable=gvcIfDnaSdmDmoTable, gvcIfDlciSp=gvcIfDlciSp, gvcIfDlciRdevIndex=gvcIfDlciRdevIndex, gvcIfDlciVcIntdTable=gvcIfDlciVcIntdTable, gvcIfLcnVcCallingLcn=gvcIfLcnVcCallingLcn, gvcIfDnaDdmDeviceUnreachable=gvcIfDnaDdmDeviceUnreachable, gvcIfDnaDdmClearVcsWhenUnreachable=gvcIfDnaDdmClearVcsWhenUnreachable, gvcIfFrSvcRateEnforcement=gvcIfFrSvcRateEnforcement, gvcIfLcnVcTransferPriorityToNetwork=gvcIfLcnVcTransferPriorityToNetwork, gvcIfDnaDdmActiveLinkStations=gvcIfDnaDdmActiveLinkStations, gvcIfDlciVcOutOfRangeFrmFromSubnet=gvcIfDlciVcOutOfRangeFrmFromSubnet, gvcIfDlciDcOptionsTable=gvcIfDlciDcOptionsTable, gvcIfDlciStorageType=gvcIfDlciStorageType, gvcIfRDnaMapComponentName=gvcIfRDnaMapComponentName, gvcIfLcnVcFrmRetryTimeouts=gvcIfLcnVcFrmRetryTimeouts, gvcIfDcDiscardPriority=gvcIfDcDiscardPriority, gvcIfDlciBnnRowStatusEntry=gvcIfDlciBnnRowStatusEntry, gvcIfFrSvcRowStatusTable=gvcIfFrSvcRowStatusTable, gvcIfLcn=gvcIfLcn, gvcIfRDnaMapMac=gvcIfRDnaMapMac, gvcIfDnaDataNetworkAddress=gvcIfDnaDataNetworkAddress, gvcIfDnaCugCugOptionsTable=gvcIfDnaCugCugOptionsTable, gvcIfDlciVcDmepValue=gvcIfDlciVcDmepValue, gvcIfDlciRemoteDeviceMac=gvcIfDlciRemoteDeviceMac, gvcIfDnaHgMHgAddrComponentName=gvcIfDnaHgMHgAddrComponentName, gvcIfDcMacIndex=gvcIfDcMacIndex, gvcIfDnaCugCugOptionsEntry=gvcIfDnaCugCugOptionsEntry, gvcIfDlciRdevMac=gvcIfDlciRdevMac, gvcIfDnaRowStatusTable=gvcIfDnaRowStatusTable, gvcIfDlciSpRowStatus=gvcIfDlciSpRowStatus, gvcIfDnaIncHighPriorityReverseCharge=gvcIfDnaIncHighPriorityReverseCharge, gvcIfDnaCugOutCalls=gvcIfDnaCugOutCalls, gvcIfPeakActiveLinkStations=gvcIfPeakActiveLinkStations, gvcIfDnaCugRowStatus=gvcIfDnaCugRowStatus, gvcIfLcnVcElapsedTimeTillNow=gvcIfLcnVcElapsedTimeTillNow, gvcIfLcnLcnCIdTable=gvcIfLcnLcnCIdTable, gvcIfBcastFramesDiscarded=gvcIfBcastFramesDiscarded, gvcIfDnaDdmDevOpEntry=gvcIfDnaDdmDevOpEntry, gvcIfActiveQllcCalls=gvcIfActiveQllcCalls, gvcIfDnaDdmLastTimeReachable=gvcIfDnaDdmLastTimeReachable, gvcIfFrSvcProvisionedTable=gvcIfFrSvcProvisionedTable, gvcIfLcnVcOutOfRangeFrmFromSubnet=gvcIfLcnVcOutOfRangeFrmFromSubnet, gvcIfDlciABitStatusFromNetwork=gvcIfDlciABitStatusFromNetwork, gvcIfRDnaMapRowStatusTable=gvcIfRDnaMapRowStatusTable, gvcIfDnaCugDnic=gvcIfDnaCugDnic, gvcIfLcnVcPeakOoSeqFrmForwarded=gvcIfLcnVcPeakOoSeqFrmForwarded)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-GeneralVcInterfaceMIB", gvcIfDlciSpCommittedBurstSize=gvcIfDlciSpCommittedBurstSize, gvcIfLcnVcCalledDna=gvcIfLcnVcCalledDna, gvcIfDnaHgMHgAddrStorageType=gvcIfDnaHgMHgAddrStorageType, generalVcInterfaceGroup=generalVcInterfaceGroup, gvcIfLcnVcCallingDna=gvcIfLcnVcCallingDna, gvcIfDnaOutAccess=gvcIfDnaOutAccess, gvcIfDlciVcStartTime=gvcIfDlciVcStartTime, gvcIfLcnAdminState=gvcIfLcnAdminState, gvcIfRg=gvcIfRg, gvcIfDlciCommittedInformationRate=gvcIfDlciCommittedInformationRate, gvcIfLcnVcDiagnosticCode=gvcIfLcnVcDiagnosticCode, gvcIfDnaRowStatusEntry=gvcIfDnaRowStatusEntry, gvcIfLogicalProcessor=gvcIfLogicalProcessor, gvcIfDlciVcCombErrorsFromSubnet=gvcIfDlciVcCombErrorsFromSubnet, gvcIfDlciDcRowStatus=gvcIfDlciDcRowStatus, gvcIfLcnVcSubnetRxWindowSize=gvcIfLcnVcSubnetRxWindowSize, gvcIfDlciBnnRowStatusTable=gvcIfDlciBnnRowStatusTable, gvcIfDcRowStatusTable=gvcIfDcRowStatusTable, gvcIfLcnVcAccountingEnd=gvcIfLcnVcAccountingEnd, gvcIfDMacFStorageType=gvcIfDMacFStorageType, gvcIfDlciSapRowStatusTable=gvcIfDlciSapRowStatusTable, gvcIfLcnVcPriority=gvcIfLcnVcPriority, gvcIfFrSvcStorageType=gvcIfFrSvcStorageType, gvcIfDcComponentName=gvcIfDcComponentName, gvcIfDnaSdmDevOpTable=gvcIfDnaSdmDevOpTable, gvcIfDlciAbitTable=gvcIfDlciAbitTable, gvcIfFrSvc=gvcIfFrSvc, gvcIfDnaDdmLanAdTable=gvcIfDnaDdmLanAdTable, gvcIfSMacFRowStatus=gvcIfSMacFRowStatus, gvcIfDlciLdevDeviceStatus=gvcIfDlciLdevDeviceStatus, gvcIfFrSvcRowStatus=gvcIfFrSvcRowStatus, gvcIfDlciVcDiagnosticCode=gvcIfDlciVcDiagnosticCode, gvcIfDnaDdmTestResponseTimer=gvcIfDnaDdmTestResponseTimer, gvcIfDMacF=gvcIfDMacF, gvcIfDnaCallOptionsEntry=gvcIfDnaCallOptionsEntry, gvcIfDnaSdmMonitoringLcn=gvcIfDnaSdmMonitoringLcn, gvcIfDnaServiceExchange=gvcIfDnaServiceExchange, gvcIfRDnaMapSap=gvcIfRDnaMapSap, gvcIfDlciLdevRowStatusEntry=gvcIfDlciLdevRowStatusEntry, gvcIfDnaNumberingPlanIndicator=gvcIfDnaNumberingPlanIndicator, gvcIfOpEntry=gvcIfOpEntry, gvcIfRowStatus=gvcIfRowStatus, gvcIfLcnLcnCIdEntry=gvcIfLcnLcnCIdEntry, gvcIfDnaAccountClass=gvcIfDnaAccountClass, gvcIfDlciDcRemoteDna=gvcIfDlciDcRemoteDna, gvcIfDlciRdevRowStatusTable=gvcIfDlciRdevRowStatusTable, gvcIfLcnVcStatsEntry=gvcIfLcnVcStatsEntry, gvcIfStateEntry=gvcIfStateEntry, gvcIfLcnVcStartTime=gvcIfLcnVcStartTime, gvcIfDlciVcCallingNpi=gvcIfDlciVcCallingNpi, gvcIfDnaOutDefaultPathReliability=gvcIfDnaOutDefaultPathReliability, gvcIfStateTable=gvcIfStateTable, gvcIfDlciLdevIndex=gvcIfDlciLdevIndex, gvcIfRDnaMapDnaIndex=gvcIfRDnaMapDnaIndex, gvcIfDlciVcType=gvcIfDlciVcType, gvcIfLcnCircuitId=gvcIfLcnCircuitId, gvcIfDlciVcFastSelectCall=gvcIfDlciVcFastSelectCall, gvcIfDnaSdmDeviceMonitoringTimer=gvcIfDnaSdmDeviceMonitoringTimer, gvcIfDnaDdmMac=gvcIfDnaDdmMac, gvcIfDnaDdmDmoTable=gvcIfDnaDdmDmoTable, gvcIfDlciDcType=gvcIfDlciDcType, gvcIfDlciBnnRowStatus=gvcIfDlciBnnRowStatus, gvcIfStatsEntry=gvcIfStatsEntry, gvcIfDnaHgMHgAddrDataNetworkAddress=gvcIfDnaHgMHgAddrDataNetworkAddress, gvcIfDnaIncSameService=gvcIfDnaIncSameService, gvcIfDnaOutDefaultPathSensitivity=gvcIfDnaOutDefaultPathSensitivity, gvcIfDlciVcMaxSubnetPktSize=gvcIfDlciVcMaxSubnetPktSize, gvcIfDcUserData=gvcIfDcUserData, gvcIfDcTransferPriority=gvcIfDcTransferPriority, gvcIfDnaDefaultSendToNetworkThruputClass=gvcIfDnaDefaultSendToNetworkThruputClass, gvcIfDnaHgMHgAddrRowStatusTable=gvcIfDnaHgMHgAddrRowStatusTable, gvcIfDcRemoteNpi=gvcIfDcRemoteNpi, gvcIfDnaDdmDeviceMonitoringTimer=gvcIfDnaDdmDeviceMonitoringTimer, gvcIfDlciVcPreviousDiagnosticCode=gvcIfDlciVcPreviousDiagnosticCode, gvcIfDlciVcFrmCongestedToSubnet=gvcIfDlciVcFrmCongestedToSubnet, gvcIfDlciSpParmsTable=gvcIfDlciSpParmsTable, gvcIfDlciVcAccountingEnabled=gvcIfDlciVcAccountingEnabled, gvcIfDlciVcAccountingEnd=gvcIfDlciVcAccountingEnd, gvcIfCallsToNetwork=gvcIfCallsToNetwork, gvcIfDlciExcessBurstSize=gvcIfDlciExcessBurstSize, gvcIfDlciVcEmissionPriorityToNetwork=gvcIfDlciVcEmissionPriorityToNetwork, gvcIfDna=gvcIfDna, gvcIfRDnaMapLanAdTable=gvcIfRDnaMapLanAdTable, gvcIfDnaAccountCollection=gvcIfDnaAccountCollection, gvcIfLcnVcSegmentSize=gvcIfLcnVcSegmentSize, gvcIfRgIfAdminStatus=gvcIfRgIfAdminStatus, gvcIfDlciVcPktRetryTimeouts=gvcIfDlciVcPktRetryTimeouts, gvcIfDlciVcFrdEntry=gvcIfDlciVcFrdEntry, gvcIfDlciLdevMonitoringLcn=gvcIfDlciLdevMonitoringLcn, gvcIfDnaIndex=gvcIfDnaIndex, gvcIfDnaCugStorageType=gvcIfDnaCugStorageType, gvcIfSMacFRowStatusTable=gvcIfSMacFRowStatusTable, gvcIfLcnOperationalState=gvcIfLcnOperationalState, gvcIfDlciSapRemoteSapIndex=gvcIfDlciSapRemoteSapIndex, gvcIfLcnRowStatusEntry=gvcIfLcnRowStatusEntry, gvcIfDlciSapRowStatusEntry=gvcIfDlciSapRowStatusEntry, gvcIfRDnaMapNpiIndex=gvcIfRDnaMapNpiIndex, gvcIfDlciRateEnforcement=gvcIfDlciRateEnforcement, gvcIfDlciSapComponentName=gvcIfDlciSapComponentName, gvcIfLcnVcWindowClosuresToSubnet=gvcIfLcnVcWindowClosuresToSubnet, gvcIfLcnVcState=gvcIfLcnVcState, gvcIfDlciVcComponentName=gvcIfDlciVcComponentName, gvcIfDlciLdevDmoTable=gvcIfDlciLdevDmoTable, gvcIfDlciVcPeakOoSeqByteCount=gvcIfDlciVcPeakOoSeqByteCount, generalVcInterfaceCapabilitiesBE01A=generalVcInterfaceCapabilitiesBE01A, gvcIfDnaCugIndex=gvcIfDnaCugIndex, gvcIfFrSvcIndex=gvcIfFrSvcIndex, gvcIfSMacFRowStatusEntry=gvcIfSMacFRowStatusEntry, gvcIfDlciRowStatusEntry=gvcIfDlciRowStatusEntry, gvcIfDnaDefaultSendToNetworkWindowSize=gvcIfDnaDefaultSendToNetworkWindowSize, gvcIfDlciDcOptionsEntry=gvcIfDlciDcOptionsEntry, gvcIfDlciVcStorageType=gvcIfDlciVcStorageType, gvcIfDnaSdmRowStatus=gvcIfDnaSdmRowStatus, gvcIfDnaIncAccess=gvcIfDnaIncAccess, gvcIfDlciVcDmepTable=gvcIfDlciVcDmepTable, gvcIfDlciLdevDevOpTable=gvcIfDlciLdevDevOpTable, gvcIfDlciLdevLastTimeReachable=gvcIfDlciLdevLastTimeReachable, gvcIfDnaCallOptionsTable=gvcIfDnaCallOptionsTable, gvcIfDnaDdmDeviceMonitoring=gvcIfDnaDdmDeviceMonitoring, gvcIfDnaCugFormat=gvcIfDnaCugFormat, gvcIfRgComponentName=gvcIfRgComponentName, gvcIfDlciBnnComponentName=gvcIfDlciBnnComponentName, gvcIfDnaOutDefaultPriority=gvcIfDnaOutDefaultPriority, gvcIfDnaSdmActiveLinkStations=gvcIfDnaSdmActiveLinkStations, generalVcInterfaceGroupBE=generalVcInterfaceGroupBE, gvcIfDlciDcTransferPriority=gvcIfDlciDcTransferPriority, gvcIfDnaSdmMaximumTestRetry=gvcIfDnaSdmMaximumTestRetry, generalVcInterfaceMIB=generalVcInterfaceMIB, gvcIfDnaHgMRowStatusEntry=gvcIfDnaHgMRowStatusEntry, gvcIfDnaSdmMac=gvcIfDnaSdmMac, gvcIfDnaIncIntlNormalCharge=gvcIfDnaIncIntlNormalCharge, gvcIfDlciEncapsulationType=gvcIfDlciEncapsulationType, gvcIfDlciDcNfaTable=gvcIfDlciDcNfaTable, gvcIfLcnStateEntry=gvcIfLcnStateEntry, gvcIfDlciRdevStorageType=gvcIfDlciRdevStorageType, gvcIfLcnVcCalledNpi=gvcIfLcnVcCalledNpi, gvcIfDnaSdmIndex=gvcIfDnaSdmIndex, gvcIfLcnVcTransferPriorityFromNetwork=gvcIfLcnVcTransferPriorityFromNetwork, gvcIfLcnState=gvcIfLcnState, gvcIfLcnVcPeakStackedAcksRx=gvcIfLcnVcPeakStackedAcksRx, gvcIfDlciSapCircuitS1MacIndex=gvcIfDlciSapCircuitS1MacIndex, gvcIfLcnSourceMac=gvcIfLcnSourceMac, gvcIfDnaServiceCategory=gvcIfDnaServiceCategory, gvcIfOpTable=gvcIfOpTable, gvcIfRgRowStatus=gvcIfRgRowStatus, gvcIfDlciBnnIndex=gvcIfDlciBnnIndex, gvcIfDnaDdmRowStatus=gvcIfDnaDdmRowStatus, gvcIfDlciLdev=gvcIfDlciLdev, gvcIfProvTable=gvcIfProvTable, gvcIfDnaSdmSap=gvcIfDnaSdmSap, gvcIfLcnVcCadTable=gvcIfLcnVcCadTable, gvcIfSMacF=gvcIfSMacF, gvcIfStatsTable=gvcIfStatsTable, gvcIfDlciVcOoSeqByteCntExceeded=gvcIfDlciVcOoSeqByteCntExceeded, gvcIfDlciVcSegmentsSent=gvcIfDlciVcSegmentsSent, gvcIfDnaDdmMaximumTestRetry=gvcIfDnaDdmMaximumTestRetry, gvcIfLcnComponentName=gvcIfLcnComponentName, gvcIfDlciVcCallingLcn=gvcIfDlciVcCallingLcn, gvcIfDlciDcComponentName=gvcIfDlciDcComponentName, gvcIfDnaSdmTestResponseTimer=gvcIfDnaSdmTestResponseTimer, gvcIfDlciVcRcosFromNetwork=gvcIfDlciVcRcosFromNetwork, gvcIfDlciVcIntdEntry=gvcIfDlciVcIntdEntry, gvcIfDlciDc=gvcIfDlciDc, gvcIfDnaSdm=gvcIfDnaSdm, gvcIfDlciVcPriority=gvcIfDlciVcPriority, gvcIfLcnIndex=gvcIfLcnIndex, gvcIfLcnVcRowStatusTable=gvcIfLcnVcRowStatusTable, gvcIfDlciSpExcessBurstSize=gvcIfDlciSpExcessBurstSize, gvcIfLcnVcStatsTable=gvcIfLcnVcStatsTable, gvcIfDlciVcDataPath=gvcIfDlciVcDataPath, gvcIfLcnStorageType=gvcIfLcnStorageType, gvcIfRgIfIndex=gvcIfRgIfIndex, gvcIfActiveLinkStations=gvcIfActiveLinkStations, gvcIfDlciVcRowStatusEntry=gvcIfDlciVcRowStatusEntry, gvcIfDlciSapRowStatus=gvcIfDlciSapRowStatus, gvcIfDnaHgMRowStatus=gvcIfDnaHgMRowStatus, gvcIfDlciSapCircuitRowStatusTable=gvcIfDlciSapCircuitRowStatusTable, gvcIfDlciDcNfaEntry=gvcIfDlciDcNfaEntry, gvcIfDlciVcDuplicatesFromSubnet=gvcIfDlciVcDuplicatesFromSubnet, gvcIfRDnaMapStorageType=gvcIfRDnaMapStorageType, gvcIfDlciSpRowStatusTable=gvcIfDlciSpRowStatusTable, gvcIfDnaSdmRowStatusEntry=gvcIfDnaSdmRowStatusEntry, gvcIfDlciVcIndex=gvcIfDlciVcIndex, gvcIfDMacFComponentName=gvcIfDMacFComponentName, gvcIfDlciABitStatusToNetwork=gvcIfDlciABitStatusToNetwork, gvcIfDlciRdevRowStatusEntry=gvcIfDlciRdevRowStatusEntry, gvcIfDlciLdevLastTimeUnreachable=gvcIfDlciLdevLastTimeUnreachable, gvcIfRgOperStatusEntry=gvcIfRgOperStatusEntry, gvcIfLcnOperEntry=gvcIfLcnOperEntry, gvcIfDlciFrmDiscardToNetwork=gvcIfDlciFrmDiscardToNetwork, gvcIfDnaHgMHgAddrIndex=gvcIfDnaHgMHgAddrIndex, gvcIfDnaDdmMonitoringLcn=gvcIfDnaDdmMonitoringLcn, gvcIfDlciDcStorageType=gvcIfDlciDcStorageType, gvcIfDMacFRowStatus=gvcIfDMacFRowStatus, gvcIfLcnVcCallReferenceNumber=gvcIfLcnVcCallReferenceNumber, gvcIfDlciSpIndex=gvcIfDlciSpIndex, gvcIfDlciSpRowStatusEntry=gvcIfDlciSpRowStatusEntry, gvcIfLcnVcSubnetTxWindowSize=gvcIfLcnVcSubnetTxWindowSize, gvcIfDlciVcCalledNpi=gvcIfDlciVcCalledNpi, gvcIfDnaHgMRowStatusTable=gvcIfDnaHgMRowStatusTable, gvcIfDlciSapCircuitS2SapIndex=gvcIfDlciSapCircuitS2SapIndex, gvcIfMaxActiveLinkStation=gvcIfMaxActiveLinkStation, gvcIfDlciSpOpTable=gvcIfDlciSpOpTable, gvcIfDnaHgMAvailableLinkStations=gvcIfDnaHgMAvailableLinkStations, gvcIfDcStorageType=gvcIfDcStorageType, gvcIfLcnVcAccountingEnabled=gvcIfLcnVcAccountingEnabled, gvcIfDlciSapCircuitRowStatusEntry=gvcIfDlciSapCircuitRowStatusEntry, gvcIfFrSvcOperationalEntry=gvcIfFrSvcOperationalEntry, gvcIfDlciDcRemoteNpi=gvcIfDlciDcRemoteNpi, gvcIfLcnVcType=gvcIfLcnVcType, gvcIfDnaSdmDeviceStatus=gvcIfDnaSdmDeviceStatus, gvcIfDnaCugType=gvcIfDnaCugType, gvcIfDlciSapStorageType=gvcIfDlciSapStorageType, gvcIfDnaHgMIfTable=gvcIfDnaHgMIfTable, gvcIfDlciVcRowStatusTable=gvcIfDlciVcRowStatusTable, gvcIfDnaCugPrivileged=gvcIfDnaCugPrivileged, gvcIfDnaDdmComponentName=gvcIfDnaDdmComponentName, gvcIfDlciRdevRowStatus=gvcIfDlciRdevRowStatus, gvcIfDnaHgMStorageType=gvcIfDnaHgMStorageType, gvcIfDnaAddrEntry=gvcIfDnaAddrEntry, gvcIfDlciVcSegmentSize=gvcIfDlciVcSegmentSize, gvcIfDlciLdevStorageType=gvcIfDlciLdevStorageType, gvcIfDlciCommittedBurstSize=gvcIfDlciCommittedBurstSize, gvcIfDlciVcPreviousState=gvcIfDlciVcPreviousState, gvcIfFrSvcProvisionedEntry=gvcIfFrSvcProvisionedEntry, gvcIfDlciSap=gvcIfDlciSap, gvcIfDlciFrmFromNetwork=gvcIfDlciFrmFromNetwork, gvcIfDlciLdevDevOpEntry=gvcIfDlciLdevDevOpEntry, gvcIfDlciVcCannotForwardToSubnet=gvcIfDlciVcCannotForwardToSubnet, gvcIfDnaIncomingOptionsTable=gvcIfDnaIncomingOptionsTable, gvcIfDnaHgMIndex=gvcIfDnaHgMIndex, gvcIfRgProvTable=gvcIfRgProvTable, gvcIfDnaStorageType=gvcIfDnaStorageType, gvcIfRgRowStatusEntry=gvcIfRgRowStatusEntry, gvcIfDnaHgMIfEntry=gvcIfDnaHgMIfEntry, gvcIfDlciLdevDeviceMonitoring=gvcIfDlciLdevDeviceMonitoring, gvcIfSMacFStorageType=gvcIfSMacFStorageType, gvcIfLcnVcStorageType=gvcIfLcnVcStorageType, gvcIfDlciDcNfaValue=gvcIfDlciDcNfaValue, gvcIfRowStatusEntry=gvcIfRowStatusEntry, gvcIfRDnaMapRowStatus=gvcIfRDnaMapRowStatus, gvcIfDlciSpComponentName=gvcIfDlciSpComponentName, gvcIfFrSvcMaximumFrameRelaySvcs=gvcIfFrSvcMaximumFrameRelaySvcs, gvcIfStorageType=gvcIfStorageType, gvcIfCustomerIdentifier=gvcIfCustomerIdentifier, gvcIfDcCfaRowStatus=gvcIfDcCfaRowStatus, gvcIfDlciMeasurementInterval=gvcIfDlciMeasurementInterval, gvcIfDnaHgMOpEntry=gvcIfDnaHgMOpEntry, gvcIfDlciVcDmepEntry=gvcIfDlciVcDmepEntry, gvcIfDlciRdev=gvcIfDlciRdev, gvcIfDnaAddrTable=gvcIfDnaAddrTable, gvcIfDcRemoteDna=gvcIfDcRemoteDna, gvcIfCidDataEntry=gvcIfCidDataEntry, gvcIfLcnVcLocalTxWindowSize=gvcIfLcnVcLocalTxWindowSize)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-GeneralVcInterfaceMIB", gvcIfDnaSdmLastTimeReachable=gvcIfDnaSdmLastTimeReachable, gvcIfDlciVcRowStatus=gvcIfDlciVcRowStatus, gvcIfDlciVcCalledLcn=gvcIfDlciVcCalledLcn, gvcIfDlciVcCalledDna=gvcIfDlciVcCalledDna, gvcIfDlciIndex=gvcIfDlciIndex, gvcIfDnaSdmComponentName=gvcIfDnaSdmComponentName, gvcIfDnaSdmDeviceUnreachable=gvcIfDnaSdmDeviceUnreachable, gvcIfLcnVcRowStatus=gvcIfLcnVcRowStatus, gvcIfSMacFFramesMatchingFilter=gvcIfSMacFFramesMatchingFilter, gvcIfLcnVcPreviousDiagnosticCode=gvcIfLcnVcPreviousDiagnosticCode, gvcIfFrSvcCurrentNumberOfSvcCalls=gvcIfFrSvcCurrentNumberOfSvcCalls, gvcIfDnaHgMAvailabilityDelta=gvcIfDnaHgMAvailabilityDelta, gvcIfLcnVcPathReliability=gvcIfLcnVcPathReliability, gvcIfDnaDdmLastTimeUnreachable=gvcIfDnaDdmLastTimeUnreachable, gvcIfFrSvcComponentName=gvcIfFrSvcComponentName, gvcIfDlciVcCallingDna=gvcIfDlciVcCallingDna, gvcIfDnaCug=gvcIfDnaCug, gvcIfDnaDefaultSendToNetworkPacketSize=gvcIfDnaDefaultSendToNetworkPacketSize, gvcIfDlciSapCircuitS2MacIndex=gvcIfDlciSapCircuitS2MacIndex, gvcIfLcnVcCallingNpi=gvcIfLcnVcCallingNpi, generalVcInterfaceGroupBE01A=generalVcInterfaceGroupBE01A, gvcIfDnaPacketSizes=gvcIfDnaPacketSizes, gvcIfDnaHgMOpTable=gvcIfDnaHgMOpTable, gvcIfDlciLdevRowStatus=gvcIfDlciLdevRowStatus, gvcIfDnaDdmStorageType=gvcIfDnaDdmStorageType)

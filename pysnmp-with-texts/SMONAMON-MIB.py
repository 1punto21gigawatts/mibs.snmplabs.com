#
# PySNMP MIB module SMONAMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SMONAMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:07:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
smon, = mibBuilder.importSymbols("APPLIC-MIB", "smon")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter32, Counter64, ModuleIdentity, Bits, TimeTicks, Gauge32, ObjectIdentity, NotificationType, IpAddress, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter32", "Counter64", "ModuleIdentity", "Bits", "TimeTicks", "Gauge32", "ObjectIdentity", "NotificationType", "IpAddress", "Integer32", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
smonamon = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 5))
amonSlotStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 5, 1))
amonSlotStatsTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1), )
if mibBuilder.loadTexts: amonSlotStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotStatsTable.setDescription('A list of slot entries. Each entry contains statistical data pertaining to a single slot on the ATM switch. An entry is maintained at all times for each of the slots that exist in the hub. The table is automatically updated for hot-swappable slots that are added to or removed from the switch. ')
amonSlotStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: amonSlotStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotStatsEntry.setDescription('A collection of statistics for a particular slot. A slot is defined according to the ifIndex of the CPU: ifIndex = Slot*1024 + 1')
amonSlotInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotInCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotInCells.setDescription('The total number of ATM cells (including bad HEC cells and cells dropped by the switch) which were received by the slot.')
amonSlotBadHecCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotBadHecCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotBadHecCells.setDescription('The total number of bad HEC cells received by the slot.')
amonSlotDroppedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotDroppedCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotDroppedCells.setDescription('The total number of cells dropped by the slot due to congestion conditions in the switching fabric.')
amonSlotUbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotUbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotUbrCells.setDescription('The total number of good ATM cells received by the slot using the UBR service.')
amonSlotAbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotAbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotAbrCells.setDescription('The total number of good ATM cells received by the slot using the ABR service.')
amonSlotNrtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotNrtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotNrtVbrCells.setDescription('The total number of good ATM cells received by the slot using the non real-time VBR service.')
amonSlotRtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotRtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotRtVbrCells.setDescription('The total number of good ATM cells received by the slot using the real-time VBR service.')
amonSlotCbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotCbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotCbrCells.setDescription('The total number of good ATM cells received by the slot using the CBR service.')
amonSlotPnniCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotPnniCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotPnniCells.setDescription('The total number of good cells received by the slot on PNNI connections.')
amonSlotSignalingCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotSignalingCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotSignalingCells.setDescription('The total number of good cells received by the slot on signalling connections.')
amonSlotLaneCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotLaneCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotLaneCells.setDescription('The total number of good LANE cells switched by the switch.')
amonSlotLaneDataDirectCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotLaneDataDirectCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotLaneDataDirectCells.setDescription('The total number of good cells received by the switch on LANE data direct connections.')
amonSlotLaneMulticastCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotLaneMulticastCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotLaneMulticastCells.setDescription('The total number of good cells received by the switch to LANE BUSes.')
amonSlotLaneConfigControlCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotLaneConfigControlCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotLaneConfigControlCells.setDescription('The total number of good cells received by the switch on LANE configuration and control connections.')
amonSlotDefinityCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotDefinityCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotDefinityCells.setDescription('The total number of good cells received by the switch on Definity PBX connections.')
amonSlotTotalBwAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotTotalBwAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotTotalBwAllocated.setDescription('The total amount of bandwidth allocated by the switch, in Kbps.')
amonSlotAbrBwAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotAbrBwAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotAbrBwAllocated.setDescription('The total amount of bandwidth allocated by the switch for ABR traffic, in Kbps.')
amonSlotNrtVbrBwAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotNrtVbrBwAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotNrtVbrBwAllocated.setDescription('The total amount of bandwidth allocated by the switch for non real-time VBR traffic, in Kbps.')
amonSlotRtVbrBwAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotRtVbrBwAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotRtVbrBwAllocated.setDescription('The total amount of bandwidth allocated by the switch for real-time VBR traffic, in Kbps.')
amonSlotCbrBwAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonSlotCbrBwAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: amonSlotCbrBwAllocated.setDescription('The total amount of bandwidth allocated by the switch for CBR traffic, in Kbps.')
amonPortStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 5, 2))
amonPortStatsTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1), )
if mibBuilder.loadTexts: amonPortStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortStatsTable.setDescription('A list of port entries. Each entry contains statistical data pertaining to a single physical port on the ATM switch. An entry is maintained at all times for each of the ports that exist in the hub. The table is automatically updated for hot-swappable ports that are added to or removed from the switch. ')
amonPortStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: amonPortStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortStatsEntry.setDescription('A collection of statistics for a particular port. A port is defined according to the ifIndex of the ATM Layer including CPU ifIndex = Slot*1024 + P*2 + 2, CPU: S*1024 + 1')
amonPortInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInCells.setDescription('The number of ATM cells -including bad HEC cells- received by the switch via this port.')
amonPortOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortOutCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortOutCells.setDescription('The number of ATM cells -including bad HEC cells- transmitted by the switch via this port.')
amonPortInBadHecCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInBadHecCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInBadHecCells.setDescription('The number of bad HEC cells received by the switch through this port.')
amonPortInUbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInUbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInUbrCells.setDescription('The number of good ATM cells received by the switch via this port using the UBR service.')
amonPortInAbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInAbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInAbrCells.setDescription('The number of good ATM cells received by the switch via this port using the ABR service.')
amonPortInNrtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInNrtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInNrtVbrCells.setDescription('The number of good ATM cells received by the switch via this port using the non real-time VBR service.')
amonPortInRtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInRtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInRtVbrCells.setDescription('The number of good ATM cells received by the switch via this port using the real-time VBR service.')
amonPortInCbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInCbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInCbrCells.setDescription('The number of good ATM cells received by the switch via this port using the CBR service.')
amonPortInPointToPointCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInPointToPointCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInPointToPointCells.setDescription('The number of good ATM cells received by the switch via this port on point to point connections.')
amonPortInPointToMultipointCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInPointToMultipointCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInPointToMultipointCells.setDescription('The number of good ATM cells received by the switch via this port on point to multipoint connections.')
amonPortInPnniCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInPnniCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInPnniCells.setDescription('The number of good cells received by the switch via this port on connections used for PNNI.')
amonPortInSignalingCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInSignalingCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInSignalingCells.setDescription('The number of good cells received by the switch via this port on connections used for signaling.')
amonPortInLaneDataDirectCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInLaneDataDirectCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInLaneDataDirectCells.setDescription('The number of good cells received by the switch via this port on LANE data direct connections.')
amonPortInLaneMulticastCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortInLaneMulticastCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortInLaneMulticastCells.setDescription('The number of good cells received by the switch via this port on LANE multicast connections.')
amonPortLaneConfigControlCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortLaneConfigControlCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortLaneConfigControlCells.setDescription('The number of good cells received by the switch via this port on LANE configuration and control connections.')
amonPortDefinityCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonPortDefinityCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonPortDefinityCells.setDescription('The number of good cells received by the switch via this port on Definity PBX connections.')
amonHostStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 5, 3))
amonHostTimeTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1), )
if mibBuilder.loadTexts: amonHostTimeTable.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeTable.setDescription("A list of ATM host time entries. Each entry contains statistical data pertaining to a single ATM host communicating via the switch. The table is activated by the RMON hostControlTable. The table is indexed by the RMON MIB's hostTimeIndex (Which will be used as Slot Index) and by amonHostTimeCreationOrder.")
amonHostTimeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1), ).setIndexNames((0, "SMONAMON-MIB", "amonHostTimeIndex"), (0, "SMONAMON-MIB", "amonHostTimeCreationOrder"))
if mibBuilder.loadTexts: amonHostTimeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeEntry.setDescription('A collection of statistics for a particular ATM host.')
amonHostTimeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeAddress.setDescription('The ATM address of this host.')
amonHostTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeIndex.setDescription('The set of collected host statistics of which this entry is a part. The set of hosts identified by a particular value of this index is associated with the hostControlEntry as identified by the same value of hostControlIndex. This is the Slot Number.')
amonHostTimeCreationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeCreationOrder.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeCreationOrder.setDescription('An index that uniquely identifies an entry in the atmHostTime table among those entries associated with the same hostControlEntry. This index shall be between 1 and N, where N is the value of the associated hostControlTableSize. The ordering of the indexes is based on the order of each entry-s insertion into the table, in which entries added earlier have a lower index value than entries added later. Thus the management station has the ability to learn of new entries added to this table without downloading the entire table.')
amonHostTimeOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutCells.setDescription('The number of ATM cells -including bad HEC cells- transmitted by this host via the switch.')
amonHostTimeOutUbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutUbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutUbrCells.setDescription('The number of good ATM cells transmitted by the host via the switch using the UBR service.')
amonHostTimeOutAbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutAbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutAbrCells.setDescription('The number of good ATM cells transmitted by the host via the switch using the ABR service.')
amonHostTimeOutNrtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutNrtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutNrtVbrCells.setDescription('The number of good ATM cells transmitted by the host via the switch using the non real-time VBR service.')
amonHostTimeOutRtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutRtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutRtVbrCells.setDescription('The number of good ATM cells transmitted by the host via the switch using the real-time VBR service.')
amonHostTimeOutCbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutCbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutCbrCells.setDescription('The number of good ATM cells transmitted by the host via the switch using the CBR service.')
amonHostTimeOutLaneCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutLaneCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutLaneCells.setDescription('The total number of good LANE cells transmitted by this host on VCs handled by the switch.')
amonHostTimeOutLaneDataDirectCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutLaneDataDirectCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutLaneDataDirectCells.setDescription('The number of good cells transmitted by this host on LANE data direct VCs handled by the switch.')
amonHostTimeOutLaneMulticastCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutLaneMulticastCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutLaneMulticastCells.setDescription('The number of good cells transmitted by this host on LANE multicast VCs handled by the switch.')
amonHostTimeOutLaneConfigControlCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutLaneConfigControlCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutLaneConfigControlCells.setDescription('The number of good cells transmitted by this host on LANE configuration and control VCs handled by the switch.')
amonHostTimeOutDefinityCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonHostTimeOutDefinityCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonHostTimeOutDefinityCells.setDescription('The number of good cells transmitted by this host on Definity PBX VCs handled by the switch.')
amonHostMatrix = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 5, 4))
amonMatrixTimeTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1), )
if mibBuilder.loadTexts: amonMatrixTimeTable.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeTable.setDescription('A list of ATM matrix entries (source and destination ATM NSAP address). The table is activated by the RMON matrixControlTable. The table is indexed by the amonMatrixTimeIndex (Which will be used as Slot Index) and by amonMatrixTimeCreationOrder.')
amonMatrixTimeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1), ).setIndexNames((0, "SMONAMON-MIB", "amonMatrixTimeIndex"), (0, "SMONAMON-MIB", "amonMatrixTimeCreationOrder"))
if mibBuilder.loadTexts: amonMatrixTimeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeEntry.setDescription('A collection of statistics for communications between two ATM NSAP addresses on the switch. This table is created by the RMON MIB matrix control table.')
amonMatrixTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeIndex.setDescription(' The set of collected matrix statistics of which this entry is a part. The set of matrix statistics identified by a particular value of this index is associated with the same matrixControlEntry as identified by the same value of matrixControlIndex. This is the Slot Number.')
amonMatrixTimeCreationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeCreationOrder.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeCreationOrder.setDescription('An index that uniquely identifies an entry in the amonMatrixTimeTable among those entries associated with the same matrixControlEntry. This index shall be between 1 and N, where N is the value of the associated matrixControlTableSize. The ordering of the indexes is based on the order of each entry-s insertion into the table, in which entries added earlier have a lower index value than entries added later. Thus the management station has the ability to learn of new entries added to this table without downloading the entire table.')
amonMatrixTimeSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeSourceAddress.setDescription(' The source ATM NSAP address.')
amonMatrixTimeDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeDestAddress.setDescription(' The destination ATM NSAP address.')
amonMatrixTimeCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeCells.setDescription(' The number of cells transmitted from the source address to the destination address.')
amonMatrixTimeUbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeUbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeUbrCells.setDescription(' The number of cells transmitted from the source address to the destination address via the switch using the UBR service.')
amonMatrixTimeAbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeAbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeAbrCells.setDescription(' The number of cells transmitted from the source address to the destination address via the switch using the ABR service.')
amonMatrixTimeNrtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeNrtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeNrtVbrCells.setDescription(' The number of cells transmitted from the source address to the destination address via the switch using the non real-Time VBR service.')
amonMatrixTimeRtVbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeRtVbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeRtVbrCells.setDescription(' The number of cells transmitted from the source address to the destination address via the switch using the real-time VBR service.')
amonMatrixTimeCbrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 5, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: amonMatrixTimeCbrCells.setStatus('mandatory')
if mibBuilder.loadTexts: amonMatrixTimeCbrCells.setDescription(' The number of cells transmitted from the source address to the destination address via the switch using the CBR service.')
mibBuilder.exportSymbols("SMONAMON-MIB", amonSlotAbrCells=amonSlotAbrCells, amonHostTimeOutAbrCells=amonHostTimeOutAbrCells, amonSlotUbrCells=amonSlotUbrCells, amonHostTimeOutLaneConfigControlCells=amonHostTimeOutLaneConfigControlCells, amonPortInLaneMulticastCells=amonPortInLaneMulticastCells, amonHostTimeOutDefinityCells=amonHostTimeOutDefinityCells, amonHostTimeOutNrtVbrCells=amonHostTimeOutNrtVbrCells, amonMatrixTimeTable=amonMatrixTimeTable, amonPortInLaneDataDirectCells=amonPortInLaneDataDirectCells, amonPortInCells=amonPortInCells, amonHostTimeOutCells=amonHostTimeOutCells, amonPortInAbrCells=amonPortInAbrCells, amonSlotLaneCells=amonSlotLaneCells, amonPortInPointToPointCells=amonPortInPointToPointCells, amonMatrixTimeAbrCells=amonMatrixTimeAbrCells, amonMatrixTimeSourceAddress=amonMatrixTimeSourceAddress, amonPortStatsTable=amonPortStatsTable, amonMatrixTimeCbrCells=amonMatrixTimeCbrCells, amonHostTimeTable=amonHostTimeTable, amonSlotStatsEntry=amonSlotStatsEntry, amonPortStatsEntry=amonPortStatsEntry, amonSlotLaneConfigControlCells=amonSlotLaneConfigControlCells, amonPortInPointToMultipointCells=amonPortInPointToMultipointCells, amonHostTimeOutCbrCells=amonHostTimeOutCbrCells, amonPortInBadHecCells=amonPortInBadHecCells, amonSlotRtVbrCells=amonSlotRtVbrCells, amonHostTimeAddress=amonHostTimeAddress, amonSlotNrtVbrBwAllocated=amonSlotNrtVbrBwAllocated, amonPortInSignalingCells=amonPortInSignalingCells, amonPortLaneConfigControlCells=amonPortLaneConfigControlCells, amonHostTimeOutLaneCells=amonHostTimeOutLaneCells, amonSlotSignalingCells=amonSlotSignalingCells, amonMatrixTimeRtVbrCells=amonMatrixTimeRtVbrCells, amonSlotLaneDataDirectCells=amonSlotLaneDataDirectCells, amonHostTimeOutLaneMulticastCells=amonHostTimeOutLaneMulticastCells, amonHostTimeEntry=amonHostTimeEntry, amonSlotLaneMulticastCells=amonSlotLaneMulticastCells, amonMatrixTimeUbrCells=amonMatrixTimeUbrCells, amonMatrixTimeEntry=amonMatrixTimeEntry, amonPortStatistics=amonPortStatistics, amonHostTimeIndex=amonHostTimeIndex, amonHostTimeOutUbrCells=amonHostTimeOutUbrCells, amonHostStatistics=amonHostStatistics, amonHostTimeCreationOrder=amonHostTimeCreationOrder, amonHostTimeOutLaneDataDirectCells=amonHostTimeOutLaneDataDirectCells, amonMatrixTimeCreationOrder=amonMatrixTimeCreationOrder, amonSlotInCells=amonSlotInCells, amonSlotPnniCells=amonSlotPnniCells, amonSlotDroppedCells=amonSlotDroppedCells, amonPortInPnniCells=amonPortInPnniCells, amonMatrixTimeIndex=amonMatrixTimeIndex, amonSlotBadHecCells=amonSlotBadHecCells, amonSlotNrtVbrCells=amonSlotNrtVbrCells, amonHostTimeOutRtVbrCells=amonHostTimeOutRtVbrCells, amonHostMatrix=amonHostMatrix, amonPortInUbrCells=amonPortInUbrCells, amonSlotCbrCells=amonSlotCbrCells, amonSlotTotalBwAllocated=amonSlotTotalBwAllocated, amonSlotDefinityCells=amonSlotDefinityCells, amonPortInNrtVbrCells=amonPortInNrtVbrCells, amonMatrixTimeCells=amonMatrixTimeCells, amonMatrixTimeNrtVbrCells=amonMatrixTimeNrtVbrCells, amonSlotStatsTable=amonSlotStatsTable, amonPortInCbrCells=amonPortInCbrCells, amonMatrixTimeDestAddress=amonMatrixTimeDestAddress, amonPortInRtVbrCells=amonPortInRtVbrCells, smonamon=smonamon, amonSlotCbrBwAllocated=amonSlotCbrBwAllocated, amonSlotRtVbrBwAllocated=amonSlotRtVbrBwAllocated, amonPortDefinityCells=amonPortDefinityCells, amonPortOutCells=amonPortOutCells, amonSlotAbrBwAllocated=amonSlotAbrBwAllocated, amonSlotStatistics=amonSlotStatistics)

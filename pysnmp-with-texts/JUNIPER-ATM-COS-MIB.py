#
# PySNMP MIB module JUNIPER-ATM-COS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-ATM-COS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
atmVclVci, atmVclVpi = mibBuilder.importSymbols("ATM-MIB", "atmVclVci", "atmVclVpi")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
jnxCosFcId, = mibBuilder.importSymbols("JUNIPER-COS-MIB", "jnxCosFcId")
jnxMibs, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, TimeTicks, Integer32, Counter64, Counter32, ModuleIdentity, NotificationType, Gauge32, ObjectIdentity, IpAddress, iso, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "TimeTicks", "Integer32", "Counter64", "Counter32", "ModuleIdentity", "NotificationType", "Gauge32", "ObjectIdentity", "IpAddress", "iso", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
jnxAtmCos = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 21))
jnxAtmCos.setRevisions(('2003-04-09 00:00', '2003-06-20 00:00', '2002-09-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxAtmCos.setRevisionsDescriptions(('Exposed jnxCosAtmTrunkTable for COS enabled Trunks.', 'Add Per queue PLP stats for COS enabled VCs.', 'Initial Version.',))
if mibBuilder.loadTexts: jnxAtmCos.setLastUpdated('200304090000Z')
if mibBuilder.loadTexts: jnxAtmCos.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxAtmCos.setContactInfo('Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net')
if mibBuilder.loadTexts: jnxAtmCos.setDescription('The Juniper enterprise MIB for ATM COS (Class Of Service) infrastructure. For detailed information on ATM COS, Junos Documentation is recommended as the reference. Abbreviations: COS - Class Of Service RED - Random Early Detection PLP - Packet Loss Priority')
jnxCosAtmVcTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 21, 1), )
if mibBuilder.loadTexts: jnxCosAtmVcTable.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcTable.setDescription('A table of ATM VCs which have COS configured.')
jnxCosAtmVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 21, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: jnxCosAtmVcEntry.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcEntry.setDescription('This entry contains COS info specific to an ATM VC. Each entry is indexed using ifIndex, vpi and vci of the VC.')
jnxCosAtmVcCosMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("strict", 0), ("alternate", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcCosMode.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcCosMode.setDescription('The mode of COS queue priority for the VC. strict mode : One queue of the four queues has strict high priority and is always serviced before the rest of the queues. The remaining queues are serviced in round robin fashion. alternate mode : One queue has high priority, but the servicing of the queues alternates between the high priority queue and the rest of the queues.')
jnxCosAtmVcScTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2), )
if mibBuilder.loadTexts: jnxCosAtmVcScTable.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScTable.setDescription('A table of rows representing atm-scheduler config parameters for each forwarding class within a specified VC. NOTE: These schedulers are specific to an atm interface and are different from the typical schedulers specified under class-of-service config in CLI. Hence, hereafter, through out this mib, scheduler will be referred to as atm-scheduler to avoid any confusion.')
jnxCosAtmVcScEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "JUNIPER-COS-MIB", "jnxCosFcId"))
if mibBuilder.loadTexts: jnxCosAtmVcScEntry.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScEntry.setDescription('This entry represents atm-scheduler config parameters per forwarding class and per VC.')
jnxCosAtmVcScPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("low", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScPriority.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScPriority.setDescription('The atm-scheduler priority for the queue associated with the specified forwarding class within the specified VC.')
jnxCosAtmVcScTxWeightType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("cells", 0), ("percent", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScTxWeightType.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScTxWeightType.setDescription('The atm-scheduler transmit-weight-type for the queue associated with the specified forwarding class inside the specified VC. An atm-scheduler can specify the transmit-weight-type either as number of cells or as a percentage of the queue size.')
jnxCosAtmVcScTxWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScTxWeight.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScTxWeight.setDescription("The atm-scheduler's transmit weight for the queue associated with the specified forwarding class and the specified VC. This object value is either expressed in units of cells or as a percentage of the total VC bandwidth. The unit (value-type) can be determined using the object jnxCosAtmVcScTxWeightType.")
jnxCosAtmVcScDpType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("linearRed", 0), ("epd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScDpType.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScDpType.setDescription('The type of RED drop profile configured for the specified forwarding class within the specified VC. A scheduler can specify either linear or constant drop profile. A constant type drop profile (aka EPD) specifies that when the number of queued cells exceeds a threshold, all the cells should be dropped. Whereas a linear type drop profile specifies that only a percentage of cells be dropped based on the number of queued cells at any time.')
jnxCosAtmVcScLrdpQueueDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScLrdpQueueDepth.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScLrdpQueueDepth.setDescription("The maximum queue size in cells, as specified by the linear RED drop profile associated with the specified forwarding class within the specified VC. This object is valid only when value of object jnxCosAtmVcScDpType is 'linearRed(0)'.")
jnxCosAtmVcScLrdpLowPlpThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScLrdpLowPlpThresh.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScLrdpLowPlpThresh.setDescription("The threshold percentage of fill-level beyond which low PLP (Packet Loss Priority) packets belonging to the specified forwarding class within the specified VC are randomly dropped. This value is specified by linear RED drop profile config. This object is valid only when value of object jnxCosAtmVcScDpType is 'linearRed(0)'.")
jnxCosAtmVcScLrdpHighPlpThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcScLrdpHighPlpThresh.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcScLrdpHighPlpThresh.setDescription("The threshold percentage of fill-level beyond which high PLP (Packet Loss Priority) packets belonging to the specified forwarding class within the specified VC are randomly dropped. This value is specified by linear RED drop profile config. This object is valid only when jnxCosAtmVcScDpType is 'linearRed(0)'.")
jnxCosAtmVcEpdThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcEpdThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcEpdThreshold.setDescription("If a EPD type drop profile is configured for this scheduler and if the number of cells queued exceeds this threshold value, all the cells in the queue are dropped. This object has valid value only when jnxCosAtmVcScDpType is 'epd(1)'.")
jnxCosAtmVcQstatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3), )
if mibBuilder.loadTexts: jnxCosAtmVcQstatsTable.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsTable.setDescription('A table of per VC and per forwarding class queue stats entries.')
jnxCosAtmVcQstatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "JUNIPER-COS-MIB", "jnxCosFcId"))
if mibBuilder.loadTexts: jnxCosAtmVcQstatsEntry.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsEntry.setDescription('This entry contains queue stats for a specified forwarding class and specified VC.')
jnxCosAtmVcQstatsOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutPackets.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutPackets.setDescription('The number of packets belonging to the specified forwarding class transmitted on the specified VC.')
jnxCosAtmVcQstatsOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutBytes.setDescription('The number of bytes belonging to the specified forwarding class that were transmitted on the specified VC.')
jnxCosAtmVcQstatsOutRedDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutRedDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutRedDropPkts.setDescription('The number of outgoing packets on the specified VC and belonging to the specified forwarding class, that were RED-dropped.')
jnxCosAtmVcQstatsOutNonRedDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutNonRedDrops.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutNonRedDrops.setDescription('The number of outgoing packets on the specified VC and belonging to the specified forwarding class, that were dropped not as a result of RED mechanism, but because of errors in packets.')
jnxCosAtmVcQstatsOutLpBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpBytes.setDescription('The number of low PLP (PLP0) bytes transmitted.')
jnxCosAtmVcQstatsOutLpPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpPkts.setDescription('The number of low PLP (PLP0) packets transmitted.')
jnxCosAtmVcQstatsOutLpDropBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpDropBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpDropBytes.setDescription('The number of low PLP (PLP0) bytes dropped at the output queue.')
jnxCosAtmVcQstatsOutHpDropBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutHpDropBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutHpDropBytes.setDescription('The number of high PLP (PLP1) bytes dropped at the output queue.')
jnxCosAtmVcQstatsOutLpDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutLpDropPkts.setDescription('The number of low PLP (PLP0) packets dropped at the output queue.')
jnxCosAtmVcQstatsOutHpDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutHpDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmVcQstatsOutHpDropPkts.setDescription('The number of high PLP (PLP1) packets dropped at the output queue.')
jnxCosAtmTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4), )
if mibBuilder.loadTexts: jnxCosAtmTrunkTable.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkTable.setDescription('A table of all ATM Trunk CoS entries. Stats and configuration information is provided for each ATM Trunk CoS interface.')
jnxCosAtmTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "JUNIPER-COS-MIB", "jnxCosFcId"))
if mibBuilder.loadTexts: jnxCosAtmTrunkEntry.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkEntry.setDescription('A single ATM Trunk CoS Entry.')
jnxCosAtmTrunkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("alternate", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkMode.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkMode.setDescription('The mode of COS queue priority for the Trunk. strict mode : One queue of the four queues has strict high priority and is always serviced before the rest of the queues. The remaining queues are serviced in round robin fashion. alternate mode : One queue has high priority, but the servicing of the queues alternates between the high priority queue and the rest of the queues.')
jnxCosAtmTrunkScPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkScPriority.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkScPriority.setDescription('The atm-scheduler priority for the queue associated with the specified forwarding class within the specified Trunk.')
jnxCosAtmTrunkScTxWeightType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cells", 1), ("percent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkScTxWeightType.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkScTxWeightType.setDescription('The atm-scheduler transmit-weight-type for the queue associated with the specified forwarding class inside the specified Trunk. An atm-scheduler can specify the transmit-weight-type either as number of cells or as a percentage of the queue size.')
jnxCosAtmTrunkScTxWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkScTxWeight.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkScTxWeight.setDescription("The atm-scheduler's transmit weight for the queue associated with the specified forwarding class and the specified Trunk. This object value is either expressed in units of cells or as a percentage of the total Trunk bandwidth. The unit (value-type) can be determined using the object jnxCosAtmTrunkScTxWeightType.")
jnxCosAtmTrunkQaType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("red", 1), ("singleEpd", 2), ("dualEpd", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQaType.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQaType.setDescription('The atm queue admission type used for the specified Trunk.')
jnxCosAtmTrunkEpdThresholdPlp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkEpdThresholdPlp0.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkEpdThresholdPlp0.setDescription('If an EPD type drop profile is configured for this scheduler and if the number of cells queued exceeds this threshold value, all the cells which have plp equal to 0 will be dropped. This object has valid value only when jnxCosAtmTrunkQaType is singleEpd or dualEpd.')
jnxCosAtmTrunkEpdThresholdPlp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkEpdThresholdPlp1.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkEpdThresholdPlp1.setDescription('If a EPD type drop profile is configured for this scheduler and if the number of cells queued exceeds this threshold value, all the cells which have plp equal to 1 will be dropped. This object has valid value only when jnxCosAtmTrunkQaType is dualEpd.')
jnxCosAtmTrunkQstatsOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutPackets.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutPackets.setDescription('The number of packets belonging to the specified forwarding class transmitted on the specified Trunk.')
jnxCosAtmTrunkQstatsOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutBytes.setDescription('The number of bytes belonging to the specified forwarding class that were transmitted on the specified Trunk.')
jnxCosAtmTrunkQstatsOutDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutDrops.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutDrops.setDescription('The number of outgoing packets on the specified Trunk and belonging to the specified forwarding class, that were dropped.')
jnxCosAtmTrunkQstatsOutLpBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpBytes.setDescription('The number of low PLP (PLP0) bytes transmitted.')
jnxCosAtmTrunkQstatsOutLpPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpPkts.setDescription('The number of low PLP (PLP0) packets transmitted.')
jnxCosAtmTrunkQstatsOutLpDropBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpDropBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpDropBytes.setDescription('The number of low PLP (PLP0) bytes dropped at the output queue.')
jnxCosAtmTrunkQstatsOutHpDropBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpDropBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpDropBytes.setDescription('The number of high PLP (PLP1) bytes dropped at the output queue.')
jnxCosAtmTrunkQstatsOutLpDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutLpDropPkts.setDescription('The number of low PLP (PLP0) packets dropped at the output queue.')
jnxCosAtmTrunkQstatsOutHpDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpDropPkts.setDescription('The number of high PLP (PLP1) packets dropped at the output queue.')
jnxCosAtmTrunkQstatsOutHpBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpBytes.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpBytes.setDescription('The number of high PLP (PLP1) bytes transmitted.')
jnxCosAtmTrunkQstatsOutHpPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 21, 4, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpPkts.setStatus('current')
if mibBuilder.loadTexts: jnxCosAtmTrunkQstatsOutHpPkts.setDescription('The number of high PLP (PLP1) packets transmitted.')
mibBuilder.exportSymbols("JUNIPER-ATM-COS-MIB", jnxCosAtmTrunkQstatsOutLpBytes=jnxCosAtmTrunkQstatsOutLpBytes, jnxCosAtmTrunkEntry=jnxCosAtmTrunkEntry, jnxCosAtmTrunkMode=jnxCosAtmTrunkMode, jnxCosAtmTrunkQstatsOutHpDropPkts=jnxCosAtmTrunkQstatsOutHpDropPkts, jnxCosAtmVcQstatsEntry=jnxCosAtmVcQstatsEntry, jnxCosAtmTrunkQstatsOutHpDropBytes=jnxCosAtmTrunkQstatsOutHpDropBytes, jnxCosAtmVcQstatsOutHpDropBytes=jnxCosAtmVcQstatsOutHpDropBytes, jnxCosAtmVcQstatsOutBytes=jnxCosAtmVcQstatsOutBytes, jnxCosAtmTrunkQstatsOutPackets=jnxCosAtmTrunkQstatsOutPackets, jnxCosAtmTrunkQaType=jnxCosAtmTrunkQaType, jnxCosAtmTrunkQstatsOutHpBytes=jnxCosAtmTrunkQstatsOutHpBytes, jnxCosAtmVcEntry=jnxCosAtmVcEntry, jnxCosAtmVcQstatsOutLpBytes=jnxCosAtmVcQstatsOutLpBytes, jnxCosAtmTrunkScPriority=jnxCosAtmTrunkScPriority, PYSNMP_MODULE_ID=jnxAtmCos, jnxCosAtmTrunkQstatsOutDrops=jnxCosAtmTrunkQstatsOutDrops, jnxCosAtmTrunkScTxWeight=jnxCosAtmTrunkScTxWeight, jnxCosAtmVcScTable=jnxCosAtmVcScTable, jnxCosAtmVcTable=jnxCosAtmVcTable, jnxCosAtmTrunkQstatsOutBytes=jnxCosAtmTrunkQstatsOutBytes, jnxCosAtmTrunkQstatsOutHpPkts=jnxCosAtmTrunkQstatsOutHpPkts, jnxCosAtmVcScLrdpLowPlpThresh=jnxCosAtmVcScLrdpLowPlpThresh, jnxCosAtmVcQstatsOutLpDropPkts=jnxCosAtmVcQstatsOutLpDropPkts, jnxCosAtmVcQstatsTable=jnxCosAtmVcQstatsTable, jnxCosAtmTrunkTable=jnxCosAtmTrunkTable, jnxCosAtmTrunkQstatsOutLpDropBytes=jnxCosAtmTrunkQstatsOutLpDropBytes, jnxCosAtmVcScLrdpHighPlpThresh=jnxCosAtmVcScLrdpHighPlpThresh, jnxCosAtmVcScEntry=jnxCosAtmVcScEntry, jnxCosAtmVcQstatsOutPackets=jnxCosAtmVcQstatsOutPackets, jnxCosAtmTrunkScTxWeightType=jnxCosAtmTrunkScTxWeightType, jnxCosAtmTrunkQstatsOutLpDropPkts=jnxCosAtmTrunkQstatsOutLpDropPkts, jnxCosAtmVcScTxWeight=jnxCosAtmVcScTxWeight, jnxCosAtmVcScTxWeightType=jnxCosAtmVcScTxWeightType, jnxCosAtmVcEpdThreshold=jnxCosAtmVcEpdThreshold, jnxCosAtmTrunkEpdThresholdPlp0=jnxCosAtmTrunkEpdThresholdPlp0, jnxCosAtmVcScPriority=jnxCosAtmVcScPriority, jnxCosAtmVcQstatsOutNonRedDrops=jnxCosAtmVcQstatsOutNonRedDrops, jnxCosAtmTrunkEpdThresholdPlp1=jnxCosAtmTrunkEpdThresholdPlp1, jnxCosAtmVcCosMode=jnxCosAtmVcCosMode, jnxCosAtmVcQstatsOutLpDropBytes=jnxCosAtmVcQstatsOutLpDropBytes, jnxAtmCos=jnxAtmCos, jnxCosAtmVcQstatsOutRedDropPkts=jnxCosAtmVcQstatsOutRedDropPkts, jnxCosAtmVcQstatsOutLpPkts=jnxCosAtmVcQstatsOutLpPkts, jnxCosAtmVcScDpType=jnxCosAtmVcScDpType, jnxCosAtmVcScLrdpQueueDepth=jnxCosAtmVcScLrdpQueueDepth, jnxCosAtmTrunkQstatsOutLpPkts=jnxCosAtmTrunkQstatsOutLpPkts, jnxCosAtmVcQstatsOutHpDropPkts=jnxCosAtmVcQstatsOutHpDropPkts)

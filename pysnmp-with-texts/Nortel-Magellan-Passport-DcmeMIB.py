#
# PySNMP MIB module Nortel-Magellan-Passport-DcmeMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-DcmeMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
Unsigned32, RowStatus, Gauge32, Counter32, PassportCounter64, DisplayString, StorageType, Integer32, RowPointer = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Unsigned32", "RowStatus", "Gauge32", "Counter32", "PassportCounter64", "DisplayString", "StorageType", "Integer32", "RowPointer")
EnterpriseDateAndTime, FixedPoint1, AsciiString, DigitString, Link, Hex, NonReplicated = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "EnterpriseDateAndTime", "FixedPoint1", "AsciiString", "DigitString", "Link", "Hex", "NonReplicated")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, Gauge32, Bits, ModuleIdentity, MibIdentifier, Counter32, NotificationType, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Integer32, IpAddress, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "Bits", "ModuleIdentity", "MibIdentifier", "Counter32", "NotificationType", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Integer32", "IpAddress", "iso", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dcmeMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134))
dcme = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129))
dcmeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 1), )
if mibBuilder.loadTexts: dcmeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeRowStatusTable.setDescription('This entry controls the addition and deletion of dcme components.')
dcmeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"))
if mibBuilder.loadTexts: dcmeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeRowStatusEntry.setDescription('A single entry in the table represents a single dcme component.')
dcmeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeRowStatus.setDescription('This variable is used as the basis for SNMP naming of dcme components. These components can be added and deleted.')
dcmeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dcmeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeStorageType.setDescription('This variable represents the storage type value for the dcme tables.')
dcmeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: dcmeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeIndex.setDescription('This variable represents the index for the dcme tables.')
dcmeProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10), )
if mibBuilder.loadTexts: dcmeProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProvTable.setDescription('This group contains the provisionable attributes of a Dcme component.')
dcmeProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"))
if mibBuilder.loadTexts: dcmeProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProvEntry.setDescription('An entry in the dcmeProvTable.')
dcmeCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, it specifies the name of the customer that is using this Dcme.')
dcmePreestablishedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmePreestablishedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: dcmePreestablishedConnections.setDescription('This attribute specifies the number of Logical Connections (LC) preestablished between each DcmeLink associated with this Dcme and its remote peer, that are established beyond those that are required to carry established connections. Those are the standby LCs to be used for the subsequent user speech or audio 3.1 kHz calls. This attribute should be set to the number of speech and audio 3.1 kHz calls expected in a typical burst of calls received from the ISC on one DcmeLink.')
dcmeTrmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeTrmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeTrmThreshold.setDescription("This attribute is used to determine when the DcmeLink may be unable to handle incoming calls from the ISC. If the Dcme fails to replenish the number of preestablished connections the 'No trunk(s) available for 3.1 kHz audio or speech' TRM signal is sent to the ISC.")
dcmeTrmSignalChangeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeTrmSignalChangeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeTrmSignalChangeInterval.setDescription("This attribute specifies a minimum time interval between TRM signal change from 'No trunk(s) available for 3.1 kHz audio or speech' or 'No 64 kbit/s capacity available' to 'DCME normal' signal.")
dcmeSpeechAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeSpeechAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeSpeechAlarmThreshold.setDescription('This attribute specifies how many normal speech calls can be rejected by one dcmeLink within the alarmTimeInterval time before a SET alarm is generated. This alarm is cleared when the number of rejected speech calls is less than speechAlarmThreshold in a subsequent interval. If the value is 0 the rejected speech calls are not monitored.')
dcmeAudio3kHzAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeAudio3kHzAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeAudio3kHzAlarmThreshold.setDescription('This attribute specifies how many audio 3.1 kHz calls can be rejected by one dcmeLink within the alarmTimeInterval time before a SET alarm is generated. This alarm is cleared when the number of rejected audio 3.1 kHz calls is less than audio3kHzAlarmThreshold in a subsequent interval. If the value is 0 the rejected audio 3.1 kHz calls are not monitored.')
dcmeUnrestricted64kAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeUnrestricted64kAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeUnrestricted64kAlarmThreshold.setDescription('This attribute specifies how many unrestricted 64 kbit/s calls can be rejected by one dcmeLink within the alarmTimeInterval time before a SET alarm is generated. This alarm is cleared when the number of rejected unrestricted 64 kbit/s calls is less than unrestricted64kAlarmThreshold in a subsequent interval. If the value is 0 the rejected unrestricted 64 kbit/s calls are not monitored.')
dcmeAlarmTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 120)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeAlarmTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeAlarmTimeInterval.setDescription('This attribute specifies the time interval within which the rejected speech calls, audio 3.1 kHz calls, and unrestricted 64 kbit/s calls are monitored. It is used in the conjunction with the speechAlarmThreshold, audio3kHzAlarmThreshold, and unrestricted64kAlarmThreshold attributes.')
dcmeMaxUnrestricted64kCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 420)).clone(420)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeMaxUnrestricted64kCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeMaxUnrestricted64kCalls.setDescription('This attribute specifies the maximum number of simultaneous dynamic unrestricted 64 kbit/s calls that can be established. A value of 0 means that no dynamic unrestricted 64 kbit/s calls can be established.')
dcmeStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 11), )
if mibBuilder.loadTexts: dcmeStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
dcmeStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"))
if mibBuilder.loadTexts: dcmeStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeStateEntry.setDescription('An entry in the dcmeStateTable.')
dcmeAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
dcmeOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
dcmeUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
dcmeStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 13), )
if mibBuilder.loadTexts: dcmeStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeStatsTable.setDescription('This group contains the statistics maintained by this Dcme.')
dcmeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"))
if mibBuilder.loadTexts: dcmeStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeStatsEntry.setDescription('An entry in the dcmeStatsTable.')
dcmeTrm64kNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeTrm64kNotAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeTrm64kNotAvailable.setDescription("This attribute counts the total number of times the TRM signal was changed to the 'No 64 kbit/s capacity available' signal. This counter wraps to zero when it exceeds its maximum.")
dcmeTrmSpeechNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeTrmSpeechNotAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeTrmSpeechNotAvailable.setDescription("This attribute counts the total number of times the TRM signal was changed to the 'No trunk(s) available for 3.1 kHz audio or speech' signal. This counter wraps to zero when it exceeds its maximum.")
dcmeDLinksTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 419), )
if mibBuilder.loadTexts: dcmeDLinksTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeDLinksTable.setDescription('This attribute specifies all of the DcmeLinks which are associated with this Dcme. There can be up to 14 DcmeLinks associated with one Dcme.')
dcmeDLinksEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 419, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeDLinksValue"))
if mibBuilder.loadTexts: dcmeDLinksEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeDLinksEntry.setDescription('An entry in the dcmeDLinksTable.')
dcmeDLinksValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 419, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeDLinksValue.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeDLinksValue.setDescription('This variable represents both the value and the index for the dcmeDLinksTable.')
dcmeDLinksRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 419, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: dcmeDLinksRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeDLinksRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the dcmeDLinksTable.')
dcmeActiveDcmeLinksTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 420), )
if mibBuilder.loadTexts: dcmeActiveDcmeLinksTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeActiveDcmeLinksTable.setDescription('This attribute indicates all of the DcmeLink components that are currently active and have registered with this Dcme.')
dcmeActiveDcmeLinksEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 420, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeActiveDcmeLinksValue"))
if mibBuilder.loadTexts: dcmeActiveDcmeLinksEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeActiveDcmeLinksEntry.setDescription('An entry in the dcmeActiveDcmeLinksTable.')
dcmeActiveDcmeLinksValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 420, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeActiveDcmeLinksValue.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeActiveDcmeLinksValue.setDescription('This variable represents both the value and the index for the dcmeActiveDcmeLinksTable.')
dcmeProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2))
dcmeProfileRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 1), )
if mibBuilder.loadTexts: dcmeProfileRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileRowStatusTable.setDescription('This entry controls the addition and deletion of dcmeProfile components.')
dcmeProfileRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeProfileIndex"))
if mibBuilder.loadTexts: dcmeProfileRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileRowStatusEntry.setDescription('A single entry in the table represents a single dcmeProfile component.')
dcmeProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeProfileRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileRowStatus.setDescription('This variable is used as the basis for SNMP naming of dcmeProfile components. These components cannot be added nor deleted.')
dcmeProfileComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeProfileComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dcmeProfileStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmeProfileStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileStorageType.setDescription('This variable represents the storage type value for the dcmeProfile tables.')
dcmeProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dcmeProfileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileIndex.setDescription('This variable represents the index for the dcmeProfile tables.')
dcmeProfileLCOpsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10), )
if mibBuilder.loadTexts: dcmeProfileLCOpsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileLCOpsTable.setDescription('This group contains attributes used in setting up Switched Logical Connections (SLC) over the network using the Path Oriented Routing System (PORS) between two peer DcmeLink components.')
dcmeProfileLCOpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeProfileIndex"))
if mibBuilder.loadTexts: dcmeProfileLCOpsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileLCOpsEntry.setDescription('An entry in the dcmeProfileLCOpsTable.')
dcmeProfileSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileSetupPriority.setDescription("This attribute specifies the priority at which a path is established. Zero is the highest priority and four is the lowest. When PORS establishes a path through the network, it uses the setupPriority attribute to determine its potential for bumping established paths to acquire their bandwidth. The holdingPriority, a complementary attribute of this attribute, indicates the priority a path maintains once it is established. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
dcmeProfileHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileHoldingPriority.setDescription("This attribute specifies the priority that a path holds once it is established. Zero is the highest priority and four is the lowest. A path's holdingPriority determines its likelihood of being bumped by a new path to acquire its bandwidth. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
dcmeProfileBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1))).clone('bumpWhenNecessary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileBumpPreference.setDescription('This attribute specifies when bumping occurs in the route selection process. A connection with higher (numerically less) setupPriority may bump a connection with lower (numerically higher) setupPriority in order to acquire its bandwidth and be established. If bumpPreference is bumpWhenNecessary, bumping occurs only when it is necessary. That is, a connection will bump another connection only if there is no other way for the connection to be established. If bumpPreference is bumpToObtainBestRoute, bumping occurs in order to use the best available route it may have.')
dcmeProfileRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7))).clone('voice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileRequiredTrafficType.setDescription('This attribute specifies the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1, then only trunks that include trafficType1 in supportedTrafficType will be candidates for this connection.')
dcmeProfilePermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfilePermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfilePermittedTrunkTypes.setDescription("This attribute specifies up to eight types of trunks that can be used on the route. The terrestrial and satellite trunk types are defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS chooses only trunks whose trunkTypes are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
dcmeProfileRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileRequiredSecurity.setDescription("This attribute specifies the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
dcmeProfileRequiredCustomerParm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileRequiredCustomerParm.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileRequiredCustomerParm.setDescription('This attribute specifies the allowed customer defined parameter of the trunks on the route. The value of requiredCustomerParm ranges from 0 to 7. The meaning of each value is specific to a particular network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
dcmeProfilePathAttributeToMinimize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("cost", 0), ("delay", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfilePathAttributeToMinimize.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfilePathAttributeToMinimize.setDescription('This attribute specifies whether a route is selected on the basis of minimizing the cost or the delay. Each trunk has a cost and a delay metric associated with it. The cost of a selected route is the sum of the trunk cost metrics for all trunks included in the route. The delay of a selected route is the sum of the trunk delay metrics for all trunks included in the route.')
dcmeProfileMaximumAcceptableCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1280)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMaximumAcceptableCost.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMaximumAcceptableCost.setDescription('This attribute specifies an upper bound on the cost metric of a route, which is the sum of the cost metrics of all trunks on the route. The cost metric is the trunkCost attribute of the Trunk component. If for any trunk the trunkCost is larger than the maximumAcceptableCost, then that trunk is not considered during the route selection. While a shortest route is being selected, the route cost is being compared with the maximumAcceptableCost attribute, and this is done for any minimization criterion. No route is selected if the cost metric of the shortest route is larger than the maximumAcceptableCost.')
dcmeProfileMaximumAcceptableDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMaximumAcceptableDelay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMaximumAcceptableDelay.setDescription("This attribute specifies an upper bound on the delay of a route, which is the sum of the delays of all trunks on the route. It should be provisioned with a reasonable maximum acceptable delay for the end to end one way delay of a 512-byte packet. During its staging, a trunk measures a measuredRoundTripDelay. This delay is divided by two and truncated to an integer number of milliseconds to provide a one way delay which is used to populate the delay in this trunk object in the topological database. The value includes emission, propagation, and queuing delays. A 512-byte packet is used to perform the measurement. If for any trunk the half of the trunk's measuredRoundTripDelay is larger than the maximumAcceptableDelay, then that trunk is not considered during the route selection. While a shortest route is being selected, the route delay is being compared with the maximumAcceptableDelay attribute, and this is done for any minimization criterion. No route is selected if the delay metric of the shortest route is larger than the maximumAcceptableDelay.")
dcmeProfileEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileEmissionPriority.setDescription('This attribute specifies the urgency with which packets on the path are emitted by the trunks on the route. An emissionPriority of 0 indicates the highest emission priority, while 2 indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets with a lower emissionPriority (or numerically higher).')
dcmeProfileDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileDiscardPriority.setDescription('This attribute specifies the importance of the packets on the path. A discardPriority of 1 is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
dcmeProfilePathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1))).clone('reRoutePath')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfilePathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfilePathFailureAction.setDescription('This attribute specifies whether the application can tolerate momentary interruption of a path while a new path is selected. If pathFailureAction is disconnectConnection, the application is informed as soon as possible about a failure by disconnection. If pathFailureAction is reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails, the application is informed of the failure. If pathFailureAction is reRoutePath, the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option has the desired effect that the path is rerouted without complete disconnection at both ends.')
dcmeProfileOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileOptimization.setDescription('This attribute specifies whether this connection should attempt to optimize its path when requested by the Rtg Pors component. Every path is optimal when it is established, but as network traffic patterns and configurations change this path may no longer be optimal. The PORS connection manager on a module requests circuits to optimize at the optimizationInterval.')
dcmeProfileFrOpsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11), )
if mibBuilder.loadTexts: dcmeProfileFrOpsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileFrOpsTable.setDescription('This group contains attributes which define how audio data will be carried across the Passport network.')
dcmeProfileFrOpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dcmeProfileIndex"))
if mibBuilder.loadTexts: dcmeProfileFrOpsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileFrOpsEntry.setDescription('An entry in the dcmeProfileFrOpsTable.')
dcmeProfileVoiceEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("g711G726", 0), ("g728at16", 1), ("g729at8", 2))).clone('g728at16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileVoiceEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileVoiceEncoding.setDescription('This attribute specifies the encoding of voice traffic. A voiceEncoding setting of g711G726 specifies that either pulse code modulation (PCM) defined by ITU-T G.711 or adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726 is used to encode voice traffic. The actual encoding performed depends on congestion in the network and the settings of minVoiceG711G726Rate and maxVoiceG711G726Rate. If voiceEncoding is g711G726, the bit rate of voice traffic can change during a call due to congestion in the network. In this case, the minimum and maximum rates that can occur during a call are specified by minVoiceG711G726Rate and maxVoiceG711G726Rate respectively. If voiceEncoding is g711G726, minVoiceG711G726Rate is 64 and maxVoiceG711G726Rate is 64, G.711 (PCM) encoding is always performed on voice traffic on this channel and all voice traffic is carried uncompressed at 64 kbit/s. A voiceEncoding setting of g728at16 specifies that the Low Delay Coded Excited Linear Predictive Coder (LD-CELP) algorithm defined by ITU-T G.728 is always performed on voice traffic. If voiceEncoding is g728at16, the bit rate of all voice traffic is fixed at 16 kbit/s. The minVoiceG711G726Rate and maxVoiceG711G726Rate attributes do not apply if voiceEncoding is g728at16. A voiceEncoding setting of g729at8 indicates that the Conjugated Structure Algebraic Code Excited Linear Predictive Coder (CS- ACELP) algorithm defined by ITU-T G.729 is always performed on voice traffic. If voiceEncoding is g729at8, the bit rate of all voice traffic is fixed at 8 kbit/s. The minVoiceG711G726Rate and maxVoiceG711G726Rate attributes do not apply if voiceEncoding is g729at8.')
dcmeProfileMaxVoiceBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMaxVoiceBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMaxVoiceBitRate.setDescription('This attribute specifies the maximum possible bit rate (minimum possible compression rate) during a voice call on this channel when voiceEncoding is g711G726. It applies only to voice traffic, not modem or fax traffic. It also applies only if voiceEncoding is g711G726. If voiceEncoding is g711G726, the bit rate of voice traffic can change during a call due to congestion in the network. In this case, the minimum and maximum rates that can occur during a call are specified by minVoiceG711G726Rate and maxVoiceG711G726Rate respectively. If voiceEncoding is g711G726, minVoiceG711G726Rate is 64 and maxVoiceG711G726Rate is 64, the G.711 (PCM) algorithm is always performed on voice traffic on this channel and all voice traffic is carried uncompressed at 64 kbit/s.')
dcmeProfileMinVoiceBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMinVoiceBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMinVoiceBitRate.setDescription('This attribute specifies the minimum possible bit rate (maximum possible compression rate) during a voice call on this channel when voiceEncoding is g711G726. It applies only to voice traffic, not modem or fax traffic. It also applies only if voiceEncoding is g711G726. If voiceEncoding is g711G726, the bit rate of voice traffic can change during a call due to congestion in the network. In this case, the minimum and maximum rates that can occur during a call are specified by minVoiceG711G726Rate and maxVoiceG711G726Rate respectively. If voiceEncoding is g711G726, minVoiceG711G726Rate is 64 and maxVoiceG711G726Rate is 64, the G.711 (PCM) algorithm is always performed on voice traffic on this channel and all voice traffic is carried uncompressed at 64 kbit/s.')
dcmeProfileVoiceTrafficOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bandwidth", 0), ("delay", 1))).clone('bandwidth')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileVoiceTrafficOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileVoiceTrafficOptimization.setDescription('This attribute specifies how to optimize voice traffic. If voiceTrafficOptimization is bandwidth, voice traffic is optimized to preserve bandwidth. If voiceTrafficOptimization is delay, voice traffic is optimized to minimize delay.')
dcmeProfileSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileSilenceSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileSilenceSuppression.setDescription('This attribute specifies when silence suppression is performed. It applies to both voice and modem calls. If silenceSuppression is off, silence suppression is never performed. If silenceSuppression is on, silence suppression is always performed. If silenceSuppression is congested, silence suppression is performed only when the network is congested. If silenceSuppression is slow, silence suppression begins after 10 to 20 seconds without any detected speech or modem traffic. If silenceSuppression is slowAndCongested, both the slow and congested options are applied.')
dcmeProfileSilenceSuppressionFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileSilenceSuppressionFactor.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileSilenceSuppressionFactor.setDescription('This attribute specifies the expected savings (percent reduction) in required bandwidth if silence suppression is used. If silence suppression is used, the bandwidth required for the connection will be lower than if silence suppression is not used. However, the routing system will not be aware of the unused bandwidth unless that bandwidth is specified by this attribute. If the value specified for the expected savings is too low, then some bandwidth made available by the use of silence suppression will be wasted. If the value specified for the expected savings is too high, then some connections may fail to set up because the routing system will over-calculate the amount of bandwidth available. The effectiveness of silence suppression can be influenced by language related speech patterns.')
dcmeProfileEchoCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileEchoCancellation.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileEchoCancellation.setDescription('This attribute specifies whether echo cancellation is performed on calls using this profile as specified by ITU-T G.165. It applies mainly to voice traffic. Echo cancellation is usually (but not always) disabled during modem and fax calls. If echoCancellation is on, the traffic that is echo cancelled is determined by ITU-T G.165.')
dcmeProfileModemFaxEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("g711G726", 0), ("faxRelayOnly", 1), ("faxRelayG711G726", 2), ("useVoiceEncoding", 3))).clone('faxRelayOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileModemFaxEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileModemFaxEncoding.setDescription("This attribute specifies how modem and fax traffic is encoded. Modem and fax traffic are identified by an inband 2100 Hz tone. Prior to the detection of a 2100 Hz tone, all traffic is handled according to voiceEncoding. If modemFaxEncoding is useVoiceEncoding, 2100 Hz tones are not detected on the channel. In this case, the channel does not differentiate between modem and fax traffic and voice traffic. All traffic is handled according to voiceEncoding. If voiceEncoding is g728at16 or g729at8, modem and fax calls will not work. If a 2100 Hz tone is detected and modemFaxEncoding is g711G726, all subsequent traffic during a call is encoded using pulse code modulation (PCM) defined by ITU-T G.711 or adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726. When the 2100 Hz tone is detected, traffic is initially encoded at the rate specified by maxModemFaxG711G726Rate. For the duration of the call, the bit rate can change due to network congestion. In this case, the minimum and maximum rates that can occur during the call are specified by minModemFaxG711G726Rate and maxModemFaxG711G726Rate respectively. If a 2100 Hz tone is detected and modemFaxEncoding is faxRelayG711G726, encoding switches to G.711 or G.726 at the rate specified in maxModemFaxG711G726Rate, exactly as it does if modemFaxEncoding is g711G726. Until a fax preamble is detected, the rate may fluctuate between maxModemFaxG711G726Rate and minModemFaxG711G726Rate due to network congestion, exactly as it does if modemFaxEncoding is g711G726. If a fax preamble is detected, all subsequent traffic during a call is demodulated and sent through the network as cells at the base rate of the sending machine. Supported demodulation methods are V.29 (up to 9.6 kbit/s) and V.27 (up to 4.8 kbit/s). The modulation and demodulation of fax traffic is called 'fax relay'. If a 2100 Hz tone is detected and modemFaxEncoding is faxRelayOnly, this channel does not wait for a fax preamble to switch to 'fax relay'. Instead, 'fax relay' is entered immediately. If modemFaxEncoding is faxRelayOnly, modem calls do not work on this Dcme. Therefore, this setting is only appropriate if modem calls are not made on the channel. The faxRelay feature is required to set modemFaxEncoding to faxRelayG711G726 or faxRelayOnly. modemFaxEncoding must have the same value at both ends of a Dcme. If modemFaxEncoding is not provisioned with the same values at both ends of a Dcme, the Dcme will not be able to carry the modem and fax traffic successfully.")
dcmeProfileMaxModemFaxG711G726Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMaxModemFaxG711G726Rate.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMaxModemFaxG711G726Rate.setDescription('This attribute specifies the maximum possible bit rate (minimum possible compression rate) during a modem call on this channel. It also specifies the maximum possible bit rate (minimum possible compression rate) during a fax call on this channel, but only if faxEncoding is g711G726. maxModemFaxG711G726Rate always applies to modem traffic, and never applies to voice traffic. If faxEncoding is g711G726, maxModemFaxG711G726Rate also applies to fax traffic. If faxEncoding is faxRelay, maxModemFaxG711G726Rate does not apply to fax traffic. Rates can change during a call due to congestion in the network.')
dcmeProfileMinModemFaxG711G726Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMinModemFaxG711G726Rate.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMinModemFaxG711G726Rate.setDescription('This attribute specifies the minimum possible bit rate (maximum possible compression rate) during a modem call on this channel. It also specifies the minimum possible bit rate (maximum possible compression rate) during a fax call on this channel, but only if faxEncoding is g711G726. minModemFaxG711G726Rate always applies to modem traffic, and never applies to voice traffic. If faxEncoding is g711G726, minModemFaxG711G726Rate also applies to fax traffic. If faxEncoding is faxRelay, minModemFaxG711G726Rate does not apply to fax traffic. Rates can change during a call due to congestion in the network.')
dcmeProfileFaxIdleSuppressionG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileFaxIdleSuppressionG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileFaxIdleSuppressionG711G726.setDescription('This attribute specifies whether fax idle suppression is performed on fax traffic on calls using this profile. It only applies to fax traffic, not voice or modem traffic. It also only applies if fax traffic is carried using G.711 or G.726.')
dcmeProfileInsertedOutputDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 15, 22, 30, 35, 40, 45, 50, 75, 100, 125, 150))).clone(namedValues=NamedValues(("n5", 5), ("n15", 15), ("n22", 22), ("n30", 30), ("n35", 35), ("n40", 40), ("n45", 45), ("n50", 50), ("n75", 75), ("n100", 100), ("n125", 125), ("n150", 150))).clone('n22')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileInsertedOutputDelay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileInsertedOutputDelay.setDescription('This attribute specifies the amount of added output delay used to compensate for cross network delay variations. It applies to voice, modem and fax traffic. It is required to add output delay so that the statistical variation in the transit time of cells crossing the network does not cause gaps in speech. Backbone networks where high priority traffic consumes a high percentage of trunk bandwidth will require a higher insertedOutputDelay to compensate for the greater cell delay variation (CDV).')
dcmeProfileIngressAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileIngressAudioGain.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileIngressAudioGain.setDescription('This attribute specifies the gain in dB that is applied to data coming from outside the network before it is transferred across the network. It applies to voice, modem and fax traffic. For example, ingress gain is applied to audio data coming from a PBX. If ingressAudioGain is negative, a loss is applied. ingressAudioGain and egressAudioGain are used in loss planning, which is the configuration of the devices in a network to ensure that the signal level from any point in the network to any other point is correct.')
dcmeProfileEgressAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileEgressAudioGain.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileEgressAudioGain.setDescription('This attribute specifies the gain in dB that is applied to data leaving the network on this route. It applies to voice, modem and fax traffic. For example, egress gain is applied to audio data going to a PBX. If egressAudioGain is negative, a loss is applied. ingressAudioGain and egressAudioGain are used in loss planning, which is the configuration of the devices in the network to ensure that the signal level from any point in the network to any other point is correct.')
dcmeProfileSpeechHangoverTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 500)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileSpeechHangoverTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileSpeechHangoverTime.setDescription('This attribute specifies the time after the end of speech before silence suppression starts. It applies only to voice traffic. Higher values of speechHangoverTime reduce undesirable clipping but increase bandwidth usage.')
dcmeProfileComfortNoiseCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-78, -78), ValueRangeConstraint(-65, -65), ValueRangeConstraint(-60, -60), ValueRangeConstraint(-54, -54), ValueRangeConstraint(-52, -52), ValueRangeConstraint(-50, -50), ValueRangeConstraint(-48, -48), ValueRangeConstraint(-46, -46), ValueRangeConstraint(-44, -44), ValueRangeConstraint(-42, -42), ValueRangeConstraint(-40, -40), )).clone(-40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileComfortNoiseCap.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileComfortNoiseCap.setDescription('This attribute specifies the maximum level at which comfort noise is generated. The comfort noise is limited by comfortNoiseCap before egressAudioGain is applied. The default value of -40 dBm0 equates to the maximum level of comfort noise available and effectively disables the comfortNoiseCap.')
dcmeProfileModemFaxSpeechDiscrim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileModemFaxSpeechDiscrim.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileModemFaxSpeechDiscrim.setDescription('This attribute specifies whether this Dcme differentiates between modemFax traffic and speech. If modemFaxSpeechDiscrim is on and a false 2100 Hz tone is detected, any Vs under this Dcme reverts to speech mode when speech is detected.')
dcmeProfileV17EncodedAsG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileV17EncodedAsG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileV17EncodedAsG711G726.setDescription('This attribute specifies how services using this Profile negotiate with V.17 fax machines. This attribute is not used unless the modemFaxEncoding, defined in this Profile, is faxRelayG711G726 If v17EncodedAsG711G726 is no, V.17 fax machines are instructed to use V.29 and V.29 fax traffic sent by fax machines is demodulated and encoded using fax relay. If v17EncodedAsG711G726 is yes, V.17 fax machines are permitted to use V.17 and V.17 fax traffic sent by fax machines is encoded using G.711 or G.726. The actual encoding performed depends on the minModemFaxG711G726Rate and maxModemFaxG711G726Rate, available in this Profile.')
dcmeProfileDtmfRegeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileDtmfRegeneration.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileDtmfRegeneration.setDescription('This attribute specifies the DTMF regeneration parameter used during negotiation with the remote end across the subnet. If dtmfRegeneration is on, it is desired that DTMF tones received from the link are first converted to digits before being sent to the subnet. When a digit is received from the subnet, its respective DTMF tone is desired to be generated before being sent to the link. If dtmfRegeneration is off, it is desired that DTMF tones are transported transparently as audio.')
dcmeProfileMaxFaxRelayRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 129, 2, 11, 1, 21), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(24, 24), ValueRangeConstraint(48, 48), ValueRangeConstraint(72, 72), ValueRangeConstraint(96, 96), ValueRangeConstraint(120, 120), ValueRangeConstraint(144, 144), )).clone(144)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmeProfileMaxFaxRelayRate.setStatus('mandatory')
if mibBuilder.loadTexts: dcmeProfileMaxFaxRelayRate.setDescription('This attribute specifies the maximum desired fax relay rate. This attribute only applies if modemFaxEncoding is faxRelayOnly or faxRelayG711G726.')
dcl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130))
dclRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 1), )
if mibBuilder.loadTexts: dclRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclRowStatusTable.setDescription('This entry controls the addition and deletion of dcl components.')
dclRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"))
if mibBuilder.loadTexts: dclRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclRowStatusEntry.setDescription('A single entry in the table represents a single dcl component.')
dclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclRowStatus.setDescription('This variable is used as the basis for SNMP naming of dcl components. These components can be added and deleted.')
dclComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclStorageType.setDescription('This variable represents the storage type value for the dcl tables.')
dclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14)))
if mibBuilder.loadTexts: dclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclIndex.setDescription('This variable represents the index for the dcl tables.')
dclProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10), )
if mibBuilder.loadTexts: dclProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclProvTable.setDescription('This group contains the provisionable attributes of a DcmeLink.')
dclProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"))
if mibBuilder.loadTexts: dclProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclProvEntry.setDescription('An entry in the dclProvTable.')
dclCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: dclCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, it specifies the name of the customer that is using this DcmeLink.')
dclRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('e164')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: dclRemoteNpi.setDescription('This attribute specifies the Numbering Plan Indicator used for the remoteDna attribute of this DcmeLink.')
dclRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1, 3), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: dclRemoteDna.setDescription('This attribute specifies the Data Network Address (DNA) of the remote DcmeLink. This is the DNA of the peer DcmeLink to which the DcmeLink component establishes its Logical Connection (LC).')
dclDcme = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclDcme.setStatus('mandatory')
if mibBuilder.loadTexts: dclDcme.setDescription('This attribute specifies the Dcme component that this DcmeLink belongs to.')
dclIdlePattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(213)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclIdlePattern.setStatus('mandatory')
if mibBuilder.loadTexts: dclIdlePattern.setDescription('This attribute specifies an idlePattern in the channel received from the E1 interface, which is required to determine if the channel is active or not. When the end of the idlePattern is detected it indicates the start of a new speech call. When this idlePattern is detected it indicates the end of a speech call. When changing this attribute make sure that the alternateIdlePattern attibute is set correctly.')
dclAlternateIdlePattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 10, 1, 6), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(213)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclAlternateIdlePattern.setStatus('mandatory')
if mibBuilder.loadTexts: dclAlternateIdlePattern.setDescription('This attribute specifies an alternateIdlePattern in the channel received from the E1 interface, after the end of a 64kbit/s call. The value of this attribute should be different than the value of the idlePattern attribute only if the ISC is programmed for Even/Odd Bit Inversion (EBI/OBI). This is only the case when the ISC is performing A to Mu or Mu to A Law conversion. When the end of the alternateIdlePattern is detected it indicates the start of a new speech call.')
dclStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 11), )
if mibBuilder.loadTexts: dclStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
dclStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"))
if mibBuilder.loadTexts: dclStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclStateEntry.setDescription('An entry in the dclStateTable.')
dclAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: dclAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
dclOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: dclOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
dclUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: dclUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
dclOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12), )
if mibBuilder.loadTexts: dclOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclOperTable.setDescription('This group provides the operational attributes for the DcmeLink component.')
dclOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"))
if mibBuilder.loadTexts: dclOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclOperEntry.setDescription('An entry in the dclOperTable.')
dclActiveSpeechCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclActiveSpeechCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclActiveSpeechCalls.setDescription('This attribute indicates the number of speech calls that are currently in progress on this DcmeLink.')
dclActive3kHzCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclActive3kHzCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclActive3kHzCalls.setDescription('This attribute indicates the number of audio 3.1 kHz calls that are currently in progress on this DcmeLink.')
dclActive64kCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclActive64kCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclActive64kCalls.setDescription('This attribute indicates the number of unrestricted 64 kbit/s calls that are currently in progress on this DcmeLink.')
dclReceivedTrmSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none000", 0), ("invalid001", 1), ("invalid010", 2), ("invalid011", 3), ("invalid100", 4), ("switchingCentreNormal101", 5), ("maintenanceReleaseAck110", 6), ("dcmeClearOfTraffic111", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclReceivedTrmSignal.setStatus('mandatory')
if mibBuilder.loadTexts: dclReceivedTrmSignal.setDescription('This attribute indicates the last TRM signal received from the ISC. The received TRM signal can be one of: Invalid (xxx): this signal should never be received, Switching Centre normal (101): this signal is allways transmitted by the ISC when there is no other signal to be sent, Maintenance release ack(110): this signal is transmitted by the ISC if it accepts the maintenance release request, Dcme clear of traffic: this signal is transmitted by the ISC if it has accepted the maintenance release request signal and now informs the DCME when all circuits are idle,')
dclTransmittedTrmSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none000", 0), ("dcmeNormal100", 4), ("no64KbitSCapacity101", 5), ("maintenanceReleaseRequest110", 6), ("noCapacityAvailable111", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclTransmittedTrmSignal.setStatus('mandatory')
if mibBuilder.loadTexts: dclTransmittedTrmSignal.setDescription('This attribute indicates the last TRM signal transmitted to the ISC. The transmitted TRM signal can be one of: Dcme normal (100): , this signal is allways transmitted by the DCME when there is no other signal to be sent, No 64 kbit/s capacity (101): this signal is transmitted by the DCME when it is not able to handle new 64 kbit/s call requests, Maintenance release request(110): this signal is transmitted by the DCME when the DCME is to be removed from the service for maintenance, No capacity available (111) this signal is transmitted by the DCME when there is bearer capacity available to set up new 3.1 kHz audio or speech calls,')
dclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13), )
if mibBuilder.loadTexts: dclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclStatsTable.setDescription('This group contains statistics for the DcmeLink component.')
dclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"))
if mibBuilder.loadTexts: dclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclStatsEntry.setDescription('An entry in the dclStatsTable.')
dclTotalSpeechCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclTotalSpeechCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclTotalSpeechCalls.setDescription('This attribute counts the total number of speech calls that have been handled by this DcmeLink, including rejected calls. This counter wraps to zero when it exceeds its maximum.')
dclTotal3kHzCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclTotal3kHzCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclTotal3kHzCalls.setDescription('This attribute counts the total number of audio 3.1 kHz calls that have been handled by this DcmeLink, including rejected calls. This counter wraps to zero when it exceeds its maximum.')
dclTotal64kCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclTotal64kCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclTotal64kCalls.setDescription('This attribute counts the total number of unrestricted 64 kbit/s calls that have been handled by this DcmeLink, including rejected calls. This counter wraps to zero when it exceeds its maximum.')
dclRejectedSpeechCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclRejectedSpeechCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclRejectedSpeechCalls.setDescription('This attribute counts the total number of speech calls that have been rejected by this DcmeLink because there was no preestablished LC available. This counter wraps to zero when it exceeds its maximum.')
dclRejected3kHzCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclRejected3kHzCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclRejected3kHzCalls.setDescription('This attribute counts the total number of audio 3.1 KHz calls that have been rejected by this DcmeLink because there was no preestablished LC available. This counter wraps to zero when it exceeds its maximum.')
dclRejected64kCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclRejected64kCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclRejected64kCalls.setDescription('This attribute counts the total number of unrestricted 64 kbit/s calls that have been rejected by this DcmeLink. This counter wraps to zero when it reaches its maximum.')
dclInvalidTrmSignals = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclInvalidTrmSignals.setStatus('mandatory')
if mibBuilder.loadTexts: dclInvalidTrmSignals.setDescription('This attribute counts the number of invalid TRM/Maintenance signals received from the ISC by this DcmeLink. The most probable cause of an invalid TRM/Maintenance signal is an invalid ISC provisionning or a transmission error. The invalid bit settings are 000, 001, 010, 011, 100. This counter wraps to zero when it exceeds its maximum.')
dclDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2))
dclDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 1), )
if mibBuilder.loadTexts: dclDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaRowStatusTable.setDescription('This entry controls the addition and deletion of dclDna components.')
dclDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclDnaIndex"))
if mibBuilder.loadTexts: dclDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaRowStatusEntry.setDescription('A single entry in the table represents a single dclDna component.')
dclDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclDna components. These components cannot be added nor deleted.')
dclDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaStorageType.setDescription('This variable represents the storage type value for the dclDna tables.')
dclDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaIndex.setDescription('This variable represents the index for the dclDna tables.')
dclDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 10), )
if mibBuilder.loadTexts: dclDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaAddressTable.setDescription("The Address group contains attributes common to all Dna's. Every Dna used in the network is defined with this group of 2 attributes. The string of address digits is complemented by the type of address or Npi. These attributes are used to interpret the format of the address digits.")
dclDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclDnaIndex"))
if mibBuilder.loadTexts: dclDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaAddressEntry.setDescription('An entry in the dclDnaAddressTable.')
dclDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('e164')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. An address may belong to the X.121 or E.164 numbering plans. X.121 is used in packet switched data networks.')
dclDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dclDnaDataNetworkAddress.setDescription('The Dna attribute contains digits which form a unique identifier of the customer interface. It can be compared (approximation only) to a telephone number where each phone number identifies a unique telephone set. Dna digits are selected and assigned by network operators.')
dclFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3))
dclFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 1), )
if mibBuilder.loadTexts: dclFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerRowStatusTable.setDescription('This entry controls the addition and deletion of dclFramer components.')
dclFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclFramerIndex"))
if mibBuilder.loadTexts: dclFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerRowStatusEntry.setDescription('A single entry in the table represents a single dclFramer component.')
dclFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclFramer components. These components cannot be added nor deleted.')
dclFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerStorageType.setDescription('This variable represents the storage type value for the dclFramer tables.')
dclFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerIndex.setDescription('This variable represents the index for the dclFramer tables.')
dclFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 10), )
if mibBuilder.loadTexts: dclFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
dclFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclFramerIndex"))
if mibBuilder.loadTexts: dclFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerProvEntry.setDescription('An entry in the dclFramerProvTable.')
dclFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
dclFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 12), )
if mibBuilder.loadTexts: dclFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
dclFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclFramerIndex"))
if mibBuilder.loadTexts: dclFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerStateEntry.setDescription('An entry in the dclFramerStateTable.')
dclFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
dclFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
dclFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: dclFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
dclVs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4))
dclVsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 1), )
if mibBuilder.loadTexts: dclVsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsRowStatusTable.setDescription('This entry controls the addition and deletion of dclVs components.')
dclVsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"))
if mibBuilder.loadTexts: dclVsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsRowStatusEntry.setDescription('A single entry in the table represents a single dclVs component.')
dclVsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclVs components. These components can be added and deleted.')
dclVsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclVsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsStorageType.setDescription('This variable represents the storage type value for the dclVs tables.')
dclVsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: dclVsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsIndex.setDescription('This variable represents the index for the dclVs tables.')
dclVsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 10), )
if mibBuilder.loadTexts: dclVsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsProvTable.setDescription('This group contains the provisionable attributes of a DcmeVs component.')
dclVsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"))
if mibBuilder.loadTexts: dclVsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsProvEntry.setDescription('An entry in the dclVsProvTable.')
dclVsVsType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("dynamicVs", 0), ("permanent64kVs", 1))).clone('dynamicVs')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsVsType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsVsType.setDescription('This attribute specifies the type of calls offered by this DcmeVs. If the value permanent64kVs is selected the 64 kbit/s call is established on the channel associated with this DcmeVs upon system activation. If this call is cleared due to the subnet failure it is reestablished again by the DcmeLink. If the value dynamicVs is selected this channel can be used to establish user selected calls.')
dclVsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 11), )
if mibBuilder.loadTexts: dclVsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsOperTable.setDescription('This group provides the operational attributes for the DcmeVoiceService component.')
dclVsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"))
if mibBuilder.loadTexts: dclVsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsOperEntry.setDescription('An entry in the dclVsOperTable.')
dclVsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("idle", 0), ("seized", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsStatus.setDescription('This attribute indicates the current status of the channel. idle means that there is no call currently active on this channel. seized means that the channel has currently an active call.')
dclVsCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("speech", 1), ("n31KHz", 2), ("n64KbitS", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsCallType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsCallType.setDescription('This attribute indicates the type of call that this channel is currently carrying. If no call is active, then it displays the value for the last call.')
dclVsReceivedAbBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none00", 0), ("normalServiceAvailable01", 1), ("n31KHzRequest10", 2), ("n64KbitSRequest11", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsReceivedAbBits.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsReceivedAbBits.setDescription('This attribute indicates the most recently received AB bits.')
dclVsTransmittedAbBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none00", 0), ("normalServiceAvailable01", 1), ("specialServiceAck10", 2), ("channelOutOfService11", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsTransmittedAbBits.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsTransmittedAbBits.setDescription('This attribute indicates the AB bits currently being transmitted.')
dclVsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 12), )
if mibBuilder.loadTexts: dclVsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsStatsTable.setDescription('This group provides the operational attributes for the DcmeVoiceService component.')
dclVsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"))
if mibBuilder.loadTexts: dclVsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsStatsEntry.setDescription('An entry in the dclVsStatsTable.')
dclVsTotalCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsTotalCalls.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsTotalCalls.setDescription('This attribute counts the call attempts processed on this channel (in both directions). This count includes both successful and unsuccessful calls. The value wraps when it exceeds its maximum.')
dclVsTotalCallSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsTotalCallSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsTotalCallSeconds.setDescription('This attribute counts the total number of seconds that this channel is handling a call. This is regardless of whether the call is successful or not. In other words, this is the amount of time that the channel is not in the idle state. The value wraps when it reaches its maximum.')
dclVsInvalidAbBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsInvalidAbBits.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsInvalidAbBits.setDescription('This attribute counts the number of invalid AB bits signals received from the ISC on this channel. The invalid bit setting is 00. This counter wraps to zero when it reaches its maximum.')
dclVsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 13), )
if mibBuilder.loadTexts: dclVsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
dclVsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"))
if mibBuilder.loadTexts: dclVsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsStateEntry.setDescription('An entry in the dclVsStateTable.')
dclVsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
dclVsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
dclVsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
dclVsFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2))
dclVsFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 1), )
if mibBuilder.loadTexts: dclVsFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerRowStatusTable.setDescription('This entry controls the addition and deletion of dclVsFramer components.')
dclVsFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"))
if mibBuilder.loadTexts: dclVsFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerRowStatusEntry.setDescription('A single entry in the table represents a single dclVsFramer component.')
dclVsFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclVsFramer components. These components cannot be added nor deleted.')
dclVsFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclVsFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerStorageType.setDescription('This variable represents the storage type value for the dclVsFramer tables.')
dclVsFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclVsFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerIndex.setDescription('This variable represents the index for the dclVsFramer tables.')
dclVsFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 10), )
if mibBuilder.loadTexts: dclVsFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
dclVsFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"))
if mibBuilder.loadTexts: dclVsFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerProvEntry.setDescription('An entry in the dclVsFramerProvTable.')
dclVsFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
dclVsFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 14), )
if mibBuilder.loadTexts: dclVsFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
dclVsFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"))
if mibBuilder.loadTexts: dclVsFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerStateEntry.setDescription('An entry in the dclVsFramerStateTable.')
dclVsFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
dclVsFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
dclVsFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
dclVsFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15), )
if mibBuilder.loadTexts: dclVsFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
dclVsFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"))
if mibBuilder.loadTexts: dclVsFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerStatsEntry.setDescription('An entry in the dclVsFramerStatsTable.')
dclVsFramerTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerTotalCells.setDescription('This attribute counts the total number of cells received from the interface. Each cell contains 44 bytes of data from the DS0 channel. Since a DS0 provides data at 64 kbit/s, each cell contains 5.5 ms of audio data. This data flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
dclVsFramerAudioCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerAudioCells.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerAudioCells.setDescription('This attribute counts the total number of cells containing audio data received from the interface while the channel was seized. A CCS channel is always considered to be seized. Audio data includes cells containing voice as well modem audio, but not silence. A cell contains 44 bytes of data from the DS0 channel(5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
dclVsFramerSilenceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerSilenceCells.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerSilenceCells.setDescription('This attribute counts the total number of cells containing silence data received from the interface which was not forwarded into the network, thus saving bandwidth. A channel may go into silence due to the operation of the silence suppression feature or for CAS channels when the ABCD signalling bits go idle. A cell contains 44 bytes of data from the DS0 channel(5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
dclVsFramerModemCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerModemCells.setStatus('obsolete')
if mibBuilder.loadTexts: dclVsFramerModemCells.setDescription('This attribute is migrated into modemFaxCells.')
dclVsFramerCurrentEncodingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n640", 1), ("n320", 2), ("n240", 3), ("n160", 4), ("n80", 5), ("n144", 6), ("n120", 7), ("n96", 8), ("n72", 9), ("n63", 10), ("n53", 11), ("n48", 12), ("n24", 13), ("n12", 14), ("n03", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerCurrentEncodingRate.setStatus('obsolete')
if mibBuilder.loadTexts: dclVsFramerCurrentEncodingRate.setDescription('This attribute has been migrated to currentRate in Operational group.')
dclVsFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerLrcErrors.setDescription('This attribute counts the number of frames received from the network with LRC errors.')
dclVsFramerFrmLostInNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFrmLostInNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmLostInNetwork.setDescription('This attribute counts the number of frames which the service knows it did not receive from the network although they were sent in to the network from the far end.')
dclVsFramerFrmUnderRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFrmUnderRuns.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmUnderRuns.setDescription('This attribute counts the number of times that a frame was needed but was not available because it had been delayed too long in the network. This error may occur repeatedly if the interface clocks at the two access points to the network are operating at different rates.')
dclVsFramerFrmDumped = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFrmDumped.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmDumped.setDescription('This attribute counts the number of frames which have been dumped because the output queue grew too large. This can occur if the clock rate on the incoming interface is faster than the clock rate on the outgoing interface and there are no silence periods to absorb the difference, or when a compression rate change occurs. This count wraps to zero after reaching its maximum value.')
dclVsFramerModemSilenceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerModemSilenceCells.setStatus('obsolete')
if mibBuilder.loadTexts: dclVsFramerModemSilenceCells.setDescription('This attribute is migrated into faxIdleCells.')
dclVsFramerCurrentEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g723", 3), ("g726", 4), ("g711", 5), ("v22", 32), ("v22bis", 33), ("faxRelay", 64), ("v27", 65), ("v29", 66), ("v17", 67), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerCurrentEncoding.setStatus('obsolete')
if mibBuilder.loadTexts: dclVsFramerCurrentEncoding.setDescription('This attribute has been migrated to currentEncoding in Operational group.')
dclVsFramerTptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("operating", 0), ("rejected", 1), ("monitoring", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerTptStatus.setStatus('obsolete')
if mibBuilder.loadTexts: dclVsFramerTptStatus.setDescription('This attribute has been migrated to tptStatus in Operational group.')
dclVsFramerFaxRelayCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFaxRelayCells.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFaxRelayCells.setDescription('This attribute counts the total number of fax relay cells sent to the network. This counter wraps to zero after reaching its maximum value.')
dclVsFramerModemFaxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerModemFaxCells.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerModemFaxCells.setDescription('This attribute counts the total number of cells containing modem data received from the interface while the channel was seized. A CCS channel is always considered to be seized. Cells are considered to be modem data if a constant energy level above -25 dBmO is detected for more than 900 ms. An energy level below -36 dBmO for more than 650 ms is required to detect that the modem is no longer present. A cell contains 44 bytes of data from the DS0 channel (5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
dclVsFramerFaxIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 15, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFaxIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFaxIdleCells.setDescription('This attribute counts the total number of cells containing silent fax data received from the interface which were not forwarded into the network, thus saving bandwidth. A channel may go into silence due to the silence Suppression feature or for CAS channels when the ABCD signalling bits go idle. A cell contains 44 bytes of data from the DS0 channel (5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
dclVsFramerOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 16), )
if mibBuilder.loadTexts: dclVsFramerOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerOperTable.setDescription('This group contains the operational data for a Svs Framer.')
dclVsFramerOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"))
if mibBuilder.loadTexts: dclVsFramerOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerOperEntry.setDescription('An entry in the dclVsFramerOperTable.')
dclVsFramerOpCurrentEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g723", 3), ("g726", 4), ("g711", 5), ("v22", 32), ("v22bis", 33), ("faxRelay", 64), ("v27", 65), ("v29", 66), ("v17", 67), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerOpCurrentEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerOpCurrentEncoding.setDescription('This attribute indicates the encoding currently being performed on this channel. g711 indicates that pulse code modulation (PCM) defined by ITU-T G.711 is being performed. g726 indicates that adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726 is being performed. g728 indicates that the Low Delay Coded Excited Linear Predictive Coder (LD-CELP) algorithm defined by ITU-T G.728 is being performed. g729 indicates that the Conjunctive Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) algorithm defined by ITU-T G.729 is being performed. v27 indicates that the algorithm defined by ITU-T V.27 is being performed. v29 indicates that the algorithm defined by ITU-T V.29 is being performed.')
dclVsFramerCurrentRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n640", 1), ("n320", 2), ("n240", 3), ("n160", 4), ("n80", 5), ("n144", 6), ("n120", 7), ("n96", 8), ("n72", 9), ("n63", 10), ("n53", 11), ("n48", 12), ("n24", 13), ("n12", 14), ("n03", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerCurrentRate.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerCurrentRate.setDescription('This attribute indicates the current encoding rate for frames being sent to the network.')
dclVsFramerOpTptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("operating", 0), ("monitoring", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerOpTptStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerOpTptStatus.setDescription('This attribute indicates the current status of the tandem pass through algorithm. If tptStatus is operating, the tandem pass through algorithm is cutting through a voice switch. If tptStatus is monitoring, negotiatedTandemPassThrough is enabled, but the tandem pass through algorithm is not cutting through a voice switch. If tptStatus is disabled, negotiatedTandemPassThrough is disabled.')
dclVsFramerNegTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17), )
if mibBuilder.loadTexts: dclVsFramerNegTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegTable.setDescription('This group contains the attributes indicating the results of voice networking end to end negotiation.')
dclVsFramerNegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"))
if mibBuilder.loadTexts: dclVsFramerNegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegEntry.setDescription('An entry in the dclVsFramerNegTable.')
dclVsFramerNegotiatedSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsFramerNegotiatedSilenceSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegotiatedSilenceSuppression.setDescription('This attribute indicates the result of negotiating silence suppression with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp silenceSuppression. If negotiatedSilenceSuppression is off, silence suppression is never performed. If negotiatedSilenceSuppression is on, silence suppression is always performed. If negotiatedSilenceSuppression is congested, silence suppression is performed only when the network is congested. If negotiatedSilenceSuppression is slow, silence suppression begins after 10 to 20 seconds without any speech or audio being detected. If negotiatedSilenceSuppression is slowAndCongested, both the slow and congested options are applied.')
dclVsFramerNegotiatedFisG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsFramerNegotiatedFisG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegotiatedFisG711G726.setDescription('This attribute indicates the result of negotiating G.711/G.726 fax idle suppression with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp faxIdleSuppressionG711G726.')
dclVsFramerNegotiatedDtmfRegeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsFramerNegotiatedDtmfRegeneration.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegotiatedDtmfRegeneration.setDescription('This attribute indicates the result of negotiating DTMF regeneration with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp dtmfRegeneration. If negotiatedDtmfRegeneration is on, DTMF tones received from the link are first converted to digits before being sent to the subnet. When a digit is received from the subnet, its respective DTMF tone is generated before being sent to the link. If negotiatedDtmfRegeneration is off, DTMF tones are transported transparently.')
dclVsFramerNegotiatedV17AsG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerNegotiatedV17AsG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegotiatedV17AsG711G726.setDescription('This attribute indicates how this SwitchedVoiceService negotiates with V.17 fax machines, as determined by negotiation with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp v17EncodedAsG711G726. If negotiatedV17AsG711G726 is no, V.17 fax machines are instructed to use V.29, and V.29 fax traffic sent by fax machines is demodulated and encoded using fax relay. If negotiatedV17AsG711G726 is yes, V.17 fax machines are permitted to use V.17 and V.17 fax traffic sent by fax machines is encoded using G.711 or G.726, at the rates given in negotiatedRates.')
dclVsFramerNegotiatedTandemPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerNegotiatedTandemPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNegotiatedTandemPassThrough.setDescription('This attribute indicates the result of negotiating tandem pass through with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp tandemPassThrough.')
dclVsFramerFrmToNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 315), )
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkTable.setDescription('This attribute counts the number of frames sent to the network at each encoding rate. Fax relay cells are not included.')
dclVsFramerFrmToNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 315, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerFrmToNetworkIndex"))
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkEntry.setDescription('An entry in the dclVsFramerFrmToNetworkTable.')
dclVsFramerFrmToNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 315, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n64KbitS", 0), ("n32KbitS", 1), ("n24KbitS", 2), ("n16KbitS", 3), ("n8KbitS", 4))))
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkIndex.setDescription('This variable represents the dclVsFramerFrmToNetworkTable specific index for the dclVsFramerFrmToNetworkTable.')
dclVsFramerFrmToNetworkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 315, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkValue.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmToNetworkValue.setDescription('This variable represents an individual value for the dclVsFramerFrmToNetworkTable.')
dclVsFramerFrmFromNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 316), )
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkTable.setDescription('This attribute counts the number of frames received from the network at each encoding rate.')
dclVsFramerFrmFromNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 316, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerFrmFromNetworkIndex"))
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkEntry.setDescription('An entry in the dclVsFramerFrmFromNetworkTable.')
dclVsFramerFrmFromNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 316, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n64KbitS", 0), ("n32KbitS", 1), ("n24KbitS", 2), ("n16KbitS", 3), ("n8KbitS", 4))))
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkIndex.setDescription('This variable represents the dclVsFramerFrmFromNetworkTable specific index for the dclVsFramerFrmFromNetworkTable.')
dclVsFramerFrmFromNetworkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 316, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkValue.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerFrmFromNetworkValue.setDescription('This variable represents an individual value for the dclVsFramerFrmFromNetworkTable.')
dclVsFramerNEncodingTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 467), )
if mibBuilder.loadTexts: dclVsFramerNEncodingTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNEncodingTable.setDescription('This attribute indicates the results of negotiating audio call encodings for voice, modemFax and fax traffic with the remote end across the subnet. The parameters used for negotiating with the remote end are provisioned in Vncs Vp voiceEncodingChoice and Vncs Vp modemFaxEncodingChoice. voice traffic is all traffic from the start of a call or speech until a 2100 Hz tone or call release. modemFax traffic is all traffic after a 2100 Hz tone but before a fax preamble, speech or call release. fax traffic is all traffic after a fax preamble but before speech or call release. g711 indicates that pulse code modulation (PCM) defined by ITU-T G.711 is the negotiated encoding. g726 indicates that Adaptive Differential Pulse Code Modulation (ADPCM) defined by ITU-T G.726 is the negotiated encoding. g711G726 indicates that pulse code modulation (PCM) defined by ITU-T G.711 and Adaptive Differential Pulse Code Modulation (ADPCM) defined by ITU-T G.726 are both negotiated encodings. If negotiatedEncoding is g711G726, the actual encoding performed can be either G.711 or G.726, depending on network congestion. g728 indicates that Low Delay Coded Excited Linear Predictive Coder (CS-ACELP) defined by ITU-T G.728 is the negotiated encoding. g729 indicates that Conjunctive Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) defined by ITU-T G.729 is the negotiated encoding. v29V27Relay indicates that fax relay using ITU-T V.27 or ITU-T V.29 is the negotiated encoding. v17V29V27Relay indicates that fax relay using ITU-T V.17, ITU-T V.27, or ITU-T V.29 is the negotiated encoding. If all negotiated encodings are none, the negotiation of audio call encodings is not complete.')
dclVsFramerNEncodingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 467, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerNEncodingIndex"))
if mibBuilder.loadTexts: dclVsFramerNEncodingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNEncodingEntry.setDescription('An entry in the dclVsFramerNEncodingTable.')
dclVsFramerNEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 467, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("modemFax", 1), ("fax", 2))))
if mibBuilder.loadTexts: dclVsFramerNEncodingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNEncodingIndex.setDescription('This variable represents the dclVsFramerNEncodingTable specific index for the dclVsFramerNEncodingTable.')
dclVsFramerNEncodingValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 467, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 31, 64, 68, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g726", 4), ("g711", 5), ("g711G726", 31), ("v29V27Relay", 64), ("v17V29V27Relay", 68), ("none", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsFramerNEncodingValue.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNEncodingValue.setDescription('This variable represents an individual value for the dclVsFramerNEncodingTable.')
dclVsFramerNRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 479), )
if mibBuilder.loadTexts: dclVsFramerNRatesTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNRatesTable.setDescription('This attribute indicates the results of negotiating minimum and maximum rates for voice, modemFax and fax traffic with the remote end across the subnet. The parameters used for negotiating with the remote end are provisioned in Vncs Vp voiceRates and Vncs Vp modemFaxRates.')
dclVsFramerNRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 479, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerNRatesTrafficIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerNRatesRateIndex"))
if mibBuilder.loadTexts: dclVsFramerNRatesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNRatesEntry.setDescription('An entry in the dclVsFramerNRatesTable.')
dclVsFramerNRatesTrafficIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 479, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("modemFax", 1), ("fax", 2))))
if mibBuilder.loadTexts: dclVsFramerNRatesTrafficIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNRatesTrafficIndex.setDescription('This variable represents the next to last index for the dclVsFramerNRatesTable.')
dclVsFramerNRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 479, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: dclVsFramerNRatesRateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNRatesRateIndex.setDescription('This variable represents the final index for the dclVsFramerNRatesTable.')
dclVsFramerNRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 479, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 66, 67, 68, 69, 70))).clone(namedValues=NamedValues(("n00", 0), ("n03", 1), ("n12", 2), ("n24", 3), ("n48", 4), ("n72", 5), ("n96", 6), ("n120", 7), ("n144", 8), ("n80", 66), ("n160", 67), ("n240", 68), ("n320", 69), ("n640", 70)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsFramerNRatesValue.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerNRatesValue.setDescription('This variable represents an individual value for the dclVsFramerNRatesTable.')
dclVsFramerVfpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5))
dclVsFramerVfpDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5, 1), )
if mibBuilder.loadTexts: dclVsFramerVfpDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerVfpDebugRowStatusTable.setDescription('This entry controls the addition and deletion of dclVsFramerVfpDebug components.')
dclVsFramerVfpDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerVfpDebugIndex"))
if mibBuilder.loadTexts: dclVsFramerVfpDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerVfpDebugRowStatusEntry.setDescription('A single entry in the table represents a single dclVsFramerVfpDebug component.')
dclVsFramerVfpDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerVfpDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerVfpDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclVsFramerVfpDebug components. These components cannot be added nor deleted.')
dclVsFramerVfpDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerVfpDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerVfpDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclVsFramerVfpDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerVfpDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerVfpDebugStorageType.setDescription('This variable represents the storage type value for the dclVsFramerVfpDebug tables.')
dclVsFramerVfpDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclVsFramerVfpDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerVfpDebugIndex.setDescription('This variable represents the index for the dclVsFramerVfpDebug tables.')
dclVsFramerMvpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6))
dclVsFramerMvpDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6, 1), )
if mibBuilder.loadTexts: dclVsFramerMvpDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerMvpDebugRowStatusTable.setDescription('This entry controls the addition and deletion of dclVsFramerMvpDebug components.')
dclVsFramerMvpDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerMvpDebugIndex"))
if mibBuilder.loadTexts: dclVsFramerMvpDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerMvpDebugRowStatusEntry.setDescription('A single entry in the table represents a single dclVsFramerMvpDebug component.')
dclVsFramerMvpDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerMvpDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerMvpDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclVsFramerMvpDebug components. These components cannot be added nor deleted.')
dclVsFramerMvpDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerMvpDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerMvpDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclVsFramerMvpDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerMvpDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerMvpDebugStorageType.setDescription('This variable represents the storage type value for the dclVsFramerMvpDebug tables.')
dclVsFramerMvpDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclVsFramerMvpDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerMvpDebugIndex.setDescription('This variable represents the index for the dclVsFramerMvpDebug tables.')
dclVsFramerPcmCapture = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7))
dclVsFramerPcmCaptureRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7, 1), )
if mibBuilder.loadTexts: dclVsFramerPcmCaptureRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerPcmCaptureRowStatusTable.setDescription('This entry controls the addition and deletion of dclVsFramerPcmCapture components.')
dclVsFramerPcmCaptureRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsFramerPcmCaptureIndex"))
if mibBuilder.loadTexts: dclVsFramerPcmCaptureRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerPcmCaptureRowStatusEntry.setDescription('A single entry in the table represents a single dclVsFramerPcmCapture component.')
dclVsFramerPcmCaptureRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerPcmCaptureRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerPcmCaptureRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclVsFramerPcmCapture components. These components cannot be added nor deleted.')
dclVsFramerPcmCaptureComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerPcmCaptureComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerPcmCaptureComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclVsFramerPcmCaptureStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsFramerPcmCaptureStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerPcmCaptureStorageType.setDescription('This variable represents the storage type value for the dclVsFramerPcmCapture tables.')
dclVsFramerPcmCaptureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 2, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclVsFramerPcmCaptureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsFramerPcmCaptureIndex.setDescription('This variable represents the index for the dclVsFramerPcmCapture tables.')
dclVsLCo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3))
dclVsLCoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 1), )
if mibBuilder.loadTexts: dclVsLCoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRowStatusTable.setDescription('This entry controls the addition and deletion of dclVsLCo components.')
dclVsLCoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsLCoIndex"))
if mibBuilder.loadTexts: dclVsLCoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRowStatusEntry.setDescription('A single entry in the table represents a single dclVsLCo component.')
dclVsLCoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRowStatus.setDescription('This variable is used as the basis for SNMP naming of dclVsLCo components. These components cannot be added nor deleted.')
dclVsLCoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
dclVsLCoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoStorageType.setDescription('This variable represents the storage type value for the dclVsLCo tables.')
dclVsLCoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: dclVsLCoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoIndex.setDescription('This variable represents the index for the dclVsLCo tables.')
dclVsLCoPathDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10), )
if mibBuilder.loadTexts: dclVsLCoPathDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathDataTable.setDescription('This group contains all operational attributes for the path oriented LCo.')
dclVsLCoPathDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsLCoIndex"))
if mibBuilder.loadTexts: dclVsLCoPathDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathDataEntry.setDescription('An entry in the dclVsLCoPathDataTable.')
dclVsLCoState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pathDown", 0), ("selectingRoute", 1), ("connecting", 2), ("pathUp", 3), ("pathDownRetrying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoState.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoState.setDescription('This attribute reflects the current state of the connection. The pathDown state indicates a connection that has no remote end provisioned or the application has not yet signalled for a path. The selectingRoute state occurs when a request has been sent to route selector and it has not yet responded. The connectingState occurs while a path is being established. The pathUp state is the normal operational state of a path. The pathDownRetrying state indicates a path that attempted route selection but received no route and is now waiting to retry route selection again.')
dclVsLCoOverrideRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclVsLCoOverrideRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoOverrideRemoteName.setDescription("If set and the current PLC remoteName is blank this remoteName will override the blank PLC remoteName. Usually you would set this attribute and then lock/unlock the service component which will result in this new overrideRemoteName being used as if it had been provisioned into the PLC remoteName. The advantage of this attribute is that the connection's remoteName can be changed immediately without having to 'activate prov' but the disadvantage is that the overrideRemoteName is not permanent and if the card or switch is reset the override will be lost.")
dclVsLCoEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("calling", 0), ("called", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoEnd.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoEnd.setDescription('This attribute identifies whether this is the calling or called end of the path.')
dclVsLCoCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoCostMetric.setDescription("This attribute gives the route's total cost metric. It is calculated as the sum of the cost metric of all trunks in the path at the time the connection was established. The cost metric of a trunk is defined by the trunkCost attribute of the Trunk component. The costMetric for an LCo that is originated and terminated on the same module is 0.")
dclVsLCoDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoDelayMetric.setDescription('This attribute gives the total delay of the route as the one way delay for a 512 byte packet. It is calculated as the sum of the delays of all trunks in the path stored in topology at the time the connection was established. The delay for an LCo that is originated and terminated on the same module is 0.')
dclVsLCoRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRoundTripDelay.setDescription('This attribute contains the time taken for a packet (cell) of 44 bytes to be transmitted to the remote LCo and return to this LCo. The number reported is given in milliseconds to the nearest millisecond. A value of one millisecond is reported if the time is less than 1 millisecond even though the delay may be less than 1 Millisecond when the LCo is originated and terminated on the same module.')
dclVsLCoSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoSetupPriority.setDescription('This attribute gives the priority at which the current path is established. Zero is the highest priority and four is the lowest. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established.')
dclVsLCoHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoHoldingPriority.setDescription('This attribute gives the priority at which a path holds its current path once the path is established. Zero is the highest priority and four is the lowest. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time.')
dclVsLCoRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRequiredTxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of the trunks of its route. This attribute represents the bandwidth for traffic outgoing to the remote end point. The originating end of the connection determines this value.')
dclVsLCoRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRequiredRxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. The originating end of the connection determines this value')
dclVsLCoRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRequiredTrafficType.setDescription('This operational attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1 then only trunks that include trafficType1 in supportedTrafficType, will be candidates for this connection.')
dclVsLCoPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPermittedTrunkTypes.setDescription("This operational attribute lists up to eight types of trunk that can be used on the route. The originating end of the connection determines the types. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
dclVsLCoRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRequiredSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
dclVsLCoRequiredCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRequiredCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRequiredCustomerParameter.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route.The originating end of the connection determines the customer defined parameter. Its value, a number from zero to seven, is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
dclVsLCoEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. The originating end of the connection selects the emissionPriority. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
dclVsLCoDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path.The originating end of the connection sets discardPriority. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
dclVsLCoPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("manual", 1), ("forced", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPathType.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathType.setDescription('This attribute indicates whether the path for this PLC was determined automatically or by static provisioning. Normal pathTypes are selected automatically by Route Selector.The other pathTypes are both manual pathTypes where the operator must specify, through provisioning, a static route termed the manualPath. A manual pathType connection is nearly identical to a normal path type connection with the exception that the route is pre-provisioned. For a manual pathType, bandwidth reservations are respected along the path exactly as in a normal path. The last type, the forced pathType, is also a manual path but regardless of the bandwidth available the route is granted provided the trunks are operational and there are sufficient Logical Channels (LChs). The forced pathType could result in over committing the reserved bandwidth allowed on a trunk. A better way to achieve the effects of a forced pathType is to use a manual pathType with setupPriority = 0 and holdingPriority = 0. In this manner the path will reserve correct bandwidth and it will bump other paths if required while not being bumped itself.')
dclVsLCoRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoRetryCount.setDescription('This attribute is the count of the number of times the path chosen during route selection could not be instantiated. This count should be three or below if the network is performing adequately. A high value indicates that the route selection is often performed using an out-of-date view of available network bandwidth and/or topology. This attribute will only increase at the calling end of the connection. This attribute is reset each time a path reconnects and stops counting when it reaches its maximum value.')
dclVsLCoPathFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPathFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathFailureCount.setDescription('This attribute is the count of the number of times the path has successfully connected. It is set to zero the first time the path is up. If a path fails anytime after connecting this count will be incremented when the path is up again. Failed route requests do not count in this statistic. See retryCount above. This attribute stops counting at its maximum value.')
dclVsLCoReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routesDelayTooLong", 10), ("attributesNotMet", 11), ("anError", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoReasonForNoRoute.setDescription("This attribute is the route selection's reasonForNoRoute and provides a brief reason for which a route was not selected. The reasons are essentially self-explanatory. Perhaps two reasons for no route require some explanation. The reason unknownRemoteNodeName is issued when the remote node name is not in the topological database. The reason plcAttributesNotMet is issued when there is no network connectivity at a level specified by the PLC attributes. This reason is also issued when there is no physical connectivity between two end nodes.")
dclVsLCoLastTearDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("none", 0), ("normalShutDown", 1), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("wrongModuleReached", 11), ("farEndBusy", 12), ("callLoopedBack", 13), ("unknownReason", 14), ("farEndNotReady", 15), ("remoteNameMismatch", 16), ("serviceTypeMismatch", 17), ("reconnectFromFarEnd", 18), ("bumped", 19), ("accessCardFailure", 20), ("optimized", 21), ("overrideRemoteName", 22), ("trunkOrFarEndDidNotSupportMode", 23))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoLastTearDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoLastTearDownReason.setDescription("This attribute reflects the last tear down reason for a connection (LCo). In many cases this displays the reason for a momentary service interruption. This attribute applies to the last path failure only. If a path is no longer up, this may give an indication to the reason that the path has failed. In many cases an alarm will also be generated with more specific information. The following is a brief description of the reasons: none - This path has no information for the teardown this is typical of a path provisioned with no remoteName that has not been up. normalShutDown - This path has gone down due to normal call termination. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the transmit direction. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the receive direction. trunkFailure- A trunk on the path has failed or has gone down due to a provisioning change of a critical attribute. trunkCardFailure- A trunk FP card has failed along the path. accessCardFailure- The FP on which the peer access service was running has failed. operatorForced- The path has terminated due to the operator locking a trunk along the path. lostLcnClash- The path has terminated because the PA's at both ends of an intermediate trunk have allocated the same LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different LC's). It is normal to get the odd clash especially when the PA's usedLC is approaching the PA's maxLC. networkCongestion - The path has failed due to control information being lost and not recoverable. trunkNotFound - Occurs on a manual path usually. Check for trunks not up or names provisioned incorrectly. farEndNotFound - The far end is not provisioned or is not up. Check remote Name. wrongModuleReached - This may occur on a manual path. Check provisioning for correct trunk and service names. For a normal path, the network Topology may be changing check remoteName. farEndBusy - The far end has been reached but it is busy. Check remoteName and remote end provisioning. callLoopedBack - This LCo is provisioned to call itself. Re- provision since this is invalid. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. remoteNameMismatch - The remote end has alarmed and rejected this setup due to remoteName provisioning. serviceTypeMismatch - The remote Service Type does not match this service type. Check provisioning. reconnectFromFarEnd - The remote end re-established this connection. Check the remote end lastTearDownReason to determine the real reason. bumped - Another call bumped this path from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority hence it was allowed to steal the bandwidth (or LC) from this path. optimized - This call has been rerouted due to the optimization feature. The call is still active this just indicates why the path changed. trunkOrFarEndDidNotSupportMode - This call was unable to complete because a mode required by the service was not supported by one of the trunks the route went through or by the far end service it connected to. Currently the only mode that this applies to is the map/mux mode on TRUNK PA ATM component. Map mode was required by the application (CES/FrAtm etc.) but was not available on the TRUNK PA ATM component through which the call was routed or the far end CES/FrAtm component did not specify the same mode.")
dclVsLCoPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathFailureAction.setDescription('This attribute displays whether the application is set to tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is displayed, the application is informed as soon as possible about a failure by disconnection. If the attribute displays reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends')
dclVsLCoBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoBumpPreference.setDescription("This attribute specifies when bumping will occur during route selection process. Bumping may occur when necessary or always. It will be necessary for a connection to bump if there is not enough resources for the connection to be established and these resources are occupied by a connection whose setupPriority is lower (numerically higher) than the connection's setupPriority. A connection may also always bump in order to obtain the best route.")
dclVsLCoOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
dclVsLCoPathUpDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 10, 1, 25), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPathUpDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathUpDateTime.setDescription('This is the time stamp when the current path was established or reestablished.')
dclVsLCoStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 11), )
if mibBuilder.loadTexts: dclVsLCoStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoStatsTable.setDescription('This group contains the operational statistics attributes for the path oriented LCo.')
dclVsLCoStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsLCoIndex"))
if mibBuilder.loadTexts: dclVsLCoStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoStatsEntry.setDescription('An entry in the dclVsLCoStatsTable.')
dclVsLCoPktsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPktsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPktsToNetwork.setDescription('This attribute counts the number of packets transmitted to the network over this Logical Connection.')
dclVsLCoBytesToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoBytesToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoBytesToNetwork.setDescription('This attribute counts the number of bytes sent to the network over this Logical Connection.')
dclVsLCoPktsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPktsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPktsFromNetwork.setDescription('This attribute counts the number of packets received from the remote LCo via the network.')
dclVsLCoBytesFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoBytesFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoBytesFromNetwork.setDescription('This attribute counts the number of bytes received from the remote LCo via the network.')
dclVsLCoPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 264), )
if mibBuilder.loadTexts: dclVsLCoPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathTable.setDescription('This attribute contains the trunk component names over which the path has been instantiated and the remote end point name terminating the path.')
dclVsLCoPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 264, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-DcmeMIB", "dclIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsLCoIndex"), (0, "Nortel-Magellan-Passport-DcmeMIB", "dclVsLCoPathValue"))
if mibBuilder.loadTexts: dclVsLCoPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathEntry.setDescription('An entry in the dclVsLCoPathTable.')
dclVsLCoPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 130, 4, 3, 264, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclVsLCoPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: dclVsLCoPathValue.setDescription('This variable represents both the value and the index for the dclVsLCoPathTable.')
dcmeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 1))
dcmeGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 1, 5))
dcmeGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 1, 5, 2))
dcmeGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 1, 5, 2, 2))
dcmeCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 3))
dcmeCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 3, 5))
dcmeCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 3, 5, 2))
dcmeCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 134, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-DcmeMIB", dcmeDLinksRowStatus=dcmeDLinksRowStatus, dclFramer=dclFramer, dclVsFramerMvpDebugRowStatusEntry=dclVsFramerMvpDebugRowStatusEntry, dclRowStatusEntry=dclRowStatusEntry, dcmeProfileRequiredSecurity=dcmeProfileRequiredSecurity, dcmeProfileMinModemFaxG711G726Rate=dcmeProfileMinModemFaxG711G726Rate, dcmeProfileRowStatusEntry=dcmeProfileRowStatusEntry, dclStateTable=dclStateTable, dcmeMaxUnrestricted64kCalls=dcmeMaxUnrestricted64kCalls, dclDnaIndex=dclDnaIndex, dclUsageState=dclUsageState, dclVsOperEntry=dclVsOperEntry, dclVsFramerMvpDebugStorageType=dclVsFramerMvpDebugStorageType, dclRejected3kHzCalls=dclRejected3kHzCalls, dclVsFramerFaxRelayCells=dclVsFramerFaxRelayCells, dcmeProfileLCOpsEntry=dcmeProfileLCOpsEntry, dclVsFramerRowStatusTable=dclVsFramerRowStatusTable, dclVsFramerFrmToNetworkEntry=dclVsFramerFrmToNetworkEntry, dclVsFramerVfpDebugComponentName=dclVsFramerVfpDebugComponentName, dclVsFramerMvpDebug=dclVsFramerMvpDebug, dclFramerRowStatus=dclFramerRowStatus, dcmePreestablishedConnections=dcmePreestablishedConnections, dcmeProfileMaximumAcceptableCost=dcmeProfileMaximumAcceptableCost, dclDnaRowStatusEntry=dclDnaRowStatusEntry, dclVsLCoRowStatus=dclVsLCoRowStatus, dcmeDLinksValue=dcmeDLinksValue, dcmeRowStatusTable=dcmeRowStatusTable, dclVsFramerNRatesRateIndex=dclVsFramerNRatesRateIndex, dclProvTable=dclProvTable, dcmeProfileBumpPreference=dcmeProfileBumpPreference, dclVsFramerMvpDebugRowStatusTable=dclVsFramerMvpDebugRowStatusTable, dclIdlePattern=dclIdlePattern, dclVsFramerFrmFromNetworkTable=dclVsFramerFrmFromNetworkTable, dcmeIndex=dcmeIndex, dclVsRowStatusEntry=dclVsRowStatusEntry, dclVsStatsEntry=dclVsStatsEntry, dclVsFramerPcmCaptureStorageType=dclVsFramerPcmCaptureStorageType, dclVsLCoHoldingPriority=dclVsLCoHoldingPriority, dclVsFramerVfpDebugRowStatusTable=dclVsFramerVfpDebugRowStatusTable, dclRemoteDna=dclRemoteDna, dclVsLCoStatsTable=dclVsLCoStatsTable, dcmeProfileMaximumAcceptableDelay=dcmeProfileMaximumAcceptableDelay, dclVsFramerFrmToNetworkIndex=dclVsFramerFrmToNetworkIndex, dcmeProfileMinVoiceBitRate=dcmeProfileMinVoiceBitRate, dclVsFramerPcmCaptureRowStatusEntry=dclVsFramerPcmCaptureRowStatusEntry, dcmeGroupBE01=dcmeGroupBE01, dcmeMIB=dcmeMIB, dclVsTransmittedAbBits=dclVsTransmittedAbBits, dclVsFramerFrmDumped=dclVsFramerFrmDumped, dcmeCapabilities=dcmeCapabilities, dcmeProfile=dcmeProfile, dclVsFramerComponentName=dclVsFramerComponentName, dclVsFramerNegotiatedTandemPassThrough=dclVsFramerNegotiatedTandemPassThrough, dclVsFramerFrmFromNetworkIndex=dclVsFramerFrmFromNetworkIndex, dcmeProfileEchoCancellation=dcmeProfileEchoCancellation, dclVsLCoRequiredCustomerParameter=dclVsLCoRequiredCustomerParameter, dcmeProvTable=dcmeProvTable, dcmeProfileEmissionPriority=dcmeProfileEmissionPriority, dclFramerRowStatusEntry=dclFramerRowStatusEntry, dclVsComponentName=dclVsComponentName, dclVsFramerFrmToNetworkValue=dclVsFramerFrmToNetworkValue, dclStateEntry=dclStateEntry, dclStatsEntry=dclStatsEntry, dcmeProfilePathAttributeToMinimize=dcmeProfilePathAttributeToMinimize, dclVsProvTable=dclVsProvTable, dclVsFramerCurrentEncoding=dclVsFramerCurrentEncoding, dclVsLCoEnd=dclVsLCoEnd, dclVsLCoPathUpDateTime=dclVsLCoPathUpDateTime, dclVsFramerInterfaceName=dclVsFramerInterfaceName, dclVsFramerProvEntry=dclVsFramerProvEntry, dclAdminState=dclAdminState, dclVsLCoLastTearDownReason=dclVsLCoLastTearDownReason, dclRejectedSpeechCalls=dclRejectedSpeechCalls, dcmeProfileRowStatusTable=dcmeProfileRowStatusTable, dclVsFramerFrmUnderRuns=dclVsFramerFrmUnderRuns, dclVsFramerNegotiatedDtmfRegeneration=dclVsFramerNegotiatedDtmfRegeneration, dclVsLCoBumpPreference=dclVsLCoBumpPreference, dclComponentName=dclComponentName, dclVsFramerNEncodingValue=dclVsFramerNEncodingValue, dclVsFramerVfpDebugStorageType=dclVsFramerVfpDebugStorageType, dclVsFramerTotalCells=dclVsFramerTotalCells, dcmeStateTable=dcmeStateTable, dclVsFramerTptStatus=dclVsFramerTptStatus, dclVsFramerModemSilenceCells=dclVsFramerModemSilenceCells, dcmeProfileEgressAudioGain=dcmeProfileEgressAudioGain, dclVsFramerModemCells=dclVsFramerModemCells, dclVsFramerNegTable=dclVsFramerNegTable, dclVsFramerVfpDebugRowStatusEntry=dclVsFramerVfpDebugRowStatusEntry, dcmeOperationalState=dcmeOperationalState, dclCommentText=dclCommentText, dclVsFramerRowStatus=dclVsFramerRowStatus, dclVsLCo=dclVsLCo, dclVsLCoOptimization=dclVsLCoOptimization, dclVsLCoBytesToNetwork=dclVsLCoBytesToNetwork, dcmeProfileMaxModemFaxG711G726Rate=dcmeProfileMaxModemFaxG711G726Rate, dcmeProfileIndex=dcmeProfileIndex, dclVsOperTable=dclVsOperTable, dcmeStatsEntry=dcmeStatsEntry, dclFramerRowStatusTable=dclFramerRowStatusTable, dclVsLCoIndex=dclVsLCoIndex, dclVsLCoDiscardPriority=dclVsLCoDiscardPriority, dclVsFramerSilenceCells=dclVsFramerSilenceCells, dclStorageType=dclStorageType, dclVsFramerStateEntry=dclVsFramerStateEntry, dcmeDLinksEntry=dcmeDLinksEntry, dclVsFramerRowStatusEntry=dclVsFramerRowStatusEntry, dclVsFramerOperEntry=dclVsFramerOperEntry, dcmeProfileModemFaxEncoding=dcmeProfileModemFaxEncoding, dclVsFramerFrmFromNetworkEntry=dclVsFramerFrmFromNetworkEntry, dclVsFramerPcmCaptureIndex=dclVsFramerPcmCaptureIndex, dclVsLCoCostMetric=dclVsLCoCostMetric, dclDnaAddressEntry=dclDnaAddressEntry, dclVsLCoEmissionPriority=dclVsLCoEmissionPriority, dclVsLCoPktsFromNetwork=dclVsLCoPktsFromNetwork, dclVsLCoPathDataEntry=dclVsLCoPathDataEntry, dcmeComponentName=dcmeComponentName, dclVsTotalCallSeconds=dclVsTotalCallSeconds, dclVsLCoOverrideRemoteName=dclVsLCoOverrideRemoteName, dclVsLCoRequiredTrafficType=dclVsLCoRequiredTrafficType, dcmeProfileStorageType=dcmeProfileStorageType, dclVsLCoRequiredRxBandwidth=dclVsLCoRequiredRxBandwidth, dcmeCapabilitiesBE01=dcmeCapabilitiesBE01, dclActiveSpeechCalls=dclActiveSpeechCalls, dclVsTotalCalls=dclVsTotalCalls, dcmeProfileFrOpsTable=dcmeProfileFrOpsTable, dclFramerProvTable=dclFramerProvTable, dclVsFramerMvpDebugComponentName=dclVsFramerMvpDebugComponentName, dcmeProfileMaxVoiceBitRate=dcmeProfileMaxVoiceBitRate, dclVsFramerNEncodingEntry=dclVsFramerNEncodingEntry, dcmeGroup=dcmeGroup, dclVsFramerPcmCaptureComponentName=dclVsFramerPcmCaptureComponentName, dcmeProfileVoiceEncoding=dcmeProfileVoiceEncoding, dcmeProfileSetupPriority=dcmeProfileSetupPriority, dclVsFramerStatsTable=dclVsFramerStatsTable, dclIndex=dclIndex, dclDnaDataNetworkAddress=dclDnaDataNetworkAddress, dclVsFramerFrmLostInNetwork=dclVsFramerFrmLostInNetwork, dcmeTrmSpeechNotAvailable=dcmeTrmSpeechNotAvailable, dclFramerStateTable=dclFramerStateTable, dcmeProvEntry=dcmeProvEntry, dcmeSpeechAlarmThreshold=dcmeSpeechAlarmThreshold, dclActive64kCalls=dclActive64kCalls, dclFramerIndex=dclFramerIndex, dclActive3kHzCalls=dclActive3kHzCalls, dcmeStorageType=dcmeStorageType, dcmeStatsTable=dcmeStatsTable, dclReceivedTrmSignal=dclReceivedTrmSignal, dclVsLCoRetryCount=dclVsLCoRetryCount, dclVsLCoPathValue=dclVsLCoPathValue, dclFramerAdminState=dclFramerAdminState, dclVsLCoPathFailureCount=dclVsLCoPathFailureCount, dclVsStateEntry=dclVsStateEntry, dclVsFramerUsageState=dclVsFramerUsageState, dcmeProfileRequiredCustomerParm=dcmeProfileRequiredCustomerParm, dclVsFramerNegEntry=dclVsFramerNegEntry, dclVsLCoBytesFromNetwork=dclVsLCoBytesFromNetwork, dclVsFramerLrcErrors=dclVsFramerLrcErrors, dcmeGroupBE01A=dcmeGroupBE01A, dclVsRowStatusTable=dclVsRowStatusTable, dcmeProfileInsertedOutputDelay=dcmeProfileInsertedOutputDelay, dclVsFramerPcmCaptureRowStatusTable=dclVsFramerPcmCaptureRowStatusTable, dcmeCapabilitiesBE01A=dcmeCapabilitiesBE01A, dcmeProfileFrOpsEntry=dcmeProfileFrOpsEntry, dclVsFramerOpTptStatus=dclVsFramerOpTptStatus, dclVsVsType=dclVsVsType, dcmeStateEntry=dcmeStateEntry, dclVsFramer=dclVsFramer, dclVsLCoDelayMetric=dclVsLCoDelayMetric, dclVsFramerFrmToNetworkTable=dclVsFramerFrmToNetworkTable, dclVsLCoPathType=dclVsLCoPathType, dclVsFramerMvpDebugRowStatus=dclVsFramerMvpDebugRowStatus, dclVsFramerOpCurrentEncoding=dclVsFramerOpCurrentEncoding, dcmeProfileRequiredTrafficType=dcmeProfileRequiredTrafficType, dcmeAudio3kHzAlarmThreshold=dcmeAudio3kHzAlarmThreshold, dclFramerUsageState=dclFramerUsageState, dclVsFramerNRatesValue=dclVsFramerNRatesValue, dclVsFramerNRatesTable=dclVsFramerNRatesTable, dclVsFramerNRatesEntry=dclVsFramerNRatesEntry, dcmeActiveDcmeLinksEntry=dcmeActiveDcmeLinksEntry, dcmeCommentText=dcmeCommentText, dcmeProfileFaxIdleSuppressionG711G726=dcmeProfileFaxIdleSuppressionG711G726, dclRowStatus=dclRowStatus, dclTotal64kCalls=dclTotal64kCalls, dcmeProfileComfortNoiseCap=dcmeProfileComfortNoiseCap, dclVsStatsTable=dclVsStatsTable, dclVsFramerAudioCells=dclVsFramerAudioCells, dcmeRowStatus=dcmeRowStatus, dclVsFramerOperTable=dclVsFramerOperTable, dclVsFramerPcmCapture=dclVsFramerPcmCapture, dcmeProfileComponentName=dcmeProfileComponentName, dcmeProfileLCOpsTable=dcmeProfileLCOpsTable, dclVsFramerNegotiatedFisG711G726=dclVsFramerNegotiatedFisG711G726, dclVsFramerModemFaxCells=dclVsFramerModemFaxCells, dclVsFramerVfpDebugRowStatus=dclVsFramerVfpDebugRowStatus, dclFramerInterfaceName=dclFramerInterfaceName, dclOperationalState=dclOperationalState, dclVsFramerFrmFromNetworkValue=dclVsFramerFrmFromNetworkValue, dclRowStatusTable=dclRowStatusTable, dclVsStateTable=dclVsStateTable, dcmeTrm64kNotAvailable=dcmeTrm64kNotAvailable, dclVsFramerOperationalState=dclVsFramerOperationalState, dclFramerStorageType=dclFramerStorageType, dclVsStatus=dclVsStatus, dclDcme=dclDcme, dclFramerProvEntry=dclFramerProvEntry, dcmeAdminState=dcmeAdminState, dcmeUnrestricted64kAlarmThreshold=dcmeUnrestricted64kAlarmThreshold, dcmeDLinksTable=dcmeDLinksTable, dcmeActiveDcmeLinksValue=dcmeActiveDcmeLinksValue, dclDnaStorageType=dclDnaStorageType, dclVsLCoPathFailureAction=dclVsLCoPathFailureAction, dclDnaRowStatus=dclDnaRowStatus, dclVsAdminState=dclVsAdminState, dcmeRowStatusEntry=dcmeRowStatusEntry, dclVsLCoRowStatusEntry=dclVsLCoRowStatusEntry, dclFramerOperationalState=dclFramerOperationalState, dclVsLCoPathTable=dclVsLCoPathTable, dclAlternateIdlePattern=dclAlternateIdlePattern, dclOperEntry=dclOperEntry, dclVsLCoStorageType=dclVsLCoStorageType, dcmeProfileSpeechHangoverTime=dcmeProfileSpeechHangoverTime, dclVsProvEntry=dclVsProvEntry, dclVsFramerNegotiatedV17AsG711G726=dclVsFramerNegotiatedV17AsG711G726, dclVsFramerNRatesTrafficIndex=dclVsFramerNRatesTrafficIndex, dclFramerStateEntry=dclFramerStateEntry, dclVsFramerProvTable=dclVsFramerProvTable, dclVsFramerPcmCaptureRowStatus=dclVsFramerPcmCaptureRowStatus, dclVsLCoSetupPriority=dclVsLCoSetupPriority, dclVsLCoRequiredSecurity=dclVsLCoRequiredSecurity, dclVsOperationalState=dclVsOperationalState, dclRemoteNpi=dclRemoteNpi, dclTransmittedTrmSignal=dclTransmittedTrmSignal, dclVsLCoComponentName=dclVsLCoComponentName, dcmeUsageState=dcmeUsageState, dclStatsTable=dclStatsTable, dcl=dcl, dclVsCallType=dclVsCallType, dcmeProfileIngressAudioGain=dcmeProfileIngressAudioGain, dclDnaAddressTable=dclDnaAddressTable, dclVsFramerFaxIdleCells=dclVsFramerFaxIdleCells, dcmeProfileSilenceSuppression=dcmeProfileSilenceSuppression, dclVsFramerNEncodingIndex=dclVsFramerNEncodingIndex, dcmeProfileDtmfRegeneration=dcmeProfileDtmfRegeneration, dcmeProfileDiscardPriority=dcmeProfileDiscardPriority, dcmeProfileOptimization=dcmeProfileOptimization, dclVsFramerVfpDebugIndex=dclVsFramerVfpDebugIndex, dclVsLCoReasonForNoRoute=dclVsLCoReasonForNoRoute, dclOperTable=dclOperTable, dcmeGroupBE=dcmeGroupBE, dcmeProfileHoldingPriority=dcmeProfileHoldingPriority, dcmeProfileV17EncodedAsG711G726=dcmeProfileV17EncodedAsG711G726, dcmeProfileVoiceTrafficOptimization=dcmeProfileVoiceTrafficOptimization, dcmeCapabilitiesBE=dcmeCapabilitiesBE, dcmeTrmThreshold=dcmeTrmThreshold)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-DcmeMIB", dclVs=dclVs, dcmeProfileSilenceSuppressionFactor=dcmeProfileSilenceSuppressionFactor, dclTotalSpeechCalls=dclTotalSpeechCalls, dclProvEntry=dclProvEntry, dclVsUsageState=dclVsUsageState, dclVsIndex=dclVsIndex, dclVsRowStatus=dclVsRowStatus, dclDna=dclDna, dclVsFramerAdminState=dclVsFramerAdminState, dclVsFramerCurrentRate=dclVsFramerCurrentRate, dclVsLCoPktsToNetwork=dclVsLCoPktsToNetwork, dcmeProfileMaxFaxRelayRate=dcmeProfileMaxFaxRelayRate, dclVsInvalidAbBits=dclVsInvalidAbBits, dclVsLCoPathDataTable=dclVsLCoPathDataTable, dcmeActiveDcmeLinksTable=dcmeActiveDcmeLinksTable, dcmeProfileRowStatus=dcmeProfileRowStatus, dcmeProfilePathFailureAction=dcmeProfilePathFailureAction, dclVsFramerNEncodingTable=dclVsFramerNEncodingTable, dcmeProfileModemFaxSpeechDiscrim=dcmeProfileModemFaxSpeechDiscrim, dcmeProfilePermittedTrunkTypes=dcmeProfilePermittedTrunkTypes, dclVsLCoPathEntry=dclVsLCoPathEntry, dcme=dcme, dclVsLCoState=dclVsLCoState, dclRejected64kCalls=dclRejected64kCalls, dclTotal3kHzCalls=dclTotal3kHzCalls, dclVsFramerIndex=dclVsFramerIndex, dcmeTrmSignalChangeInterval=dcmeTrmSignalChangeInterval, dclVsFramerNegotiatedSilenceSuppression=dclVsFramerNegotiatedSilenceSuppression, dclVsLCoStatsEntry=dclVsLCoStatsEntry, dclVsFramerCurrentEncodingRate=dclVsFramerCurrentEncodingRate, dclInvalidTrmSignals=dclInvalidTrmSignals, dclDnaRowStatusTable=dclDnaRowStatusTable, dcmeAlarmTimeInterval=dcmeAlarmTimeInterval, dclDnaNumberingPlanIndicator=dclDnaNumberingPlanIndicator, dclVsFramerStatsEntry=dclVsFramerStatsEntry, dclFramerComponentName=dclFramerComponentName, dclVsReceivedAbBits=dclVsReceivedAbBits, dclVsStorageType=dclVsStorageType, dclVsFramerVfpDebug=dclVsFramerVfpDebug, dclVsFramerStorageType=dclVsFramerStorageType, dclVsFramerMvpDebugIndex=dclVsFramerMvpDebugIndex, dclVsLCoRowStatusTable=dclVsLCoRowStatusTable, dclVsLCoRequiredTxBandwidth=dclVsLCoRequiredTxBandwidth, dclVsFramerStateTable=dclVsFramerStateTable, dclVsLCoPermittedTrunkTypes=dclVsLCoPermittedTrunkTypes, dclDnaComponentName=dclDnaComponentName, dclVsLCoRoundTripDelay=dclVsLCoRoundTripDelay)

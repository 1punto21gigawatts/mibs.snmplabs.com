#
# PySNMP MIB module ZXTM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZXTM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:48:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, ObjectIdentity, ModuleIdentity, Integer32, Counter64, enterprises, Unsigned32, NotificationType, IpAddress, Gauge32, TimeTicks, NotificationType, MibIdentifier, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "ModuleIdentity", "Integer32", "Counter64", "enterprises", "Unsigned32", "NotificationType", "IpAddress", "Gauge32", "TimeTicks", "NotificationType", "MibIdentifier", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
zeus = MibIdentifier((1, 3, 6, 1, 4, 1, 7146))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1))
zxtm = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2))
globals = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1))
virtualservers = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2))
pools = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3))
nodes = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4))
serviceprotection = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5))
trafficips = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6))
servicelevelmonitoring = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7))
pernodeservicelevelmon = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8))
bandwidthmgt = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9))
connratelimit = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10))
extra = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 11))
netinterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12))
events = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 13))
actions = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 14))
zxtmtraps = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15))
persistence = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 16))
cache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17))
webcache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1))
sslcache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2))
aspsessioncache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3))
ipsessioncache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4))
j2eesessioncache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5))
unisessioncache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6))
sslsessioncache = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7))
rules = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18))
monitors = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 19))
licensekeys = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 20))
zxtms = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 21))
trapobjects = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 22))
cloudcredentials = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23))
glbservices = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24))
perlocationservices = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25))
locations = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26))
listenips = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27))
authenticators = MibIdentifier((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28))
version = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: version.setStatus('mandatory')
if mibBuilder.loadTexts: version.setDescription('The Zeus Traffic Manager version.')
numberChildProcesses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberChildProcesses.setStatus('mandatory')
if mibBuilder.loadTexts: numberChildProcesses.setDescription('The number of traffic manager child processes.')
upTime = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upTime.setStatus('mandatory')
if mibBuilder.loadTexts: upTime.setDescription('The time (in hundredths of a second) that Zeus software has been operational for (this value will wrap if it has been running for more than 497 days).')
timeLastConfigUpdate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeLastConfigUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: timeLastConfigUpdate.setDescription('The time (in hundredths of a second) since the configuration of traffic manager was updated (this value will wrap if no configuration changes are made for 497 days).')
totalBytesInLo = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBytesInLo.setStatus('mandatory')
if mibBuilder.loadTexts: totalBytesInLo.setDescription('Bytes received by the traffic manager from clients ( low 32bits ).')
totalBytesInHi = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBytesInHi.setStatus('mandatory')
if mibBuilder.loadTexts: totalBytesInHi.setDescription('Bytes received by the traffic manager from clients ( high 32bits ).')
totalBytesOutLo = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBytesOutLo.setStatus('mandatory')
if mibBuilder.loadTexts: totalBytesOutLo.setDescription('Bytes sent by the traffic manager to clients ( low 32bits ).')
totalBytesOutHi = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBytesOutHi.setStatus('mandatory')
if mibBuilder.loadTexts: totalBytesOutHi.setDescription('Bytes sent by the traffic manager to clients ( high 32bits ).')
totalCurrentConn = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: totalCurrentConn.setDescription('Number of TCP connections currently established.')
totalConn = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalConn.setStatus('mandatory')
if mibBuilder.loadTexts: totalConn.setDescription('Total number of TCP connections received.')
totalRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 127), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalRequests.setStatus('mandatory')
if mibBuilder.loadTexts: totalRequests.setDescription('Total number of TCP requests recieved.')
totalTransactions = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 128), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalTransactions.setStatus('mandatory')
if mibBuilder.loadTexts: totalTransactions.setDescription('Total number of TCP requests being processed, after applying TPS limits.')
numberDNSARequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberDNSARequests.setStatus('mandatory')
if mibBuilder.loadTexts: numberDNSARequests.setDescription('Requests for DNS A records (hostname->IP address) made by the traffic manager.')
numberDNSACacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberDNSACacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: numberDNSACacheHits.setDescription("Requests for DNS A records resolved from the traffic manager's local cache.")
numberDNSPTRRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberDNSPTRRequests.setStatus('mandatory')
if mibBuilder.loadTexts: numberDNSPTRRequests.setDescription('Requests for DNS PTR records (IP address->hostname) made by the traffic manager.')
numberDNSPTRCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberDNSPTRCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: numberDNSPTRCacheHits.setDescription("Requests for DNS PTR records resolved from the traffic manager's local cache.")
numberSNMPUnauthorisedRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberSNMPUnauthorisedRequests.setStatus('mandatory')
if mibBuilder.loadTexts: numberSNMPUnauthorisedRequests.setDescription('SNMP requests dropped due to access restrictions.')
numberSNMPBadRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberSNMPBadRequests.setStatus('mandatory')
if mibBuilder.loadTexts: numberSNMPBadRequests.setDescription('Malformed SNMP requests received.')
numberSNMPGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberSNMPGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: numberSNMPGetRequests.setDescription('SNMP GetRequests received.')
numberSNMPGetNextRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberSNMPGetNextRequests.setStatus('mandatory')
if mibBuilder.loadTexts: numberSNMPGetNextRequests.setDescription('SNMP GetNextRequests received.')
sslCipherEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherEncrypts.setDescription('Bytes encrypted with a symmetric cipher.')
sslCipherDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherDecrypts.setDescription('Bytes decrypted with a symmetric cipher.')
sslCipherRC4Encrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherRC4Encrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherRC4Encrypts.setDescription('Bytes encrypted with RC4.')
sslCipherRC4Decrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherRC4Decrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherRC4Decrypts.setDescription('Bytes decrypted with RC4.')
sslCipherDESEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherDESEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherDESEncrypts.setDescription('Bytes encrypted with DES.')
sslCipherDESDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherDESDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherDESDecrypts.setDescription('Bytes decrypted with DES.')
sslCipher3DESEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipher3DESEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipher3DESEncrypts.setDescription('Bytes encrypted with 3DES.')
sslCipher3DESDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipher3DESDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipher3DESDecrypts.setDescription('Bytes decrypted with 3DES.')
sslCipherAESEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherAESEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherAESEncrypts.setDescription('Bytes encrypted with AES.')
sslCipherAESDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherAESDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherAESDecrypts.setDescription('Bytes decrypted with AES.')
sslCipherRSAEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherRSAEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherRSAEncrypts.setDescription('Number of RSA encrypts.')
sslCipherRSADecrypts = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherRSADecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherRSADecrypts.setDescription('Number of RSA decrypts.')
sslCipherRSADecryptsExternal = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherRSADecryptsExternal.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherRSADecryptsExternal.setDescription('Number of external RSA decrypts.')
sslHandshakeSSLv2 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslHandshakeSSLv2.setStatus('mandatory')
if mibBuilder.loadTexts: sslHandshakeSSLv2.setDescription('Number of SSLv2 handshakes.')
sslHandshakeSSLv3 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslHandshakeSSLv3.setStatus('mandatory')
if mibBuilder.loadTexts: sslHandshakeSSLv3.setDescription('Number of SSLv3 handshakes.')
sslHandshakeTLSv1 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslHandshakeTLSv1.setStatus('mandatory')
if mibBuilder.loadTexts: sslHandshakeTLSv1.setDescription('Number of TLSv1.0 handshakes.')
sslClientCertNotSent = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslClientCertNotSent.setStatus('mandatory')
if mibBuilder.loadTexts: sslClientCertNotSent.setDescription('Number of times a client certificate was required but not supplied.')
sslClientCertInvalid = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslClientCertInvalid.setStatus('mandatory')
if mibBuilder.loadTexts: sslClientCertInvalid.setDescription('Number of times a client certificate was invalid.')
sslClientCertExpired = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslClientCertExpired.setStatus('mandatory')
if mibBuilder.loadTexts: sslClientCertExpired.setDescription('Number of times a client certificate has expired.')
sslClientCertRevoked = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslClientCertRevoked.setStatus('mandatory')
if mibBuilder.loadTexts: sslClientCertRevoked.setDescription('Number of times a client certificate was revoked.')
sslSessionIDMemCacheHit = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionIDMemCacheHit.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionIDMemCacheHit.setDescription('Number of times the SSL session id was found in the cache and reused.')
sslSessionIDMemCacheMiss = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionIDMemCacheMiss.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionIDMemCacheMiss.setDescription('Number of times the SSL session id was not found in the cache.')
sslSessionIDDiskCacheHit = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionIDDiskCacheHit.setStatus('deprecated')
if mibBuilder.loadTexts: sslSessionIDDiskCacheHit.setDescription('Number of times the SSL session id was found in the disk cache and reused (deprecated, will always return 0).')
sslSessionIDDiskCacheMiss = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionIDDiskCacheMiss.setStatus('deprecated')
if mibBuilder.loadTexts: sslSessionIDDiskCacheMiss.setDescription('Number of times the SSL session id was not found in the disk cache (deprecated, will always return 0).')
sslHandshakeTLSv11 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslHandshakeTLSv11.setStatus('mandatory')
if mibBuilder.loadTexts: sslHandshakeTLSv11.setDescription('Number of TLSv1.1 handshakes.')
sslConnections = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslConnections.setStatus('mandatory')
if mibBuilder.loadTexts: sslConnections.setDescription('Number of SSL connections negotiated.')
sslCipherRSAEncryptsExternal = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCipherRSAEncryptsExternal.setStatus('mandatory')
if mibBuilder.loadTexts: sslCipherRSAEncryptsExternal.setDescription('Number of external RSA encrypts.')
sysCPUIdlePercent = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 45), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCPUIdlePercent.setStatus('mandatory')
if mibBuilder.loadTexts: sysCPUIdlePercent.setDescription('Percentage of time that the CPUs are idle.')
sysCPUBusyPercent = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 46), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCPUBusyPercent.setStatus('mandatory')
if mibBuilder.loadTexts: sysCPUBusyPercent.setDescription('Percentage of time that the CPUs are busy.')
sysCPUUserBusyPercent = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 47), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCPUUserBusyPercent.setStatus('mandatory')
if mibBuilder.loadTexts: sysCPUUserBusyPercent.setDescription('Percentage of time that the CPUs are busy running user-space code.')
sysCPUSystemBusyPercent = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 48), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCPUSystemBusyPercent.setStatus('mandatory')
if mibBuilder.loadTexts: sysCPUSystemBusyPercent.setDescription('Percentage of time that the CPUs are busy running system code.')
sysFDsFree = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 49), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysFDsFree.setStatus('mandatory')
if mibBuilder.loadTexts: sysFDsFree.setDescription('Number of free file descriptors.')
sysMemTotal = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 50), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMemTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sysMemTotal.setDescription('Total memory (MBytes).')
sysMemFree = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 51), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMemFree.setStatus('mandatory')
if mibBuilder.loadTexts: sysMemFree.setDescription('Free memory (MBytes).')
sysMemInUse = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 52), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMemInUse.setStatus('mandatory')
if mibBuilder.loadTexts: sysMemInUse.setDescription('Memory used (MBytes).')
sysMemBuffered = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMemBuffered.setStatus('mandatory')
if mibBuilder.loadTexts: sysMemBuffered.setDescription('Buffer memory (MBytes).')
sysMemSwapped = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMemSwapped.setStatus('mandatory')
if mibBuilder.loadTexts: sysMemSwapped.setDescription('Amount of swap space in use (MBytes).')
sysMemSwapTotal = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMemSwapTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sysMemSwapTotal.setDescription('Total swap space (MBytes).')
numIdleConnections = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 56), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numIdleConnections.setStatus('mandatory')
if mibBuilder.loadTexts: numIdleConnections.setDescription('Total number of idle HTTP connections to all nodes (used for future HTTP requests).')
dataEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataEntries.setStatus('mandatory')
if mibBuilder.loadTexts: dataEntries.setDescription('Number of entries in the TrafficScript data.get()/set() storage.')
dataMemoryUsage = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 59), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: dataMemoryUsage.setDescription('Number of bytes used in the TrafficScript data.get()/set() storage.')
eventsSeen = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventsSeen.setStatus('mandatory')
if mibBuilder.loadTexts: eventsSeen.setDescription("Events seen by the traffic Manager's event handling process.")
totalDNSResponses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalDNSResponses.setStatus('mandatory')
if mibBuilder.loadTexts: totalDNSResponses.setDescription('Total number of DNS response packets handled.')
totalBadDNSPackets = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBadDNSPackets.setStatus('mandatory')
if mibBuilder.loadTexts: totalBadDNSPackets.setDescription('Total number of malformed DNS response packets encountered from the backend servers.')
totalBackendServerErrors = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBackendServerErrors.setStatus('mandatory')
if mibBuilder.loadTexts: totalBackendServerErrors.setDescription('Total errors returned from the backend servers.')
virtualserverNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverNumber.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverNumber.setDescription('The number of virtual servers.')
virtualserverTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2), )
if mibBuilder.loadTexts: virtualserverTable.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverTable.setDescription('This table gives information and statistics for the virtual servers the traffic manager is hosting.')
virtualserverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: virtualserverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverEntry.setDescription('This defines a row in the virtual servers table.')
virtualserverName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverName.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverName.setDescription('The name of the virtual server.')
virtualserverPort = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverPort.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverPort.setDescription('The port the virtual server listens on.')
virtualserverProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("http", 1), ("https", 2), ("ftp", 3), ("imaps", 4), ("imapv2", 5), ("imapv3", 6), ("imapv4", 7), ("pop3", 8), ("pop3s", 9), ("smtp", 10), ("ldap", 11), ("ldaps", 12), ("telnet", 13), ("sslforwarding", 14), ("udpstreaming", 15), ("udp", 16), ("dns", 17), ("genericserverfirst", 18), ("genericclientfirst", 19), ("dnstcp", 20), ("sipudp", 21), ("siptcp", 22), ("rtsp", 23)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverProtocol.setDescription('The protocol the virtual server is operating.')
virtualserverDefaultTrafficPool = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverDefaultTrafficPool.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverDefaultTrafficPool.setDescription("The virtual server's default pool.")
virtualserverBytesInLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverBytesInLo.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverBytesInLo.setDescription('Bytes received by this virtual server from clients ( low 32bits ).')
virtualserverBytesInHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverBytesInHi.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverBytesInHi.setDescription('Bytes received by this virtual server from clients ( high 32bits ).')
virtualserverBytesOutLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverBytesOutLo.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverBytesOutLo.setDescription('Bytes sent by this virtual server to clients ( low 32bits ).')
virtualserverBytesOutHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverBytesOutHi.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverBytesOutHi.setDescription('Bytes sent by this virtual server to clients ( high 32bits ).')
virtualserverCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverCurrentConn.setDescription('TCP connections currently established to this virtual server.')
virtualserverMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverMaxConn.setDescription('Maximum number of simultaneous TCP connections this virtual server has processed at any one time.')
virtualserverTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverTotalConn.setDescription('Requests received by this virtual server.')
virtualserverDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverDiscard.setDescription('Connections discarded by this virtual server.')
virtualserverDirectReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverDirectReplies.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverDirectReplies.setDescription('Direct replies from this virtual server, without forwarding to a node.')
virtualserverConnectTimedOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverConnectTimedOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverConnectTimedOut.setDescription("Connections closed by this virtual server because the 'connect_timeout' interval was exceeded.")
virtualserverDataTimedOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverDataTimedOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverDataTimedOut.setDescription("Connections closed by this virtual server because the 'timeout' interval was exceeded.")
virtualserverKeepaliveTimedOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverKeepaliveTimedOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverKeepaliveTimedOut.setDescription("Connections closed by this virtual server because the 'keepalive_timeout' interval was exceeded.")
virtualserverUdpTimedOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverUdpTimedOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverUdpTimedOut.setDescription("Connections closed by this virtual server because the 'udp_timeout' interval was exceeded.")
virtualserverTotalDgram = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverTotalDgram.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverTotalDgram.setDescription('UDP datagrams processed by this virtual server.')
virtualserverGzip = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverGzip.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverGzip.setDescription('Responses which have been compressed by content compression.')
virtualserverGzipBytesSavedLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverGzipBytesSavedLo.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverGzipBytesSavedLo.setDescription('Bytes of network traffic saved by content compression ( low 32bits ).')
virtualserverGzipBytesSavedHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverGzipBytesSavedHi.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverGzipBytesSavedHi.setDescription('Bytes of network traffic saved by content compression ( high 32bits ).')
virtualserverHttpRewriteLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverHttpRewriteLocation.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverHttpRewriteLocation.setDescription('HTTP Location headers, supplied by a node, that have been rewritten.')
virtualserverHttpRewriteCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverHttpRewriteCookie.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverHttpRewriteCookie.setDescription('HTTP Set-Cookie headers, supplied by a node, that have been rewritten.')
virtualserverHttpCacheHits = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverHttpCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverHttpCacheHits.setDescription('HTTP responses sent directly from the web cache by this virtual server.')
virtualserverHttpCacheLookups = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverHttpCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverHttpCacheLookups.setDescription('HTTP requests that are looked up in the web cache by this virtual server.')
virtualserverHttpCacheHitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverHttpCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverHttpCacheHitRate.setDescription('Percentage hit rate of the web cache for this virtual server.')
virtualserverSIPTotalCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverSIPTotalCalls.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverSIPTotalCalls.setDescription('Total number of SIP INVITE requests seen by this virtual server.')
virtualserverSIPRejectedRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverSIPRejectedRequests.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverSIPRejectedRequests.setDescription('Number of SIP requests rejected due to them exceeding the maximum amount of memory allocated to the connection.')
virtualserverConnectionErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverConnectionErrors.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverConnectionErrors.setDescription('Number of transaction or protocol errors in this virtual server.')
virtualserverConnectionFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 2, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualserverConnectionFailures.setStatus('mandatory')
if mibBuilder.loadTexts: virtualserverConnectionFailures.setDescription('Number of connection failures in this virtual server.')
poolNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolNumber.setStatus('mandatory')
if mibBuilder.loadTexts: poolNumber.setDescription('The number of pools on this system.')
poolTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2), )
if mibBuilder.loadTexts: poolTable.setStatus('mandatory')
if mibBuilder.loadTexts: poolTable.setDescription('This table provides information and statistics for pools.')
poolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: poolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: poolEntry.setDescription('This defines a row in the pools table.')
poolName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolName.setStatus('mandatory')
if mibBuilder.loadTexts: poolName.setDescription('The name of the pool.')
poolAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("roundrobin", 1), ("weightedRoundRobin", 2), ("perceptive", 3), ("leastConnections", 4), ("fastestResponseTime", 5), ("random", 6), ("weightedLeastConnections", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: poolAlgorithm.setDescription('The load-balancing algorithm the pool uses.')
poolNodes = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolNodes.setStatus('mandatory')
if mibBuilder.loadTexts: poolNodes.setDescription('The number of nodes registered with this pool.')
poolDraining = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolDraining.setStatus('mandatory')
if mibBuilder.loadTexts: poolDraining.setDescription('The number of nodes in this pool which are draining.')
poolFailPool = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolFailPool.setStatus('mandatory')
if mibBuilder.loadTexts: poolFailPool.setDescription("The name of this pool's failure pool.")
poolBytesInLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBytesInLo.setStatus('mandatory')
if mibBuilder.loadTexts: poolBytesInLo.setDescription('Bytes received by this pool from nodes ( low 32bits ).')
poolBytesInHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBytesInHi.setStatus('mandatory')
if mibBuilder.loadTexts: poolBytesInHi.setDescription('Bytes received by this pool from nodes ( high 32bits ).')
poolBytesOutLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBytesOutLo.setStatus('mandatory')
if mibBuilder.loadTexts: poolBytesOutLo.setDescription('Bytes sent by this pool to nodes ( low 32bits ).')
poolBytesOutHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBytesOutHi.setStatus('mandatory')
if mibBuilder.loadTexts: poolBytesOutHi.setDescription('Bytes sent by this pool to nodes ( high 32bits ).')
poolTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolTotalConn.setDescription('Requests sent to this pool.')
poolPersistence = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("ip", 2), ("rule", 3), ("transparent", 4), ("applicationCookie", 5), ("xZeusBackend", 6), ("ssl", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPersistence.setStatus('mandatory')
if mibBuilder.loadTexts: poolPersistence.setDescription('The session persistence method this pool uses')
poolSessionMigrated = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolSessionMigrated.setStatus('mandatory')
if mibBuilder.loadTexts: poolSessionMigrated.setDescription('Sessions migrated to a new node because the desired node was unavailable.')
poolDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: poolDisabled.setDescription('The number of nodes in this pool that are disabled.')
poolState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("active", 1), ("disabled", 2), ("draining", 3), ("unused", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolState.setStatus('mandatory')
if mibBuilder.loadTexts: poolState.setDescription('The state of this pool.')
poolConnsQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolConnsQueued.setStatus('mandatory')
if mibBuilder.loadTexts: poolConnsQueued.setDescription('Total connections currently queued to this pool.')
poolQueueTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolQueueTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: poolQueueTimeouts.setDescription('Total connections that timed-out while queued.')
poolMinQueueTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMinQueueTime.setStatus('mandatory')
if mibBuilder.loadTexts: poolMinQueueTime.setDescription('Minimum time a connection was queued for, over the last second.')
poolMaxQueueTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMaxQueueTime.setStatus('mandatory')
if mibBuilder.loadTexts: poolMaxQueueTime.setDescription('Maximum time a connection was queued for, over the last second.')
poolMeanQueueTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 3, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMeanQueueTime.setStatus('mandatory')
if mibBuilder.loadTexts: poolMeanQueueTime.setDescription('Mean time a connection was queued for, over the last second.')
nodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNumber.setStatus('obsolete')
if mibBuilder.loadTexts: nodeNumber.setDescription('The number of IPv4 nodes on this system.')
nodeTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2), )
if mibBuilder.loadTexts: nodeTable.setStatus('obsolete')
if mibBuilder.loadTexts: nodeTable.setDescription('This table defines all the information for a particular IPv4 node.')
nodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "nodeIPAddress"), (0, "ZXTM-MIB", "nodePort"))
if mibBuilder.loadTexts: nodeEntry.setStatus('obsolete')
if mibBuilder.loadTexts: nodeEntry.setDescription('This defines a row in the IPv4 nodes table.')
nodeIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIPAddress.setStatus('obsolete')
if mibBuilder.loadTexts: nodeIPAddress.setDescription('The IPv4 address of this node.')
nodePort = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePort.setStatus('obsolete')
if mibBuilder.loadTexts: nodePort.setDescription('The port this node listens on.')
nodeHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeHostName.setStatus('obsolete')
if mibBuilder.loadTexts: nodeHostName.setDescription('The resolved name for this node.')
nodeState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alive", 1), ("dead", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeState.setStatus('obsolete')
if mibBuilder.loadTexts: nodeState.setDescription('The state of this node.')
nodeBytesToNodeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeBytesToNodeLo.setStatus('obsolete')
if mibBuilder.loadTexts: nodeBytesToNodeLo.setDescription('Bytes sent to this node ( low 32bits ).')
nodeBytesToNodeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeBytesToNodeHi.setStatus('obsolete')
if mibBuilder.loadTexts: nodeBytesToNodeHi.setDescription('Bytes sent to this node ( high 32bits ).')
nodeBytesFromNodeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeBytesFromNodeLo.setStatus('obsolete')
if mibBuilder.loadTexts: nodeBytesFromNodeLo.setDescription('Bytes received from this node ( low 32bits ).')
nodeBytesFromNodeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeBytesFromNodeHi.setStatus('obsolete')
if mibBuilder.loadTexts: nodeBytesFromNodeHi.setDescription('Bytes received from this node ( high 32bits ).')
nodeCurrentRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCurrentRequests.setStatus('obsolete')
if mibBuilder.loadTexts: nodeCurrentRequests.setDescription('Connections currently established to this node.')
nodeTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeTotalConn.setStatus('obsolete')
if mibBuilder.loadTexts: nodeTotalConn.setDescription('Requests sent to this node.')
nodePooledConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePooledConn.setStatus('obsolete')
if mibBuilder.loadTexts: nodePooledConn.setDescription('Requests that reused an existing pooled/keepalive connection rather than creating a new TCP connection.')
nodeFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeFailures.setStatus('obsolete')
if mibBuilder.loadTexts: nodeFailures.setDescription('Failures of this node.')
nodeNewConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNewConn.setStatus('obsolete')
if mibBuilder.loadTexts: nodeNewConn.setDescription('Requests that created a new connection to this node.')
nodeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeErrors.setStatus('obsolete')
if mibBuilder.loadTexts: nodeErrors.setDescription('Number of timeouts, connection problems and other errors for this node.')
nodeResponseMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeResponseMin.setStatus('obsolete')
if mibBuilder.loadTexts: nodeResponseMin.setDescription('Minimum response time (ms) in the last second for this node.')
nodeResponseMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeResponseMax.setStatus('obsolete')
if mibBuilder.loadTexts: nodeResponseMax.setDescription('Maximum response time (ms) in the last second for this node.')
nodeResponseMean = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeResponseMean.setStatus('obsolete')
if mibBuilder.loadTexts: nodeResponseMean.setDescription('Mean response time (ms) in the last second for this node.')
nodeNumberInet46 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNumberInet46.setStatus('mandatory')
if mibBuilder.loadTexts: nodeNumberInet46.setDescription('The number of nodes on this system (includes IPv4 and IPv6 nodes).')
nodeCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCurrentConn.setStatus('obsolete')
if mibBuilder.loadTexts: nodeCurrentConn.setDescription('Requests currently established to this node. ( does not include idle keepalives ).')
nodeInet46Table = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4), )
if mibBuilder.loadTexts: nodeInet46Table.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46Table.setDescription('This table defines all the information for a particular node (includes IPv4 and IPv6 addresses).')
nodeInet46Entry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1), ).setIndexNames((0, "ZXTM-MIB", "nodeInet46AddressType"), (0, "ZXTM-MIB", "nodeInet46Address"), (0, "ZXTM-MIB", "nodeInet46Port"))
if mibBuilder.loadTexts: nodeInet46Entry.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46Entry.setDescription('This defines a row in the nodes table (includes IPv4 and IPv6 addresses).')
nodeInet46AddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46AddressType.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46AddressType.setDescription('The IP address type of this node.')
nodeInet46Address = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46Address.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46Address.setDescription('The IPv4 or IPv6 address of this node.')
nodeInet46Port = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46Port.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46Port.setDescription('The port this node listens on.')
nodeInet46HostName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46HostName.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46HostName.setDescription('The resolved name for this node.')
nodeInet46State = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alive", 1), ("dead", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46State.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46State.setDescription('The state of this node.')
nodeInet46BytesToNodeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46BytesToNodeLo.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46BytesToNodeLo.setDescription('Bytes sent to this node ( low 32bits ).')
nodeInet46BytesToNodeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46BytesToNodeHi.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46BytesToNodeHi.setDescription('Bytes sent to this node ( high 32bits ).')
nodeInet46BytesFromNodeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46BytesFromNodeLo.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46BytesFromNodeLo.setDescription('Bytes received from this node ( low 32bits ).')
nodeInet46BytesFromNodeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46BytesFromNodeHi.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46BytesFromNodeHi.setDescription('Bytes received from this node ( high 32bits ).')
nodeInet46CurrentRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46CurrentRequests.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46CurrentRequests.setDescription('Active connections established to this node, does not include idle connections.')
nodeInet46TotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46TotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46TotalConn.setDescription('Requests sent to this node.')
nodeInet46PooledConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46PooledConn.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46PooledConn.setDescription('Requests that reused an existing pooled/keepalive connection rather than creating a new TCP connection.')
nodeInet46Failures = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46Failures.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46Failures.setDescription('Failures of this node.')
nodeInet46NewConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46NewConn.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46NewConn.setDescription('Requests that created a new connection to this node.')
nodeInet46Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46Errors.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46Errors.setDescription('Number of timeouts, connection problems and other errors for this node.')
nodeInet46ResponseMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46ResponseMin.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46ResponseMin.setDescription('Minimum response time (ms) in the last second for this node.')
nodeInet46ResponseMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46ResponseMax.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46ResponseMax.setDescription('Maximum response time (ms) in the last second for this node.')
nodeInet46ResponseMean = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46ResponseMean.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46ResponseMean.setDescription('Mean response time (ms) in the last second for this node.')
nodeInet46IdleConns = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46IdleConns.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46IdleConns.setDescription('Number of idle HTTP connections to this node.')
nodeInet46CurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 4, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeInet46CurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: nodeInet46CurrentConn.setDescription('Current connections established to this node, includes idle connections.')
perPoolNodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeNumber.setDescription('The number of nodes on this system.')
perPoolNodeTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6), )
if mibBuilder.loadTexts: perPoolNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeTable.setDescription('This table defines all the information for a particular node in a pool.')
perPoolNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1), ).setIndexNames((0, "ZXTM-MIB", "perPoolNodePoolName"), (0, "ZXTM-MIB", "perPoolNodeNodeAddressType"), (0, "ZXTM-MIB", "perPoolNodeNodeAddress"), (0, "ZXTM-MIB", "perPoolNodeNodePort"))
if mibBuilder.loadTexts: perPoolNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeEntry.setDescription('This defines a row in the perPoolNodes table.')
perPoolNodePoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodePoolName.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodePoolName.setDescription('The name of the pool that this node belongs to.')
perPoolNodeNodeAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeNodeAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeNodeAddressType.setDescription('The IP address type of this node.')
perPoolNodeNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeNodeAddress.setDescription('The IPv4 or IPv6 address of this node.')
perPoolNodeNodePort = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeNodePort.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeNodePort.setDescription('The port that this node listens on.')
perPoolNodeNodeHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeNodeHostName.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeNodeHostName.setDescription('The name for this node provided in the configuration.')
perPoolNodeState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("alive", 1), ("dead", 2), ("unknown", 3), ("draining", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeState.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeState.setDescription('The state of this node.')
perPoolNodeBytesToNodeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeBytesToNodeLo.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeBytesToNodeLo.setDescription('Bytes sent to this node ( low 32bits ).')
perPoolNodeBytesToNodeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeBytesToNodeHi.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeBytesToNodeHi.setDescription('Bytes sent to this node ( high 32bits ).')
perPoolNodeBytesFromNodeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeBytesFromNodeLo.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeBytesFromNodeLo.setDescription('Bytes received from this node ( low 32bits ).')
perPoolNodeBytesFromNodeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeBytesFromNodeHi.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeBytesFromNodeHi.setDescription('Bytes received from this node ( high 32bits ).')
perPoolNodeCurrentRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeCurrentRequests.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeCurrentRequests.setDescription('Active connections established to this node, does not include idle connections.')
perPoolNodeTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeTotalConn.setDescription('Requests sent to this node.')
perPoolNodePooledConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodePooledConn.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodePooledConn.setDescription('Requests that reused an existing pooled/keepalive connection rather than creating a new TCP connection.')
perPoolNodeFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeFailures.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeFailures.setDescription('Failures of this node.')
perPoolNodeNewConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeNewConn.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeNewConn.setDescription('Requests that created a new connection to this node.')
perPoolNodeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeErrors.setDescription('Number of timeouts, connection problems and other errors for this node.')
perPoolNodeResponseMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeResponseMin.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeResponseMin.setDescription('Minimum response time (ms) in the last second for this node.')
perPoolNodeResponseMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeResponseMax.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeResponseMax.setDescription('Maximum response time (ms) in the last second for this node.')
perPoolNodeResponseMean = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeResponseMean.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeResponseMean.setDescription('Mean response time (ms) in the last second for this node.')
perPoolNodeIdleConns = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeIdleConns.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeIdleConns.setDescription('Number of idle HTTP connections to this node.')
perPoolNodeCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 4, 6, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPoolNodeCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: perPoolNodeCurrentConn.setDescription('Current connections established to a node, includes idle connections.')
trafficIPNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPNumber.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPNumber.setDescription('The number of traffic IPv4 addresses on this system.')
trafficIPNumberRaised = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPNumberRaised.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPNumberRaised.setDescription('The number of traffic IPv4 addresses currently raised on this system.')
trafficIPTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 3), )
if mibBuilder.loadTexts: trafficIPTable.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPTable.setDescription('This table details the traffic IPv4 addresses that are hosted by this traffic manager cluster.')
trafficIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 3, 1), ).setIndexNames((0, "ZXTM-MIB", "trafficIPAddress"))
if mibBuilder.loadTexts: trafficIPEntry.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPEntry.setDescription('This defines a row in the IPv4 traffic IP table.')
trafficIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPAddress.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPAddress.setDescription('This is a traffic IP address.')
trafficIPState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("raised", 1), ("lowered", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPState.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPState.setDescription('Whether this traffic IP address is currently being hosted by this traffic manager.')
trafficIPTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPTime.setStatus('obsolete')
if mibBuilder.loadTexts: trafficIPTime.setDescription("The time (in hundredths of a second) since trafficIPState last changed (this value will wrap if the state hasn't changed for 497 days).")
trafficIPGatewayPingRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPGatewayPingRequests.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPGatewayPingRequests.setDescription('Number of ping requests sent to the gateway machine.')
trafficIPGatewayPingResponses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPGatewayPingResponses.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPGatewayPingResponses.setDescription('Number of ping responses received from the gateway machine.')
trafficIPNodePingRequests = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPNodePingRequests.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPNodePingRequests.setDescription('Number of ping requests sent to the backend nodes.')
trafficIPNodePingResponses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPNodePingResponses.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPNodePingResponses.setDescription('Number of ping responses received from the backend nodes.')
trafficIPPingResponseErrors = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPPingResponseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPPingResponseErrors.setDescription('Number of ping response errors.')
trafficIPARPMessage = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPARPMessage.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPARPMessage.setDescription('Number of ARP messages sent for raised Traffic IP Addresses.')
trafficIPNumberInet46 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPNumberInet46.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPNumberInet46.setDescription('The number of traffic IP addresses on this system (includes IPv4 and IPv6 addresses).')
trafficIPNumberRaisedInet46 = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPNumberRaisedInet46.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPNumberRaisedInet46.setDescription('The number of traffic IP addresses currently raised on this system (includes IPv4 and IPv6 addresses).')
trafficIPInet46Table = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 12), )
if mibBuilder.loadTexts: trafficIPInet46Table.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPInet46Table.setDescription('This table details the traffic IP addresses that are hosted by this traffic manager cluster (includes IPv4 and IPv6 addresses).')
trafficIPInet46Entry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 12, 1), ).setIndexNames((0, "ZXTM-MIB", "trafficIPInet46AddressType"), (0, "ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: trafficIPInet46Entry.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPInet46Entry.setDescription('This defines a row in the traffic IP table.')
trafficIPInet46AddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 12, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPInet46AddressType.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPInet46AddressType.setDescription('The traffic IP address type.')
trafficIPInet46Address = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 12, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPInet46Address.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPInet46Address.setDescription('This is a traffic IP address.')
trafficIPInet46State = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("raised", 1), ("lowered", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPInet46State.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPInet46State.setDescription('Whether this traffic IP address is currently being hosted by this traffic manager.')
trafficIPInet46Time = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 6, 12, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficIPInet46Time.setStatus('mandatory')
if mibBuilder.loadTexts: trafficIPInet46Time.setDescription("The time (in hundredths of a second) since trafficIPState last changed (this value will wrap if the state hasn't changed for 497 days).")
serviceProtNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtNumber.setDescription('The number of service protection classes defined.')
serviceProtTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2), )
if mibBuilder.loadTexts: serviceProtTable.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtTable.setDescription('This table provides information and statistics for service protection classes.')
serviceProtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "serviceProtName"))
if mibBuilder.loadTexts: serviceProtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtEntry.setDescription('This defines a row in the service protection table.')
serviceProtName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtName.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtName.setDescription('The name of the service protection class.')
serviceProtTotalRefusal = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtTotalRefusal.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtTotalRefusal.setDescription('Connections refused by this service protection class.')
serviceProtLastRefusalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtLastRefusalTime.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtLastRefusalTime.setDescription('The time (in hundredths of a second) since this service protection class last refused a connection (this value will wrap if no connections are refused in more than 497 days).')
serviceProtRefusalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalIP.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalIP.setDescription('Connections refused by this service protection class because the source IP address was banned.')
serviceProtRefusalConc1IP = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalConc1IP.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalConc1IP.setDescription('Connections refused by this service protection class because the source IP address issued too many concurrent connections.')
serviceProtRefusalConc10IP = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalConc10IP.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalConc10IP.setDescription('Connections refused by this service protection class because the top 10 source IP addresses issued too many concurrent connections.')
serviceProtRefusalConnRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalConnRate.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalConnRate.setDescription('Connections refused by this service protection class because the source IP address issued too many connections within 60 seconds.')
serviceProtRefusalRFC2396 = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalRFC2396.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalRFC2396.setDescription('Connections refused by this service protection class because the HTTP request was not RFC 2396 compliant.')
serviceProtRefusalSize = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalSize.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalSize.setDescription('Connections refused by this service protection class because the request was larger than the defined limits allowed.')
serviceProtRefusalBinary = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 5, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceProtRefusalBinary.setStatus('mandatory')
if mibBuilder.loadTexts: serviceProtRefusalBinary.setDescription('Connections refused by this service protection class because the request contained disallowed binary content.')
serviceLevelNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelNumber.setDescription('The number of SLM classes defined.')
serviceLevelTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2), )
if mibBuilder.loadTexts: serviceLevelTable.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelTable.setDescription('This table provides information and statistics for SLM classes.')
serviceLevelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "serviceLevelName"))
if mibBuilder.loadTexts: serviceLevelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelEntry.setDescription('This defines a row in the SLM table.')
serviceLevelName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelName.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelName.setDescription('The name of the SLM class.')
serviceLevelTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelTotalConn.setDescription('Requests handled by this SLM class.')
serviceLevelTotalNonConf = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelTotalNonConf.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelTotalNonConf.setDescription('Non-conforming requests handled by this SLM class.')
serviceLevelResponseMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelResponseMin.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelResponseMin.setDescription('Minimum response time (ms) in the last second for this SLM class.')
serviceLevelResponseMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelResponseMax.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelResponseMax.setDescription('Maximum response time (ms) in the last second for this SLM class.')
serviceLevelResponseMean = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelResponseMean.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelResponseMean.setDescription('Mean response time (ms) in the last second for this SLM class.')
serviceLevelIsOK = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notok", 1), ("ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelIsOK.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelIsOK.setDescription('Indicates if this SLM class is currently conforming.')
serviceLevelConforming = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelConforming.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelConforming.setDescription('Percentage of requests associated with this SLM class that are conforming')
serviceLevelCurrentConns = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 7, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceLevelCurrentConns.setStatus('mandatory')
if mibBuilder.loadTexts: serviceLevelCurrentConns.setDescription('The number of connections currently associated with this SLM class.')
perNodeServiceLevelTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1), )
if mibBuilder.loadTexts: perNodeServiceLevelTable.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelTable.setDescription('This table provides information and statistics for SLM classes on a per node basis (IPv4 nodes only).')
perNodeServiceLevelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1), ).setIndexNames((0, "ZXTM-MIB", "perNodeServiceLevelSLMName"), (0, "ZXTM-MIB", "perNodeServiceLevelNodeIPAddr"), (0, "ZXTM-MIB", "perNodeServiceLevelNodePort"))
if mibBuilder.loadTexts: perNodeServiceLevelEntry.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelEntry.setDescription('This defines a row in the per-node SLM table (IPv4 nodes only).')
perNodeServiceLevelSLMName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelSLMName.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelSLMName.setDescription('The name of the SLM class.')
perNodeServiceLevelNodeIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelNodeIPAddr.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelNodeIPAddr.setDescription('The IP address of this node.')
perNodeServiceLevelNodePort = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelNodePort.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelNodePort.setDescription('The port number of this node.')
perNodeServiceLevelTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelTotalConn.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelTotalConn.setDescription('Requests handled by this SLM class to this node.')
perNodeServiceLevelTotalNonConf = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelTotalNonConf.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelTotalNonConf.setDescription('Non-conforming requests handled by this SLM class to this node.')
perNodeServiceLevelResponseMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelResponseMin.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelResponseMin.setDescription('Minimum response time (ms) in the last second for this SLM class to this node.')
perNodeServiceLevelResponseMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelResponseMax.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelResponseMax.setDescription('Maximum response time (ms) in the last second for this SLM class to this node.')
perNodeServiceLevelResponseMean = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelResponseMean.setStatus('obsolete')
if mibBuilder.loadTexts: perNodeServiceLevelResponseMean.setDescription('Mean response time (ms) in the last second for this SLM class to this node.')
perNodeServiceLevelInet46Table = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2), )
if mibBuilder.loadTexts: perNodeServiceLevelInet46Table.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46Table.setDescription('This table provides information and statistics for SLM classes on a per node basis (includes IPv4 and IPv6 nodes).')
perNodeServiceLevelInet46Entry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "perNodeServiceLevelInet46SLMName"), (0, "ZXTM-MIB", "perNodeServiceLevelInet46NodeAddressType"), (0, "ZXTM-MIB", "perNodeServiceLevelInet46NodeAddress"), (0, "ZXTM-MIB", "perNodeServiceLevelInet46NodePort"))
if mibBuilder.loadTexts: perNodeServiceLevelInet46Entry.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46Entry.setDescription('This defines a row in the per-node SLM table (includes IPv4 and IPv6 nodes).')
perNodeServiceLevelInet46SLMName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46SLMName.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46SLMName.setDescription('The name of the SLM class.')
perNodeServiceLevelInet46NodeAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46NodeAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46NodeAddressType.setDescription('The type of IP address of this node.')
perNodeServiceLevelInet46NodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46NodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46NodeAddress.setDescription('The IP address of this node.')
perNodeServiceLevelInet46NodePort = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46NodePort.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46NodePort.setDescription('The port number of this node.')
perNodeServiceLevelInet46TotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46TotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46TotalConn.setDescription('Requests handled by this SLM class to this node.')
perNodeServiceLevelInet46TotalNonConf = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46TotalNonConf.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46TotalNonConf.setDescription('Non-conforming requests handled by this SLM class to this node.')
perNodeServiceLevelInet46ResponseMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46ResponseMin.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46ResponseMin.setDescription('Minimum response time (ms) in the last second for this SLM class to this node.')
perNodeServiceLevelInet46ResponseMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46ResponseMax.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46ResponseMax.setDescription('Maximum response time (ms) in the last second for this SLM class to this node.')
perNodeServiceLevelInet46ResponseMean = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 8, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perNodeServiceLevelInet46ResponseMean.setStatus('mandatory')
if mibBuilder.loadTexts: perNodeServiceLevelInet46ResponseMean.setDescription('Mean response time (ms) in the last second for this SLM class to this node.')
bandwidthClassNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthClassNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassNumber.setDescription('The number of bandwidth classes defined.')
bandwidthClassTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2), )
if mibBuilder.loadTexts: bandwidthClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassTable.setDescription('This table provides information and statistics for bandwidth classes.')
bandwidthClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "bandwidthClassName"))
if mibBuilder.loadTexts: bandwidthClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassEntry.setDescription('This defines a row in the bandwidth class.')
bandwidthClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthClassName.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassName.setDescription('The name of the bandwidth class.')
bandwidthClassMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthClassMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassMaximum.setDescription('Maximum bandwidth class limit (kbits/s).')
bandwidthClassGuarantee = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthClassGuarantee.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassGuarantee.setDescription('Guaranteed bandwidth class limit (kbits/s). Currently unused.')
bandwidthClassBytesOutLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthClassBytesOutLo.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassBytesOutLo.setDescription('Bytes output by connections assigned to this bandwidth class ( low 32bits ).')
bandwidthClassBytesOutHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 9, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthClassBytesOutHi.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthClassBytesOutHi.setDescription('Bytes output by connections assigned to this bandwidth class ( high 32bits ).')
rateClassNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassNumber.setDescription('The number of rate classes defined.')
rateClassTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2), )
if mibBuilder.loadTexts: rateClassTable.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassTable.setDescription('This table provides information and statistics for rate classes.')
rateClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "rateClassName"))
if mibBuilder.loadTexts: rateClassEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassEntry.setDescription('This defines a row in the rate class info.')
rateClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassName.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassName.setDescription('The name of the rate class.')
rateClassMaxRatePerMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassMaxRatePerMin.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassMaxRatePerMin.setDescription('The maximum rate that requests may pass through this rate class (requests/min).')
rateClassMaxRatePerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassMaxRatePerSec.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassMaxRatePerSec.setDescription('The maximum rate that requests may pass through this rate class (requests/sec).')
rateClassQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassQueueLength.setDescription('The current number of requests queued by this rate class.')
rateClassCurrentRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassCurrentRate.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassCurrentRate.setDescription('The average rate that requests are passing through this rate class.')
rateClassDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassDropped.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassDropped.setDescription('Requests dropped from this rate class without being processed (e.g. timeouts).')
rateClassConnsEntered = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassConnsEntered.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassConnsEntered.setDescription('Connections that have entered the rate class and have been queued.')
rateClassConnsLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 10, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateClassConnsLeft.setStatus('mandatory')
if mibBuilder.loadTexts: rateClassConnsLeft.setDescription('Connections that have left the rate class.')
userCounterNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 11, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: userCounterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: userCounterNumber.setDescription('The number of user defined counters.')
userCounterTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 11, 2), )
if mibBuilder.loadTexts: userCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: userCounterTable.setDescription('This table holds the values for user defined counters.')
userCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 11, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "userCounterName"))
if mibBuilder.loadTexts: userCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: userCounterEntry.setDescription('This defines a row in the user counters table.')
userCounterName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 11, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userCounterName.setStatus('mandatory')
if mibBuilder.loadTexts: userCounterName.setDescription('The name of the user counter.')
userCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 11, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: userCounterValue.setStatus('mandatory')
if mibBuilder.loadTexts: userCounterValue.setDescription('The value of the user counter.')
interfaceNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNumber.setDescription('The number of network interfaces.')
interfaceTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2), )
if mibBuilder.loadTexts: interfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTable.setDescription('This table gives statistics for the network interfaces on this system.')
interfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "interfaceName"))
if mibBuilder.loadTexts: interfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceEntry.setDescription('This defines a row in the network interfaces table.')
interfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceName.setDescription('The name of the network interface.')
interfaceRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceRxPackets.setDescription('The number of packets received by this interface.')
interfaceTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTxPackets.setDescription('The number of packets transmitted by this interface.')
interfaceRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceRxErrors.setDescription('The number of receive errors reported by this interface.')
interfaceTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceTxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTxErrors.setDescription('The number of transmit errors reported by this interface.')
interfaceCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceCollisions.setDescription('The number of collisions reported by this interface.')
interfaceRxBytesLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceRxBytesLo.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceRxBytesLo.setDescription('Bytes received by this interface ( low 32bits ).')
interfaceRxBytesHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceRxBytesHi.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceRxBytesHi.setDescription('Bytes received by this interface ( high 32bits ).')
interfaceTxBytesLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceTxBytesLo.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTxBytesLo.setDescription('Bytes transmitted by this interface ( low 32bits ).')
interfaceTxBytesHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 12, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceTxBytesHi.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTxBytesHi.setDescription('Bytes transmitted by this interface ( high 32bits ).')
webCacheHitsLo = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheHitsLo.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheHitsLo.setDescription('Number of times a page has been successfully found in the web cache (low 32 bits).')
webCacheHitsHi = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheHitsHi.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheHitsHi.setDescription('Number of times a page has been successfully found in the web cache (high 32 bits).')
webCacheMissesLo = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheMissesLo.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheMissesLo.setDescription('Number of times a page has not been found in the web cache (low 32 bits).')
webCacheMissesHi = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheMissesHi.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheMissesHi.setDescription('Number of times a page has not been found in the web cache (high 32 bits).')
webCacheLookupsLo = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheLookupsLo.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheLookupsLo.setDescription('Number of times a page has been looked up in the web cache (low 32 bits).')
webCacheLookupsHi = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheLookupsHi.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheLookupsHi.setDescription('Number of times a page has been looked up in the web cache (high 32 bits).')
webCacheMemUsed = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheMemUsed.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheMemUsed.setDescription('Total memory used by the web cache in kilobytes.')
webCacheMemMaximum = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheMemMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheMemMaximum.setDescription('The maximum amount of memory the web cache can use in kilobytes.')
webCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheHitRate.setDescription('The percentage of web cache lookups that succeeded.')
webCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheEntries.setDescription('The number of items in the web cache.')
webCacheMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheMaxEntries.setDescription('The maximum number of items in the web cache.')
webCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: webCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: webCacheOldest.setDescription('The age of the oldest item in the web cache (in seconds).')
sslCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheHits.setDescription('Number of times a SSL entry has been successfully found in the server cache.')
sslCacheMisses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheMisses.setDescription('Number of times a SSL entry has not been available in the server cache.')
sslCacheLookups = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheLookups.setDescription('Number of times a SSL entry has been looked up in the server cache.')
sslCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheHitRate.setDescription('The percentage of SSL server cache lookups that succeeded.')
sslCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheEntries.setDescription('The total number of SSL sessions stored in the server cache.')
sslCacheEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheEntriesMax.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheEntriesMax.setDescription('The maximum number of SSL entries in the server cache.')
sslCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 2, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: sslCacheOldest.setDescription('The age of the oldest SSL session in the server cache (in seconds).')
aspSessionCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheHits.setDescription('Number of times a ASP session entry has been successfully found in the cache.')
aspSessionCacheMisses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheMisses.setDescription('Number of times a ASP session entry has not been available in the cache.')
aspSessionCacheLookups = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheLookups.setDescription('Number of times a ASP session entry has been looked up in the cache.')
aspSessionCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheHitRate.setDescription('The percentage of ASP session lookups that succeeded.')
aspSessionCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheEntries.setDescription('The total number of ASP sessions stored in the cache.')
aspSessionCacheEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheEntriesMax.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheEntriesMax.setDescription('The maximum number of ASP sessions in the cache.')
aspSessionCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 3, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspSessionCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: aspSessionCacheOldest.setDescription('The age of the oldest ASP session in the cache (in seconds).')
ipSessionCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheHits.setDescription('Number of times a IP session entry has been successfully found in the cache.')
ipSessionCacheMisses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheMisses.setDescription('Number of times a IP session entry has not been available in the cache.')
ipSessionCacheLookups = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheLookups.setDescription('Number of times a IP session entry has been looked up in the cache.')
ipSessionCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheHitRate.setDescription('The percentage of IP session lookups that succeeded.')
ipSessionCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheEntries.setDescription('The total number of IP sessions stored in the cache.')
ipSessionCacheEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheEntriesMax.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheEntriesMax.setDescription('The maximum number of IP sessions in the cache.')
ipSessionCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 4, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSessionCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: ipSessionCacheOldest.setDescription('The age of the oldest IP session in the cache (in seconds).')
j2eeSessionCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheHits.setDescription('Number of times a J2EE session entry has been successfully found in the cache.')
j2eeSessionCacheMisses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheMisses.setDescription('Number of times a J2EE session entry has not been available in the cache.')
j2eeSessionCacheLookups = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheLookups.setDescription('Number of times a J2EE session entry has been looked up in the cache.')
j2eeSessionCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheHitRate.setDescription('The percentage of J2EE session lookups that succeeded.')
j2eeSessionCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheEntries.setDescription('The total number of J2EE sessions stored in the cache.')
j2eeSessionCacheEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheEntriesMax.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheEntriesMax.setDescription('The maximum number of J2EE sessions in the cache.')
j2eeSessionCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 5, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: j2eeSessionCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: j2eeSessionCacheOldest.setDescription('The age of the oldest J2EE session in the cache (in seconds).')
uniSessionCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheHits.setDescription('Number of times a universal session entry has been successfully found in the cache.')
uniSessionCacheMisses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheMisses.setDescription('Number of times a universal session entry has not been available in the cache.')
uniSessionCacheLookups = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheLookups.setDescription('Number of times a universal session entry has been looked up in the cache.')
uniSessionCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheHitRate.setDescription('The percentage of universal session lookups that succeeded.')
uniSessionCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheEntries.setDescription('The total number of universal sessions stored in the cache.')
uniSessionCacheEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheEntriesMax.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheEntriesMax.setDescription('The maximum number of universal sessions in the cache.')
uniSessionCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 6, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSessionCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: uniSessionCacheOldest.setDescription('The age of the oldest universal session in the cache (in seconds).')
sslSessionCacheHits = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheHits.setDescription('Number of times a SSL session persistence entry has been successfully found in the cache.')
sslSessionCacheMisses = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheMisses.setDescription('Number of times a SSL session persistence entry has not been available in the cache.')
sslSessionCacheLookups = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheLookups.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheLookups.setDescription('Number of times a SSL session persistence entry has been looked up in the cache.')
sslSessionCacheHitRate = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheHitRate.setDescription('The percentage of SSL session persistence lookups that succeeded.')
sslSessionCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheEntries.setDescription('The total number of SSL session persistence entries stored in the cache.')
sslSessionCacheEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheEntriesMax.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheEntriesMax.setDescription('The maximum number of SSL session persistence entries in the cache.')
sslSessionCacheOldest = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 17, 7, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslSessionCacheOldest.setStatus('mandatory')
if mibBuilder.loadTexts: sslSessionCacheOldest.setDescription('The age of the oldest SSL session in the cache (in seconds).')
ruleNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ruleNumber.setDescription('The number of TrafficScript rules.')
ruleTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2), )
if mibBuilder.loadTexts: ruleTable.setStatus('mandatory')
if mibBuilder.loadTexts: ruleTable.setDescription('This table provides information and statistics for TrafficScript rules.')
ruleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: ruleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ruleEntry.setDescription('This defines a row in the rules table.')
ruleName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleName.setStatus('mandatory')
if mibBuilder.loadTexts: ruleName.setDescription('The name of the TrafficScript rule.')
ruleExecutions = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleExecutions.setStatus('mandatory')
if mibBuilder.loadTexts: ruleExecutions.setDescription('Number of times this TrafficScript rule has been executed.')
ruleAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleAborts.setStatus('mandatory')
if mibBuilder.loadTexts: ruleAborts.setDescription('Number of times this TrafficScript rule has aborted.')
ruleResponds = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleResponds.setStatus('mandatory')
if mibBuilder.loadTexts: ruleResponds.setDescription('Number of times this TrafficScript rule has responded directly to the client.')
rulePoolSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rulePoolSelect.setStatus('mandatory')
if mibBuilder.loadTexts: rulePoolSelect.setDescription('Number of times this TrafficScript rule has selected a pool to use.')
ruleRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleRetries.setStatus('mandatory')
if mibBuilder.loadTexts: ruleRetries.setDescription('Number of times this TrafficScript rule has forced the request to be retried.')
ruleDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 18, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ruleDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ruleDiscards.setDescription('Number of times this TrafficScript rule has discarded the connection.')
monitorNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 19, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: monitorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: monitorNumber.setDescription('The number of Monitors.')
monitorTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 19, 2), )
if mibBuilder.loadTexts: monitorTable.setStatus('mandatory')
if mibBuilder.loadTexts: monitorTable.setDescription('This table provides information and statistics on Monitors.')
monitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 19, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "monitorName"))
if mibBuilder.loadTexts: monitorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: monitorEntry.setDescription('This defines a row in the monitors table.')
monitorName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 19, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: monitorName.setStatus('mandatory')
if mibBuilder.loadTexts: monitorName.setDescription('The name of the monitor.')
licensekeyNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licensekeyNumber.setStatus('mandatory')
if mibBuilder.loadTexts: licensekeyNumber.setDescription('The number of License keys.')
licensekeyTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 20, 2), )
if mibBuilder.loadTexts: licensekeyTable.setStatus('mandatory')
if mibBuilder.loadTexts: licensekeyTable.setDescription('This table provides information and statistics on License Keys.')
licensekeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 20, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: licensekeyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: licensekeyEntry.setDescription('This defines a row in the license keys table.')
licensekeyName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 20, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licensekeyName.setStatus('mandatory')
if mibBuilder.loadTexts: licensekeyName.setDescription('The name of the License Key.')
zxtmNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 21, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zxtmNumber.setStatus('mandatory')
if mibBuilder.loadTexts: zxtmNumber.setDescription('The number of traffic managers in the cluster.')
zxtmTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 21, 2), )
if mibBuilder.loadTexts: zxtmTable.setStatus('mandatory')
if mibBuilder.loadTexts: zxtmTable.setDescription('This table provides information and statistics on traffic managers.')
zxtmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 21, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "zxtmName"))
if mibBuilder.loadTexts: zxtmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: zxtmEntry.setDescription('This defines a row in the traffic managers table.')
zxtmName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 21, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zxtmName.setStatus('mandatory')
if mibBuilder.loadTexts: zxtmName.setDescription('The name of the traffic manager.')
glbServiceNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: glbServiceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceNumber.setDescription('The number of GLB Services on this system.')
glbServiceTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 2), )
if mibBuilder.loadTexts: glbServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceTable.setDescription('This table provides information and statistics for GLB Services.')
glbServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: glbServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceEntry.setDescription('This defines a row in the GLB Services table.')
glbServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: glbServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceName.setDescription('The name of the GLB Service.')
glbServiceResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: glbServiceResponses.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceResponses.setDescription('Number of A records this GLB Service has altered.')
glbServiceUnmodified = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: glbServiceUnmodified.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceUnmodified.setDescription('Number of A records this GLB Service has passed through unmodified.')
glbServiceDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 24, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: glbServiceDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: glbServiceDiscarded.setDescription('Number of A records this GLB Service has discarded.')
perLocationServiceTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1), )
if mibBuilder.loadTexts: perLocationServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceTable.setDescription('This table provides information and statistics for GLB Services on a per location basis.')
perLocationServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1), ).setIndexNames((0, "ZXTM-MIB", "perLocationServiceLocationName"), (0, "ZXTM-MIB", "perLocationServiceName"))
if mibBuilder.loadTexts: perLocationServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceEntry.setDescription('This defines a row in the per-location table.')
perLocationServiceLocationName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceLocationName.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceLocationName.setDescription('The name of the location.')
perLocationServiceLocationCode = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceLocationCode.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceLocationCode.setDescription('The code for the location.')
perLocationServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceName.setDescription('The name of the GLB Service.')
perLocationServiceDraining = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("draining", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceDraining.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceDraining.setDescription('The draining state of this location for this GLB Service.')
perLocationServiceState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alive", 1), ("dead", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceState.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceState.setDescription('The state of this location for this GLB Service.')
perLocationServiceFrontendState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alive", 1), ("dead", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceFrontendState.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceFrontendState.setDescription('The frontend state of this location for this GLB Service.')
perLocationServiceMonitorState = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alive", 1), ("dead", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceMonitorState.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceMonitorState.setDescription('The monitor state of this location for this GLB Service.')
perLocationServiceLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceLoad.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceLoad.setDescription('The load metric for this location for this GLB Service.')
perLocationServiceResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 25, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perLocationServiceResponses.setStatus('mandatory')
if mibBuilder.loadTexts: perLocationServiceResponses.setDescription('Number of A records that have been altered to point to this location for this GLB Service.')
locationTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26, 1), )
if mibBuilder.loadTexts: locationTable.setStatus('mandatory')
if mibBuilder.loadTexts: locationTable.setDescription('This table provides information and statistics for GLB Services on a per location basis.')
locationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26, 1, 1), ).setIndexNames((0, "ZXTM-MIB", "locationName"))
if mibBuilder.loadTexts: locationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: locationEntry.setDescription('This defines a row in the per-location table.')
locationName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: locationName.setStatus('mandatory')
if mibBuilder.loadTexts: locationName.setDescription('The name of the location.')
locationCode = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: locationCode.setStatus('mandatory')
if mibBuilder.loadTexts: locationCode.setDescription('The code for the location.')
locationLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locationLoad.setStatus('mandatory')
if mibBuilder.loadTexts: locationLoad.setDescription('The mean load metric for this location.')
locationResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 26, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locationResponses.setStatus('mandatory')
if mibBuilder.loadTexts: locationResponses.setDescription('Number of A records that have been altered to point to this location.')
eventNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 13, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventNumber.setStatus('mandatory')
if mibBuilder.loadTexts: eventNumber.setDescription('The number of event configurations.')
eventTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 13, 2), )
if mibBuilder.loadTexts: eventTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventTable.setDescription('This table gives information on the event configurations in the traffic manager.')
eventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 13, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "eventName"))
if mibBuilder.loadTexts: eventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventEntry.setDescription('This defines a row in the events table.')
eventName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 13, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventName.setStatus('mandatory')
if mibBuilder.loadTexts: eventName.setDescription('The name of the event configuration.')
eventsMatched = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 13, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventsMatched.setStatus('mandatory')
if mibBuilder.loadTexts: eventsMatched.setDescription('Number of times this event configuration has matched.')
actionNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 14, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: actionNumber.setDescription('The number of actions configured in the traffic manager.')
actionTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 14, 2), )
if mibBuilder.loadTexts: actionTable.setStatus('mandatory')
if mibBuilder.loadTexts: actionTable.setDescription('This table gives information on the action configurations in the traffic manager.')
actionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 14, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "actionName"))
if mibBuilder.loadTexts: actionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: actionEntry.setDescription('This defines a row in the actions table.')
actionName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 14, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: actionName.setStatus('mandatory')
if mibBuilder.loadTexts: actionName.setDescription('The name of the action.')
actionsProcessed = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 14, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actionsProcessed.setStatus('mandatory')
if mibBuilder.loadTexts: actionsProcessed.setDescription('Number of times this action has been processed.')
fullLogLine = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 22, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fullLogLine.setStatus('mandatory')
if mibBuilder.loadTexts: fullLogLine.setDescription('The full log line of an event (for traps).')
confName = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 22, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: confName.setStatus('mandatory')
if mibBuilder.loadTexts: confName.setDescription('The name of the configuration file affected (for traps).')
customEventName = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 22, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: customEventName.setStatus('mandatory')
if mibBuilder.loadTexts: customEventName.setDescription('The name of the Custom Event (for traps).')
testaction = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,1)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "actionName"))
if mibBuilder.loadTexts: testaction.setDescription('Testing configuration for an action (emitted when testing an action in the UI)')
running = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,2)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: running.setDescription('Software is running')
fewfreefds = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,3)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: fewfreefds.setDescription('Running out of free file descriptors')
restartrequired = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,4)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: restartrequired.setDescription('Software must be restarted to apply configuration changes')
timemovedback = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,5)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: timemovedback.setDescription('Time has been moved back')
sslfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,6)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: sslfail.setDescription('One or more SSL connections from clients failed recently')
hardware = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,7)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: hardware.setDescription('Appliance hardware notification')
zxtmswerror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,8)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: zxtmswerror.setDescription('Zeus Traffic Manager software problem')
customevent = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,9)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "customEventName"))
if mibBuilder.loadTexts: customevent.setDescription("A custom event was emitted using the TrafficScript 'event.emit()' function")
versionmismatch = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,10)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: versionmismatch.setDescription('Configuration update refused: traffic manager version mismatch')
autherror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,114)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: autherror.setDescription('An error occurred during user authentication')
machineok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,11)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "zxtmName"))
if mibBuilder.loadTexts: machineok.setDescription('Remote machine is now working')
machinetimeout = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,12)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "zxtmName"))
if mibBuilder.loadTexts: machinetimeout.setDescription('Remote machine has timed out and been marked as failed')
machinefail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,13)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "zxtmName"))
if mibBuilder.loadTexts: machinefail.setDescription('Remote machine has failed')
allmachinesok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,14)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: allmachinesok.setDescription('All machines are working')
flipperbackendsworking = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,15)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: flipperbackendsworking.setDescription('Back-end nodes are now working')
flipperfrontendsworking = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,16)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: flipperfrontendsworking.setDescription('Frontend machines are now working')
pingbackendfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,17)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: pingbackendfail.setDescription('Failed to ping back-end nodes')
pingfrontendfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,18)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: pingfrontendfail.setDescription('Failed to ping any of the machines used to check the front-end connectivity')
pinggwfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,19)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: pinggwfail.setDescription('Failed to ping default gateway')
statebaddata = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,20)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: statebaddata.setDescription('Received an invalid response from another cluster member')
stateconnfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,21)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: stateconnfail.setDescription('Failed to connect to another cluster member for state sharing')
stateok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,22)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: stateok.setDescription('Successfully connected to another cluster member for state sharing')
statereadfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,23)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: statereadfail.setDescription('Reading state data from another cluster member failed')
statetimeout = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,24)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: statetimeout.setDescription('Timeout while sending state data to another cluster member')
stateunexpected = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,25)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: stateunexpected.setDescription('Received unexpected state data from another cluster member')
statewritefail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,26)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: statewritefail.setDescription('Writing state data to another cluster member failed')
activatealldead = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,107)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: activatealldead.setDescription('Activating this machine automatically because it is the only working machine in its Traffic IP Groups')
machinerecovered = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,108)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: machinerecovered.setDescription('Remote machine has recovered and can raise Traffic IP addresses')
flipperrecovered = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,109)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: flipperrecovered.setDescription('Machine is ready to raise Traffic IP addresses')
activatedautomatically = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,110)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: activatedautomatically.setDescription('Machine has recovered and been activated automatically because it would cause no service disruption')
zclustermoderr = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,111)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: zclustermoderr.setDescription('An error occurred when using the zcluster Multi-Hosted IP kernel module')
ec2flipperraiselocalworking = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,112)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: ec2flipperraiselocalworking.setDescription('Moving EC2 Elastic IP Address; local machine is working')
ec2flipperraiseothersdead = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,113)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: ec2flipperraiseothersdead.setDescription('Moving EC2 Elastic IP Address; other machines have failed')
ec2iperr = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,130)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: ec2iperr.setDescription('Problem occurred when managing an Elastic IP address')
dropec2ipwarn = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,131)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: dropec2ipwarn.setDescription('Removing EC2 Elastic IP Address from all machines; it is no longer a part of any Traffic IP Groups')
ec2nopublicip = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,132)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: ec2nopublicip.setDescription('Cannot raise Elastic IP on this machine until EC2 provides it with a public IP address')
multihostload = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,133)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: multihostload.setDescription('The amount of load handled by the local machine destined for this Traffic IP has changed')
sslhwfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,27)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: sslhwfail.setDescription('SSL hardware support failed')
sslhwrestart = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,28)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: sslhwrestart.setDescription('SSL hardware support restarted')
sslhwstart = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,29)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: sslhwstart.setDescription('SSL hardware support started')
confdel = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,30)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "confName"))
if mibBuilder.loadTexts: confdel.setDescription('Configuration file deleted')
confmod = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,31)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "confName"))
if mibBuilder.loadTexts: confmod.setDescription('Configuration file modified')
confadd = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,32)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "confName"))
if mibBuilder.loadTexts: confadd.setDescription('Configuration file added')
confok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,33)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "confName"))
if mibBuilder.loadTexts: confok.setDescription('Configuration file now OK')
confreptimeout = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,178)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: confreptimeout.setDescription('Replication of configuration has timed out')
confrepfailed = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,179)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: confrepfailed.setDescription('Replication of configuration has failed')
javadied = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,34)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: javadied.setDescription('Java runner died')
javastop = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,35)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: javastop.setDescription('Java support has stopped')
javastartfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,36)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: javastartfail.setDescription('Java runner failed to start')
javaterminatefail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,37)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: javaterminatefail.setDescription('Java runner failed to terminate')
javanotfound = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,38)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: javanotfound.setDescription('Cannot start Java runner, program not found')
javastarted = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,39)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: javastarted.setDescription('Java runner started')
servleterror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,40)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: servleterror.setDescription('Servlet encountered an error')
monitorfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,41)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "monitorName"))
if mibBuilder.loadTexts: monitorfail.setDescription('Monitor has detected a failure')
monitorok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,42)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "monitorName"))
if mibBuilder.loadTexts: monitorok.setDescription('Monitor is working')
rulexmlerr = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,43)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulexmlerr.setDescription('Rule encountered an XML error')
pooluseunknown = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,44)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: pooluseunknown.setDescription('Rule selected an unknown pool')
ruleabort = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,45)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: ruleabort.setDescription('Rule aborted during execution')
rulebufferlarge = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,46)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulebufferlarge.setDescription('Rule has buffered more data than expected')
rulebodycomperror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,47)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulebodycomperror.setDescription('Rule encountered invalid data while uncompressing response')
forwardproxybadhost = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,48)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: forwardproxybadhost.setDescription('Rule selected an unresolvable host')
invalidemit = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,49)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: invalidemit.setDescription('Rule used event.emit() with an invalid custom event')
rulenopersistence = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,50)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulenopersistence.setDescription('Rule selected an unknown session persistence class')
rulelogmsginfo = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,51)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulelogmsginfo.setDescription('Rule logged an info message using log.info')
rulelogmsgwarn = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,52)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulelogmsgwarn.setDescription('Rule logged a warning message using log.warn')
rulelogmsgserious = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,53)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulelogmsgserious.setDescription('Rule logged an error message using log.error')
norate = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,54)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: norate.setDescription('Rule selected an unknown rate shaping class')
poolactivenodesunknown = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,55)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: poolactivenodesunknown.setDescription('Rule references an unknown pool via pool.activenodes')
datastorefull = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,56)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: datastorefull.setDescription('data.set() has run out of space')
rulestreamerrortoomuch = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,210)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrortoomuch.setDescription('Rule supplied too much data in HTTP stream')
rulestreamerrornotenough = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,211)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrornotenough.setDescription('Rule did not supply enough data in HTTP stream')
rulestreamerrorprocessfailure = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,212)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrorprocessfailure.setDescription('Data supplied to HTTP stream could not be processed')
rulestreamerrornotstarted = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,213)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrornotstarted.setDescription('Attempt to stream data or finish a stream before streaming had been initialized')
rulestreamerrornotfinished = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,214)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrornotfinished.setDescription('Attempt to initialize HTTP stream before previous stream had finished')
rulestreamerrorinternal = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,215)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrorinternal.setDescription('Internal error while processing HTTP stream')
rulestreamerrorgetresponse = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,216)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: rulestreamerrorgetresponse.setDescription('Attempt to use http.getResponse or http.getResponseBody after http.stream.startResponse')
rulesinvalidrequestbody = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,217)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "ruleName"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: rulesinvalidrequestbody.setDescription('Client sent invalid HTTP request body')
serviceruleabort = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,218)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: serviceruleabort.setDescription('GLB service rule aborted during execution')
servicerulelocunknown = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,219)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: servicerulelocunknown.setDescription('GLB service rule specified an unknown location')
servicerulelocnotconfigured = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,220)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: servicerulelocnotconfigured.setDescription('GLB service rule specified a location that is not configured for the service')
servicerulelocdead = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,221)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"), ("ZXTM-MIB", "ruleName"))
if mibBuilder.loadTexts: servicerulelocdead.setDescription('GLB service rule specified a location that has either failed or been marked as draining in the service configuration')
expired = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,57)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: expired.setDescription('License key has expired')
licensecorrupt = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,58)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: licensecorrupt.setDescription('License key is corrupt')
expiresoon = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,59)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: expiresoon.setDescription('License key expires within 7 days')
usinglicense = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,60)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: usinglicense.setDescription('Using license key')
licenseclustertoobig = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,61)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: licenseclustertoobig.setDescription('Cluster size exceeds license key limit')
unlicensed = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,62)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: unlicensed.setDescription('Started without a license')
usingdevlicense = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,63)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: usingdevlicense.setDescription('Using a development license')
morememallowed = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,124)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: morememallowed.setDescription('License allows more memory for caching')
lessmemallowed = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,125)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: lessmemallowed.setDescription('License allows less memory for caching')
cachesizereduced = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,123)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: cachesizereduced.setDescription('Configured cache size exceeds license limit, only using amount allowed by license')
tpslimited = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,134)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: tpslimited.setDescription('License key transactions-per-second limit has been hit')
ssltpslimited = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,135)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: ssltpslimited.setDescription('License key SSL transactions-per-second limit has been hit')
bwlimited = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,136)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: bwlimited.setDescription('License key bandwidth limit has been hit')
licensetoomanylocations = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,137)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: licensetoomanylocations.setDescription('A location has been disabled because you have exceeded the licence limit')
autoscalinglicenseerror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,175)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: autoscalinglicenseerror.setDescription('Autoscaling not permitted by licence key')
autoscalinglicenseenabled = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,176)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: autoscalinglicenseenabled.setDescription('Autoscaling support has been enabled')
autoscalinglicensedisabled = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,177)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: autoscalinglicensedisabled.setDescription('Autoscaling support has been disabled')
analyticslicenseenabled = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,180)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: analyticslicenseenabled.setDescription('Realtime Analytics support has been enabled')
analyticslicensedisabled = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,181)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: analyticslicensedisabled.setDescription('Realtime Analytics support has been disabled')
poolnonodes = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,64)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: poolnonodes.setDescription('Pool configuration contains no valid backend nodes')
poolok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,65)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: poolok.setDescription('Pool now has working nodes')
pooldied = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,66)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: pooldied.setDescription('Pool has no back-end nodes responding')
noderesolvefailure = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,67)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: noderesolvefailure.setDescription('Failed to resolve node address')
noderesolvemultiple = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,68)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: noderesolvemultiple.setDescription('Node resolves to multiple IP addresses')
nodeworking = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,69)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "perPoolNodePoolName"), ("ZXTM-MIB", "perPoolNodeNodeAddressType"), ("ZXTM-MIB", "perPoolNodeNodeAddress"), ("ZXTM-MIB", "perPoolNodeNodePort"))
if mibBuilder.loadTexts: nodeworking.setDescription('Node is working again')
nostarttls = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,70)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "perPoolNodePoolName"), ("ZXTM-MIB", "perPoolNodeNodeAddressType"), ("ZXTM-MIB", "perPoolNodeNodeAddress"), ("ZXTM-MIB", "perPoolNodeNodePort"))
if mibBuilder.loadTexts: nostarttls.setDescription("Node doesn't provide STARTTLS support")
nodefail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,71)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "perPoolNodePoolName"), ("ZXTM-MIB", "perPoolNodeNodeAddressType"), ("ZXTM-MIB", "perPoolNodeNodeAddress"), ("ZXTM-MIB", "perPoolNodeNodePort"))
if mibBuilder.loadTexts: nodefail.setDescription('Node has failed')
starttlsinvalid = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,72)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "perPoolNodePoolName"), ("ZXTM-MIB", "perPoolNodeNodeAddressType"), ("ZXTM-MIB", "perPoolNodeNodeAddress"), ("ZXTM-MIB", "perPoolNodeNodePort"))
if mibBuilder.loadTexts: starttlsinvalid.setDescription('Node returned invalid STARTTLS response')
ehloinvalid = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,73)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "perPoolNodePoolName"), ("ZXTM-MIB", "perPoolNodeNodeAddressType"), ("ZXTM-MIB", "perPoolNodeNodeAddress"), ("ZXTM-MIB", "perPoolNodeNodePort"))
if mibBuilder.loadTexts: ehloinvalid.setDescription('Node returned invalid EHLO response')
usedcredsdeleted = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,126)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "cloudcredentialsName"))
if mibBuilder.loadTexts: usedcredsdeleted.setDescription('A Cloud Credentials object has been deleted but it was still in use')
autoscalestatusupdateerror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,129)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "cloudcredentialsName"))
if mibBuilder.loadTexts: autoscalestatusupdateerror.setDescription('An API call made by the autoscaler process has reported an error')
autoscaleresponseparseerror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,159)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "cloudcredentialsName"))
if mibBuilder.loadTexts: autoscaleresponseparseerror.setDescription('An API call made by the autoscaler process has returned a response that could not be parsed')
autoscalingchangeprocessfailure = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,182)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalingchangeprocessfailure.setDescription('An API process that should have created or destroyed a node has failed to produce the expected result')
autoscalewrongimageid = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,183)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalewrongimageid.setDescription('A node created by the autoscaler has the wrong imageid')
autoscalewrongname = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,184)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalewrongname.setDescription('A node created by the autoscaler has a non-matching name')
autoscalewrongsizeid = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,185)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalewrongsizeid.setDescription('A node created by the autoscaler has the wrong sizeid')
apistatusprocesshanging = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,127)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "cloudcredentialsName"))
if mibBuilder.loadTexts: apistatusprocesshanging.setDescription('A cloud API process querying changes to cloud instances is hanging')
autonodedestructioncomplete = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,138)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodedestructioncomplete.setDescription('The destruction of a node in an autoscaled pool is now complete')
autonodeexisted = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,139)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodeexisted.setDescription("IP address of newly created instance already existed in pool's node list")
autoscaledpooltoosmall = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,140)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscaledpooltoosmall.setDescription('Minimum size undercut - growing')
autoscaleinvalidargforcreatenode = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,141)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscaleinvalidargforcreatenode.setDescription("The 'imageid' was empty when attempting to create a node in an autoscaled pool")
autonodedisappeared = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,142)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodedisappeared.setDescription('A node in an autoscaled pool has disappeared from the cloud')
autoscaledpoolrefractory = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,143)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscaledpoolrefractory.setDescription('An autoscaled pool is now refractory')
cannotshrinkemptypool = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,144)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: cannotshrinkemptypool.setDescription('Attempt to scale down a pool that only had pending nodes or none at all')
autoscalinghysteresiscantgrow = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,145)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalinghysteresiscantgrow.setDescription('An autoscaled pool is waiting to grow')
autonodecreationcomplete = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,146)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodecreationcomplete.setDescription('The creation of a new node requested by an autoscaled pool is now complete')
autonodestatuschange = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,147)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodestatuschange.setDescription('The status of a node in an autoscaled pool has changed')
autoscalinghysteresiscantshrink = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,148)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalinghysteresiscantshrink.setDescription('An autoscaled pool is waiting to shrink')
autoscalingpoolstatechange = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,149)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalingpoolstatechange.setDescription("An autoscaled pool's state has changed")
autonodedestroyed = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,128)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodedestroyed.setDescription('A cloud API call to destroy a node has been started')
autonodecreationstarted = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,165)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autonodecreationstarted.setDescription('Creation of new node instigated')
autoscaleinvalidargfordeletenode = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,166)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscaleinvalidargfordeletenode.setDescription("'unique id' was empty when attempting to destroy a node in an autoscaled pool")
autoscalinghitroof = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,167)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalinghitroof.setDescription('Maximum size reached by autoscaled pool, cannot grow further')
autoscalinghitfloor = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,168)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalinghitfloor.setDescription('Minimum size reached, cannot shrink further')
apichangeprocesshanging = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,169)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: apichangeprocesshanging.setDescription('API change process still running after refractory period is over')
autoscaledpooltoobig = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,170)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscaledpooltoobig.setDescription('Over maximum size - shrinking')
autoscalingprocesstimedout = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,171)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "cloudcredentialsName"))
if mibBuilder.loadTexts: autoscalingprocesstimedout.setDescription('A cloud API process has timed out')
autoscalingdisabled = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,172)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalingdisabled.setDescription('Autoscaling for a pool has been disabled due to errors communicating with the cloud API')
autoscalednodecontested = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,163)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalednodecontested.setDescription('Two pools are trying to use the same instance')
autoscalepoolconfupdate = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,164)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalepoolconfupdate.setDescription('A pool config file has been updated by the autoscaler process')
autoscalingresuscitatepool = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,188)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: autoscalingresuscitatepool.setDescription('An autoscaled pool has failed completely')
flipperraiselocalworking = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,74)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: flipperraiselocalworking.setDescription('Raising Traffic IP Address; local machine is working')
flipperraiseothersdead = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,75)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: flipperraiseothersdead.setDescription('Raising Traffic IP Address; other machines have failed')
flipperraiseosdrop = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,76)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: flipperraiseosdrop.setDescription('Raising Traffic IP Address; Operating System had dropped this IP address')
dropipinfo = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,77)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: dropipinfo.setDescription('Dropping Traffic IP Address due to a configuration change or traffic manager recovery')
dropipwarn = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,78)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: dropipwarn.setDescription('Dropping Traffic IP Address due to an error')
flipperdadreraise = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,79)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: flipperdadreraise.setDescription('Re-raising Traffic IP Address; Operating system did not fully raise the address')
flipperipexists = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,80)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "trafficIPInet46AddressType"), ("ZXTM-MIB", "trafficIPInet46Address"))
if mibBuilder.loadTexts: flipperipexists.setDescription('Failed to raise Traffic IP Address; the address exists elsewhere on your network and cannot be raised')
triggersummary = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,81)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "serviceProtName"))
if mibBuilder.loadTexts: triggersummary.setDescription('Summary of recent service protection events')
slmclasslimitexceeded = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,82)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: slmclasslimitexceeded.setDescription('SLM shared memory limit exceeded')
slmrecoveredwarn = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,83)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "serviceLevelName"))
if mibBuilder.loadTexts: slmrecoveredwarn.setDescription('SLM has recovered')
slmrecoveredserious = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,84)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "serviceLevelName"))
if mibBuilder.loadTexts: slmrecoveredserious.setDescription('SLM has risen above the serious threshold')
slmfallenbelowwarn = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,85)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "serviceLevelName"))
if mibBuilder.loadTexts: slmfallenbelowwarn.setDescription('SLM has fallen below warning threshold')
slmfallenbelowserious = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,86)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "serviceLevelName"))
if mibBuilder.loadTexts: slmfallenbelowserious.setDescription('SLM has fallen below serious threshold')
vscrloutofdate = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,87)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: vscrloutofdate.setDescription('CRL for a Certificate Authority is out of date')
vsstart = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,88)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vsstart.setDescription('Virtual server started')
vsstop = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,89)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vsstop.setDescription('Virtual server stopped')
privkeyok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,90)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: privkeyok.setDescription('Private key now OK (hardware available)')
ssldrop = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,91)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: ssldrop.setDescription('Request(s) received while SSL configuration invalid, connection closed')
vslogwritefail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,92)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vslogwritefail.setDescription('Failed to write log file for virtual server')
vssslcertexpired = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,93)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vssslcertexpired.setDescription('Public SSL certificate expired')
vssslcerttoexpire = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,94)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vssslcerttoexpire.setDescription('Public SSL certificate will expire within seven days')
vscacertexpired = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,95)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vscacertexpired.setDescription('Certificate Authority certificate expired')
vscacerttoexpire = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,96)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: vscacerttoexpire.setDescription('Certificate Authority certificate will expire within seven days')
glbmissingips = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,150)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: glbmissingips.setDescription('A DNS Query returned IP addresses that are not configured in any location')
glbdeadlocmissingips = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,158)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: glbdeadlocmissingips.setDescription('A DNS Query returned IP addresses that are not configured for any location that is currently alive')
glbnolocations = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,151)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: glbnolocations.setDescription('No valid location could be chosen for Global Load Balancing')
locationmonitorok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,152)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: locationmonitorok.setDescription('A monitor has indicated this location is now working')
locationmonitorfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,153)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: locationmonitorfail.setDescription('A monitor has detected a failure in this location')
locationok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,154)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: locationok.setDescription('Location is now working for GLB Service')
locationfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,155)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: locationfail.setDescription('Location has failed for GLB Service')
locationsoapok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,156)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: locationsoapok.setDescription('An external SOAP agent indicates this location is now working')
locationsoapfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,157)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: locationsoapfail.setDescription('An external SOAP agent has detected a failure in this location')
glbnewmaster = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,160)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: glbnewmaster.setDescription('A location has been set as master for a GLB service')
glblogwritefail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,161)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: glblogwritefail.setDescription('Failed to write log file for GLB service')
glbfailalter = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,162)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: glbfailalter.setDescription('Failed to alter DNS packet for global load balancing')
glbservicedied = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,190)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: glbservicedied.setDescription('GLB Service has no working locations')
glbserviceok = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,191)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "glbServiceName"))
if mibBuilder.loadTexts: glbserviceok.setDescription('GLB Service has recovered')
locmovemachine = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,173)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"), ("ZXTM-MIB", "zxtmName"))
if mibBuilder.loadTexts: locmovemachine.setDescription('Machine now in location')
locempty = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,174)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "locationName"))
if mibBuilder.loadTexts: locempty.setDescription('Location no longer contains any machines')
maxclientbufferdrop = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,97)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: maxclientbufferdrop.setDescription('Dropped connection, request exceeded max_client_buffer limit')
respcompfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,98)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: respcompfail.setDescription('Error compressing HTTP response')
responsetoolarge = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,99)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: responsetoolarge.setDescription('Response headers from webserver too large')
sipstreamnoports = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,100)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: sipstreamnoports.setDescription('No suitable ports available for streaming data connection')
rtspstreamnoports = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,101)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: rtspstreamnoports.setDescription('No suitable ports available for streaming data connection')
geodataloadfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,102)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: geodataloadfail.setDescription('Failed to load geolocation data')
poolpersistencemismatch = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,103)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: poolpersistencemismatch.setDescription("Pool uses a session persistence class that does not work with this virtual server's protocol")
connerror = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,104)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: connerror.setDescription('A protocol error has occurred')
connfail = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,105)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: connfail.setDescription('A socket connection failure has occurred')
badcontentlen = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,106)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "poolName"))
if mibBuilder.loadTexts: badcontentlen.setDescription('HTTP response contained an invalid Content-Length header')
logfiledeleted = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,115)).setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "virtualserverName"))
if mibBuilder.loadTexts: logfiledeleted.setDescription('A virtual server request log file was deleted (Zeus Appliances only)')
license_graceperiodexpired = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,116)).setLabel("license-graceperiodexpired").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_graceperiodexpired.setDescription('Unable to authorize license key')
license_authorized = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,117)).setLabel("license-authorized").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_authorized.setDescription('License key authorized')
license_rejected_authorized = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,118)).setLabel("license-rejected-authorized").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_rejected_authorized.setDescription('License server rejected license key; key remains authorized')
license_rejected_unauthorized = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,119)).setLabel("license-rejected-unauthorized").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_rejected_unauthorized.setDescription('License server rejected license key; key is not authorized')
license_timedout_authorized = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,120)).setLabel("license-timedout-authorized").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_timedout_authorized.setDescription('Unable to contact license server; license key remains authorized')
license_timedout_unauthorized = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,121)).setLabel("license-timedout-unauthorized").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_timedout_unauthorized.setDescription('Unable to contact license server; license key is not authorized')
license_unauthorized = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,122)).setLabel("license-unauthorized").setObjects(("ZXTM-MIB", "fullLogLine"), ("ZXTM-MIB", "licensekeyName"))
if mibBuilder.loadTexts: license_unauthorized.setDescription('License key is not authorized')
logdiskoverload = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,186)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: logdiskoverload.setDescription('Log disk partition usage has exceeded threshold')
logdiskfull = NotificationType((1, 3, 6, 1, 4, 1, 7146, 1, 2, 15) + (0,187)).setObjects(("ZXTM-MIB", "fullLogLine"))
if mibBuilder.loadTexts: logdiskfull.setDescription('Log disk partition full')
cloudcredentialsClassNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cloudcredentialsClassNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsClassNumber.setDescription('The number of cloud credentials sets defined.')
cloudcredentialsTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 2), )
if mibBuilder.loadTexts: cloudcredentialsTable.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsTable.setDescription('This table provides statistics for cloud credentials sets.')
cloudcredentialsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "cloudcredentialsName"))
if mibBuilder.loadTexts: cloudcredentialsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsEntry.setDescription('This defines a row in the cloud credentials table.')
cloudcredentialsName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cloudcredentialsName.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsName.setDescription('The name of this set of cloud credentials.')
cloudcredentialsStatusRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cloudcredentialsStatusRequests.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsStatusRequests.setDescription('The number of status API requests made with this set of cloud credentials.')
cloudcredentialsNodeCreations = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cloudcredentialsNodeCreations.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsNodeCreations.setDescription('The number of instance creation API requests made with this set of cloud credentials.')
cloudcredentialsNodeDeletions = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 23, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cloudcredentialsNodeDeletions.setStatus('mandatory')
if mibBuilder.loadTexts: cloudcredentialsNodeDeletions.setDescription('The number of instance destruction API requests made with this set of cloud credentials.')
listenIPTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2), )
if mibBuilder.loadTexts: listenIPTable.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPTable.setDescription('This table defines all the information for a particular listening IP (includes IPv4 and IPv6 addresses).')
listenIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "listenIPAddressType"), (0, "ZXTM-MIB", "listenIPAddress"))
if mibBuilder.loadTexts: listenIPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPEntry.setDescription('This defines a row in the listenips table (includes IPv4 and IPv6 addresses).')
listenIPAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPAddressType.setDescription('The IP address type of this listening IP.')
listenIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPAddress.setDescription('The IPv4 or IPv6 address of this listening IP.')
listenIPBytesInLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPBytesInLo.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPBytesInLo.setDescription('Bytes sent to this listening IP ( low 32bits ).')
listenIPBytesInHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPBytesInHi.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPBytesInHi.setDescription('Bytes sent to this listening IP ( high 32bits ).')
listenIPBytesOutLo = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPBytesOutLo.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPBytesOutLo.setDescription('Bytes sent from this listening IP ( low 32bits ).')
listenIPBytesOutHi = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPBytesOutHi.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPBytesOutHi.setDescription('Bytes sent from this listening IP ( high 32bits ).')
listenIPCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPCurrentConn.setDescription('TCP connections currently established to this listening IP.')
listenIPTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPTotalConn.setDescription('Requests sent to this listening IP.')
listenIPMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 27, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: listenIPMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: listenIPMaxConn.setDescription('Maximum number of simultaneous TCP connections this listening IP has processed at any one time.')
authenticatorNumber = MibScalar((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticatorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorNumber.setDescription('The number of Authenticators.')
authenticatorTable = MibTable((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2), )
if mibBuilder.loadTexts: authenticatorTable.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorTable.setDescription('This table provides information and statistics for Authenticators.')
authenticatorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2, 1), ).setIndexNames((0, "ZXTM-MIB", "authenticatorName"))
if mibBuilder.loadTexts: authenticatorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorEntry.setDescription('This defines a row in the authenticators table.')
authenticatorName = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticatorName.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorName.setDescription('The name of the Authenticator.')
authenticatorRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticatorRequests.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorRequests.setDescription('Number of times this Authenticator has been asked to authenticate.')
authenticatorPasses = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticatorPasses.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorPasses.setDescription('Number of times this Authenticator has successfully authenticated.')
authenticatorFails = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticatorFails.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorFails.setDescription('Number of times this Authenticator has failed to authenticate.')
authenticatorErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7146, 1, 2, 28, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authenticatorErrors.setStatus('mandatory')
if mibBuilder.loadTexts: authenticatorErrors.setDescription('Number of connection errors that have occured when trying to connect to an authentication server.')
mibBuilder.exportSymbols("ZXTM-MIB", nodeFailures=nodeFailures, trafficIPEntry=trafficIPEntry, perPoolNodeBytesFromNodeHi=perPoolNodeBytesFromNodeHi, statebaddata=statebaddata, customevent=customevent, license_timedout_unauthorized=license_timedout_unauthorized, trafficIPInet46AddressType=trafficIPInet46AddressType, perNodeServiceLevelInet46NodeAddress=perNodeServiceLevelInet46NodeAddress, license_timedout_authorized=license_timedout_authorized, perLocationServiceLocationCode=perLocationServiceLocationCode, testaction=testaction, sslCipherDecrypts=sslCipherDecrypts, autonodeexisted=autonodeexisted, flipperraiseothersdead=flipperraiseothersdead, virtualserverConnectionFailures=virtualserverConnectionFailures, monitorName=monitorName, rulestreamerrornotfinished=rulestreamerrornotfinished, poolBytesOutLo=poolBytesOutLo, rateClassCurrentRate=rateClassCurrentRate, hardware=hardware, licenseclustertoobig=licenseclustertoobig, virtualserverMaxConn=virtualserverMaxConn, ruleAborts=ruleAborts, poolBytesInLo=poolBytesInLo, poolName=poolName, glbnolocations=glbnolocations, slmfallenbelowwarn=slmfallenbelowwarn, virtualserverConnectTimedOut=virtualserverConnectTimedOut, nodeNumberInet46=nodeNumberInet46, poolNodes=poolNodes, autoscaleinvalidargforcreatenode=autoscaleinvalidargforcreatenode, poolNumber=poolNumber, trafficIPInet46State=trafficIPInet46State, stateconnfail=stateconnfail, bandwidthClassGuarantee=bandwidthClassGuarantee, cloudcredentialsName=cloudcredentialsName, perPoolNodeIdleConns=perPoolNodeIdleConns, sslSessionIDDiskCacheHit=sslSessionIDDiskCacheHit, perPoolNodeBytesFromNodeLo=perPoolNodeBytesFromNodeLo, perLocationServiceLocationName=perLocationServiceLocationName, cloudcredentials=cloudcredentials, running=running, perPoolNodeCurrentRequests=perPoolNodeCurrentRequests, listenIPEntry=listenIPEntry, perNodeServiceLevelInet46SLMName=perNodeServiceLevelInet46SLMName, authenticatorEntry=authenticatorEntry, poolConnsQueued=poolConnsQueued, nodeInet46HostName=nodeInet46HostName, sslConnections=sslConnections, autoscalinglicenseenabled=autoscalinglicenseenabled, uniSessionCacheOldest=uniSessionCacheOldest, nodeBytesToNodeLo=nodeBytesToNodeLo, totalBytesInLo=totalBytesInLo, rateClassQueueLength=rateClassQueueLength, perNodeServiceLevelInet46Table=perNodeServiceLevelInet46Table, ipSessionCacheLookups=ipSessionCacheLookups, sslCipherDESDecrypts=sslCipherDESDecrypts, perPoolNodeTotalConn=perPoolNodeTotalConn, trafficIPTime=trafficIPTime, authenticatorName=authenticatorName, rateClassEntry=rateClassEntry, triggersummary=triggersummary, j2eeSessionCacheHitRate=j2eeSessionCacheHitRate, rateClassNumber=rateClassNumber, locationLoad=locationLoad, rulestreamerrornotstarted=rulestreamerrornotstarted, pernodeservicelevelmon=pernodeservicelevelmon, poolTotalConn=poolTotalConn, nodeInet46Table=nodeInet46Table, virtualservers=virtualservers, j2eeSessionCacheMisses=j2eeSessionCacheMisses, rulenopersistence=rulenopersistence, perPoolNodeResponseMean=perPoolNodeResponseMean, machinetimeout=machinetimeout, perPoolNodePooledConn=perPoolNodePooledConn, sslSessionCacheEntriesMax=sslSessionCacheEntriesMax, nodeInet46Entry=nodeInet46Entry, customEventName=customEventName, sslSessionCacheMisses=sslSessionCacheMisses, sysMemBuffered=sysMemBuffered, license_rejected_authorized=license_rejected_authorized, sysMemTotal=sysMemTotal, confrepfailed=confrepfailed, events=events, sslCipherRC4Decrypts=sslCipherRC4Decrypts, cloudcredentialsEntry=cloudcredentialsEntry, timeLastConfigUpdate=timeLastConfigUpdate, webCacheMissesHi=webCacheMissesHi, autoscalewrongimageid=autoscalewrongimageid, nodeInet46TotalConn=nodeInet46TotalConn, bandwidthClassBytesOutLo=bandwidthClassBytesOutLo, badcontentlen=badcontentlen, rateClassName=rateClassName, poolnonodes=poolnonodes, perLocationServiceLoad=perLocationServiceLoad, trafficIPARPMessage=trafficIPARPMessage, perNodeServiceLevelNodePort=perNodeServiceLevelNodePort, tpslimited=tpslimited, rulestreamerrornotenough=rulestreamerrornotenough, nodeworking=nodeworking, glbnewmaster=glbnewmaster, nodeInet46State=nodeInet46State, monitorfail=monitorfail, perNodeServiceLevelResponseMax=perNodeServiceLevelResponseMax, perLocationServiceName=perLocationServiceName, authenticators=authenticators, virtualserverPort=virtualserverPort, aspSessionCacheHits=aspSessionCacheHits, autonodedisappeared=autonodedisappeared, sslhwstart=sslhwstart, interfaceTxBytesHi=interfaceTxBytesHi, webCacheMaxEntries=webCacheMaxEntries, sslCipher3DESEncrypts=sslCipher3DESEncrypts, sslCacheOldest=sslCacheOldest, sslCacheHits=sslCacheHits, rulebodycomperror=rulebodycomperror, sslCipher3DESDecrypts=sslCipher3DESDecrypts, nodeInet46BytesToNodeHi=nodeInet46BytesToNodeHi, totalBytesOutHi=totalBytesOutHi, poolMaxQueueTime=poolMaxQueueTime, ruleEntry=ruleEntry, rulestreamerrorinternal=rulestreamerrorinternal, serviceProtRefusalRFC2396=serviceProtRefusalRFC2396, sysMemSwapped=sysMemSwapped, license_authorized=license_authorized, zxtmTable=zxtmTable, serviceProtTable=serviceProtTable, ipSessionCacheEntries=ipSessionCacheEntries, sslhwrestart=sslhwrestart, rateClassTable=rateClassTable, numberDNSACacheHits=numberDNSACacheHits, eventsMatched=eventsMatched, licensekeyName=licensekeyName, bandwidthClassBytesOutHi=bandwidthClassBytesOutHi, licensekeys=licensekeys, noderesolvefailure=noderesolvefailure, virtualserverHttpCacheHitRate=virtualserverHttpCacheHitRate, autoscalepoolconfupdate=autoscalepoolconfupdate, vssslcerttoexpire=vssslcerttoexpire, autoscalewrongname=autoscalewrongname, listenIPTable=listenIPTable, ehloinvalid=ehloinvalid, perNodeServiceLevelInet46NodeAddressType=perNodeServiceLevelInet46NodeAddressType, aspSessionCacheHitRate=aspSessionCacheHitRate, sslSessionCacheHits=sslSessionCacheHits, virtualserverDataTimedOut=virtualserverDataTimedOut, javastartfail=javastartfail, locationsoapfail=locationsoapfail, license_graceperiodexpired=license_graceperiodexpired, javaterminatefail=javaterminatefail, serviceLevelEntry=serviceLevelEntry, nodeInet46ResponseMax=nodeInet46ResponseMax, serviceProtRefusalConc10IP=serviceProtRefusalConc10IP, monitorTable=monitorTable, autonodedestructioncomplete=autonodedestructioncomplete, sslHandshakeSSLv2=sslHandshakeSSLv2, webCacheLookupsLo=webCacheLookupsLo, cloudcredentialsStatusRequests=cloudcredentialsStatusRequests, interfaceEntry=interfaceEntry, webCacheHitsHi=webCacheHitsHi, sslCipherRSAEncryptsExternal=sslCipherRSAEncryptsExternal, autoscalinghitroof=autoscalinghitroof, nodeInet46IdleConns=nodeInet46IdleConns, virtualserverBytesInHi=virtualserverBytesInHi, perNodeServiceLevelTotalNonConf=perNodeServiceLevelTotalNonConf, uniSessionCacheEntries=uniSessionCacheEntries, cloudcredentialsNodeDeletions=cloudcredentialsNodeDeletions, serviceLevelResponseMean=serviceLevelResponseMean, perNodeServiceLevelInet46ResponseMean=perNodeServiceLevelInet46ResponseMean, usingdevlicense=usingdevlicense, pools=pools, ssldrop=ssldrop, pinggwfail=pinggwfail, sslSessionIDMemCacheMiss=sslSessionIDMemCacheMiss, nodeInet46CurrentRequests=nodeInet46CurrentRequests, sslClientCertInvalid=sslClientCertInvalid, trafficIPGatewayPingRequests=trafficIPGatewayPingRequests, rulelogmsgserious=rulelogmsgserious, rulexmlerr=rulexmlerr, logfiledeleted=logfiledeleted, cloudcredentialsClassNumber=cloudcredentialsClassNumber, aspSessionCacheMisses=aspSessionCacheMisses, connerror=connerror, sslSessionIDMemCacheHit=sslSessionIDMemCacheHit, eventTable=eventTable, numberSNMPBadRequests=numberSNMPBadRequests, autoscalingresuscitatepool=autoscalingresuscitatepool, rateClassConnsEntered=rateClassConnsEntered, sslSessionCacheLookups=sslSessionCacheLookups, pooluseunknown=pooluseunknown, norate=norate, autoscalingprocesstimedout=autoscalingprocesstimedout, flipperraiselocalworking=flipperraiselocalworking, nodeResponseMax=nodeResponseMax, autonodecreationstarted=autonodecreationstarted, actionTable=actionTable, vslogwritefail=vslogwritefail, poolSessionMigrated=poolSessionMigrated, nodeResponseMin=nodeResponseMin, serviceProtLastRefusalTime=serviceProtLastRefusalTime, confok=confok, totalBytesOutLo=totalBytesOutLo, sslCacheEntriesMax=sslCacheEntriesMax, serviceLevelName=serviceLevelName, perPoolNodeNodeAddressType=perPoolNodeNodeAddressType, cloudcredentialsTable=cloudcredentialsTable, javastop=javastop, trafficIPNumberRaisedInet46=trafficIPNumberRaisedInet46, restartrequired=restartrequired, glbServiceNumber=glbServiceNumber, numberChildProcesses=numberChildProcesses, totalCurrentConn=totalCurrentConn, j2eeSessionCacheEntriesMax=j2eeSessionCacheEntriesMax, aspSessionCacheEntries=aspSessionCacheEntries, nodeResponseMean=nodeResponseMean, trafficIPPingResponseErrors=trafficIPPingResponseErrors, serviceProtNumber=serviceProtNumber, autoscaledpoolrefractory=autoscaledpoolrefractory, sslCacheLookups=sslCacheLookups, version=version, aspSessionCacheOldest=aspSessionCacheOldest, perNodeServiceLevelNodeIPAddr=perNodeServiceLevelNodeIPAddr, locationName=locationName, zxtmswerror=zxtmswerror, allmachinesok=allmachinesok, responsetoolarge=responsetoolarge, bandwidthClassEntry=bandwidthClassEntry, rulelogmsgwarn=rulelogmsgwarn, perPoolNodeErrors=perPoolNodeErrors, poolEntry=poolEntry, perPoolNodeNodeHostName=perPoolNodeNodeHostName, javadied=javadied, webCacheEntries=webCacheEntries, listenIPBytesInHi=listenIPBytesInHi, authenticatorTable=authenticatorTable, numberSNMPUnauthorisedRequests=numberSNMPUnauthorisedRequests, rtspstreamnoports=rtspstreamnoports, virtualserverEntry=virtualserverEntry, virtualserverSIPTotalCalls=virtualserverSIPTotalCalls, poolPersistence=poolPersistence, autoscaledpooltoobig=autoscaledpooltoobig, trafficIPNodePingRequests=trafficIPNodePingRequests, virtualserverUdpTimedOut=virtualserverUdpTimedOut, perPoolNodeCurrentConn=perPoolNodeCurrentConn, glbserviceok=glbserviceok, licensetoomanylocations=licensetoomanylocations, nodeHostName=nodeHostName, virtualserverCurrentConn=virtualserverCurrentConn, nodeInet46Errors=nodeInet46Errors, pingfrontendfail=pingfrontendfail, sslCipherRSADecryptsExternal=sslCipherRSADecryptsExternal, activatedautomatically=activatedautomatically, nodes=nodes, noderesolvemultiple=noderesolvemultiple)
mibBuilder.exportSymbols("ZXTM-MIB", poolFailPool=poolFailPool, licensekeyTable=licensekeyTable, flipperipexists=flipperipexists, autoscalednodecontested=autoscalednodecontested, servicerulelocnotconfigured=servicerulelocnotconfigured, serviceProtName=serviceProtName, ruleTable=ruleTable, apistatusprocesshanging=apistatusprocesshanging, bandwidthClassName=bandwidthClassName, autoscaledpooltoosmall=autoscaledpooltoosmall, rateClassMaxRatePerMin=rateClassMaxRatePerMin, authenticatorFails=authenticatorFails, autonodecreationcomplete=autonodecreationcomplete, ruleResponds=ruleResponds, slmfallenbelowserious=slmfallenbelowserious, ruleRetries=ruleRetries, sslClientCertNotSent=sslClientCertNotSent, perNodeServiceLevelInet46NodePort=perNodeServiceLevelInet46NodePort, autoscalingpoolstatechange=autoscalingpoolstatechange, nodeInet46ResponseMin=nodeInet46ResponseMin, rulestreamerrorgetresponse=rulestreamerrorgetresponse, totalConn=totalConn, virtualserverHttpRewriteCookie=virtualserverHttpRewriteCookie, glbServiceTable=glbServiceTable, usedcredsdeleted=usedcredsdeleted, totalBytesInHi=totalBytesInHi, sysCPUIdlePercent=sysCPUIdlePercent, sslHandshakeTLSv1=sslHandshakeTLSv1, statetimeout=statetimeout, perLocationServiceMonitorState=perLocationServiceMonitorState, aspSessionCacheLookups=aspSessionCacheLookups, monitorNumber=monitorNumber, nodeErrors=nodeErrors, sysCPUBusyPercent=sysCPUBusyPercent, slmclasslimitexceeded=slmclasslimitexceeded, autherror=autherror, geodataloadfail=geodataloadfail, sipstreamnoports=sipstreamnoports, license_rejected_unauthorized=license_rejected_unauthorized, interfaceTxBytesLo=interfaceTxBytesLo, webCacheMemMaximum=webCacheMemMaximum, nostarttls=nostarttls, stateok=stateok, serviceProtRefusalSize=serviceProtRefusalSize, totalBadDNSPackets=totalBadDNSPackets, serviceLevelConforming=serviceLevelConforming, nodePort=nodePort, perPoolNodeNewConn=perPoolNodeNewConn, poolactivenodesunknown=poolactivenodesunknown, sysMemFree=sysMemFree, trafficIPInet46Time=trafficIPInet46Time, virtualserverName=virtualserverName, actions=actions, nodeInet46Port=nodeInet46Port, listenIPAddressType=listenIPAddressType, autoscalinghysteresiscantgrow=autoscalinghysteresiscantgrow, nodeInet46PooledConn=nodeInet46PooledConn, sysMemSwapTotal=sysMemSwapTotal, licensecorrupt=licensecorrupt, pooldied=pooldied, flipperfrontendsworking=flipperfrontendsworking, locationok=locationok, datastorefull=datastorefull, perNodeServiceLevelTotalConn=perNodeServiceLevelTotalConn, actionName=actionName, sslCipherRSAEncrypts=sslCipherRSAEncrypts, nodeEntry=nodeEntry, virtualserverHttpRewriteLocation=virtualserverHttpRewriteLocation, poolok=poolok, virtualserverBytesInLo=virtualserverBytesInLo, virtualserverHttpCacheHits=virtualserverHttpCacheHits, dataEntries=dataEntries, numberSNMPGetNextRequests=numberSNMPGetNextRequests, nodefail=nodefail, confName=confName, interfaceCollisions=interfaceCollisions, javastarted=javastarted, zxtm=zxtm, zxtms=zxtms, trafficIPNodePingResponses=trafficIPNodePingResponses, sysFDsFree=sysFDsFree, ruleabort=ruleabort, userCounterValue=userCounterValue, trafficIPTable=trafficIPTable, nodeInet46NewConn=nodeInet46NewConn, ssltpslimited=ssltpslimited, zxtmName=zxtmName, unlicensed=unlicensed, locationResponses=locationResponses, zxtmNumber=zxtmNumber, monitorEntry=monitorEntry, flipperrecovered=flipperrecovered, sslSessionIDDiskCacheMiss=sslSessionIDDiskCacheMiss, rulestreamerrortoomuch=rulestreamerrortoomuch, bandwidthClassTable=bandwidthClassTable, webCacheLookupsHi=webCacheLookupsHi, ec2flipperraiseothersdead=ec2flipperraiseothersdead, locationmonitorok=locationmonitorok, cannotshrinkemptypool=cannotshrinkemptypool, serviceProtTotalRefusal=serviceProtTotalRefusal, numberSNMPGetRequests=numberSNMPGetRequests, glbServiceResponses=glbServiceResponses, rules=rules, numIdleConnections=numIdleConnections, locationTable=locationTable, webCacheOldest=webCacheOldest, autoscalinglicensedisabled=autoscalinglicensedisabled, servicerulelocunknown=servicerulelocunknown, poolMinQueueTime=poolMinQueueTime, serviceProtRefusalConnRate=serviceProtRefusalConnRate, autoscalinghysteresiscantshrink=autoscalinghysteresiscantshrink, perPoolNodeNodeAddress=perPoolNodeNodeAddress, glbServiceUnmodified=glbServiceUnmodified, trafficIPNumberRaised=trafficIPNumberRaised, autonodestatuschange=autonodestatuschange, webCacheMissesLo=webCacheMissesLo, listenIPAddress=listenIPAddress, sysCPUSystemBusyPercent=sysCPUSystemBusyPercent, totalTransactions=totalTransactions, monitors=monitors, serviceProtRefusalBinary=serviceProtRefusalBinary, virtualserverNumber=virtualserverNumber, locmovemachine=locmovemachine, actionNumber=actionNumber, serviceLevelTotalConn=serviceLevelTotalConn, virtualserverTotalConn=virtualserverTotalConn, virtualserverGzipBytesSavedHi=virtualserverGzipBytesSavedHi, poolDisabled=poolDisabled, slmrecoveredwarn=slmrecoveredwarn, connfail=connfail, flipperbackendsworking=flipperbackendsworking, poolMeanQueueTime=poolMeanQueueTime, numberDNSPTRRequests=numberDNSPTRRequests, serviceProtRefusalConc1IP=serviceProtRefusalConc1IP, bandwidthmgt=bandwidthmgt, aspsessioncache=aspsessioncache, webCacheMemUsed=webCacheMemUsed, perLocationServiceDraining=perLocationServiceDraining, nodeNumber=nodeNumber, nodeInet46AddressType=nodeInet46AddressType, virtualserverDiscard=virtualserverDiscard, serviceLevelNumber=serviceLevelNumber, nodeInet46Failures=nodeInet46Failures, serviceLevelCurrentConns=serviceLevelCurrentConns, poolDraining=poolDraining, serviceProtEntry=serviceProtEntry, zxtmEntry=zxtmEntry, virtualserverKeepaliveTimedOut=virtualserverKeepaliveTimedOut, autoscalingchangeprocessfailure=autoscalingchangeprocessfailure, perlocationservices=perlocationservices, userCounterNumber=userCounterNumber, machinefail=machinefail, eventNumber=eventNumber, perLocationServiceTable=perLocationServiceTable, timemovedback=timemovedback, javanotfound=javanotfound, forwardproxybadhost=forwardproxybadhost, trafficIPAddress=trafficIPAddress, maxclientbufferdrop=maxclientbufferdrop, uniSessionCacheHits=uniSessionCacheHits, logdiskfull=logdiskfull, dropipwarn=dropipwarn, sslCipherRC4Encrypts=sslCipherRC4Encrypts, serviceLevelResponseMax=serviceLevelResponseMax, licensekeyNumber=licensekeyNumber, ipSessionCacheHitRate=ipSessionCacheHitRate, bwlimited=bwlimited, extra=extra, serviceProtRefusalIP=serviceProtRefusalIP, nodeBytesToNodeHi=nodeBytesToNodeHi, poolTable=poolTable, authenticatorNumber=authenticatorNumber, listenips=listenips, sslCipherDESEncrypts=sslCipherDESEncrypts, cachesizereduced=cachesizereduced, ruleNumber=ruleNumber, interfaceRxErrors=interfaceRxErrors, virtualserverDirectReplies=virtualserverDirectReplies, upTime=upTime, j2eeSessionCacheHits=j2eeSessionCacheHits, userCounterTable=userCounterTable, locempty=locempty, flipperdadreraise=flipperdadreraise, interfaceRxBytesHi=interfaceRxBytesHi, fullLogLine=fullLogLine, rateClassConnsLeft=rateClassConnsLeft, vsstart=vsstart, sslCacheMisses=sslCacheMisses, logdiskoverload=logdiskoverload, uniSessionCacheHitRate=uniSessionCacheHitRate, sslSessionCacheEntries=sslSessionCacheEntries, nodePooledConn=nodePooledConn, virtualserverTable=virtualserverTable, trafficIPGatewayPingResponses=trafficIPGatewayPingResponses, glbdeadlocmissingips=glbdeadlocmissingips, perLocationServiceState=perLocationServiceState, stateunexpected=stateunexpected, autoscalewrongsizeid=autoscalewrongsizeid, poolBytesInHi=poolBytesInHi, perLocationServiceResponses=perLocationServiceResponses, eventEntry=eventEntry, glblogwritefail=glblogwritefail, poolQueueTimeouts=poolQueueTimeouts, perNodeServiceLevelEntry=perNodeServiceLevelEntry, zeus=zeus, perPoolNodeBytesToNodeLo=perPoolNodeBytesToNodeLo, nodeInet46Address=nodeInet46Address, interfaceTable=interfaceTable, sslCacheHitRate=sslCacheHitRate, machinerecovered=machinerecovered, sslhwfail=sslhwfail, zclustermoderr=zclustermoderr, rulePoolSelect=rulePoolSelect, perLocationServiceEntry=perLocationServiceEntry, vscacertexpired=vscacertexpired, interfaceRxBytesLo=interfaceRxBytesLo, ec2flipperraiselocalworking=ec2flipperraiselocalworking, ipSessionCacheEntriesMax=ipSessionCacheEntriesMax, locationEntry=locationEntry, statewritefail=statewritefail, respcompfail=respcompfail, numberDNSPTRCacheHits=numberDNSPTRCacheHits, locationmonitorfail=locationmonitorfail, perNodeServiceLevelInet46ResponseMin=perNodeServiceLevelInet46ResponseMin, autonodedestroyed=autonodedestroyed, eventsSeen=eventsSeen, sslCipherAESDecrypts=sslCipherAESDecrypts, glbServiceName=glbServiceName, serviceLevelResponseMin=serviceLevelResponseMin, uniSessionCacheMisses=uniSessionCacheMisses, nodeBytesFromNodeLo=nodeBytesFromNodeLo, sslHandshakeTLSv11=sslHandshakeTLSv11, rulebufferlarge=rulebufferlarge, slmrecoveredserious=slmrecoveredserious, pingbackendfail=pingbackendfail, ipsessioncache=ipsessioncache, virtualserverConnectionErrors=virtualserverConnectionErrors, perPoolNodeBytesToNodeHi=perPoolNodeBytesToNodeHi, actionEntry=actionEntry, locationfail=locationfail, autoscalingdisabled=autoscalingdisabled, ruleExecutions=ruleExecutions, serviceLevelTable=serviceLevelTable, ipSessionCacheHits=ipSessionCacheHits, virtualserverBytesOutHi=virtualserverBytesOutHi, poolAlgorithm=poolAlgorithm, perPoolNodeResponseMax=perPoolNodeResponseMax, glbmissingips=glbmissingips, j2eeSessionCacheEntries=j2eeSessionCacheEntries, netinterfaces=netinterfaces, aspSessionCacheEntriesMax=aspSessionCacheEntriesMax, uniSessionCacheLookups=uniSessionCacheLookups, glbServiceDiscarded=glbServiceDiscarded, vscrloutofdate=vscrloutofdate)
mibBuilder.exportSymbols("ZXTM-MIB", perPoolNodeTable=perPoolNodeTable, interfaceNumber=interfaceNumber, analyticslicensedisabled=analyticslicensedisabled, expiresoon=expiresoon, j2eeSessionCacheOldest=j2eeSessionCacheOldest, listenIPTotalConn=listenIPTotalConn, virtualserverProtocol=virtualserverProtocol, webcache=webcache, sysMemInUse=sysMemInUse, interfaceTxPackets=interfaceTxPackets, trafficIPNumberInet46=trafficIPNumberInet46, numberDNSARequests=numberDNSARequests, vsstop=vsstop, cache=cache, dropipinfo=dropipinfo, uniSessionCacheEntriesMax=uniSessionCacheEntriesMax, zxtmtraps=zxtmtraps, trafficips=trafficips, virtualserverTotalDgram=virtualserverTotalDgram, listenIPMaxConn=listenIPMaxConn, invalidemit=invalidemit, listenIPBytesOutHi=listenIPBytesOutHi, virtualserverSIPRejectedRequests=virtualserverSIPRejectedRequests, nodeInet46BytesToNodeLo=nodeInet46BytesToNodeLo, ipSessionCacheOldest=ipSessionCacheOldest, locationCode=locationCode, interfaceTxErrors=interfaceTxErrors, lessmemallowed=lessmemallowed, perNodeServiceLevelResponseMean=perNodeServiceLevelResponseMean, glbServiceEntry=glbServiceEntry, serviceruleabort=serviceruleabort, sslCipherRSADecrypts=sslCipherRSADecrypts, serviceLevelTotalNonConf=serviceLevelTotalNonConf, perNodeServiceLevelInet46TotalNonConf=perNodeServiceLevelInet46TotalNonConf, servicerulelocdead=servicerulelocdead, rulestreamerrorprocessfailure=rulestreamerrorprocessfailure, products=products, autoscalinghitfloor=autoscalinghitfloor, license_unauthorized=license_unauthorized, monitorok=monitorok, userCounterName=userCounterName, servleterror=servleterror, unisessioncache=unisessioncache, nodeInet46BytesFromNodeLo=nodeInet46BytesFromNodeLo, starttlsinvalid=starttlsinvalid, confreptimeout=confreptimeout, totalBackendServerErrors=totalBackendServerErrors, sslcache=sslcache, j2eesessioncache=j2eesessioncache, perNodeServiceLevelInet46TotalConn=perNodeServiceLevelInet46TotalConn, confmod=confmod, autoscaleresponseparseerror=autoscaleresponseparseerror, sslClientCertRevoked=sslClientCertRevoked, glbservicedied=glbservicedied, nodeInet46BytesFromNodeHi=nodeInet46BytesFromNodeHi, autoscalestatusupdateerror=autoscalestatusupdateerror, glbfailalter=glbfailalter, nodeTable=nodeTable, trafficIPInet46Table=trafficIPInet46Table, virtualserverGzipBytesSavedLo=virtualserverGzipBytesSavedLo, sslCacheEntries=sslCacheEntries, autoscaleinvalidargfordeletenode=autoscaleinvalidargfordeletenode, perLocationServiceFrontendState=perLocationServiceFrontendState, glbservices=glbservices, confadd=confadd, authenticatorPasses=authenticatorPasses, poolBytesOutHi=poolBytesOutHi, poolpersistencemismatch=poolpersistencemismatch, fewfreefds=fewfreefds, sysCPUUserBusyPercent=sysCPUUserBusyPercent, perNodeServiceLevelTable=perNodeServiceLevelTable, virtualserverDefaultTrafficPool=virtualserverDefaultTrafficPool, cloudcredentialsNodeCreations=cloudcredentialsNodeCreations, autoscalinglicenseerror=autoscalinglicenseerror, perNodeServiceLevelInet46Entry=perNodeServiceLevelInet46Entry, flipperraiseosdrop=flipperraiseosdrop, privkeyok=privkeyok, ipSessionCacheMisses=ipSessionCacheMisses, ruleName=ruleName, machineok=machineok, ruleDiscards=ruleDiscards, versionmismatch=versionmismatch, webCacheHitsLo=webCacheHitsLo, userCounterEntry=userCounterEntry, nodeTotalConn=nodeTotalConn, nodeIPAddress=nodeIPAddress, j2eeSessionCacheLookups=j2eeSessionCacheLookups, virtualserverBytesOutLo=virtualserverBytesOutLo, globals=globals, vscacerttoexpire=vscacerttoexpire, actionsProcessed=actionsProcessed, nodeInet46ResponseMean=nodeInet46ResponseMean, activatealldead=activatealldead, trafficIPNumber=trafficIPNumber, sslCipherAESEncrypts=sslCipherAESEncrypts, nodeNewConn=nodeNewConn, bandwidthClassNumber=bandwidthClassNumber, sslHandshakeSSLv3=sslHandshakeSSLv3, rulelogmsginfo=rulelogmsginfo, interfaceName=interfaceName, morememallowed=morememallowed, sslfail=sslfail, poolState=poolState, perPoolNodeEntry=perPoolNodeEntry, apichangeprocesshanging=apichangeprocesshanging, ec2nopublicip=ec2nopublicip, listenIPBytesInLo=listenIPBytesInLo, serviceprotection=serviceprotection, dataMemoryUsage=dataMemoryUsage, connratelimit=connratelimit, rateClassMaxRatePerSec=rateClassMaxRatePerSec, interfaceRxPackets=interfaceRxPackets, perNodeServiceLevelInet46ResponseMax=perNodeServiceLevelInet46ResponseMax, analyticslicenseenabled=analyticslicenseenabled, listenIPBytesOutLo=listenIPBytesOutLo, perNodeServiceLevelResponseMin=perNodeServiceLevelResponseMin, trapobjects=trapobjects, perNodeServiceLevelSLMName=perNodeServiceLevelSLMName, rateClassDropped=rateClassDropped, vssslcertexpired=vssslcertexpired, sslClientCertExpired=sslClientCertExpired, virtualserverHttpCacheLookups=virtualserverHttpCacheLookups, trafficIPState=trafficIPState, dropec2ipwarn=dropec2ipwarn, perPoolNodePoolName=perPoolNodePoolName, trafficIPInet46Address=trafficIPInet46Address, eventName=eventName, usinglicense=usinglicense, perPoolNodeNumber=perPoolNodeNumber, persistence=persistence, trafficIPInet46Entry=trafficIPInet46Entry, nodeCurrentConn=nodeCurrentConn, listenIPCurrentConn=listenIPCurrentConn, licensekeyEntry=licensekeyEntry, locations=locations, virtualserverGzip=virtualserverGzip, perPoolNodeFailures=perPoolNodeFailures, sslSessionCacheOldest=sslSessionCacheOldest, sslCipherEncrypts=sslCipherEncrypts, totalRequests=totalRequests, statereadfail=statereadfail, confdel=confdel, locationsoapok=locationsoapok, authenticatorRequests=authenticatorRequests, serviceLevelIsOK=serviceLevelIsOK, servicelevelmonitoring=servicelevelmonitoring, sslsessioncache=sslsessioncache, perPoolNodeNodePort=perPoolNodeNodePort, nodeInet46CurrentConn=nodeInet46CurrentConn, nodeBytesFromNodeHi=nodeBytesFromNodeHi, expired=expired, multihostload=multihostload, ec2iperr=ec2iperr, sslSessionCacheHitRate=sslSessionCacheHitRate, authenticatorErrors=authenticatorErrors, webCacheHitRate=webCacheHitRate, perPoolNodeState=perPoolNodeState, nodeState=nodeState, nodeCurrentRequests=nodeCurrentRequests, rulesinvalidrequestbody=rulesinvalidrequestbody, perPoolNodeResponseMin=perPoolNodeResponseMin, bandwidthClassMaximum=bandwidthClassMaximum, totalDNSResponses=totalDNSResponses)

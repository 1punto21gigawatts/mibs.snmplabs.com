#
# PySNMP MIB module A3COM51-SS9000SX (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM51-SS9000SX
# Produced by pysmi-0.3.4 at Wed May  1 11:09:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysDescr, sysUpTime = mibBuilder.importSymbols("SNMPv2-MIB", "sysDescr", "sysUpTime")
Counter64, NotificationType, Unsigned32, Bits, IpAddress, MibIdentifier, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter32, iso, ObjectIdentity, Integer32, TimeTicks, NotificationType, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "NotificationType", "Unsigned32", "Bits", "IpAddress", "MibIdentifier", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter32", "iso", "ObjectIdentity", "Integer32", "TimeTicks", "NotificationType", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
extreme = MibIdentifier((1, 3, 6, 1, 4, 1, 1916))
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8))
superStackSwitch9000SX = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 32))
superStackSwitch3800 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 34))
superStackSwitch9100 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 36))
superStackSwitch9000SX_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 27)).setLabel("superStackSwitch9000SX-mib")
overheat = NotificationType((1, 3, 6, 1, 4, 1, 1916) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("SNMPv2-MIB", "sysDescr"))
if mibBuilder.loadTexts: overheat.setDescription('A overheat trap indicates that the on board tempature sensor has reported a overheat condition. System will shutdown until unit has suficiently cooled such that operation may begin again. A cold start trap will be issued when the unit has come back on line.')
fanfailed = NotificationType((1, 3, 6, 1, 4, 1, 1916) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("SNMPv2-MIB", "sysDescr"))
if mibBuilder.loadTexts: fanfailed.setDescription('A fan failed trap indicates one or more of the cooling fans inside the device has failed. A fanOK trap will be sent once the fan has attained normal operation.')
fanOK = NotificationType((1, 3, 6, 1, 4, 1, 1916) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("SNMPv2-MIB", "sysDescr"))
if mibBuilder.loadTexts: fanOK.setDescription('A fan has tansitioned out of a failure state and is now operating correctly.')
invalidLoginAttempt = NotificationType((1, 3, 6, 1, 4, 1, 1916) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("SNMPv2-MIB", "sysDescr"))
if mibBuilder.loadTexts: invalidLoginAttempt.setDescription('A user attempted to login to console or by telnet but was refused access due to incorrect username or password')
ss9000UnitPaceMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 27, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normalEthernet", 2), ("lowLatency", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ss9000UnitPaceMode.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000UnitPaceMode.setDescription('This object specifies the type of backoff algorithm. Any port can use the standard ethernet algorithm or, for PACE applications, it can be set into low latency mode. In this mode, the backoff algorithm is optimized to minimize the possibility of collisions. PACE mode can be set for the whole unit only.')
ss9000PortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 27, 2), )
if mibBuilder.loadTexts: ss9000PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortTable.setDescription('The port management table.')
ss9000PortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 27, 2, 1), ).setIndexNames((0, "A3COM51-SS9000SX", "ss9000PortIndex"))
if mibBuilder.loadTexts: ss9000PortTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortTableEntry.setDescription('This table contains pairs of 32-bit counters which map to RMON 2 64-bit counters')
ss9000PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortIndex.setDescription('The index of this table entry.')
ss9000PortRxPktCtLow = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortRxPktCtLow.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortRxPktCtLow.setDescription('The lower 32 bits of the 64 bit receive packet counter for this port')
ss9000PortRxPktCtHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortRxPktCtHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortRxPktCtHigh.setDescription('The upper 32 bits of the 64 bit receive packet counter for this port')
ss9000PortRxByteCtLow = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortRxByteCtLow.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortRxByteCtLow.setDescription('The lower 32 bits of the 64 bit receive byte counter for this port')
ss9000PortRxByteCtHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortRxByteCtHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortRxByteCtHigh.setDescription('The upper 32 bits of the 64 bit receive byte counter for this port')
ss9000PortTxPktCtLow = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortTxPktCtLow.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortTxPktCtLow.setDescription('The lower 32 bits of the 64 bit transmit packet counter for this port')
ss9000PortTxPktCtHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortTxPktCtHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortTxPktCtHigh.setDescription('The upper 32 bits of the 64 bit transmit packet counter for this port')
ss9000PortTxByteCtLow = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortTxByteCtLow.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortTxByteCtLow.setDescription('The lower 32 bits of the 64 bit transmit byte counter for this port')
ss9000PortTxByteCtHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 27, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000PortTxByteCtHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000PortTxByteCtHigh.setDescription('The upper 32 bits of the 64 bit transmit byte counter for this port')
ss9000SaveConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 43, 27, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("saveToPrimary", 1), ("saveToSecondary", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: ss9000SaveConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000SaveConfiguration.setDescription('When this object is set, the device will copy the contents of the configuration database to a buffer and save it to the persistant store specified by the value of the object. The save is performed asynchronously, and the snmp agent will continue to respond to both gets and sets while the save is taking place. A network management application may use the ss9000SaveStatus object to determine when the asynchronous save operation has completed.')
ss9000SaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 27, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("saveInProgress", 1), ("saveNotInProgress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ss9000SaveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ss9000SaveStatus.setDescription('This object will return the status of a save operation invoked by setting the ss9000SaveConfiguration object. A network management application can read this object to determine that a save operation has completed.')
ss9000MauType = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 27, 5))
ss9000MauType1000BaseSX = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 27, 5, 1))
mibBuilder.exportSymbols("A3COM51-SS9000SX", ss9000PortRxByteCtLow=ss9000PortRxByteCtLow, ss9000PortTxPktCtLow=ss9000PortTxPktCtLow, ss9000PortTable=ss9000PortTable, invalidLoginAttempt=invalidLoginAttempt, ss9000PortTxByteCtLow=ss9000PortTxByteCtLow, superStackSwitch9000SX=superStackSwitch9000SX, ss9000MauType=ss9000MauType, ss9000SaveStatus=ss9000SaveStatus, ss9000PortRxPktCtHigh=ss9000PortRxPktCtHigh, superStackSwitch9100=superStackSwitch9100, ss9000PortTxPktCtHigh=ss9000PortTxPktCtHigh, ss9000MauType1000BaseSX=ss9000MauType1000BaseSX, ss9000SaveConfiguration=ss9000SaveConfiguration, extreme=extreme, ss9000UnitPaceMode=ss9000UnitPaceMode, fanfailed=fanfailed, ss9000PortRxByteCtHigh=ss9000PortRxByteCtHigh, overheat=overheat, ss9000PortRxPktCtLow=ss9000PortRxPktCtLow, fanOK=fanOK, hub=hub, ss9000PortTxByteCtHigh=ss9000PortTxByteCtHigh, ss9000PortTableEntry=ss9000PortTableEntry, superStackSwitch3800=superStackSwitch3800, products=products, ss9000PortIndex=ss9000PortIndex, a3Com=a3Com, superStackSwitch9000SX_mib=superStackSwitch9000SX_mib)

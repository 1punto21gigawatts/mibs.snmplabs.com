#
# PySNMP MIB module CISCO-ATM-CONN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ATM-CONN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:50:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
atmVclVpi, atmVplVpi, AtmTrafficDescrParamIndex, atmVclVci = mibBuilder.importSymbols("ATM-MIB", "atmVclVpi", "atmVplVpi", "AtmTrafficDescrParamIndex", "atmVclVci")
NsapAtmAddr, = mibBuilder.importSymbols("CISCO-ATM-IF-MIB", "NsapAtmAddr")
LsPerVcqThresholdGroup, = mibBuilder.importSymbols("CISCO-ATM-RM-MIB", "LsPerVcqThresholdGroup")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
IpAddress, Counter32, iso, ObjectIdentity, Bits, Integer32, Unsigned32, MibIdentifier, Gauge32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter32", "iso", "ObjectIdentity", "Bits", "Integer32", "Unsigned32", "MibIdentifier", "Gauge32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "NotificationType")
RowStatus, TextualConvention, TruthValue, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "TimeStamp", "DisplayString")
ciscoAtmConnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 13))
ciscoAtmConnMIB.setRevisions(('2002-07-12 00:00', '2001-10-30 00:00', '2001-10-10 00:00', '2001-08-06 00:00', '2001-01-29 00:00', '1998-10-02 00:00', '1997-05-26 00:00', '1996-11-01 00:00', '1998-07-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoAtmConnMIB.setRevisionsDescriptions(("Added a new enumeration 'useTrafficDescr' to the syntax of ciscoAtmVclEpdEnable.", 'Added ciscoAtmVplConnType and ciscoAtmVclConnType objects to the VPL and VCL tables.', 'Added ciscoAtmVplConnName and ciscoAtmVclConnName objects to the VPL and VCL tables.', 'Added a enumeration for ConfigType to enable configuration of Passive Half leg for 2-ended Soft PVC/PVP', 'Added objects that provide per-connection Transmit statistics for the switch fabric.', 'Added objects for reporting negotiated traffic parameters.', 'Added objects for management of new features made possible on the LS1010 by the Feature Card Plus. This includes support for: - per-VC queueing hardware structures, - enhanced UPC, - per-connection snooping, - enhanced per-connection statistics.', 'Added - VPL/VCL violation counter, - SVC frame discard using AAL5IE, - default VPL/VCL tolerance objects.', 'Added - object to configure a VP leg as a hierarchical VP.',))
if mibBuilder.loadTexts: ciscoAtmConnMIB.setLastUpdated('200207120000Z')
if mibBuilder.loadTexts: ciscoAtmConnMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoAtmConnMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-atm@cisco.com')
if mibBuilder.loadTexts: ciscoAtmConnMIB.setDescription('This MIB module is a cisco extension to VPL/VCL table defined in rfc1695 for ATM switch connection management.')
ciscoAtmConnMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1))
class CastType(TextualConvention, Integer32):
    description = 'Specifies the type of the connection. It can be either a point to point connection or point to multipoint root or leaf.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("pointToPoint", 1), ("pointToMultiPointRoot", 2), ("pointToMultiPointLeaf", 3))

class ConfigType(TextualConvention, Integer32):
    description = "Specifies whether it's a permanent, switched, soft or soft passive config type."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("permanent", 2), ("switch", 3), ("soft", 4), ("softPassive", 5))

class SpanType(TextualConvention, Integer32):
    description = "The SpanType textual convention is used to specify different connection span types. The connection span types are: - 'unknown', which indicates that the connection entry is not cross-connected. - 'transit', which indicates that the connection entry is cross-connected and is not a connection end point. - 'terminate', which indicates that the connection entry is cross-connected and is a connection end point. - 'both', which indicates that the connection is transit as well as terminating. This will be true only if the connection cast type is a pointToMultiPointRoot and has transit and terminating connection leaves. None of the above values may be specified in a management protocol set operation."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("transit", 2), ("terminate", 3), ("both", 4))

class EnableStatus(TextualConvention, Integer32):
    description = 'Enable or Disable operation.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enable", 1), ("disable", 2))

class UpcStatus(TextualConvention, Integer32):
    description = 'Define the Usage Parameter Control (UPC) operation as one of pass,tag or drop at this connection.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("passing", 1), ("tagging", 2), ("dropping", 3), ("localShaping", 4))

class ConnState(TextualConvention, Integer32):
    description = "The ConnState textual convention is used to specify different connection states. The connections states are: - 'setup', which indicates that the connection entry is to be created and installed in the hardware and software connection tables. - 'release', which indicates that the connection entry is to be removed from the hardware and software connection tables. - 'notInstalled', which indicates connection entry is created only in the software connection tables. The connection entry is not installed in the hardware connection table. - 'down' which indicates that connection is down and is present in both software and hardware connection tables. - 'up' which indicates that connection is up and is present in both software and hardware connection tables. - 'setup' and 'release' are only two values may be specified in a management protocol set operation, only three values will be returned in response to a management protocol retrieval operation: 'notInstalled', 'down' or 'up'."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("setup", 1), ("release", 2), ("notInstalled", 3), ("down", 4), ("up", 5))

class Location(TextualConvention, Integer32):
    description = 'Location of calling or called or unknown.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("calling", 2), ("called", 3))

class Direction(TextualConvention, Integer32):
    description = 'Calling or called side associated with address.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("unknown", 1), ("p2pCallingSide", 2), ("p2pCalledSide", 3), ("p2mpRoot", 4), ("p2mpLeaf", 5))

class SnoopDirType(TextualConvention, Integer32):
    description = 'Direction of Snooped Traffic'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("transmit", 1), ("receive", 2))

ciscoAtmVpl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1))
ciscoAtmVplTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1), )
if mibBuilder.loadTexts: ciscoAtmVplTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplTable.setDescription('The Virtual Path Link extension Table.')
ciscoAtmVplEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: ciscoAtmVplEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplEntry.setDescription(' An entry in the Vpl table.This entry is used to model a bi-directional Vpl. This table augments the atmVplTable defined in RFC 1695. However it uses ifIndex and atmVplVpi as an Index for historical reasons. The entries are created/deleted as a by-product of creating and deleting entries in the atmVplTable.')
ciscoAtmVplCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 1), CastType().clone('pointToPoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplCastType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplCastType.setDescription(' Vpl type is either a point to point connection or point to multipoint root or leaf.')
ciscoAtmVplSpanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 2), SpanType().clone('transit')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplSpanType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplSpanType.setDescription(' Vpl span is either a transit one or a terminating one.')
ciscoAtmVplConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 3), ConfigType().clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplConfigType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplConfigType.setDescription(' Vpl type is either a PVC, SVC, Soft PVC or Soft Passive half leg. The half leg can be set to Passive through user configuration only.')
ciscoAtmVplRxUpcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 4), UpcStatus().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplRxUpcMode.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplRxUpcMode.setDescription(' Usage Parameter Control opeartion is pass,tag,drop or local shaping at this connection.')
ciscoAtmVplConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 5), ConnState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplConnState.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplConnState.setDescription('The connection state of this VPL. ')
ciscoAtmVplOamLoopbkTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplOamLoopbkTxInterval.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOamLoopbkTxInterval.setDescription('Frequency of OAM loopback cells generated.')
ciscoAtmVplOamSegmentLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 7), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplOamSegmentLoopback.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOamSegmentLoopback.setDescription('Enable segment loopback on this virtual path.')
ciscoAtmVplOamEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 8), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplOamEndLoopback.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOamEndLoopback.setDescription('Enable end to end loopback on this virtual path.')
ciscoAtmVplOamAisEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 9), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplOamAisEnable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOamAisEnable.setDescription('Enable Alarm Indication Signal OAM cell generation if the interafce goes down on a crossconnect virtual path.')
ciscoAtmVplOamRdiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 10), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplOamRdiEnable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOamRdiEnable.setDescription('Enable Remote Defect Indication OAM cell generation if an Alarm Indication Signal OAM cell is received.')
ciscoAtmVplInstallTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplInstallTime.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplInstallTime.setDescription('The time stamp derived from sysUpTime when this VPL gets created. The VPL entries are created/deleted as a by-product of creating and deleting entries in the atmVplTable defined in RFC1695.')
ciscoAtmVplInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplInCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplInCells.setDescription('The total number of cells received on this VPL.')
ciscoAtmVplOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplOutCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOutCells.setDescription('The total number of cells transmitted on this VPL.')
ciscoAtmVplCrossIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 14), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplCrossIfIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplCrossIfIndex.setDescription("For point to point, this is the cross-connected VPL's ifIndex of this VPL. For point to multi-point connection, this will be the root VPL's ifIndex for a leaf VPL entry in the multicast chain, or it's the 1st leaf for a root VPL entry. If it's zero, it means it's not cross-connected yet. Atomically set ciscoAtmVplConnState, ciscoAtmVplCrossIfIndex and ciscoAtmVplCrossVpi will create or delete a cross connection to crossed half leg of this ciscoAtmVplCrossIfindex and ciscoAtmVplCrossVpi for p2p PVP, or add or drop a multicast connection of this ciscoAtmVplCrossIfindex and ciscoAtmVplCrossVpi to/from the root on the multicast chain for p2mp PVP.")
ciscoAtmVplCrossVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplCrossVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplCrossVpi.setDescription("This specifies the VPI value of the VPL to which this VPL is cross-connected. For point to multi-point connection, this is the root VPL's VPI for the leaf entry. Similarly it is the 1st leaf's VPI value for the root entry.")
ciscoAtmVplNextLeafIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 16), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplNextLeafIfIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplNextLeafIfIndex.setDescription("For point to point, this is zero i.e. not used. For point to multi-point connection, this will be the next leaf VPL's ifIndex on the multicast chain. This will be 0 if this is the root VPL entry. If it's zero for a leaf VPL, it means this is the last leaf.")
ciscoAtmVplNextLeafVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplNextLeafVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplNextLeafVpi.setDescription("For point to point, this is zero i.e. not used. This apply only to point to multi-point connection, this will be the next leaf VPL's VPI on the multicast chain.")
ciscoAtmVplRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 18), NsapAtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplRemoteAddr.setDescription('Soft PVP target address if this is the calling side Soft PVP source address if this is called side. Atomically set ConnState, RemoteAddr and RemoteVpi will create or delete a soft PVP. Atomically set ConnState, RemoteAddr without RemoteVpi will also create or delete a soft PVP but let target switch assign the vpi.')
ciscoAtmVplRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplRemoteVpi.setDescription('Soft PVP target VPI in calling side. 0 in called side.')
ciscoAtmVplLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 20), Location()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplLocation.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLocation.setDescription('Indicate calling or called side of a soft PVP. If ciscoAtmVplConfigType is not soft then ciscoAtmVplLocation value should be ignored.')
ciscoAtmVplSlowRetryIntv = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplSlowRetryIntv.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplSlowRetryIntv.setDescription('Soft PVP slow retry interval time in seconds.')
ciscoAtmVplNumAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplNumAttempts.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplNumAttempts.setDescription('Number of retries made to install this soft PVP connection. If ciscoAtmVplConfigType is not soft then ciscoAtmVplNumAttempts value should be ignored.')
ciscoAtmVplLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplLastReleaseCause.setReference("ATM Forum's UNI3.0/3.1 Speicifcation")
if mibBuilder.loadTexts: ciscoAtmVplLastReleaseCause.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLastReleaseCause.setDescription('Value of the Cause field of the Cause Information Element in the last Release Signalling message received for this SPVP. Indicates the reason for the Release. ciscoAtmVplConfigType is not soft then ciscoAtmVplLastReleaseCause value should be ignored.')
ciscoAtmVplLogicalPortDef = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notLogicalIf", 1), ("isLogicalIf", 2))).clone('notLogicalIf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplLogicalPortDef.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLogicalPortDef.setDescription('Indicates whether the VPC at this VPL interface is an Atm Logical Port interface.')
ciscoAtmVplLogicalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 25), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplLogicalPortIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLogicalPortIndex.setDescription('The ifTable index of the Atm logical port interface associated with this VPL. Only valid if the value of atmVplLogicalPortDef is isLogicalIf, and the VPL row is active.')
ciscoAtmVplUpcViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplUpcViolations.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplUpcViolations.setDescription('The total number of nonconforming cells detected by Usage Parameter Control (UPC) for cells received on this VPL. On LS1010 systems, this counter is valid only if equipped with the Feature Card - Per Flow Queueing.')
ciscoAtmVplEpdTpdCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplEpdTpdCellDrops.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmVplEpdTpdCellDrops.setDescription('Never implemented.')
ciscoAtmVplEpdTpdPacketDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplEpdTpdPacketDrops.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmVplEpdTpdPacketDrops.setDescription('Never implemented.')
ciscoAtmVplEpdTpdPacketsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplEpdTpdPacketsIn.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmVplEpdTpdPacketsIn.setDescription('Never implemented.')
ciscoAtmVplClp1Drops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplClp1Drops.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmVplClp1Drops.setDescription('Never implemented.')
ciscoAtmVplDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplDefaultRxUpcTolerance.setDescription('If the tolerance (CDVT for CBR, ABR, UBR connections, Maximum Burst Size for VBR connectons) requested for Usage Parameter Control is not explicitly specified in VPL creation, this object contains the default that is used. If tolerance is explicitly specified in VPL creation, it can be found in the Traffic Table row specified by atmVplReceiveTrafficDescrIndex, and the value of this object is -1.')
ciscoAtmVplDefaultRxUpcVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplDefaultRxUpcVbrCdvt.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplDefaultRxUpcVbrCdvt.setDescription('If the Cell Delay Variation Tolerance (CDVT) requested for Usage Parameter Control for a VBR connection is not explicitly specified in VPL creation, this object contains the default that is used. If CDVT is explicitly specified in VPL creation, it can be found in the Traffic Table row specified by atmVplReceiveTrafficDescrIndex, and the value of this object is -1.')
ciscoAtmVplLsPerVcqWrrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqWrrWeight.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqWrrWeight.setDescription('Configure the weighting specified for a VP half-leg within a service class to make the scheduling decision among other active VPLs in the service class. This is for transmit on the VPL on the interface. This parameter only applies to transit VPs. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVplLsPerVcqTunnelIsShaped = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 34), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqTunnelIsShaped.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqTunnelIsShaped.setDescription('Determines whether this is to be a -shaped- VP, per the Lightstream per-VC queueing chipset. If the value specified is TRUE, the VP is to be a shaped VP Tunnel. Such a VP cannot be cross-connected. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVplLsPerVcqXmtQueuedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqXmtQueuedCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqXmtQueuedCells.setDescription('Number of cells received on this VPL and residing on the per-connection queue. Note that this value is not valid until the VPL is in an active cross-connect. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVplLsPerVcQThreshGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 36), LsPerVcqThresholdGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcQThreshGrp.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcQThreshGrp.setDescription('The Threshold Group to which the cell-queue for cells received by this VP are queued. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVplInClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplInClp0Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplInClp0Cells.setDescription('The total number of cells with the CLP bit clear received on this VPL. Note that these cells may subsequently be discarded. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVplInClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplInClp1Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplInClp1Cells.setDescription('The total number of cells with the CLP bit set received on this VPL. Note that these cells may subsequently be discarded. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVplOutClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplOutClp0Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOutClp0Cells.setDescription('The total number of cells with the CLP bit clear transmitted on this VPL. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with the Feature Card - Per Flow Queueing.')
ciscoAtmVplOutClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplOutClp1Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplOutClp1Cells.setDescription('The total number of cells with the CLP bit set transmitted on this VPL. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with the Feature Card - Per Flow Queueing.')
ciscoAtmVplCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplCellDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplCellDrops.setDescription('The total number of cells received on this VPL, but discarded. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVplClp0VcqFullCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplClp0VcqFullCellDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplClp0VcqFullCellDrops.setDescription('The total number of cells received on this VPL with the CLP bit clear, discarded because the per-VC queue limit is exceeded. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVplVcqClpThreshCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplVcqClpThreshCellDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplVcqClpThreshCellDrops.setDescription('The total number of cells received on this VPL, discarded because the discard threshold (as opposed to the queue-limit) is exceeded on the per-VC queue, and the CLP bit is set. This counter is valid only: - if the VPL is not a Logical Interface (tunnel). - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVplLsPerVcqTunnelIsHierarchical = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 45), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqTunnelIsHierarchical.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplLsPerVcqTunnelIsHierarchical.setDescription('Determines whether this is to be a -Hierarchical- VP, per the Lightstream per-VC queueing chipset. If the value specified is TRUE, the VP is to be a Hierarchical VP Tunnel. Such a VP cannot be cross-connected. This object is defined on a LS1010 only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVplRxNegTraffDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 46), AtmTrafficDescrParamIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplRxNegTraffDescrIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplRxNegTraffDescrIndex.setDescription('Identifies the entry in the atmTrafficDescrParamTable which contains negotiated traffic parameters applied to the receive direction of this VPL. This object is not instantiated if this VPL is not the calling side of a soft VP, or if there was no traffic negotiation.')
ciscoAtmVplTxNegTraffDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 47), AtmTrafficDescrParamIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplTxNegTraffDescrIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplTxNegTraffDescrIndex.setDescription('Identifies the entry in the atmTrafficDescrParamTable which contains negotiated traffic parameters applied to the transmit direction of this VPL. This object is not instantiated if this VPL is not the calling side of a soft VP, or if there was no traffic negotiation.')
ciscoAtmVplSwFabOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplSwFabOutCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplSwFabOutCells.setDescription('The total number of cells transmitted on this VPL by the Switch Fabric. This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmVplSwFabOutClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplSwFabOutClp0Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplSwFabOutClp0Cells.setDescription('The total number of cells with the CLP bit clear transmitted on this VPL by the Switch Fabric. This object is not instantiated for a VPL that is a logical interface (VP Tunnel). This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmVplSwFabOutClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVplSwFabOutClp1Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplSwFabOutClp1Cells.setDescription('The total number of cells with the CLP bit set transmitted on this VPL by the Switch Fabric. This object is not instantiated for a VPL that is a logical interface (VP Tunnel). This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmVplConnName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 51), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplConnName.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplConnName.setDescription('A human readable string that identifies this connection. This object will return a zero-length string if value is not set.')
ciscoAtmVplConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("endToEnd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVplConnType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVplConnType.setDescription('This object represent the PVP Type for this connection. - local connection within the node - endToEnd across several nodes This object serves as an information object for a management system and has no functional meaning to the switch.')
ciscoAtmVcl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2))
ciscoAtmVclTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1), )
if mibBuilder.loadTexts: ciscoAtmVclTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclTable.setDescription('The Virtual Channel Link extension Table.')
ciscoAtmVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: ciscoAtmVclEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclEntry.setDescription(' An entry in the Vcl table.This entry is used to model a bi-directional Vcl. This table augments the atmVclTable defined in RFC 1695. However it uses ifIndex, atmVclVpi and atmVclVci as an Index for historical reasons. The entries are created/deleted as a by-product of creating and deleting entries in the atmVclTable.')
ciscoAtmVclCastType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 1), CastType().clone('pointToPoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclCastType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclCastType.setDescription(' Vcl type is either a point to point connection or point to multipoint root or leaf.')
ciscoAtmVclSpanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 2), SpanType().clone('transit')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclSpanType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclSpanType.setDescription(' Vcl span is either a transit one or a terminating one.')
ciscoAtmVclConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 3), ConfigType().clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclConfigType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclConfigType.setDescription(' Vcl type is either a PVC, SVC, Soft PVC or Soft Passive half leg. The half leg can be set to Passive through user configuration only.')
ciscoAtmVclRxUpcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 4), UpcStatus().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclRxUpcMode.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclRxUpcMode.setDescription(' Usage Parameter Control opeartion is pass,tag,drop or local shaping at this connection.')
ciscoAtmVclEpdEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("useTrafficDescr", 3))).clone('useTrafficDescr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclEpdEnable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclEpdEnable.setDescription(' Early Packet Discard option used for this VCL. The use is as follows: enable(1) Packet-discard is enabled. disable(2) Packet-discard is disabled. useTrafficDescr(3) Packet-discard in the receive direction is as specified by the atmTrafficFrameDiscard value in row corresponding to atmVclReceiveTrafficDescrIndex. For VCLs of type spvcInitiator, the packet-discard in the reverse direction is as specified by the atmTrafficFrameDiscard value in row corresponding to atmVclTransmitTrafficDescrIndex. ')
ciscoAtmVclConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 6), ConnState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclConnState.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclConnState.setDescription('The connection state of this VCL.')
ciscoAtmVclOamLoopbkTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclOamLoopbkTxInterval.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOamLoopbkTxInterval.setDescription('Frequency of OAM loopback cell are generated on this virtual channel.')
ciscoAtmVclOamSegmentLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 8), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclOamSegmentLoopback.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOamSegmentLoopback.setDescription('Enable segment loopback on this virtual channel.')
ciscoAtmVclOamEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 9), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclOamEndLoopback.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOamEndLoopback.setDescription('Enable end to end loopback on this virtual channel.')
ciscoAtmVclOamAisEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 10), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclOamAisEnable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOamAisEnable.setDescription('Enable Alarm Indication Signal OAM cell generation if the interafce goes down on a crossconnect virtual channel.')
ciscoAtmVclOamRdiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 11), EnableStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclOamRdiEnable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOamRdiEnable.setDescription('Enable Remote Defect Indication OAM cell generation if an Alarm Indication Signal OAM cell is received.')
ciscoAtmVclInstallTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclInstallTime.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclInstallTime.setDescription('The time stamp derived from sysUpTime when this VCL gets created. The VCL entries are created/deleted as a by-product of creating and deleting entries in the atmVclTable defined in RFC1695.')
ciscoAtmVclInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclInCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclInCells.setDescription('The total number of cells received on this VCL.')
ciscoAtmVclOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclOutCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOutCells.setDescription('The total number of cells transmitted on this VCL.')
ciscoAtmVclCrossIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 15), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclCrossIfIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclCrossIfIndex.setDescription("For point to point, this is the cross-connected VCL's ifIndex of this VCL. For point to multi-point connection, this will be the root VCL's ifIndex for a leaf VCL entry in the multicast chain, or it's the 1st leaf VCL for a root VCL entry. If it's zero, it means it's not cross-connected yet. Atomically set ciscoAtmVclConnState, ciscoAtmVclCrossIfindex, ciscoAtmVclCrossVpi and ciscoAtmVclCrossVci will create or delete a cross connection to crossed half leg of this ciscoAtmVclCrossIfindex, ciscoAtmVclCrossVpi and ciscoAtmVclCrossVci for p2p PVC, or add or drop a multicast connection to/from the root of this ciscoAtmVclCrossIfindex, ciscoAtmVclCrossVpi and ciscoAtmVclCrossVci on the multicast chain for p2mp PVC.")
ciscoAtmVclCrossVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclCrossVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclCrossVpi.setDescription("This specifies the VPI value of the VCL to which this VCL is cross-connected. For point to multi-point connection, this is the root VCL's VPI for the leaf entry. Similarly it is the 1st leaf's VPI value for the root entry.")
ciscoAtmVclCrossVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclCrossVci.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclCrossVci.setDescription("This specifies the VCI value of the VCL to which this VCL is cross-connected. For point to multi-point connection, this is the root VCL's VCI for the leaf entry. Similarly it is the 1st leaf's VCI value for the root entry.")
ciscoAtmVclNextLeafIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 18), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclNextLeafIfIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclNextLeafIfIndex.setDescription("For point to point, this is zero i.e. not used. For point to multi-point connection, this will be the next leaf VCL's ifIndex on the multicast chain. This will be 0 if this is the root VCL entry. If it's zero for a leaf VCL, it means this is the last leaf.")
ciscoAtmVclNextLeafVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclNextLeafVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclNextLeafVpi.setDescription("For point to point, this is zero i.e. not used. This apply only to point to multi-point connection, this will be the next leaf VCL's VPI on the multicast chain.")
ciscoAtmVclNextLeafVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclNextLeafVci.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclNextLeafVci.setDescription("For point to point, this is zero i.e. not used. This apply only to point to multi-point connection, this will be the next leaf VCL's VCI on the multicast chain.")
ciscoAtmVclAalEncapFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("aal5Snap", 2), ("aal5Nlpid", 3), ("aal5FrNlpid", 4), ("aal5Mux", 5), ("aal34Smds", 6), ("aalQsAal", 7), ("aal5Ilmi", 8), ("aal5Lane", 9), ("aal5Pnni", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclAalEncapFlag.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclAalEncapFlag.setDescription('Encapsulation type for terminating VC.')
ciscoAtmVclAalEncapProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("ip", 2), ("xns", 3), ("appletalk", 4), ("clns", 5), ("decnet", 6), ("novell", 7), ("apollo", 8), ("vines", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclAalEncapProtocol.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclAalEncapProtocol.setDescription('Protocol for terminating VC if EncapFlag is aal5Mux.')
ciscoAtmVclAalUserVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("boxConfigure", 2), ("busForward", 3), ("busSend", 4), ("clientConfigure", 5), ("clientData", 6), ("clientDirect", 7), ("clientDistribute", 8), ("clientForward", 9), ("clientSend", 10), ("configure", 11), ("serverConfigure", 12), ("serverDirect", 13), ("serverDistribute", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclAalUserVcType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclAalUserVcType.setDescription('Following is the list of user virtual circuit types in case aal5Lane encapusation on this virtual channel. boxConfigure -- The shared Server/Client end of a Configure VCC busForward -- The BUS end of the Data Forward VCC busSend -- The BUS end of the Data Send VCC clientConfigure -- The LE Client end of the Configure Direct VCC clientData -- One end of the Data Direct VCC clientDirect -- The LE Client end of the Control Direct VCC clientDistribute -- The LE Client end of the Control Distribute VCC clientForward -- The LE Client end of the Multicast Forward VCC clientSend -- The LE Client end of the Multicast Send VCC configure -- The Config Server end of any Configure VCC serverConfigure -- The LE Server end of the Configure VCC serverDirect -- The LE Server end of the Control Direct VCC.')
ciscoAtmVclAtmInArpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclAtmInArpInterval.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclAtmInArpInterval.setDescription('Time interval in minutes to send InArp on a PVC for IP over ATM. 0 will disable the InArp for this pvc.')
ciscoAtmVclRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 25), NsapAtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclRemoteAddr.setDescription('Soft PVC target address if this is the calling side Soft PVC source address if this is called side. Atomically set ConnState, RemoteAddr, RemoteVpi and RemoteVci will create or delete a soft PVC. Atomically set ConnState, RemoteAddr without RemoteVpi, Remote Vci will also create or delete a soft PVC but let target switch assign the vpi and vci.')
ciscoAtmVclRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclRemoteVpi.setDescription('Soft PVC target VPI in calling side. 0 in called side.')
ciscoAtmVclRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclRemoteVci.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclRemoteVci.setDescription('Soft PVC target VCI in calling side. 0 in called side.')
ciscoAtmVclLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 28), Location()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclLocation.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclLocation.setDescription('Indicate calling or called side of a soft PVC. If ciscoAtmVclConfigType is not soft then ciscoAtmVclLocation value should be ignored.')
ciscoAtmVclSlowRetryIntv = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclSlowRetryIntv.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclSlowRetryIntv.setDescription('Soft PVC slow retry interval in seconds.')
ciscoAtmVclNumAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclNumAttempts.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclNumAttempts.setDescription('Number of retries made to install this soft PVC connection. If ciscoAtmVclConfigType is not soft then ciscoAtmVclNumAttempts value should be ignored.')
ciscoAtmVclLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclLastReleaseCause.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclLastReleaseCause.setDescription('Value of the Cause field of the Cause Information Element in the last Release Signalling message received for this SPVC. Indicates the reason for the Release. ciscoAtmVclConfigType is not soft then ciscoAtmVclLastReleaseCause value should be ignored.')
ciscoAtmVclUpcViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclUpcViolations.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclUpcViolations.setDescription('The total number of nonconforming cells detected by Usage Parameter Control (UPC) for cells received on this VCL. On LS1010 systems, this counter is valid only on those equipped with the Feature Card - Per Flow Queueing.')
ciscoAtmVclEpdTpdCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclEpdTpdCellDrops.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmVclEpdTpdCellDrops.setDescription('Never implemented.')
ciscoAtmVclEpdTpdPacketDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclEpdTpdPacketDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclEpdTpdPacketDrops.setDescription('The total number of EPD/TPD packet drops of packets received on this VCL. This counter is valid only: - if EPD is enabled on this VCL. - on LS1010 systems, only those equipped with the Feature Card - Per Flow Queueing.')
ciscoAtmVclEpdTpdPacketsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclEpdTpdPacketsIn.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclEpdTpdPacketsIn.setDescription('The total number of packets received in their entirety on this VPL. This counter is valid only: - if EPD is enabled on this VCL. - on LS1010 systems, only those equipped with the Feature Card - Per Flow Queueing.')
ciscoAtmVclClp1Drops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclClp1Drops.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmVclClp1Drops.setDescription('Never implemented.')
ciscoAtmVclDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclDefaultRxUpcTolerance.setDescription('If the tolerance (CDVT for CBR, ABR, UBR connections, Maximum Burst Size for VBR connectons) requested for Usage Parameter Control is not explicitly specified in VCL creation, this object contains the default that is used.If tolerance is explicitly specified in VCL creation, it can be found in the Traffic Table row specified by atmVclReceiveTrafficDescrIndex, and the value of this object is -1.')
ciscoAtmVclDefaultRxUpcVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclDefaultRxUpcVbrCdvt.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclDefaultRxUpcVbrCdvt.setDescription('If the Cell Delay Variation Tolerance (CDVT) requested for Usage Parameter Control for a VBR connection is not explicitly specified in VCL creation, this object contains the default that is used. If CDVT is explicitly specified in VCL creation, it can be found in the Traffic Table row specified by atmVclReceiveTrafficDescrIndex, and the value of this object is -1.')
ciscoAtmVclLsPerVcqWrrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclLsPerVcqWrrWeight.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclLsPerVcqWrrWeight.setDescription('Configure the weighting specified for a VC half-leg within a service class to make the scheduling decision among other active VCLs in the service class. This is for transmit on the VCL on the interface. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVclLsPerVcqXmtQueuedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 41), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclLsPerVcqXmtQueuedCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclLsPerVcqXmtQueuedCells.setDescription('Number of cells received on this VCL and residing on the per-connection queue. Note that this value is not valid until the VCL is in an active cross-connect. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVclLsPerVcQThreshGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 42), LsPerVcqThresholdGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclLsPerVcQThreshGrp.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclLsPerVcQThreshGrp.setDescription('The Threshold Group to which the cell-queue for cells received by this VC are queued. Note that this value is not valid until the VCL is in an active cross-connect. This object is defined only when the switch is equipped with the Lightstream per-VC queueing chipset.')
ciscoAtmVclInClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclInClp0Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclInClp0Cells.setDescription('The total number of cells with the CLP bit clear received on this VCL. Note that these cells may subsequently be discarded. This counter is valid only: - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclInClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclInClp1Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclInClp1Cells.setDescription('The total number of cells with the CLP bit set received on this VCL. Note that these cells may subsequently be discarded. This counter is valid only: - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclOutClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclOutClp0Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOutClp0Cells.setDescription('The total number of cells with the CLP bit clear transmitted on this VCL. This counter is valid only: - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclOutClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclOutClp1Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclOutClp1Cells.setDescription('The total number of cells with the CLP bit set transmitted on this VCL. This counter is valid only: - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclCellDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclCellDrops.setDescription('The total number of cells received on this VCL, but discarded. This counter is valid only: - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclClp0VcqFullCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclClp0VcqFullCellDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclClp0VcqFullCellDrops.setDescription('The total number of cells received on this VCL with the CLP bit clear, discarded because the per-VC queue limit is exceeded. This counter is valid only: - if EPD is disabled on the VCL. - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclVcqClpThreshCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclVcqClpThreshCellDrops.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclVcqClpThreshCellDrops.setDescription('The total number of cells received on this VCL, discarded because the discard threshold (as opposed to the queue-limit) is exceeded on the per-VC queue, and the CLP bit is set. This counter is valid only: - if EPD is disabled on the VCL. - on LS1010 systems, only those equipped with Feature Card - Per Flow Queueing.')
ciscoAtmVclRxNegTraffDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 50), AtmTrafficDescrParamIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclRxNegTraffDescrIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclRxNegTraffDescrIndex.setDescription('Identifies the entry in the atmTrafficDescrParamTable which contains negotiated traffic parameters applied to the receive direction of this VCL. This object is not instantiated if this VCL is not the calling side of a soft VC, or if there was no traffic negotiation.')
ciscoAtmVclTxNegTraffDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 51), AtmTrafficDescrParamIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclTxNegTraffDescrIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclTxNegTraffDescrIndex.setDescription('Identifies the entry in the atmTrafficDescrParamTable which contains negotiated traffic parameters applied to the transmit direction of this VCL. This object is not instantiated if this VCL is not the calling side of a soft VC, or if there was no traffic negotiation.')
ciscoAtmVclSwFabOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclSwFabOutCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclSwFabOutCells.setDescription('The total number of cells transmitted on this VCL by the Switch Fabric. This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmVclSwFabOutClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclSwFabOutClp0Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclSwFabOutClp0Cells.setDescription('The total number of cells with the CLP bit clear transmitted on this VCL by the Switch Fabric. This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmVclSwFabOutClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmVclSwFabOutClp1Cells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclSwFabOutClp1Cells.setDescription('The total number of cells with the CLP bit set transmitted on this VCL by the Switch Fabric. This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmVclConnName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 55), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclConnName.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclConnName.setDescription('A human readable string that identifies this connection. This object will return a zero-length string if value is not set.')
ciscoAtmVclConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 2, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("endToEnd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmVclConnType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmVclConnType.setDescription('This object represent the PVC Type for this connection. - local connection within the node - endToEnd across several nodes. This object serves as an information object for a management system and has no functional meaning to the switch.')
ciscoAtmSvp = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 3))
ciscoAtmSvpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 3, 1), )
if mibBuilder.loadTexts: ciscoAtmSvpAddrTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvpAddrTable.setDescription('Switched virtual path link address table.')
ciscoAtmSvpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-CONN-MIB", "ciscoAtmSvpAddr"), (0, "CISCO-ATM-CONN-MIB", "ciscoAtmSvpVpi"))
if mibBuilder.loadTexts: ciscoAtmSvpAddrEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvpAddrEntry.setDescription(' An entry in the Switched Vrtual Path address table.')
ciscoAtmSvpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: ciscoAtmSvpAddr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvpAddr.setDescription('It depends on the direction.This could be p2pCallingSide address on a called side VPL, or p2pCalledSide address on a calling side VPL or p2mpRoot address on a p2mp leaf side VPL or p2mpLeaf address on a p2mp root side VPL.')
ciscoAtmSvpVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: ciscoAtmSvpVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvpVpi.setDescription("This SVP's VPI value on this interface.")
ciscoAtmSvpDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 3, 1, 1, 3), Direction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmSvpDirection.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvpDirection.setDescription('Indicate whether this VPL is calling side, called side, root or leaf for this address.')
ciscoAtmSvc = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4))
ciscoAtmSvcAddrTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 1), )
if mibBuilder.loadTexts: ciscoAtmSvcAddrTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcAddrTable.setDescription('Switched virtual channel link address table.')
ciscoAtmSvcAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-CONN-MIB", "ciscoAtmSvcAddr"), (0, "CISCO-ATM-CONN-MIB", "ciscoAtmSvcVpi"), (0, "CISCO-ATM-CONN-MIB", "ciscoAtmSvcVci"))
if mibBuilder.loadTexts: ciscoAtmSvcAddrEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcAddrEntry.setDescription(' An entry in the SVC address table.')
ciscoAtmSvcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: ciscoAtmSvcAddr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcAddr.setDescription('It depends on the direction.This could be p2pCallingSide address on a called side VCL, or p2pCalledSide address on a calling side VCL or p2mpRoot address on a p2mp leaf side VCL or p2mpLeaf address on a p2mp root side VCL.')
ciscoAtmSvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: ciscoAtmSvcVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcVpi.setDescription("This SVC's VPI value on this interface.")
ciscoAtmSvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ciscoAtmSvcVci.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcVci.setDescription("This SVC's VCI value on this interface.")
ciscoAtmSvcDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 1, 1, 4), Direction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmSvcDirection.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcDirection.setDescription('Indicate whether this VCL is calling side, called side, root or leaf for this address.')
ciscoAtmSnoopVc = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5))
ciscoAtmSnoopVcTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1), )
if mibBuilder.loadTexts: ciscoAtmSnoopVcTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcTable.setDescription('Snooping VC Table.')
ciscoAtmSnoopVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: ciscoAtmSnoopVcEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcEntry.setDescription("An entry in the Snoop VC table. This entry models a VC snooping connection. The ifIndex indicates the snooping interface, the atmVclVpi and atmVclVci specifies the VPI and VCI value of the snooping connection. To create or destroy a snooping connection at an ATM interface, the following procedures are used: Configure VC Snooping A snooping connection is configured in one step by a set-request with all necessary snoop parameter values and set-request to the object ciscoAtmSnoopVcRowStatus to createAndGo(4). This may fail for the following reasons: - The selected snooping VPI/VCI values are unavailable, - The selected snooping VPI/VCI values are in use. - The selected snooping interface is CPU interface. - The selected snooped connection doesn't exist. - There is no traffic in the selected snoop direction. - Resource failure during configuration of snooping connection. De-Configure VC Snooping A snooping connection is deconfigured by a set-request to the object ciscoAtmSnoopVcRowStatus to destroy(6), and the agent releases all associated resources.")
ciscoAtmSnoopVcSnoopedIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVcSnoopedIfIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcSnoopedIfIndex.setDescription('This specifies the ifIndex of the snooped interface.')
ciscoAtmSnoopVcSnoopedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVcSnoopedVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcSnoopedVpi.setDescription('This specifies the VPI value of the snooped connection endpoint.')
ciscoAtmSnoopVcSnoopedVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVcSnoopedVci.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcSnoopedVci.setDescription('This specifies the VCI value of the snooped connection endpoint.')
ciscoAtmSnoopVcDir = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1, 4), SnoopDirType().clone('receive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVcDir.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcDir.setDescription('This specifies the traffic direction at the snooped connection endpoint.')
ciscoAtmSnoopVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1, 5), ConnState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmSnoopVcState.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcState.setDescription('The connection state of this Snooping connetion.')
ciscoAtmSnoopVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 5, 1, 1, 6), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVcRowStatus.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVcRowStatus.setDescription('This object is used to create a new row or delete an existing row in this table. This gives the way to configure one-shot per-vc snooping connection')
ciscoAtmSnoopVp = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6))
ciscoAtmSnoopVpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1), )
if mibBuilder.loadTexts: ciscoAtmSnoopVpTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpTable.setDescription('Snooping VP Table.')
ciscoAtmSnoopVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: ciscoAtmSnoopVpEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpEntry.setDescription("An entry in the Snoop VP table. This entry models a VP snooping connection. The ifIndex indicates the snooping interface, the atmVclVpi specifies the VPI value of the snooping connection. To create or destroy a snooping connection at an ATM interface, the following procedures are used: Configure VP Snooping A snooping connection is configured in one step by a set-request with all necessary snoop parameter values and set-request to the object ciscoAtmSnoopVpRowStatus to createAndGo(4). This may fail for the following reasons: - The selected snooping VPI values are unavailable, - The selected snooping VPI values are in use. - The selected snooping interface is CPU interface. - The selected snooped connection doesn't exist. - There is no traffic in the selected snoop direction. - Resource failure during configuration of snooping connection. De-Configure VP Snooping A snooping connection is deconfigured by a set-request to the object ciscoAtmSnoopVpRowStatus to destroy(6), and the agent releases all associated resources.")
ciscoAtmSnoopVpSnoopedIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVpSnoopedIfIndex.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpSnoopedIfIndex.setDescription('This specifies the ifIndex of the snooped interface.')
ciscoAtmSnoopVpSnoopedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVpSnoopedVpi.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpSnoopedVpi.setDescription('This specifies the VPI value of the snooped connection endpoint.')
ciscoAtmSnoopVpDir = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1, 1, 3), SnoopDirType().clone('receive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVpDir.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpDir.setDescription('This specifies the traffic direction at the snooped connection endpoint.')
ciscoAtmSnoopVpState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1, 1, 4), ConnState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmSnoopVpState.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpState.setDescription('The connection state of this Snooping connection .')
ciscoAtmSnoopVpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 6, 1, 1, 5), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoAtmSnoopVpRowStatus.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSnoopVpRowStatus.setDescription('This object is used to create a new row or delete an existing row in this table. This gives the way to configure one-shot per-vp snooping connection')
ciscoAtmSvcFrameDiscardUsesAal5Ie = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 13, 1, 4, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmSvcFrameDiscardUsesAal5Ie.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmSvcFrameDiscardUsesAal5Ie.setDescription('Determines mechanism to use on interfaces to specify frame discard. Specifying a value of true causes the presence of the AAL5 IE to influence whether frame discard is used on an SVC. If AAL5 IE is present in a received SETUP, frame discard is used. Specifying a value of false results in no influence on presence of the frame discard by the AAL5 IE.')
ciscoAtmConnMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 3))
ciscoAtmConnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1))
ciscoAtmConnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2))
ciscoAtmConnMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 1)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance = ciscoAtmConnMIBCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 2)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance2 = ciscoAtmConnMIBCompliance2.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance2.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 3)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup3"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsPerVcqGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsFcPfqGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance3 = ciscoAtmConnMIBCompliance3.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance3.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 4)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup3"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsPerVcqGroup2"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsFcPfqGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance4 = ciscoAtmConnMIBCompliance4.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance4.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 5)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup3"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsPerVcqGroup2"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsFcPfqGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBNegTraffGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance5 = ciscoAtmConnMIBCompliance5.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance5.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 6)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup3"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsPerVcqGroup2"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsFcPfqGroup1"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBNegTraffGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance6 = ciscoAtmConnMIBCompliance6.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance6.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 7)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup1"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup3"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsPerVcqGroup2"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsFcPfqGroup1"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBNegTraffGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance7 = ciscoAtmConnMIBCompliance7.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance7.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBCompliance8 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 1, 8)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup4"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBGroup3"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsPerVcqGroup2"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBlsFcPfqGroup1"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnMIBNegTraffGroup"), ("CISCO-ATM-CONN-MIB", "ciscoAtmConnNmsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBCompliance8 = ciscoAtmConnMIBCompliance8.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnMIBCompliance8.setDescription('The compliance statement for the Cisco ATM connection management group.')
ciscoAtmConnMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 1)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplCastType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSpanType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConfigType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRxUpcMode"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConnState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamLoopbkTxInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamSegmentLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamEndLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamAisEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamRdiEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInstallTime"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCrossIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCrossVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNextLeafIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNextLeafVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRemoteAddr"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRemoteVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLocation"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSlowRetryIntv"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNumAttempts"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLastReleaseCause"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLogicalPortDef"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLogicalPortIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCastType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSpanType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConfigType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRxUpcMode"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConnState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamLoopbkTxInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamSegmentLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamEndLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamAisEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamRdiEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInstallTime"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalEncapFlag"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalEncapProtocol"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalUserVcType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAtmInArpInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteAddr"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLocation"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSlowRetryIntv"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNumAttempts"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLastReleaseCause"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvpDirection"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvcDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBGroup = ciscoAtmConnMIBGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmConnMIBGroup.setDescription('')
ciscoAtmConnMIBGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 2)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplUpcViolations"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplEpdTpdCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplEpdTpdPacketDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplEpdTpdPacketsIn"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplClp1Drops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplDefaultRxUpcTolerance"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclUpcViolations"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdPacketDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdPacketsIn"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclClp1Drops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclDefaultRxUpcTolerance"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvcFrameDiscardUsesAal5Ie"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBGroup2 = ciscoAtmConnMIBGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmConnMIBGroup2.setDescription('')
ciscoAtmConnMIBGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 3)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplDefaultRxUpcTolerance"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclDefaultRxUpcTolerance"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplDefaultRxUpcVbrCdvt"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclDefaultRxUpcVbrCdvt"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvcFrameDiscardUsesAal5Ie"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBGroup3 = ciscoAtmConnMIBGroup3.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnMIBGroup3.setDescription('')
ciscoAtmConnMIBlsPerVcqGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 4)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqWrrWeight"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqTunnelIsShaped"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqXmtQueuedCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcQThreshGrp"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLsPerVcqWrrWeight"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLsPerVcqXmtQueuedCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLsPerVcQThreshGrp"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcSnoopedIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcSnoopedVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcSnoopedVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcDir"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcRowStatus"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpSnoopedIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpSnoopedVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpDir"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBlsPerVcqGroup = ciscoAtmConnMIBlsPerVcqGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmConnMIBlsPerVcqGroup.setDescription('A collection of objects which are supported on platforms using the Lightstream per-VC queueing chipset.')
ciscoAtmConnMIBlsFcPfqGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 5)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplUpcViolations"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclUpcViolations"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdPacketDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdPacketsIn"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplClp0VcqFullCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplVcqClpThreshCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclClp0VcqFullCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclVcqClpThreshCellDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBlsFcPfqGroup = ciscoAtmConnMIBlsFcPfqGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmConnMIBlsFcPfqGroup.setDescription('A collection of objects which are supported on LS1010 systems equipped with the FC-PFQ feature card.')
ciscoAtmConnMIBlsPerVcqGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 6)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqWrrWeight"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqTunnelIsShaped"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqTunnelIsHierarchical"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcqXmtQueuedCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLsPerVcQThreshGrp"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLsPerVcqWrrWeight"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLsPerVcqXmtQueuedCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLsPerVcQThreshGrp"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcSnoopedIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcSnoopedVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcSnoopedVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcDir"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVcRowStatus"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpSnoopedIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpSnoopedVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpDir"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSnoopVpRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBlsPerVcqGroup2 = ciscoAtmConnMIBlsPerVcqGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnMIBlsPerVcqGroup2.setDescription('A collection of objects which are supported on platforms using the Lightstream per-VC queueing chipset.')
ciscoAtmConnMIBNegTraffGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 7)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplRxNegTraffDescrIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplTxNegTraffDescrIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRxNegTraffDescrIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclTxNegTraffDescrIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBNegTraffGroup = ciscoAtmConnMIBNegTraffGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnMIBNegTraffGroup.setDescription('A collection of objects to report negotiated traffic parameters on a Cisco ATM switch.')
ciscoAtmConnMIBlsFcPfqGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 8)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplUpcViolations"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclUpcViolations"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdPacketDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdTpdPacketsIn"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplClp0VcqFullCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplVcqClpThreshCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSwFabOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSwFabOutClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSwFabOutClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutClp1Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclClp0VcqFullCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclVcqClpThreshCellDrops"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSwFabOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSwFabOutClp0Cells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSwFabOutClp1Cells"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBlsFcPfqGroup1 = ciscoAtmConnMIBlsFcPfqGroup1.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnMIBlsFcPfqGroup1.setDescription('A collection of objects which are supported on LS1010 systems equipped with the FC-PFQ feature card.')
ciscoAtmConnMIBGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 9)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplCastType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSpanType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConfigType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRxUpcMode"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConnState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamLoopbkTxInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamSegmentLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamEndLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamAisEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamRdiEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInstallTime"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCrossIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCrossVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNextLeafIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNextLeafVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRemoteAddr"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRemoteVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLocation"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSlowRetryIntv"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNumAttempts"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLastReleaseCause"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLogicalPortDef"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLogicalPortIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConnName"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCastType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSpanType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConfigType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRxUpcMode"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConnState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamLoopbkTxInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamSegmentLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamEndLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamAisEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamRdiEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInstallTime"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalEncapFlag"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalEncapProtocol"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalUserVcType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAtmInArpInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteAddr"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLocation"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSlowRetryIntv"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNumAttempts"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLastReleaseCause"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConnName"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvpDirection"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvcDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBGroup1 = ciscoAtmConnMIBGroup1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmConnMIBGroup1.setDescription('')
ciscoAtmConnMIBGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 10)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplCastType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSpanType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConfigType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRxUpcMode"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConnState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamLoopbkTxInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamSegmentLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamEndLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamAisEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOamRdiEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInstallTime"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplInCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCrossIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplCrossVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNextLeafIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNextLeafVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRemoteAddr"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplRemoteVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLocation"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplSlowRetryIntv"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplNumAttempts"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLastReleaseCause"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLogicalPortDef"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplLogicalPortIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCastType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSpanType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConfigType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRxUpcMode"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclEpdEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConnState"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamLoopbkTxInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamSegmentLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamEndLoopback"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamAisEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOamRdiEnable"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInstallTime"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclInCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclOutCells"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclCrossVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafIfIndex"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNextLeafVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalEncapFlag"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalEncapProtocol"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAalUserVcType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclAtmInArpInterval"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteAddr"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteVpi"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclRemoteVci"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLocation"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclSlowRetryIntv"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclNumAttempts"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclLastReleaseCause"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvpDirection"), ("CISCO-ATM-CONN-MIB", "ciscoAtmSvcDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnMIBGroup4 = ciscoAtmConnMIBGroup4.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnMIBGroup4.setDescription('')
ciscoAtmConnNmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 13, 3, 2, 11)).setObjects(("CISCO-ATM-CONN-MIB", "ciscoAtmVplConnName"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVplConnType"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConnName"), ("CISCO-ATM-CONN-MIB", "ciscoAtmVclConnType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmConnNmsGroup = ciscoAtmConnNmsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmConnNmsGroup.setDescription('A group of objects that provides additional information for a management system')
mibBuilder.exportSymbols("CISCO-ATM-CONN-MIB", ciscoAtmSvpAddrTable=ciscoAtmSvpAddrTable, ciscoAtmSvpVpi=ciscoAtmSvpVpi, ciscoAtmVplDefaultRxUpcTolerance=ciscoAtmVplDefaultRxUpcTolerance, ciscoAtmVclOutCells=ciscoAtmVclOutCells, ciscoAtmConnMIBCompliance2=ciscoAtmConnMIBCompliance2, ciscoAtmVclInClp1Cells=ciscoAtmVclInClp1Cells, ciscoAtmConnMIBlsFcPfqGroup1=ciscoAtmConnMIBlsFcPfqGroup1, ciscoAtmVplInClp1Cells=ciscoAtmVplInClp1Cells, ciscoAtmVclClp0VcqFullCellDrops=ciscoAtmVclClp0VcqFullCellDrops, ciscoAtmVplSlowRetryIntv=ciscoAtmVplSlowRetryIntv, ciscoAtmVplSwFabOutClp0Cells=ciscoAtmVplSwFabOutClp0Cells, ciscoAtmSnoopVp=ciscoAtmSnoopVp, ciscoAtmConnMIBGroup=ciscoAtmConnMIBGroup, ciscoAtmVclAtmInArpInterval=ciscoAtmVclAtmInArpInterval, ciscoAtmSnoopVpDir=ciscoAtmSnoopVpDir, ciscoAtmVclAalUserVcType=ciscoAtmVclAalUserVcType, ciscoAtmVclLsPerVcqWrrWeight=ciscoAtmVclLsPerVcqWrrWeight, ciscoAtmSnoopVpEntry=ciscoAtmSnoopVpEntry, ciscoAtmVplConnState=ciscoAtmVplConnState, ciscoAtmVplConnName=ciscoAtmVplConnName, ciscoAtmVclDefaultRxUpcVbrCdvt=ciscoAtmVclDefaultRxUpcVbrCdvt, ciscoAtmSvcAddrEntry=ciscoAtmSvcAddrEntry, ciscoAtmVclNextLeafVci=ciscoAtmVclNextLeafVci, CastType=CastType, ciscoAtmVplLsPerVcqXmtQueuedCells=ciscoAtmVplLsPerVcqXmtQueuedCells, ciscoAtmConnMIBCompliance5=ciscoAtmConnMIBCompliance5, ciscoAtmVplConfigType=ciscoAtmVplConfigType, ciscoAtmVplDefaultRxUpcVbrCdvt=ciscoAtmVplDefaultRxUpcVbrCdvt, ciscoAtmVplOutClp1Cells=ciscoAtmVplOutClp1Cells, ciscoAtmConnMIBCompliances=ciscoAtmConnMIBCompliances, ciscoAtmVplEpdTpdPacketDrops=ciscoAtmVplEpdTpdPacketDrops, ciscoAtmVclConnType=ciscoAtmVclConnType, ciscoAtmVclAalEncapFlag=ciscoAtmVclAalEncapFlag, ciscoAtmVplOamLoopbkTxInterval=ciscoAtmVplOamLoopbkTxInterval, ciscoAtmVplNumAttempts=ciscoAtmVplNumAttempts, ciscoAtmVclConnName=ciscoAtmVclConnName, ciscoAtmConnMIBConformance=ciscoAtmConnMIBConformance, Direction=Direction, ciscoAtmVplEntry=ciscoAtmVplEntry, ciscoAtmVclCrossIfIndex=ciscoAtmVclCrossIfIndex, ciscoAtmConnMIBCompliance6=ciscoAtmConnMIBCompliance6, ciscoAtmVclOutClp0Cells=ciscoAtmVclOutClp0Cells, ciscoAtmVclNextLeafVpi=ciscoAtmVclNextLeafVpi, EnableStatus=EnableStatus, ciscoAtmVclSwFabOutCells=ciscoAtmVclSwFabOutCells, ciscoAtmConnMIBNegTraffGroup=ciscoAtmConnMIBNegTraffGroup, ciscoAtmVplOamAisEnable=ciscoAtmVplOamAisEnable, ciscoAtmVplLsPerVcQThreshGrp=ciscoAtmVplLsPerVcQThreshGrp, ciscoAtmSnoopVcSnoopedVpi=ciscoAtmSnoopVcSnoopedVpi, ciscoAtmVplUpcViolations=ciscoAtmVplUpcViolations, ciscoAtmConnMIBCompliance7=ciscoAtmConnMIBCompliance7, ciscoAtmVclOamRdiEnable=ciscoAtmVclOamRdiEnable, ciscoAtmSvcAddrTable=ciscoAtmSvcAddrTable, ciscoAtmVclLastReleaseCause=ciscoAtmVclLastReleaseCause, ciscoAtmVclTable=ciscoAtmVclTable, ciscoAtmVplOutClp0Cells=ciscoAtmVplOutClp0Cells, ciscoAtmVclLsPerVcQThreshGrp=ciscoAtmVclLsPerVcQThreshGrp, ciscoAtmConnNmsGroup=ciscoAtmConnNmsGroup, ciscoAtmVclEpdTpdCellDrops=ciscoAtmVclEpdTpdCellDrops, ciscoAtmSnoopVpRowStatus=ciscoAtmSnoopVpRowStatus, ciscoAtmVplNextLeafVpi=ciscoAtmVplNextLeafVpi, UpcStatus=UpcStatus, ciscoAtmVplRxNegTraffDescrIndex=ciscoAtmVplRxNegTraffDescrIndex, ciscoAtmVclUpcViolations=ciscoAtmVclUpcViolations, ciscoAtmVplInstallTime=ciscoAtmVplInstallTime, ciscoAtmVclCastType=ciscoAtmVclCastType, ciscoAtmVplOamSegmentLoopback=ciscoAtmVplOamSegmentLoopback, ciscoAtmVclOamLoopbkTxInterval=ciscoAtmVclOamLoopbkTxInterval, ciscoAtmVclEpdTpdPacketsIn=ciscoAtmVclEpdTpdPacketsIn, ciscoAtmVclInClp0Cells=ciscoAtmVclInClp0Cells, ciscoAtmSnoopVcTable=ciscoAtmSnoopVcTable, ciscoAtmVplLogicalPortIndex=ciscoAtmVplLogicalPortIndex, ciscoAtmVplClp0VcqFullCellDrops=ciscoAtmVplClp0VcqFullCellDrops, ciscoAtmVplOamEndLoopback=ciscoAtmVplOamEndLoopback, ciscoAtmVclSwFabOutClp1Cells=ciscoAtmVclSwFabOutClp1Cells, ciscoAtmVplLastReleaseCause=ciscoAtmVplLastReleaseCause, ciscoAtmVclRemoteVci=ciscoAtmVclRemoteVci, ciscoAtmVclOutClp1Cells=ciscoAtmVclOutClp1Cells, ciscoAtmSvcFrameDiscardUsesAal5Ie=ciscoAtmSvcFrameDiscardUsesAal5Ie, ciscoAtmVclOamSegmentLoopback=ciscoAtmVclOamSegmentLoopback, ciscoAtmConnMIBObjects=ciscoAtmConnMIBObjects, ciscoAtmVplTable=ciscoAtmVplTable, ciscoAtmVplLsPerVcqTunnelIsHierarchical=ciscoAtmVplLsPerVcqTunnelIsHierarchical, ciscoAtmVplSwFabOutCells=ciscoAtmVplSwFabOutCells, ciscoAtmVplClp1Drops=ciscoAtmVplClp1Drops, ciscoAtmVplSwFabOutClp1Cells=ciscoAtmVplSwFabOutClp1Cells, ciscoAtmVclRxUpcMode=ciscoAtmVclRxUpcMode, ciscoAtmVclNextLeafIfIndex=ciscoAtmVclNextLeafIfIndex, ciscoAtmSvcDirection=ciscoAtmSvcDirection, ciscoAtmConnMIBCompliance=ciscoAtmConnMIBCompliance, ciscoAtmVplCrossVpi=ciscoAtmVplCrossVpi, ciscoAtmVcl=ciscoAtmVcl, ciscoAtmVclEntry=ciscoAtmVclEntry, ciscoAtmVclConfigType=ciscoAtmVclConfigType, ciscoAtmVclInCells=ciscoAtmVclInCells, ciscoAtmVclSpanType=ciscoAtmVclSpanType, ciscoAtmVclSwFabOutClp0Cells=ciscoAtmVclSwFabOutClp0Cells, ciscoAtmVplCrossIfIndex=ciscoAtmVplCrossIfIndex, ciscoAtmSvcVci=ciscoAtmSvcVci, ciscoAtmConnMIBlsFcPfqGroup=ciscoAtmConnMIBlsFcPfqGroup, ciscoAtmVplOamRdiEnable=ciscoAtmVplOamRdiEnable, ciscoAtmSnoopVpSnoopedVpi=ciscoAtmSnoopVpSnoopedVpi, ciscoAtmSvc=ciscoAtmSvc, ciscoAtmConnMIBCompliance8=ciscoAtmConnMIBCompliance8, ciscoAtmVclCrossVci=ciscoAtmVclCrossVci, ciscoAtmVplLocation=ciscoAtmVplLocation, ciscoAtmSvpAddrEntry=ciscoAtmSvpAddrEntry, ciscoAtmSnoopVcRowStatus=ciscoAtmSnoopVcRowStatus, ciscoAtmVclOamAisEnable=ciscoAtmVclOamAisEnable, ciscoAtmVplCellDrops=ciscoAtmVplCellDrops, ciscoAtmConnMIBGroup3=ciscoAtmConnMIBGroup3, ciscoAtmVplLogicalPortDef=ciscoAtmVplLogicalPortDef, ciscoAtmConnMIBlsPerVcqGroup=ciscoAtmConnMIBlsPerVcqGroup, ciscoAtmConnMIBGroup4=ciscoAtmConnMIBGroup4, ciscoAtmVplRemoteAddr=ciscoAtmVplRemoteAddr, ciscoAtmSnoopVcState=ciscoAtmSnoopVcState, ciscoAtmVplOutCells=ciscoAtmVplOutCells, ciscoAtmVplRxUpcMode=ciscoAtmVplRxUpcMode, ciscoAtmVplEpdTpdPacketsIn=ciscoAtmVplEpdTpdPacketsIn, ciscoAtmSnoopVcEntry=ciscoAtmSnoopVcEntry, ciscoAtmSnoopVpTable=ciscoAtmSnoopVpTable, ciscoAtmVplNextLeafIfIndex=ciscoAtmVplNextLeafIfIndex, ciscoAtmSvcAddr=ciscoAtmSvcAddr, ConfigType=ConfigType, ciscoAtmVclLsPerVcqXmtQueuedCells=ciscoAtmVclLsPerVcqXmtQueuedCells, ciscoAtmSvcVpi=ciscoAtmSvcVpi, ciscoAtmVplEpdTpdCellDrops=ciscoAtmVplEpdTpdCellDrops, ciscoAtmVclLocation=ciscoAtmVclLocation, ciscoAtmVpl=ciscoAtmVpl, ciscoAtmVclRemoteAddr=ciscoAtmVclRemoteAddr, ciscoAtmVclOamEndLoopback=ciscoAtmVclOamEndLoopback, ciscoAtmSvpAddr=ciscoAtmSvpAddr, ciscoAtmVclEpdTpdPacketDrops=ciscoAtmVclEpdTpdPacketDrops, ciscoAtmVclEpdEnable=ciscoAtmVclEpdEnable, ciscoAtmSnoopVc=ciscoAtmSnoopVc, ciscoAtmConnMIBCompliance4=ciscoAtmConnMIBCompliance4, ciscoAtmVplRemoteVpi=ciscoAtmVplRemoteVpi, ciscoAtmVplLsPerVcqTunnelIsShaped=ciscoAtmVplLsPerVcqTunnelIsShaped, ciscoAtmVclRemoteVpi=ciscoAtmVclRemoteVpi, ciscoAtmConnMIBCompliance3=ciscoAtmConnMIBCompliance3, ciscoAtmVplSpanType=ciscoAtmVplSpanType, ciscoAtmVclCrossVpi=ciscoAtmVclCrossVpi, ciscoAtmVclDefaultRxUpcTolerance=ciscoAtmVclDefaultRxUpcTolerance, ciscoAtmSnoopVcDir=ciscoAtmSnoopVcDir, ciscoAtmVclTxNegTraffDescrIndex=ciscoAtmVclTxNegTraffDescrIndex, ciscoAtmConnMIBlsPerVcqGroup2=ciscoAtmConnMIBlsPerVcqGroup2, ciscoAtmVclCellDrops=ciscoAtmVclCellDrops, SnoopDirType=SnoopDirType, ciscoAtmVplCastType=ciscoAtmVplCastType, ciscoAtmVclVcqClpThreshCellDrops=ciscoAtmVclVcqClpThreshCellDrops, ciscoAtmVclInstallTime=ciscoAtmVclInstallTime, ciscoAtmVclAalEncapProtocol=ciscoAtmVclAalEncapProtocol, ciscoAtmConnMIBGroup1=ciscoAtmConnMIBGroup1, ciscoAtmSnoopVpSnoopedIfIndex=ciscoAtmSnoopVpSnoopedIfIndex, ciscoAtmConnMIB=ciscoAtmConnMIB, ciscoAtmVplVcqClpThreshCellDrops=ciscoAtmVplVcqClpThreshCellDrops, SpanType=SpanType, ConnState=ConnState, ciscoAtmVplInClp0Cells=ciscoAtmVplInClp0Cells, ciscoAtmSnoopVcSnoopedVci=ciscoAtmSnoopVcSnoopedVci, ciscoAtmSvp=ciscoAtmSvp, ciscoAtmSvpDirection=ciscoAtmSvpDirection, Location=Location, ciscoAtmConnMIBGroup2=ciscoAtmConnMIBGroup2, ciscoAtmVplLsPerVcqWrrWeight=ciscoAtmVplLsPerVcqWrrWeight, ciscoAtmVclRxNegTraffDescrIndex=ciscoAtmVclRxNegTraffDescrIndex, PYSNMP_MODULE_ID=ciscoAtmConnMIB, ciscoAtmVclConnState=ciscoAtmVclConnState, ciscoAtmVclNumAttempts=ciscoAtmVclNumAttempts, ciscoAtmVplTxNegTraffDescrIndex=ciscoAtmVplTxNegTraffDescrIndex, ciscoAtmVplConnType=ciscoAtmVplConnType, ciscoAtmConnMIBGroups=ciscoAtmConnMIBGroups, ciscoAtmVclSlowRetryIntv=ciscoAtmVclSlowRetryIntv, ciscoAtmSnoopVpState=ciscoAtmSnoopVpState, ciscoAtmVclClp1Drops=ciscoAtmVclClp1Drops, ciscoAtmVplInCells=ciscoAtmVplInCells, ciscoAtmSnoopVcSnoopedIfIndex=ciscoAtmSnoopVcSnoopedIfIndex)

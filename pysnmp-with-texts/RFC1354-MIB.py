#
# PySNMP MIB module RFC1354-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RFC1354-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:56:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
ip, = mibBuilder.importSymbols("IP-MIB", "ip")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Integer32, iso, IpAddress, Counter64, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Bits, MibIdentifier, Gauge32, Counter32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "iso", "IpAddress", "Counter64", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Bits", "MibIdentifier", "Gauge32", "Counter32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ipForward = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24))
ipForwardNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardNumber.setDescription('The number of current ipForwardTable entries that are not invalid.')
ipForwardTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 2), )
if mibBuilder.loadTexts: ipForwardTable.setReference('RFC 1213 Section 6.6, The IP Group')
if mibBuilder.loadTexts: ipForwardTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardTable.setDescription("This entity's IP Routing table.")
ipForwardEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 2, 1), ).setIndexNames((0, "RFC1354-MIB", "ipForwardDest"), (0, "RFC1354-MIB", "ipForwardProto"), (0, "RFC1354-MIB", "ipForwardPolicy"), (0, "RFC1354-MIB", "ipForwardNextHop"))
if mibBuilder.loadTexts: ipForwardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardEntry.setDescription('A particular route to a particular destina- tion, under a particular policy.')
ipForwardDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardDest.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardDest.setDescription('The destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the ipForwardMask object is not equal to x.')
ipForwardMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipForwardDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipForwardMask by reference to the IP Ad- dress Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the ipForwardDest object is not equal to ipForward- Dest.')
ipForwardPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardPolicy.setDescription("The general set of conditions that would cause the selection of one multipath route (set of next hops for a given destination) is referred to as 'policy'. Unless the mechanism indicated by ipForwardPro- to specifies otherwise, the policy specifier is the IP TOS Field. The encoding of IP TOS is as specified by the following convention. Zero indicates the default path if no more specific policy applies. +-----+-----+-----+-----+-----+-----+-----+-----+ | | | | | PRECEDENCE | TYPE OF SERVICE | 0 | | | | | +-----+-----+-----+-----+-----+-----+-----+-----+ IP TOS IP TOS Field Policy Field Policy Contents Code Contents Code 0 0 0 0 ==> 0 0 0 0 1 ==> 2 0 0 1 0 ==> 4 0 0 1 1 ==> 6 0 1 0 0 ==> 8 0 1 0 1 ==> 10 0 1 1 0 ==> 12 0 1 1 1 ==> 14 1 0 0 0 ==> 16 1 0 0 1 ==> 18 1 0 1 0 ==> 20 1 0 1 1 ==> 22 1 1 0 0 ==> 24 1 1 0 1 ==> 26 1 1 1 0 ==> 28 1 1 1 1 ==> 30 Protocols defining 'policy' otherwise must ei- ther define a set of values which are valid for this object or must implement an integer- instanced policy table for which this object's value acts as an index.")
ipForwardNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardNextHop.setDescription('On remote routes, the address of the next sys- tem en route; Otherwise, 0.0.0.0.')
ipForwardIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardIfIndex.setDescription('The ifIndex value which identifies the local interface through which the next hop of this route should be reached.')
ipForwardType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("local", 3), ("remote", 4))).clone('invalid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardType.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardType.setDescription('The type of route. Note that local(3) refers to a route for which the next hop is the final destination; remote(4) refers to a route for which the next hop is not the final destina- tion. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipForwardTable object. That is, it effectively disassociates the destination identified with said entry from the route iden- tified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not current- ly in use. Proper interpretation of such en- tries requires examination of the relevant ip- ForwardType object.')
ipForwardProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("is-is", 9), ("es-is", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardProto.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway rout- ing protocols is not intended to imply that hosts should support those protocols.')
ipForwardAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardAge.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
ipForwardInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 9), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardInfo.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsi- ble for this route, as determined by the value specified in the route's ipForwardProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identif- ier, and any implementation conforming to ASN.1 and the Basic Encoding Rules must be able to generate and recognize this value.")
ipForwardNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardNextHopAS.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardNextHopAS.setDescription('The Autonomous System Number of the Next Hop. When this is unknown or not relevant to the protocol indicated by ipForwardProto, zero.')
ipForwardMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 11), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardMetric1.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 12), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardMetric2.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 13), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardMetric3.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 14), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardMetric4.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 15), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipForwardMetric5.setStatus('mandatory')
if mibBuilder.loadTexts: ipForwardMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
mibBuilder.exportSymbols("RFC1354-MIB", ipForwardMetric5=ipForwardMetric5, ipForwardDest=ipForwardDest, ipForwardInfo=ipForwardInfo, ipForwardType=ipForwardType, ipForwardMetric2=ipForwardMetric2, ipForwardPolicy=ipForwardPolicy, ipForwardEntry=ipForwardEntry, ipForwardProto=ipForwardProto, ipForwardNextHop=ipForwardNextHop, ipForwardTable=ipForwardTable, ipForwardMetric3=ipForwardMetric3, ipForwardAge=ipForwardAge, ipForwardMetric1=ipForwardMetric1, ipForwardNumber=ipForwardNumber, ipForwardMetric4=ipForwardMetric4, ipForwardMask=ipForwardMask, ipForwardNextHopAS=ipForwardNextHopAS, ipForward=ipForward, ipForwardIfIndex=ipForwardIfIndex)

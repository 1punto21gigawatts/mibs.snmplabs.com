#
# PySNMP MIB module Wellfleet-CES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-CES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:39:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, NotificationType, ObjectIdentity, iso, Gauge32, Unsigned32, ModuleIdentity, IpAddress, Counter64, TimeTicks, Bits, MibIdentifier, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "NotificationType", "ObjectIdentity", "iso", "Gauge32", "Unsigned32", "ModuleIdentity", "IpAddress", "Counter64", "TimeTicks", "Bits", "MibIdentifier", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfAtmInterfaceGroup, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfAtmInterfaceGroup")
wfAtmCESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4))
wfAtmCESObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1))
wfAtmCESConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1), )
if mibBuilder.loadTexts: wfAtmCESConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfTable.setDescription('The CES configuration table used to manage interworking between CBR interfaces or channels and ATM Virtual Channel Links (VCLs).')
wfAtmCESConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1), ).setIndexNames((0, "Wellfleet-CES-MIB", "wfAtmCESConfAtmIndex"), (0, "Wellfleet-CES-MIB", "wfAtmCESConfCbrIndex"))
if mibBuilder.loadTexts: wfAtmCESConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfEntry.setDescription('An entry in the CES configuration table. There is one entry in the table per CES entity, mapping one CBR interface, channel, or bundle to an ATM VCL.')
wfAtmCESConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmCESConfDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfDisable.setDescription('Enable/Disable MIB instance parameter.')
wfAtmCESConfAtmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESConfAtmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfAtmIndex.setDescription('The value of this object is equal to the line number value of the ATM Port interface mapped through this CES IWF to a CBR interface.')
wfAtmCESConfCbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESConfCbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCbrIndex.setDescription('The value of this object is equal to the line number value of the CBR interface, channel, or bundle that is being cross-connected to this ATM VCL.')
wfAtmCESConfAtmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESConfAtmVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfAtmVpi.setDescription('The value of this object is equal to the VPI used by the ATM VCL mapped through this CES IWF to a CBR interface.')
wfAtmCESConfAtmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESConfAtmVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfAtmVci.setDescription('The value of this object is equal to the VCI used by the ATM VCL mapped through this CES IWF to a CBR interface.')
wfAtmCESConfCfgAtmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCfgAtmVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCfgAtmVpi.setDescription('The value of this object is equal to the VPI used by the ATM VCL mapped through this CES IWF to a CBR interface. Setting this attribute when wfAtmCESConfConnType is set to activeSvc or passiveSvc has no effect.')
wfAtmCESConfCfgAtmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCfgAtmVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCfgAtmVci.setDescription('The value of this object is equal to the VCI used by the ATM VCL mapped through this CES IWF to a CBR interface. Setting this attribute when wfAtmCESConfConnType is set to activeSvc or passiveSvc has no effect.')
wfAtmCESConfVclCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfVclCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfVclCct.setDescription('Identifies the object which corresponds to the Wellfleet circuit number.')
wfAtmCESConfCbrService = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unstructured", 1), ("structured", 2))).clone('structured')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCbrService.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCbrService.setDescription('Define if DSx/Ex service is structured or unstructured. A structured(2) interface is some nx64kbKbps. An unstructured (1) interface is 1.544Mbps, 2.048Mbps, 6.312Mbps, 44.736 Mbps, or 34.368 Mbps. unstructured(1) passes all bits through the ATM network. strucutured(2) passes data bits through the ATM network, and may also pass signalling bits. At this time, only unstructured mode is defined for the 44.736 Mbps and 34.368 Mbps services.')
wfAtmCESConfCbrClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("synchronous", 1), ("srts", 2), ("adaptive", 3))).clone('synchronous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCbrClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCbrClockMode.setDescription('Define if DSx/Ex service clocking mode. This maps into transmit clock source of CBR interface. For structured modes this value, if present, must be set to synchronous(1).')
wfAtmCESConfCas = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("basic", 1), ("e1Cas", 2), ("ds1SfCas", 3), ("ds1EsfCas", 4), ("j2Cas", 5))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCas.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCas.setDescription('This parameter selects which AAL1 Format should be used: Basic does not carry CAS bits, and uses a single 125 usec frame. e1Cas, ds1SfCas, dS1EsfCas and j2Cas carry CAS bits in a multiframe structure for E1, DS1 SF, DS1 ESF and J2 respectively. This applies to structured interfaces only. Default is basic (1). For unstructured interfaces this value, if present, must be set to the default of basic (1).')
wfAtmCESConfPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfPartialFill.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfPartialFill.setDescription('If partial cell fill is used, the number of user octets per cell must be set with this parameter. Setting this parameter to zero disables partial cell fill, and causes all cells to be completely filled before they are sent.')
wfAtmCESConfBufMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfBufMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfBufMaxSize.setDescription('Define maximum size in 10 microsecond increments of the reassembly buffer. Some implementations may want allow the maximum buffer size to be programmed to a size less than the physical limit to reduce the maximum delay through a circuit.')
wfAtmCESConfCdvRxT = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCdvRxT.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCdvRxT.setDescription('The maximum cell arrival jitter in 10 usec increments that the reassembly process will tolerate in the cell stream without producing errors on the CBR service interface.')
wfAtmCESConfCellLossIntegrationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535)).clone(2500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfCellLossIntegrationPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfCellLossIntegrationPeriod.setDescription('The time in milliseconds for the cell loss integration period. If cells are continuously lost for this period of time, wfAtmCESCellLossStatus is set to loss (2). The default definition is 2500.')
wfAtmCESConfConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("pvc", 2), ("activeSvc", 3), ("passiveSvc", 4))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfConnType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfConnType.setDescription("The type of ATM connectivity between associated CES IWF's. Valid values are: other - none of the types specified below pvc - supporting connectivity is a permanent virtual connection activeSvc - attempt calls whenever none established passiveSvc - accept calls")
wfAtmCESConfLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 18), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfLocalAddr.setDescription('The ATM address of the local CES IWF process. This address may be used by the automatic SVC establishment procedures to identify the intended recipient CES IWF of an incoming automatic SVC call request. Optionally, the MAX-ACCESS of this object may be read-only, for those implementations where it is not desired to manually configure this address.')
wfAtmCESConfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCESConfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfAdminStatus.setDescription('The desired administrative status of the CES interworking function. The up and down states indicate that the traffic flow is enabled or disabled respectively across the CES interworking function.')
wfAtmCESConfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESConfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESConfOperStatus.setDescription('The operational status of the CES interworking function. The up and down states indicate that the traffic flow is enabled or disabled respectively across the CES interworking function. The unknown state indicates that the state of the CES interworking function cannot be determined. The state will be down or unknown if the supporting CBR or ATM interfaces are down or unknown, respectively.')
wfAtmCESStatsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2), )
if mibBuilder.loadTexts: wfAtmCESStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsTable.setDescription('The CES AAL1 statistical data table.')
wfAtmCESStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1), ).setIndexNames((0, "Wellfleet-CES-MIB", "wfAtmCESStatsAtmIndex"), (0, "Wellfleet-CES-MIB", "wfAtmCESStatsAtmVpi"), (0, "Wellfleet-CES-MIB", "wfAtmCESStatsAtmVci"))
if mibBuilder.loadTexts: wfAtmCESStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsEntry.setDescription('An entry in the CES AAL1 Stats table. There is one entry in this table corresponding to each entry in the wfAtmCESConfTable.')
wfAtmCESStatsAtmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsAtmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsAtmIndex.setDescription('The value of this object is equal to the line number value of the ATM Port interface mapped through this CES IWF to a CBR interface.')
wfAtmCESStatsAtmVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsAtmVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsAtmVpi.setDescription('The value of this object is equal to the VPI used by the ATM VCL mapped through this CES IWF to a CBR interface.')
wfAtmCESStatsAtmVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsAtmVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsAtmVci.setDescription('The value of this object is equal to the VCI used by the ATM VCL mapped through this CES IWF to a CBR interface.')
wfAtmCESStatsCbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsCbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsCbrIndex.setDescription('The value of this object is equal to the line number value of the CBR interface, channel, or bundle that is being cross-connected to this ATM VCL.')
wfAtmCESStatsVclCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsVclCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsVclCct.setDescription('Identifies the object which corresponds to the Wellfleet circuit number.')
wfAtmCESStatsReassCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsReassCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsReassCells.setDescription('This count gives the number of cells played out to the CES Service Interface. It excludes cells that were discarded for any reason, including cells that were not used due to being declared misinserted, or discarded while the reassembler was waiting to achieve synchronization.')
wfAtmCESStatsHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsHdrErrors.setDescription('The count of the number of AAL1 header errors detected, including those corrected. Header errors include correctable and uncorrectable CRC, plus bad parity.')
wfAtmCESStatsPointerReframes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsPointerReframes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsPointerReframes.setDescription('This records the count of the number of events in which the AAL1 reassembler found that an SDT pointer is not where it is expected, and the pointer must be reacquired. This count is only meaningful for structured CES modes, as unstructured CES modes do not use pointers. For unstructured CES modes, this count, if present, should indicate zero.')
wfAtmCESStatsPointerParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsPointerParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsPointerParityErrors.setDescription('This records the count of the number of events in which the AAL1 reassembler detects a parity check failure at the point where a structured data pointer is expected. This count is only meaningful for structured CES modes, as unstructured CES modes do not use pointers. For unstructured CES modes, this count, if present, should indicate zero.')
wfAtmCESStatsAal1SeqErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsAal1SeqErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsAal1SeqErrors.setDescription("Number of times that the sequence number of an incoming AAL1 Type 1 SAR-PDU causes a transition from the 'sync' state to the 'out of sequence' state, as defined by ITU-T I.363.1.")
wfAtmCESStatsLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsLostCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsLostCells.setDescription('Number of lost cells, as detected by the AAL1 sequence number processing, for example. This records the count of the number of cells detected as lost in the network prior to the destination CES IWF AAL1 layer processing.')
wfAtmCESStatsMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsMisinsertedCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsMisinsertedCells.setDescription('Number of AAL1 sequence violations which the AAL Convergence sublayer interprets as a misinserted cell, as defined by ITU-T I.363.1.')
wfAtmCESStatsBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsBufUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsBufUnderflows.setDescription('Number of buffer underflows. This records the count of the number of times the CES reassembly buffer underflows. In the case of a continuous underflow caused by a loss of ATM cell flow, a single buffer underflow should be counted. If the CES IWF is implemented with multiple buffers (such as a cell level buffer and a bit level buffer), then either buffer underflow will cause this count to be incremented.')
wfAtmCESStatsBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsBufOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsBufOverflows.setDescription('Number of buffer overflows. This records the count of the number of times the CES reassembly buffer overflows. If the CES IWF is implemented with multiple buffers (such as a cell level buffer and a bit level buffer, then either buffer overflow will cause this count to be incremented ')
wfAtmCESStatsCellLossStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 4, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoss", 1), ("loss", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmCESStatsCellLossStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCESStatsCellLossStatus.setDescription('When cells are continuously lost for the number of milliseconds specified by wfAtmCESConfCellLossIntegrationPeriod, the value is set to loss (2). When cells are no longer lost, the value is set to noLoss (1).')
mibBuilder.exportSymbols("Wellfleet-CES-MIB", wfAtmCESConfConnType=wfAtmCESConfConnType, wfAtmCESStatsPointerReframes=wfAtmCESStatsPointerReframes, wfAtmCESStatsReassCells=wfAtmCESStatsReassCells, wfAtmCESConfCbrService=wfAtmCESConfCbrService, wfAtmCESStatsAtmVci=wfAtmCESStatsAtmVci, wfAtmCESObjects=wfAtmCESObjects, wfAtmCESStatsTable=wfAtmCESStatsTable, wfAtmCESConfOperStatus=wfAtmCESConfOperStatus, wfAtmCESConfCbrClockMode=wfAtmCESConfCbrClockMode, wfAtmCESConfLocalAddr=wfAtmCESConfLocalAddr, wfAtmCESConfVclCct=wfAtmCESConfVclCct, wfAtmCESConfCdvRxT=wfAtmCESConfCdvRxT, wfAtmCESConfAtmVpi=wfAtmCESConfAtmVpi, wfAtmCESConfCellLossIntegrationPeriod=wfAtmCESConfCellLossIntegrationPeriod, wfAtmCESConfCfgAtmVci=wfAtmCESConfCfgAtmVci, wfAtmCESConfAtmIndex=wfAtmCESConfAtmIndex, wfAtmCESStatsMisinsertedCells=wfAtmCESStatsMisinsertedCells, wfAtmCESStatsCbrIndex=wfAtmCESStatsCbrIndex, wfAtmCESConfPartialFill=wfAtmCESConfPartialFill, wfAtmCESConfCbrIndex=wfAtmCESConfCbrIndex, wfAtmCESConfCfgAtmVpi=wfAtmCESConfCfgAtmVpi, wfAtmCESConfAdminStatus=wfAtmCESConfAdminStatus, wfAtmCESStatsAal1SeqErrors=wfAtmCESStatsAal1SeqErrors, wfAtmCESStatsBufOverflows=wfAtmCESStatsBufOverflows, wfAtmCESConfBufMaxSize=wfAtmCESConfBufMaxSize, wfAtmCESConfDisable=wfAtmCESConfDisable, wfAtmCESConfEntry=wfAtmCESConfEntry, wfAtmCESStatsCellLossStatus=wfAtmCESStatsCellLossStatus, wfAtmCESStatsEntry=wfAtmCESStatsEntry, wfAtmCESStatsPointerParityErrors=wfAtmCESStatsPointerParityErrors, wfAtmCESStatsVclCct=wfAtmCESStatsVclCct, wfAtmCESStatsAtmIndex=wfAtmCESStatsAtmIndex, wfAtmCESStatsHdrErrors=wfAtmCESStatsHdrErrors, wfAtmCESStatsBufUnderflows=wfAtmCESStatsBufUnderflows, wfAtmCESStatsAtmVpi=wfAtmCESStatsAtmVpi, wfAtmCESConfCas=wfAtmCESConfCas, wfAtmCESConfDelete=wfAtmCESConfDelete, wfAtmCESConfAtmVci=wfAtmCESConfAtmVci, wfAtmCESConfTable=wfAtmCESConfTable, wfAtmCESStatsLostCells=wfAtmCESStatsLostCells, wfAtmCESGroup=wfAtmCESGroup)

#
# PySNMP MIB module CISCO-WIRELESS-P2MP-RF-METRICS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WIRELESS-P2MP-RF-METRICS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:21:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CwrUpdateTime, CwrCollectionStatus, CwrFixedPointPrecision, CwrCollectionAction, CwrThreshLimitType, CwrFixedPointScale, P2mpSnapshotAttribute, CwrFixedPointValue, P2mpRadioSignalAttribute = mibBuilder.importSymbols("CISCO-WIRELESS-TC-MIB", "CwrUpdateTime", "CwrCollectionStatus", "CwrFixedPointPrecision", "CwrCollectionAction", "CwrThreshLimitType", "CwrFixedPointScale", "P2mpSnapshotAttribute", "CwrFixedPointValue", "P2mpRadioSignalAttribute")
OwnerString, ifIndex = mibBuilder.importSymbols("IF-MIB", "OwnerString", "ifIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Counter32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, MibIdentifier, Gauge32, Counter64, Unsigned32, NotificationType, TimeTicks, Bits, Integer32, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "MibIdentifier", "Gauge32", "Counter64", "Unsigned32", "NotificationType", "TimeTicks", "Bits", "Integer32", "ObjectIdentity", "iso")
MacAddress, TruthValue, TextualConvention, TimeInterval, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TruthValue", "TextualConvention", "TimeInterval", "DisplayString", "RowStatus")
ciscoWirelessRfMetricsMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 180))
if mibBuilder.loadTexts: ciscoWirelessRfMetricsMIB.setLastUpdated('200004191910Z')
if mibBuilder.loadTexts: ciscoWirelessRfMetricsMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoWirelessRfMetricsMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: wireless-nms@cisco.com')
if mibBuilder.loadTexts: ciscoWirelessRfMetricsMIB.setDescription('This is the MIB Module for the Cisco Wireless Radio Point to MultiPoint interface specification.')
p2mpRadioHistoryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 1))
p2mpRadioTimelineGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 2))
p2mpRadioThresholdGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 3))
p2mpRadioSnapshotGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 4))
p2mpHistCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1), )
if mibBuilder.loadTexts: p2mpHistCtrlTable.setStatus('current')
if mibBuilder.loadTexts: p2mpHistCtrlTable.setDescription('This table contains information about histograms configured in hardware.')
p2mpHistCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistSuMacAddress"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistClass"))
if mibBuilder.loadTexts: p2mpHistCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpHistCtrlEntry.setDescription("This represents one entry in the p2mpHistCtrlTable. This table is indexed by ifIndex, p2mpHistSuMacAddress, and p2mpHistClass. At the head end: Histograms can be created on each upstream channel either on a per channel or per subscriber unit basis. When histograms are created on a per subscriber unit basis, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer (propDocsWirelessMaclayer) at the head end. When histograms are created on a per channel basis, the user must set the MAC address to zero(00 00 00 00 00 00). The channel ID is specified by the ifIndex of the upstream channel. Hence, when creating histograms on a per channel basis, the ifIndex must be set to the ifIndex of the upstream channel (propDocsWirelessUpstream) on which the histogram is to be created. At the subscriber end: Histograms can only be created on the downstream channel. Since there is only one downstream channel, histograms cannot be created per channel ID. Hence, when a histogram is created, the user must set the MAC address (p2mpHistSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex must be set to the ifIndex of the downstream channel (propDocsWirelessDownstream).")
p2mpHistSuMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: p2mpHistSuMacAddress.setStatus('current')
if mibBuilder.loadTexts: p2mpHistSuMacAddress.setDescription('This object is used to index this table. At the head end: When a histogram is created on a per subscriber unit basis, this object should reflect the MAC address of the subscriber unit. When a histogram is created on a per channel basis, this object must be set to zero(00 00 00 00 00 00). At the subscriber end: When creating a histogram, this object must always be set to zero (00 00 00 00 00 00).')
p2mpHistClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 2), P2mpRadioSignalAttribute())
if mibBuilder.loadTexts: p2mpHistClass.setStatus('current')
if mibBuilder.loadTexts: p2mpHistClass.setDescription('This objects used to index this table. It represents the attribute that is being histogrammed.')
p2mpHistSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fine", 1), ("coarse", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpHistSize.setStatus('current')
if mibBuilder.loadTexts: p2mpHistSize.setDescription('This object lets the user select the granularity of the histogram. The number of bins used for the capture in each category is hardware dependent.')
p2mpHistSumScale = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 4), CwrFixedPointScale()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistSumScale.setStatus('current')
if mibBuilder.loadTexts: p2mpHistSumScale.setDescription('This variable indicates the exponent to apply to the fixed-point values in the histogram summary table.')
p2mpHistSumPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 5), CwrFixedPointPrecision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistSumPrecision.setStatus('current')
if mibBuilder.loadTexts: p2mpHistSumPrecision.setDescription('This variable indicates the number of decimal places used for precision when interpreting the fixed-point values in the histogram summary table.')
p2mpStartBinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483647, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpStartBinValue.setStatus('current')
if mibBuilder.loadTexts: p2mpStartBinValue.setDescription('This object represents the maximum of the values that will be collected in the first bin of the histogram. All values <= p2mpStartBinValue are kept in the first histogram bin.')
p2mpEndBinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483647, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpEndBinValue.setStatus('current')
if mibBuilder.loadTexts: p2mpEndBinValue.setDescription('This object represents the minimum of the values that will be collected in the last bin of the histogram. All values >= p2mpEndBinValue are kept in the last histogram bin.')
p2mpCollDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 8), CwrUpdateTime()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpCollDuration.setStatus('current')
if mibBuilder.loadTexts: p2mpCollDuration.setDescription('This object specifies the duration for which this histogram must be accumulated. After successfully accumulating data for this amount of time the collection stops and the p2mpHistStatus changes to statusCaptured.')
p2mpUpdateRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 9), CwrUpdateTime()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpUpdateRate.setStatus('current')
if mibBuilder.loadTexts: p2mpUpdateRate.setDescription('This object represents rate at which snapshots of the histogram will be available.')
p2mpPeriodicSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpPeriodicSum.setStatus('current')
if mibBuilder.loadTexts: p2mpPeriodicSum.setDescription('The histogram data is updated every p2mpUpdateRate seconds. When set to true(1), the latest histogram data set is summed with the previous histogram data set and the p2mpHistSummaryTable will reflect cumulative values. When set to false(2), only the latest data set is made available and the p2mpHistSummarytable will reflect the latest values.')
p2mpHistOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 11), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpHistOwner.setStatus('current')
if mibBuilder.loadTexts: p2mpHistOwner.setDescription('This object identifies management station that created this histogram specification.')
p2mpHistAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 12), CwrCollectionAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpHistAction.setStatus('current')
if mibBuilder.loadTexts: p2mpHistAction.setDescription('This object represents the action to be carried out on this histogram specification. If a histogram has been successfully captured then it must be cleared before an other capture may be initiated.')
p2mpHistStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 13), CwrCollectionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpHistStatus.setDescription("This object represents the current state of this histogram. Once the histogram collection is complete the status changes to statusCaptured and the data is available for use. None of the parameters of a histogram specification may be modified when the specification is in statusInProgress. A statusCaptured or statusStopped histogram must be actionClear'ed before it can be restarted. The histogram may be read accurately between the p2mpUpdateRate intervals. If the read spans across the update time data from the previous and current updates can be mingled.")
p2mpHistRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 1, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpHistRowStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpHistRowStatus.setDescription('This object may be used to create or delete a histogram control specification.')
p2mpHistSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 2), )
if mibBuilder.loadTexts: p2mpHistSummaryTable.setStatus('current')
if mibBuilder.loadTexts: p2mpHistSummaryTable.setDescription('This table contains histogram Summary collected based on the specifications in the p2mpHistCtrlTable.')
p2mpHistSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistSuMacAddress"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistClass"))
if mibBuilder.loadTexts: p2mpHistSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpHistSummaryEntry.setDescription("This represents one entry in the p2mpHistSummaryTable. At the head end: When viewing the summary of a histogram that was created for a specific subscriber unit, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer at the head end. When viewing the summary of a histogram created for a specific channel, the user must set the MAC address to zero (00 00 00 00 00 00). The ifIndex is the upstream channel on which the histogram was created. At the subscriber end: The user sets the MAC address (p2mpHistSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex is the channel ID of the downstream channel.")
p2mpHistUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 2, 1, 1), CwrUpdateTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistUpdateTime.setStatus('current')
if mibBuilder.loadTexts: p2mpHistUpdateTime.setDescription('This object represents the sysUpTime when this histogram was retrieved from hardware.')
p2mpHistMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 2, 1, 2), CwrFixedPointValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistMin.setStatus('current')
if mibBuilder.loadTexts: p2mpHistMin.setDescription('This object represents minimum value seen in this histogram.')
p2mpHistMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 2, 1, 3), CwrFixedPointValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistMax.setStatus('current')
if mibBuilder.loadTexts: p2mpHistMax.setDescription('This object represents maximum value seen in this histogram.')
p2mpHistMean = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 2, 1, 4), CwrFixedPointValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpHistMean.setStatus('current')
if mibBuilder.loadTexts: p2mpHistMean.setDescription('This object represents mean of the values in this histogram.')
p2mpHistDataTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 3), )
if mibBuilder.loadTexts: p2mpHistDataTable.setStatus('current')
if mibBuilder.loadTexts: p2mpHistDataTable.setDescription('This table contains histogram values collected based on the specifications in the p2mpHistCtrlTable.')
p2mpHistDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistSuMacAddress"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistClass"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistBinIndex"))
if mibBuilder.loadTexts: p2mpHistDataEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpHistDataEntry.setDescription("This represents one entry in the p2mpHistDataTable. At the head end: When viewing the data of a histogram that was created for a specific subscriber unit, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer at the head end. When viewing the data of a histogram created for a specific channel, the user must set the MAC address to zero (00 00 00 00 00 00). The ifIndex is the upstream channel on which the histogram was created. At the subscriber end: The user sets the MAC address (p2mpHistSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex is the channel ID of the downstream channel.")
p2mpHistBinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)))
if mibBuilder.loadTexts: p2mpHistBinIndex.setStatus('current')
if mibBuilder.loadTexts: p2mpHistBinIndex.setDescription('This object represents the histogram bin number for the value in p2mpValue.')
p2mpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpValue.setStatus('current')
if mibBuilder.loadTexts: p2mpValue.setDescription('This object represents the value in the histogram bin p2mpHistBinIndex.')
p2mpTlCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1), )
if mibBuilder.loadTexts: p2mpTlCtrlTable.setStatus('current')
if mibBuilder.loadTexts: p2mpTlCtrlTable.setDescription('This table contains information about timelines configured in hardware. When radio signal data is collected it will be stored in a buffer of size p2mpTlNumDataValues which may be later retrieved.')
p2mpTlCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlSuMacAddress"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlClass"))
if mibBuilder.loadTexts: p2mpTlCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpTlCtrlEntry.setDescription("This represents one entry in the p2mpTlCtrlTable. This table is indexed by ifIndex, p2mpTlSuMacAddress, and p2mpTlClass. At the head end: Timelines can be created on each upstream channel either on a per channel or per subscriber unit basis. When timelines are created on a per subscriber unit basis, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer (propDocsWirelessMaclayer) at the head end. When timelines are created on a per channel basis, the user must set the MAC address to zero(00 00 00 00 00 00). The channel ID is specified by the ifIndex of the upstream channel. Hence, when creating timelines on a per channel basis, the ifIndex must be set to the ifIndex of the upstream channel on which the timeline is to be created At the subscriber end: Timelines can only be created on the downstream channel. Since there is only one downstream channel, timelines cannot be created per channel ID. Hence, when a timeline is created, the user must set the MAC address (p2mpTlSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex must be set to the ifIndex of the downstream channel (propDocsWirelessDownstream).")
p2mpTlSuMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: p2mpTlSuMacAddress.setStatus('current')
if mibBuilder.loadTexts: p2mpTlSuMacAddress.setDescription('This object is used to index this table. At the head end: When a timeline is created on a per subscriber unit basis, this object should reflect the MAC address of the subscriber unit. When a timeline is created on a per channel basis, this object must be set to zero(00 00 00 00 00 00). At the subscriber end: When creating a timeline, this object must always be set to zero (00 00 00 00 00 00).')
p2mpTlClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 2), P2mpRadioSignalAttribute())
if mibBuilder.loadTexts: p2mpTlClass.setStatus('current')
if mibBuilder.loadTexts: p2mpTlClass.setDescription('This object represents the attribute for which a timline capture is requested. When a timeline is requested p2mpBufSize worth of data will be captured.')
p2mpTlThreshAttribute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 3), P2mpRadioSignalAttribute()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlThreshAttribute.setStatus('current')
if mibBuilder.loadTexts: p2mpTlThreshAttribute.setDescription("This object, along with p2mpTlThreshType, identifies the threshold in the p2mpThresholdTable responsible for trigerring this timeline. When this object's value is none(0), it implies that there is no threshold associated with this timeline.")
p2mpTlThreshType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 4), CwrThreshLimitType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlThreshType.setStatus('current')
if mibBuilder.loadTexts: p2mpTlThreshType.setDescription("This object, along with p2mpTlThreshAttribute, identifies the threshold in the p2mpThresholdTable responsible for trigerring this timeline. When this object's value is none(0), it implies that there is no threshold associated with this timeline.")
p2mpTlNumDataValues = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('number of data values').setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlNumDataValues.setStatus('current')
if mibBuilder.loadTexts: p2mpTlNumDataValues.setDescription('This object indicates the number of data values to be captured for this timeline. The captured data can be viewed by reading the p2mpTlDataTable.')
p2mpTlDataScale = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 6), CwrFixedPointScale()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlDataScale.setStatus('current')
if mibBuilder.loadTexts: p2mpTlDataScale.setDescription('This variable indicates the exponent to apply to the fixed-point values in the timeline data table.')
p2mpTlDataPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 7), CwrFixedPointPrecision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlDataPrecision.setStatus('current')
if mibBuilder.loadTexts: p2mpTlDataPrecision.setDescription('This variable indicates the number of decimal places used for precision when interpreting the fixed-point values in the timeline data table.')
p2mpTlSamplePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlSamplePeriod.setStatus('current')
if mibBuilder.loadTexts: p2mpTlSamplePeriod.setDescription("This lets the user specify the time in milliseconds between consecutive timeline samples. The special value of '0' indicates that the timeline will be sampled on every burst of data. The number of bursts in one milliseconds depends on the modulation profile.")
p2mpTlAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 9), CwrCollectionAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlAction.setStatus('current')
if mibBuilder.loadTexts: p2mpTlAction.setDescription('This object represents the action to be carried out on this timeline specification. If a timeline has been successfully captured then it must be cleared before another capture may be initiated.')
p2mpTlPostTrigBufMgmt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("preTrigger", 1), ("postTrigger", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlPostTrigBufMgmt.setStatus('current')
if mibBuilder.loadTexts: p2mpTlPostTrigBufMgmt.setDescription('Once a trigger fires, this object determines which portion of the collected data to capture for use. If it is: preTrigger(1) : Then most of the data collected prior to trigger is captured. postTrigger(2): Then most of the data collected after the trigger is captured.')
p2mpTlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 11), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlOwner.setStatus('current')
if mibBuilder.loadTexts: p2mpTlOwner.setDescription('This object identifies the management station that created this timeline specification.')
p2mpTlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 12), CwrCollectionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpTlStatus.setDescription("This object represents the current state of this timeline. Once the timeline collection is complete the status changes to statusCaptured and the data is available for use. None of the parameters of a timeline specification may be modified when the specification is in statusInProgress. A statusCaptured or statusStopped timeline must be actionClear'ed before it can be restarted.")
p2mpTlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 1, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpTlRowStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpTlRowStatus.setDescription('This object may be used to create or delete a timeline control specification. Once created data sampling starts based on the value of p2mpTlAction.')
p2mpTlSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 2), )
if mibBuilder.loadTexts: p2mpTlSummaryTable.setStatus('current')
if mibBuilder.loadTexts: p2mpTlSummaryTable.setDescription('This table contains Timeline Summary collected based on the specifications in the p2mpTlCtrlTable.')
p2mpTlSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlSuMacAddress"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlClass"))
if mibBuilder.loadTexts: p2mpTlSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpTlSummaryEntry.setDescription("This represents one entry in the p2mpTlSummaryTable. At the head end: When viewing the summary of a timeline created for a specific subscriber unit, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer at the head end. When viewing the summary of a timeline created for a specific channel, the user must set the MAC address to zero(00 00 00 00 00 00). The ifIndex is the upstream channel on which the timeline was created. At the subscriber end: The user sets the MAC address (p2mpTlSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex is the channel ID of the downstream channel.")
p2mpTlUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 2, 1, 1), CwrUpdateTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlUpdateTime.setStatus('current')
if mibBuilder.loadTexts: p2mpTlUpdateTime.setDescription('This object represents the sysUpTime when this timeline capture was completed.')
p2mpTlNumValues = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlNumValues.setStatus('current')
if mibBuilder.loadTexts: p2mpTlNumValues.setDescription('This object represents the number of values available in the timeline')
p2mpTlTriggerLoc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlTriggerLoc.setStatus('current')
if mibBuilder.loadTexts: p2mpTlTriggerLoc.setDescription('This object contains the value of p2mpTlValueIndex which represents the entry in the p2mpTlDataTable that caused the stop trigger to fire, thereby resulting in this timeline to be collected.')
p2mpTlDataTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 3), )
if mibBuilder.loadTexts: p2mpTlDataTable.setStatus('current')
if mibBuilder.loadTexts: p2mpTlDataTable.setDescription('This table contains timeline values collected based on the specifications in the p2mpTlCtrlTable.')
p2mpTlDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlSuMacAddress"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlClass"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlValueIndex"))
if mibBuilder.loadTexts: p2mpTlDataEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpTlDataEntry.setDescription("This represents one entry in the p2mpTlDataTable. At the head end: When viewing the data of a timeline created for a specific subscriber unit, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer at the head end. When viewing the data of a timeline created for a specific channel, the user must set the MAC address to zero(00 00 00 00 00 00). The ifIndex is the upstream channel on which the timeline was created. At the subscriber end: The user sets the MAC address (p2mpTlSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex is the channel ID of the downstream channel.")
p2mpTlValueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: p2mpTlValueIndex.setStatus('current')
if mibBuilder.loadTexts: p2mpTlValueIndex.setDescription('This object is the index into the timeline data.')
p2mpTlValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 2, 3, 1, 2), CwrFixedPointValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpTlValue.setStatus('current')
if mibBuilder.loadTexts: p2mpTlValue.setDescription('This object represents the radio signal data sampled.')
p2mpThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1), )
if mibBuilder.loadTexts: p2mpThresholdTable.setStatus('current')
if mibBuilder.loadTexts: p2mpThresholdTable.setDescription('This table enables the user to establish thresholds for the radio signals analyzed on the radio interface.')
p2mpThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshSuMacAddr"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshAttribute"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshType"))
if mibBuilder.loadTexts: p2mpThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpThresholdEntry.setDescription("This represents one entry in the p2mpThresholdTable. At the head end: Thresholds can be created on each upstream channel either on a per channel or per subscriber unit basis. When creating thresholds on a per subscriber unit basis, the user must specify the subscriber unit's MAC address and the ifIndex of the MAC layer (propDocsWirelessMaclayer) at the head end. When creating thresholds on a per channel basis, the user must set the MAC address to zero(00 00 00 00 00 00). The channel ID is specified by the ifIndex of the upstream channel. Hence, when creating thresholds on a per channel basis, the ifIndex must be set to the ifIndex of the upstream channel (propDocsWirelessUpstream) on which the threshold is created. At the subscriber end: Thresholds can only be created on the downstream channel. Since there is only one downstream channel, thresholds cannot be created per channel ID. Hence, when a thresholds is created, the users sets the MAC address (p2mpThreshSuMacAdress) to zero(00 00 00 00 00 00). The ifIndex must be set to the ifIndex of the downstream channel (propDocsWirelessDownstream).")
p2mpThreshSuMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: p2mpThreshSuMacAddr.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshSuMacAddr.setDescription('This object is used to index this table. At the head end: When a threshold is created on a per subscriber unit basis, this object should reflect the MAC address of the subscriber unit. When a threshold is created on a per channel basis, this object must be set to zero(00 00 00 00 00 00). At the subscriber end: When creating a threshold , this object must always be set to zero (00 00 00 00 00 00).')
p2mpThreshAttribute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 2), P2mpRadioSignalAttribute())
if mibBuilder.loadTexts: p2mpThreshAttribute.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshAttribute.setDescription('This represents the attribute of a radio link which needs to be thresholded. For each of these attributes, the p2mpThreshType identifies the type of change to monitor. When that threshold is exceeded a Trap with appropriate parameters will be generated.')
p2mpThreshType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 3), CwrThreshLimitType())
if mibBuilder.loadTexts: p2mpThreshType.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshType.setDescription('This object represents the kind of change that needs to be monitored for the p2mpThreshAttribute. An event is generated when the specified condition is met.')
p2mpThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483647, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpThreshValue.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshValue.setDescription('This object represents the value to be compared against. The p2mpThreshType determines the way in which it is used. It is used as follows: if p2mpThreshType is .. highThresh : Notify if data sample exceeds the p2mpThreshValue. lowThresh : Notify if data sample recedes below the p2mpThreshValue. upChange : Notify if data sample increases by more than p2mpThreshValue. downChange : Notify if data sample decreases by more than p2mpThreshValue. upLimit : Notify if data sample crosses p2mpThreshValue while increasing in value. lowLimit : Notify if data sample crosses p2mpThreshValue while decreasing in value.')
p2mpThreshHysteresisTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 5), TimeInterval()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpThreshHysteresisTime.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshHysteresisTime.setDescription('When radio signals oscillate around threshold values, they potentially flood the system with notifications. This object specifies the amount of time to wait before sending an identical notification if the oscillations continue.')
p2mpThreshLimitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 6), TimeInterval()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpThreshLimitTime.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshLimitTime.setDescription("It is desirable to know when a radio signal has stabilized. This object specifies the amount of time that the radio signal should stay below the threshold after crossing it. If it does then a 'clear' notification is sent.")
p2mpThreshRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpThreshRowStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpThreshRowStatus.setDescription('This object represents the status of this threshold entry. It may be used to create a new threshold specification. For every p2mpThreshAttribute one threshold of p2mpThreshType on one DSP may be created.')
p2mpSnapshotCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1), )
if mibBuilder.loadTexts: p2mpSnapshotCtrlTable.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotCtrlTable.setDescription('This table contains information about the snapshots configured in hardware. When data is collected it will be stored in p2mpSnapDataTable. Snapshots can only be captured per DSP.')
p2mpSnapshotCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotDspNum"))
if mibBuilder.loadTexts: p2mpSnapshotCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotCtrlEntry.setDescription('This represents one entry in the p2mpSnapshotCntrlTable It is indexed by the ifIndex of the MAC layer (propDocsWirelessMaclayer) and p2mpSnapshotDspNum.')
p2mpSnapshotDspNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: p2mpSnapshotDspNum.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotDspNum.setDescription('This object represents the DSP on which the snapshot needs to be collected.')
p2mpSnapshotType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 2), P2mpSnapshotAttribute()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpSnapshotType.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotType.setDescription('This identfies the set of radio signal attributes being monitored in this snapshot.')
p2mpSnapshotDataScale = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 3), CwrFixedPointScale()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapshotDataScale.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotDataScale.setDescription('This variable indicates the exponent to apply to the fixed-point values in the snapshot data table.')
p2mpSnapshotDataPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 4), CwrFixedPointPrecision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapshotDataPrecision.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotDataPrecision.setDescription('This variable indicates the number of decimal places used for precision when interpreting the fixed-point values in the snapshot data table.')
p2mpSnapshotOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 5), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpSnapshotOwner.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotOwner.setDescription('This object identifies management station that created this snapshot specification.')
p2mpSnapshotAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 6), CwrCollectionAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpSnapshotAction.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotAction.setDescription('This object represents the action to be carried out on this snapshot specification. If a snapshot has been successfully captured then it must be cleared before another capture may be initiated.')
p2mpSnapshotStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 7), CwrCollectionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapshotStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotStatus.setDescription('This object represents the current status of this snapshot specification. When the status in statusInProgress none of the snapshot parameters can be configured. When the status is statusCaptured then data is available for use.')
p2mpSnapshotRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: p2mpSnapshotRowStatus.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapshotRowStatus.setDescription('This object may be used to create or delete this snapshot specification.')
p2mpSnapSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2), )
if mibBuilder.loadTexts: p2mpSnapSummaryTable.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapSummaryTable.setDescription('This table contains summary information for captured snapshots defined in p2mpSnapshotCtrlTable.')
p2mpSnapSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotDspNum"))
if mibBuilder.loadTexts: p2mpSnapSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapSummaryEntry.setDescription('This represents one entry in the p2mpSnapSummaryTable. It is indexed by the ifIndex of the MAC layer (propDocsWirelessMaclayer) and p2mpSnapshotDspNum.')
p2mpSnapAttr1Id = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr1Id.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr1Id.setDescription('This object represents the bit in the P2mpSnapshotAttribute bitmask that identifies the first attribute value.')
p2mpSnapAttr1Size = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr1Size.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr1Size.setDescription('This object represents the number of values captured for the snapshot p2mpSnapAttr1Id.')
p2mpSnapAttr2Id = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr2Id.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr2Id.setDescription('This object represents the bit in the P2mpSnapshotAttribute bitmask that identifies the second attribute value.')
p2mpSnapAttr2Size = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr2Size.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr2Size.setDescription('This object represents the number of values captured for the snapshot p2mpSnapAttr2Id.')
p2mpSnapAttr3Id = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr3Id.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr3Id.setDescription('This object represents the bit in the P2mpSnapshotAttribute bitmask that identifies the third attribute value.')
p2mpSnapAttr3Size = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr3Size.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr3Size.setDescription('This object represents the number of values captured for the snapshot p2mpSnapAttr3Id.')
p2mpSnapAttr4Id = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr4Id.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr4Id.setDescription('This object represents the bit in the P2mpSnapshotAttribute bitmask that identifies the fourth attribute value.')
p2mpSnapAttr4Size = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpSnapAttr4Size.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapAttr4Size.setDescription('This object represents the number of values captured for the snapshot p2mpSnapAttr4Id.')
p2mpSnapDataTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 3), )
if mibBuilder.loadTexts: p2mpSnapDataTable.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapDataTable.setDescription('This table contains snapshot values collected based on the specifications in the p2mpSnapshotCtrlTable.')
p2mpSnapDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotDspNum"), (0, "CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapValueIndex"))
if mibBuilder.loadTexts: p2mpSnapDataEntry.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapDataEntry.setDescription('This represents one entry in the P2mpSnapDataTable. It is indexed by ifIndex of the MAC layer (propDocsWirelessMaclayer), p2mpSnapshotIndex, and p2mpSnapValueIndex. The values in this table represent real and complex numbers. If they are real numbers then p2mpRealPart contains the data and p2mpImaginaryPart is undefined.')
p2mpSnapValueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)))
if mibBuilder.loadTexts: p2mpSnapValueIndex.setStatus('current')
if mibBuilder.loadTexts: p2mpSnapValueIndex.setDescription('This object represents the snapshot entry value number. The hardware provides a maximum of 1024 data points for any snapshot attribute. Since we can capture a maximum of 4 attributes in a single snapshot, this object can have a maximum value of 4096 (1024 * 4).')
p2mpRealPart = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 3, 1, 2), CwrFixedPointValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpRealPart.setStatus('current')
if mibBuilder.loadTexts: p2mpRealPart.setDescription('The data sample value. Real part.')
p2mpImaginaryPart = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 180, 4, 3, 1, 3), CwrFixedPointValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: p2mpImaginaryPart.setStatus('current')
if mibBuilder.loadTexts: p2mpImaginaryPart.setDescription('The data sample value. Imaginary part of the attribute is represented by a complex number.')
p2mpRfMetricsMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 2))
p2mpRfMetricsMIBNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 2, 0))
p2mpTrapThresh = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 180, 3, 2, 0, 1)).setObjects(("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshValue"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshHysteresisTime"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshLimitTime"))
if mibBuilder.loadTexts: p2mpTrapThresh.setStatus('current')
if mibBuilder.loadTexts: p2mpTrapThresh.setDescription('The radio subsystem generates this trap when a threshold crosses its specified limit. The parameters identify the following: p2mpThreshValue - The value that was crossed. p2mpThreshHysteresisTime - The specified hysteresis time p2mpThreshLimitTime - The specified limit time ')
p2mpRadioRfConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 5))
p2mpRadioRfCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 1))
p2mpRadioRfGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 2))
p2mpRadioRfCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 1, 1)).setObjects(("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpComplianceHistogramGroup"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpComplianceThresholdGroup"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpComplianceTimelineGroup"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpComplianceSnapshotGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    p2mpRadioRfCompliance = p2mpRadioRfCompliance.setStatus('current')
if mibBuilder.loadTexts: p2mpRadioRfCompliance.setDescription('The compliance statement for devices that are Point to MultiPoint wireless interfaces.')
p2mpComplianceHistogramGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 2, 1)).setObjects(("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistSize"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistSumScale"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistSumPrecision"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpStartBinValue"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpEndBinValue"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpUpdateRate"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpCollDuration"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpPeriodicSum"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistOwner"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistAction"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistStatus"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistRowStatus"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistUpdateTime"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistMin"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistMax"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpHistMean"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    p2mpComplianceHistogramGroup = p2mpComplianceHistogramGroup.setStatus('current')
if mibBuilder.loadTexts: p2mpComplianceHistogramGroup.setDescription('Group of objects implemented in the point to multipoint wireless system for capturing histograms and snapshots of radio signal parameters on the radio interface.')
p2mpComplianceThresholdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 2, 2)).setObjects(("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshValue"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshHysteresisTime"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshLimitTime"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpThreshRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    p2mpComplianceThresholdGroup = p2mpComplianceThresholdGroup.setStatus('current')
if mibBuilder.loadTexts: p2mpComplianceThresholdGroup.setDescription('Group of objects implemented in the point to multipoint wireless system to set thresholds on the radio interface.')
p2mpComplianceTimelineGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 2, 3)).setObjects(("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlThreshAttribute"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlThreshType"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlNumDataValues"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlDataScale"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlDataPrecision"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlSamplePeriod"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlAction"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlPostTrigBufMgmt"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlOwner"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlStatus"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlRowStatus"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlUpdateTime"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlNumValues"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlTriggerLoc"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpTlValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    p2mpComplianceTimelineGroup = p2mpComplianceTimelineGroup.setStatus('current')
if mibBuilder.loadTexts: p2mpComplianceTimelineGroup.setDescription('Group of objects implemented in the point to point wireless system for establishing thresholds and capturing timeline data.')
p2mpComplianceSnapshotGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 180, 5, 2, 4)).setObjects(("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotType"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotDataScale"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotDataPrecision"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotOwner"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotAction"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotStatus"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapshotRowStatus"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr1Id"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr1Size"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr2Id"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr2Size"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr3Id"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr3Size"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr4Id"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpSnapAttr4Size"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpRealPart"), ("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", "p2mpImaginaryPart"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    p2mpComplianceSnapshotGroup = p2mpComplianceSnapshotGroup.setStatus('current')
if mibBuilder.loadTexts: p2mpComplianceSnapshotGroup.setDescription('Group of objects implemented in the point to multi point wireless system for capturing snapshots of various parameters on the radio interface.')
mibBuilder.exportSymbols("CISCO-WIRELESS-P2MP-RF-METRICS-MIB", p2mpRadioRfGroups=p2mpRadioRfGroups, p2mpSnapshotType=p2mpSnapshotType, p2mpComplianceThresholdGroup=p2mpComplianceThresholdGroup, p2mpTlNumDataValues=p2mpTlNumDataValues, p2mpTlStatus=p2mpTlStatus, p2mpSnapshotOwner=p2mpSnapshotOwner, p2mpRealPart=p2mpRealPart, p2mpValue=p2mpValue, p2mpTlValueIndex=p2mpTlValueIndex, p2mpEndBinValue=p2mpEndBinValue, p2mpThreshSuMacAddr=p2mpThreshSuMacAddr, p2mpSnapAttr3Id=p2mpSnapAttr3Id, p2mpComplianceHistogramGroup=p2mpComplianceHistogramGroup, p2mpTlDataPrecision=p2mpTlDataPrecision, p2mpTlSummaryTable=p2mpTlSummaryTable, p2mpHistSummaryTable=p2mpHistSummaryTable, p2mpSnapshotCtrlTable=p2mpSnapshotCtrlTable, p2mpSnapAttr4Id=p2mpSnapAttr4Id, p2mpHistDataTable=p2mpHistDataTable, ciscoWirelessRfMetricsMIB=ciscoWirelessRfMetricsMIB, p2mpRfMetricsMIBNotificationPrefix=p2mpRfMetricsMIBNotificationPrefix, p2mpTlSuMacAddress=p2mpTlSuMacAddress, p2mpHistCtrlEntry=p2mpHistCtrlEntry, p2mpCollDuration=p2mpCollDuration, PYSNMP_MODULE_ID=ciscoWirelessRfMetricsMIB, p2mpTlDataEntry=p2mpTlDataEntry, p2mpTlCtrlTable=p2mpTlCtrlTable, p2mpSnapAttr2Id=p2mpSnapAttr2Id, p2mpHistSumPrecision=p2mpHistSumPrecision, p2mpHistSumScale=p2mpHistSumScale, p2mpHistAction=p2mpHistAction, p2mpHistUpdateTime=p2mpHistUpdateTime, p2mpHistRowStatus=p2mpHistRowStatus, p2mpSnapAttr1Id=p2mpSnapAttr1Id, p2mpTlThreshAttribute=p2mpTlThreshAttribute, p2mpThreshRowStatus=p2mpThreshRowStatus, p2mpHistSize=p2mpHistSize, p2mpSnapshotDataPrecision=p2mpSnapshotDataPrecision, p2mpTlDataTable=p2mpTlDataTable, p2mpTlRowStatus=p2mpTlRowStatus, p2mpTlValue=p2mpTlValue, p2mpRfMetricsMIBNotification=p2mpRfMetricsMIBNotification, p2mpSnapAttr3Size=p2mpSnapAttr3Size, p2mpSnapAttr4Size=p2mpSnapAttr4Size, p2mpTlSamplePeriod=p2mpTlSamplePeriod, p2mpSnapSummaryTable=p2mpSnapSummaryTable, p2mpSnapshotAction=p2mpSnapshotAction, p2mpHistSuMacAddress=p2mpHistSuMacAddress, p2mpTlTriggerLoc=p2mpTlTriggerLoc, p2mpHistOwner=p2mpHistOwner, p2mpRadioRfConformance=p2mpRadioRfConformance, p2mpRadioHistoryGroup=p2mpRadioHistoryGroup, p2mpTlThreshType=p2mpTlThreshType, p2mpTlDataScale=p2mpTlDataScale, p2mpTlUpdateTime=p2mpTlUpdateTime, p2mpTlOwner=p2mpTlOwner, p2mpSnapshotDataScale=p2mpSnapshotDataScale, p2mpHistClass=p2mpHistClass, p2mpTrapThresh=p2mpTrapThresh, p2mpRadioThresholdGroup=p2mpRadioThresholdGroup, p2mpThreshType=p2mpThreshType, p2mpThreshAttribute=p2mpThreshAttribute, p2mpComplianceSnapshotGroup=p2mpComplianceSnapshotGroup, p2mpTlAction=p2mpTlAction, p2mpTlCtrlEntry=p2mpTlCtrlEntry, p2mpSnapDataEntry=p2mpSnapDataEntry, p2mpHistMean=p2mpHistMean, p2mpThresholdTable=p2mpThresholdTable, p2mpSnapDataTable=p2mpSnapDataTable, p2mpHistMax=p2mpHistMax, p2mpHistStatus=p2mpHistStatus, p2mpHistSummaryEntry=p2mpHistSummaryEntry, p2mpThreshLimitTime=p2mpThreshLimitTime, p2mpSnapshotDspNum=p2mpSnapshotDspNum, p2mpRadioRfCompliances=p2mpRadioRfCompliances, p2mpImaginaryPart=p2mpImaginaryPart, p2mpSnapValueIndex=p2mpSnapValueIndex, p2mpSnapshotCtrlEntry=p2mpSnapshotCtrlEntry, p2mpSnapshotRowStatus=p2mpSnapshotRowStatus, p2mpTlPostTrigBufMgmt=p2mpTlPostTrigBufMgmt, p2mpSnapAttr2Size=p2mpSnapAttr2Size, p2mpTlNumValues=p2mpTlNumValues, p2mpThresholdEntry=p2mpThresholdEntry, p2mpThreshHysteresisTime=p2mpThreshHysteresisTime, p2mpRadioTimelineGroup=p2mpRadioTimelineGroup, p2mpTlClass=p2mpTlClass, p2mpStartBinValue=p2mpStartBinValue, p2mpSnapAttr1Size=p2mpSnapAttr1Size, p2mpHistBinIndex=p2mpHistBinIndex, p2mpRadioRfCompliance=p2mpRadioRfCompliance, p2mpSnapshotStatus=p2mpSnapshotStatus, p2mpHistCtrlTable=p2mpHistCtrlTable, p2mpTlSummaryEntry=p2mpTlSummaryEntry, p2mpPeriodicSum=p2mpPeriodicSum, p2mpUpdateRate=p2mpUpdateRate, p2mpRadioSnapshotGroup=p2mpRadioSnapshotGroup, p2mpHistMin=p2mpHistMin, p2mpThreshValue=p2mpThreshValue, p2mpSnapSummaryEntry=p2mpSnapSummaryEntry, p2mpComplianceTimelineGroup=p2mpComplianceTimelineGroup, p2mpHistDataEntry=p2mpHistDataEntry)

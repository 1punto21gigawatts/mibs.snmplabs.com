#
# PySNMP MIB module AT-DHCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AT-DHCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:29:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
DisplayStringUnsized, modules = mibBuilder.importSymbols("AT-SMI-MIB", "DisplayStringUnsized", "modules")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, TimeTicks, ModuleIdentity, Unsigned32, iso, Counter64, Counter32, Gauge32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Bits, NotificationType, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "TimeTicks", "ModuleIdentity", "Unsigned32", "iso", "Counter64", "Counter32", "Gauge32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Bits", "NotificationType", "Integer32")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
dhcp = ModuleIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70))
dhcp.setRevisions(('2009-04-01 02:00', '2006-06-28 12:22',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: dhcp.setRevisionsDescriptions(('Added a new TRAP (dhcpRangeExceededThresholdTrap) which will be generated when the number of clients allocated for that range exceeds a preset threshold.', 'Initial Revision',))
if mibBuilder.loadTexts: dhcp.setLastUpdated('200904010200Z')
if mibBuilder.loadTexts: dhcp.setOrganization('Allied Telesis, Inc')
if mibBuilder.loadTexts: dhcp.setContactInfo('http://www.alliedtelesis.com')
if mibBuilder.loadTexts: dhcp.setDescription('This MIB file contains definitions of managed objects for the DHCP module. ')
dhcpRangeTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1), )
if mibBuilder.loadTexts: dhcpRangeTable.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeTable.setDescription('The table of DHCP ranges.')
dhcpRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1), ).setIndexNames((0, "AT-DHCP-MIB", "dhcpRangeIndex"))
if mibBuilder.loadTexts: dhcpRangeEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeEntry.setDescription('A single entry of the DHCP range table. This contains information about a single DHCP range configured on this device.')
dhcpRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeIndex.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeIndex.setDescription('The index of this DHCP range. DHCP ranges are stored in a list which is ordered by range name. The index gives the place in the list. Note that if ranges are added or deleted, the index for a given range will change. Since this table is read-only, this will not have an undue effect, but if in future this table is made read-write, a mechanism will have to be created to lock the indices of the range table while SET operations are proceeding.')
dhcpRangeName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 2), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeName.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeName.setDescription('The name given to identify this DHCP range. This is the ultimate method for uniquely identifying this range. Names are compared without regard to case, for example >range1< will be treated as the same as >RANGE1<.')
dhcpRangeBaseAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeBaseAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeBaseAddress.setDescription('The base address of this range. This address defines the lower bound of the range of IP addresses which can be allocated to devices requesting an IP address via DHCP.')
dhcpRangeNumberOfAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeNumberOfAddresses.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeNumberOfAddresses.setDescription('The number of IP address in this range. This number defines the upper bound of the range of IP addresses which can be allocated to devices requesting an IP address via DHCP.')
dhcpRangeGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeGateway.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeGateway.setDescription('The IP address of the BOOTP relay agent which will be relaying DHCP requests for this range. If this address is 0.0.0.0, then there will be no BOOTP relay agent and the range will be allocated to devices directly connected to this device.')
dhcpTrapVariable = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2))
dhcpRangeExhaustedGateway = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExhaustedGateway.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExhaustedGateway.setDescription('Whenever a DHCP client attempts to lease an IP address and the DHCP server cannot provide an address, this variable is set to the gateway address of the DHCP request. The gateway address is the IP address of the gateway acting as a BOOTP relay agent for the request. If there is no gateway, the address will be 0.0.0.0. If the gateway address is non-zero, the DHCP range from which the allocation should have been made will able to be identified by lookup in the DHCP range table.')
dhcpRangeExhaustedInterface = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExhaustedInterface.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExhaustedInterface.setDescription('Whenever a DHCP client attempts to lease an IP address and the DHCP server cannot provide an address, this variable is set to the IP address of the interface which received the DHCP request. If the gateway address associated with the failed DHCP request is 0.0.0.0, the interface address will be able to be used to lookup the range that was exhausted and from which the allocation should have been made.')
dhcpRangeExceededRange = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 3), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExceededRange.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExceededRange.setDescription('Whenever a DHCP client attempts to lease an IP address and the DHCP server has exceeded a pre-defined threshold this variable is set to the name of the range which received the DHCP request.')
dhcpRangeExceededClients = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExceededClients.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExceededClients.setDescription('The number of IP addresses statically defined for a range upon creation. Based on the starting IP address for a range, this number determines the upper bound of IP addresses which can be allocated to devices requesting an IP address via DHCP.')
dhcpRangeExceededRemaining = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExceededRemaining.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExceededRemaining.setDescription('The number of IP addresses still available to be allocated in this range.')
dhcpRangeExceededPercentage = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExceededPercentage.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExceededPercentage.setDescription('The percentage of IP addresses in a range that are currently in use.')
dhcpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 0))
dhcpRangeExhaustedTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 0, 1)).setObjects(("AT-DHCP-MIB", "dhcpRangeExhaustedGateway"), ("AT-DHCP-MIB", "dhcpRangeExhaustedInterface"))
if mibBuilder.loadTexts: dhcpRangeExhaustedTrap.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExhaustedTrap.setDescription('This trap is generated when a DHCP client makes a request for an IP address and the request cannot be satisfied because all addresses in the range are already allocated to other devices.')
dhcpRangeExceededThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 0, 2)).setObjects(("AT-DHCP-MIB", "dhcpRangeExhaustedInterface"), ("AT-DHCP-MIB", "dhcpRangeExceededRange"), ("AT-DHCP-MIB", "dhcpRangeExceededClients"), ("AT-DHCP-MIB", "dhcpRangeExceededRemaining"), ("AT-DHCP-MIB", "dhcpRangeExceededPercentage"))
if mibBuilder.loadTexts: dhcpRangeExceededThresholdTrap.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExceededThresholdTrap.setDescription('This trap is generated when a DHCP client makes a request for an IP address and a pre-defined usage threshold has been exceeded. The IP addresses will continue to be allocated until the range is exhausted.')
dhcpRangeExceededThresholdClearTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 0, 3)).setObjects(("AT-DHCP-MIB", "dhcpRangeExhaustedInterface"), ("AT-DHCP-MIB", "dhcpRangeExceededRange"), ("AT-DHCP-MIB", "dhcpRangeExceededClients"), ("AT-DHCP-MIB", "dhcpRangeExceededRemaining"), ("AT-DHCP-MIB", "dhcpRangeExceededPercentage"))
if mibBuilder.loadTexts: dhcpRangeExceededThresholdClearTrap.setStatus('current')
if mibBuilder.loadTexts: dhcpRangeExceededThresholdClearTrap.setDescription('This trap is generated when the number of allocated clients in a designated range falls below a pre-defined usage threshold.')
dhcpClientTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3), )
if mibBuilder.loadTexts: dhcpClientTable.setStatus('current')
if mibBuilder.loadTexts: dhcpClientTable.setDescription('The table of defined DHCP range client addresses.')
dhcpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1), ).setIndexNames((0, "AT-DHCP-MIB", "dhcpRangeIndex"), (0, "AT-DHCP-MIB", "dhcpClientIpAddress"))
if mibBuilder.loadTexts: dhcpClientEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpClientEntry.setDescription('A single entry of the DHCP range client table. This contains information about a single DHCP range client address.')
dhcpClientIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpClientIpAddress.setDescription('An IP address from the range of available addresses.')
dhcpClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientID.setStatus('current')
if mibBuilder.loadTexts: dhcpClientID.setDescription('The hardware address of the client, if any, that has been assigned the IP address.')
dhcpClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unused", 0), ("reclaiming", 1), ("inuse", 2), ("offered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientState.setStatus('current')
if mibBuilder.loadTexts: dhcpClientState.setDescription('The state of the IP address; one of unused, inuse or reclaim.')
dhcpClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("dyn", 2), ("static", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientType.setStatus('current')
if mibBuilder.loadTexts: dhcpClientType.setDescription('The type of allocation mechanism applied to the IP address; one of static, auto or dyn.')
dhcpClientExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientExpiry.setStatus('current')
if mibBuilder.loadTexts: dhcpClientExpiry.setDescription('The expiry date for dynamically allocated IP address.')
mibBuilder.exportSymbols("AT-DHCP-MIB", dhcpClientState=dhcpClientState, dhcpRangeExceededRemaining=dhcpRangeExceededRemaining, dhcpRangeNumberOfAddresses=dhcpRangeNumberOfAddresses, dhcpRangeExceededPercentage=dhcpRangeExceededPercentage, dhcpRangeExhaustedInterface=dhcpRangeExhaustedInterface, dhcpRangeExhaustedTrap=dhcpRangeExhaustedTrap, dhcpRangeIndex=dhcpRangeIndex, dhcpRangeExhaustedGateway=dhcpRangeExhaustedGateway, dhcp=dhcp, dhcpRangeExceededRange=dhcpRangeExceededRange, dhcpClientID=dhcpClientID, dhcpRangeExceededClients=dhcpRangeExceededClients, dhcpRangeGateway=dhcpRangeGateway, dhcpClientExpiry=dhcpClientExpiry, dhcpRangeTable=dhcpRangeTable, PYSNMP_MODULE_ID=dhcp, dhcpTrapVariable=dhcpTrapVariable, dhcpClientType=dhcpClientType, dhcpClientIpAddress=dhcpClientIpAddress, dhcpRangeExceededThresholdTrap=dhcpRangeExceededThresholdTrap, dhcpClientEntry=dhcpClientEntry, dhcpRangeEntry=dhcpRangeEntry, dhcpClientTable=dhcpClientTable, dhcpTraps=dhcpTraps, dhcpRangeBaseAddress=dhcpRangeBaseAddress, dhcpRangeExceededThresholdClearTrap=dhcpRangeExceededThresholdClearTrap, dhcpRangeName=dhcpRangeName)

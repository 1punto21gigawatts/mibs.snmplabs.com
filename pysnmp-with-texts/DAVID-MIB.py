#
# PySNMP MIB module DAVID-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DAVID-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:37:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
DisplayString, = mibBuilder.importSymbols("RFC1155-SMI", "DisplayString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, Gauge32, ObjectIdentity, TimeTicks, IpAddress, NotificationType, iso, MibIdentifier, Counter32, Integer32, enterprises, ModuleIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "ObjectIdentity", "TimeTicks", "IpAddress", "NotificationType", "iso", "MibIdentifier", "Counter32", "Integer32", "enterprises", "ModuleIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
david = MibIdentifier((1, 3, 6, 1, 4, 1, 66))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1))
davidExpressNet = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3))
exNetChassis = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3, 1))
exNetEthernet = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3, 2))
exNetConcentrator = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1))
exNetModule = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2))
exNetPort = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3))
exNetMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4))
exNetChassisType = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("m6102", 2), ("m6103", 3), ("m6310tel", 4), ("m6310rj", 5), ("m6318st", 6), ("m6318sma", 7), ("reserved", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetChassisType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetChassisType.setDescription('The chassis type (option).')
exNetChassisBkplType = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("expressNet", 2), ("reserved", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetChassisBkplType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetChassisBkplType.setDescription('The chassis backplane type (option).')
exNetChassisBkplRev = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetChassisBkplRev.setStatus('mandatory')
if mibBuilder.loadTexts: exNetChassisBkplRev.setDescription('The chassis backplane revision.')
exNetChassisPsType = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("standardXfmr", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetChassisPsType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetChassisPsType.setDescription('The chassis power supply type. This refers to the chassis transformer. Each module (including the Supervisor Module) has its own switching power supply.')
exNetChassisPsStatus = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetChassisPsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetChassisPsStatus.setDescription("The chassis power supply status. This refers t othe chassis transformer. Each module (including the Supervisor Module) has its own switching power supply. The status of the individual modules' power supplies is a module attribute.")
exNetSlotConfigTable = MibTable((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7), )
if mibBuilder.loadTexts: exNetSlotConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: exNetSlotConfigTable.setDescription('The chassis slot configuration table.')
exNetSlotConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7, 1), ).setIndexNames((0, "DAVID-MIB", "exNetSlotIndex"))
if mibBuilder.loadTexts: exNetSlotConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: exNetSlotConfigEntry.setDescription('Descriptions of the modules (or boards) in each slot.')
exNetSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: exNetSlotIndex.setDescription('The DAVID ExpressNet chassis slot number. Valid entries are 1 to exNetChassisCapacity. On the physical Concentrator boxes, the Supervisor Modules are not numbered and the plug-in modules are numbered from 1 to n-1, where n is the number of slots in the Concentrator. For the purposes of the DAVID ExpressNet SNMP MIB, the Supervisor Module is numbered one past the highest-numbered plug-in module. For example, in a 12-Slot Concentrator, the plug-in modules are numbered 1-11 and the Supervisor Module is numbered 12.')
exNetBoardId = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetBoardId.setStatus('mandatory')
if mibBuilder.loadTexts: exNetBoardId.setDescription('The unique hardware ID for the module.')
exNetBoardType = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("empty", 1), ("other", 2), ("m6203", 3), ("m6201", 4), ("m6311", 5), ("m6312", 6), ("m6313st", 7), ("m6313sma", 8), ("m6006", 9), ("reserved", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetBoardType.setDescription('The type of the module.')
exNetBoardDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetBoardDescr.setStatus('mandatory')
if mibBuilder.loadTexts: exNetBoardDescr.setDescription('Textual description of the module type.')
exNetBoardNumOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 7, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetBoardNumOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: exNetBoardNumOfPorts.setDescription('The number of ports supported by the plug-in module. For a 10BASE-T Module the value is 12; for an FOIRL Module, 6; for a Supervisor Module, 1.')
exNetChassisCapacity = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetChassisCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: exNetChassisCapacity.setDescription('The number of slots in the chassis for plug-in modules. This number will be either five or twelve for a Concentrator and two for a Hub.')
exNetConcRetimingStatus = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcRetimingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcRetimingStatus.setDescription('Indicates whether this repeater has retiming turned on. All DAVID ExpressNet repeaters implement retiming, so the value on(2) is always returned for this variable.')
exNetConcFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcFrmsRxOk.setDescription('A count of frames that are successfully received by the Concentrator. This counter does not include frames received with frame-too-long, runt, FCS, or alignment errors. This counter includes broadcast and multicast frames that are received.')
exNetConcOctetsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcOctetsRxOk.setDescription('A count of data and padding octets in frames that are successfully received by the concentrator. This counter does not include frames received with frame-too-long, runt, FCS, or alignment errors. This counter includes octets in broadcast and multicast frames that are received.')
exNetConcMcastFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcMcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcMcastFrmsRxOk.setDescription('A count of frames that are successfully received by the concentrator and are directed to an active non-broadcast group address. This counter does not include frames received with frame-too-long, runt, FCS, or alignment errors. Only frames that are for a multicast address that this interface is receiving are counted. Broadcast packets are not included.')
exNetConcBcastFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcBcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcBcastFrmsRxOk.setDescription('A count of frames that are successfully received by the concentrator and are directed to the broadcast group address. This counter does not include frames received with frame-too- long, runt, FCS, or alignment errors. Multicast packets are not included.')
exNetConcColls = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcColls.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcColls.setDescription('Total collisions involving an incoming packet on any port (link or Network Interface port) in the Concentrator. This counter increments once for each collision involving an incoming packet on any port, no matter how many ports are involved.')
exNetConcTooLongErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcTooLongErrors.setDescription('A count of frames that are received by the Concentrator and exceed the maximum permitted frame size.')
exNetConcRuntErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcRuntErrors.setDescription("Number of frames received by the Concentrator that have a correct preamble (including double 1), but are shorter than the minimum legal frame size of 64 bytes (512 bits). Runts are commonly collision fragments, and as such do not necessarily indicate a problem in the network. Runts are also known as 'short frames.'")
exNetConcFragErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcFragErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcFragErrors.setDescription("Fragments of packets, shorter than the minimum legal transmission size of 96 bits, that are received on the Concentrator. Fragments indicate an external noise hit (a problem on the network). Fragments are also known as 'pygmies.'")
exNetConcAlignErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcAlignErrors.setDescription('Number of frames received on the Concentrator that are byte-misaligned, such that the number of bits is not a multiple of 8. (These frames do not pass the frame check sequence check, but are not counted as FCS errors.)')
exNetConcFcsErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcFcsErrors.setDescription('A count of frames received by the Concentrator that are an integral number of octets in length and do not pass the frame check sequence (FCS) check. FCS errors are sometimes called CRC errors.')
exNetConcLateCollErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcLateCollErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcLateCollErrors.setDescription('A total Concentrator count of the late collisions. The late collision counter for a port is incremented whenever a collision is detected on the port later than 512 bit times into the transmitted packet. Late collisions are not included in the collision count.')
exNetConcName = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetConcName.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcName.setDescription('A descriptive string that can be used by a network administrator to name the Concentrator.')
exNetConcJabbers = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcJabbers.setDescription("A count of the number of times that the jabber function had to be invoked because a frame received from one of this Concentrator's ports exceeded 5 msec in duration.")
exNetConcSfdErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcSfdErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcSfdErrors.setDescription("Amount of activity from this Concentrator's ports where a double-zero is seen before the start-frame delimiter (double-1). (This could indicate a polarity problem.)")
exNetConcAutoPartitions = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcAutoPartitions.setDescription('Indicates how often ports on this Concentrator have been automatically partitioned by the Concentrator repeater function.')
exNetConcOosBitRate = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcOosBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcOosBitRate.setDescription('Number of times that frames have been received on the Concentrator with the transmission frequency (data rate) badly out of spec. This counter is incremented when the frequency of a received frame is so far out of spec that the packet has been corrupted within the relay. The spec allows deviations of +/- 100 parts per million (ppm). The DAVID ExpressNet Intelligent Concentrators can handle greater deviations than this, depending on frame length.')
exNetConcLinkErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcLinkErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcLinkErrors.setDescription('This composite counter includes jabbers, auto-partitions, and start-frame delimiter errors.')
exNetConcFrameErrors = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcFrameErrors.setDescription('This composite counter includes frame check sequence errors, fragments, short frames, long frames, and alignment errors.')
exNetConcNetUtilization = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 47), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcNetUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcNetUtilization.setDescription('A series of ten bytes, each indicating the percentage of bandwidth utilization for a 100-millisecond interval. Together they give the bandwidth utilization for the previous second.')
exNetConcResetTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 48), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetConcResetTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcResetTimeStamp.setDescription('The value of sysUpTime at the point that the Concentrator repeater state machine was last reset.')
exNetConcReset = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2), ("resetToDefault", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetConcReset.setStatus('mandatory')
if mibBuilder.loadTexts: exNetConcReset.setDescription("The reset state of the Concentrator's repeater state machine. Writing a 2 will reset the Concentrator's control logic, without changing the current configuration. Writing a 3 will reset the Concentrator to the initial factory default configuration.")
exNetModuleTable = MibTable((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1), )
if mibBuilder.loadTexts: exNetModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleTable.setDescription('A list of module entries. The number of entries is given by the number of modules that are obtained by the Concentrator Slot Configuration Table.')
exNetModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1), ).setIndexNames((0, "DAVID-MIB", "exNetModuleIndex"))
if mibBuilder.loadTexts: exNetModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleEntry.setDescription('A module entry containing objects at the module level for a particular module.')
exNetModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleIndex.setDescription("A unique value for each module. Its value ranges between 1 and exNetChassisCapacity. The value for each module must remain constant at least from one reinitialization of the entity's network management system to the next reinitialization. This value is tied to the hardware chassis slot number.")
exNetModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("empty", 1), ("other", 2), ("m6203", 3), ("m6201", 4), ("m6311", 5), ("m6312", 6), ("m6313st", 7), ("m6313sma", 8), ("m6006", 9), ("reserved", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleType.setDescription('The type of the module.')
exNetModuleHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleHwVer.setDescription('The hardware configuration of the module or hub. For model 6311, 6312, and 6313 board types, the type of Network Interface provided with the board is indicated by the following values (0-3 apply to ExpressNet Hubs; 7 is returned for Concentrator modules): 0 = AUI 1 = 10BASE2 2 = 10BASE-T 3 = FOIRL 7 = no interface')
exNetModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("noComms", 2), ("selfTestFail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleStatus.setDescription("The operational status of the module. If the status is selfTestFail(3), the exNetModuleSelfTestResult will give more detailed information about the module's condition.")
exNetModuleReset = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2), ("resetToDefault", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetModuleReset.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleReset.setDescription("The reset state of the module. Writing a 2 will reset the module's control logic, without changing the current configuration. Writing a 3 will reset the module to the initial factory default configuration.")
exNetModulePartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("partition", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetModulePartStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModulePartStatus.setDescription('Tells whether the module is partitioned or enabled. Writing a 2 will partition the module and 1 will enable the module.')
exNetModuleNmCntlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notNmControl", 1), ("nmControl", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleNmCntlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleNmCntlStatus.setDescription('Tells whether the module is under network management control. DAVID ExpressNet Concentrators always return nmControl(2), since all modules are always under network management control.')
exNetModulePsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModulePsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModulePsStatus.setDescription("The status of the module's power supply.")
exNetModuleFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleFrmsRxOk.setDescription('A count of frames that are successfully received by the module. This counter does not include frames received with frame-too-long, runt, FCS, or alignment errors. This counter includes broadcast and multicast frames that are received.')
exNetModuleOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleOctetsRxOk.setDescription('A count of data and padding octets in frames that are successfully received by the module. This counter does not include frames received with frame-too-long, runt, FCS, or alignment errors. This counter includes octets in broadcast and multicast frames that are received.')
exNetModuleColls = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleColls.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleColls.setDescription('Total collisions involving an incoming packet on any link or the backplane connector in the module. This counter increments once for each collision involving an incoming packet on any port, no matter how many ports are involved.')
exNetModuleTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleTooLongErrors.setDescription('A count of frames that are received by the module and exceed the maximum permitted frame size.')
exNetModuleRuntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleRuntErrors.setDescription("Number of frames received by the module that have a correct preamble (including double 1), but are shorter than the minimum legal frame size of 64 bytes (512 bits). Runts are commonly collision fragments, and as such do not necessarily indicate a problem in the network. Runts are also called 'short frames.'")
exNetModuleAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleAlignErrors.setDescription('Number of frames received by the module that are byte-misaligned, such that the number of bits is not a multiple of 8. (These frames do not pass the frame check sequence check, but are not counted as FCS errors.)')
exNetModuleFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleFcsErrors.setDescription('A count of frames received by the module that are an integral number of octets in length and do not pass the frame check sequence (FCS) check. FCS errors are sometimes called CRC errors.')
exNetModuleLateCollErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleLateCollErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleLateCollErrors.setDescription("A module count of the late collisions on all of the module's ports. The late collision counter for a port is incremented whenever a collision is detected on the port later than 512 bit times into the transmitted packet. Late collisions are not included in the collision count.")
exNetModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetModuleName.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleName.setDescription('A descriptive string that can be used by a network administrator to name the module.')
exNetModuleJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleJabbers.setDescription("A count of the number of times that the jabber function had to be invoked because a frame received from one of this module's ports exceeded 5 msec in duration.")
exNetModuleSfdErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleSfdErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleSfdErrors.setDescription("Amount of activity from this module's ports where a double-zero is seen before the start-frame delimiter (double-1). (This could indicate a polarity problem.)")
exNetModuleAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleAutoPartitions.setDescription('Indicates how often ports on this module have been automatically partitioned by the module repeater function.')
exNetModuleOosBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleOosBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleOosBitRate.setDescription('Number of times that frames have been received from ports on this module with the transmission frequency (data rate) badly out of spec. This counter is incremented when the frequency of a received frame is so far out of spec that the packet has been corrupted within the relay. The spec allows deviations of +/- 100 parts per million (ppm). The DAVID ExpressNet Concentrators can handle greater deviations than this, depending on frame length.')
exNetModuleLinkErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleLinkErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleLinkErrors.setDescription('This composite counter includes jabbers, auto-partitions, and start-frame delimiter errors.')
exNetModuleFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleFrameErrors.setDescription('This composite counter includes frame check sequence errors, fragments, short frames, long frames, and alignment errors.')
exNetModuleFragErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleFragErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleFragErrors.setDescription("Fragments of packets, shorter than the minimum legal transmission size of 96 bits, that are received on the module. Fragments indicate an external noise hit (a problem on the network). Fragments are also known as 'pygmies.'")
exNetModulePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetModulePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModulePortConfig.setDescription("Compresses the configuration of all of this module's ports into a two-byte integer value. Sums f(x) as x goes from 1 to number of ports, where f(x) = 0 for disabled port and f(x) = exp(2,x-1) for enabled port.")
exNetModuleLinkStatConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetModuleLinkStatConfig.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleLinkStatConfig.setDescription("Compresses the link status configuration of all of this module's ports into a two-byte integer value. Sums f(x) as x goes from 1 to number of ports, where f(x) = 0 for port with link status disabled and f(x) = exp(2,x-1) for port with link status enabled.")
exNetModuleResetTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 50), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleResetTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleResetTimeStamp.setDescription('The value of sysUpTime at the point that the module repeater state machine was last reset.')
exNetModuleLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleLinkStatus.setDescription("Compresses the link status of all of this module's ports into a two-byte integer value. Sums f(x) as x goes from 1 to number of ports, where f(x) = 0 for port with link status test passed (link active) and f(x) = exp(2,x-1) for port with link status test failed (link inactive). For ports with link status test disabled, zero is returned. For example, if link status is active on all ports, the value returned is zero. If link status for ports 3 and 7 is inactive and the rest of the ports have active link status, the value returned is (2^(3-1) + 2^(7-1)) = (4 + 64) = 68.")
exNetModuleFwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleFwVer.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleFwVer.setDescription('The firmware revision of the GAP processor on the module.')
exNetModuleFwFeaturePkg = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleFwFeaturePkg.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleFwFeaturePkg.setDescription('The feature package associated with the GAP processor on the module.')
exNetModuleSelfTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 2, 1, 1, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetModuleSelfTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: exNetModuleSelfTestResult.setDescription('The self-test result value returned by the GAP processor on the module. Zero indicates that the module passed all tests. Bits set in the result indicate error conditions, as follows: Bit number Error encountered 0 ROM failure 1 CPU failure 2 RAM failure 3 repeater module failure 4 reserved 5 internal power (-5v) failure 6 NI power fuse (+12v) failure')
exNetPortTable = MibTable((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1), )
if mibBuilder.loadTexts: exNetPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortTable.setDescription('A list of port entries. The number of entries is given by knowing the number of occupied slots in the exNetSlotConfigTable and the number of ports that are on an exNetModuleType.')
exNetPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1), ).setIndexNames((0, "DAVID-MIB", "exNetPortModuleIndex"), (0, "DAVID-MIB", "exNetPortIndex"))
if mibBuilder.loadTexts: exNetPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortEntry.setDescription('A port entry containing objects at the port level for a particular port.')
exNetPortModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortModuleIndex.setDescription('A unique value for each module. Its value ranges between 1 and exNetChassisCapacity.')
exNetPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortIndex.setDescription('A unique value for each port. Its value ranges between 1 and the value of exNetBoardNumOfPorts for this module.')
exNetPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortLinkStatus.setDescription('For 10BASE-T ports: this is the link integrity test defined by the 10BASE-T standard. If link status test is enabled, this flag indicates whether the link is active or inactive. There are several reasons for an inactive link: . PC or workstation connected to the MAU has been turned off . disrupted link (e.g., wiring problem) . TP-MAU on the end of the link is missing, dead, or powered off . transmit and receive polarities are swapped For FOIRL ports: the link status is constantly tested; thus, this variable is always meaningful. A value of off(1) indicates a low-light condition (poor signal quality). The value on(2) indicates that signal quality on the link is ok. For AUI ports: the value other(3) is always returned since link status test does not apply.')
exNetPortPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("partition", 2), ("autoPartition", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetPortPartStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortPartStatus.setDescription("Indicates whether the port is currently partitioned by the Concentrator's auto-partition protection. (The Concentrator automatically partitions a port if it is signalling continuous collision, or 32 consecutive collisions.) Writing a 1 will forcibly unpartition the port. Writing a 2 or a 3 is illegal. To enable or disable the port, use the exNetPortConfig variable.")
exNetPortJabberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("jabbering", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortJabberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortJabberStatus.setDescription('Tells whether the DTE connected to the port is jabbering (receiving a frame longer than 5 msec in duration).')
exNetPortFrmsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortFrmsRxOk.setDescription('A count of frames that are successfully received by the port. This counter does not include frames received with frame-too- long, runt, FCS, or alignment errors. This counter includes broadcast and multicast frames that are received.')
exNetPortOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortOctetsRxOk.setDescription('A count of data and padding octets in frames that are successfully received by the port. This counter does not include frames received with frame-too-long, runt, FCS, or alignment errors. This counter includes octets in broadcast and multicast frames that are received.')
exNetPortColls = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortColls.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortColls.setDescription('Number of times this port was involved in a collision with another port in the same Hub.')
exNetPortTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortTooLongErrors.setDescription('A count of frames that are received by the port and exceed the maximum permitted frame size.')
exNetPortRuntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortRuntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortRuntErrors.setDescription("Number of frames received by the port that have a correct preamble (including double 1), but are shorter than the minimum legal frame size of 64 bytes (512 bits). Runts are commonly collision fragments, and as such do not necessarily indicate a problem in the network. Runts are also called 'short frames.'")
exNetPortAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortAlignErrors.setDescription('Number of frames received by the port that are byte-misaligned, such that the number of bits is not a multiple of 8. (These frames do not pass the frame check sequence check, but are not counted as FCS errors.)')
exNetPortFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortFcsErrors.setDescription('A count of frames received by the port that are an integral number of octets in length and do not pass the frame check sequence (FCS) check. This counter is incremented when the frameCheckError status is detected. FCS errors are sometimes called CRC errors.')
exNetPortLateCollErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortLateCollErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortLateCollErrors.setDescription('Number of times that a collision has been detected on this port later than 512 bit times into the transmitted packet. Late collisions are not included in the collision count.')
exNetPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetPortName.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortName.setDescription('A descriptive string that can be used by a network administrator to name the port.')
exNetPortJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortJabbers.setDescription('A count of the number of times that the jabber function had to be invoked because a frame received from this port exceeded 5 msec in duration.')
exNetPortSfdErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortSfdErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortSfdErrors.setDescription('Amount of activity from this port where a double-zero is seen before the start-frame delimiter (double-1). (This could indicate a polarity problem.)')
exNetPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortAutoPartitions.setDescription('Indicates how often this port has been automatically partitioned by the module repeater function.')
exNetPortOosBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortOosBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortOosBitRate.setDescription('Number of times that frames have been received from this link with the transmission frequency (data rate) badly out of spec. This counter is incremented when the frequency of a received frame is so far out of spec that the packet has been corrupted within the relay. The spec allows deviations of +/- 100 parts per million (ppm). The DAVID ExpressNet Concentrators can handle greater deviations than this, depending on frame length.')
exNetPortLinkErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortLinkErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortLinkErrors.setDescription('This composite counter includes jabbers, auto-partitions, late collisions, start-frame delimiter errors, and out-of-spec bit rate errors.')
exNetPortFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortFrameErrors.setDescription('This composite counter includes frame check sequence errors, fragments, short frames, long frames, and alignment errors.')
exNetPortFragErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortFragErrors.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortFragErrors.setDescription('Fragments of packets, shorter than the minimum legal transmission size of 96 bits, that are received on this port. Fragments indicate an external noise hit (a problem on the network).')
exNetPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("repeater", 2), ("tenBasefAsync", 3), ("tenBasefSync", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortType.setDescription('The type of the port.')
exNetPortMauType = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("tenBase5", 2), ("tenBaseT", 3), ("fOIRL", 4), ("tenBase2", 5), ("tenBaseFA", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetPortMauType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortMauType.setDescription('The type of the MAU attached to the port.')
exNetPortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3), ("txDisabled", 4), ("rxDisabled", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetPortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortConfig.setDescription('The administrative state of the port. If both transmit and receive are enabled, the port state is enabled. If both transmit and receive are disabled, the port state is disabled.')
exNetPortLinkStatConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3), ("txDisabled", 4), ("rxDisabled", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetPortLinkStatConfig.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortLinkStatConfig.setDescription('The administrative status of the link status test for this link. If both transmit and receive are enabled, the link status test is enabled. If both transmit and receive are disabled, the link status test is disabled. This variable applies only to ports with MauType = 10BASE-T. The value other(1) is returned for other MAU types.')
exNetPortPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("positive", 2), ("negative", 3), ("txNegative", 4), ("rxNegative", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetPortPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortPolarity.setDescription('The polarity of the port. Applies only to ports with MAU type 10BASE-T. The value other(1) is returned for other MAU types.')
exNetPortTransmitTest = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 3, 1, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetPortTransmitTest.setStatus('mandatory')
if mibBuilder.loadTexts: exNetPortTransmitTest.setDescription('Whether or not transmit test is enabled on the link. Transmit test applies only to links of type 10BASE-T. The value other(1) is returned for other MAU types. THIS TEST CAN BE DISRUPTIVE TO THE NETWORK.')
exNetMgmtType = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("tbd", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtType.setDescription('The DAVID ExpressNet Ethernet network management type.')
exNetMgmtHwVer = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtHwVer.setDescription('The network management ICM hardware version number: 1=Rev. A, 2=Rev. B, etc.')
exNetMgmtFwVer = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtFwVer.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtFwVer.setDescription('The network management ICP firmware version.')
exNetMgmtSwMajorVer = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtSwMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtSwMajorVer.setDescription('The network management major software version number, where the version number is of the form major.minor, e.g. 3.0. Refers to the ECP (External Communications Processor).')
exNetMgmtSwMinorVer = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtSwMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtSwMinorVer.setDescription('The network management minor software version number, where the version number is of the form major.minor, e.g. 3.0. Refers to the ECP.')
exNetMgmtStatus = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offline", 1), ("online", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtStatus.setDescription('Indicates that the network management is on line and operating. For the DAVID ExpressNet Concentrators, management status is always online(2).')
exNetMgmtMode = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtMode.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtMode.setDescription('Indicates whether the network management is operating in primary or secondary mode. Presently, all DAVID ExpressNet Concentrators return primary(1).')
exNetMgmtReset = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtReset.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtReset.setDescription('Network management reset status. Writing a 2 to this object will reset the network management (stop refreshing the watchdog timer) and restart.')
exNetMgmtRestart = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notRestart", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtRestart.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtRestart.setDescription('Network management restart status. Writing a 2 to this object will restart the network management. This initializes all the counters, rereads the EEPROM data structure, and starts executing from the beginning of the code.')
exNetMgmtIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtIpAddr.setDescription("The network management's administrative IP address. This parameter will take effect ONLY after a restart (exNetMgmtRestart) or reset (exNetMgmtReset) is issued. At that time it becomes the operational IP address. The value of the CURRENT operational IP address can be obtained from the ipAdEntAddr entry in the ipAddrTable.")
exNetMgmtNetMask = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtNetMask.setDescription("The network management's administrative subnet mask. This parameter will take effect ONLY after a restart (exNetMgmtRestart) or reset (exNetMgmtReset) is issued. At that time it becomes the operational subnet mask. The value of the CURRENT operational subnet mask can be obtained from the ipAdEntNetMask entry in the ipAddrTable.")
exNetMgmtDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtDefaultGateway.setDescription("The network management's administrative default gateway IP address. This parameter will take effect ONLY after a restart (exNetMgmtRestart) or reset (exNetMgmtReset) is issued. At that time it becomes the operational default gateway IP address. The value of the CURRENT operational default gateway's IP address can be obtained from the ipRoutingTable.")
exNetMgmtBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: exNetMgmtBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtBaudRate.setDescription('Returns the baud rate in bits per second of the RS-232 port. Note: The Concentrators autobaud to match the device attached to the RS-232 port.')
exNetMgmtLocation = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 19), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtLocation.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtLocation.setDescription('This is an informational string that could be used to show the physical location (i.e., area) of the network management or Concentrator. This parameter is saved in non-volatile memory and will survive a reset. Note: This variable is aliased to the sysLocation variable in the MIB-II system group. Changing one will change the other. It is suggested that the system group variable be used whenever possible.')
exNetMgmtTrapReceiverTable = MibTable((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 20), )
if mibBuilder.loadTexts: exNetMgmtTrapReceiverTable.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtTrapReceiverTable.setDescription("This entity's Trap Receiver Table (10 entries).")
exNetMgmtTrapReceiverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 20, 1), ).setIndexNames((0, "DAVID-MIB", "exNetMgmtTrapReceiverAddr"))
if mibBuilder.loadTexts: exNetMgmtTrapReceiverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtTrapReceiverEntry.setDescription('A destination address and community string to a particular trap receiver.')
exNetMgmtTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtTrapType.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtTrapType.setDescription('Setting this object to the value invalid(2) invalidates the corresponding entry in the exNetTrapReceiverTable. That is, it effectively disassociates the address identified with the entry by removing the entry from the table.')
exNetMgmtTrapReceiverAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 20, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtTrapReceiverAddr.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtTrapReceiverAddr.setDescription('IP address for trap receiver.')
exNetMgmtTrapReceiverComm = MibTableColumn((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 20, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtTrapReceiverComm.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtTrapReceiverComm.setDescription('Community string used for traps.')
exNetMgmtAuthTrap = MibScalar((1, 3, 6, 1, 4, 1, 66, 1, 3, 2, 4, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: exNetMgmtAuthTrap.setStatus('mandatory')
if mibBuilder.loadTexts: exNetMgmtAuthTrap.setDescription('Enable or disable the use of authentication error trap generation.')
mibBuilder.exportSymbols("DAVID-MIB", exNetConcOosBitRate=exNetConcOosBitRate, exNetPortColls=exNetPortColls, exNetModuleColls=exNetModuleColls, exNetMgmtDefaultGateway=exNetMgmtDefaultGateway, exNetConcLateCollErrors=exNetConcLateCollErrors, exNetMgmtSwMinorVer=exNetMgmtSwMinorVer, exNetBoardDescr=exNetBoardDescr, exNetConcFrmsRxOk=exNetConcFrmsRxOk, exNetModuleFragErrors=exNetModuleFragErrors, exNetPortFragErrors=exNetPortFragErrors, exNetPortType=exNetPortType, exNetConcSfdErrors=exNetConcSfdErrors, exNetMgmtTrapType=exNetMgmtTrapType, exNetEthernet=exNetEthernet, exNetPortConfig=exNetPortConfig, exNetPortRuntErrors=exNetPortRuntErrors, exNetPortAlignErrors=exNetPortAlignErrors, exNetMgmtTrapReceiverEntry=exNetMgmtTrapReceiverEntry, exNetMgmtHwVer=exNetMgmtHwVer, exNetConcAutoPartitions=exNetConcAutoPartitions, exNetSlotConfigEntry=exNetSlotConfigEntry, exNetModule=exNetModule, exNetModuleFwVer=exNetModuleFwVer, exNetChassisType=exNetChassisType, exNetBoardType=exNetBoardType, exNetPortLinkErrors=exNetPortLinkErrors, exNetConcNetUtilization=exNetConcNetUtilization, exNetConcRetimingStatus=exNetConcRetimingStatus, exNetConcBcastFrmsRxOk=exNetConcBcastFrmsRxOk, exNetModuleType=exNetModuleType, exNetModulePartStatus=exNetModulePartStatus, exNetModulePsStatus=exNetModulePsStatus, exNetSlotIndex=exNetSlotIndex, exNetPortSfdErrors=exNetPortSfdErrors, exNetPortLinkStatus=exNetPortLinkStatus, exNetMgmtStatus=exNetMgmtStatus, exNetConcOctetsRxOk=exNetConcOctetsRxOk, exNetMgmtTrapReceiverTable=exNetMgmtTrapReceiverTable, exNetMgmtIpAddr=exNetMgmtIpAddr, exNetConcResetTimeStamp=exNetConcResetTimeStamp, exNetChassisPsStatus=exNetChassisPsStatus, exNetChassis=exNetChassis, exNetMgmtFwVer=exNetMgmtFwVer, exNetPortLateCollErrors=exNetPortLateCollErrors, exNetChassisBkplType=exNetChassisBkplType, exNetModuleFwFeaturePkg=exNetModuleFwFeaturePkg, exNetModuleEntry=exNetModuleEntry, exNetModuleStatus=exNetModuleStatus, exNetBoardId=exNetBoardId, exNetModuleAlignErrors=exNetModuleAlignErrors, exNetConcRuntErrors=exNetConcRuntErrors, exNetPortTransmitTest=exNetPortTransmitTest, exNetModuleIndex=exNetModuleIndex, exNetPortName=exNetPortName, exNetChassisBkplRev=exNetChassisBkplRev, exNetModuleTooLongErrors=exNetModuleTooLongErrors, exNetModuleHwVer=exNetModuleHwVer, exNetPortModuleIndex=exNetPortModuleIndex, exNetPortFcsErrors=exNetPortFcsErrors, exNetModuleLinkErrors=exNetModuleLinkErrors, exNetConcName=exNetConcName, exNetPortTable=exNetPortTable, exNetBoardNumOfPorts=exNetBoardNumOfPorts, exNetMgmtTrapReceiverAddr=exNetMgmtTrapReceiverAddr, exNetMgmtReset=exNetMgmtReset, exNetPortMauType=exNetPortMauType, exNetConcLinkErrors=exNetConcLinkErrors, exNetModuleLinkStatus=exNetModuleLinkStatus, exNetConcFragErrors=exNetConcFragErrors, exNetConcJabbers=exNetConcJabbers, exNetModuleResetTimeStamp=exNetModuleResetTimeStamp, exNetMgmtLocation=exNetMgmtLocation, exNetModuleOctetsRxOk=exNetModuleOctetsRxOk, exNetModulePortConfig=exNetModulePortConfig, exNetMgmtTrapReceiverComm=exNetMgmtTrapReceiverComm, exNetModuleRuntErrors=exNetModuleRuntErrors, exNetModuleFrameErrors=exNetModuleFrameErrors, exNetMgmtMode=exNetMgmtMode, exNetMgmtNetMask=exNetMgmtNetMask, exNetConcFcsErrors=exNetConcFcsErrors, exNetChassisPsType=exNetChassisPsType, exNetPortOctetsRxOk=exNetPortOctetsRxOk, exNetConcColls=exNetConcColls, exNetMgmtSwMajorVer=exNetMgmtSwMajorVer, exNetModuleReset=exNetModuleReset, exNetModuleLateCollErrors=exNetModuleLateCollErrors, exNetMgmt=exNetMgmt, exNetPortAutoPartitions=exNetPortAutoPartitions, exNetMgmtAuthTrap=exNetMgmtAuthTrap, exNetConcAlignErrors=exNetConcAlignErrors, exNetModuleName=exNetModuleName, david=david, exNetPortJabberStatus=exNetPortJabberStatus, exNetConcFrameErrors=exNetConcFrameErrors, exNetMgmtType=exNetMgmtType, exNetPortEntry=exNetPortEntry, exNetModuleFcsErrors=exNetModuleFcsErrors, exNetMgmtBaudRate=exNetMgmtBaudRate, exNetPortTooLongErrors=exNetPortTooLongErrors, exNetPort=exNetPort, exNetConcReset=exNetConcReset, exNetConcMcastFrmsRxOk=exNetConcMcastFrmsRxOk, exNetPortPartStatus=exNetPortPartStatus, exNetPortPolarity=exNetPortPolarity, exNetPortLinkStatConfig=exNetPortLinkStatConfig, exNetSlotConfigTable=exNetSlotConfigTable, exNetPortFrmsRxOk=exNetPortFrmsRxOk, products=products, exNetModuleOosBitRate=exNetModuleOosBitRate, exNetModuleFrmsRxOk=exNetModuleFrmsRxOk, exNetPortOosBitRate=exNetPortOosBitRate, exNetPortJabbers=exNetPortJabbers, exNetConcentrator=exNetConcentrator, exNetModuleSfdErrors=exNetModuleSfdErrors, exNetMgmtRestart=exNetMgmtRestart, exNetConcTooLongErrors=exNetConcTooLongErrors, exNetModuleSelfTestResult=exNetModuleSelfTestResult, exNetPortIndex=exNetPortIndex, exNetModuleLinkStatConfig=exNetModuleLinkStatConfig, exNetModuleJabbers=exNetModuleJabbers, davidExpressNet=davidExpressNet, exNetChassisCapacity=exNetChassisCapacity, exNetPortFrameErrors=exNetPortFrameErrors, exNetModuleNmCntlStatus=exNetModuleNmCntlStatus, exNetModuleTable=exNetModuleTable, exNetModuleAutoPartitions=exNetModuleAutoPartitions)

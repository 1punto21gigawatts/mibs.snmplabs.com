#
# PySNMP MIB module LaserJet_3300-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LaserJet_3300-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:09:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Integer32, ModuleIdentity, TimeTicks, Unsigned32, Counter32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, NotificationType, Gauge32, MibIdentifier, iso, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "ModuleIdentity", "TimeTicks", "Unsigned32", "Counter32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "NotificationType", "Gauge32", "MibIdentifier", "iso", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
dm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2))
class DisplayString(OctetString):
    pass

device = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1))
settings_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1)).setLabel("settings-system")
copier = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5))
settings_copier = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1)).setLabel("settings-copier")
status_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2)).setLabel("status-system")
id = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3))
job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6))
settings_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1)).setLabel("settings-job")
fax_job_control = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3)).setLabel("fax-job-control")
settings_fax_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 1)).setLabel("settings-fax-job")
status_fax_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 2)).setLabel("status-fax-job")
faxjob = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3))
faxjob_rx_status = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 1)).setLabel("faxjob-rx-status")
faxjob_tx_status = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 3)).setLabel("faxjob-tx-status")
faxjob_tx_error = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 4)).setLabel("faxjob-tx-error")
faxjob_tx_current_page = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 5)).setLabel("faxjob-tx-current-page")
faxjob_rx_current_page = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 6)).setLabel("faxjob-rx-current-page")
faxjob_rx_duration = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 7)).setLabel("faxjob-rx-duration")
faxjob_tx_duration = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 8)).setLabel("faxjob-tx-duration")
fax_activity_log = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 4)).setLabel("fax-activity-log")
settings_faxlog = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 4, 1)).setLabel("settings-faxlog")
phone = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9))
dial = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 1))
dial_all_lines = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 1, 1)).setLabel("dial-all-lines")
answer = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 2))
answer_all_lines = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 2, 1)).setLabel("answer-all-lines")
source_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2)).setLabel("source-subsystem")
fax_receive = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 3)).setLabel("fax-receive")
settings_fax_receive = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 3, 1)).setLabel("settings-fax-receive")
status_fax_receive = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 3, 2)).setLabel("status-fax-receive")
processing_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3)).setLabel("processing-subsystem")
fax_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7)).setLabel("fax-proc-sub")
settings_fax_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1)).setLabel("settings-fax-proc-sub")
status_fax_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2)).setLabel("status-fax-proc-sub")
fax_forwarding = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 3)).setLabel("fax-forwarding")
destination_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4)).setLabel("destination-subsystem")
fax_send = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2)).setLabel("fax-send")
settings_fax_send = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 1)).setLabel("settings-fax-send")
status_fax_send = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 2)).setLabel("status-fax-send")
transmit_fax = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 5)).setLabel("transmit-fax")
hrm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3))
hrStorage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2))
hrStorageTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3))
hrStorageEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1))
hrDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3))
hrDeviceTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2))
hrDeviceEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1))
hrPrinterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5))
hrPrinterEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4))
simm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1))
simm1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1))
test = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5))
active_print_jobs = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2)).setLabel("active-print-jobs")
job_being_parsed = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1)).setLabel("job-being-parsed")
job_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5)).setLabel("job-info")
job_info_attribute = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23)).setLabel("job-info-attribute")
errorlog = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11))
error1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1))
error2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2))
error3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3))
error4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4))
error5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5))
error6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6))
error7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7))
error8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8))
error9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9))
error10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10))
io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1))
settings_io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1)).setLabel("settings-io")
pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3))
settings_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1)).setLabel("settings-pdl")
status_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2)).setLabel("status-pdl")
pdl_pcl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3)).setLabel("pdl-pcl")
pjl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 5))
print_engine = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1)).setLabel("print-engine")
settings_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1)).setLabel("settings-prt-eng")
status_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2)).setLabel("status-prt-eng")
intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3))
settings_intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1)).setLabel("settings-intray")
intrays = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3))
intray1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1))
imaging = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6))
tables = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7))
channel_table = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2)).setLabel("channel-table")
channel_entry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1)).setLabel("channel-entry")
scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2))
settings_scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1)).setLabel("settings-scanner")
scan_calibration = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 32)).setLabel("scan-calibration")
status_scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2)).setLabel("status-scanner")
printmib = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2))
prtGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5))
prtGeneralTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1))
prtGeneralEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1))
prtCover = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6))
prtCoverTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1))
prtCoverEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1))
prtLocalization = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7))
prtLocalizationTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1))
prtLocalizationEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1))
prtStorageRefTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2))
prtStorageRefEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2, 1))
prtDeviceRefTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3))
prtDeviceRefEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3, 1))
prtInput = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8))
prtInputTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2))
prtInputEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1))
prtOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9))
prtOutputTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2))
prtOutputEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1))
prtMarker = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10))
prtMarkerTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2))
prtMarkerEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1))
prtMarkerSupplies = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11))
prtMarkerSuppliesTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1))
prtMarkerSuppliesEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1))
prtMediaPath = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13))
prtMediaPathTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4))
prtMediaPathEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1))
prtChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14))
prtChannelTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1))
prtChannelEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1))
prtInterpreter = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15))
prtInterpreterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1))
prtInterpreterEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1))
prtConsoleDisplayBuffer = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16))
prtConsoleDisplayBufferTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5))
prtConsoleDisplayBufferEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5, 1))
prtConsoleLights = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17))
prtConsoleLightTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6))
prtConsoleLightEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1))
prtAlert = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18))
prtAlertTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1))
prtAlertEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1))
copier_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setLabel("copier-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_token.setStatus('optional')
if mibBuilder.loadTexts: copier_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to a copier device. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on COPIER-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing copier objects, and 2) releasing the lock when done changing copier objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on COPY-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing copy objects, and 2) releasing the lock when done changing copy objects.')
copier_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("copier-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_contrast.setStatus('optional')
if mibBuilder.loadTexts: copier_contrast.setDescription("Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the copier contrast level. Range is 0..100. Additional information: Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the copier contrast level. Contrast values can range from -127 to +127, for a total of 255 contrast levels. A positive value results in a larger difference, and a negative value results in a smaller difference. We support the values -125, -100, -75, -50, -25, 0, 25, 50, 75, 100, 125. We will map by snapping toward 0, to the closest device dependent value if some other value is given. ")
copier_reduction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 400))).setLabel("copier-reduction").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_reduction.setStatus('optional')
if mibBuilder.loadTexts: copier_reduction.setDescription('Percentage reduction desired for the copier. A value less than or equal to zero is invalid. A value greater than 100 accomplishes magnification. A device is allowed to support a set of values (documented in its POS), instead of the full range. <OKNearestLegalValueUsed> will be returned for unsupported values greater than zero. Additional information: Percentage reduction desired for the copier. A value less than or equal to zero is invalid. A value greater than 100 accomplishes magnification. A device is allowed to support a set of values (documented in its POS), instead of the full range. <OKNearestLegalValueUsed> will be returned for unsupported valuesgreater than zero. Our default of 100 means no scaling')
copier_num_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setLabel("copier-num-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_num_copies.setStatus('optional')
if mibBuilder.loadTexts: copier_num_copies.setDescription('Returns or changes the number of copies to be printed in the next Host requested copy operation. Additional information: Returns or changes the number of copies to be printed in the next Host requested copy operation.')
copier_collation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eCollateDisabled", 1), ("eCollateForward", 2)))).setLabel("copier-collation").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_collation.setStatus('optional')
if mibBuilder.loadTexts: copier_collation.setDescription('Enables the device with local copier capability that also supports outputting multiple copies of a multi- paged source document to print in a collated fashion. eCollateDisabled - The collating feature of the copier device is not to be performed on subsequent copier operation. eCollateForward - Copier device is to print multiple copies of the input document in such a way that the printed output order matches the source document. eCollateReverse - Copier device is to print multiple copies of the input document such that the order of the printed output is in reverse order of the source document. Additional information: Enables the device with local copier capability that also supports outputting multiple copies of a multi- paged source document to print in a collated fashion. eCollateDisabled - The collating feature of the copier device is not to be performed on subsequent copier operation. eCollateForward - Copier device is to print multiple copies of the input document in such a way that the printed output order matches the source document.')
copier_enlargement_maximum = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 11), Integer32()).setLabel("copier-enlargement-maximum").setMaxAccess("readonly")
if mibBuilder.loadTexts: copier_enlargement_maximum.setStatus('optional')
if mibBuilder.loadTexts: copier_enlargement_maximum.setDescription('Maximum value that the host may set COPIER-REDUCTION to. A value less than or equal to zero is invalid. Additional information: Maximum value that the host may set COPIER-REDUCTION or COPIER-JOB-REDUCTION to. A value less than or equal to zero is invalid.')
copier_reduction_maximum = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 12), Integer32()).setLabel("copier-reduction-maximum").setMaxAccess("readonly")
if mibBuilder.loadTexts: copier_reduction_maximum.setStatus('optional')
if mibBuilder.loadTexts: copier_reduction_maximum.setDescription('Minimum value that the host may set COPIER-REDUCTION to. A value less than or equal to zero is invalid. Additional information: Minimum value that the host may set COPIER-REDUCTION or COPIER-JOB-REDUCTION to. A value less than or equal to zero is invalid.')
copier_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eCopierQualityFast", 1), ("eCopierQualityNormal", 2), ("eCopierQualityPresentation", 3), ("eCopierQualityDraft", 4), ("eCopierQualityBest", 5)))).setLabel("copier-quality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_quality.setStatus('optional')
if mibBuilder.loadTexts: copier_quality.setDescription('Returns or sets the copier quality. This value is stored in NVRAM, hence the value is saved over power cycles. Additional information: This value is stored in NVRAM, hence the value is saved over power cycles. eCopierQualityFast is mapped to eCopierQualityNormal.')
copier_adf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 19), Integer32()).setLabel("copier-adf-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_adf_page_count.setStatus('optional')
if mibBuilder.loadTexts: copier_adf_page_count.setDescription('This object tracks the page count for the pages scanned for copying through the ADF. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for pages scanned for copying through the ADF. This value is stored in the device NVRAM.')
copier_print_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 20), Integer32()).setLabel("copier-print-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_print_page_count.setStatus('optional')
if mibBuilder.loadTexts: copier_print_page_count.setDescription('This object tracks the page count for the pages sent to the print engine, for copy jobs. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for pages sent to the print engine, for copy jobs. This value is stored in the device NVRAM.')
copier_job_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eUSLegal", 3), ("eISOandJISA4", 26)))).setLabel("copier-job-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_media_size.setStatus('optional')
if mibBuilder.loadTexts: copier_job_media_size.setDescription('The user can set a copy job setting for paper size using the COPIER-JOB-MEDIA-SIZE object, which is independent of other functions in the device. The device behavior when the scanned media and or print media do not match the value of this object should be documented in the device POS. Additional information: The default size for imaging a copy is determined by reading the common device default paper size object. The default for copy size cannot be changed independently of other functions like fax and print. The device will scan and format the print data based on the value of this object.')
copier_job_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eCopierQualityFast", 1), ("eCopierQualityNormal", 2), ("eCopierQualityPresentation", 3), ("eCopierQualityDraft", 4), ("eCopierQualityBest", 5)))).setLabel("copier-job-quality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_quality.setStatus('optional')
if mibBuilder.loadTexts: copier_job_quality.setDescription('Returns or sets the copier quality. Additional information: Returns or sets the copier quality. eCopierQualityFast is supported but gets mapped to normal.')
copier_job_collation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eCollateDisabled", 1), ("eCollateForward", 2)))).setLabel("copier-job-collation").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_collation.setStatus('optional')
if mibBuilder.loadTexts: copier_job_collation.setDescription('Enables the device with local copier capability that also supports outputting multiple copies of a multi-paged source document to print in a collated fashion. eCollateDisabled - The collating feature of the copier device is not be performed on subsequent copier operation. eCollateForward - Copier device is to print multiple copies of the input document in such a way that the printed output order matches the source document. eCollateReverse - Copier device is to print multiple copies of the input document such that the order of the printed output is in reverse order of the source document. ')
copier_job_num_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setLabel("copier-job-num-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_num_copies.setStatus('optional')
if mibBuilder.loadTexts: copier_job_num_copies.setDescription('Returns or changes the number of copies to be printed in the next Host requested copy operation.')
copier_job_reduction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 400))).setLabel("copier-job-reduction").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_reduction.setStatus('optional')
if mibBuilder.loadTexts: copier_job_reduction.setDescription('Percentage reduction desired for the copier. A device is allowed to support a set of values (documented in its POS), instead of the full range. <OKNearesetLegalValueUsed> will be returned for unsupported values. Additional information: A value less than or equal to zero is invalid. A value greater than 100 accomplishes magnification. <OKNearestLegalValueUsed> will be returned for unsupported valuesgreater than zero. (default = 100 = no scaling).')
copier_job_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("copier-job-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_contrast.setStatus('optional')
if mibBuilder.loadTexts: copier_job_contrast.setDescription("Used to set the copier contrast level. Additional information: Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the copier contrast level. Contrast values can range from --127 to +127, for a total of 255 contrast levels. The default contrast level is 0 (normal). A positive value results in a larger difference, and a negative value results in a smaller difference. We support values of -125, -100, -75, -50, -25, 0, 25, 50, 75, 100, 125. The range of values we support is spread over a range such that a software product would support the standard spec, and we would map by snapping toward 0 to the closest device dependent value.")
copier_job = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eCopierIdle", 1), ("eCopierStart", 2), ("eCopierActive", 3), ("eCopierAborting", 4), ("eCopierSetup", 5)))).setLabel("copier-job").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job.setStatus('optional')
if mibBuilder.loadTexts: copier_job.setDescription('Controls initiating and canceling a copy job. Additional information: Controls initiating and canceling a copy job. eCopierIdle - indicates that a copy function is not in progress. - Device sets to this state from eCopierActive to signal successful completion of copy operation. - Device sets to this state from eCopierAborting to signal successful cancel of copy operation. - Device sets to this state from eCopierStart to signal that the device is busy and cannot perform a copy operation. - Host sets to this state to indicate it wants to cancel the job. Device will abort the job. eCopierSetup - indicates the host wants to set up job settings for a copy job. Host sets to this state to then access copier job settings objects. Device does not set to this state. Object can only transition to this state from eCopierIdle. eCopierStart - This state is set by host to request copy function initiation. Object can only transition to this state from eCopierSetup. To specify job settings host has to set to Setup first, send settings, then set to Start. Device should not set to this state. eCopierActive - indicates the copy function is in progress. Device sets this state if the activity was started through front panel or if host request was successfully initiated. Host should not set to this state. eCopierAborting - Set by device to indicate copy function was prematurely terminated, either by an error, or user canceled by pressing cancel button on device. Device stays in this state until abort is complete, then moves to eCopierIdle. Host cannot set to this state, host sets to eCopierIdle to indicate it want to cancel the job. - Device powers up in eCopierIdle. ')
copier_flatbed_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 44), Integer32()).setLabel("copier-flatbed-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_flatbed_page_count.setStatus('optional')
if mibBuilder.loadTexts: copier_flatbed_page_count.setDescription('This object tracks the page count for the pages scanned for copying from the flatbed. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for pages scanned for copying from the flatbed. This value is stored in the device NVRAM.')
copier_pages_per_sheet = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ePagesPerSheet1", 1), ("ePagesPerSheet2", 2), ("ePagesPerSheet4", 3)))).setLabel("copier-pages-per-sheet").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_pages_per_sheet.setStatus('optional')
if mibBuilder.loadTexts: copier_pages_per_sheet.setDescription('Returns or sets the copier number of input pages per output sheet. This is also known as nup. This value is stored in NVRAM, hence the value is saved over power cycles. Additional information: Enables the device with local copier capability that also supports outputting multiple copies of a multi- paged source document to print multiple input sheets onto a single output sheet. ePagesPerSheet_1: A single input image is placed on a single output sheet. This basically has no affect. ePagesPerSheet_2: Two input images are placed on a single output sheet, in landscape format. ePagesPerSheet_4: Four input images are placed on a single output sheet, in portrait format. NOTE: The Pages Per Sheet feature will only be supported on devices with an ADF. If no ADF is present, then changes to this object will not be allowed.')
copier_job_pages_per_sheet = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ePagesPerSheet1", 1), ("ePagesPerSheet2", 2), ("ePagesPerSheet4", 3)))).setLabel("copier-job-pages-per-sheet").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_pages_per_sheet.setStatus('optional')
if mibBuilder.loadTexts: copier_job_pages_per_sheet.setDescription('Returns or sets the copy value for how many input pages per output sheet. Additional information: Enables the device with local copier capability that also supports outputting multiple copies of a multi- paged source document to print multiple input sheets onto a single output sheet. ePagesPerSheet1: A single input image is placed on a single output sheet. This basically has no affect. ePagesPerSheet2: Two input images are placed on a single output sheet, in landscape format. ePagesPerSheet4: Four input images are placed on a single output sheet, in portrait format. NOTE: The Pages Per Sheet feature will only be supported on devices with an ADF. If no ADF is present, then changes to this object will not be allowed.')
copier_fit_to_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFitToPageDisabled", 1), ("eFitToPageEnabled", 2)))).setLabel("copier-fit-to-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_fit_to_page.setStatus('optional')
if mibBuilder.loadTexts: copier_fit_to_page.setDescription('Returns or sets the copy setting for fit to page. This value is stored in NVRAM, hence the value is saved over power cycles. Additional information: Enables the device with local copier capability to fit the input image size automatically onto the output sheet size.')
copier_job_fit_to_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFitToPageDisabled", 1), ("eFitToPageEnabled", 2)))).setLabel("copier-job-fit-to-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_fit_to_page.setStatus('optional')
if mibBuilder.loadTexts: copier_job_fit_to_page.setDescription('Returns or sets the copy value for fit to page. Additional information: Enables the device with local copier capability to fit the input image size automatically onto the output sheet size.')
copier_pages_per_sheet_maximum = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 49), Integer32()).setLabel("copier-pages-per-sheet-maximum").setMaxAccess("readonly")
if mibBuilder.loadTexts: copier_pages_per_sheet_maximum.setStatus('optional')
if mibBuilder.loadTexts: copier_pages_per_sheet_maximum.setDescription('Maximum pages per sheet value supported by the COPIER- PAGES-PER-SHEET and COPIER-JOB-PAGES-PER-SHEET objects. A value less than or equal to zero is invalid. Additional information: Maximum value supported for COPIER-PAGES-PER-SHEET or COPIER-JOB-PAGES-PER-SHEET objects. A value less than or equal to zero is invalid.')
device_cfg_download = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eCfgDownloadIdle", 1), ("eCfgDownloadStart", 2), ("eCfgDownloadActive", 3), ("eCfgDownloadAborted", 4), ("eCfgDownloadDone", 5)))).setLabel("device-cfg-download").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_cfg_download.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_download.setDescription('Handshaking mechanism between host and device to coordinate the download of device specific data. eCfgDownloadIdle - indicates device configuration download activity is not occurring. Device powers up in this state but will otherwise never transition to this state. This state is host settable from eCfgDownloadActive, eCfgDownloadDone, and eCfgDownloadAborted. Host setting to eCfgDownloadIdle while object is in eCfgDownloadActive will cause the download activity to be prematurely terminated. Host setting to this state resets the object to permit another download activity to be initiated. eCfgDownloadStart - indicates host wishes to commence a device configuration download activity. This state is only host settable from eCfgDownloadIdle. Only the device can transition this object from this state to eCfgDownloadActive or eCfgDownloadAborted. Device will not set to this state. eCfgDownloadActive - indicates download activity is in progress. Device transitions object to this state only from eCfgDownloadStart, to signal data download can commence. The device can transition from this state to eCfgDownloadDone or eCfgDownloadAborted. The host can transition from this state to eCfgDownloadIdle. This state is not host settable. eCfgDownloadAborted - indicates the download activity was terminated by the device. Only the device can set to this state from eCfgDownloadStart or eCfgDownloadActive. Only the host can transition from this state to eCfgDownloadIdle. This state is not host settable. eCfgDownloadDone - indicates device has completely received the download data. Device transitions to this state only from eCfgDownloadActive. Only the host can transition from this state to eCfgDownloadIdle. This state is not host settable.')
device_cfg_download_data_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 9))).clone(namedValues=NamedValues(("eSpeedDials", 5), ("eFaxLogs", 6), ("eConfigPrams", 7), ("eJunkFaxDialStrings", 9)))).setLabel("device-cfg-download-data-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_cfg_download_data_type.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_download_data_type.setDescription('Indicates the type of device specific data to be downloaded.')
device_cfg_upload = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eCfgUploadIdle", 1), ("eCfgUploadStart", 2), ("eCfgUploadActive", 3), ("eCfgUploadAborted", 4), ("eCfgUploadDone", 5)))).setLabel("device-cfg-upload").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_cfg_upload.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_upload.setDescription('Handshaking mechanism between host and device to coordinate the upload of device specific data. eCfgUploadIdle - indicates device configuration upload activity is not occurring. Device powers up in this state but will otherwise never transition to this state. This state is host settable from eCfgUploadActive, eCfgUploadDone, and eCfgUploadAborted. Host setting to eCfgUploadIdle while object is in eCfgUploadActive will cause the upload activity to be prematurely terminated. Host setting to this state resets the object allowing a new upload to be initiated. eCfgUploadStart - indicates host wishes to commence a device configuration upload activity. This state is only host settable from eCfgUploadIdle. Only the device can transition this object from this state to eCfgUploadActive or eCfgUploadAborted. Device will not set to this state. eCfgUploadActive - indicates upload activity is in progress. Device transitions object to this state only from eCfgUploadStart, to signal data upload can commence. The device can transition from this state to eCfgUploadDone or eCfgUploadAborted. The host can transition from this state to eCfgUploadIdle. This state is not host settable. eCfgUploadAborted - indicates the upload activity was terminated by the device. Only the device can set to this state from eCfgUploadStart or eCfgUploadActive. Only the host can transition from this state to eCfgUploadIdle. This state is not host settable. eCfgUploadDone - indicates device completely transmitted the upload data. Device transitions to this state only from eCfgUploadActive. Only the host can transition from this state to eCfgUploadIdle. This state is not host settable.')
device_cfg_upload_data_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 9))).clone(namedValues=NamedValues(("eSpeedDials", 5), ("eFaxLogs", 6), ("eConfigPrams", 7), ("eJunkFaxDialStrings", 9)))).setLabel("device-cfg-upload-data-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_cfg_upload_data_type.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_upload_data_type.setDescription('Indicates the type of device specific data to be uploaded.')
download_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 17), Integer32()).setLabel("download-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: download_timeout.setStatus('optional')
if mibBuilder.loadTexts: download_timeout.setDescription('Specifies the number of seconds that device will wait for data from the host before the device determines the host is being unresponsive. This timeout condition may cause the device to take recourse action regarding the disposition of the download activity. A value of zero indicates device will wait forever for the host data. POS should indicate whether this object value, when set by the host, is remembered between device power cycles. Additional information: This object is volatile and as such will not be retained by the device between power cycles.')
upload_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 18), Integer32()).setLabel("upload-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: upload_timeout.setStatus('optional')
if mibBuilder.loadTexts: upload_timeout.setDescription('Specifies the number of seconds that device will wait for response from the host after transmitting a unit of data before the device determines the host is being unresponsive. This timeout condition may cause the device to take recourse action regarding the disposition of the upload activity. A value of zero indicates device will wait forever for the host response. POS should indicate whether this object value, when set by the host, is remembered between device power cycles Additional information: This object is volatile and as such will not be retained by the device between power cycles.')
date_display = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eDateDisplayMMDDYY", 1), ("eDateDisplayDDMMYY", 2), ("eDateDisplayYYMMDD", 3)))).setLabel("date-display").setMaxAccess("readwrite")
if mibBuilder.loadTexts: date_display.setStatus('optional')
if mibBuilder.loadTexts: date_display.setDescription('Controls front-panel date display format.')
device_cfg_param_command = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 23), OctetString()).setLabel("device-cfg-param-command").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_cfg_param_command.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_param_command.setDescription("A C structure containing the following fields: typedef struct { u8bit list_id; s8bit auto_incr; u16bit max_index; u16bit rec_size; u16bit index; u8bit data[]; } PML_device_cfg_param_cmd_t; where u8bit is an unsigned byte (0..255), s8bit is a signed byte (-128..127), and u16bit is an big endian format unsigned short (0..65535). The POS should state which list_id's the device supports. Additional information: LaserJet 3300 supports two values for list_id: 0 for configuration parameters and 1 for default configuration parameters.")
fax_upload_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setLabel("fax-upload-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_upload_token.setStatus('optional')
if mibBuilder.loadTexts: fax_upload_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to the fax upload features of a device. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on FAX-UPLOAD- TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing any fax-upload objects, and 2) releasing the lock when done changing scan objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on FAX-UPLOAD-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing fax objects, and 2) releasing the lock when done changing fax objects.')
fax_download_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setLabel("fax-download-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_download_token.setStatus('optional')
if mibBuilder.loadTexts: fax_download_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to the fax download features of a device. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on FAX-DOWNLOAD- TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing any fax-download objects, and 2) releasing the lock when done changing scan objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on FAX-DOWNLOAD-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing fax objects, and 2) releasing the lock when done changing fax objects.')
date_and_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 17), OctetString()).setLabel("date-and-time").setMaxAccess("readwrite")
if mibBuilder.loadTexts: date_and_time.setStatus('optional')
if mibBuilder.loadTexts: date_and_time.setDescription('A C structure containing the following fields: typedef struct { ubyte yr; /* year: 0 to 99 */ ubyte mon; /* month: 1 to 12 */ ubyte day; /* day: 1 to 31 */ ubyte wday; /* Day of week: 1 to 07 */ ubyte hr; /* hour: 0 to 23 */ ubyte min; /* minute: 0 to 59 */ ubyte sec; /* second: 0 to 59 */ } date_t; where ubyte is an unsigned byte (0-255).')
time_display = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eTimeDisplayTwelveHour", 1), ("eTimeDisplayTwentyFourHour", 2)))).setLabel("time-display").setMaxAccess("readwrite")
if mibBuilder.loadTexts: time_display.setStatus('optional')
if mibBuilder.loadTexts: time_display.setDescription('Controls front-panel time display format. Set to eTimeDisplayTwelveHour for AM/PM display. Set to eTimeDisplayTwentyFourHour for military-type display.')
device_cfg_download_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 43), Integer32()).setLabel("device-cfg-download-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: device_cfg_download_error.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_download_error.setDescription('Error status of the configuration download session. POS should indicate the actual error values reserving value 0 as NO ERROR. Additional information: A value of 0 indicates NO ERROR. GECKO NOTE: SW & FW, what error conditions do we want to report with this object.')
device_cfg_upload_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 45), Integer32()).setLabel("device-cfg-upload-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: device_cfg_upload_error.setStatus('optional')
if mibBuilder.loadTexts: device_cfg_upload_error.setDescription('Error status of the configuration upload session. POS should indicate the actual error values reserving value 0 as NO ERROR. Additional information: A value of 0 indicates NO ERROR. GECKO NOTE: SW & FW, what error conditions do we want to report with this object.')
fax_local_phone_num = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 8), DisplayString()).setLabel("fax-local-phone-num").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_local_phone_num.setStatus('optional')
if mibBuilder.loadTexts: fax_local_phone_num.setDescription("CCITT sender's station id (ex. 08-396-4122).")
fax_station_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 9), DisplayString()).setLabel("fax-station-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_station_name.setStatus('optional')
if mibBuilder.loadTexts: fax_station_name.setDescription('name for the fax device (ex. HP R&D).')
fax_line_interface_unit_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setLabel("fax-line-interface-unit-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_line_interface_unit_id.setStatus('optional')
if mibBuilder.loadTexts: fax_line_interface_unit_id.setDescription('The fax device line interface unit (LIU) identifier. The LIU number identifies the telephone system electrical characteristics supported by this device. Additional information: In LaserJet 3300 this value is stored in 3 bits on the LIU.')
cancel_job = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 2), Integer32()).setLabel("cancel-job").setMaxAccess("readwrite")
if mibBuilder.loadTexts: cancel_job.setStatus('optional')
if mibBuilder.loadTexts: cancel_job.setDescription('Cancels the print job whose ID matches the value written to the CANCEL-JOB object. The host first learns the job ID using the CURRENT-JOB-PARSING-ID command. If the printer has completely processed the job, the printer responds with <badValue>. If the value of the CURRENT-JOB-PARSING-ID is smaller than the value written to the CANCEL-JOB object, then the printer responds with <badValue>. When read, returns the value of the last job ID what was canceled, or -1 to indicate no job has been canceled.')
faxjob_action = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("ePrintFaxToPrinter", 1), ("eDeleteFaxFromMemory", 3)))).setLabel("faxjob-action").setMaxAccess("readwrite")
if mibBuilder.loadTexts: faxjob_action.setStatus('optional')
if mibBuilder.loadTexts: faxjob_action.setDescription('Permits host to specify an action to be applied with a particular fax.')
faxjob_action_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 1, 2), Integer32()).setLabel("faxjob-action-id").setMaxAccess("readwrite")
if mibBuilder.loadTexts: faxjob_action_id.setStatus('optional')
if mibBuilder.loadTexts: faxjob_action_id.setDescription('Contains the fax job identification of the fax to be acted upon by the action specified by the object FAXJOB- ACTION.')
faxjob_tx_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 9))).clone(namedValues=NamedValues(("eSrcHostOnly", 2), ("eSrcScannerOnly", 5), ("eSrcHostToMemoryOnly", 9)))).setLabel("faxjob-tx-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: faxjob_tx_type.setStatus('optional')
if mibBuilder.loadTexts: faxjob_tx_type.setDescription('Indicates sources of the fax image for transmission. Also specifies the temporal order of the data sources. eSrcHostOnly - The fax document images will be wholly downloaded from the host. eSrcScannerOnly - The fax document images originate wholly from the device scanner/ADF subsystem. eSrcHostThenScanner - The fax document is composed of images downloaded from the host and pages from the scanner/ADF subsystem. The host downloaded pages will be faxed first, followed by the pages in the scanner/ADF. eSrcScannerThenHost - The fax document is composed of pages in the scanner/ADF and the images downloaded from the host. The document in the ADF is faxed first, followed by the pages downloaded from the host. wSrcHostThenMemory - The fax document is composed of pages downloaded from the host and images already stored within the device. The fax transmission will contain the host downloaded pages followed by the images in the device memory. eSrcHostToMemoryOnly - Permits fax images to be downloaded into device memory for later use with eSrcHostThenMemory. Additional information: GECKO NOTE: eSrcHostToMemoryOnly is included for development and testing only. eSrcHostToMemoryOnly will not be an allowed value for this object in the released product.')
faxjob_download_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 2, 1), Integer32()).setLabel("faxjob-download-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_download_id.setStatus('optional')
if mibBuilder.loadTexts: faxjob_download_id.setDescription('Contains the device assigned job identification for the current fax downloading job. The job ID is monotonically increasing number. The job ID may be reset to zero or may roll over to zero after reaching some maximum. The maximum value before the rollover should be stated in the POS. Additional information: The maximum value before this object rolls over to 0 is 2,147,483,648. Behavior of this object once the value rolls over to 0 is not specified.')
faxjob_rx_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 2, 2), Integer32()).setLabel("faxjob-rx-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_rx_id.setStatus('optional')
if mibBuilder.loadTexts: faxjob_rx_id.setDescription('Contains the device assigned job identification for the currently fax reception job. The job ID is monotonically increasing number. The job ID may be reset to zero or may roll over to zero after reaching some maximum. The maximum value before the rollover should be stated in the POS. Additional information: The maximum value before this object rolls over to 0 is 2,147,483,648. Behavior of this object once the value rolls over to 0 is not specified.')
faxjob_tx_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 2, 3), Integer32()).setLabel("faxjob-tx-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_tx_id.setStatus('optional')
if mibBuilder.loadTexts: faxjob_tx_id.setDescription('Contains the device assigned job identification for the current fax transmission job. The job ID is monotonically increasing number. The job ID may be reset to zero or may roll over to zero after reaching some maximum. The maximum value before the rollover should be stated in the POS. Additional information: The maximum value before this object rolls over to 0 is 2,147,483,648. Behavior of this object once the value rolls over to 0 is not specified.')
faxjob_upload_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 2, 4), Integer32()).setLabel("faxjob-upload-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_upload_id.setStatus('optional')
if mibBuilder.loadTexts: faxjob_upload_id.setDescription('Contains the device assigned job identification for the current fax upload job. The job ID is monotonically increasing number. The job ID may be reset to zero or may roll over to zero after reaching some maximum. The maximum value before the rollover should be stated in the POS. Additional information: The maximum value before this object rolls over to 0 is 2,147,483,648. Behavior of this object once the value rolls over to 0 is not specified.')
faxjob_rx_status_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eFaxRxIdle", 1), ("eFaxRxRinging", 2), ("eFaxRxAnswering", 3), ("eFaxRxReceiving", 4)))).setLabel("faxjob-rx-status-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_rx_status_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_rx_status_1.setDescription('Status of receiving fax session 1.')
faxjob_tx_status_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eFaxTxIdle", 1), ("eFaxTxDialing", 2), ("eFaxTxConnecting", 3), ("eFaxTxTransmitting", 4)))).setLabel("faxjob-tx-status-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_tx_status_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_tx_status_1.setDescription('Status of sending fax session 1.')
faxjob_tx_error_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 4, 1), Integer32()).setLabel("faxjob-tx-error-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_tx_error_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_tx_error_1.setDescription('Error status of the fax reception session 1. Additional information: Error status of the fax transmission session 1.')
faxjob_tx_current_page_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 5, 1), Integer32()).setLabel("faxjob-tx-current-page-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_tx_current_page_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_tx_current_page_1.setDescription('The page number of the fax page currently being transmitted via send fax session 1. Starts with page number 1.')
faxjob_rx_current_page_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 6, 1), Integer32()).setLabel("faxjob-rx-current-page-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_rx_current_page_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_rx_current_page_1.setDescription('The page number of the fax page currently being received via fax reception session 1. Starts with page number 1.')
faxjob_rx_duration_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 7, 1), Integer32()).setLabel("faxjob-rx-duration-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_rx_duration_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_rx_duration_1.setDescription('Represent the number of seconds of phone-connect time for a fax reception session 1.')
faxjob_tx_duration_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 3, 3, 8, 1), Integer32()).setLabel("faxjob-tx-duration-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: faxjob_tx_duration_1.setStatus('optional')
if mibBuilder.loadTexts: faxjob_tx_duration_1.setDescription('Represent the number of seconds of phone-connect time for send fax session 1.')
fax_log_action = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eIdle", 1), ("eClear", 2), ("ePrintLatest", 3), ("ePrintAll", 4)))).setLabel("fax-log-action").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_log_action.setStatus('optional')
if mibBuilder.loadTexts: fax_log_action.setDescription("Provides applications with the ability to clear or print the fax transaction log. eIdle - no action is occurring on the fax log. eClear - clear the fax log. ePrintLatest - print the latest entry in the fax log. ePrintAll - print all the entries in the fax log. When this object is set to a non-eIdle value by an application, the given action starts. When the action is complete, this object is changed back to eIdle by the device. A host's request to write this object will be rejected when the object is not eIdle. When eIdle, the host may set the object to any value (including eIdle).")
fax_log_reporting = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eNever", 1), ("eErrorOnly", 2), ("eSendOnly", 3)))).setLabel("fax-log-reporting").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_log_reporting.setStatus('optional')
if mibBuilder.loadTexts: fax_log_reporting.setDescription('Specifies when fax transaction logs are to be printed.')
fax_dial_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eToneDial", 1), ("ePulseDial", 2)))).setLabel("fax-dial-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_dial_mode.setStatus('optional')
if mibBuilder.loadTexts: fax_dial_mode.setDescription('Device should use DTMF dialing if eToneDial, pulse dial if ePulseDial.')
device_redial = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 1, 1, 2), OctetString()).setLabel("device-redial").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_redial.setStatus('optional')
if mibBuilder.loadTexts: device_redial.setDescription('Device to permit redial upon detecting certain error conditions.')
fax_pulse_dial_support = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eSupported", 1), ("eNotSupported", 2)))).setLabel("fax-pulse-dial-support").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_pulse_dial_support.setStatus('optional')
if mibBuilder.loadTexts: fax_pulse_dial_support.setDescription('This object reports whether the current set country supports pulse dial. Additional information: This object reports whether the current set country supports pulse dial. In LaserJet 3300, it checks the DS variable, which is updated when the pml object FAX-COUNTRY is changed.')
fax_answer_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eManualAnswer", 1), ("eFaxAnswer", 2)))).setLabel("fax-answer-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_answer_mode.setStatus('optional')
if mibBuilder.loadTexts: fax_answer_mode.setDescription('Sets the answering-priority when using a shared voice line. eManualAnswer - Device will not automatically answer the phone. User must answer and push START button. eFaxAnswer - Device should assume call is fax, send CED immediately upon answering. eTadAnswer - (Telephone Answering Device Mode) Device allows downstream TAD to answer but device will eavesdrop for fax CNG signal. If a CNG detected, cut off the downstream device, send CED. Do nothing if CNG not detected.')
fax_num_rings_pickup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setLabel("fax-num-rings-pickup").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_num_rings_pickup.setStatus('optional')
if mibBuilder.loadTexts: fax_num_rings_pickup.setDescription('Number of rings before the fax device answers the phone if FAX-ANSWER-MODE is not set to MANUAL-MODE.')
device_ring_type_pickup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 9, 2, 1, 3), OctetString()).setLabel("device-ring-type-pickup").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_ring_type_pickup.setStatus('optional')
if mibBuilder.loadTexts: device_ring_type_pickup.setDescription('Device to answer the incoming call based on detecting the the specified type of telephone ring.')
fax_receive_stamping_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-receive-stamping-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_receive_stamping_enable.setStatus('optional')
if mibBuilder.loadTexts: fax_receive_stamping_enable.setDescription('Controls whether or not incoming pages of a fax will be stamped upon receipt. Content of the stamp is device- specific but may include such information as date, time, fax station name, and page number. When this object is set to eEnabled each page of an incoming fax is stamped by the device. When this object is set to eDisabled incoming fax pages are not stamped. Additional information: When this object is set to eEnabled each page of an incoming fax is stamped with the date, time, fax station name, and page number. When this object is set to eDisabled incoming fax pages are not stamped. // The received fax page will be scaled down 0.03% to accomodate the header. No header will be printed on page 2 of paginated output.')
not_ready_fax_receive = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 3, 2, 1), OctetString()).setLabel("not-ready-fax-receive").setMaxAccess("readonly")
if mibBuilder.loadTexts: not_ready_fax_receive.setStatus('optional')
if mibBuilder.loadTexts: not_ready_fax_receive.setDescription('Indicates if the receiving fax sub-system in the device is not ready. If there are no items in the collection (i.e. no bits are set), then the receiving fax sub- system is ready. If there is an item present, then the item indicates what is causing the receiving fax sub- system to be not ready.')
fax_rxscale = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 1), Integer32()).setLabel("fax-rxscale").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_rxscale.setStatus('optional')
if mibBuilder.loadTexts: fax_rxscale.setDescription('Received faxes are to be printed at a reduced scale percentage. Value of 0 indicates auto-scaled printing based on the length of the received fax image and the length of the paper.')
fax_noise_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setLabel("fax-noise-volume").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_noise_volume.setStatus('optional')
if mibBuilder.loadTexts: fax_noise_volume.setDescription('Range is 0..100, where 0 = quietest possible, and 100 = loudest possible. A device shall divide this value into ranges corresponding to the possible volumes. Additional information: For LaserJet 3300 the range is 0..200, where 0=off (silent), 96=soft, 160=medium, and 200=loud. For LaserJet 3300 this object refers to the line monitor noise volume. The decimal values above correspond to the hex values the object gets set to.')
fax_download = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eFaxDownloadIdle", 1), ("eFaxDownloadStart", 2), ("eFaxDownloadActive", 3), ("eFaxDownloadAborted", 4), ("eFaxDownloadDone", 5)))).setLabel("fax-download").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_download.setStatus('optional')
if mibBuilder.loadTexts: fax_download.setDescription('Note: Changed enumeration values in a non-backwards manner in version 4.7. Handshake mechanism between host and device to initiate and coordinate the download of fax image data to be transmitted by the device fax modem. This object serves both as an indicator of fax download activity as well as a trigger for the host to alter fax download progress. This object has been redefined to track only the download acpect of the fax transmission. eFaxDownloadIdle - indicates no fax download activity is occurring. Device powers up in this state but will otherwise never transition to this state of its own accord. Host setting to eFaxDownloadIdle while object is in eFaxDownloadActive will cause download activity to be prematurely terminated. Host setting to this state resets the handshake mechanism to permit a another fax download activity to be initiated. eFaxDownloadStart - indicates the host requests to commence a download session for sending a fax. This state is host settable only from eFaxDownloadIdle. Device will never transition to this state of its own accord. eFaxDownloadActive - indicates a fax download is occurring. This state is not host settable. Device will transition to this state from eFaxDownloadStart as a positive response for host to commence download of fax data. This state is not host settable. The object FAXJOB-DOWNLOAD-ID now contains the job ID to be used to track the progress of this fax job. eFaxDownloadAborted - indicates the fax download activity has been prematurely terminated by the device due to some error. Object FAX-DOWNLOAD-ERROR contains the error reason for the premature session termination. This state is device settable from eFaxDownloadStart or eFaxDownloadActive. This state is not host settable. If modem transmission of fax data has started for this download, the fax session will also be aborted. eFaxDownloadDone - indicates the fax download activity has reached a successful termination in that the device has accepted all the download data from the host. This state is only settable by the device from eFaxDownloadActive. This state is not host settable. This state does not indicate the progress of the modem transmission of the downloaded fax data. Host should transition from this state to eFaxDownloadIdle in order to reset the handshake mechanism for subsequent download.')
fax_silent_detection = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-silent-detection").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_silent_detection.setStatus('optional')
if mibBuilder.loadTexts: fax_silent_detection.setDescription('When enabled, this object causes the FAX machine to assume that the caller is a FAX even though the line has remained silent for a time (i.e., no CNG detected). When disabled, a CNG is required of the caller.')
fax_ring_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-ring-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_ring_enable.setStatus('optional')
if mibBuilder.loadTexts: fax_ring_enable.setDescription('When the phone line rings, this object determines whether an audible ring shall be emitted.')
fax_country = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 13, 14, 15, 19, 21, 23, 27, 29, 30, 31, 34, 35, 37, 39, 40, 41, 43, 44, 45, 46, 47, 51, 55, 56, 62, 63, 64))).clone(namedValues=NamedValues(("eChina", 6), ("eMexicoAndLatinAmerica", 13), ("eCanadaFrench", 14), ("eUnitedStatesAndCanadaEnglish", 15), ("eNewZealand", 19), ("eIsrael", 21), ("eAustralia", 23), ("eMalaysia", 27), ("eHongKong", 29), ("eSingapore", 30), ("eUnitedKingdom", 31), ("eAustria", 34), ("eNetherlands", 35), ("eSwitzerlandFrench", 37), ("eGermany", 39), ("eDenmark", 40), ("eSweden", 41), ("eNorway", 43), ("eIreland", 44), ("eBelgium", 45), ("eFinland", 46), ("eFrance", 47), ("eItaly", 51), ("eSpain", 55), ("ePoland", 56), ("eHungary", 62), ("eUkraine", 63), ("eRussia", 64)))).setLabel("fax-country").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_country.setStatus('optional')
if mibBuilder.loadTexts: fax_country.setDescription('Note: Non-backwards compatible change make in version 4.7. Returns which country the telephone-electronics (LIU) is configured for. If this object is implemented with an access of read-write the device POS will specify what occurs when this object is written. Additional information: GECKO NOTE: Is enumeration 37 (eSwitzerlandFrench) the correct setting for Switzerland? The mib also provides the following options: eSwitzerland(36) eSwitzerlandGerman(36) eSwitzerlandItalian(38)')
fax_tx_phone_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 10), DisplayString()).setLabel("fax-tx-phone-number").setMaxAccess("writeonly")
if mibBuilder.loadTexts: fax_tx_phone_number.setStatus('optional')
if mibBuilder.loadTexts: fax_tx_phone_number.setDescription('Phone number about to be dialed.')
fax_redial_time = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 14), Integer32()).setLabel("fax-redial-time").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_redial_time.setStatus('optional')
if mibBuilder.loadTexts: fax_redial_time.setDescription('Number of seconds one must wait between the current redial (set by FAX-WHICH-REDIAL) and any prior dialing.')
fax_pstn_access_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 18), DisplayString()).setLabel("fax-pstn-access-code").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_pstn_access_code.setStatus('optional')
if mibBuilder.loadTexts: fax_pstn_access_code.setDescription("The code used within a PBX to get access to an outside PSTN line. Typically this is ''9''.")
fax_rx_disposition = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6))).clone(namedValues=NamedValues(("ePrintOnly", 1), ("eUploadOnly", 2), ("eUploadElsePrint", 4), ("eForwardElsePrint", 6)))).setLabel("fax-rx-disposition").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_rx_disposition.setStatus('optional')
if mibBuilder.loadTexts: fax_rx_disposition.setDescription('Indicates what is to be done with the incoming fax call. ePrintOnly - New fax arrivals only go to the printer. If printer becomes unavailable, the fax is stored in device memory until the printer becomes available. If device memory becomes full, no subsequent calls will be answered. If power is cycled on the device, the user must be informed of any lost faxes. If faxes are saved in non-volatile memory, then they will be printed upon successful power-up. eUploadOnly - New fax can only be uploaded to the host. If host becomes unavailable, the fax is stored in device memory until host becomes available again to upload. If device memory becomes full, no subsequent calls will be answered. If power is cycled on the device, the user must be informed of any lost faxes. If faxes are saved in non-volatile device memory, the host must be informed of a need to upload saved faxes upon successful power up. eUploadAndPrint - Received faxes are to be printed and also uploaded to the host. The fax is stored in device memory until it has been printed and uploaded. If device memory becomes full, no subsequent calls will be answered. If power is cycled on the device, the user must be informed of any lost faxes. If faxes were saved into non-volatile memory, then faxes must be printed and uploaded before erasure from device memory. eUploadElsePrint - Received faxes are to be uploaded if host is available, otherwise the fax is printed. During an upload, if the host becomes unavailable, the remainder of the fax is printed. Once the host is detected to be unavailable, the object will transition to ePrintOnly. Refer to fax reception behavior for ePrintOnly. ePrintElseUpload - Received faxes are to be printed. If printer is unavailable, the fax will be uploaded. If printer becomes unavailable while the fax is being received, the remainder unprinted pages of the fax will be uploaded. If host then becomes unavailable, this object will transition to ePrintOnly. Remainder pages of the fax being uploaded will be stored in device memory, to be printed when printer becomes available. If device memory becomes full, no subsequent calls will be answered. If power is cycled on the device, the user must be informed of any lost faxes. eForwardElsePrint - Received faxes are to be forwarded to another fax station. If remote number does not answer, fax is printed. If remote number is busy on multiple redial attempts, the fax is printed. If device memory becomes full before fax reception is complete, the fax is printed. If printer becomes unavailable, the fax is stored in device memory and then printed when printer becomes available again. ')
fax_error_correction_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-error-correction-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_error_correction_mode.setStatus('optional')
if mibBuilder.loadTexts: fax_error_correction_mode.setDescription('Indicates whether the device is configured to send and receive faxes in error correction mode (ECM). This object controls both receiving and transmitting in ECM. A value of eDisabled means ECM is off and the device will not advertise the ability to do ECM during negotiation with other fax machines. A value of eEnabled means ECM is on and the device will advertise its ability to do ECM. Changing this setting may or may not take affect on the immediate page or ensuing pages of the document currently being sent.')
fax_report_transmission = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eNone", 1), ("ePrintReport", 2), ("ePrintReportOnSend", 3), ("ePrintReportOnError", 4), ("ePrintReportOnSendError", 5), ("ePrintReportOnReceiveError", 6)))).setLabel("fax-report-transmission").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_report_transmission.setStatus('optional')
if mibBuilder.loadTexts: fax_report_transmission.setDescription('Provides a host application with the ability to print a fax transmission report. The supported enumerations are: eNone - no transmission report printed ePrintReport - transmission report always printed ePrintReportOnSend - transmission report printed on send only ePrintReportOnError - transmission report printed on error only ePrintReportOnSendError - transmission report printed on send error only ePrintReportOnReceiveError - transmission report printed on receive error only.')
fax_report_activity_log = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eNever", 1), ("eThreshold", 2)))).setLabel("fax-report-activity-log").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_report_activity_log.setStatus('optional')
if mibBuilder.loadTexts: fax_report_activity_log.setDescription('Specifies when a report of fax transactions is to be printed. eNever - to never print a transaction report. eThreshold - to automatically print a transaction report every N transactions. The POS for each product shall specify the value of N. FAX-REPORT-TRANSMISSION also prints a transaction report, but for only a given fax, not a log of fax activities. May not be settable if the fax machine is not idle. The log is cleared after each printing caused by this object.')
fax_dial_tone_detection = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-dial-tone-detection").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_dial_tone_detection.setStatus('optional')
if mibBuilder.loadTexts: fax_dial_tone_detection.setDescription('Determines whether the fax machine waits for a dial tone before dialing a fax number. eEnabled - causes the fax machine to wait until a dial tone is recognized before attempting to dial a fax number. eDisabled - causes the fax machine to dial without waiting to recognize a dial tone.')
fax_alarm_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setLabel("fax-alarm-volume").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_alarm_volume.setStatus('optional')
if mibBuilder.loadTexts: fax_alarm_volume.setDescription('Range is 0..100, where 0 = quietest possible, and 100 = loudest possible. A device shall divide this value into ranges corresponding to the possible volumes and document these settings and their meanings in the product POS. Additional information: For LaserJet 3300 the range is 0..3, where 0=off (silent), 1=soft, 2=medium, and 3=loud.')
fax_beep_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setLabel("fax-beep-volume").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_beep_volume.setStatus('optional')
if mibBuilder.loadTexts: fax_beep_volume.setDescription('Range is 0..100, where 0 = quietest possible, and 100 = loudest possible. A device shall divide this value into ranges corresponding to the possible volumes and document these settings and their meanings in the product POS. Additional information: For LaserJet 3300 the range is 0..3, where 0=off (silent), 1=soft, 2=medium, and 3=loud.')
fax_ring_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setLabel("fax-ring-volume").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_ring_volume.setStatus('optional')
if mibBuilder.loadTexts: fax_ring_volume.setDescription('Range is 0..100, where 0 = quietest possible, and 100 = loudest possible. A device shall divide this value into ranges corresponding to the possible volumes and document these settings and their meanings in the product POS. Additional information: For LaserJet 3300 the range is 0..3, where 0=off (silent), 1=soft, 2=medium, and 3=loud.')
fax_master_host = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 28), DisplayString()).setLabel("fax-master-host").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_master_host.setStatus('optional')
if mibBuilder.loadTexts: fax_master_host.setDescription('Identifies the hostname of the master host to which the device is connected.')
fax_thumbnail_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-thumbnail-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_thumbnail_enable.setStatus('optional')
if mibBuilder.loadTexts: fax_thumbnail_enable.setDescription('Controls whether or not a thumbnail reprint of the first page of a fax shall be included on the fax call report. When set to eEnabled a thumbnail shall be included on the report. When set to eDisabled there shall be not be a thumbnail on the fax call report. Additional information: Controls whether or not a thumbnail reprint of the first page of a fax shall be included on the fax call report. When set to eEnabled a thumbnail shall be included on the report. When set to eDisabled there shall be not be a thumbnail on the fax call report.')
fax_phone_pickup_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("fax-phone-pickup-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_phone_pickup_enable.setStatus('optional')
if mibBuilder.loadTexts: fax_phone_pickup_enable.setDescription("This object is included to handle the situation where a fax machine and a telephone share the same phone line. If a call picked up at the phone turns out to be a fax call, the user may initiate a fax receive via the fax machine front panel (with, say, a button press). When this object is set to eEnabled and a fax call is answered at the phone, the user has the option of initiating the fax receive in the usual way at the fax front panel or by entering a (product-specific) key sequence on the telephone keypad (e.g. '***'). The device POS must indicate what the key sequence is for a particular product. When this object is set to eDisabled and a fax call is answered at the phone, the user may only initiate the fax receive by taking the product-specific action (such as a button press) at the fax machine front panel. It is necessary to be able to turn this feature off (i.e. set it to eDisabled) because the key sequence of a particular fax device may interfere with other devices connected to the phone line (e.g. an answering machine). Additional information: On LaserJet 3300, the key sequence to initiate a fax from the phone keypad is '***'.")
fax_adf_scan_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 31), Integer32()).setLabel("fax-adf-scan-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_adf_scan_count.setStatus('optional')
if mibBuilder.loadTexts: fax_adf_scan_count.setDescription('This object tracks the page count for the pages scanned for faxing from the ADF. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for the pages scanned for faxing from the ADF. In order to write this object SERVICE-PASSWORD must be set correctly.')
fax_print_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 32), Integer32()).setLabel("fax-print-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_print_page_count.setStatus('optional')
if mibBuilder.loadTexts: fax_print_page_count.setDescription('This object tracks the page count for the pages sent to the print engine for fax jobs. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for the pages sent to the print engine for fax jobs. In order to write this object SERVICE- PASSWORD must be set correctly.')
fax_download_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 33), Integer32()).setLabel("fax-download-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_download_page_count.setStatus('optional')
if mibBuilder.loadTexts: fax_download_page_count.setDescription('This object tracks the page count for the pages downloaded to the peripheral for fax jobs. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for the pages downloaded to the peripheral for fax jobs. In order to write this object SERVICE- PASSWORD must be set correctly.')
fax_upload_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 1, 34), Integer32()).setLabel("fax-upload-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_upload_page_count.setStatus('optional')
if mibBuilder.loadTexts: fax_upload_page_count.setDescription('This object tracks the page count for the pages uploaded from the peripheral for fax jobs. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for the pages uploaded from the peripheral for fax jobs. In order to write this object SERVICE- PASSWORD must be set correctly.')
fax_upload = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eFaxUploadIdle", 1), ("eFaxUploadStart", 2), ("eFaxUploadActive", 3), ("eFaxUploadAborted", 4), ("eFaxUploadDone", 5), ("eFaxUploadNeeded", 6)))).setLabel("fax-upload").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_upload.setStatus('optional')
if mibBuilder.loadTexts: fax_upload.setDescription('Note: The enumeration values for this object where changed in a non-backwards compatible manner in version 4.7. Handshake mechanism between host and device to notify and coordinate the transfer of fax image data received by the device fax modem. This object serves both as an indicator of fax upload activity as well as a trigger for the host to alter fax upload progress. Handshake mechanism between host and device to initiate scan operation and coordinate the transfer of scanned image data to the host. This object serves both as an indicator of scan upload activity as well as a trigger for the host to alter scan upload progress. eFaxUploadIdle - indicates no fax upload activity is is occurring. Device powers up in this state but will otherwise never transition to this state of its own accord. Host setting to eFaxUploadIdle while object is in eFaxUploadActive will cause download activity to be prematurely terminated. Host setting to this state resets the handshake mechanism to permit another fax upload activity to be initiated. eFaxUploadStart - indicates the host requests to commence an upload session for a received fax. This state is host settable only from eFaxUploadIdle. Device will never transition to this state of its own accord. eFaxUploadActive - indicates a fax upload is occurring. This state is not host settable. Device will transition to this state from eFaxUploadStart as a positive response for host to commence upload of fax data. The object FAXJOB-UPLOAD-ID now contains the job ID. eFaxUploadAborted - indicates the fax upload activity has been prematurely terminated by the device due to some error. Object FAX-UPLOAD-ERROR contains the error reason for the premature session termination. This state is device settable from eFaxUploadStart, eFaxUploadActive or eFaxUploadNeeded. This state is not host settable. eFaxUploadDone - indicates the fax upload activity has reached a successful termination in that the device has transmitted all the upload data to the host. This state is only settable by the device from eFaxUploadActive. This state is not host settable. Host should transition from this state to eFaxUploadIdle in order to reset the handshake mechanism for subsequent upload session. eFaxUploadNeeded - indicates device has received fax modem data available for host upload. This state is not host settable. This state is device settable from eFaxUploadIdle. Host should respond by setting to eFaxUploadStart to initiate upload session. Should host fail to respond by the time fax reception is complete or device has exhausted local memory storage, device shall transition object from eFaxUploadNeeded to eFaxUploadAborted. The POS should state the recourse behavior associated with the received fax.')
fax_min_rings_pickup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setLabel("fax-min-rings-pickup").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_min_rings_pickup.setStatus('optional')
if mibBuilder.loadTexts: fax_min_rings_pickup.setDescription('Indicates the minimum legal rings before pickup. Additional information: GECKO NOTE: Do all countries on the LaserJet 3300 list allow a minimum of 1? If not, object syntax must be amended.')
fax_max_rings_pickup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setLabel("fax-max-rings-pickup").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_max_rings_pickup.setStatus('optional')
if mibBuilder.loadTexts: fax_max_rings_pickup.setDescription('Indicates the maximum legal rings before pickup.')
fax_max_redials = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 4), Integer32()).setLabel("fax-max-redials").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_max_redials.setStatus('optional')
if mibBuilder.loadTexts: fax_max_redials.setDescription('Maximum number of allowed redials.')
fax_additional_wait = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 5), Integer32()).setLabel("fax-additional-wait").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_additional_wait.setStatus('optional')
if mibBuilder.loadTexts: fax_additional_wait.setDescription('Number of additional seconds to wait before beginning a FAX-DOWNLOAD.')
fax_download_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 6), Integer32()).setLabel("fax-download-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_download_error.setStatus('optional')
if mibBuilder.loadTexts: fax_download_error.setDescription('Error status of the fax download session. Additional information: GECKO NOTE: What error conditions will be reported by this object? Provide a map for the meaning of each valid value here.')
fax_upload_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 7), Integer32()).setLabel("fax-upload-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_upload_error.setStatus('optional')
if mibBuilder.loadTexts: fax_upload_error.setDescription('Error status of the fax upload session. Additional information: GECKO NOTE: What error conditions will be reported by this object? Provide a map for the meaning of each valid value here. Does this functionality stay? If not, this object is superfluous.')
fax_firmware_revision = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setLabel("fax-firmware-revision").setMaxAccess("readonly")
if mibBuilder.loadTexts: fax_firmware_revision.setStatus('optional')
if mibBuilder.loadTexts: fax_firmware_revision.setDescription('This object identifies the fax firmware ROM revision code. The format is device specific and shall be specified in the device POS. Additional information: This object identifies the fax firmware ROM revision code. For LaserJet 3300, the format for this object is a date in the form YYYYMMDD.')
fax_forwarding_phone_num = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 7, 3, 3), DisplayString()).setLabel("fax-forwarding-phone-num").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_forwarding_phone_num.setStatus('optional')
if mibBuilder.loadTexts: fax_forwarding_phone_num.setDescription('Phone number digits of the remote fax station where arrived faxes are to be forwarded.')
fax_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setLabel("fax-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_resolution.setStatus('optional')
if mibBuilder.loadTexts: fax_resolution.setDescription("struct { unsigned_32bit x_res; /* 1st four bytes; big endian */ unsigned_32bit y_res; /* 2nd four bytes; big endian */ } Sets the send fax resolution. The x and y resolutions in this object are in fixed-point with 16 bits of fraction, and 16 bits of integer, and are in dots per inch. X is horizontal; Y is vertical. Examples of computing x_res and y_res: 300 dots/inch:round(300 * 65536) = 19660800 16 dots/mm: round(16 * 25.4 * 65536) = 26633830. If the device does not support the given combination, then it'll select the nearest supported values in a device-dependent manner (documented in the POS). Additional information: LaserJet 3300 supports 4 fax resolutions. As far as the end-user is concerned these resolutions are: standard, fine, superfine, and photo. Photo is not really a resolution--see more below. Standard is the default. Resolutions map as follows (values are given in dots per inch (dpi) horizontal X vertical (x X y)): standard(203 X 98), fine(203 X 196), superfine(300 X 300), and photo(300 X 300). Supported resolutions in hex notation (dpi, x X y) are: standard(00cb0000 X 00620000), fine(00cb0000 X 00c4000), superfine(012C0000 X 012C0000), and photo(012C0000 X 012C0000). The device ignores attempts to set invalid resolutions. Photo is not a resolution, but photo setting depends on whether half-toning is on or off. In the case of LaserJet 3300 photo setting doesn't actually change the bits going out the modem -- still one bit per pixel so photo and superfine are the same. NOTE: The last 16 bits of the horizontal and vertical settings are ignored. Only the first 16 bits of the horizontal and vertical resolution setting are used.")
fax_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("fax-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_contrast.setStatus('optional')
if mibBuilder.loadTexts: fax_contrast.setDescription("Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the sending fax contrast level. Range is 0..100. Additional information: Behaves as COPIER-CONTRAST and SCANNER-CONTRAST. Contrast values can range from -127 to +127, for a total of 255 contrast values. Within that range, LaserJet 3300 supports 11 values. They are: -125, -100, -75, -50, -25, 0, 25, 50, 75, 100, 125. The default contrast level is 0 (normal). A positive value results in a larger difference, and a negative value results in a smaller difference. LaserJet 3300 snaps unsupported values toward zero as follows: <=-125 snaps to -125 >-125 and <=-100 snaps to -100 >-100 and <=-75 snaps to -75 >-75 and <=-50 snaps to -50 >-50 and <=-25 snaps to -25 >-25 and <25 snaps to 0 >=25 and <50 snaps to 25 >=50 and <75 snaps to 50 >=75 and <100 snaps to 75 >=100 and <125 snaps to 100 >=125 snaps to 125")
fax_pixel_data_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eBiLevelThesholded", 1), ("eBiLevelHalfToned", 2)))).setLabel("fax-pixel-data-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_pixel_data_type.setStatus('optional')
if mibBuilder.loadTexts: fax_pixel_data_type.setDescription('Sets the scanning method used when sending a fax. eBiLevelThesholded - One bit per pixel, using simple thresholding of greyscale scan data. eBiLevelHalfToned - One bit per pixel, using some kind of half-toning technique (such as dithering or error-diffusion) to approximate greyscale scan data.')
not_ready_fax_send = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 2, 1), OctetString()).setLabel("not-ready-fax-send").setMaxAccess("readonly")
if mibBuilder.loadTexts: not_ready_fax_send.setStatus('optional')
if mibBuilder.loadTexts: not_ready_fax_send.setDescription('Indicates if the sending fax sub-system in the device is not ready. If there are no items in the collection (i.e. no bits are set), then the sending fax sub-system is ready. If there is an item present, then the item indicates what is causing the sending fax sub-system to be not ready.')
fax_allow_redials = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("fax-allow-redials").setMaxAccess("readwrite")
if mibBuilder.loadTexts: fax_allow_redials.setStatus('optional')
if mibBuilder.loadTexts: fax_allow_redials.setDescription('When eTrue, the FAX machine can redial a phone number if the prior call failed for some reason. When eFalse, such redialing will not occur. Additional information: This object is not used for the LaserJet 3300 Series products.')
hrmemorysize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrmemorysize.setStatus('mandatory')
if mibBuilder.loadTexts: hrmemorysize.setDescription('The amount of physical main memory contained by the host. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The unit of measure for this object is 1024 bytes. The default value assumes the base printer with no additional memory.')
hrstorageindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageindex.setDescription('A unique value for each logical storage area contained by the host. Refer to RFC 1514, Host Resources MIB, for more details.')
hrstoragetype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragetype.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragetype.setDescription('The type of storage represented by this entry. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: For the LaserJet 3300 Series this object is constant.')
hrstoragedescr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragedescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragedescr.setDescription('A description of the type and instance of the storage described by this entry. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is not localized. For the HP LaserJet 3300 Series this object is constant.')
hrstorageallocationunits = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageallocationunits.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageallocationunits.setDescription('The size, in bytes, of the data objects allocated from this pool. If this entry is monitoring sectors, blocks, buffers, or packets, for example, this number will commonly be greater than one. Otherwise this number will typically be one. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Unit is one byte. For the HP LaserJet 3300 Series this object is constant.')
hrstoragesize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragesize.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragesize.setDescription('The size of the storage represented by this entry, in units of hrStorageAllocationUnits. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Total formatter RAM. (The value of this object is hrMemorySize times the unit of measure for hrMemorySize. In the case of the HP LaserJet 3300 Series this is 32768*1024 bytes.)')
hrstorageused = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageused.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageused.setDescription('The amount of the storage represented by this entry that is allocated, in units of hrStorageAllocationUnits. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object returns the amount of memory in use by the printer at the current time. This object should not be used when creating a print job for the device because the amount of memory in use will likely be different when the printer processes the print job.')
hrstorageallocationfailures = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageallocationfailures.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageallocationfailures.setDescription('The number of requests for storage represented by this entry that could not be honored due to not enough storage. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is set to zero at power on and when any reset is done via prtGeneralReset. This object is incremented whenever the printer is short on memory (codewise: when PersMemoryCycle is called with a parameter of 2).')
hrdeviceindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceindex.setDescription('A unique value for each device contained by the host. The value for each device must remain constant at least from one re-initialization of the agent to the next re-initialization. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The entry in the Device Table which describes the printer.')
hrdevicetype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicetype.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicetype.setDescription("An indication of the type of device. If this value is `hrDeviceProcessor { hrDeviceTypes 3 }' then an entry exists in the hrProcessorTable which corresponds to this device. If this value is `hrDeviceNetwork { hrDeviceTypes 4 }', then an entry exists in the hrNetworkTable which corresponds to this device. If this value is `hrDevicePrinter { hrDeviceTypes 5 }', then an entry exists in the hrPrinterTable which corresponds to this device. If this value is `hrDeviceDiskStorage { hrDeviceTypes 6 }', then an entry exists in the hrDiskStorageTable which corresponds to this device. Refer to RFC 1514, Host Resources MIB, for more details.")
hrdevicedescr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicedescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicedescr.setDescription("A textual description of this device, including the device's manufacturer and revision, and optionally, its serial number. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The serial number is not returned with this object. This object is not localized.")
hrdeviceid = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceid.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceid.setDescription('The product ID for this device. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The complete OID reported by this object is: .1.3.6.1.4.1.11.2.3.9.1.2.30')
hrdevicestatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5))).clone(namedValues=NamedValues(("eHrunning", 2), ("eHwarning", 3), ("eHdown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicestatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicestatus.setDescription("The current operational state of the device described by this row of the table. A value unknown(1) indicates that the current state of the device is unknown. running(2) indicates that the device is up and running and that no unusual error conditions are known. The warning(3) state indicates that agent has been informed of an unusual error condition by the operational software (e.g., a disk device driver) but that the device is still 'operational'. An example would be high number of soft errors on a disk. A value of testing(4), indicates that the device is not available for use because it is in the testing state. The state of down(5) is used only when the agent has been informed that the device is not available for any use. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The printer's condition is mapped as follows: eHrunning -- Printer ready to print or is printing. May be in power save mode. eHwarning -- A condition exists that needs attention but it is not currently preventing printing. A non-critical alert is active. eHdown -- Printer is not printing because it is offline or a critical alert is active. Human interaction is needed to bring the printer to a ready state.")
hrdeviceerrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceerrors.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceerrors.setDescription('The number of errors detected on this device. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This is the number of critical alerts that have been entered into the alert table since the device was powered on. The maximum value for this object is 2^32-1. At power-on, this object will be set to zero.')
hrprinterstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("eHother", 1), ("eHidle", 3), ("eHprinting", 4), ("eHwarmup", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrprinterstatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrprinterstatus.setDescription("The current status of this printer device. When in the idle(1), printing(2), or warmup(3) state, the corresponding hrDeviceStatus should be running(2) or warning(3). When in the unknown state, the corresponding hrDeviceStatus should be unknown(1). Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The printer's condition is mapped as follows: eHother -- The printer is offline or a critical alert is active. eHidle -- The printer is not doing any of the items listed below for eHprinting status. eHprinting -- A job is currently being processed or printed or a PJL job is being processed. eHwarmup -- If hrDeviceStatus is eHdown, then the printer is currently offline but is resolving the condition that caused it to be offline and it will be online when it is ready to print. If hrDeviceStatus is eHrunning, then the printer was in power save mode and is now becoming ready to print. (In the HP LaserJet 3300 Series this status only occurs very briefly at boot time. At no other time does the printer report 'eHwarmup' status.)")
hrprinterdetectederrorstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrprinterdetectederrorstate.setStatus('mandatory')
if mibBuilder.loadTexts: hrprinterdetectederrorstate.setDescription("This object represents any error conditions detected by the printer. The error conditions are encoded as bits in an octet string, with the following definitions: Condition Bit # hrDeviceStatus lowPaper 0 warning(3) noPaper 1 down(5) lowToner 2 warning(3) noToner 3 down(5) doorOpen 4 down(5) jammed 5 down(5) offline 6 down(5) serviceRequested 7 warning(3) If multiple conditions are currently detected and the hrDeviceStatus would not otherwise be unknown(1) or testing(4), the hrDeviceStatus shall correspond to the worst state of those indicated, where down(5) is worse than warning(3) which is worse than running(2). Bits are numbered starting with the most significant bit of the first byte being bit 0, the least significant bit of the first byte being bit 7, the most significant bit of the second byte being bit 8, and so on. A one bit encodes that the condition was detected, while a zero bit encodes that the condition was not detected. This object is useful for alerting an operator to specific warning or error conditions that may occur, especially those requiring human intervention. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Here is the table from the general description, above, rewritten with formatting to make it more easily readable. The error conditions are encoded as bits in an octet string, with the following definitions: Condition.........Bit #......hrDeviceStatus lowPaper...........0...........warning(3) noPaper............1...........down(5) lowToner...........2...........warning(3) noToner............3...........down(5) doorOpen...........4...........down(5) jammed.............5...........down(5) offline............6...........down(5) serviceRequested...7...........warning(3) The HP LaserJet 3300 Series reports error conditions as follows: noPaper -- A tray is empty and must be filled for printing to continue. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. coverOpen -- A cover or door is open. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. jammed -- A jam condition is preventing printing. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. offline -- Printer is offline and will not accept new print jobs until it is online. This condition is rare in the HP LaserJet 3300 Series and may indicate some other error. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. serviceRequested -- Any status or error condition not listed above. These fall into two categories: (1) If the condition prevents printing, the 'offline' bit is also set and status values are as for offline. i.e.: hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. (2) If the condition does not prevent printing the status values are: hrDeviceStatus = eHwarning; hrPrinterStatus = eHidle or eHprinting; A non-critical alert is active. lowToner -- The HP LaserJet 3300 Series does not report this condition. noToner -- The HP LaserJet 3300 Series does not report this condition.")
energy_star = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 1), Integer32()).setLabel("energy-star").setMaxAccess("readonly")
if mibBuilder.loadTexts: energy_star.setStatus('optional')
if mibBuilder.loadTexts: energy_star.setDescription('Returns or changes the Energy Star sleep value. If the value is greater than zero, then the device will go into energy saving sleep mode after the print engine has been idle for the number of seconds specified by this object. A value of zero means Energy Star is disabled and the device will not go to sleep based on print engine idle time. The value must be non-negative. Additional information: The LaserJet 3300 product will always be in sleep mode when not processing data. This object will always return a value of 1.')
sleep_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("sleep-mode").setMaxAccess("readonly")
if mibBuilder.loadTexts: sleep_mode.setStatus('optional')
if mibBuilder.loadTexts: sleep_mode.setDescription('Returns eTrue if the device is in energy saving sleep mode, otherwise returns eFalse. Setting SLEEP-MODE to eFalse causes the device to wake up, if it is in sleep mode. Setting SLEEP-MODE to eTrue causes the device to go into sleep mode. Additional information: The LaserJet 3300 product will always be in sleep mode except when either processing a print job or in an error state.')
service_password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 9), Integer32()).setLabel("service-password").setMaxAccess("writeonly")
if mibBuilder.loadTexts: service_password.setStatus('optional')
if mibBuilder.loadTexts: service_password.setDescription("When set to the password value, other service related objects become 'visible' (i.e readable) and/or become writable. When written with any other value, the service related objects become 'hidden' (i.e. are no longer readable) and/or are not longer writable. The objects that can be effected by the SERVICE-PASSWORD object include: SERIAL-NUMBER and TOTAL-ENGINE-PAGE- COUNT. The password value, and the list of objects effected by the SERVICE-PASSWORD being set to the correct value, should be documented in the device POS. Additional information: The objects that can be effected by the SERVICE- PASSWORD are: SCANNER-JAM-PAGE-COUNT, SCANNER-ADF-PAGE -COUNT, SCAN-ADF-PAGE-COUNT, SCANNER-RETRIEVE-SCANLINE, SCANNER-MOTOR-CONTROL, COPIER-ADF-PAGE-COUNT, COPIER- PRINT-PAGE-COUNT, TOTAL-ENGINE-PAGE-COUNT, PRINT-ENGINE- JAM-COUNT, PRINT-ENGINE-MISPICK-COUNT")
device_config_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setLabel("device-config-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_config_token.setStatus('optional')
if mibBuilder.loadTexts: device_config_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to a specific device or subset of device capabilities. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on DEVICE-CONFIG-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing device config objects, and 2) releasing the lock when done changing device config objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on CONFIG-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing CONFIG objects, and 2) releasing the lock when done changing CONFIG objects.')
on_off_line = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOnline", 1), ("eOffline", 2)))).setLabel("on-off-line").setMaxAccess("readonly")
if mibBuilder.loadTexts: on_off_line.setStatus('optional')
if mibBuilder.loadTexts: on_off_line.setDescription('To bring the PDL processing sub-system on or off line. If the device is a printer, then the printer does not process print job data when the printer is off line. PML communication persists. Additional information: The value of this object is eOnline whenever the printer is in the ready state. This object will return eOffline only when an alert is active. For example, the printer will go eOffline if the cover is open, if the toner cartridge is removed, or if the paper trays are all empty. It is not possible to change the state of the printer with this object. ')
pysmi_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eInitiateAction", 1)))).setLabel("continue").setMaxAccess("writeonly")
if mibBuilder.loadTexts: pysmi_continue.setStatus('optional')
if mibBuilder.loadTexts: pysmi_continue.setDescription("A device can support a class of errors called continuable errors. When a continuable error is encountered, the device requires a continue event to occur before the device will continue operation. One continue event is setting the CONTINUE object to eInitiateAction. Devices can support other continue events, like auto-continue. A continue event causes the continuable error to be acknowledged, thus allowing the device to continue. Each device needs to list the continuable errors. If the device doesn't currently have an unacknowledged continuable error, the response will contain <genErr>. Additional information: Consult the LaserJet 3300 Control Panel ERS for a list of continuable errors.")
auto_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("auto-continue").setMaxAccess("readwrite")
if mibBuilder.loadTexts: auto_continue.setStatus('optional')
if mibBuilder.loadTexts: auto_continue.setDescription('Indicates if the device will automatically continue after encountering a continuable error. If AUTO- CONTINUE is set to eOn, the device will automatically generate continue event to acknowledge continuable errors. If AUTO-CONTINUE is set to eOff, then some other continue event will have to acknowledge the continuable error.')
install_date = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setLabel("install-date").setMaxAccess("readonly")
if mibBuilder.loadTexts: install_date.setStatus('optional')
if mibBuilder.loadTexts: install_date.setDescription("Identifies the date that the device was installed. The format of the string is 'YYYYMMDDHHmmZ'. Where: YYYY is the year. MM is the month (1-12). DD is the day (1-31). HH is the hour of the day (0-23). mm are the minutes (0-59). 'Z' designates Greenwich Mean Time; if 'Z' not specified, value is local time. Device POS must specify the conditions for setting this object. Additional information: This value IS AFFECTED BY NVRAM RESETS, it is set to the default value of 199000300000 when an NVRAM init is done.")
error_log_clear = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eClearErrorLog", 1)))).setLabel("error-log-clear").setMaxAccess("writeonly")
if mibBuilder.loadTexts: error_log_clear.setStatus('optional')
if mibBuilder.loadTexts: error_log_clear.setDescription("Setting this object clears all the entries in the error log sub-tree. Additional information: Setting this object removes all errors that have been stored in the printer's non-volatile memory.")
collated_originals_support = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 42), OctetString()).setLabel("collated-originals-support").setMaxAccess("readonly")
if mibBuilder.loadTexts: collated_originals_support.setStatus('optional')
if mibBuilder.loadTexts: collated_originals_support.setDescription("Indicates that the printer can create multiple, collated 'originals' of a job and shows the level of support for this capability. cCollatedOriginals - The printer can create multiple collated originals, or 'mopies'. This is the base functionality required by the other collection items. cProofAndHold - The printer saves a copy of the job while printing the first mopy. Later, this held job can be released and the rest of the mopies will print. cSecurityPrint - The printer spools the job and holds the job until the user releases the job by entering a password at the printer's control panel. cAutoHighlight - The printer prints the job a number of times with a mail distribution list prepended to each job. A different mailing address is highlighted on each mopy. cCollatedAtSpeed - The printer can create multiple collated copies where all copies after the original are printed at engine speed. Additional information: Indicates that the printer can create multiple, collated 'originals' of a job and shows the level of support for this capability. cCollatedOriginals - The printer can create multiple collated originals, or 'mopies'. This is the base functionality required by the other collection items. This is the base functionality required by the other collection items.")
model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 2), DisplayString()).setLabel("model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: model_name.setStatus('optional')
if mibBuilder.loadTexts: model_name.setDescription("Identifies the device model name (e.g. ''DeskJet 1200C''). The string is as specific as possible. Capitalization and spacing should match family naming conventions. Products should note in POS if the model name on the HP corporate price list changes but the device reports the previous device name. If the model name changes based on the installed options, the POS should indicate if only the base model name is returned, or if the device senses the installed options and returns the correct model name. If possible, encode the model name in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: The value of this object does not change based on the installed options. This default of this object is 'HP LaserJet 3300' for all configurations of the printer. Since the value of this object is frequently used in displaying a list of printers, it is kept relatively short in case systems have limited width for their display area.")
serial_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setLabel("serial-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: serial_number.setStatus('optional')
if mibBuilder.loadTexts: serial_number.setDescription('Identifies the serial number for the device. If the SERIAL-NUMBER object is set by the user, then setting the object does not need to be protected. If the SERIAL-NUMBER object is set at the factory, then the SERVICE-PASSWORD object must be set correctly before the SERIAL-NUMBER object is writable. If this is a writable object, the POS should indicate the maximum supported string length. If possible, encode the serial number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: This value IS AFFECTED BY NVRAM RESETS, it is set to the default value of XXXXXXXXXX when an NVRAM init is done.')
fw_rom_datecode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 5), DisplayString()).setLabel("fw-rom-datecode").setMaxAccess("readonly")
if mibBuilder.loadTexts: fw_rom_datecode.setStatus('optional')
if mibBuilder.loadTexts: fw_rom_datecode.setDescription('Identifies the base system firmware date code. The date code will be encoded in the yyyymmdd format. There may be several versions of the base system firmware. The date code associated with the version of the base system firmware that is being used is reported. There may be other date code objects for other specific modules such as fonts, localization modules, etc.; these other datecode objects are device specific.')
device_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 10), DisplayString()).setLabel("device-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_name.setStatus('optional')
if mibBuilder.loadTexts: device_name.setDescription('User defined device name. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 32 characters. If the user entered string is too long, the device will store the first 32 characters and will return the <noError> status.')
device_location = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 11), DisplayString()).setLabel("device-location").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_location.setStatus('optional')
if mibBuilder.loadTexts: device_location.setDescription('User defined device location. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 16 characters. If the user entered string is too long, the device will store the first 16 characters and will return the <noError> status.')
asset_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 12), DisplayString()).setLabel("asset-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: asset_number.setStatus('optional')
if mibBuilder.loadTexts: asset_number.setDescription('User defined asset number. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 8 characters. If the user entered string is too long, the device will store the first 8 characters and will return the <noError> status.')
simm1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 9))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5), ("eRamRom", 9)))).setLabel("simm1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm1_type.setStatus('optional')
if mibBuilder.loadTexts: simm1_type.setDescription("Returns an indication of the type of option installed in SIMM slot 1. eEmpty means the device did not detect any option installed in the interface slot. eUnknown means the device doesn't recognize the installed option. eUnSupported means the device recognizes the installed option, but does not support the option. eReadOnlyMemory means the installed option contains ROM Ics. eVolatileRandomAccessMemory means the installed option contains RAM ICs that loose data when the power is turned off. eNonVolatileRandomAccessMemory means that the installed option contains RAM ICs that do not loose data when the power is turned off. eFlashMemory means that the installed option contains a type of non-volatile RAM that needs to be erased before it can be written. eDiskDrive means the installed option contains a disk drive. eRamRom means the installed option contains both volatile random access memory and read only memory. eInputPHD means the installed option is an input paper handling device. eOutputPHD means the installed option is an output paper handling device. eIOCard means the installed option is an I/O card. Additional information: This object is used to describe DIMMs instead of SIMMs on the LaserJet 3300 product. eRamRom is used to denote LaserJet 3300 product's combo dimm.")
simm1_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1, 5), Integer32()).setLabel("simm1-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm1_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm1_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 1. The capacity is dependent on the type of option, as indicated by the SIMM1-TYPE object. This object has no meaning if the installed option type is eUnknown or eReadOnlyMemory. This object contains the size, in bytes, if the installed option type is eVolatileRandomAccessMemory, eNonVolatileRandomAccessMemory, eFlashMemory, or eDiskDrive. If the type of the installed option is eRamRom, this object contains the size, in bytes, of the random access memory. If the type of the installed option is eInputPHD, the capacity indicates the number of input trays supported by the installed option. If the type of the installed option is eOutputPHD, the capacity indicates the number of output bins supported by the installed option. If the type of the installed option is eIOCard, the capacity indicates the number of logical I/O ports supported by the I/O card. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM1-TYPE type is eVolatileRandomAccessMemory or eRamRom. For eRamRom only the size of the Ram portion of the simm (dimm) is returned.')
self_test = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("eNotInASelfTest", 1), ("eNonDestructiveSelfTest", 4)))).setLabel("self-test").setMaxAccess("readwrite")
if mibBuilder.loadTexts: self_test.setStatus('optional')
if mibBuilder.loadTexts: self_test.setDescription("Writing this object allows a device self test to be started. Reading this object provides an indication what self-test is currently executing, if any. Actual self-test operation is device specific. A self test may not be allowed at any arbitrary time. If the device supports the requested self test, but can not start the execution of the self test when requested, the device will respond with <genErr>. If a non-destructive self test is being started, the device will generate a response before the self test is completed. RECOMMENDATION: If the device is ready (i.e. the NOT- READY-PRINTER object does not contain any items, except maybe being off-line) and is idle (i.e. the NOT-IDLE object does not contain any items), this request should always succeed. This provides a mechanism for driver writers to always determine if the action will succeed or not. Additional information: The eNonDestructiveSelfTest performs limited testing on the printer and its attached paper handling devices. After the self-test is complete a configuration page is printed. The recommended way to cause a configuration page to be printed is to use the PRINT-INTERNAL-PAGE object. A continuous self test cannot be started or terminated using this OID. When the printer is idle, setting this object to eNonDestructiveSelfTest results in a status of <noError> and a value of eNonDestructiveSelfTest being returned. If the printer is not idle (whether printing an external job, printing an internal page or running self test), a status of <genErr> status will be returned with a value of eNotInASelfTest. When the printer is idle, setting this object to eNonDestructiveSelfTest causes the configuration page to be formatted and put in the printer's print queue. Attempting to set this object before the configuration page has completed being formatted and printed will cause <genErr> status to be returned with a value of eNotInASelfTest. After the configuration page is in the queue, a get on this object will return a value of eNotInASelfTest. Setting the value to eNotInASelfTest is not supported on the LaserJet 3300 product. Once the test has started, it will finish printing. Likewise, if the PRINT-INTERNAL-PAGE object is set to a valid value and that page has not printed when this object is set to eNonDestructiveSelfTest, a status of <genErr> status with a value of eNotInASelfTest will be returned until the internal page has printed.")
print_internal_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 8, 11, 12, 350, 450))).clone(namedValues=NamedValues(("eNotPrintingAnInternalPage", 1), ("ePrintingAnUnknownInternalPage", 2), ("eDeviceDemoPage1ConfigurationPage", 3), ("eDeviceDemoPage2", 4), ("eDeviceDemoPage6FileSystemDirectoryListing", 8), ("eDeviceDemoPage8BlockFaxList", 11), ("eDeviceDemoPage9BlockFaxLogReport", 12), ("ePCLFontList1", 350), ("ePostScriptFontList1", 450)))).setLabel("print-internal-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_internal_page.setStatus('optional')
if mibBuilder.loadTexts: print_internal_page.setDescription("Writing this object to a value other than eNotPrintingAnInternalPage causes the device to attempt to print an internally generated page. Reading this object provides an indication what internally generated page is currently being printed, if any. The actual page is device specific. Some devices may support continuously printing an internally generated page. Setting this object to eNotPrintingAnInternalPage terminates continuously printing internally generated pages. An internally generated page may not be allowed to be printed at any arbitrary time; under what conditions it will succeed or fail is device specific. If the device supports the requested page, but can not start printing the page when requested, the device will respond with <genErr>. RECOMMENDATION: If the device is ready (i.e. the NOT- READY-PRINTER object does not contain any items, except maybe being off-line) and is idle (i.e. the NOT-IDLE object does not contain any items), this request should always succeed. This provides a mechanism for driver writers to always determine if the action will succeed or not. Additional information: eDeviceDemoPage2 is the printer demo page. ePCLFontList1 is the PCL typeface list, ePostScriptFontList1 is the PostScript font list, eDeviceDemoPage1ConfigurationPage is the selftest page, eDeviceDemoPage8BlockFaxList is the list of blocked fax numbers, and eDeviceDemoPage9BlockFaxLogReport is the fax activity log (this enumeration is mis-named and should be changed to eDeviceDemoPage9FaxLogReport in the next edition of the mib). The LaserJet 3300 product does not support continuously printing a demo page. The printer will queue requests if it is currently busy. When this object is set to a valid value and the printer is idle, the status returned is <noError> and the value returned is ePrintingAnUnknownInternalPage. Setting this object to a valid value causes the desired page to be formatted and put in the printer's print queue. While the page is being formatted, and the printer remains in a testing state, a get on this object will return the value ePrintingAnUnknownInternalPage. The return value will be eNotPrintingAnInternal page if the printer is not in a testing state, and the internal page is done being formatted. The user will not be able to set eNotPrintingAnInternalPage or ePrintingAnUnknownInternalPage, and the return status will be <badValue> with a return value of eNotPrintingAnInternalPage. ePostScriptFontList1 will not be a valid value unless postscript is installed in the printer. If postscript is not installed and the user attempts to set ePostScriptFontList1, the return status will be <badValue> with a return value of eNotPrintingAnInternalPage. Setting through DMCMD will cause a 15 second delay in printing.")
job_info_change_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("job-info-change-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_change_id.setStatus('optional')
if mibBuilder.loadTexts: job_info_change_id.setDescription('Returns the current value of an object in the job-info sub-tree whose value has changed. Define the object identifier for the object whose value has changed as job-info.required-field.optional-field.job-id. job-info represents the OID prefix of all objects in the job-info sub-tree. Required-field represents the OID field value that follows the job-info prefix. Since some objects in the job-info sub-tree have two OID fields between the job-info prefix and the job-id, the optional-field represents the OID field between the required-field and the job-id field, if present. Using this definition, the format for the JOB-INFO-CHANGE-ID binary value can be described as follows: Bytes 0-3 : required-field Bytes 4-7 : optional-field, or all zeros if there is no optional field Bytes 8-11: Job ID. Bytes 12-n : The value of the object job-info. required-field.optional-field.job-id. All multi-byte values stored in Motorola (big-endian) format, where the most significant byte occurs first. Additional information: The LaserJet 3300 product will use this object to report changes of the job-info-pages-printed and job-info-state objects. The required-field (bytes 0 through 3) will designate whether the change to be reported involves the pages printed (13) or job state (15). The optional-field (bytes 4 through 7) will always be zeroes. The value-field (bytes 12 through 15) will contain the new value for pages printed or job state cast to a 32-bit integer.')
current_job_parsing_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setLabel("current-job-parsing-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: current_job_parsing_id.setStatus('optional')
if mibBuilder.loadTexts: current_job_parsing_id.setDescription("Contains the printer assigned job identification for the job currently being processed by the processing PDL sub- system. The job ID is a monotonically increasing number. The job ID may be reset to zero at power-up and may roll over to zero after reaching some maximum value. Additional information: A value of -1 is returned when the printer is not parsing a job. When data for a new job is detected, this object is updated (the job may or may not turn out to be a Null Job); however, the trap does not occur until the printer determines that it is not a Null Job. (A job is considered to be a 'null job' if it has no name or job attribute, causes no pages to be printed, and consumes MIN_JOB_SIZE (9) or fewer bytes.) A trapped value will differ from the previous value by one or more. See the Job Boundary ERS for details on what constitutes a job boundary. Some job-info- objects are created when the first data bytes are received. If the printer determines that the job is a Null Job, the job-info- objects related to the Null Job are deleted. The LaserJet 3300 product retains the job-info- objects for the MAX_JOBS_IN_LIST (12) most recent jobs that are not Null Jobs. The first job received after power-up will have job ID 1, and the job ID will increment to 32767 before rolling to zero. To distinguish whether a power cycle or a rollover causes a reduction in the job ID value, the object prtGeneralConfigChanges can be watched and if it increments at the same time as the drop is observed in the value of CURRENT-JOB-PARSING-ID, then a power cycle is the most likely cause.")
job_info_name1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 1), DisplayString()).setLabel("job-info-name1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name1.setStatus('optional')
if mibBuilder.loadTexts: job_info_name1.setDescription("Contains the first part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: The job name is the string specified by the NAME= parameter of the @PJL JOB command which allows a maximum of 80 characters. The first 40 characters are in this object and the second 40 are in job-info-name2. The symbol set is Roman-8. When jobs are nested, the value assigned to this object is the name provided by the most recent @PJL JOB NAME= command. If no name is provided, a null string is returned.")
job_info_name2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 2), DisplayString()).setLabel("job-info-name2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name2.setStatus('optional')
if mibBuilder.loadTexts: job_info_name2.setDescription("Contains the second part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: See job-info-name1-1.")
job_info_stage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 10), OctetString()).setLabel("job-info-stage").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_stage.setStatus('optional')
if mibBuilder.loadTexts: job_info_stage.setDescription("Indicates what printer sub-systems are currently processing this print job. The last OID field for this dynamic object contains the job ID. cSourceSubsystem - some of the job is in the printer I/O subsystem. cProcessingSubsystem - some of the job is in the printer imaging processing subsystem. cDestinationSubsystem - some of the job is being printed. Additional information: For the LaserJet 3300 product, cSourceSubsystem and cProcessingSubsystem will always be set and cleared together. They are set when the beginning of the job is detected, and they are cleared when the end of the job is parsed. A non-printing job will never set cDestinationSubsystem. When a page is ready to be printed (the intermediate has been built and the page is 'closed' by the personality), cDestinationSubsystem will be set even if a page of a previous job is currently being printed. cDestinationSubsystem remains set until the last page of the job has finished printing. If a page requires extensive processing and allows all the previous pages of a job to complete printing cDestinationSubsystem will remain set until the last page of the job has finished printing.")
job_info_io_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 11), Integer32()).setLabel("job-info-io-source").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_io_source.setStatus('optional')
if mibBuilder.loadTexts: job_info_io_source.setDescription('Indicates which I/O source, the print job was received over. The value maps to port numbering scheme supported in the DEVICE/SOURCE-SUBSYSTEM/IO/PORTS sub-tree. Additional information: The LaserJet 3300 product does not support the DEVICE/SOURCE-SUBSYSTEM/IO/PORTS sub-tree.')
job_info_pages_processed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 12), Integer32()).setLabel("job-info-pages-processed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_processed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_processed.setDescription("Indicates the number of pages processed by the processing subsystem. If neither the cSourceSubsystem or the cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages processed for this job. The last OID field for this dynamic object contains the job ID. Additional information: This object is incremented by one when a page is processed ('closed' by the personality), regardless of the number of pages that are printed as a result of the single page processed. In other words, it does not matter how many identical copies of a page are printed, or no pages may be printed if operating in silent run mode, this count is incremented exactly once per page processed. A page is considered processed when all of the input data has been processed for a page (that is, when the intermediate has been produced and the personality has 'closed' the page). At this time, the image of the page is not necessarily completely formed.")
job_info_pages_printed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 13), Integer32()).setLabel("job-info-pages-printed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_printed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_printed.setDescription('Indicates the number of pages printed by the destination subsystem. If non of the cSourceSubsystem, cProcessingSubsystem or cDestinationSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages printed for this job. This value may increase by two each time for duplex jobs. The last OID field for this dynamic object contains the job ID. Additional information: If multiple copies of a page are printed, each copy is counted individually.')
job_info_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 14), Integer32()).setLabel("job-info-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_size.setStatus('optional')
if mibBuilder.loadTexts: job_info_size.setDescription('Indicates the number of bytes of data processed by the processing subsystem. If neither of the cSourceSubsystem or cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the size of this job, in bytes. The last OID field for this dynamic object contains the job ID. Additional information: This count may be incremented by values other than one as blocks of data are processed; blocks of data (which may be as large as 2K bytes) will be processed in a varying amount of time. During the processing of a job and even when a job completes, an exact count of the number of I/O bytes processed by teh job is not necessarily expected.')
job_info_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 7, 10, 11))).clone(namedValues=NamedValues(("eAborted", 3), ("eWaitingForResources", 4), ("ePrinted", 5), ("eTerminating", 7), ("eCancelled", 10), ("eProcessing", 11)))).setLabel("job-info-state").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_state.setStatus('optional')
if mibBuilder.loadTexts: job_info_state.setDescription('Indicates the state of the job. The last OID field for this dynamic object contains the job ID. eAborted - the print job was aborted. eWaitingForResources - the print job requires resources that are not currently available. Example resources that can cause the job to wait include the print engine or PDL processor being unavailable. The print engine could be unavailable due to paper out, paper jam, staple out, stapler jam, marking agent low, output bin full, etc. The PDL processor could be unavailable due to an off-line condition. Each printer specific object specification should state which conditions cause a job to be waiting for resources and also state which objects can be retrieved by an application to determine the exact cause of a resource being unavailable. ePrinted - the job has printed. The related JOB-INFO- OUTCOME object indicates if any problems were encountered while the job was processed. eRetained - the job can be reprinted. eTerminating - the job was aborted or cancelled and is currently is terminating. eInterrupted - the job has been interrupted. The job can be continued. ePaused - the job has been paused. The job can be continuted. eCancelled - the job has been cancelled. eProcessing - the job is currently being printed normally.')
job_info_outcome = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("eOk", 3)))).setLabel("job-info-outcome").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outcome.setStatus('optional')
if mibBuilder.loadTexts: job_info_outcome.setDescription('Indicates if any warning or error conditions were encountered while processing the assoicated job. The last OID field for this dynamic object contains the job ID. Additional information: In the LaserJet 3300 product, warnings and errors are not recorded in this object. Although no meaningful information can be obtained from this object, it is kept around for the compatibility needs of existing software.')
job_info_outbins_used = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 20), OctetString()).setLabel("job-info-outbins-used").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outbins_used.setStatus('optional')
if mibBuilder.loadTexts: job_info_outbins_used.setDescription('Indicates which output bins this job has delivered printed pages to. The last OID field for this dynamic object contains the job ID. Additional information: The LaserJet 3300 product has only 1 output bin. cOutbin1 is the top/face-down bin.')
job_info_physical_outbins_used = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 22), OctetString()).setLabel("job-info-physical-outbins-used").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_physical_outbins_used.setStatus('optional')
if mibBuilder.loadTexts: job_info_physical_outbins_used.setDescription('Indicates which physical output bins this job has delivered printed pages to. The last OID field for this dynamic object contains the job ID. Additional information: The LaserJet 3300 product only has one output bin so this will always be set to cOutbin1. cOutbin1--Face-up bin')
job_info_attr_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_1.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_1.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. Attribute objects are saved sequentially, starting with 1, after the start of a job. If more attributes are set than there are objects to store them, the excess JOBATTR values are ignored. If the corresponding SET JOBATTR= command has not been received when a get is done for this object, a status of <noSuchName> will be returned.')
job_info_attr_2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_2.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_2.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_3 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-3").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_3.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_3.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-4").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_4.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_4.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_5 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-5").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_5.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_5.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_6 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-6").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_6.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_6.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_7 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-7").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_7.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_7.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_8 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-8").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_8.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_8.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_9 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-9").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_9.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_9.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_10 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-10").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_10.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_10.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_11 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-11").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_11.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_11.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_12 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-12").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_12.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_12.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_13 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-13").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_13.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_13.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_14 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-14").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_14.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_14.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_15 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-15").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_15.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_15.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_16 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-16").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_16.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_16.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
error1_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 1), Integer32()).setLabel("error1-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error1_time_stamp.setDescription("Contains some sort of time stamp indicating when error 1 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: This item contains the engine page count when the error occurred. If there is currently no error entry for this object, a '0' will be returned. If ERROR1-CODE object also returns '0', then an error has not yet been logged for this object See ERROR1-CODE for an explanation of the order used for storing errors.")
error1_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 2), Integer32()).setLabel("error1-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_code.setStatus('optional')
if mibBuilder.loadTexts: error1_code.setDescription("Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: Returns a device specific error code. If the error code returned is '0', then the printer has not yet logged an error for this object. When the maximum number of errors is reached (10 on the LaserJet 3300 product), and a new error occurs, the error in ERROR1-CODE will be replaced by the one in ERROR2-CODE, and so on until the last error object will be given the value of the new error. The error category is returned in the upper 16 bits, either 79 (for service) or 0 (for support). The lower 16 bits encodes the specific error. If an error is not a 79 service error, the value of this object is the PJL USTATUS code. If it is a 79 service error, the lower 16 bits contain the PJL USTATUS code. The types of errors reported for the LaserJet 3300 product are: Page Punt (21 Print Overrun) 49 Service Error 50-67 Service Error 69 Service Error 70-72 Service Error 79 Service Errors Beam Detect Malfunction Laser Malfunction Engine Communication Error Bad Fan Motor Bad Scanner Motor Bad Beam Detect Bad Fuser NVRAM Error NVRAM Service")
error2_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 1), Integer32()).setLabel("error2-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error2_time_stamp.setDescription('Contains some sort of time stamp indicating when error 2 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error2_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 2), Integer32()).setLabel("error2-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_code.setStatus('optional')
if mibBuilder.loadTexts: error2_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error3_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 1), Integer32()).setLabel("error3-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error3_time_stamp.setDescription('Contains some sort of time stamp indicating when error 3 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error3_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 2), Integer32()).setLabel("error3-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_code.setStatus('optional')
if mibBuilder.loadTexts: error3_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error4_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 1), Integer32()).setLabel("error4-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error4_time_stamp.setDescription('Contains some sort of time stamp indicating when error 4 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error4_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 2), Integer32()).setLabel("error4-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_code.setStatus('optional')
if mibBuilder.loadTexts: error4_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error5_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 1), Integer32()).setLabel("error5-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error5_time_stamp.setDescription('Contains some sort of time stamp indicating when error 5 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error5_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 2), Integer32()).setLabel("error5-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_code.setStatus('optional')
if mibBuilder.loadTexts: error5_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error6_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 1), Integer32()).setLabel("error6-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error6_time_stamp.setDescription('Contains some sort of time stamp indicating when error 6 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error6_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 2), Integer32()).setLabel("error6-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_code.setStatus('optional')
if mibBuilder.loadTexts: error6_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error7_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 1), Integer32()).setLabel("error7-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error7_time_stamp.setDescription('Contains some sort of time stamp indicating when error 7 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error7_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 2), Integer32()).setLabel("error7-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_code.setStatus('optional')
if mibBuilder.loadTexts: error7_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error8_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 1), Integer32()).setLabel("error8-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error8_time_stamp.setDescription('Contains some sort of time stamp indicating when error 8 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error8_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 2), Integer32()).setLabel("error8-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_code.setStatus('optional')
if mibBuilder.loadTexts: error8_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error9_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 1), Integer32()).setLabel("error9-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error9_time_stamp.setDescription('Contains some sort of time stamp indicating when error 9 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error9_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 2), Integer32()).setLabel("error9-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_code.setStatus('optional')
if mibBuilder.loadTexts: error9_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error10_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 1), Integer32()).setLabel("error10-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error10_time_stamp.setDescription('Contains some sort of time stamp indicating when error 10 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error10_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 2), Integer32()).setLabel("error10-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_code.setStatus('optional')
if mibBuilder.loadTexts: error10_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
io_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300))).setLabel("io-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: io_timeout.setStatus('optional')
if mibBuilder.loadTexts: io_timeout.setDescription('The amount of time, in seconds, to wait for more print job data to be received before an I/O timeout occurs. The I/O channel being timed is the I/O channel that received the data associated with the current print job. If an I/O timeout occurs, the PDL processing sub-system assumes all the data associated with the current print job has been received, and processes the end of job in an PDL specific manner. The POS specifies the supported values. Additional information: If an I/O timeout occurs,the PDL processing sub-system will consider it an end of job condition only if there is data from another I/O subsystem waiting to be processed. The supported values are 5 to 300 seconds. Setting to a value outside the supported range returns <badValue> status.')
io_switch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eYes", 1)))).setLabel("io-switch").setMaxAccess("readonly")
if mibBuilder.loadTexts: io_switch.setStatus('optional')
if mibBuilder.loadTexts: io_switch.setDescription('Indicates if the device will switch between I/O channels when a job boundary is encountered and print job data is available on another I/O channel.')
default_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setLabel("default-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_copies.setStatus('optional')
if mibBuilder.loadTexts: default_copies.setDescription('Returns or changes default copies. Default copies is the default values used by the PDL to control the number of copies of each page in the print job that are printed. The print job can override this value. The list of supported values should be documented in the device POS. Additional information: The supported values are 1 through 999. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snaps are as follows: <1 snaps to 1 >999 snaps to 999')
form_feed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eInitiateAction", 1)))).setLabel("form-feed").setMaxAccess("writeonly")
if mibBuilder.loadTexts: form_feed.setStatus('optional')
if mibBuilder.loadTexts: form_feed.setDescription('Instructs the PDL processing sub-system to finishing processing the current page of the current job. Form feed is also known as close page or eject page. If the PDL processing sub-system is in a FORM-FEED-NEEDED state, this causes the device to flush or finish processing the current page of the current job. If the device is not in the FORM-FEED-NEEDED state, an <genErr> will occur.')
maximum_resource_saving_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 7), Integer32()).setLabel("maximum-resource-saving-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: maximum_resource_saving_memory.setStatus('optional')
if mibBuilder.loadTexts: maximum_resource_saving_memory.setDescription("This object's name is misleading. This object returns the maximum amount of additional memory, in bytes, that can be dedicated to holding PDL permanent soft resources. Additional information: For a PCL-only printer, the value of this object is zero (all resource saving memory is dedicated to PCL).")
default_vertical_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 8), Integer32()).setLabel("default-vertical-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vertical_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_vertical_black_resolution.setDescription('Returns or changes the value of the default vertical black resolution. The units are dots per inch. Additional information: In the LaserJet 3300 product, changing this OID also causes DEFAULT-HORIZONTAL-BLACK RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported values are 300, 600, and 1200. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <450 will snap to 300 >=450 and <900 will snap to 600 >=900 will snap to 1200')
default_horizontal_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 9), Integer32()).setLabel("default-horizontal-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_horizontal_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_horizontal_black_resolution.setDescription('Returns or changes the value of the default horizontal black resolution. The units are dots per inch. Additional information: In the LaserJet 3300 product, changing this OID also causes DEFAULT-VERTICAL-BLACK RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported values are 300, 600 and 1200. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <450 snaps to 300 >=450 and <900 snaps to 600 >=900 snaps to 1200')
default_page_protect = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("eOn", 2), ("eAuto", 3)))).setLabel("default-page-protect").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_page_protect.setStatus('optional')
if mibBuilder.loadTexts: default_page_protect.setDescription('Returns or changes the default page protection behavior. If eOff, the device does not reserve memory for holding the entire raster form of a processed page. If eOn, then memory is reserved. If eAuto, the device determines the amount of memory to reserve. Additional information: Setting to eOn causes MET to be more conservative, but it will not allocate memory to hold an entire rasterized page.')
default_lines_per_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 11), Integer32()).setLabel("default-lines-per-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_lines_per_page.setStatus('optional')
if mibBuilder.loadTexts: default_lines_per_page.setDescription('Returns or changes the default number of lines per page. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return the <noError>. Additional information: The supported values in the LaserJet 3300 product are 5 to 128. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <5 snaps to 5 >128 snaps to 128')
default_vmi = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 12), Integer32()).setLabel("default-vmi").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vmi.setStatus('optional')
if mibBuilder.loadTexts: default_vmi.setDescription('Returns or changes the default vertical motion index. The unit of measure for VMI is centipoints per line. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. Additional information: Setting this object may cause DEFAULT-LINES-PER-PAGE to change.')
default_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 17, 26, 25, 45, 71, 72, 80, 81, 90, 91, 100, 101))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eROC16K", 17), ("eISOandJISA4", 26), ("eISOandJISA5", 25), ("eJISB5", 45), ("eJapanesePostcardSingle", 71), ("eJapanesePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101)))).setLabel("default-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_media_size.setStatus('optional')
if mibBuilder.loadTexts: default_media_size.setDescription("This indicates the default media size. A write of an unsupported value causes an <badValue>. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document.")
cold_reset_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eISOandJISA4", 26)))).setLabel("cold-reset-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: cold_reset_media_size.setStatus('optional')
if mibBuilder.loadTexts: cold_reset_media_size.setDescription('Returns or sets the media size that is used as the DEFAULT-MEDIA-SIZE when a cold reset occurs.')
reprint = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2), ("eAuto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reprint.setStatus('optional')
if mibBuilder.loadTexts: reprint.setDescription('Returns or changes the reprint (jam recovery) setting. If eOn, then the device will reprint pages jammed pages. If eOff, the device will not attempt to reprint jammed pages. If eAuto, a device dependent algorithm (which should be documented in the POS) will be used to determine if the page gets reprinted. This object controls all PDLs, unless a specific PDL supports its own reprint control mechanism. To date, only PostScript has a PDL reprint control mechanism. Additional information: Setting this object when the printer is not idle, may cause a status of <noError> to be returned, but the new value will not take effect until a job boundary is reached. If a get is done on object before the job boundary is reached, the value last set will be returned. When the value is set to eOff, pages will not be stored in the printer, and in the event of a paper jam, will have to be reprinted. When the value is set to eOn, pages will be stored until delivery, therefore, in the event of a paper jam, the page will be reprinted. When the value is set to eAuto, the printer will behave as though it is eOff when there is less than seven megabytes of memory installed in the printer. When additional memory is installed, to total at least seven megabytes of RAM, the setting of eAuto will behave as though it was set to eOn.')
wide_a4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("wide-a4").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wide_a4.setStatus('optional')
if mibBuilder.loadTexts: wide_a4.setDescription('Returns or changes the wide A4 logical page size setting. If eOn, then the margins/printable area of A4 paper will be changed to allow 80 10-pitch characters to be printed on a single line. If eOff then the industry standard A4 logical page size is used.')
dark_courier = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("dark-courier").setMaxAccess("readwrite")
if mibBuilder.loadTexts: dark_courier.setStatus('optional')
if mibBuilder.loadTexts: dark_courier.setDescription('Returns or changes the dark Courier setting. If eOn, then the Courier font used will approximate the same darkness as the LaserJet III printer. If eOff, then the Courier font used will approximate the same darkness as the LaserJet 4 printer.')
default_bits_per_pixel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 39), Integer32()).setLabel("default-bits-per-pixel").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_bits_per_pixel.setStatus('optional')
if mibBuilder.loadTexts: default_bits_per_pixel.setDescription('Controls the number of levels used (per pixel) when printing grayscale or color images.')
form_feed_needed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("form-feed-needed").setMaxAccess("readonly")
if mibBuilder.loadTexts: form_feed_needed.setStatus('optional')
if mibBuilder.loadTexts: form_feed_needed.setDescription("Indicates if the PDL processing sub-system has made marks on the current page and the source subsystem has been idle for a device specific amount of time. Additional information: The LaserJet 3300 product will set this object to eTrue when it has made marks on the current page, the IO-TIMEOUT has expired while PCL was running in 'backward-compatibility mode' (which is caused by jobs consisting purely of PCL data with no prepended PJL commands), and no data is pending on another I/O. Once it is set to eTrue, more data on the same I/O will cause this object to be set to eFalse, until the above conditions are met again.")
pcl_resource_saving_memory_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 2), Integer32()).setLabel("pcl-resource-saving-memory-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_resource_saving_memory_size.setStatus('optional')
if mibBuilder.loadTexts: pcl_resource_saving_memory_size.setDescription('Returns or changes the amount of resource saving memory set aside to hold permanent soft PCL resources. Additional information: The value returned by this object is the amount of Resource Saving memory currently dedicated to PCL, regardless of the value of RESOURCE-SAVING. For a PCL-only printer, the value of this object is zero. All memory is dedicated to PCL, but it is not shown as such. If PostScript is installed, the default value of this object is as follows: 0 if RESOURCE-SAVING=eOff. 0 if <12M memory is installed. 400K if >=12M memory is installed and RESOURCE-SAVING=eOn. 400K if =12M memory is installed and RESOURCE-SAVING=eAuto. plus 100K for each 1M over 12M memory installed. If RESOURCE-SAVING=eOn, this object can be used to set the amount of Resource Saving memory currently dedicated to PCL. The range of values supported by this object are: 0 (disables resource saving for PCL). 400K bytes through (400K bytes + value of MAXIMUM-RESOURCE-SAVING-MEMORY) in increments of 100K bytes. If a value is received that is greater than 0 and less than 400K bytes, it will be snapped to 400K bytes and a status of <noError> will be returned. If an unsupported value greater than 400K bytes is received, it will be snapped down to the nearest 100K value and a status of <noError> will be returned. Attempting to set this object when RESOURCE-SAVING is eAuto or eOff will cause a status of <genErr> to be returned.')
pcl_default_font_height = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 13), Integer32()).setLabel("pcl-default-font-height").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_height.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_height.setDescription("Returns or changes the default PCL height. Height is an approximate measure of the body of the type in centipoints. A centipoint is 1/7200 inch. Height applies only to proportional fonts. Point size, in points, can be converted to font height, in centipoints, by multiplying the point size by 100. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. ''Closest'' means the smallest absolute difference. Additional information: This object refers to the font point size with 400 representing the smallest settable font (4) and 99975 representing the largest settable font (999.75). The default of 1200 is a font point size of 12. Supported values range from 400 to 99975. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <=400 snaps to 400 >=99975 snaps to 99975 Fonts are settable to the nearest quarter point size (i.e. 10, 10.25, 10.50, 10.75). Unsupported values in the range 401 to 99974 snap DOWN to the previous supported value (i.e 25293 snaps to 25275 or 75038 snaps to 75025).")
pcl_default_font_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10))).clone(namedValues=NamedValues(("eInternal", 1), ("ePermanentSoft", 2), ("eRomSimm1", 10)))).setLabel("pcl-default-font-source").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_source.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_source.setDescription('Returns or changes the value of the default font source variable in NVRAM.')
pcl_default_font_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setLabel("pcl-default-font-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_number.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_number.setDescription('Returns or changes the value of the default font number variable in NVRAM. Writing an unsupported value causes the printer to generate an <badValue>. Additional information: Valid numbers or 0 - 255, but only font numbers that are included in the PCL FONT LIST are selectable.')
pcl_default_font_width = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 16), Integer32()).setLabel("pcl-default-font-width").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_width.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_width.setDescription("Returns or changes the default PCL font width. Width is expressed as the width of a character in centipoints. A centipoint is 1/7200 inch. Width applies only to fixed space fonts. Pitch, in character per inch, can be converted to font width, in centipoints, by dividing 7200 by the pitch. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. ''Closest'' means the smallest absolute difference. Additional information: Setting to an unsupported value causes the printer to substitue in a snap value (listed below) and return <noError> status. The snap values for pitch are as follow: <=44 snaps to 44 >=9999 snaps to 9999 Unsupported values in the range 44 - 9999 (.44 - 99.99) snap DOWN to the next supported value.")
pjl_password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 5, 1), Integer32()).setLabel("pjl-password").setMaxAccess("readonly")
if mibBuilder.loadTexts: pjl_password.setStatus('optional')
if mibBuilder.loadTexts: pjl_password.setDescription('Returns PJL password, if the password is not set (zero). If the password is set, then attempting to retrieve the password causes an <genErr> to occur and will return the <NullValue>.')
override_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 17, 26, 25, 45, 71, 72, 80, 81, 90, 91, 100, 101))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eROC16K", 17), ("eISOandJISA4", 26), ("eISOandJISA5", 25), ("eJISB5", 45), ("eJapanesePostcardSingle", 71), ("eJapanesePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101)))).setLabel("override-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: override_media_size.setStatus('optional')
if mibBuilder.loadTexts: override_media_size.setDescription('Sets the media size that is to be used in place of the currently requested media size. Additional information: When a request is received to print on a size and type of media that is not currently available this object contains the desired size as set by the print job. This object should be set to a media size that is currently available to the printer. If a paper mount request is not pending, attempting to get or set this object will cause <noSuchName> to be returned.')
print_density = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setLabel("print-density").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_density.setStatus('optional')
if mibBuilder.loadTexts: print_density.setDescription('Returns or sets the print density setting. Print density is the instantaneous amount of marking agent applied to the paper while printing. A value of zero has the lowest print density, yielding a lighter page. A value of 10 has the highest print density, yielding a darker page. Each POS should document what values in the 0 to 10 range are supported. Additional information: When this value is written, the page pipeline will be flushed (all pages being printed are completed, no new ones are started), the new density setting is set and printing resumes. The acutal change in print density may be gradual over several pages. The supported values are 1 through 5. Setting to an unsupported value causes the printer to substitue in a a snap value and to return <noError> status. The snap values are as follows: <1 snaps to 1 >5 snaps to 5.')
total_engine_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 5), Integer32()).setLabel("total-engine-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: total_engine_page_count.setStatus('optional')
if mibBuilder.loadTexts: total_engine_page_count.setDescription('Total number of pages printed by the device. POS indicates if the total engine page count is kept in NVRAM, and the maximum supported value before the page count rolls over to zero. Additional information: This object is stored in NVRAM. The maximum value of this count is 1000000 before it rolls over to zero.')
print_engine_jam_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 34), Integer32()).setLabel("print-engine-jam-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_engine_jam_count.setStatus('optional')
if mibBuilder.loadTexts: print_engine_jam_count.setDescription("Total number of pages jammed in the print engine's life time. The POS indicates if the total jam count is kept in NVRAM and the maximum supported value before the jam count rolls over to zero. Additional information: This object is stored in NVRAM. The maximum value of this count is 65000 before it rolls over to zero.")
print_engine_mispick_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 35), Integer32()).setLabel("print-engine-mispick-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_engine_mispick_count.setStatus('optional')
if mibBuilder.loadTexts: print_engine_mispick_count.setDescription("Total number of pages mispicked in the print engine's life time. The POS indicates if the total mispick count is kept in NVRAM and the maximum supported value before the mispick count rolls over to zero. Additional information: This object is stored in NVRAM. The maximum value of this count is 65000 before it rolls over to zero.")
custom_paper_dim_unit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("eTenThousandthsOfInches", 3), ("eMicrometers", 4)))).setLabel("custom-paper-dim-unit").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_dim_unit.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_dim_unit.setDescription("The units of measure used to specify the width and height of the printer's custom paper. The unit of measure of eTenThousandthsOfInches is 0.0001 inches. Additional information: The only valid values for this object are eTenThousandthsOfInches (3), and eMicrometers (4). The data for this object is stored in NVRAM.")
custom_paper_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 8), Integer32()).setLabel("custom-paper-feed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_feed_dim.setDescription("Sets the printer's custom paper dimension in the feed direction (direction parallel to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: The valid range is 50000 to 140000 if CUSTOM-PAPER_DIM_UNIT is eTenThousandthsOfInches or 127000 to 355600 if CUSTOM-PAPER-DIM-UNIT is ePmicrometers. Attempts to set this object outside the valid range will result in a return value of ERROR_INVALID_OR_UNSUPPORTED_VALUE.")
custom_paper_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 9), Integer32()).setLabel("custom-paper-xfeed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setDescription("Sets the printer's custom paper dimension in the cross- feed direction (direction ninety degrees relative to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: The valid range for Brundage is 30000 to 85000 if CUSTOM-PAPER-DIM-UNIT is eTenThousandthsOfInches or 76200 to 216000 if CUSTOM-PAPER-DIM-UNIT is ePmicrometers. Attempts to set this object outside the valid range will result in a return value of <badValue>.")
tray1_fuser_temperature = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setLabel("tray1-fuser-temperature").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray1_fuser_temperature.setStatus('optional')
if mibBuilder.loadTexts: tray1_fuser_temperature.setDescription('The fuser temperature to be used when printing media from Tray 1. The value zero is the default temperature. Values less than zero are progressively lower and values greater than zero are progressively higher. The range of values supported is device specific. Additional information: LaserJet 3300 product supports 4 fuser temperatures. Zero (0) is the default temperature, one(1) is a higher temperature (for use on media like cardstock), two(2) is an even higher temperature (for use on rough media), negative one (-1) is a lower temperature (for use on media like transparencies). Setting to an unsupported value causes the printer to snap to the nearest supported value and to return <noError> status along with the actual value that was written. The snap values are as follows: <=-1 snaps to -1 >=2 snaps to 2')
default_ret = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eOff", 1), ("eLight", 2), ("eMedium", 3), ("eDark", 4)))).setLabel("default-ret").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_ret.setStatus('optional')
if mibBuilder.loadTexts: default_ret.setDescription('Returns or changes the Resolution Enhancement Technology setting. Devices that only support eOff and on should map all other values to on and always return the same non-eOff value to indicate on. The list of supported values should be documented in the device POS.')
default_print_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setLabel("default-print-quality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_print_quality.setStatus('optional')
if mibBuilder.loadTexts: default_print_quality.setDescription('Returns or sets the default print quality. A value of zero has the lowest print quality. A value of 100 has the highest print quality. Each POS should document what values in the 0 to 100 range are supported. Additional information: The LaserJet 3300 product supports DEFAULT-PRINT-QUALITY in 300, 600, 1200 and 1200SB dpi. In the LaserJet 3300 product, the supported values are 0 and 100. A value of zero has the lowest print quality (ECONOMODE=ON), thus minimizes the amount of toner used to print a page. A value of 100 has the highest print quality (ECONOMODE=OFF), thus uses more toner to print a page. Setting to an unsupported value outside of the 0 to 100 range causes the printer to return <badValue> status. Setting to an unsupported value inside of the 0 to 100 range causes the printer to substitute in a snap value (listed below) and to return <noError> status. The snap values are as follow: 0 to 50 snaps to 0 51 to 100 snaps to 100')
channel_bytes_sent = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 2), Integer32()).setLabel("channel-bytes-sent").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_bytes_sent.setStatus('optional')
if mibBuilder.loadTexts: channel_bytes_sent.setDescription('The low order 31 bits of the number of bytes sent from the printer to the host on this logical channel.')
channel_bytes_received = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 3), Integer32()).setLabel("channel-bytes-received").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_bytes_received.setStatus('optional')
if mibBuilder.loadTexts: channel_bytes_received.setDescription('The low order 31 bits of the number of bytes received by the printer from the host on this logical channel.')
channel_io_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 4), Integer32()).setLabel("channel-io-errors").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_io_errors.setStatus('optional')
if mibBuilder.loadTexts: channel_io_errors.setDescription('The low order 31 bits of the number of I/O errors which have occured on this logical channel.')
channel_jobs_received = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 5), Integer32()).setLabel("channel-jobs-received").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_jobs_received.setStatus('optional')
if mibBuilder.loadTexts: channel_jobs_received.setDescription('The low order 31 bits of the number of print jobs which have been received on this logical channel.')
scan_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setLabel("scan-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_token.setStatus('optional')
if mibBuilder.loadTexts: scan_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to a scanner device. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on SCAN-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing scan objects, and 2) releasing the lock when done changing scan objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on SCAN-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing scan objects, and 2) releasing the lock when done changing scan objects.')
scan_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("scan-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_contrast.setStatus('optional')
if mibBuilder.loadTexts: scan_contrast.setDescription("Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the scanner contrast level. Range is 0..100. Additional information: There are 11 different tonemap that will be used on scan images to change the contrast. Software can set the contrast setting to -125, -100, -75, -50, -25, 0, 50, 75, 100, and 125 to select the different tonemaps. A user can also set the value to -127, which is a special mode used by manufacturing to tell the device to use all linear tonemaps and to perform no gamma correction. The scan pml object does not snap the pml scan-contrast. However, the contrast setting is mapped to the correct tonemap within the device.")
scan_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setLabel("scan-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_resolution.setStatus('optional')
if mibBuilder.loadTexts: scan_resolution.setDescription("struct { unsigned_32bit x_res; /* 1st four bytes; big endian */ unsigned_32bit y_res; /* 2nd four bytes; big endian */ } Sets the scanning resolution. The x and y resolutions in this object are in fixed-point with 16 bits of fraction, and 16 bits of integer, and are in dots per inch. X is horizontal; Y is vertical. Examples of computing x_res and y_res: 300 dots/inch:round(300 * 65536) = 19660800 16 dots/mm: round(16 * 25.4 * 65536) = 26633830. If the device does not support the given combination, then it'll select the nearest supported values in a device-dependent manner (documented in the POS). Additional information: The LaserJet 3300 device will support only: 75, 100, 150, 200, 300 and 600. The Host SW may scale the image to many more resolutions. If an invalid resolution setting is passed to the device or the setting is greater than the max value(600ppi), the device will set the resolution to the default value. If the resolution setting is not 75, 100, 150, 200, 300 or 600, the value is snapped up. For instance, if the value is < 75, the resolution is snapped to 75. If the value is between 101-149, the value is snapped to 150, etc. NOTE: The last 16 bits of the horizontal and vertical settings are ignored. Only the first 16 bits of the horizontal and vertical resolution setting are used.")
scan_pixel_data_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 24))).clone(namedValues=NamedValues(("eBiLevelThesholded", 1), ("eGrey256", 8), ("e24BitColor", 24)))).setLabel("scan-pixel-data-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_pixel_data_type.setStatus('optional')
if mibBuilder.loadTexts: scan_pixel_data_type.setDescription('Sets the method used when scanning. eBiLevelThesholded - One bit per pixel, using simple thresholding of greyscale scan data. eBiLevelHalfToned - One bit per pixel, using some kind of half-toning technique (such as dithering or error- diffusion) to approximate greyscale scan data. eGrey16 - 4 bits per pixel to represent 16 shades of grey. eGrey64 - 6 bits per pixel to represent 64 shades of grey. e3BitColor - 1 bit thresholded per Red, Green, and Blue plane. eGrey128 - 7 bits per pixel to represent 128 shades of grey. eGrey256 - 8 bits per pixel to represent 256 shades of grey. e24BitColor - 24 bits per pixel, 8 bits for Red, 8 bit for Green, and 8 bits for Blue.')
scan_compression = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6))).clone(namedValues=NamedValues(("eCompressNone", 1), ("eCompressDefault", 2), ("eCompressionMMR", 5), ("eCompressionJPEG", 6)))).setLabel("scan-compression").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_compression.setStatus('optional')
if mibBuilder.loadTexts: scan_compression.setDescription('Indicates the type of data compression applied to the image data in the scanning upload session.')
scan_compression_factor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setLabel("scan-compression-factor").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_compression_factor.setStatus('optional')
if mibBuilder.loadTexts: scan_compression_factor.setDescription('Indicates the level of compression to be applied to the scanned image data for upload. Range is normalized to be between 0..100. The device POS determines the mapping of the normalized scale to the actual Q factor for JPEG. Additional information: The LaserJet 3300 will use the SCAN-COMPRESSION-FACTOR for JPEG as described above in the General Description.')
scan_upload_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 6), Integer32()).setLabel("scan-upload-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_upload_error.setStatus('optional')
if mibBuilder.loadTexts: scan_upload_error.setDescription('Error status of the image scanning upload session.')
scan_upload = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eScanUploadIdle", 1), ("eScanUploadStart", 2), ("eScanUploadActive", 3), ("eScanUploadAborted", 4), ("eScanUploadDone", 5), ("eScanUploadNewPage", 6)))).setLabel("scan-upload").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_upload.setStatus('optional')
if mibBuilder.loadTexts: scan_upload.setDescription('Handshake mechanism between host and device to initiate scan operation and coordinate the transfer of scanned image data to the host. This object serves both as an indicator of scan upload activity as well as a trigger for the host to alter scan upload progress. The handshake is on a per page basis to allow greater host control. eScanUploadIdle - indicates the scan upload activity is not occurring. Host setting this object to eScanUploadIdle from eScanUploadActive will cause the scan upload activity to be prematurely terminated. Host may set object to this state at any time. Device sets object to this state only upon initial power up but will otherwise never set to this state of its own accord. eScanUploadStart - indicates host requesting to commence a scan to host operation. Host may set object to this state from eScanUploadIdle or eScanUploadNewPage. Device will not set object to this state of its own accord. eScanUploadActive - indicates scan upload activity is occurring. The device sets object to this state to indicate host may commence receiving scanned image data. During this state, the device will be writing scanned image data to the I/O channel. eScanUploadAborted - indicates the scanning and scan upload activity has terminated in error state. This value is set by the device. This state is not settable by the host. The host should transition this state to eScanUploadIdle. eScanUploadDone - indicates the device is signaling successful completion of scan upload activity and there are no more document pages in the scanner/ADF. The application should set this object to eScanUploadIdle. eScanUploadNewPage - indicates the device is signaling successful completion of scan upload activity for the current page and there remains at least one page in the scanner/ADF available for scanning. Host may choose to begin scan upload cycle by setting object to eScanUploadStart or end the cycle by setting object to eScanUploadIdle. Additional information: eScanUploadNewPage - indicates the device is signaling successful completion of scan upload activity for the current page. There may be a page in the device or not. The device will wait to prefeed another page until the application sets the object to eScanUploadStart. This was to fix a bug on Timberline that a prefed page would cause a jam if the application set the object to eScanUploadIdle. The application could not create another scan job until the prefed page was removed. Host may choose to begin scan upload cycle by setting object to eScanUploadStart or end the cycle by setting object to eScanUploadIdle.')
default_scanner_margin_left = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5088))).setLabel("default-scanner-margin-left").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_scanner_margin_left.setStatus('optional')
if mibBuilder.loadTexts: default_scanner_margin_left.setDescription('Sets the left scanner margin. The unit of measure should be documented in the device POS. Additional information: The margin value must be a multiple of 4 for alignment reasons. If the entered value is not a multiple of 4, the resolution value will be snapped down to the closest value divisible by 4.')
default_scanner_margin_right = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 5120))).setLabel("default-scanner-margin-right").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_scanner_margin_right.setStatus('optional')
if mibBuilder.loadTexts: default_scanner_margin_right.setDescription('Sets the right scanner margin. The unit of measure should be documented in the device POS. Additional information: The margin value must be a multiple of 4 for alignment reasons. If the entered value is not a multiple of 4, the resolution value will be snapped down to the closest value divisible by 4.')
ui_add_option = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 37), DisplayString()).setLabel("ui-add-option").setMaxAccess("writeonly")
if mibBuilder.loadTexts: ui_add_option.setStatus('optional')
if mibBuilder.loadTexts: ui_add_option.setDescription("Lets the host application set up target (eg.scan) destinations. The destinations can be a host network address and/or an application to be launched on that host. The string sent down has a list of 'KEYWORD=value;' items. The data sent down also contains a string to be displayed in the device LCD display. The device POS specifies the number of strings that can be handled (eg. 20) and the replacement/expiration policy as new target destinations are added. Additional information: For push scanning on the LaserJet 3300, there will be a limitation to the number of unique strings sent to the device via UI-ADD-OPTION. A host registers for push scanning by using the UI-ADD-OPTION object. Gecko will limit the number of hosts registered for push scanning to 20. Sockeye will have a limitation of 1. Another limitation for the LaserJet 3300 is that the DISPLAY value must be at most 18 characters. This limitation is due to the control panel display. ")
ui_select_option = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 38), DisplayString()).setLabel("ui-select-option").setMaxAccess("readonly")
if mibBuilder.loadTexts: ui_select_option.setStatus('optional')
if mibBuilder.loadTexts: ui_select_option.setDescription('Triggers a job from the device based on the option selected.')
ui_delete_option = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 42), DisplayString()).setLabel("ui-delete-option").setMaxAccess("writeonly")
if mibBuilder.loadTexts: ui_delete_option.setStatus('optional')
if mibBuilder.loadTexts: ui_delete_option.setDescription('Lets the host application delete target eg. scan destinations that were setup with UI-ADD-OPTION. The host sends down the entire string that was sent earlier. The firmware looks for an exact match in its lists and deletes the requested option. Additional information: Removes an existing option only if it is uniquely matched by the given object value.')
scanner_jam_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 43), Integer32()).setLabel("scanner-jam-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_jam_page_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_jam_page_count.setDescription("Indicates a count of the total pages jammed in the scanner'slifetime.")
scanner_adf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 44), Integer32()).setLabel("scanner-adf-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_adf_page_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_adf_page_count.setDescription('Indicates a count of the total pages scanned through the ADF on the device. This may include scan to host jobs, copyjobs, and fax jobs. If only the total pages scanned to the host are wanted, use SCAN-ADF-PAGE-COUNT.')
scan_adf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 45), Integer32()).setLabel("scan-adf-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_adf_page_count.setStatus('optional')
if mibBuilder.loadTexts: scan_adf_page_count.setDescription('Indicates the total pages scanned through the ADF to the host from the device. If the total pages scanned through the scanner are needed for all features, including copy and fax jobs, use the SCANNER-ADF-PAGE-COUNT object.')
scan_image_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eText", 1), ("ePhoto", 2), ("eMixed", 3)))).setLabel("scan-image-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_image_type.setStatus('optional')
if mibBuilder.loadTexts: scan_image_type.setDescription('Indicates the image type of the scan data.')
scan_subsample = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eFourToOneToOne", 1), ("eFourToTwoToTwo", 2), ("eFourToThreeToThree", 3), ("eFourToFourToFour", 4)))).setLabel("scan-subsample").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_subsample.setStatus('optional')
if mibBuilder.loadTexts: scan_subsample.setDescription('Indicates the subsampling used for Scan Data. 4:1:1, 4:2:2, and 4:3:3 subsampling are used to modify the scan image quality and amount of scan data by reducing the number of samples or pixels of the luminous and chrominance data.')
scanner_retrieve_scanline = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 48), OctetString()).setLabel("scanner-retrieve-scanline").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_retrieve_scanline.setStatus('optional')
if mibBuilder.loadTexts: scanner_retrieve_scanline.setDescription('This object facilitates the sending of a scan line of data from the scanner to a host. It grabs either raw or corrected data. SERVICE-PASSWORD must be set correctly to use this object. cScannerRequestRawScanLine - This is set by the host in order to signal to the firmware that it wants an scan line of raw (no PRNU or DSNU correction)data to be sent back up to the host. cScannerRequestCorrectedScanLine - This is set by the host in order to signal to the firmware that it wants a scan line of corrected (PRNU or DSNU correction) data to be sent back up to the host. cScannerSendDataRequest - This is set by firmware to indicate that it has acquired the scan line from scan engine and is ready to send the data to the host. cScannerSendDataOK - This is set by the host to indicate that it is ready to receive the data from the device. cScannerSendDataDone - This is set by the firmware to indicate that the transfer of data is complete. cScannerPickSheet - This is set by the host to tell the device to pick and stage the sheet of paper in the ADF. cScannerFlushSheet - This is set by the host to tell the device to flush the sheet of paper currently in the device. Additional information: This object is meant to be used by Manufacturing in order to facilitate the sending of a scan line of data from the scanner over HDT. It grabs either raw or corrected data. cScannerRequestRawScanLine - This is set by the host in order to signal to the firmware that it wants an scan line of raw (no PRNU or DSNU correction)data to be sent back up to the host. cScannerRequestCorrectedScanLine - This is set by the host in order to signal to the firmware that it wants a scan line of corrected (PRNU or DSNU correction) data to be sent back up to the host. This now uses the correct analog values for the LaserJet 3300 Series product. cScannerSendDataRequest - This is set by firmware to indicate that it has acquired the scan line from scan engine and is ready to send the data to the host. cScannerSendDataOK - This is set by the host to indicate that it is ready to receive the data from the device. cScannerSendDataDone - This is set by the firmware to indicate that the transfer of data is complete. cScannerPickSheet - This is used for manufacturing to drop the scan bogey to prevent damage during shipping. For LaserJet 3200, it was used to load a sheet in the ADF for shipping. cScannerFlushSheet - This is set by the host to tell the device to flush the sheet of paper currently in the device.')
scanner_motor_control = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-240, 4680))).setLabel("scanner-motor-control").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_motor_control.setStatus('optional')
if mibBuilder.loadTexts: scanner_motor_control.setDescription('This objects is set to the number of steps that the scan motor should move. SERVICE-PASSWORD must be setcorrectly to use this object. Additional information: This objects is set to the number of steps that the scan motor should move. It is meant to be used by Manufacturing in order to position the scanner shipping blocks. The minimum value is -240, and the maximum is 4680. The value set for this object will move the scan motor relative to the home position. A value of 0 will use the find home algorithm to move the scan motor home.')
scan_height = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25200))).setLabel("scan-height").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_height.setStatus('optional')
if mibBuilder.loadTexts: scan_height.setDescription('Used to set the height of a scan image in Decapoints. The use of Decapoints as units of measure eliminates the need for the user to understand the scanner mechanics and the device supported resolutions. Additional information: This object will be used to set the height of the scan image. The height will be entered using the measurement of 1/720th of an inch. This will eliminate the host being tied to the scanner mechanics and needing to know what resolutions and number of lines the device supports.')
scanner_scanline_statistics = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 51), DisplayString()).setLabel("scanner-scanline-statistics").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_scanline_statistics.setStatus('optional')
if mibBuilder.loadTexts: scanner_scanline_statistics.setDescription('This object is used to obtain statistics about the scan line that was previously obtained using the SCANNER-RETRIEVE- SCANLINE object. Just as SERVICE-PASSWORD must be set correctly for SCANNER-RETRIEVE-SCANLINE, it must be set correctly to use this object as well. Additional information: This object is used to obtain statistics about the scan line that was previously grabbed using the SCANNER_ RETRIEVE_SCANLINE object, max string is 256 bytes. The format is the following: max red value; position; min red value; position; max red pixel to pixel difference; position; red mean; max blue value; position; min blue value; position; max blue pixel to pixel difference; position; blue mean; max green value; position; min green value; position; max green pixel to pixel difference; position; green mean;')
scan_control_descriptor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 52), DisplayString()).setLabel("scan-control-descriptor").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_control_descriptor.setStatus('optional')
if mibBuilder.loadTexts: scan_control_descriptor.setDescription('Describes the control language and formats supported for this scanner. Additional information: This string is also used by Jetdirect Embedded WebScan')
scan_gamma_correction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 53), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setLabel("scan-gamma-correction").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_gamma_correction.setStatus('optional')
if mibBuilder.loadTexts: scan_gamma_correction.setDescription('A 32-bit quantity that indicates the gamma correction to use on the scan image. The first 16 bits indicate the integral portion of the gamma correction. The last 16 bits indicate the fraction portion in units of 1/65536. An example is gamma correction value of 2.2 will be representedas 0x00023333 (2 & 13107/65536ths)). The 4-pack products (gecko, sockeye, osprey & steelhead) software will set the gamma correction to be applied on the scan data. IPE SW will request a value of 1.0, which indicates no gamma correction. TWAIN software will request a value of 2.2 for grayscale scans and 2.9 for color scans. The device pos will indicate any deviation from the above description. Additional information: Indicates the gamma correction to use on the scan image. The first 16 bits indicate the integral portion of the gamma correction. The last 16 bits indicate the fraction portion and in units of 1/65536. An example is gamma correction value of 2.2 will be represented as 0x00023333 (2 & 13107/65536ths). ')
scan_pad_image = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("scan-pad-image").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_pad_image.setStatus('optional')
if mibBuilder.loadTexts: scan_pad_image.setDescription('Indicates if the scan image should be padded with white data or not.')
scan_flatbed_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 73), Integer32()).setLabel("scan-flatbed-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_flatbed_page_count.setStatus('optional')
if mibBuilder.loadTexts: scan_flatbed_page_count.setDescription('This object tracks the page count for the pages scanned from the flatbed.')
scanner_flatbed_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 74), Integer32()).setLabel("scanner-flatbed-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_flatbed_page_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_flatbed_page_count.setDescription('This object tracks the page count for the pages scanned for all jobs from the flatbed. This includes scan to host jobs, fax jobs, and copy jobs. ')
scanner_modular_hardware = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 75), OctetString()).setLabel("scanner-modular-hardware").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_modular_hardware.setStatus('optional')
if mibBuilder.loadTexts: scanner_modular_hardware.setDescription('Used to specify whether optional hardware is installed or not Additional information: HP LaserJet 3300 Series uses this object to allow a host to query whether or not it has an ADF installed.')
default_scanner_margin_top = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 720))).setLabel("default-scanner-margin-top").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_scanner_margin_top.setStatus('optional')
if mibBuilder.loadTexts: default_scanner_margin_top.setDescription('Sets the top scanner margin. The unit of measure should be documented in the device POS. Additional information: This object is a signed integer value that sets the number of decipoints (1/720 inch) to skip from the top of the document being scanned.')
scan_max_line_width = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 77), Integer32()).setLabel("scan-max-line-width").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_max_line_width.setStatus('optional')
if mibBuilder.loadTexts: scan_max_line_width.setDescription('Returns the maximum scan line width in pixels for the currently selected resolution. Additional information: Returns the maximum scanline width in pixels for the currently selected resolution. If a page is detected in the ADF, then the ADF width is returned, otherwise the flatbed width is returned.')
scan_calibration_target = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 32, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eWhiteSheet", 1), ("ePlaten", 2)))).setLabel("scan-calibration-target").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_calibration_target.setStatus('optional')
if mibBuilder.loadTexts: scan_calibration_target.setDescription("This object is used by the host to check which type of calibration this scan device supports. The device pos will describe the meaning and intent of each type of scan calibration supported. Additional information: This object is used by the host to check which type of calibration the firmware supports. This is in anticipation of the fact that the initial release of Gecko will be calibrated off of a sheet, but the 'Rest of World' release will be calibrated off of the platen.")
not_ready_source_scanner = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 1), OctetString()).setLabel("not-ready-source-scanner").setMaxAccess("readonly")
if mibBuilder.loadTexts: not_ready_source_scanner.setStatus('optional')
if mibBuilder.loadTexts: not_ready_source_scanner.setDescription('Indicates whether and why the scanner is not ready. A set bit indicates a problem. Additional information: ISSUES: Timberline only used cScannerFeederJam. Tahiti does not have an ADF sensor. Can cScannerFeederEmpty still be used (i.e. when the device tries to pull a page, but the ADF is empty or a mispick occurred). cInvalidScannerMediaSize may be used. If a page is longer that 33 inches normally this would be shown to the host as a Jam. However, can the device use cInvalidScannerMediaSize instead? This object will report cScannerFeederOpen state for the LaserJet 3300 Series product, when the ADF door is open.')
scan_resolution_range = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 3), DisplayString()).setLabel("scan-resolution-range").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_resolution_range.setStatus('optional')
if mibBuilder.loadTexts: scan_resolution_range.setDescription('Enumerates the range of selectable scanning resolutions. Format as follows: Each supported resolution is in the format: (m)x(n) where m describes the x dpi resolution along the paper width. n describes the y dpi resolution along the paper length. A scanner that supports several resolutions would enumerate each resolution separated by a comma. A scanner that supports a continuous resolution range would format its range as: (m1-m2)x(n1- n2) where m1 < m2, n1 < n2 ')
scan_calibration_download = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 5), OctetString()).setLabel("scan-calibration-download").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_calibration_download.setStatus('optional')
if mibBuilder.loadTexts: scan_calibration_download.setDescription('Returns or changes the state of the calibration operation. cScanCalibrationIdle - indicates that calibration is not in progress. cScanCalibrationStart - This state is set by host to request calibration initiation. Device should not set to this state. cScanCalibrationActive - Indicates device is in calibration mode. Device sets cScanCalibrationActive to signal calibration is in process. cScanCalibrationAborted - Set by device to indicate calibration was prematurely terminated. Set by host when a calibration error occurs. cScanCalibrationSendDataRequest - Set by host when host wants to send data to the device. cScanCalibrationSendDataRequestOK - Set by the device to tell the host that the device is ready to accept data. cScanCalibrationSendDataRequestDone -Set by the device to indicate the data was received by the device. cScanCalibrationRequestScanBuffer - Set by the host to request a buffer from the device. cScanCalibrationDone - Set by the host to inform the device calibration is complete. The sequence of bits being set and the restrictions for setting bits should be documented in the device POS. Additional information: This object was originally defined for use on Timberline. For Tahiti/Gecko we will not be using values 3-6. These are no longer applicable since the calibration is completely contained within firmware. For LaserJet 3300 Series product, the scanner will find home after every user initiated calibration. This is necessary as multiple user calibrations in a row cause the scanner to lose home. The first 15 lines that are scanned are discarded in a user calibration for the LaserJet 3300 Series product. This accounts for the possible skew of the label. The number of samples grabbed from the white strip is 15. This only affects RGB scans. For the LaserJet 3300 Series product, a factory calibration will save the analog values. The graph for the LaserJet 3300 Series product contains figures to help determine acceptance of uncorrectable pixels.')
scan_calibration_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("eNoError", 1), ("eUnknownCalibrationError", 2), ("eScannerFeederEmpty", 3), ("eLowMemory", 4), ("eWriteFailed", 5), ("eScannerBusy", 6), ("eADFMispick", 7), ("eADFJam", 8), ("eUncorrectablePixels", 9)))).setLabel("scan-calibration-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_calibration_error.setStatus('optional')
if mibBuilder.loadTexts: scan_calibration_error.setDescription('Error status of the most recent calibration session. eNoError(1) - The calibation was successful. eUnknownCalibrationError(2) - An unknown error occurred. eScannerFeederEmpty(3) - The feeder contained nothing to scan. eLowMemory(4) - Insufficient memory available to complete the calibration. eWriteFailed(5) - Write to NVRAM failure. eScannerBusy(6) - Scanner is busy. Detailed information about the cause and remedy for each error should be documented in the device POS. Additional information: This object was originally defined for use on Timberline. We are proposing the new enums number 7-9. Note: Option 9 would only be set during a factory calibration to indicate that at least one pixel was not correctable by the digital calibration factors.')
scanner_button_status = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("scanner-button-status").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_button_status.setStatus('optional')
if mibBuilder.loadTexts: scanner_button_status.setDescription('Indicates the scanner button has been pressed. The value changes to eOn(2) when the button is pressed. The host acknowledges the button press by setting the value to eOff(1).')
scanner_lamp_gain_value = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 8), DisplayString()).setLabel("scanner-lamp-gain-value").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_lamp_gain_value.setStatus('optional')
if mibBuilder.loadTexts: scanner_lamp_gain_value.setDescription("Provides PWM and analog gain for the color channels. The range will vary based on scan mode. The device specific POS should describe the valid range. The format is the following: PWM value; red analog gain; green analog gain; blue analog gain. Additional information: The range will vary based on scan mode. The values will differ from those of San Diego. The initial value can be obtained at the start of warmup and the final value can be obtained at the end of warmup. The warmup period is about 2 minutes. The analog gain values are obtained from the calibration application, instead of from the hardware on the LaserJet 3300 Series product. The hardware values are reset whenever the bulb finds home, goes into standby, etc. so that the gains obtained during these times would not reflect norm=al scanning gains. The format is the following PWM value; red analog gain; green analog gain; blue analog gain;. The valid values for PWM value are 580 - 730 and the valid values for analog gains are 1.00-5.80. The gains are reported with accuracy to 2 decimal places. A sample return value would be '584;1.00;1.34;1.00;' ")
scanner_light_monitor_window = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 9), DisplayString()).setLabel("scanner-light-monitor-window").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_light_monitor_window.setStatus('optional')
if mibBuilder.loadTexts: scanner_light_monitor_window.setDescription("Provides the pixel at which the LMW starts, as the ratio of the average LMW value to the six pixel average value. The device specific pos should specify the valid ranges for each value. The format is the following: LMW position; ratio of LMWavg to 6 pixel avg; Additional information: Provides the pixel at which the LMW starts as well as the ratio of the average LMW value over a 6 pixel average value. A algebraic representation of this ratio is: Average of Light Monitor Window pixels ______________________________________ Average of 6 test point pixels The 6 test point pixels do not inlcude any of the Light Monitor Window. A sample return value would be '50;0.059;'. ")
scanner_reference_position = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 10), DisplayString()).setLabel("scanner-reference-position").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_reference_position.setStatus('optional')
if mibBuilder.loadTexts: scanner_reference_position.setDescription("Provides 3 pairs of x,y coordinates within a specified range of the calibrate reference position. The device specific POS should specify the valid ranges. The format is the following: 'x;y;x;y;x;y' Additional information: Provides x,y coordinates within 1/300 of a line of the calibrate reference position. The 3 locations in order that are reported are the 1st Reference Mark, the 2nd Reference Mark, and the Document Origin. A sample return value would be '0,0;2505,0;74,164;' ")
scanner_sensor_manufacturer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 11), DisplayString()).setLabel("scanner-sensor-manufacturer").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_sensor_manufacturer.setStatus('optional')
if mibBuilder.loadTexts: scanner_sensor_manufacturer.setDescription('Reports the scan sensor manufacturer. The device specific POS should list valid manufacturers. Additional information: Reports the scan sensor manufacturer. The device specific POS should list valid manufacturers.')
prtgeneralconfigchanges = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtgeneralconfigchanges.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralconfigchanges.setDescription("Counts configuration changes that change the capabilities of a printer, such as the addition/deletion of input/output bins, the addition/deletion of interpreters, or changes in media size. Such changes will often affect the capability of the printer to service certain types of print jobs. Management applications may cache infrequently changed configuration information about sub-units on the printer. This object should be incremented whenever the agent wishes such applications to invalidate that cache and re-download all of this configuration information, thereby signaling a change in the printer's configuration. For example, if an input tray that contained paper of different dimensions was added, this counter would be incremented. As an additional example, this counter would not be incremented when an input tray is removed or the level of an input device changes. Additional information: This is a 32 bit counter (unsigned). When it reaches its maximum value, it will roll to zero.")
prtgeneralcurrentlocalization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralcurrentlocalization.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralcurrentlocalization.setDescription("The value of the prtLocalizationIndex corresponding to the current language, country, and character set to be used for localized string values that are identified as being dependent on the value of this object. Note that this object does not apply to localized strings in the prtConsole group or to any object that is not explicitly identified as being localized according to prtGeneralCurrentLocalization. Additional information: The value of this object is saved in NVRAM. The PJL INITIALIZE command or a cold reset at the control panel will cause this object to return to its default value. After this object is set, it will no longer power cycle. This is to satisfy a manufacturing requirement that PJL won't power cycle HP LaserJet 3300 Series, due to the long power cycle times in this product. PML has been changed to match PJL behavior. Fax will not work until the unit has been power cycled.")
prtgeneralreset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6))).clone(namedValues=NamedValues(("ePnotResetting", 3), ("ePpowerCycleReset", 4), ("ePresetToNVRAM", 5), ("ePresetToFactoryDefaults", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralreset.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralreset.setDescription("Setting this value to `powerCycleReset', `resetToNVRAM', or `resetToFactoryDefaults' will result in the resetting of the printer. When read, this object will always have the value `notResetting(3)', and a SET of the value `notResetting' shall have no effect on the printer. Some of the defined values are optional. However, every implementation must support at least the values `notResetting' and 'resetToNVRAM'. Additional information: The LaserJet 3300 supports the values 'notResetting', 'resetToNVRAM' and 'resetToFactoryDefaults. Setting this object to ePnotResetting causes the printer to do no reset. Setting this object to ePpowerCycleReset causes this device to do a reset. Setting this object to 'resetToNVRAM' does NOT perform an NVRAM init on the LaserJet 3300 Series product. It causes the LaserJet 3300 products to perform its power on initialization routines. All I/O buffers are reset and tests normally run at power on time are executed. Setting the object to 'resetToFactoryDefaults, causes the device to perform its reset to factory defaults routines. Also, the device will perform a power cycle, which is required to set all variables to their factory defaults.")
prtgeneralcurrentoperator = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralcurrentoperator.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralcurrentoperator.setDescription("The name of the person who is responsible for operating this printer. It is suggested that this string include information that would enable other humans to reach the operator, such as a phone number. As a convention to facilitate automatic notification of the operator by the agent or the network management station, the phone number, fax number or email address should be placed on a separate line starting with ASCII LF (hex 0x0A) and the ASCII text string (without the quotes): 'phone: ', 'fax: ', and 'email: ', respectively. Phone numbers may contain digits, whitespace and parentheses, which shall be ignored. Phone numbers may also include ASCII comma characters(hex 2C) that are used to indicate a two-second pause during the dialing sequence. If either the phone, fax, or email information is not available, then a line should not be included for this information. NOTE: For interoperability purposes, it is advisable to use email addresses formatted according to RFC 822 requirements. Additional information: The maximum supported string length is 32 characters. Length of 32 was chosen so a phone number could be included with the name. If the user entered string is too long, the device will store as much as possible and will return the <noError> status.")
prtgeneralserviceperson = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralserviceperson.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralserviceperson.setDescription("The name of the person responsible for servicing this printer. It is suggested that this string include information that would enable other humans to reach the service person, such as a phone number. As a convention to facilitate automatic notification of the service person by the agent or a network management station, the phone number, fax number or email address should be placed on a separate line starting with ASCII LF (hex 0x0A) and the ASCII text string (without the quotes): 'phone: ', 'fax: ', and 'email: ', respectively. Phone numbers may contain digits, whitespace and parentheses, which shall be ignored. Phone numbers can also include one or more ASCII comma characters(hex 2C) to indicate a two-second pause during the dialing sequence. If either the phone,fax, or email information is not available, then a line should not included for this information. NOTE: For interoperability purposes, it is advisable to use email addresses formatted according to RFC 822 requirements. Additional information: The maximum supported string length is 32 characters. Length of 32 was chosen so a phone number could be included with the name. If the user entered string is too long, the device will store as much as possible and will return the <noError> status.")
prtinputdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtinputdefaultindex.setDescription("The value of prtInputIndex corresponding to the default input sub-unit: that is, this object selects the default source of input media. This value shall be -1 if there is no default input subunit specified for the printer as a whole. In this case, the actual default input subunit may be specified by means outside the scope of this MIB, such as by each interpreter in a printer with multiple interpreters. Additional information: The default input tray is determined by the printer based on DEFAULT-MEDIA-SIZE, what trays are locked (if any), and whether or not Tray 3 is installed. See the 'LaserJet 3300 Handling ERS' for complete details. This object always returns -1, unknown.")
prtoutputdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtoutputdefaultindex.setDescription('The value of prtOutputIndex corresponding to the default output sub-unit; that is, this object selects the default output destination. This value shall be -1 if there is no default output subunit specified for the printer as a whole. In this case, the actual default output subunit may be specified by means outside the scope of this MIB, such as by each interpreter in a printer with multiple interpreters. Additional information: The LaserJet 3300 products have only one output bin, a face-down bin located at the top of the printer.')
prtmarkerdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerdefaultindex.setDescription('The value of prtMarkerIndex corresponding to the default marker sub-unit; that is, this object selects the default marker. Additional information: The LaserJet 3300 products only has one marker subunit.')
prtmediapathdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathdefaultindex.setDescription('The value of prtMediaPathIndex corresponding to the default media path; that is, the selection of the default media path. Additional information: The only valid value for this object is 1 (simplex).')
prtconsolelocalization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtconsolelocalization.setStatus('optional')
if mibBuilder.loadTexts: prtconsolelocalization.setDescription('The value of the prtLocalizationIndex corresponding to the language, country, and character set to be used for the console. This localization applies both to the actual display on the console as well as the encoding of these console objects in management operations. Additional information: LaserJet 3300 has a localized display.')
prtconsolenumberofdisplaylines = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolenumberofdisplaylines.setStatus('optional')
if mibBuilder.loadTexts: prtconsolenumberofdisplaylines.setDescription("The number of lines on the printer's physical display. This value is 0 if there are no lines on the physical display or if there is no physical display Additional information: LaserJet 3300 has a 2-line display. The second line can scroll")
prtconsolenumberofdisplaychars = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolenumberofdisplaychars.setStatus('optional')
if mibBuilder.loadTexts: prtconsolenumberofdisplaychars.setDescription('The number of characters per line displayed on the physical display. This value is 0 if there are no lines on the physical display or if there is no physical display Additional information: LaserJet 3300 has a 16-character display. The second line can scroll messages up to 40 characters.')
prtconsoledisable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("ePoperatorConsoleEnabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledisable.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledisable.setDescription("If the object prtConsoleDisable has value 'operatorConsoleDisabled' then input is not accepted from the operator console. If the object prtConsoleDisable has the value 'operatorConsoleEnabled' then input is accepted from the operator console. If the object prtConsoleDisable has the value 'operatorConsoleEnabledLevel1','operatorConsoleEnabledLevel2' or 'operatorConsoleEnabledLevel3' then limited input is accepted from the operator console; the limitations are product specific, however, the limitations are generally less restrictive for operatorConsoleEnabledLevel1 than for operatorConsoleEnabledLeve2, which is less restrictive than operatorConsoleEnabledLevel3. The value of the prtConsoleDisable object is a type-2 enumeration.")
prtgeneralprintername = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralprintername.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralprintername.setDescription("An administrator-specified name for this printer. Depending upon implementation of this printer, the value of this object may or may not be same as the value for the MIB-II 'SysName' object. Additional information: The maximum supported string length is 32 characters. Length of 32 was chosen so a phone number could be included with the name. If the user-entered string is too long, the device will store as much as possible and will return the <noError> status. The value of this object is NOT saved over a power cycle.")
prtgeneralserialnumber = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtgeneralserialnumber.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralserialnumber.setDescription('A recorded serial number for this device that indexes some type device catalog or inventory. This value is usually set by the device manufacturer but the MIB supports the option of writeability for this object for site-specific administration of device inventory or tracking.')
prtalertcriticalevents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertcriticalevents.setStatus('optional')
if mibBuilder.loadTexts: prtalertcriticalevents.setDescription('A running counter of the number of critical alert events that have been recorded in the alert table. The value of this object is RESET in the event of a power cycle operation (i.e., the value is not persistent. Additional information: This object is set to zero every time the printer is turned on.')
prtalertallevents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertallevents.setStatus('optional')
if mibBuilder.loadTexts: prtalertallevents.setDescription('A running counter of the total number of alert event entries (critical and non-critical) that have been recorded in the alert table Additional information: This object is set to zero every time the printer is turned on. (It is not persistent through a power-cycle.)')
prtcoverdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtcoverdescription.setStatus('optional')
if mibBuilder.loadTexts: prtcoverdescription.setDescription('The manufacturer provided cover sub-mechanism name in the localization specified by prtGeneralCurrentLocalization.')
prtcoverstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePdoorOpen", 3), ("ePdoorClosed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtcoverstatus.setStatus('optional')
if mibBuilder.loadTexts: prtcoverstatus.setDescription('The status of this cover sub-unit.')
prtlocalizationlanguage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationlanguage.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationlanguage.setDescription('A two character language code from ISO 639. Examples en, gb, ca, fr, de. Refer to Printer Management Standards web page, Additional information: The languages supported by the LaserJet 3300 product English, French, German, Italian, Spanish, Swedish, Danish, Norwegian, Dutch, Finnish, Portuguese, Turkish, Polish, Russian, Czech, and Hungarian')
prtlocalizationcountry = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationcountry.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationcountry.setDescription('A two character country code from ISO 3166, a blank string (two space characters) shall indicate that the country is not defined. Examples: US, FR, DE, ... Additional information: The languages supported by the Laserjet 2200 product (and corresponding country) are English (US, United States), French (FR, France), German (DE, Germany), Italian (IT, Italy), Spanish (ES, Spain), Swedish (SE, Sweden), Danish (DK, Denmark), Norwegian (NO, Norway), Dutch (NL, Netherlands), Finnish (FI, Finland), Portuguese (PT, Portugal), Turkish (TR, Turkey), Polish (PL, Poland), Russian (RU, Russia), Czech (CS, Czech and Slovak Republics), Hungarian (HU, Hungary).')
prtlocalizationcharacterset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2004, 5, 8, 12))).clone(namedValues=NamedValues(("ePcsHPRoman8", 2004), ("ePcsISOLatin2", 5), ("ePcsISOLatinCyrillic", 8), ("ePcsISOLatin5", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationcharacterset.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationcharacterset.setDescription('The coded character set used for this localization.')
prtstoragerefindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtstoragerefindex.setStatus('optional')
if mibBuilder.loadTexts: prtstoragerefindex.setDescription('The value of the hrDeviceIndex of the printer device that this storageEntry is associated with.')
prtdevicerefindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtdevicerefindex.setStatus('optional')
if mibBuilder.loadTexts: prtdevicerefindex.setDescription('The value of the hrDeviceIndex of the printer device that this deviceEntry is associated with.')
prtinputtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePsheetFeedAutoRemovableTray", 3), ("ePsheetFeedAutoNonRemovableTray", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputtype.setStatus('optional')
if mibBuilder.loadTexts: prtinputtype.setDescription('The type of technology (discriminated primarily according to feeder mechanism type) employed by the input sub-unit. Note, the Optional Input Class provides for a descriptor field to further qualify the other choice. Additional information: Tray 1 is the multi-purpose tray and is always present. It supports both sheets and envelopes. Its type is ePsheetFeedAutoNonRemovableTray.')
prtinputdimunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdimunit.setStatus('optional')
if mibBuilder.loadTexts: prtinputdimunit.setDescription('The unit of measurement for use calculating and relaying dimensional values for this input sub-unit. Additional information: Following is a table of paper sizes and dimensions for each paper size supported by the LaserJet 3300 products: Size....................Inches(ten-thousandths)...Micrometers ---------------------------------------------------------------- - eUSExecutive............72500 x 105000............184150 x 266700 eUSLetter...............85000 x 110000............215900 x 279400 eUSLegal................85000 x 140000............215900 x 355600 eFoolscap...............85000 x 130000............215900 x 330200 eROC16K.................77500 x 107500............196850 x 273050 eISOandJISA4............82677 x 116929............210000 x 297000 eISOandJISA5............58286 x 82677.............148000 x 210000 eJISB5..................71654 x 101181............182000 x 257000 eJapanesePostcardSingle.39370 x 58267.............100000 x 148000 eJapanesePostcardDouble.58267 x 78740.............148000 x 200000 eMonarch................38750 x 75000.............98425 x 190500 eCommercial10...........41250 x 95000.............104775 x 241300 eInternationalDL........43307 x 86614.............110000 x 220000 eInternationalC5........63780 x 90157.............162000 x 229000 eInternationalB5........69291 x 98425.............176000 x 250000 eCustom.................85000 x 140000(max).......215900 x 355600(max)')
prtinputmediadimfeeddirdeclared = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimfeeddirdeclared.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimfeeddirdeclared.setDescription('This object provides the value of the declared dimension, in the feed direction, of the media that is (or, if empty, was or will be) in this input sub-unit. The feed direction is the direction in which the media is fed on this sub-unit. This dimension is measured in input sub-unit dimensional units (prtInputDimUnit). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests. Otherwise, the value may be changed. The value (-1) means other and specifically means that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Additional information: The default values assume the trays are configured for letter size paper. For tray 1 the value is the dimension for the media size currently declared. Valid values are 63000 to 140000 if prtInputDimUnit is ePtenThousandthsOfInches and 160000 to 356000 if prtInputDimUnit is ePmicrometers.')
prtinputmediadimxfeeddirdeclared = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimxfeeddirdeclared.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimxfeeddirdeclared.setDescription('This object provides the value of the declared dimension, in the cross feed direction, of the media that is (or, if empty, was or will be) in this input sub-unit. The cross feed direction is ninety degrees relative to the feed direction associated with this sub-unit. This dimension is measured in input sub-unit dimensional units (prtInputDimUnit). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests. Otherwise, the value may be changed. The value (-1) means other and specifically means that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Additional information: The default values assume the trays are configured for letter size paper. For tray 1 the value is the dimension for the media size currently declared. Valid values are 35000 to 85000 if prtInputDimUnit is ePtenThousandthsOfInches and 90000 to 216000 if prtInputDimUnit is ePmicrometers.')
prtinputmediadimfeeddirchosen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimfeeddirchosen.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimfeeddirchosen.setDescription('The printer will act as if media of the chosen dimension (in the feed direction) is present in this input source. Note that this value will be used even if the input tray is empty. Feed dimension measurements are taken relative to the feed direction associated with that sub-unit and are in input sub-unit dimensional units (MediaUnit). If the printer supports the declared dimension, the granted dimension is the same as the declared dimension. If not, the granted dimension is set to the closest dimension that the printer supports when the declared dimension is set. The value (-1) means other and specifically indicates that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Additional information: The default value assumes the tray is configured for letter size paper. The object for tray 1 returns the value of the media size for which the tray is currently configured because it cannot sense what size media it contains.')
prtinputmediadimxfeeddirchosen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimxfeeddirchosen.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimxfeeddirchosen.setDescription('The printer will act as if media of the chosen dimension (in the cross feed direction) is present in this input source. Note that this value will be used even if the input tray is empty. The cross feed direction is ninety degrees relative to the feed direction associated with this sub-unit. This dimension is measured in input sub-unit dimensional units (MediaUnit). If the printer supports the declared dimension, the granted dimension is the same as the declared dimension. If not, the granted dimension is set to the closest dimension that the printer supports when the declared dimension is set. The value (-1) means other and specifically indicates that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Additional information: The default value assumes the tray is configured for letter size paper. The object for tray 1 returns the value of the media size for which the tray is currently configured because it cannot sense what size media it contains.')
prtinputcapacityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8))).clone(namedValues=NamedValues(("ePsheets", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputcapacityunit.setStatus('optional')
if mibBuilder.loadTexts: prtinputcapacityunit.setDescription('The unit of measurement for use in calculating and relaying capacity values for this input sub-unit. Additional information: A sheet is a single piece of 20 pound paper. ')
prtinputmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtinputmaxcapacity.setDescription('The maximum capacity of the input sub-unit in input sub-unit capacity units (PrtCapacityUnitTC). There is no convention associated with the media itself so this value reflects claimed capacity. If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Additional information: This is specified assuming 20 pound paper for the paper trays.')
prtinputcurrentlevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputcurrentlevel.setStatus('optional')
if mibBuilder.loadTexts: prtinputcurrentlevel.setDescription('The current capacity of the input sub-unit in input sub-unit capacity units (PrtCapacityUnitTC). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Contol Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. The value (-3) means that the printer knows that at least one unit remains. Additional information: The LaserJet 3300 products can only detect empty/not empty in its trays. It returns -3 for not empty and -2 (unknown) for any other condition (e.g. tray is empty or tray is removed).')
prtinputstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputstatus.setStatus('optional')
if mibBuilder.loadTexts: prtinputstatus.setDescription('The current status of this input sub-unit. Additional information: The default value assumes that media is loaded in the tray. When there is not media loaded in the tray it returns 9 instead of 0 (the default). Default - 0 (Available and Idle) paper motion - 6 (Available and Busy) paper out in this tray - 9 (Non-Critical Alert(8) + Unavailable and OnRequest(1)) paper mount in this tray - 48 (Critical Alert (16) + OffLine (32)) manual feed prompt (PaperMount) - 48 (Critical Alert (16) + OffLine (32))')
prtinputmedianame = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmedianame.setStatus('optional')
if mibBuilder.loadTexts: prtinputmedianame.setDescription("A description of the media contained in this input sub-unit; This description is intended for display to a human operator. This description is not processed by the printer. It is used to provide information not expressible in terms of the other media attributes (e.g. prtInputMediaDimFeedDirChosen, prtInputMediaDimXFeedDirChosen, prtInputMediaWeight, prtInputMediaType). An example would be `legal tender bond paper'. Additional information: The LaserJet 3300 products does not support the concept of named media types.")
prtinputname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputname.setStatus('optional')
if mibBuilder.loadTexts: prtinputname.setDescription('The name assigned to this input sub-unit.')
prtinputvendorname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputvendorname.setStatus('optional')
if mibBuilder.loadTexts: prtinputvendorname.setDescription('The vendor name of this input sub-unit.')
prtinputmodel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmodel.setStatus('optional')
if mibBuilder.loadTexts: prtinputmodel.setDescription('The model name of this input sub-unit. Additional information: The LaserJet 3300 products does not specify a model name for Tray1.')
prtinputversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputversion.setStatus('optional')
if mibBuilder.loadTexts: prtinputversion.setDescription('The version of this input sub-unit. Additional information: The LaserJet 3300 products do not specify a version number for the input trays.')
prtinputserialnumber = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputserialnumber.setStatus('optional')
if mibBuilder.loadTexts: prtinputserialnumber.setDescription('The serial number assigned to this input sub-unit. Additional information: The LaserJet 3300 products do not specify a serial number for the input trays.')
prtinputdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdescription.setStatus('optional')
if mibBuilder.loadTexts: prtinputdescription.setDescription('A free-form text description of this input sub-unit in the localization specified by prtGeneralCurrentLocalization.')
prtinputsecurity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputsecurity.setStatus('optional')
if mibBuilder.loadTexts: prtinputsecurity.setDescription('Indicates if this input sub-unit has some security associated with it. Additional information: No security mechanism provided.')
prtoutputtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePremovableBin", 3), ("ePunRemovableBin", 4), ("ePcontinuousRollDevice", 5), ("ePmailBox", 6), ("ePcontinousFanFold", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputtype.setStatus('optional')
if mibBuilder.loadTexts: prtoutputtype.setDescription('The type of technology supported by this output sub-unit. Additional information: The LaserJet 3300 products have only one output bin, a face-down bin located at the top of the printer.')
prtoutputcapacityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 8, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4), ("ePsheets", 8), ("ePfeet", 16), ("ePmeters", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputcapacityunit.setStatus('optional')
if mibBuilder.loadTexts: prtoutputcapacityunit.setDescription('The unit of measurement for use in calculating and relaying capacity values for this output sub-unit. Additional information: A sheet is a single piece of 20 pound paper.')
prtoutputmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputmaxcapacity.setDescription('The maximum capacity of this output sub-unit in output sub-unit capacity units (PrtCapacityUnitTC). There is no convention associated with the media itself so this value essentially reflects claimed capacity. If this output sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Additional information: Note: The LaserJet 3300 products cannot sense how much is in the output bin. The output bin can hold 150 sheets. This object refers only to the face-down output bin, not the face-up output tray.')
prtoutputremainingcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputremainingcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputremainingcapacity.setDescription('The remaining capacity of the possible output sub-unit capacity in output sub-unit capacity units (PrtCapacityUnitTC) of this output sub-unit. If this output sub-unit can reliably sense this value, the value is sensed by the printer and may not be modified by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. The value (-3) means that the printer knows that there remains capacity for at least one unit. Additional information: The LaserJet 3300 products do not have any sensing on the output bin, so it will always report unknown (-2). Note that for the LaserJet 3300 products this object is read- only (because any values written by a Remote Control Panel or a Management Application would be unreliable).')
prtoutputstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputstatus.setStatus('optional')
if mibBuilder.loadTexts: prtoutputstatus.setDescription('The current status of this output sub-unit. Additional information: The LaserJet 3300 products cannot sense the output tray so this object will always return 5 (Unknown Status).')
prtmarkermarktech = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("ePelectrophotographicLaser", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkermarktech.setStatus('optional')
if mibBuilder.loadTexts: prtmarkermarktech.setDescription('The type of marking technology used for this marking sub-unit.')
prtmarkercounterunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7))).clone(namedValues=NamedValues(("ePimpressions", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkercounterunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkercounterunit.setDescription("The unit that will be used by the printer when reporting counter values for this marking sub-unit. The time units of measure are provided for a device like a strip recorder that does not or cannot track the physical dimensions of the media and does not use characters, lines or sheets. Additional information: Since the LaserJet 3300 products keeps track of pages printed, the counter unit will be defined as ePimpressions which would be like saying pages printed. (The term 'impressions' is used instead of 'pages' to avoid confusion between 'sheets' and 'pages' on a duplexing printer. This confusion isn't a problem with the LaserJet 3300 products because it has no duplexer.)")
prtmarkerlifecount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerlifecount.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerlifecount.setDescription('The count of the number of units of measure counted during the life of printer using units of measure as specified by prtMarkerCounterUnit. Additional information: In the LaserJet 3300 products the total engine page count is kept in NVRAM however the NVRAM value is only updated every 10 impressions. NOTE: The value returned by this OID will be incremented every page but if power is lost between NVRAM updates, up to 9 impressions of the page count may be lost. The counter will be reset to zero after 999999 pages. The page count is incremented when a sheet of media is pulled from an input tray.')
prtmarkerpoweroncount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerpoweroncount.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerpoweroncount.setDescription('The count of the number of units of measure counted since the equipment was most recently powered on using units of measure as specified by prtMarkerCounterUnit.')
prtmarkerprocesscolorants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerprocesscolorants.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerprocesscolorants.setDescription('The number of process colors supported by this marker. A process color of 1 implies monochrome. The value of this object and prtMarkerSpotColorants cannot both be 0. The value of prtMarkerProcessColorants must be 0 or greater.')
prtmarkerspotcolorants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerspotcolorants.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerspotcolorants.setDescription('The number of spot colors supported by this marker. The value of this object and prtMarkerProcessColorants cannot both be 0. Must be 0 or greater.')
prtmarkeraddressabilityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityunit.setDescription("The unit of measure of distances, as applied to the marker's resolution. Additional information: This will always be ePtenThousandthsOfInches, no matter what COLD-RESET-MEDIA-SIZE is because we are talking about resolution and toner addressability, which is always dpi.")
prtmarkeraddressabilityfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityfeeddir.setDescription("The maximum number of addressable marking positions in the feed direction per 10000 units of measure specified by prtMarkerAddressabilityUnit. A value of (-1) implies 'other' or 'infinite' while a value of (-2) implies 'unknown'. Additional information: Use this object to specify resolution. The LaserJet 3300 products support 300, 600, or 1200 dots per inch with 1200 being the default. If this object changes it causes prtMarkerAddressabilityXFeedDir object to change to the same value.")
prtmarkeraddressabilityxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityxfeeddir.setDescription("The maximum number of addressable marking positions in the cross feed direction in 10000 units of measure specified by prtMarkerAddressabilityUnit. A value of (-1) implies 'other' or 'infinite' while a value of (-2) implies 'unknown'. Additional information: Use this object to specify resolution. The LaserJet 3300 products support 300, 600, or 1200 dots per inch with 1200 being the default. If this object changes it causes prtMarkerAddressabilityFeedDir object to change to the same value.")
prtmarkernorthmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkernorthmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkernorthmargin.setDescription('The margin, in units identified by prtMarkerAddressabilityUnit, from the leading edge of the medium as the medium flows through the marking engine with the side to be imaged facing the observer. The leading edge is the North edge and the other edges are defined by the normal compass layout of directions with the compass facing the observer. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown.')
prtmarkersouthmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersouthmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersouthmargin.setDescription('The margin from the South edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown.')
prtmarkerwestmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerwestmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerwestmargin.setDescription('The margin from the West edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown.')
prtmarkereastmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkereastmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkereastmargin.setDescription('The margin from the East edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown.')
prtmarkerstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerstatus.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerstatus.setDescription('The current status of this marker sub-unit. Additional information: The default value assumes the printer is idle and has no malfunctions. Default - 0 (Available and Idle) no toner cartridge - 51 (UnAvailable because Broken (3) + Critical Alert (16) + OffLine (32))')
prtmarkersuppliesmarkerindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesmarkerindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesmarkerindex.setDescription('The value of prtMarkerIndex corresponding to the marking sub-unit with which this marker supply sub-unit is associated. Additional information: The LaserJet 3300 products have just one marker supply, the toner cartridge, so this value is always 1.')
prtmarkersuppliescolorantindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliescolorantindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliescolorantindex.setDescription('The value of prtMarkerColorantIndex corresponding to the colorant with which this marker supply sub-unit is associated. This value shall be 0 if there is no colorant table.')
prtmarkersuppliesclass = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("ePother", 1), ("ePsupplyThatIsConsumed", 3), ("ePreceptacleThatIsFilled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesclass.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesclass.setDescription('Indicates whether this supply entity represents a supply that is consumed or a receptacle that is filled.')
prtmarkersuppliestype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("ePtoner", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliestype.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliestype.setDescription('The type of this supply.')
prtmarkersuppliesdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesdescription.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesdescription.setDescription('The description of this supply container/receptacle in the localization specified by prtGeneralCurrentLocalization.')
prtmarkersuppliessupplyunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(13))).clone(namedValues=NamedValues(("ePtenthsOfGrams", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliessupplyunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliessupplyunit.setDescription('Unit of measure of this marker supply container/receptacle.')
prtmarkersuppliesmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesmaxcapacity.setDescription('The maximum capacity of this supply container/receptacle expressed in prtMarkerSuppliesSupplyUnit. If this supply container/receptacle can reliably sense this value, the value is reported by the printer and is read-only; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Additional information: The LaserJet 3300 products always return -2 (Unknown).')
prtmarkersupplieslevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersupplieslevel.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersupplieslevel.setDescription('The current level if this supply is a container; the remaining space if this supply is a receptacle. If this supply container/receptacle can reliably sense this value, the value is reported by the printer and is read-only; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. A value of (-3) means that the printer knows that there is some supply/remaining space, respectively. Additional information: The LaserJet 3300 products cannot sense toner level. The LaserJet 3300 products always return -2 (Unknown).')
prtmediapathmaxspeedprintunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7))).clone(namedValues=NamedValues(("ePimpressionsPerHour", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxspeedprintunit.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxspeedprintunit.setDescription('The unit of measure used in specifying the speed of all media paths in the printer. Additional information: ePimpressionsPerHour is the value that will always be returned for this object. (Print Speed is measured in pages-per-minute (impressions per minute), so ePimpressionsPerHour is a natural extension.)')
prtmediapathmediasizeunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmediasizeunit.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmediasizeunit.setDescription('The units of measure of media size for use in calculating and relaying dimensional values for all media paths in the printer.')
prtmediapathmaxspeed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxspeed.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxspeed.setDescription("The maximum printing speed of this media path expressed in prtMediaPathMaxSpeedUnit's. A value of (-1) implies 'other'. Additional information: The page size for this performance is 8.5 x 11.")
prtmediapathmaxmediafeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxmediafeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxmediafeeddir.setDescription("The maximum physical media size in the feed direction of this media path expressed in units of measure specified by PrtMediaPathMediaSizeUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 140000 if prtInputDimUnit is ePtenThousandthsOfInches or 355600 if prtInputDimUnit is ePmicrometers. (140000 is the value arrived at because legal paper is the longest allowable on the LaserJet 3300 products.)")
prtmediapathmaxmediaxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxmediaxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxmediaxfeeddir.setDescription("The maximum physical media size across the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 85000 if prtInputDimUnit is ePtenThousandthsOfInches or 216000 if prtInputDimUnit is ePmicrometers.")
prtmediapathminmediafeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathminmediafeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathminmediafeeddir.setDescription("The minimum physical media size in the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 50000 if prtInputDimUnit is ePtenThousandthsOfInches or 127000 if prtInputDimUnit is ePmicrometers.")
prtmediapathminmediaxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathminmediaxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathminmediaxfeeddir.setDescription("The minimum physical media size across the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 30000 if prtInputDimUnit is ePtenThousandthsOfInches or 76200 if prtInputDimUnit is ePmicrometers. This size corresponds to a Monarch envelope. ")
prtmediapathtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5))).clone(namedValues=NamedValues(("ePsimplex", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathtype.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathtype.setDescription('The type of the media path for this media path. Additional information: This object describes how many paths there are through the engine disregarding the paper source (tray 1, 2, or 3). For the LaserJet 3300 products there is exactly one such path, a simplex path.')
prtmediapathdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathdescription.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathdescription.setDescription('The manufacturer-provided description of this media path in the localization specified by prtGeneralCurrentLocalization. Additional information: The LaserJet 3300 products has one paper path, a simplex path.')
prtmediapathstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathstatus.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathstatus.setDescription('The current status of this media path. Additional information: The LaserJet 3300 products have one paper path, a simplex path. The default values assume the printer is idle. Default - 0 (Available and Idle) paper motion - 6 (Available and Busy) paper out in all trays - 9 (Non-Critical Alert(8) + Unavailable and OnRequest(1)) paper mount (any tray) - 0 (Available and Idle) manual feed prompt (PaperMount) - 48 (Critical Alert (16) + OffLine (32))')
prtchanneltype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 7, 10, 11, 15, 34, 38))).clone(namedValues=NamedValues(("ePother", 1), ("ePchIEEE1284Port", 5), ("ePchAppleTalkPAP", 7), ("ePchNetwarePServer", 10), ("ePchPort9100", 11), ("ePchDLCLLCPort", 15), ("ePchUSB", 34), ("ePchBidirPortTCP", 38)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchanneltype.setStatus('optional')
if mibBuilder.loadTexts: prtchanneltype.setDescription('The type of this print data channel. This object provides the linkage to ChannelType-specific groups that may (conceptually) extend the prtChannelTable with additional details about that channel.')
prtchannelprotocolversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelprotocolversion.setStatus('optional')
if mibBuilder.loadTexts: prtchannelprotocolversion.setDescription('The version of the protocol used on this channel. The format used for version numbering depends on prtChannelType. Additional information: The channel 1 value includes (separated by semi colons) different aspects of the spec: electrical: logical: and physical connector.')
prtchannelcurrentjobcntllangindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelcurrentjobcntllangindex.setStatus('optional')
if mibBuilder.loadTexts: prtchannelcurrentjobcntllangindex.setDescription("The value of prtInterpreterIndex corresponding to the Control Language Interpreter for this channel. This interpreter defines the syntax used for control functions, such as querying or changing environment variables and identifying job boundaries (e.g. PJL, PostScript, NPAP). Must be 1 or greater. Additional information: This object points to the PJL language. It is read-only because PJL is the printer's only job control language.")
prtchanneldefaultpagedesclangindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtchanneldefaultpagedesclangindex.setStatus('optional')
if mibBuilder.loadTexts: prtchanneldefaultpagedesclangindex.setDescription('The value of prtInterpreterIndex corresponding to the Page Description Language Interpreter for this channel. This interpreter defines the default Page Description Language interpreter to be used for the print data unless the Control Language is used to select a specific interpreter (e.g., PCL, PostScript Language, auto-sense). Must be 1 or greater. Additional information: The default points to the automatic language switcher. If this object is changed for one channel, all channels will be changed.')
prtchannelstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("ePother", 1), ("ePprintDataAccepted", 3), ("ePnoDataAccepted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelstate.setStatus('optional')
if mibBuilder.loadTexts: prtchannelstate.setDescription("The state of this print data channel. The value determines whether control information and print data is allowed through this channel or not. Additional information: The base-printer's ports always report a value of ePprintDataAccepted. If the printer is offline, that is detected by reading the Host Resources General Printer Status objects, not by reading this object.")
prtchannelifindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelifindex.setStatus('optional')
if mibBuilder.loadTexts: prtchannelifindex.setDescription('The value of ifIndex (in the ifTable; see the interface section of MIB-2/RFC 1213) which corresponds to this channel. When more than one row of the ifTable is relevant, this is the index of the row representing the topmost layer in the interface hierarchy. A value of zero indicates that no interface is associated with this channel.')
prtchannelstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelstatus.setStatus('optional')
if mibBuilder.loadTexts: prtchannelstatus.setDescription('The current status of the channel.')
prtchannelinformation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelinformation.setStatus('optional')
if mibBuilder.loadTexts: prtchannelinformation.setDescription("Auxiliary information to allow a printing application to use the channel for data submission to the printer. An application capable of using a specific PrtChannelType should be able to use the combined information from the prtChannelInformation and other channel and interface group objects to 'bootstrap' its use of the channel. prtChannelInformation is not intended to provide a general channel description, nor to provide information that is available once the channel is in use. The encoding and interpretation of the prtChannelInformation object is specific to channel type. The description of each PrtChannelType enum value for which prtChannelInformation is defined specifies the appropriate encoding and interpretation, including interaction with other objects. For channel types that do not specify a prtChannelInformation value, its value shall be null (0 length). When a new PrtChannelType enumeration value is registered, its accompanying description must specify the encoding and interpretation of the prtChannelInformation value for the channel type. prtChannelInformation semantics for an existing PrtChannelType may be added or amended in the same manner as described in section 2.4.1 for type 2 enumeration values. The prtChannelInformation specifies values for a collection of channel attributes, represented as text according to the following rules: 1. The prtChannelInformation is coded in the NVT ASCII character set. It is not affected by localization. 2. The prtChannelInformation is a list of entries representing the attribute values. Each entry consists of the following items, in order: a. a keyword, composed of alphabetic characters (A-Z, a-z), that identifies a channel attribute, b. an Equals Sign (=) to delimit the keyword, c. a data value, consisting of NVT ASCII graphics characters (codes 32-126), d. a Line Feed character (code 10) to delimit the data value. No other characters shall be present. Keywords are case-sensitive. Conventionally, keywords are capitalized (including each word of a multi-word keyword), and, since they occupy space in the prtChannelInformation, they are kept short. 3. If a channel attribute has multiple values, it is represented by multiple entries with the same keyword, each specifying one value. Otherwise, there shall be at most one entry for each attribute. 4. By default, entries may appear in any order. If there are ordering constraints for particular entries, these must be specified in their definitions. 5. The prtChannelInformation value may represent information that is not normally coded in textual form, or that is coded in a character set other than NVT ASCII. In these cases, whatever symbolic representation is conventionally used for the information should be used for encoding the prtChannelInformation. (For instance, a binary port value might be represented as a decimal number, Unicode would be represented in UTF-8 format.) 6. For each PrtChannelType for which prtChannelInformation entries are defined, the descriptive text associated with the PrtChannelType enumeration value shall specify the following information for each entry: Title: Brief description phrase, e.g.: 'Port name', 'Service Name', Keyword: The keyword value, eg: 'Port', 'Service' Syntax: The encoding of the entry value, if it cannot be directly represented by NVT ASCII, Status: 'Mandatory', 'Optional', or 'Conditionally Mandatory', Multiplicity: 'Single' or 'Multiple', to indicate whether the entry may be present multiple times, Description: Description of the use of the entry, other information required to complete the definition (e.g.: ordering contstraints, interactions between entries). Applications that interpret prtChannelInformation should ignore unrecognized entries, so they are not affected if new entry types are added.")
prtinterpreterlangfamily = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 37, 47))).clone(namedValues=NamedValues(("ePother", 1), ("ePlangPCL", 3), ("ePlangPJL", 5), ("ePlangPS", 6), ("ePlangAutomatic", 37), ("ePlangPCLXL", 47)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlangfamily.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlangfamily.setDescription("The family name of a Page Description Language (PDL) or control language which this interpreter in the printer can interpret or emulate. Additional information: ePlangAutomatic refers to the 'super-language' made available by implicit language switching.")
prtinterpreterlanglevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlanglevel.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlanglevel.setDescription("The level of the language which this interpreter is interpreting or emulating. This might contain a value like '5e' for an interpreter which is emulating level 5e of the PCL language. It might contain '2' for an interpreter which is emulating level 2 of the PostScript language. Similarly it might contain '2' for an interpreter which is emulating level 2 of the HPGL language.")
prtinterpreterlangversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlangversion.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlangversion.setDescription('The date code or version of the language which this interpreter is interpreting or emulating. Additional information: These values are derived from the dateCode field of the personality entities. (ePlangautomatic uses the PJL dateCode.) For PostScript, this is more detailed revision information.')
prtinterpreterdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterdescription.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdescription.setDescription('A string to identify this interpreter in the localization specified by prtGeneralCurrentLocalization as opposed to the language which is being interpreted. It is anticipated that this string will allow manufacturers to unambiguously identify their interpreters. Additional information: None of these strings are localized.')
prtinterpreterversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterversion.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterversion.setDescription('The date code, version number, or other product specific information tied to this interpreter. This value is associated with the interpreter, rather than with the version of the language which is being interpreted or emulated. Additional information: Same as prtInterpreterLangVersion.')
prtinterpreterdefaultorientation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePportrait", 3), ("ePlandscape", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinterpreterdefaultorientation.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultorientation.setDescription('The current orientation default for this interpreter. This value may be overridden for a particular job (e.g., by a command in the input data stream). Additional information: Interpreters 1 and 2 ignore the value of this object. The values for PCL and PostScript are either ePportrait or ePlandscape; attempting to set them to a different value will cause <badValue> to be returned. Setting this object for one interpreter will change it for all installed interpreters.')
prtinterpreterfeedaddressability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterfeedaddressability.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterfeedaddressability.setDescription('The maximum interpreter addressability in the feed direction in 10000 prtMarkerAddressabilityUnits (see prtMarkerAddressabilityFeedDir ) for this interpreter. The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter.')
prtinterpreterxfeedaddressability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterxfeedaddressability.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterxfeedaddressability.setDescription('The maximum interpreter addressability in the cross feed direction in 10000 prtMarkerAddressabilityUnits (see prtMarkerAddressabilityXFeedDir) for this interpreter. The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter.')
prtinterpreterdefaultcharsetin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 12, 13, 20, 21, 22, 23, 24, 25, 26, 1004, 2000, 2001, 2002, 2003, 2004, 2005, 2009, 2010, 2011, 2012, 2014, 2017, 2021, 2027))).clone(namedValues=NamedValues(("ePother", 1), ("ePcsASCII", 3), ("ePcsISOLatin1", 4), ("ePcsISOLatin2", 5), ("ePcsISOLatin5", 12), ("ePcsISOLatin6", 13), ("ePcsISO4UnitedKingdom", 20), ("ePcsISO11SwedishforNames", 21), ("ePcsISO15Italian", 22), ("ePcsISO17Spanish", 23), ("ePcsISO21German", 24), ("ePcsISO60DanishNorwegian", 25), ("ePcsISO69French", 26), ("ePcsUnicodeIBM2039", 1004), ("ePcsWindows30Latin1", 2000), ("ePcsWindows31Latin1", 2001), ("ePcsWindows31Latin2", 2002), ("ePcsWindows31Latin5", 2003), ("ePcsHPRoman8", 2004), ("ePcsAdobeStandardEncoding", 2005), ("ePcsPC850Multilingual", 2009), ("ePcsPCp852", 2010), ("ePcsPC8CodePage437", 2011), ("ePcsPC8DNDanishNorwegian", 2012), ("ePcsHPPC8Turkish", 2014), ("ePcsHPLegal", 2017), ("ePcsHPDeskTop", 2021), ("ePcsMacintosh", 2027)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetin.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetin.setDescription('The default coded character set for input octets encountered outside a context in which the Page Description Language established the interpretation of the octets. (Input octets are presented to the interpreter through a path defined in the channel group.) This value shall be (2) if there is no default. Additional information: ePcsAdobeStandardEncoding is the same as PSText(10J). The object corresponding to PCL has read-write acces; all others are read-only. the above list corresponds to the following symbol sets as they appear on the Control Panel: ePother( 1) - used if designated coded char. set not in list ePcsASCII( 3) - ISO-6 ePcsISOLatin1( 4) - ISO L1 ePcsISOLatin2( 5) - IS L2 ePcsISOLatin5( 12) - ISO L5 ePcsISOLatin6( 13) - ISO L6 ePcsISO4UnitedKingdom( 20) - ISO-4 ePcsISO11SwedishforNames( 21) - ISO-11 ePcsISO15Italian( 22) - ISO-15 ePcsISO17Spanish( 23) - ISO-17 ePcsISO21German( 24) - ISO-21 ePcsISO60DanishNorwegian( 25) - ISO-60 ePcsISO69French( 26) - ISO-69 ePcsUnicodeIBM2039(1004) - PC-1004 ePcsWindows30Latin1( 2000) - WIN 3.0 ePcsWindows31Latin1( 2001) - WIN L1 ePcsWindows31Latin2( 2002) - WIN L2 ePcsWindows31Latin5( 2003) - WIN L5 ePcsHPRoman8( 2004) - ROMAN-8 ePcsAdobeStandardEncoding( 2005) - PS TEXT ePcsPC850Multilingual( 2009) - PC-850 ePcsPCp852( 2010) - PC-852 ePcsPC8CodePage437( 2011) - PC-8 ePcsPC8DNDanishNorwegian( 2012) - PC-8DN ePcsHPPC8Turkish( 2014) - PC-8 TK ePcsHPLegal( 2017) - LEGAL ePcsHPDeskTop( 2021) - DESKTOP ePcsMacintosh(2027) - MC TEXT')
prtinterpreterdefaultcharsetout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 2004, 2005))).clone(namedValues=NamedValues(("ePcsNoDefault", 2), ("ePcsASCII", 3), ("ePcsHPRoman8", 2004), ("ePcsAdobeStandardEncoding", 2005)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetout.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetout.setDescription("The default character set for data coming from this interpreter through the printer's output channel (i.e. the 'backchannel'). This value shall be (2) if there is no default.")
prtinterpretertwoway = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePyes", 3), ("ePno", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpretertwoway.setStatus('optional')
if mibBuilder.loadTexts: prtinterpretertwoway.setDescription('Indicates whether or not this interpreter returns information back to the host.')
prtconsoledisplaybuffertext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledisplaybuffertext.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledisplaybuffertext.setDescription("The content of a line in the logical display buffer of the operator's console of the printer. When a write operation occurs, normally a critical message, to one of the LineText strings, the agent should make that line displayable if a physical display is present. Writing a zero length string clears the line. It is an implementation-specific matter as to whether the agent allows a line to be overwritten before it has been cleared. Printer generated strings shall be in the localization specified by prtConsoleLocalization. Management Application generated strings should be localized by the Management Application. Additional information: In the case of a 2-line display message, prtConsoleDisplayBufferText.1 maps to the first line and prtConsoleDisplayBufferText.2 maps to the second. In the case of a 1-line display message, prtConsoleDisplayBufferText.1 maps to the first line and prtConsoleDisplayBufferText.2 return NULL.")
prtconsoleontime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoleontime.setStatus('optional')
if mibBuilder.loadTexts: prtconsoleontime.setDescription('This object, in conjunction with prtConsoleOffTime, defines the current status of the light. If both prtConsoleOnTime and prtConsoleOffTime are non-zero, the lamp is blinking and the values presented define the on time and off time, respectively, in milliseconds. If prtConsoleOnTime is zero and prtConsoleOffTime is non-zero, the lamp is off. If prtConsoleOffTime is zero and prtConsoleOnTime is non-zero, the lamp is on. If both values are zero the status of the lamp is undefined. Additional information: There are two control panel LEDs: Attention and Off-hook. When an LED blinks, it is on for one half second and off for one half second. The value used for this object is 500 when the LED is on or blinking, otherwise it is zero. When the LEDs are in a cycling state the value of this object for all LEDs is zero and the value for prtConsoleOffTime for all LEDs is zero.')
prtconsoleofftime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoleofftime.setStatus('optional')
if mibBuilder.loadTexts: prtconsoleofftime.setDescription('This object, in conjunction with prtConsoleOnTime, defines the current status of the light. If both prtConsoleOnTime and prtConsoleOffTime are non-zero, the lamp is blinking and the values presented define the on time and off time, respectively, in milliseconds. If prtConsoleOnTime is zero and prtConsoleOffTime is non-zero, the lamp is off. If prtConsoleOffTime is zero and prtConsoleOnTime is non-zero, the lamp is on. If both values are zero the status of the lamp is undefined. Additional information: There are 2 control panel LEDs: Attention and Off-Hook. When an LED blinks, it is on for one half second and off for one half second. The value used for this object is 500 when the LED is off or blinking, otherwise it is zero. When the LEDs are in a cycling state the value of this object for all LEDs is zero and the value for prtConsoleOnTime for all LEDs is zero.')
prtconsolecolor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePwhite", 3), ("ePred", 4), ("ePgreen", 5), ("ePblue", 6), ("ePcyan", 7), ("ePmagenta", 8), ("ePyellow", 9), ("ePorange", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolecolor.setStatus('optional')
if mibBuilder.loadTexts: prtconsolecolor.setDescription('The color of this light.')
prtconsoledescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledescription.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledescription.setDescription('The vendor description or label of this light in the localization specified by prtConsoleLocalization.')
prtalertseveritylevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePcriticalBinaryChangeEvent", 3), ("ePwarningUnaryChangeEvent", 4), ("ePwarningBinaryChangeEvent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertseveritylevel.setStatus('optional')
if mibBuilder.loadTexts: prtalertseveritylevel.setDescription('The level of severity of this alert table entry. The printer determines the severity level assigned to each entry into the table.')
prtalerttraininglevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePuntrained", 3), ("ePtrained", 4), ("ePfieldService", 5), ("ePmanagement", 6), ("ePnoInterventionRequired", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalerttraininglevel.setStatus('optional')
if mibBuilder.loadTexts: prtalerttraininglevel.setDescription('See textual convention PrtAlertTrainingLevelTC Additional information: The value of this object depends on the alert condition as follows: ePuntrained: Paper low/out. ePtrained: Toner low. ePfieldService: Marker failure. ePmanagement: Configuration change.')
prtalertgroup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 8, 9, 10, 14))).clone(namedValues=NamedValues(("ePgeneralPrinter", 5), ("ePcover", 6), ("ePinput", 8), ("ePoutput", 9), ("ePmarker", 10), ("ePchannel", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertgroup.setStatus('optional')
if mibBuilder.loadTexts: prtalertgroup.setDescription('The type of sub-unit within the printer model that this alert is related. Input, output, and markers are examples of printer model groups, i.e., examples of types of sub-units. Wherever possible, these enumerations match the sub-identifier that identifies the relevant table in the printmib.')
prtalertgroupindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertgroupindex.setStatus('optional')
if mibBuilder.loadTexts: prtalertgroupindex.setDescription('An index of the row within the principle table in the group identified by prtAlertGroup that represents the sub-unit of the printer that caused this alert. The combination of the prtAlertGroup and the prtAlertGroupIndex defines exactly which printer sub-unit caused the alert.; for example, Input #3, Output #2, and Marker #1. Every object in this MIB is indexed with hrDeviceIndex and optionally, another index variable. If this other index variable is present in the table that generated the alert, it will be used as the value for this object. Otherwise, this value shall be -1.')
prtalertlocation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertlocation.setStatus('optional')
if mibBuilder.loadTexts: prtalertlocation.setDescription('The sub-unit location that is defined by the printer manufacturer to further refine the location of this alert within the designated sub-unit. The location is used in conjunction with the Group and GroupIndex values; for example, there is an alert in Input #2 at location number 7. The value (-2) indicates unknown.')
prtalertcode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 8, 801, 808))).clone(namedValues=NamedValues(("ePother", 1), ("ePcoverOpened", 3), ("ePjam", 8), ("ePinputMediaTrayMissing", 801), ("ePinputMediaSupplyEmpty", 808)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertcode.setStatus('optional')
if mibBuilder.loadTexts: prtalertcode.setDescription('See associated textual convention PrtAlertCodeTC Additional information: ePother is returned for a variety of conditions, including: page punt, io buffer overflow, memory overflow, and warming up. ePcoverOpened is returned for both door open (top) and/or toner cartridge missing. ePinputMediaTrayMissing is returned when paper is out in all trays. And, ePinputMediaSupplyEmpty is returned for a paper prompt.')
prtalertdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertdescription.setStatus('optional')
if mibBuilder.loadTexts: prtalertdescription.setDescription("A description of this alert entry in the localization specified by prtGeneralCurrentLocalization. The description is provided by the printer to further elaborate on the enumerated alert or provide information in the case where the code is classified as `other' or `unknown'. The printer is required to return a description string but the string may be a null string.")
prtalerttime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalerttime.setStatus('optional')
if mibBuilder.loadTexts: prtalerttime.setDescription('The value of sysUpTime at the time that this alert was generated. Additional information: This object is always zero.')
mibBuilder.exportSymbols("LaserJet_3300-MIB", dial=dial, prtmediapathmaxspeedprintunit=prtmediapathmaxspeedprintunit, not_ready_source_scanner=not_ready_source_scanner, prtGeneral=prtGeneral, prtGeneralTable=prtGeneralTable, fax_print_page_count=fax_print_page_count, prtconsolenumberofdisplaychars=prtconsolenumberofdisplaychars, prtconsoledisplaybuffertext=prtconsoledisplaybuffertext, faxjob_tx_error_1=faxjob_tx_error_1, prtmarkersuppliesclass=prtmarkersuppliesclass, fax_tx_phone_number=fax_tx_phone_number, copier_fit_to_page=copier_fit_to_page, prtconsoleofftime=prtconsoleofftime, pcl_default_font_height=pcl_default_font_height, fax_forwarding=fax_forwarding, channel_bytes_received=channel_bytes_received, scan_image_type=scan_image_type, prtinterpreterlangfamily=prtinterpreterlangfamily, device_location=device_location, scanner_motor_control=scanner_motor_control, prtmediapathmaxmediafeeddir=prtmediapathmaxmediafeeddir, error7=error7, prtinputdescription=prtinputdescription, copier_job_collation=copier_job_collation, prtinterpreterlangversion=prtinterpreterlangversion, default_bits_per_pixel=default_bits_per_pixel, hrPrinterTable=hrPrinterTable, default_lines_per_page=default_lines_per_page, job_info_name2=job_info_name2, faxjob_tx_current_page_1=faxjob_tx_current_page_1, prtinputmediadimfeeddirdeclared=prtinputmediadimfeeddirdeclared, job_info_io_source=job_info_io_source, fax_log_action=fax_log_action, cold_reset_media_size=cold_reset_media_size, error10_time_stamp=error10_time_stamp, prtmarkeraddressabilityfeeddir=prtmarkeraddressabilityfeeddir, hrDeviceTable=hrDeviceTable, hrm=hrm, fax_job_control=fax_job_control, ui_delete_option=ui_delete_option, fax_upload_token=fax_upload_token, auto_continue=auto_continue, service_password=service_password, copier_job_contrast=copier_job_contrast, prtalertgroup=prtalertgroup, phone=phone, fax_dial_mode=fax_dial_mode, hrDevice=hrDevice, scanner_jam_page_count=scanner_jam_page_count, processing_subsystem=processing_subsystem, prtLocalization=prtLocalization, current_job_parsing_id=current_job_parsing_id, fax_send=fax_send, download_timeout=download_timeout, error8_time_stamp=error8_time_stamp, prtlocalizationcountry=prtlocalizationcountry, faxjob_tx_status_1=faxjob_tx_status_1, fax_thumbnail_enable=fax_thumbnail_enable, default_page_protect=default_page_protect, settings_io=settings_io, io_timeout=io_timeout, hrstorageused=hrstorageused, on_off_line=on_off_line, copier=copier, fax_num_rings_pickup=fax_num_rings_pickup, device_cfg_download_data_type=device_cfg_download_data_type, channel_table=channel_table, settings_pdl=settings_pdl, faxjob_rx_status_1=faxjob_rx_status_1, channel_jobs_received=channel_jobs_received, prtmediapathminmediafeeddir=prtmediapathminmediafeeddir, job_info_attr_3=job_info_attr_3, prtStorageRefEntry=prtStorageRefEntry, tables=tables, pysmi_continue=pysmi_continue, dial_all_lines=dial_all_lines, fax_download_page_count=fax_download_page_count, prtMediaPath=prtMediaPath, copier_adf_page_count=copier_adf_page_count, scan_adf_page_count=scan_adf_page_count, scan_height=scan_height, channel_io_errors=channel_io_errors, prtmarkerstatus=prtmarkerstatus, prtmarkercounterunit=prtmarkercounterunit, fax_redial_time=fax_redial_time, prtchannelcurrentjobcntllangindex=prtchannelcurrentjobcntllangindex, faxjob_tx_current_page=faxjob_tx_current_page, simm1=simm1, pcl_default_font_width=pcl_default_font_width, status_pdl=status_pdl, settings_system=settings_system, prtConsoleLightTable=prtConsoleLightTable, scanner_light_monitor_window=scanner_light_monitor_window, job_info_attr_10=job_info_attr_10, hrdeviceindex=hrdeviceindex, DisplayString=DisplayString, default_media_size=default_media_size, prtInput=prtInput, prtconsoledisable=prtconsoledisable, scan_max_line_width=scan_max_line_width, prtinputtype=prtinputtype, prtoutputcapacityunit=prtoutputcapacityunit, fax_ring_enable=fax_ring_enable, answer=answer, default_ret=default_ret, hp=hp, fax_pulse_dial_support=fax_pulse_dial_support, prtinputstatus=prtinputstatus, copier_reduction=copier_reduction, fax_additional_wait=fax_additional_wait, prtchannelifindex=prtchannelifindex, dm=dm, scanner_reference_position=scanner_reference_position, prtmarkersuppliesmarkerindex=prtmarkersuppliesmarkerindex, copier_job=copier_job, scanner_button_status=scanner_button_status, settings_fax_proc_sub=settings_fax_proc_sub, job_info_outbins_used=job_info_outbins_used, device_cfg_upload_error=device_cfg_upload_error, scan_compression=scan_compression, error4_time_stamp=error4_time_stamp, fax_pixel_data_type=fax_pixel_data_type, default_vertical_black_resolution=default_vertical_black_resolution, fax_rxscale=fax_rxscale, ui_add_option=ui_add_option, error1_code=error1_code, prtinterpreterdefaultcharsetin=prtinterpreterdefaultcharsetin, prtalertlocation=prtalertlocation, copier_print_page_count=copier_print_page_count, prtmarkerspotcolorants=prtmarkerspotcolorants, error4_code=error4_code, prtAlert=prtAlert, settings_fax_send=settings_fax_send, error2=error2, pcl_default_font_source=pcl_default_font_source, fax_allow_redials=fax_allow_redials, device_name=device_name, faxjob_action=faxjob_action, prtmarkermarktech=prtmarkermarktech, prtAlertEntry=prtAlertEntry, faxjob_rx_id=faxjob_rx_id, fax_line_interface_unit_id=fax_line_interface_unit_id, copier_num_copies=copier_num_copies, date_and_time=date_and_time, prtinterpreterversion=prtinterpreterversion, prtinterpreterdefaultorientation=prtinterpreterdefaultorientation, error8=error8, faxjob_tx_error=faxjob_tx_error, prtLocalizationTable=prtLocalizationTable, form_feed=form_feed, settings_fax_job=settings_fax_job, copier_reduction_maximum=copier_reduction_maximum, print_density=print_density, error2_time_stamp=error2_time_stamp, fax_adf_scan_count=fax_adf_scan_count, error_log_clear=error_log_clear, collated_originals_support=collated_originals_support, copier_job_media_size=copier_job_media_size, prtinputmediadimfeeddirchosen=prtinputmediadimfeeddirchosen, prtinterpreterdefaultcharsetout=prtinterpreterdefaultcharsetout, sleep_mode=sleep_mode, error6=error6, fax_activity_log=fax_activity_log, faxjob=faxjob, interface=interface, error7_time_stamp=error7_time_stamp, job_info_physical_outbins_used=job_info_physical_outbins_used, faxjob_action_id=faxjob_action_id, fax_master_host=fax_master_host, settings_scanner=settings_scanner, prtmediapathmaxmediaxfeeddir=prtmediapathmaxmediaxfeeddir, copier_token=copier_token, device=device, fw_rom_datecode=fw_rom_datecode, system=system, status_system=status_system, prtMediaPathEntry=prtMediaPathEntry, prtmediapathdefaultindex=prtmediapathdefaultindex, fax_dial_tone_detection=fax_dial_tone_detection, prtoutputstatus=prtoutputstatus, fax_phone_pickup_enable=fax_phone_pickup_enable, status_scanner=status_scanner, prtinputdefaultindex=prtinputdefaultindex, intrays=intrays, prtinterpreterdescription=prtinterpreterdescription, hrstorageallocationfailures=hrstorageallocationfailures, error9=error9, prtchannelprotocolversion=prtchannelprotocolversion, prtmarkerwestmargin=prtmarkerwestmargin, job_info_pages_processed=job_info_pages_processed, scan_subsample=scan_subsample, error10=error10, copier_quality=copier_quality, prtmarkersouthmargin=prtmarkersouthmargin, hrprinterdetectederrorstate=hrprinterdetectederrorstate, settings_prt_eng=settings_prt_eng, faxjob_rx_duration_1=faxjob_rx_duration_1, hrstorageindex=hrstorageindex, custom_paper_xfeed_dim=custom_paper_xfeed_dim, job_info_attr_5=job_info_attr_5, hrstoragesize=hrstoragesize, error10_code=error10_code, job_info_attr_16=job_info_attr_16, prtconsoledescription=prtconsoledescription, prtgeneralprintername=prtgeneralprintername, prtMarkerTable=prtMarkerTable, status_prt_eng=status_prt_eng, prtMarkerSuppliesEntry=prtMarkerSuppliesEntry, prtDeviceRefEntry=prtDeviceRefEntry, prtinputmaxcapacity=prtinputmaxcapacity, job_being_parsed=job_being_parsed, job_info_attr_11=job_info_attr_11, prtmarkerlifecount=prtmarkerlifecount, job_info_attr_7=job_info_attr_7, copier_collation=copier_collation, install_date=install_date, job_info_name1=job_info_name1, prtinterpreterfeedaddressability=prtinterpreterfeedaddressability, settings_intray=settings_intray, prtAlertTable=prtAlertTable, copier_job_num_copies=copier_job_num_copies, prtLocalizationEntry=prtLocalizationEntry, prtMarker=prtMarker, error6_time_stamp=error6_time_stamp, error3_time_stamp=error3_time_stamp, answer_all_lines=answer_all_lines, prtinputdimunit=prtinputdimunit, hrstorageallocationunits=hrstorageallocationunits, prtChannelEntry=prtChannelEntry, pdl_pcl=pdl_pcl, job_info_attr_4=job_info_attr_4, scan_calibration_target=scan_calibration_target, default_horizontal_black_resolution=default_horizontal_black_resolution, pcl_resource_saving_memory_size=pcl_resource_saving_memory_size, hrdeviceid=hrdeviceid, io_switch=io_switch, hrdevicestatus=hrdevicestatus, simm1_capacity=simm1_capacity, copier_contrast=copier_contrast, transmit_fax=transmit_fax, prtoutputmaxcapacity=prtoutputmaxcapacity, faxjob_tx_type=faxjob_tx_type, hrPrinterEntry=hrPrinterEntry, scan_compression_factor=scan_compression_factor, fax_local_phone_num=fax_local_phone_num, serial_number=serial_number, fax_beep_volume=fax_beep_volume, prtchanneldefaultpagedesclangindex=prtchanneldefaultpagedesclangindex, scan_contrast=scan_contrast, prtmarkerpoweroncount=prtmarkerpoweroncount, default_scanner_margin_top=default_scanner_margin_top, scan_token=scan_token, prtConsoleLights=prtConsoleLights, not_ready_fax_receive=not_ready_fax_receive)
mibBuilder.exportSymbols("LaserJet_3300-MIB", prtOutputEntry=prtOutputEntry, fax_max_redials=fax_max_redials, fax_report_activity_log=fax_report_activity_log, pdl=pdl, hrdeviceerrors=hrdeviceerrors, job_info_change_id=job_info_change_id, prtgeneralserialnumber=prtgeneralserialnumber, prtchannelstatus=prtchannelstatus, prtconsolenumberofdisplaylines=prtconsolenumberofdisplaylines, custom_paper_dim_unit=custom_paper_dim_unit, prtalertseveritylevel=prtalertseveritylevel, prtconsolecolor=prtconsolecolor, model_name=model_name, error5_time_stamp=error5_time_stamp, prtConsoleLightEntry=prtConsoleLightEntry, prtoutputremainingcapacity=prtoutputremainingcapacity, maximum_resource_saving_memory=maximum_resource_saving_memory, copier_job_pages_per_sheet=copier_job_pages_per_sheet, fax_silent_detection=fax_silent_detection, wide_a4=wide_a4, prtmarkerdefaultindex=prtmarkerdefaultindex, intray=intray, hrStorageEntry=hrStorageEntry, scan_resolution_range=scan_resolution_range, status_fax_job=status_fax_job, prtalertallevents=prtalertallevents, prtMediaPathTable=prtMediaPathTable, scanner_adf_page_count=scanner_adf_page_count, device_cfg_upload=device_cfg_upload, job_info_attr_2=job_info_attr_2, device_ring_type_pickup=device_ring_type_pickup, prtmediapathmediasizeunit=prtmediapathmediasizeunit, fax_upload_page_count=fax_upload_page_count, prtalertcriticalevents=prtalertcriticalevents, prtMarkerSuppliesTable=prtMarkerSuppliesTable, job_info_attr_6=job_info_attr_6, channel_bytes_sent=channel_bytes_sent, prtinterpreterlanglevel=prtinterpreterlanglevel, default_scanner_margin_right=default_scanner_margin_right, prtMarkerSupplies=prtMarkerSupplies, prtinputcurrentlevel=prtinputcurrentlevel, fax_noise_volume=fax_noise_volume, imaging=imaging, prtlocalizationcharacterset=prtlocalizationcharacterset, prtoutputtype=prtoutputtype, prtInterpreter=prtInterpreter, copier_job_fit_to_page=copier_job_fit_to_page, prtConsoleDisplayBufferTable=prtConsoleDisplayBufferTable, faxjob_tx_id=faxjob_tx_id, faxjob_tx_status=faxjob_tx_status, job_info_pages_printed=job_info_pages_printed, scanner_lamp_gain_value=scanner_lamp_gain_value, scan_upload=scan_upload, copier_enlargement_maximum=copier_enlargement_maximum, error1=error1, hrmemorysize=hrmemorysize, error7_code=error7_code, fax_download_error=fax_download_error, prtmarkersupplieslevel=prtmarkersupplieslevel, hrdevicedescr=hrdevicedescr, error1_time_stamp=error1_time_stamp, prtinputmedianame=prtinputmedianame, faxjob_upload_id=faxjob_upload_id, fax_forwarding_phone_num=fax_forwarding_phone_num, error4=error4, faxjob_download_id=faxjob_download_id, prtchannelinformation=prtchannelinformation, error3=error3, job_info_attr_13=job_info_attr_13, prtalerttime=prtalerttime, pjl_password=pjl_password, fax_upload_error=fax_upload_error, job_info_stage=job_info_stage, id=id, prtgeneralreset=prtgeneralreset, prtChannel=prtChannel, scan_calibration_download=scan_calibration_download, test=test, prtCover=prtCover, prtinputmediadimxfeeddirdeclared=prtinputmediadimxfeeddirdeclared, prtinputmediadimxfeeddirchosen=prtinputmediadimxfeeddirchosen, hrdevicetype=hrdevicetype, prtmarkersuppliestype=prtmarkersuppliestype, fax_log_reporting=fax_log_reporting, print_engine_mispick_count=print_engine_mispick_count, status_fax_proc_sub=status_fax_proc_sub, prtCoverEntry=prtCoverEntry, device_cfg_download=device_cfg_download, fax_download_token=fax_download_token, settings_faxlog=settings_faxlog, channel_entry=channel_entry, job_info_attr_9=job_info_attr_9, prtalerttraininglevel=prtalerttraininglevel, device_redial=device_redial, prtinputname=prtinputname, prtmarkersuppliesdescription=prtmarkersuppliesdescription, faxjob_tx_duration=faxjob_tx_duration, scanner_flatbed_page_count=scanner_flatbed_page_count, prtmarkersuppliescolorantindex=prtmarkersuppliescolorantindex, prtinterpreterxfeedaddressability=prtinterpreterxfeedaddressability, scan_calibration=scan_calibration, energy_star=energy_star, dark_courier=dark_courier, fax_alarm_volume=fax_alarm_volume, prtmediapathstatus=prtmediapathstatus, total_engine_page_count=total_engine_page_count, fax_max_rings_pickup=fax_max_rings_pickup, prtConsoleDisplayBufferEntry=prtConsoleDisplayBufferEntry, scan_resolution=scan_resolution, custom_paper_feed_dim=custom_paper_feed_dim, copier_job_quality=copier_job_quality, prtInterpreterEntry=prtInterpreterEntry, prtmediapathtype=prtmediapathtype, scan_flatbed_page_count=scan_flatbed_page_count, asset_number=asset_number, printmib=printmib, ui_select_option=ui_select_option, prtChannelTable=prtChannelTable, device_config_token=device_config_token, print_internal_page=print_internal_page, prtalertdescription=prtalertdescription, error8_code=error8_code, prtmarkersuppliesmaxcapacity=prtmarkersuppliesmaxcapacity, job_info_outcome=job_info_outcome, time_display=time_display, hrprinterstatus=hrprinterstatus, prtalertgroupindex=prtalertgroupindex, fax_contrast=fax_contrast, scan_pad_image=scan_pad_image, scan_upload_error=scan_upload_error, scanner_scanline_statistics=scanner_scanline_statistics, hrstoragetype=hrstoragetype, prtmarkeraddressabilityxfeeddir=prtmarkeraddressabilityxfeeddir, upload_timeout=upload_timeout, prtgeneralcurrentlocalization=prtgeneralcurrentlocalization, faxjob_rx_duration=faxjob_rx_duration, prtOutputTable=prtOutputTable, fax_receive=fax_receive, print_engine_jam_count=print_engine_jam_count, job_info_attribute=job_info_attribute, prtmarkeraddressabilityunit=prtmarkeraddressabilityunit, prtGeneralEntry=prtGeneralEntry, job_info_attr_12=job_info_attr_12, device_cfg_upload_data_type=device_cfg_upload_data_type, destination_subsystem=destination_subsystem, prtCoverTable=prtCoverTable, job_info=job_info, prtmarkersuppliessupplyunit=prtmarkersuppliessupplyunit, device_cfg_download_error=device_cfg_download_error, fax_answer_mode=fax_answer_mode, error5_code=error5_code, prtgeneralcurrentoperator=prtgeneralcurrentoperator, fax_firmware_revision=fax_firmware_revision, prtConsoleDisplayBuffer=prtConsoleDisplayBuffer, default_copies=default_copies, hrStorage=hrStorage, prtinputmodel=prtinputmodel, job_info_attr_1=job_info_attr_1, default_print_quality=default_print_quality, prtStorageRefTable=prtStorageRefTable, scan_gamma_correction=scan_gamma_correction, not_ready_fax_send=not_ready_fax_send, form_feed_needed=form_feed_needed, fax_error_correction_mode=fax_error_correction_mode, prtinputversion=prtinputversion, error9_time_stamp=error9_time_stamp, fax_receive_stamping_enable=fax_receive_stamping_enable, prtcoverdescription=prtcoverdescription, fax_proc_sub=fax_proc_sub, scan_control_descriptor=scan_control_descriptor, tray1_fuser_temperature=tray1_fuser_temperature, error5=error5, fax_rx_disposition=fax_rx_disposition, error9_code=error9_code, default_vmi=default_vmi, scanner=scanner, prtinputsecurity=prtinputsecurity, prtDeviceRefTable=prtDeviceRefTable, hrstoragedescr=hrstoragedescr, error3_code=error3_code, prtchanneltype=prtchanneltype, self_test=self_test, prtdevicerefindex=prtdevicerefindex, prtmarkernorthmargin=prtmarkernorthmargin, pcl_default_font_number=pcl_default_font_number, job_info_attr_14=job_info_attr_14, default_scanner_margin_left=default_scanner_margin_left, fax_min_rings_pickup=fax_min_rings_pickup, device_cfg_param_command=device_cfg_param_command, status_fax_receive=status_fax_receive, prtmediapathdescription=prtmediapathdescription, copier_pages_per_sheet_maximum=copier_pages_per_sheet_maximum, settings_copier=settings_copier, error6_code=error6_code, prtgeneralconfigchanges=prtgeneralconfigchanges, prtmarkerprocesscolorants=prtmarkerprocesscolorants, pjl=pjl, prtlocalizationlanguage=prtlocalizationlanguage, cancel_job=cancel_job, status_fax_send=status_fax_send, prtmediapathmaxspeed=prtmediapathmaxspeed, fax_download=fax_download, prtmediapathminmediaxfeeddir=prtmediapathminmediaxfeeddir, job=job, copier_flatbed_page_count=copier_flatbed_page_count, prtMarkerEntry=prtMarkerEntry, settings_job=settings_job, print_engine=print_engine, intray1=intray1, job_info_attr_15=job_info_attr_15, prtconsoleontime=prtconsoleontime, copier_job_reduction=copier_job_reduction, scanner_retrieve_scanline=scanner_retrieve_scanline, prtinputcapacityunit=prtinputcapacityunit, active_print_jobs=active_print_jobs, fax_pstn_access_code=fax_pstn_access_code, scan_calibration_error=scan_calibration_error, faxjob_rx_current_page=faxjob_rx_current_page, date_display=date_display, job_info_state=job_info_state, prtinputvendorname=prtinputvendorname, job_info_size=job_info_size, faxjob_rx_status=faxjob_rx_status, source_subsystem=source_subsystem, fax_upload=fax_upload, job_info_attr_8=job_info_attr_8, prtalertcode=prtalertcode, prtconsolelocalization=prtconsolelocalization, fax_report_transmission=fax_report_transmission, prtcoverstatus=prtcoverstatus, simm1_type=simm1_type, scanner_sensor_manufacturer=scanner_sensor_manufacturer, fax_station_name=fax_station_name, prtinputserialnumber=prtinputserialnumber, fax_ring_volume=fax_ring_volume, prtchannelstate=prtchannelstate, hrStorageTable=hrStorageTable, prtoutputdefaultindex=prtoutputdefaultindex, io=io, prtInputEntry=prtInputEntry, prtInputTable=prtInputTable, scanner_modular_hardware=scanner_modular_hardware, error2_code=error2_code, prtinterpretertwoway=prtinterpretertwoway, simm=simm, prtmarkereastmargin=prtmarkereastmargin, prtstoragerefindex=prtstoragerefindex, prtInterpreterTable=prtInterpreterTable, prtOutput=prtOutput, reprint=reprint, override_media_size=override_media_size, settings_fax_receive=settings_fax_receive, fax_country=fax_country, copier_pages_per_sheet=copier_pages_per_sheet)
mibBuilder.exportSymbols("LaserJet_3300-MIB", faxjob_rx_current_page_1=faxjob_rx_current_page_1, prtgeneralserviceperson=prtgeneralserviceperson, errorlog=errorlog, scan_pixel_data_type=scan_pixel_data_type, faxjob_tx_duration_1=faxjob_tx_duration_1, hrDeviceEntry=hrDeviceEntry, fax_resolution=fax_resolution)

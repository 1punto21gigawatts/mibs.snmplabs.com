#
# PySNMP MIB module Wellfleet-TOKEN-RING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-TOKEN-RING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:42:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, NotificationType, Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Counter64, Bits, ModuleIdentity, ObjectIdentity, IpAddress, TimeTicks, MibIdentifier, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Counter64", "Bits", "ModuleIdentity", "ObjectIdentity", "IpAddress", "TimeTicks", "MibIdentifier", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
wfLine, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfLine")
wfTokenRingTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 2), )
if mibBuilder.loadTexts: wfTokenRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTable.setDescription('TOKEN RING line record')
wfTokenRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1), ).setIndexNames((0, "Wellfleet-TOKEN-RING-MIB", "wfTokenRingSlot"), (0, "Wellfleet-TOKEN-RING-MIB", "wfTokenRingConnector"))
if mibBuilder.loadTexts: wfTokenRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingEntry.setDescription('An entry in the token table')
wfTokenRingDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDelete.setDescription('create/delete parameter.')
wfTokenRingDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDisable.setDescription('enable/disable parameter.')
wfTokenRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingState.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingState.setDescription('line driver state variable, Not Present, Init, Down, Up')
wfTokenRingSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSlot.setDescription('instance ID Slot, filled in by driver')
wfTokenRingConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingConnector.setDescription("instance ID Connector, filled in by driver. For the ASN this attribute is an encoded value and is equal to 'module'*10 + 'connector'. Where 'module' is defined in attribute 70 and 'connector' is defined in attribute 71 of this table. For non-ASN platforms this attribute is the phisical connector number on the slot")
wfTokenRingCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCct.setDescription('cct number for this line instance, configuration required')
wfTokenRingMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4568))).clone(namedValues=NamedValues(("default", 4568))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMtu.setDescription('mtu parameter, fixed. This mtu of 4568 allows a type 3 Source Route Frame (info=4472) to be IP encapsulated over Token Ring. The components are: AC_FC (2) + SNAP (12+8) + SNAP_IP (12+8+20) + SR (12+18) + TYPE3_INFO (4472) + FCS (4) --------------------- total 4568 bytes')
wfTokenRingMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMadr.setDescription('line MAC address, line driver fills in the currently used 48 bit MAC address.')
wfTokenRingCfgMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCfgMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCfgMadr.setDescription('Configured line MAC address. Only used if wfTokenRingMadrSelect is set appropriately.')
wfTokenRingMadrSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("boxwide", 1), ("prom", 2), ("cnfg", 3))).clone('prom')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingMadrSelect.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMadrSelect.setDescription('Selector determines which MAC address the interface will use.')
wfTokenRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4194304, 16777216))).clone(namedValues=NamedValues(("mbps4", 4194304), ("mbps16", 16777216))).clone('mbps16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSpeed.setDescription('Token Ring speed parameter - 4 and 16 Mbps are only valid values')
wfTokenRingEarlyTokenRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingEarlyTokenRelease.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingEarlyTokenRelease.setDescription('Early Token Release parameter, only valid with 16Mbps')
wfTokenRingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingStatus.setDescription("The current interface status. This attribute is only valid when the wfTokenRingOpenState attribute is set to OPENED. The attribute's value is a sum of values, one for each currently applicable condition (ie, bit positions indicate active conditions). Occurrences of each condition are separately counted and the counts are included in this MIB as attributes wfTokenRingSignalLosses through wfTokenRingRingRecoveries. The following values are defined: 32768 = Signal Losses 16384 = Hard Errors 8192 = Soft Errors 4096 = Transmit Beacons 2048 = Lobe Wire Faults 1024 = Auto-Removal Errors 256 = Remove Received 128 = Counter Overflows 64 = Single Stations 32 = Ring Recoveries This attribute is the most recent sum of these conditions. More information on each condition is include in the descriptions of the individual counter attributes.")
wfTokenRingOpenState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("opened", 1), ("opening", 2), ("closing", 3), ("openfailure", 4), ("ringfailure", 5), ("closed", 6))).clone('closed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOpenState.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOpenState.setDescription('The current interface state with respect to entering or leaving the ring.')
wfTokenRingOpenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("open", 1), ("badparam", 2), ("lobefailed", 3), ("signalloss", 4), ("insertiontimeout", 5), ("ringfailed", 6), ("beaconing", 7), ("duplicatemac", 8), ("requestfailed", 9), ("removereceived", 10), ("unkerror", 11), ("noopen", 12))).clone('noopen')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOpenStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOpenStatus.setDescription("Indicates the success, or the reason for failure, of the station's most recent attempt to enter the ring.")
wfTokenRingUpStream = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingUpStream.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingUpStream.setDescription("MAC address of Up Stream neighbor. Only valid when 'opened'.")
wfTokenRingRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxOctets.setDescription('Number of octets received without error.')
wfTokenRingRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxFrames.setDescription('Number of frames received without error.')
wfTokenRingTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxOctets.setDescription('Number of octets transmitted without error.')
wfTokenRingTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxFrames.setDescription('Number of frames transmitted without error.')
wfTokenRingInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingInDiscards.setDescription('Number of error-free inbound packets discarded. Usually due to lack of memory resources. This is equivalent to wfTokenRingRxCongestionErrors.')
wfTokenRingInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingInErrors.setDescription('Number of inbound packets not delivered to higher-layer protocol due to errors. The sum of wfTokenRingLineErrors and wfTokenRingBurstErrors.')
wfTokenRingOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOutDiscards.setDescription('Number of error-free outbound packets discarded. Usually due to lack of transmission bandwidth. This is equivalent to wfTokenRingTxClipFrames.')
wfTokenRingOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOutErrors.setDescription('Number of outbound packets that could not be transmitted because of errors. This is equivalent to wfTokenRingLostFrameErrors.')
wfTokenRingTxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxClipFrames.setDescription("Number of frames clipped in driver's transmit routine due to transmit congestion.")
wfTokenRingRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxReplenMisses.setDescription('Number of packet buffer misses while attempting to replenish driver receive ring.')
wfTokenRingSignalLosses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSignalLosses.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSignalLosses.setDescription('Number of ring signal losses detected.')
wfTokenRingHardErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingHardErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingHardErrors.setDescription('Number of events causing the adapter to transmit or receive beacon MAC frames.')
wfTokenRingSoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSoftErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSoftErrors.setDescription('Number of soft errors. Corresponds to the number of Report Error MAC frames transmitted by this station.')
wfTokenRingTransmitBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTransmitBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTransmitBeacons.setDescription('Number of events causing the adapter to transmit beacon frames.')
wfTokenRingLobeWireFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLobeWireFaults.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLobeWireFaults.setDescription('Number of opens or shorts (cable faults) between the adapter and the MAU.')
wfTokenRingAutoRemovalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingAutoRemovalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingAutoRemovalErrors.setDescription('Number of lobe wrap test failures during beacon auto_removal process.')
wfTokenRingRequestRemoves = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRequestRemoves.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRequestRemoves.setDescription('Number of Remove Ring Station MAC frames received. Each frame causes this station to leave the ring.')
wfTokenRingCounterOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingCounterOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCounterOverflows.setDescription('Number of adapter error counter overflows.')
wfTokenRingSingleStations = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSingleStations.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSingleStations.setDescription('Number of ring status change interrupts while adapter is only station on the ring.')
wfTokenRingRingRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRingRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRingRecoveries.setDescription('Number of claim token MAC frames (ring recoveries) observed on the ring.')
wfTokenRingAdapterChecks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingAdapterChecks.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingAdapterChecks.setDescription('Number of internal adapter errors that result in adapter crashes.')
wfTokenRingFirstAdapterCheckCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingFirstAdapterCheckCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingFirstAdapterCheckCode.setDescription('Adapter Check Code of first occurrence.')
wfTokenRingLastAdapterCheckCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLastAdapterCheckCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLastAdapterCheckCode.setDescription('Adapter Check Code of most recent (last) occurrence.')
wfTokenRingLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLineErrors.setDescription('Number of frames copied or repeated by this station with bad format or an FCS error.')
wfTokenRingBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingBurstErrors.setDescription('Number of errored frames with no transition for 5 1/2 bit times.')
wfTokenRingAriFciErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingAriFciErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingAriFciErrors.setDescription('Number of occurrences of this station receiving both an AMP MAC frame and a SMP MAC frame with the a & c bits clear or more than one SMP MAC frame with the a & c bits clear without an intervening AMP MAC frame. This condition indicates that the up-stream neighbor is unable to set the a & c bits in a frame that it has copied.')
wfTokenRingLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLostFrameErrors.setDescription('Number of frames being stripped which are missing their tails.')
wfTokenRingRxCongestionErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxCongestionErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxCongestionErrors.setDescription('Number of frames dropped due to receive congestion.')
wfTokenRingFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingFrameCopiedErrors.setDescription('Number of specifically addressed frames for this station that had their a & c bits previously set.')
wfTokenRingTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTokenErrors.setDescription('Number of token protocol errors. Only relevant when this station is the active monitor.')
wfTokenRingDmaBusErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingDmaBusErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDmaBusErrors.setDescription('Number of bus errors during DMA that do not exceed threshold.')
wfTokenRingDmaParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingDmaParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDmaParityErrors.setDescription('Number of parity errors during DMA that do not exceed threshold.')
wfTokenRingSrbNotFreeCmdAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSrbNotFreeCmdAborts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSrbNotFreeCmdAborts.setDescription('Number of host to adapter commands aborted because of in-completed in process commands.')
wfTokenRingRxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxProcessings.setDescription('Number of processings of received frames (similar to RINT).')
wfTokenRingTxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxProcessings.setDescription('Number of processings of frames for transmit.')
wfTokenRingTxCmplProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxCmplProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxCmplProcessings.setDescription('Number of processings of transmitted frames (similar to TINT).')
wfTokenRingRxTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxTimeouts.setDescription('Number of re-initializations due to receiver time-outs.')
wfTokenRingCmdTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingCmdTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCmdTimeouts.setDescription('Number of re-initializations due to command time-outs.')
wfTokenRingRxHostIntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxHostIntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxHostIntErrors.setDescription('Number of re-initializations due to receive host interface errors.')
wfTokenRingRxTxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxTxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxTxBufferSize.setDescription('Internal Adapter RAM buffer size.')
wfTokenRingCfgTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCfgTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCfgTxQueueLength.setDescription('Configured Transmit Queue Length. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based default values to be used. Values larger than the compiled ring size are truncated to the compiled ring size. ')
wfTokenRingCfgRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCfgRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCfgRxQueueLength.setDescription('Configured Receive Queue Length. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based default values to be used. Values larger than the compiled ring size are truncated to the compiled ring size. ')
wfTokenRingTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 59), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxQueueLength.setDescription('Current Transmit Queue Length.')
wfTokenRingRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxQueueLength.setDescription('Current Receive Queue Length.')
wfTokenRingMacRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMacRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMacRxOctets.setDescription('Number of Mac frame octets received without error.')
wfTokenRingMacRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMacRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMacRxFrames.setDescription('Number of Mac frames received without error.')
wfTokenRingCfgFunctionalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2147467520))).clone(namedValues=NamedValues(("mask", 2147467520))).clone('mask')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCfgFunctionalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCfgFunctionalAddress.setDescription("The configurable bit mask of all Token Ring Functional addresses for which this interface will accept frames. This value is loaded into the func addr defined in the attribute 'wfTokenRingFunctionalAddress.' note: 2147467520 = 0x7fffc100")
wfTokenRingFunctionalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 64), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingFunctionalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingFunctionalAddress.setDescription('The bit mask of all Token Ring Functional addresses for which this interface will accept frames.')
wfTokenRingGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingGroupAddress.setDescription('The single Token Ring Group address for which this interface will accept frames.')
wfTokenRingLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 66), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLineNumber.setDescription('Logical line number associated with this driver entity.')
wfTokenRingMacCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 67), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMacCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMacCode.setDescription('Type and version of microcode running on the TMS380.')
wfTokenRingModule = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingModule.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingModule.setDescription('Module number for ASN platform, filled in by driver. For non-ASN platforms this attribute will not be used.')
wfTokenRingActualConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingActualConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingActualConnector.setDescription('Actual connector number for ASN platform, filled in by driver. For non-ASN platforms this attribute will not be used.')
wfTokenRingLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 70), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLastChange.setDescription("The value of SysUpTime at the time the interface entered it's current operational state (UP state). SysUpTime is defined as the time (in hundredths of a second) since the network management portion of the system was last re-initialized. Usually the time since boot.")
wfTokenRingOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 71), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOutQLen.setDescription('The instantaneous current length of the output packet queue (in packets).')
wfTokenRingForceMacCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("timac", 1), ("fastmac", 2), ("fastmacplus", 3), ("fastmacplusb", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingForceMacCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingForceMacCode.setDescription('Selector determines which microcode will be downloaded for the TMS380.')
wfTokenRingMSBMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 73), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMSBMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMSBMadr.setDescription("Provides this interface's MAC address in Most Significant Bit (MSB) format. This format is also referred to as Token Ring or IBM format. This MAC address is the same MAC address as given in the wfTokenRingMadr attribute except that wfTokenRingMadr is displayed in ethernet format.")
wfTokenRingTurboBoflDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 74), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingTurboBoflDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTurboBoflDebug.setDescription('Special Turbo-BOFL debug mechanism to be used by Engineering and Manufacturing only. 31-24 : TMO - period of breath (amount of time between successive breaths of life) 23-16 : Number of packets per breath. 15-0 : Packet length in bytes - 22 bytes minimum. All bits set to zero will disable this attribute.')
wfTokenRingSingleStatDis = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingSingleStatDis.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSingleStatDis.setDescription('Enable/Disable the single station mode')
mibBuilder.exportSymbols("Wellfleet-TOKEN-RING-MIB", wfTokenRingLostFrameErrors=wfTokenRingLostFrameErrors, wfTokenRingGroupAddress=wfTokenRingGroupAddress, wfTokenRingLastChange=wfTokenRingLastChange, wfTokenRingRxTimeouts=wfTokenRingRxTimeouts, wfTokenRingRxReplenMisses=wfTokenRingRxReplenMisses, wfTokenRingConnector=wfTokenRingConnector, wfTokenRingLineNumber=wfTokenRingLineNumber, wfTokenRingSrbNotFreeCmdAborts=wfTokenRingSrbNotFreeCmdAborts, wfTokenRingAdapterChecks=wfTokenRingAdapterChecks, wfTokenRingSingleStations=wfTokenRingSingleStations, wfTokenRingBurstErrors=wfTokenRingBurstErrors, wfTokenRingHardErrors=wfTokenRingHardErrors, wfTokenRingInErrors=wfTokenRingInErrors, wfTokenRingTxOctets=wfTokenRingTxOctets, wfTokenRingRingRecoveries=wfTokenRingRingRecoveries, wfTokenRingFunctionalAddress=wfTokenRingFunctionalAddress, wfTokenRingRxTxBufferSize=wfTokenRingRxTxBufferSize, wfTokenRingMSBMadr=wfTokenRingMSBMadr, wfTokenRingLastAdapterCheckCode=wfTokenRingLastAdapterCheckCode, wfTokenRingMacRxFrames=wfTokenRingMacRxFrames, wfTokenRingSlot=wfTokenRingSlot, wfTokenRingTxQueueLength=wfTokenRingTxQueueLength, wfTokenRingTokenErrors=wfTokenRingTokenErrors, wfTokenRingCfgFunctionalAddress=wfTokenRingCfgFunctionalAddress, wfTokenRingMacRxOctets=wfTokenRingMacRxOctets, wfTokenRingMtu=wfTokenRingMtu, wfTokenRingModule=wfTokenRingModule, wfTokenRingCct=wfTokenRingCct, wfTokenRingCfgTxQueueLength=wfTokenRingCfgTxQueueLength, wfTokenRingRxProcessings=wfTokenRingRxProcessings, wfTokenRingEarlyTokenRelease=wfTokenRingEarlyTokenRelease, wfTokenRingTable=wfTokenRingTable, wfTokenRingOpenState=wfTokenRingOpenState, wfTokenRingInDiscards=wfTokenRingInDiscards, wfTokenRingStatus=wfTokenRingStatus, wfTokenRingRequestRemoves=wfTokenRingRequestRemoves, wfTokenRingTurboBoflDebug=wfTokenRingTurboBoflDebug, wfTokenRingCmdTimeouts=wfTokenRingCmdTimeouts, wfTokenRingLobeWireFaults=wfTokenRingLobeWireFaults, wfTokenRingEntry=wfTokenRingEntry, wfTokenRingMadrSelect=wfTokenRingMadrSelect, wfTokenRingOutErrors=wfTokenRingOutErrors, wfTokenRingDmaBusErrors=wfTokenRingDmaBusErrors, wfTokenRingTransmitBeacons=wfTokenRingTransmitBeacons, wfTokenRingTxProcessings=wfTokenRingTxProcessings, wfTokenRingFirstAdapterCheckCode=wfTokenRingFirstAdapterCheckCode, wfTokenRingTxCmplProcessings=wfTokenRingTxCmplProcessings, wfTokenRingAutoRemovalErrors=wfTokenRingAutoRemovalErrors, wfTokenRingCfgRxQueueLength=wfTokenRingCfgRxQueueLength, wfTokenRingRxHostIntErrors=wfTokenRingRxHostIntErrors, wfTokenRingAriFciErrors=wfTokenRingAriFciErrors, wfTokenRingLineErrors=wfTokenRingLineErrors, wfTokenRingRxCongestionErrors=wfTokenRingRxCongestionErrors, wfTokenRingMadr=wfTokenRingMadr, wfTokenRingRxFrames=wfTokenRingRxFrames, wfTokenRingState=wfTokenRingState, wfTokenRingForceMacCode=wfTokenRingForceMacCode, wfTokenRingCfgMadr=wfTokenRingCfgMadr, wfTokenRingDmaParityErrors=wfTokenRingDmaParityErrors, wfTokenRingActualConnector=wfTokenRingActualConnector, wfTokenRingOpenStatus=wfTokenRingOpenStatus, wfTokenRingRxQueueLength=wfTokenRingRxQueueLength, wfTokenRingOutQLen=wfTokenRingOutQLen, wfTokenRingFrameCopiedErrors=wfTokenRingFrameCopiedErrors, wfTokenRingRxOctets=wfTokenRingRxOctets, wfTokenRingTxClipFrames=wfTokenRingTxClipFrames, wfTokenRingSoftErrors=wfTokenRingSoftErrors, wfTokenRingUpStream=wfTokenRingUpStream, wfTokenRingCounterOverflows=wfTokenRingCounterOverflows, wfTokenRingSpeed=wfTokenRingSpeed, wfTokenRingDisable=wfTokenRingDisable, wfTokenRingMacCode=wfTokenRingMacCode, wfTokenRingSignalLosses=wfTokenRingSignalLosses, wfTokenRingTxFrames=wfTokenRingTxFrames, wfTokenRingOutDiscards=wfTokenRingOutDiscards, wfTokenRingDelete=wfTokenRingDelete, wfTokenRingSingleStatDis=wfTokenRingSingleStatDis)

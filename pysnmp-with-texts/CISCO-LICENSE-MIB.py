#
# PySNMP MIB module CISCO-LICENSE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-LICENSE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:04:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
EntPhysicalIndexOrZero, = mibBuilder.importSymbols("CISCO-TC", "EntPhysicalIndexOrZero")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, iso, Unsigned32, TimeTicks, Integer32, IpAddress, Gauge32, Bits, ModuleIdentity, MibIdentifier, Counter32, NotificationType, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "iso", "Unsigned32", "TimeTicks", "Integer32", "IpAddress", "Gauge32", "Bits", "ModuleIdentity", "MibIdentifier", "Counter32", "NotificationType", "Counter64")
TextualConvention, DisplayString, DateAndTime, AutonomousType = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "DateAndTime", "AutonomousType")
ciscoLicenseMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 359))
ciscoLicenseMIB.setRevisions(('2004-01-31 00:00', '2003-06-06 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoLicenseMIB.setRevisionsDescriptions(('Added following enums to LicenseType: multilink(10) ppp(11) ', 'Initial version of the mib module.',))
if mibBuilder.loadTexts: ciscoLicenseMIB.setLastUpdated('200401310000Z')
if mibBuilder.loadTexts: ciscoLicenseMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoLicenseMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com ')
if mibBuilder.loadTexts: ciscoLicenseMIB.setDescription('This MIB module provides objects to view the features and services that are licensed to run on a system (usually a network entity), and an inventory of the licenses for these features and services. The inventory of the licenses is kept in a license pool which is a repository of the installed licenses. This MIB does not provide any object to facilitate the installation or addition of licenses in the license pool. The licenses are used to perform specific services, and are used by, but not limited to, the physical entities. The meaningful entities which can use licenses to perform specific services include: module(9), or chassis(3) as defined in RFC 2737. As an example, some of the services/features that can be licensed include (but not limited to) the following : - Single Service. Only one of: ATM, FR, or CES (Circuit Emulation Service). - Multi Service. More than one of: ATM, FR, or CES. - IMA (Inverse Multiplexing over ATM). - MFR (Multilink Frame Relay). - Channelization. As an example of implementation, all licenses can be kept in the license pool owned by a chassis, while licenseable services are performed by service modules plugged into that chassis. In order to provide licenseable services/features, the service modules use/consume appropriate licenses from the license pool owned by the chassis. ')
celMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 359, 0))
celMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 359, 1))
celGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1))
class LicenseType(TextualConvention, Integer32):
    description = 'This defines a licenseable feature: unknown(1) The license type can not be determined. none(2) No license is granted for any licenseable feature/service. reserved(3) This is special restricted license. singleService(4) Only one of following services: ATM, FR (FrameRelay), or CES (Circuit emulation service). multiService(5) More than one of: ATM, FR, CES. channelization (6) Channelization. ima(7) Inverse multiplexing over ATM. mfr(8) Multilink Frame Relay. rateControl(9) Rate-Control (Cisco Foresight and/or ABR). multilink(10) Multilink features such as: Inverse Multiplexing over ATM (IMA), Multilink Frame Relay (MFR). ppp(11) Point-to-point protocols (PPP), such as: Multilink Point-to-point Protocol(MLPPP), PPP Multiplexing (PPPMux). '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
    namedValues = NamedValues(("unknown", 1), ("none", 2), ("reserved", 3), ("singleService", 4), ("multiService", 5), ("channelization", 6), ("ima", 7), ("mfr", 8), ("rateControl", 9), ("multilink", 10), ("ppp", 11))

celLicenseConfigHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1), )
if mibBuilder.loadTexts: celLicenseConfigHistoryTable.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigHistoryTable.setDescription('This table keeps track of the license installation history. Each time licenses are installed, a record is made in one of the entries in this table. When licensed features are applicable to physical entities, this table contains entries showing various licenseable vendor-specific hardware entities represented by the object celLicenseEntityVendorType, the corresponding license serial numbers (if any), and license update time-stamp, and license update sequence numbers. When licensed features are not applicable to a physical entity, the object celLicenseEntityVendorType is set to NULL. Each time a new entry is made in this table, the total number of installed licenses is updated in the table celPoolLicenseTable in the appropriate entry. If the necessary entry in the table celPoolLicenseTable does not exist, it is created. The implementations may choose to implement the table in circular fashion by limiting the number of entries in the table. In this case the oldest entry is overwritten by the latest. The object celLicenseConfigHistoryIndex always increase monotonically and indicates how many times the licenses have been installed. ')
celLicenseConfigHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-LICENSE-MIB", "celLicenseConfigIndex"))
if mibBuilder.loadTexts: celLicenseConfigHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigHistoryEntry.setDescription('An entry in ceLicenseConfigHistoryTable. Each entry contains objects showing: reference to the vendor-specific hardware (if applicable), the license serial number, and license update time-stamp, the license update sequence number. ')
celLicenseConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: celLicenseConfigIndex.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigIndex.setDescription('A unique running value greater than 0, used as index into the table. The values of this index are assigned contiguously starting normally from 1. ')
celLicenseEntityVendorType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 2), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseEntityVendorType.setStatus('current')
if mibBuilder.loadTexts: celLicenseEntityVendorType.setDescription('This represents vendor-specific hardware type of a physical entity which can use one or more licenses to provide licensed services or features. If no vendor-specific registration identifier exists for this object, or the value is unknown by this agent, then the value { 0 0 } is returned. ')
celLicenseSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseSerialNumber.setStatus('current')
if mibBuilder.loadTexts: celLicenseSerialNumber.setDescription('A textual representation of the license serial number, if any. Value contained in this object is optional, and if not used, it should be zero length string. ')
celLicenseInstallEntitySerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseInstallEntitySerNum.setStatus('current')
if mibBuilder.loadTexts: celLicenseInstallEntitySerNum.setDescription('A textual representation of the serial number of the physical entity (if applicable) from where the license installation took place. Value contained in this object is optional, and if not used, it should be zero length string. ')
celLicenseUpdateTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseUpdateTimeStamp.setStatus('current')
if mibBuilder.loadTexts: celLicenseUpdateTimeStamp.setDescription('This represents the time-stamp when the licenses, usable by the corresponding vendor-specific hardware, were upgraded or modified. ')
celLicenseConfigHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseConfigHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigHistoryIndex.setDescription('This value shows the license update sequence number recorded in the license pool. Each time licenses are updated or installed, this object is incremented. If the table size is limited and circular, this number may be different from the running index celLicenseConfigIndex. This value is greater than zero. ')
celLicenseUpdateSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseUpdateSequenceNum.setStatus('current')
if mibBuilder.loadTexts: celLicenseUpdateSequenceNum.setDescription("This value shows the license update sequence number as contained in the license itself. Each time licenses are updated or installed, this object is assigned the sequence number that is a part of the license being installed. Depending upon the implementation, it serves the purpose of preventing the reuse of an already installed license, especially when that license is applied in additive mode. When an attempt is made to update/install the licenses, the implementation may allow update only if the new license's sequence number is greater than the last installed license sequence number. If the license update/installation is successful, this object reflects the new license sequence number and can be used to detect if attempt is being made to reuse a previous license. This value is greater than zero. ")
celLicenseUpdateMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 1, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseUpdateMethod.setStatus('current')
if mibBuilder.loadTexts: celLicenseUpdateMethod.setDescription('Use of this object is implementation dependent. A textual short description explaining how this entry was updated in this table. If not used, it should be zero length string. ')
celLicenseConfigDetailTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 2), )
if mibBuilder.loadTexts: celLicenseConfigDetailTable.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigDetailTable.setDescription('For each entry in the table celLicenseConfigHistoryTable, this table expands the information showing the installed type of license, and the number of licenses. There may be more than one entries corresponding to a single entry in the table celLicenseConfigHistoryTable One of the indicies of this table is celLicenseConfigIndex which is the index into the table celLicenseConfigHistoryTable. ')
celLicenseConfigDetailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-LICENSE-MIB", "celLicenseConfigIndex"), (0, "CISCO-LICENSE-MIB", "celLicenseConfigType"))
if mibBuilder.loadTexts: celLicenseConfigDetailEntry.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigDetailEntry.setDescription('An entry in celLicenseConfigDetailTable. Each entry contains objects showing: license type celLicenseConfigType, and the corresponding number of licenses celLicenseConfigNumber. ')
celLicenseConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 2, 1, 1), LicenseType())
if mibBuilder.loadTexts: celLicenseConfigType.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigType.setDescription('This represents one of the the license types corresponding to the entry indexed by celLicenseConfigIndex in the table celLicenseConfigHistoryTable. ')
celLicenseTypeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseTypeDescr.setStatus('current')
if mibBuilder.loadTexts: celLicenseTypeDescr.setDescription('A textual representation of the licensable feature. Value contained in this object is optional, and if not used, it should be zero length string. ')
celLicenseConfigCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celLicenseConfigCount.setStatus('current')
if mibBuilder.loadTexts: celLicenseConfigCount.setDescription('Number of licenses of the type celLicenseConfigType. This represents the count of installed licenses represented by the entry with index celLicenseConfigIndex in the table celLicenseConfigHistoryTable. ')
celPoolLicenseTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3), )
if mibBuilder.loadTexts: celPoolLicenseTable.setStatus('current')
if mibBuilder.loadTexts: celPoolLicenseTable.setDescription('This table contains the inventory of installed licenses and completely defines the license pool owned by the SNMP agent implementing this table. These licenses can be used by the appropriate entities (physical or otherwise) to which these licenses are applicable. ')
celPoolLicenseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-LICENSE-MIB", "celPoolLicenseIndex"))
if mibBuilder.loadTexts: celPoolLicenseEntry.setStatus('current')
if mibBuilder.loadTexts: celPoolLicenseEntry.setDescription('An entry in the table celPoolLicenseTable. When licensed features are applicable to physical entities, the entry contains a licenseable vendor-specific hardware type, corresponding licensed service or feature represented by celPoolLicenseType, total installed number of licenses of this type, already used number of license of this type, and the maximum allowed usage of this type of licenses by an entity of the type celPoolLicenseEntityVendorType. When licensed features are not applicable to a physical entity, the object celPoolLicenseEntityVendorType is set to to NULL. Preferably, implementations should have a single entry corresponding to the pair celPoolLicenseEntityVendorType and celPoolLicenseType, by keeping only the total of the other objects. This keeps the table size small without losing any useful data. ')
celPoolLicenseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: celPoolLicenseIndex.setStatus('current')
if mibBuilder.loadTexts: celPoolLicenseIndex.setDescription('A unique running value greater than 0, used as index into the table. The values of this index are assigned contiguously starting from 1. ')
celPoolLicenseEntityVendorType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1, 2), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPoolLicenseEntityVendorType.setStatus('current')
if mibBuilder.loadTexts: celPoolLicenseEntityVendorType.setDescription('This represents vendor-specific hardware type of a physical entity which can use one or more licenses to provide licensed services or features. If no vendor-specific registration identifier exists for this object, or the value is unknown by this agent, then the value { 0 0 } is returned. ')
celPoolLicenseType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1, 3), LicenseType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPoolLicenseType.setStatus('current')
if mibBuilder.loadTexts: celPoolLicenseType.setDescription('This represents a useable license type. ')
celPoolLicensesInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPoolLicensesInstalled.setStatus('current')
if mibBuilder.loadTexts: celPoolLicensesInstalled.setDescription('Total number of licenses of the type celPoolLicenseType at a given time in the license pool. This number changes as a result of installation of licenses of the type celPoolLicenseType. ')
celPoolLicensesInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPoolLicensesInUse.setStatus('current')
if mibBuilder.loadTexts: celPoolLicensesInUse.setDescription('Number of used up licenses of the type celPoolLicenseType. Each time a license is used up by the appropriate entity (physical or otherwise), this number is incremented. Similarly, when a license is released back to the license pool, this number decrements. Difference between celPoolLicensesInstalled and this object is the number of licenses still available for use. Depending upon the implementation and the system operational considerations, it is possible that at a given time, this object has a value greater than celPoolLicensesInstalled. This indicates over-subscription to the licenses. The implementation may choose to disallow such situation or treat this situation as temporary and allow the system operation to continue until the implementation specific time period. In this case, more licenses of this type must be installed in the license pool to avoid disruption of the services. ')
celPoolLicenseMaxUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPoolLicenseMaxUsage.setStatus('current')
if mibBuilder.loadTexts: celPoolLicenseMaxUsage.setDescription('The value represented by this object specifies the maximum number of the licenses of type celPoolLicenseType which can be allowed for use by the corresponding entity type (physical or otherwise). As an example of usage of this object, if the entity of corresponding type attempts to use more licenses than this value, it is considered an error. ')
celInUseLicenseTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4), )
if mibBuilder.loadTexts: celInUseLicenseTable.setStatus('current')
if mibBuilder.loadTexts: celInUseLicenseTable.setDescription('This table contains entries showing the entities (physical or otherwise) that are using up licenses, and the number and type of licenses in use. For example, if a service module is consuming certain type of licenses from the license pool, an entry corresponding to that module will exist in this table and will show the number and type licenses being used. An entry in this table is automatically created as soon as an appropriate entity starts using one or more licenses of the type celInUseLicenseType. The object celInUseLicenses can increase or decrease any time the number of in-use licenses changes. As soon as the value of the object celInUseLicenses reduces to the value 0, the corresponding entry is deleted automatically. ')
celInUseLicenseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-LICENSE-MIB", "celInUseSlotIndex"), (0, "CISCO-LICENSE-MIB", "celInUseLicenseType"))
if mibBuilder.loadTexts: celInUseLicenseEntry.setStatus('current')
if mibBuilder.loadTexts: celInUseLicenseEntry.setDescription('Entry containing a licenseable service/feature being used by an entity (physical or otherwise), and the number of instances of this license type. ')
celInUseSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: celInUseSlotIndex.setStatus('current')
if mibBuilder.loadTexts: celInUseSlotIndex.setDescription('A unique running value used as index into the table. When not 0, this index is interpreted as the slot number (within the chassis) containing the entity that is using licenses. If corresponding entPhysicalIndex (RFC 2737) exists for this slot, celEntPhysicalIndex contains its value. When it is 0, it can be interpreted as a reference to all non-physical entities which can use licenses and which do hot have entPhysicalIndex. In such cases the object celEntPhysicalIndex is also set to 0. In addition, when referring to a physical entity for which a slot is non meaningful, but entPhysicalIndex exists, this index has a value 0 and the object celEntPhysicalIndex contains the corresponding value of entPhysicalIndex. ')
celInUseLicenseType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 2), LicenseType())
if mibBuilder.loadTexts: celInUseLicenseType.setStatus('current')
if mibBuilder.loadTexts: celInUseLicenseType.setDescription('This represents a license type being used by the entity (physical or otherwise). ')
celEntPhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 3), EntPhysicalIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celEntPhysicalIndex.setStatus('current')
if mibBuilder.loadTexts: celEntPhysicalIndex.setDescription('When its value is not 0, it represents entPhysicalIndex for the physical entity which is using up license/licenses. When it is 0, it represents all entities (most likly non- physical) which do not have implementation in the entity MIB (RFC 2737). ')
celInUseLicenseDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celInUseLicenseDescr.setStatus('current')
if mibBuilder.loadTexts: celInUseLicenseDescr.setDescription('A textual representation of the licensable feature. Value contained in this object is optional, and if not used, it should be zero length string. ')
celInUseLicenses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celInUseLicenses.setStatus('current')
if mibBuilder.loadTexts: celInUseLicenses.setDescription('Number of licenses of type celInUseLicenseType being used by this physical entity (represented by entPhysicalIndex) at this time. These licenses are obtained from the license pool represented by the table celPoolLicenseTable. Therefore, the value of the object celPoolLicensesInUse, corresponding to relevant license and the vendor-specific hardware type, increases or decreases when the value of this object increases or decreases. ')
celNeededLicenses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celNeededLicenses.setStatus('current')
if mibBuilder.loadTexts: celNeededLicenses.setDescription('Number of licenses of type celInUseLicenseType required by this entity (physical or otherwise) at this time to perform the desired services. When this number is more than celInUseLicenses, a shortfall of licenses is indicated. In this case, the object celOperationExpiryTmStamp specifies until how long such condition can continue. ')
celOperationExpiryTmStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 4, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celOperationExpiryTmStamp.setStatus('current')
if mibBuilder.loadTexts: celOperationExpiryTmStamp.setDescription("The use of this object is implementation specific. This time-stamp indicates that the physical entity's operation will not continue beyond this time, since for this particular entity (physical or otherwise), celNeededLicenses exceeds celInUseLicenses. Under these conditions, user is expected to install sufficient number of licenses, before this time-stamp expires, to avoid interruption of the operation. No expiration is indicated by a value: Jan 1, 0000. ")
celPhysicallyProgLicenseTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5), )
if mibBuilder.loadTexts: celPhysicallyProgLicenseTable.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicenseTable.setDescription("This table contains entries for those physical entities into which licenses have been physically programmed. Depending upon the implementation, this may involve programming the licenses into the non-volatile ram (NVRAM) of a physical entity, such as a service module. An entry in this table is automatically created for those entities which contain such licenses. This table exists independently of all previous tables described in this MIB. The following example illustrates the use of this table for a specific implementation: For a module, if the object celPhysicallyProgLicenseStatus has the value 'hasInstallableLic', it means that this module has never had its programmed licenses installed (or transferred) into any chassis, and therefore its license can be installed (or transferred) if needed. If installation (or transferring) of licenses (programmed on the entity) takes place, it results in incrementing the number of licenses in the license pool (object celPoolLicensesInstalled) for the vendor-specific hardware type corresponding to this module. Once the licenses from the module have been installed (or transferred) into the chassis, the value of the object celPhysicallyProgLicenseStatus changes to 'alreadyInstalled'. This prevents any re-installation or re-use of licenses. This example shows the usage of the module as a vehicle for installing (or transporting) licenses into the license pool. ")
celPhysicallyProgLicenseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-LICENSE-MIB", "celPhysicallyProgSlotNumber"), (0, "CISCO-LICENSE-MIB", "celPhysicallyProgLicenseType"))
if mibBuilder.loadTexts: celPhysicallyProgLicenseEntry.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicenseEntry.setDescription('Entry containing details on a physically programmed license. ')
celPhysicallyProgSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: celPhysicallyProgSlotNumber.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgSlotNumber.setDescription('A unique running value used as index into the table. When not 0, this index is interpreted as the slot number (within the chassis) containing the entity that is using licenses. If corresponding entPhysicalIndex (RFC 2737) exists for this slot, celPhysicallyProgEntIndex contains its value. When referring to a physical entity for which a slot is non meaningful, but entPhysicalIndex exists, this index has a value 0 and the object celPhysicallyProgEntIndex contains the corresponding value of entPhysicalIndex. ')
celPhysicallyProgLicenseType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 2), LicenseType())
if mibBuilder.loadTexts: celPhysicallyProgLicenseType.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicenseType.setDescription('This represents a programmed license type on this entity. ')
celPhysicallyProgEntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 3), EntPhysicalIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgEntIndex.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgEntIndex.setDescription('When its value is not 0, it represents entPhysicalIndex corresponding to slot for this entry. If entPhysicalIndex is not available, this object is set to 0. ')
celPhysicallyProgLicTypeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicTypeDescr.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicTypeDescr.setDescription('A textual representation of the licensable feature. Value contained in this object is optional, and if not used, it should be zero length string. ')
celPhysicallyProgLicenses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicenses.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicenses.setDescription('Number of licenses of type celPhysicallyProgLicenseType programmed into this physical entity. ')
celPhysicallyProgLicenseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("noInstallableLic", 2), ("hasInstallableLic", 3), ("alreadyInstalled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicenseStatus.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicenseStatus.setDescription("Status of the programmed licenses of the type celPhysicallyProgLicenseType. Depending upon the implementation, all of the programmed licenses of different types on the physical entity may be installed (or transferred) into the license pool owned by the agent at the same time. In this case this object will have the same value for different license types(represented by the object celPhysicallyProgLicenseType). These comments also apply to the next two objects. Note that in this context, 'license installation' is akin to 'license transfer' from physical entity to license pool. The possible values are: unknown (1) noInstallableLic(2): Licenses not programmed on this entity. hasInstallableLic(3): The entity has usable licenses, which can be installed. alreadyInstalled(4): The programmed licenses on this entity have been already installed. ")
celPhysicallyProgLicInstSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicInstSysName.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicInstSysName.setDescription("A textual string containing the name of the system to which this entity's programmed licenses were installed. As an example of use of this object, it may be the sysName of node where the license installation/transfer took place. The usefulness of this object is to track the system where such operation was performed. ")
celPhysicallyProgLicInstSerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicInstSerNum.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicInstSerNum.setDescription("A textual string containing the serial number of the system to which this entity's programmed licenses were installed. For example, it may be the serial number of the chassis where installation took place. ")
celPhysicallyProgLicSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicSerialNum.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicSerialNum.setDescription('A textual representation of the license serial number, if any. Value contained by this object is optional, and if it is not used, it should be zero length string. Depending upon the implementation, the licenses of different types can be programmed into the physical entity in one shot and with same value of this object. ')
celPhysicallyProgLicUseTmStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 359, 1, 1, 5, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: celPhysicallyProgLicUseTmStamp.setStatus('current')
if mibBuilder.loadTexts: celPhysicallyProgLicUseTmStamp.setDescription('This represents the time-stamp when the object celPhysicallyProgLicInstSysName was written after licenses were installed to the corresponding system. ')
celMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 359, 2))
celMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 359, 2, 1))
celMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 359, 2, 2))
celMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 359, 2, 1, 1)).setObjects(("CISCO-LICENSE-MIB", "celMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    celMIBCompliance = celMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: celMIBCompliance.setDescription('The Compliance statement for entity license management group. ')
celMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 359, 2, 2, 1)).setObjects(("CISCO-LICENSE-MIB", "celLicenseEntityVendorType"), ("CISCO-LICENSE-MIB", "celLicenseSerialNumber"), ("CISCO-LICENSE-MIB", "celLicenseInstallEntitySerNum"), ("CISCO-LICENSE-MIB", "celLicenseUpdateTimeStamp"), ("CISCO-LICENSE-MIB", "celLicenseConfigHistoryIndex"), ("CISCO-LICENSE-MIB", "celLicenseUpdateSequenceNum"), ("CISCO-LICENSE-MIB", "celLicenseUpdateMethod"), ("CISCO-LICENSE-MIB", "celLicenseConfigCount"), ("CISCO-LICENSE-MIB", "celLicenseTypeDescr"), ("CISCO-LICENSE-MIB", "celPoolLicenseEntityVendorType"), ("CISCO-LICENSE-MIB", "celPoolLicenseType"), ("CISCO-LICENSE-MIB", "celPoolLicensesInstalled"), ("CISCO-LICENSE-MIB", "celPoolLicensesInUse"), ("CISCO-LICENSE-MIB", "celPoolLicenseMaxUsage"), ("CISCO-LICENSE-MIB", "celInUseLicenseDescr"), ("CISCO-LICENSE-MIB", "celInUseLicenses"), ("CISCO-LICENSE-MIB", "celEntPhysicalIndex"), ("CISCO-LICENSE-MIB", "celNeededLicenses"), ("CISCO-LICENSE-MIB", "celOperationExpiryTmStamp"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicenses"), ("CISCO-LICENSE-MIB", "celPhysicallyProgEntIndex"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicTypeDescr"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicenseStatus"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicInstSysName"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicInstSerNum"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicSerialNum"), ("CISCO-LICENSE-MIB", "celPhysicallyProgLicUseTmStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    celMIBGroup = celMIBGroup.setStatus('current')
if mibBuilder.loadTexts: celMIBGroup.setDescription('Group containing objects representing the system license details. ')
mibBuilder.exportSymbols("CISCO-LICENSE-MIB", celInUseLicenseDescr=celInUseLicenseDescr, celPhysicallyProgSlotNumber=celPhysicallyProgSlotNumber, celInUseLicenseType=celInUseLicenseType, celPhysicallyProgLicenseTable=celPhysicallyProgLicenseTable, celPhysicallyProgLicTypeDescr=celPhysicallyProgLicTypeDescr, celPhysicallyProgLicenses=celPhysicallyProgLicenses, celLicenseUpdateSequenceNum=celLicenseUpdateSequenceNum, LicenseType=LicenseType, celPoolLicenseEntityVendorType=celPoolLicenseEntityVendorType, celOperationExpiryTmStamp=celOperationExpiryTmStamp, celPoolLicenseType=celPoolLicenseType, celMIBGroups=celMIBGroups, celPoolLicensesInUse=celPoolLicensesInUse, ciscoLicenseMIB=ciscoLicenseMIB, celLicenseConfigIndex=celLicenseConfigIndex, celGeneral=celGeneral, PYSNMP_MODULE_ID=ciscoLicenseMIB, celLicenseEntityVendorType=celLicenseEntityVendorType, celLicenseConfigHistoryEntry=celLicenseConfigHistoryEntry, celLicenseInstallEntitySerNum=celLicenseInstallEntitySerNum, celPoolLicenseTable=celPoolLicenseTable, celPhysicallyProgEntIndex=celPhysicallyProgEntIndex, celPoolLicenseIndex=celPoolLicenseIndex, celPhysicallyProgLicInstSysName=celPhysicallyProgLicInstSysName, celLicenseConfigHistoryTable=celLicenseConfigHistoryTable, celLicenseUpdateMethod=celLicenseUpdateMethod, celPhysicallyProgLicSerialNum=celPhysicallyProgLicSerialNum, celInUseSlotIndex=celInUseSlotIndex, celPoolLicenseEntry=celPoolLicenseEntry, celEntPhysicalIndex=celEntPhysicalIndex, celNeededLicenses=celNeededLicenses, celPhysicallyProgLicUseTmStamp=celPhysicallyProgLicUseTmStamp, celMIBGroup=celMIBGroup, celMIBCompliance=celMIBCompliance, celPhysicallyProgLicInstSerNum=celPhysicallyProgLicInstSerNum, celLicenseConfigHistoryIndex=celLicenseConfigHistoryIndex, celPhysicallyProgLicenseEntry=celPhysicallyProgLicenseEntry, celMIBCompliances=celMIBCompliances, celLicenseConfigDetailEntry=celLicenseConfigDetailEntry, celInUseLicenseEntry=celInUseLicenseEntry, celMIBConformance=celMIBConformance, celMIBNotifications=celMIBNotifications, celPoolLicensesInstalled=celPoolLicensesInstalled, celLicenseSerialNumber=celLicenseSerialNumber, celLicenseUpdateTimeStamp=celLicenseUpdateTimeStamp, celPhysicallyProgLicenseStatus=celPhysicallyProgLicenseStatus, celMIBObjects=celMIBObjects, celLicenseConfigCount=celLicenseConfigCount, celLicenseTypeDescr=celLicenseTypeDescr, celInUseLicenses=celInUseLicenses, celPoolLicenseMaxUsage=celPoolLicenseMaxUsage, celPhysicallyProgLicenseType=celPhysicallyProgLicenseType, celInUseLicenseTable=celInUseLicenseTable, celLicenseConfigDetailTable=celLicenseConfigDetailTable, celLicenseConfigType=celLicenseConfigType)

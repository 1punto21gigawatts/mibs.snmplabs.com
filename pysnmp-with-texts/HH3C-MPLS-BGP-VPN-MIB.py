#
# PySNMP MIB module HH3C-MPLS-BGP-VPN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-MPLS-BGP-VPN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
hh3cMpls, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cMpls")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Counter64, ObjectIdentity, MibIdentifier, Integer32, IpAddress, Gauge32, ModuleIdentity, experimental, Bits, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "ObjectIdentity", "MibIdentifier", "Integer32", "IpAddress", "Gauge32", "ModuleIdentity", "experimental", "Bits", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "iso", "Counter32")
TruthValue, TextualConvention, DisplayString, TimeStamp, StorageType, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString", "TimeStamp", "StorageType", "RowStatus")
hh3cMplsVpn = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3))
hh3cMplsVpn.setRevisions(('2001-07-20 12:00', '2001-07-17 12:00', '2001-07-10 12:00', '2001-06-19 12:00', '2001-05-30 12:00', '2000-09-30 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cMplsVpn.setRevisionsDescriptions(('Re-published as PPVPN working group draft. No changes between this version and last; just name change.', "Removed hh3cmplsVpnVrfRouteTargetImport/Export from route target table, and modified indexing to better reflect N <> R distribution policy. Also added new object called hh3cmplsVpnVrfRouteTargetType which denotes import/export policy for the specified route target. Added hh3cmplsVpnInterfaceConfRowStatus which allows for an interface to be associated with a VPN through SNMP configuration. Added VrfName to index of VrfInterfaceConfEntry which allows interfaces to be associated with the appropriate VRF. Modified description of hh3cmplsVpnVrfConfMaxPossibleRoutes and hh3cmplsVpnVrfConfMaxRoutes to allow for undetermined value. Removed 'both' enumerated value in hh3cmplsVpnVrfBgpNbrRole. Updated example to reflect these changes.", 'Renamed hh3cmplsNumVrfSecViolationThreshExceeded to hh3cmplsNumVrfSecIllegalLabelThreshExceeded, and removed hh3cmplsVpnInterfaceConfIndex from varbind. Changed Hh3cMplsVpnId TC from SnmpAdminString to OCTET STRING. Added hh3cmplsVpnVrfSecIllegalLabelRcvThresh to hh3cmplsVpnVrfSecEntry. Changed duplicate hh3cmplsVpnVrfRouteTargetImport in hh3cmplsVpnVrfRouteTargetEntry INDEX to hh3cmplsVpnVrfRouteTargetExport.', 'Fixed several compile errors.', 'Updated most of document and MIB to reflect comments from WG.', 'Initial draft version.',))
if mibBuilder.loadTexts: hh3cMplsVpn.setLastUpdated('200107201200Z')
if mibBuilder.loadTexts: hh3cMplsVpn.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cMplsVpn.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cMplsVpn.setDescription('This MIB contains managed object definitions for the Multiprotocol Label Switching (MPLS)/Border Gateway Protocol (BGP) Virtual Private Networks (VPNs) as defined in : Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, Internet Draft <draft-ietf-mpls-arch-06.txt>, August 1999.')
class Hh3cMplsVpnId(TextualConvention, OctetString):
    reference = "RFC 2685 [VPN-RFC2685] Fox B., et al, 'Virtual Private Networks Identifier', September 1999."
    description = 'An identifier that is assigned to each MPLS/BGP VPN and is used to uniquely identify it. This is assigned by the system operator or NMS and SHOULD be unique throughout the MPLS domain. If this is the case, then this identifier can then be used at any LSR within a specific MPLS domain to identify this MPLS/BGP VPN. It may also be possible to preserve the uniqueness of this identifier across MPLS domain boundaries, in which case this identifier can then be used to uniquely identify MPLS/BGP VPNs on a more global basis.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 31)

class Hh3cMplsVpnRouteDistinguisher(TextualConvention, OctetString):
    description = 'Syntax for a route distinguisher and route target.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 256)

hh3cmplsVpnObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1))
hh3cmplsVpnScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 1))
hh3cmplsVpnConf = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2))
hh3cmplsVpnRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3))
hh3cmplsVpnConfiguredVrfs = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnConfiguredVrfs.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnConfiguredVrfs.setDescription('The number of VRFs which are configured on this node.')
hh3cmplsVpnActiveVrfs = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnActiveVrfs.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnActiveVrfs.setDescription('The number of VRFs which are active on this node. That is, those whose operStatus = Up (1).')
hh3cmplsVpnInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1), )
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfTable.setDescription('This table specifies per-interface MPLS capability and associated information.')
hh3cmplsVpnInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1), ).setIndexNames((0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfName"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnInterfaceConfIndex"))
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfEntry.setDescription('An entry in this table is created by an LSR for every interface capable of supporting MPLS/BGP VPN. Each entry in this table is meant to correspond to an entry in the Interfaces Table.')
hh3cmplsVpnInterfaceConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfIndex.setReference('RFC 2233 - The Interfaces Group MIB using SMIv2, McCloghrie, K., and F. Kastenholtz, Nov. 1997')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfIndex.setDescription('This is a unique index for an entry in the hh3cmplsVpnInterfaceConfTable.')
hh3cmplsVpnInterfaceLabelEdgeType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("providerEdge", 1), ("customerEdge", 2))).clone('providerEdge')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceLabelEdgeType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceLabelEdgeType.setDescription('Either the providerEdge(1) (PE) or customerEdge(2) (CE) bit MUST be set.')
hh3cmplsVpnInterfaceVpnClassification = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("carrierOfCarrier", 1), ("enterprise", 2), ("interProvider", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceVpnClassification.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceVpnClassification.setDescription("Denotes whether this link participates in a carrier-of-carrier's, enterprise, or inter-provider scenario.")
hh3cmplsVpnInterfaceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceIpAddress.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceIpAddress.setDescription('The IP address of this interface.')
hh3cmplsVpnInterfaceIpAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceIpAddressMask.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceIpAddressMask.setDescription('The IP address mask of this interface.')
hh3cmplsVpnInterfaceConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnInterfaceConfRowStatus.setDescription('The row status for this entry. This value is used to create a row in this table, signifying that the specified interface is to be associated with the specified interface. If this operation suceeds, the interface will have been associated, otherwise the agent would not allow the association. If the agent only allows read-only operations on this table, it will create entries in this table as they are created.')
hh3cmplsVpnVrfConfTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2), )
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfTable.setDescription('This table specifies per-interface MPLS/BGP VPN VRF Table capability and associated information. Entries in this table define VRF routing instances associated with MPLS/VPN interfaces. Note that multiple interfaces can belong to the same VRF instance. The collection of all VRF instances comprises an actual VPN.')
hh3cmplsVpnVrfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1), ).setIndexNames((0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfName"))
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfEntry.setDescription('An entry in this table is created by an LSR for every VRF capable of supporting MPLS/BGP VPN. The indexing provides an ordering of VRFs per-VPN interface.')
hh3cmplsVpnVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 1), Hh3cMplsVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfName.setReference('RFC 2685 [VPN-RFC2685] Fox B., et al, `Virtual Private Networks Identifier`, September 1999.')
if mibBuilder.loadTexts: hh3cmplsVpnVrfName.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfName.setDescription('The human-readable name of this VPN. This MAY be equivalent to the RFC2685 VPN-ID.')
hh3cmplsVpnVrfRouteDistinguisher = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 2), Hh3cMplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteDistinguisher.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteDistinguisher.setDescription('The route distinguisher for this VRF.')
hh3cmplsVpnVrfNetPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("rip", 2), ("ospf", 3), ("isis", 4), ("bgp", 5), ("static", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfNetPrefixType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfNetPrefixType.setDescription('Denotes the type network prefix in use for the PE-CE connections. ')
hh3cmplsVpnVrfNetPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfNetPrefix.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfNetPrefix.setDescription('Denotes the network prefix for the PE-CE connections.')
hh3cmplsVpnVrfIpRouteRedistributeConn = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 5), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfIpRouteRedistributeConn.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfIpRouteRedistributeConn.setDescription('Denotes the redistribution of directly connected networks into the VRF BGP table.')
hh3cmplsVpnVrfIpRouteRedistributeStatic = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfIpRouteRedistributeStatic.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfIpRouteRedistributeStatic.setDescription('Denotes the redistribution of static routes into the VRF BGP table.')
hh3cmplsVpnVrfIpRouteRedistributeRip = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfIpRouteRedistributeRip.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfIpRouteRedistributeRip.setDescription('Denotes the redistribution of rip routes into the VRF BGP table.')
hh3cmplsVpnVrfConfHighRouteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfHighRouteThreshold.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfHighRouteThreshold.setDescription('Denotes high-level water marker for the number of routes which this VRF may hold.')
hh3cmplsVpnVrfConfIsWarnOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 9), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfIsWarnOnly.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfIsWarnOnly.setDescription("Denotes the action when the amount of VPN's routes exceed the hh3cmplsVpnVrfConfHighRouteThreshold.")
hh3cmplsVpnVrfConfMaxRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfMaxRoutes.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfMaxRoutes.setDescription('Denotes maximum number of routes which this VRF is configured to hold. This value MUST be less than or equal to hh3cmplsVrfMaxPossibleRoutes unless it is set to 0.')
hh3cmplsVpnVrfConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfConfRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
hh3cmplsVpnVrfRouteTargetTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 3), )
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetTable.setDescription('This table specifies per-VRF route target association. Each entry identifies a connectivity policy supported as part of a VPN.')
hh3cmplsVpnVrfRouteTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 3, 1), ).setIndexNames((0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfName"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfRouteTarget"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfRouteTargetType"))
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetEntry.setDescription(' An entry in this table is created by an LSR for each route target configured for a VRF supporting a MPLS/BGP VPN instance. The indexing provides an ordering per-VRF instance.')
hh3cmplsVpnVrfRouteTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 3, 1, 1), Hh3cMplsVpnRouteDistinguisher()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTarget.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTarget.setDescription('The route target distribution policy.')
hh3cmplsVpnVrfRouteTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("import", 1), ("export", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetType.setDescription('The route target export distribution type.')
hh3cmplsVpnVrfRouteTargetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTargetRowStatus.setDescription('Row status for this entry.')
hh3cmplsVpnVrfBgpNbrAddrTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4), )
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAddrTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAddrTable.setDescription('This table specifies per-interface MPLS/BGP neighbor addresses for both PEs and CEs.')
hh3cmplsVpnVrfBgpNbrAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1), ).setIndexNames((0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfName"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfBgpNbrAddr"))
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAddrEntry.setDescription('An entry in this table is created by an LSR for every VRF capable of supporting MPLS/BGP VPN. The indexing provides an ordering of VRFs per-VPN interface.')
hh3cmplsVpnVrfBgpNbrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1, 1), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAddr.setDescription('Denotes the BGP neighbor address.')
hh3cmplsVpnVrfBgpNbrRole = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ce", 1), ("pe", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrRole.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrRole.setDescription('Denotes the role played by this BGP neighbor with respect to this VRF.')
hh3cmplsVpnVrfBgpNbrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrType.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrType.setDescription('Denotes the address family of the PE address.')
hh3cmplsVpnVrfBgpNbrAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAsNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAsNumber.setDescription("The Automonous System that the BGP's neighbour in.")
hh3cmplsVpnVrfBgpNbrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mplsVpnVrfBgpNbrSetUp", 1), ("mplsVpnVrfBgpNbrSetDown", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrAdminStatus.setDescription('The action set by SNMP client.')
hh3cmplsVpnVrfBgpNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 2, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfBgpNbrRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
hh3cmplsVpnVrfRouteTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1), )
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTable.setReference('1. RFC 1213 Section 6.6, The IP Group. 2. RFC 2096 ')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTable.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteTable.setDescription('This table specifies per-interface MPLS/BGP VPN VRF Table routing information. Entries in this table define VRF routing entries associated with the specified MPLS/VPN interfaces. Note that this table contains both BGP and IGP routes, as both may appear in the same VRF.')
hh3cmplsVpnVrfRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1), ).setIndexNames((0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfName"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfRouteDest"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfRouteMask"), (0, "HH3C-MPLS-BGP-VPN-MIB", "hh3cmplsVpnVrfRouteNextHop"))
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteEntry.setDescription('An entry in this table is created by an LSR for every route present configured (either dynamically or statically) within the context of a specific VRF capable of supporting MPLS/BGP VPN. The indexing provides an ordering of VRFs per-VPN interface.')
hh3cmplsVpnVrfRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1, 1), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteDest.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteDest.setDescription('The destination IP address of this route. This object may not take a Multicast (Class D) address value.')
hh3cmplsVpnVrfRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1, 2), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteMask.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the hh3cmplsVpnVrfRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the hh3cmplsVpnVrfRouteMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bit-wise logical-AND of x with the value of the corresponding instance of the hh3cmplsVpnVrfRouteDest object is not equal to hh3cmplsVpnVrfRouteDest.')
hh3cmplsVpnVrfRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteNextHop.setDescription('On remote routes, the address of the next system en route; Otherwise, 0.0.0.0. .')
hh3cmplsVpnVrfRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1, 4), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached.')
hh3cmplsVpnVrfRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteProto.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway rout- ing protocols is not intended to imply that hosts should support those protocols.')
hh3cmplsVpnVrfRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 12, 3, 1, 3, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cmplsVpnVrfRouteRowStatus.setDescription('Row status for this table. It is used according to row installation and removal conventions.')
mibBuilder.exportSymbols("HH3C-MPLS-BGP-VPN-MIB", hh3cmplsVpnInterfaceConfTable=hh3cmplsVpnInterfaceConfTable, PYSNMP_MODULE_ID=hh3cMplsVpn, hh3cmplsVpnVrfConfTable=hh3cmplsVpnVrfConfTable, hh3cmplsVpnVrfRouteTargetTable=hh3cmplsVpnVrfRouteTargetTable, hh3cmplsVpnVrfName=hh3cmplsVpnVrfName, hh3cmplsVpnVrfRouteTable=hh3cmplsVpnVrfRouteTable, hh3cmplsVpnVrfConfMaxRoutes=hh3cmplsVpnVrfConfMaxRoutes, hh3cmplsVpnVrfRouteTarget=hh3cmplsVpnVrfRouteTarget, hh3cmplsVpnVrfBgpNbrType=hh3cmplsVpnVrfBgpNbrType, hh3cmplsVpnVrfBgpNbrAdminStatus=hh3cmplsVpnVrfBgpNbrAdminStatus, hh3cmplsVpnVrfRouteRowStatus=hh3cmplsVpnVrfRouteRowStatus, hh3cmplsVpnVrfNetPrefixType=hh3cmplsVpnVrfNetPrefixType, hh3cmplsVpnVrfBgpNbrRowStatus=hh3cmplsVpnVrfBgpNbrRowStatus, hh3cmplsVpnVrfBgpNbrAddr=hh3cmplsVpnVrfBgpNbrAddr, hh3cmplsVpnVrfConfRowStatus=hh3cmplsVpnVrfConfRowStatus, hh3cmplsVpnVrfRouteDistinguisher=hh3cmplsVpnVrfRouteDistinguisher, hh3cmplsVpnConfiguredVrfs=hh3cmplsVpnConfiguredVrfs, hh3cMplsVpn=hh3cMplsVpn, hh3cmplsVpnVrfNetPrefix=hh3cmplsVpnVrfNetPrefix, hh3cmplsVpnVrfBgpNbrAddrEntry=hh3cmplsVpnVrfBgpNbrAddrEntry, hh3cmplsVpnVrfBgpNbrAsNumber=hh3cmplsVpnVrfBgpNbrAsNumber, hh3cmplsVpnInterfaceLabelEdgeType=hh3cmplsVpnInterfaceLabelEdgeType, hh3cmplsVpnVrfRouteMask=hh3cmplsVpnVrfRouteMask, Hh3cMplsVpnId=Hh3cMplsVpnId, hh3cmplsVpnVrfIpRouteRedistributeRip=hh3cmplsVpnVrfIpRouteRedistributeRip, hh3cmplsVpnVrfRouteDest=hh3cmplsVpnVrfRouteDest, hh3cmplsVpnVrfIpRouteRedistributeConn=hh3cmplsVpnVrfIpRouteRedistributeConn, hh3cmplsVpnRoute=hh3cmplsVpnRoute, Hh3cMplsVpnRouteDistinguisher=Hh3cMplsVpnRouteDistinguisher, hh3cmplsVpnVrfRouteProto=hh3cmplsVpnVrfRouteProto, hh3cmplsVpnInterfaceConfRowStatus=hh3cmplsVpnInterfaceConfRowStatus, hh3cmplsVpnVrfRouteTargetRowStatus=hh3cmplsVpnVrfRouteTargetRowStatus, hh3cmplsVpnVrfRouteNextHop=hh3cmplsVpnVrfRouteNextHop, hh3cmplsVpnInterfaceVpnClassification=hh3cmplsVpnInterfaceVpnClassification, hh3cmplsVpnInterfaceIpAddress=hh3cmplsVpnInterfaceIpAddress, hh3cmplsVpnVrfIpRouteRedistributeStatic=hh3cmplsVpnVrfIpRouteRedistributeStatic, hh3cmplsVpnVrfConfHighRouteThreshold=hh3cmplsVpnVrfConfHighRouteThreshold, hh3cmplsVpnVrfRouteTargetEntry=hh3cmplsVpnVrfRouteTargetEntry, hh3cmplsVpnActiveVrfs=hh3cmplsVpnActiveVrfs, hh3cmplsVpnVrfRouteIfIndex=hh3cmplsVpnVrfRouteIfIndex, hh3cmplsVpnInterfaceIpAddressMask=hh3cmplsVpnInterfaceIpAddressMask, hh3cmplsVpnObjects=hh3cmplsVpnObjects, hh3cmplsVpnConf=hh3cmplsVpnConf, hh3cmplsVpnVrfRouteTargetType=hh3cmplsVpnVrfRouteTargetType, hh3cmplsVpnScalars=hh3cmplsVpnScalars, hh3cmplsVpnVrfBgpNbrRole=hh3cmplsVpnVrfBgpNbrRole, hh3cmplsVpnInterfaceConfEntry=hh3cmplsVpnInterfaceConfEntry, hh3cmplsVpnVrfConfEntry=hh3cmplsVpnVrfConfEntry, hh3cmplsVpnVrfRouteEntry=hh3cmplsVpnVrfRouteEntry, hh3cmplsVpnVrfConfIsWarnOnly=hh3cmplsVpnVrfConfIsWarnOnly, hh3cmplsVpnInterfaceConfIndex=hh3cmplsVpnInterfaceConfIndex, hh3cmplsVpnVrfBgpNbrAddrTable=hh3cmplsVpnVrfBgpNbrAddrTable)

#
# PySNMP MIB module CISCO-PRIVATE-VLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-PRIVATE-VLAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
vtpVlanEntry, vtpVlanEditEntry = mibBuilder.importSymbols("CISCO-VTP-MIB", "vtpVlanEntry", "vtpVlanEditEntry")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Bits, IpAddress, MibIdentifier, ObjectIdentity, NotificationType, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, iso, Gauge32, Integer32, TimeTicks, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "IpAddress", "MibIdentifier", "ObjectIdentity", "NotificationType", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "iso", "Gauge32", "Integer32", "TimeTicks", "Counter64")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
ciscoPrivateVlanMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 173))
ciscoPrivateVlanMIB.setRevisions(('2005-09-08 00:00', '2002-07-24 00:00', '2001-05-23 00:00', '2001-04-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setRevisionsDescriptions(('Added support for Private VLAN Promiscuous Trunk Ports. by adding a new mode type', 'Added support for Private VLAN Trunk Ports. Added the TCs for VlanIndex Bitmaps', 'Added support for Private VLAN port mode and SVI mapping.', ' The Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setLastUpdated('200509080000Z')
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wbu@cisco.com')
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setDescription("The MIB module to support Private VLAN feature on Cisco's switching devices.")
class PrivateVlanType(TextualConvention, Integer32):
    description = "The VLAN type as defined for Private VLAN feature. 'normal' -- this VLAN is a normal VLAN (i.e., not a private VLAN or private group). 'primary' -- this VLAN is the primary VLAN as defined for Private VLAN feature. 'isolated' -- this VLAN is the isolated VLAN as defined for Private VLAN feature. All the ports in the isolated VLAN can only talk to the specifically designated ports configured as promiscuous ports, i.e., the ports even in the same isolated VLAN can not talk to each other. Promiscuous ports are the ports that are performing the L2 mapping of the secondary VLANs (isolated, community, twoWayCommunity VLANs) to their associated primary VLANs. Promiscuous ports with cpvlanPromPortTwoWayRemapCapable values of true(1) can also perform the L2 mapping of primary VLANS to the twoWayCommunity (5) VLANs associated with them. 'community' -- this VLAN is the community VLAN as defined for Private VLAN feature. All the ports in this community VLAN can behave like ports in normal VLAN type except that they can also receive egress packets tagged with its associated primary VLAN ID. 'twoWayCommunity' -- this VLAN is the twoWayCommunity VLAN as defined for Private VLAN feature. All the ports in this twoWayCommunity VLAN behave the same as ports in community(4) VLAN. Promiscuous ports with cpvlanPromPortTwoWayRemapCapable value of true can also perform the L2 mapping from primary VLANs to the twoWayCommunity VLANs associated with them. A VLAN of isolated(3), community(4) or twoWayCommunity(5) type is also called a secondary VLAN."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("normal", 1), ("primary", 2), ("isolated", 3), ("community", 4), ("twoWayCommunity", 5))

class VlanIndexOrZero(TextualConvention, Integer32):
    description = 'The VLAN ID or zero as defined for Private VLAN feature. If the value is between 1 and 4095 inclusive, it represents an IEEE 802.1Q VLAN-ID. If the value is zero, it is object-specific and must therefore be defined as part of the description of any object which uses this syntax.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 4095)

class VlanIndexBitmap(TextualConvention, OctetString):
    description = "A string of octets containing one bit per VLAN for a total of 1024 VLANs in the management domain. The most significant bit of the octet string is the lowest value VLAN of 1024 VLANs. Refer to the description on the MIB object that uses this textual convention to determine the meaning of bits that are set ('1') or cleared ('0'). The most significant bit of the bitmap is transmitted first. Note that if the length of this string is less than 128 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 128)

cpvlanMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1))
cpvlanVlanObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1))
cpvlanPortObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2))
cpvlanSVIObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3))
cpvlanVlanTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1), )
if mibBuilder.loadTexts: cpvlanVlanTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanTable.setDescription('A table containing Private VLAN information on the VLANs which currently exist.')
cpvlanVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1, 1), )
vtpVlanEntry.registerAugmentions(("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEntry"))
cpvlanVlanEntry.setIndexNames(*vtpVlanEntry.getIndexNames())
if mibBuilder.loadTexts: cpvlanVlanEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanEntry.setDescription('A conceptual row containing the Private VLAN information on the VLANs for a particular management domain.')
cpvlanVlanPrivateVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1, 1, 1), PrivateVlanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanVlanPrivateVlanType.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanPrivateVlanType.setDescription('Indicated the VLAN type as defined for Private VLAN feature.')
cpvlanVlanAssociatedPrimaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1, 1, 2), VlanIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanVlanAssociatedPrimaryVlan.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanAssociatedPrimaryVlan.setDescription('The VLAN ID of The associated primary VLAN used for the Private VLAN feature if cpvlanVlanPrivateVlanType has the value of isolated(3), community(4) or twoWayCommunity(5). If cpvlanVlanPrivateVlanType has the value of normal(1) or primary(2), then this object has the value of 0. Note that one isolated VLAN can only be associated with one unique primary VLAN. One primary VLAN can only be associated with one isolated VLAN. One primary VLAN can be associated with multiple VLANs of community or twoWayCommunity type; one community or twoWayCommunity VLAN can only be associated with one unique primary VLAN.')
cpvlanVlanEditTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2), )
if mibBuilder.loadTexts: cpvlanVlanEditTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanEditTable.setDescription('A table containing Private VLAN information on the VLANs in the VLAN Edit Buffer for a particular management domain.')
cpvlanVlanEditEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2, 1), )
vtpVlanEditEntry.registerAugmentions(("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEditEntry"))
cpvlanVlanEditEntry.setIndexNames(*vtpVlanEditEntry.getIndexNames())
if mibBuilder.loadTexts: cpvlanVlanEditEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanEditEntry.setDescription('A conceptual row containing the Private VLAN information on the VLANs in the VLAN Edit Buffer for a particular management domain.')
cpvlanVlanEditPrivateVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2, 1, 1), PrivateVlanType().clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanVlanEditPrivateVlanType.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanEditPrivateVlanType.setDescription("The VLAN type as defined for Private VLAN feature. Note that a VLAN's Private VLAN type can not be changed once it already has any ports in it.")
cpvlanVlanEditAssocPrimaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2, 1, 2), VlanIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanVlanEditAssocPrimaryVlan.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanEditAssocPrimaryVlan.setDescription('The VLAN ID of the associated primary VLAN used for the Private VLAN feature if cpvlanVlanEditPrivateVlanType has the value of isolated(3), community(4), twoWayCommunity(5). If cpvlanVlanEditPrivateVlanType has the value of normal(1) or primary(2), then this object has the value of 0. Note that one isolated VLAN can only be associated with one unique primary VLAN. One primary VLAN can only be associated with one isolated VLAN. One primary VLAN can be associated with multiple VLANs of community or twoWayCommunity type; one community or twoWayCommunity VLAN can only be associated with one unique primary VLAN.')
cpvlanPrivatePortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 1), )
if mibBuilder.loadTexts: cpvlanPrivatePortTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanPrivatePortTable.setDescription('A table containing information of the configuration of secondary VLAN on the ports of the device.')
cpvlanPrivatePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanPrivatePortEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanPrivatePortEntry.setDescription('A conceptual row containing information of the configuration of secondary VLAN for each port. An entry is created by the managed system for each interface which can be configured as a private port for Private VLAN feature.')
cpvlanPrivatePortSecondaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 1, 1, 1), VlanIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPrivatePortSecondaryVlan.setStatus('current')
if mibBuilder.loadTexts: cpvlanPrivatePortSecondaryVlan.setDescription('The VLAN ID of the secondary VLAN configured on this private port. A private port is a port that allows the ingress traffic of the secondary VLAN as well as egress traffic of its associated primary VLAN, but blocks the egress traffic of the isolated VLAN while allowing the egress traffic of the community or twoWayCommunity VLAN depending on the type of the secondary VLAN. Note that a port can join a secondary VLAN only after this secondary VLAN has been associated with a primary VLAN, i.e., the cpvlanVlanAssociatedPrimaryVlan has a non-zero value. The default value of 0 for this object means this port has not joined any secondary VLAN yet.')
cpvlanPromPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2), )
if mibBuilder.loadTexts: cpvlanPromPortTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortTable.setDescription('A table containing information of secondary VLAN to primary VLAN remapping on ports of the device.')
cpvlanPromPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanPromPortEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortEntry.setDescription('A conceptual row containing information of secondary VLAN to primary VLAN remapping for each port. An entry is created by the managed system for each interface which can be configured as a promiscuous port for Private VLAN feature.')
cpvlanPromPortMultiPrimaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanPromPortMultiPrimaryVlan.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortMultiPrimaryVlan.setDescription("Indicates whether all the bits set as secondary VLANs in the corresponding remapping objects (i.e. cpvlanPromPortSecondaryRemap, cpvlanPromPortSecondaryRemap2k, cpvlanPromPortSecondaryRemap3k, cpvlanPromPortSecondaryRemap4k) can belong to multiple primary VLANs or not for this port. If this object value is false(2), then the object values of cpvlanVlanAssociatedPrimaryVlan for the secondary VLANs with their bits turned on as '1' in those remapping objects must be the same. If this object value is true(1), then the object values of cpvlanVlanAssociatedPrimaryVlan for the secondary VLANs with their bits turned on as '1' in those remapping objects need not be the same. A promiscuous port can remap a secondary VLAN to its associated primary VLAN for egress traffic on the fly as defined for Private VLAN feature.")
cpvlanPromPortSecondaryRemap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap.setDescription("A string of octets containing one bit per VLAN in the management domain on this port. The first octet corresponds to VLANs with VlanIndexOrZero values of 0 through 7; the second octet to VLANs 8 through 15; etc. The most significant bit of each octet corresponds to the lowest value VlanIndexOrZero in that octet. A bit can only be set to '1' when the bit is corresponding to a VLAN of Private VLAN isolated, community or twoWayCommunity type which has already been associated with a primary VLAN. Setting this bit to '1' makes this promiscuous port remap the secondary VLAN to its associated primary VLAN for egress traffic on the fly, or remap the associated primary VLAN to the secondary VLAN if the secondary VLAN is of twoWayCommunity type and the object value of cpvlanPromPortTwoWayRemapCapable for this promiscuous port is true(1). Note that if the length of this string is less than 128 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs.")
cpvlanPromPortSecondaryRemap2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap2k.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap2k.setDescription("A string of octets containing one bit per VLAN for VLANs with VlanIndexOrZero values of 1024 through 2047 in the management domain on this port. The first octet corresponds to VLANs with VlanIndexOrZero values of 1024 through 1031; the second octet to VLANs 1032 through 1039; etc. The most significant bit of each octet corresponds to the lowest value VlanIndexOrZero in that octet. A bit can only be set to '1' when the bit is corresponding to a VLAN of Private VLAN isolated or community type which has already been associated with a primary VLAN. Setting this bit to '1' makes this promiscuous port remap the secondary VLAN to its associated primary VLAN for egress traffic on the fly, or remap the associated primary VLAN to the secondary VLAN if the secondary VLAN is of twoWayCommunity type and the object value of cpvlanPromPortTwoWayRemapCapable for this promiscuous port is true(1). Note that if the length of this string is less than 128 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. This object is only instantiated on devices which support the range of VlanIndexOrZero up to 4095.")
cpvlanPromPortSecondaryRemap3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap3k.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap3k.setDescription("A string of octets containing one bit per VLAN for VLANs with VlanIndexOrZero values of 2048 through 3071 in the management domain on this port. The first octet corresponds to VLANs with VlanIndexOrZero values of 2048 through 2055; the second octet to VLANs 2056 through 2063; etc. The most significant bit of each octet corresponds to the lowest value VlanIndexOrZero in that octet. A bit can only be set to '1' when the bit is corresponding to a VLAN of Private VLAN isolated or community type which has already been associated with a primary VLAN. Setting this bit to '1' makes this promiscuous port remap the secondary VLAN to its associated primary VLAN for egress traffic on the fly, or remap the associated primary VLAN to the secondary VLAN if the secondary VLAN is of twoWayCommunity type and the object value of cpvlanPromPortTwoWayRemapCapable for this promiscuous port is true(1). Note that if the length of this string is less than 128 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. This object is only instantiated on devices which support the range of VlanIndexOrZero up to 4095.")
cpvlanPromPortSecondaryRemap4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap4k.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap4k.setDescription("A string of octets containing one bit per VLAN for VLANs with VlanIndexOrZero values of 3072 through 4095 in the management domain on this port. The first octet corresponds to VLANs with VlanIndexOrZero values of 3072 through 3079; the second octet to VLANs 3080 through 3087; etc. The most significant bit of each octet corresponds to the lowest value VlanIndexOrZero in that octet. A bit can only be set to '1' when the bit is corresponding to a VLAN of Private VLAN isolated or community type which has already been associated with a primary VLAN. Setting this bit to '1' makes this promiscuous port remap the secondary VLAN to its associated primary VLAN for egress traffic on the fly, or remap the associated primary VLAN to the secondary VLAN if the secondary VLAN is of twoWayCommunity type and the object value of cpvlanPromPortTwoWayRemapCapable for this promiscuous port is true(1). Note that if the length of this string is less than 128 octets, any 'missing' octets are assumed to contain the value zero. An NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. This object is only instantiated on devices which support the range of VlanIndexOrZero up to 4095.")
cpvlanPromPortTwoWayRemapCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanPromPortTwoWayRemapCapable.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortTwoWayRemapCapable.setDescription('Indicates whether the port is capable to perform remapping from primary VLANs to the twoWayCommunity VLANs associated with them for the Private VLAN feature. A promiscuous port with this object value of false(2) can only perform one-way remapping from secondary VLANs to their associated primary VLANs, while a promiscuous port with this object value of true(1) can also perform remapping from primary VLANs to the twoWayCommunity VLANs associated with them in addition to that.')
cpvlanPortModeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 3), )
if mibBuilder.loadTexts: cpvlanPortModeTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanPortModeTable.setDescription('A table containing information of the configuration of port mode for the Private VLAN feature.')
cpvlanPortModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanPortModeEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanPortModeEntry.setDescription('A conceptual row containing information of the configuration of port mode on each port for the Private VLAN feature. An entry of this table is created by the managed system when the capability to be a Private VLAN port is detected on an interface.')
cpvlanPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonPrivateVlan", 1), ("host", 2), ("promiscuous", 3), ("secondaryTrunk", 4), ("promiscuousTrunk", 5))).clone('nonPrivateVlan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPortMode.setStatus('current')
if mibBuilder.loadTexts: cpvlanPortMode.setDescription('The Private VLAN port mode on this port. nonPrivateVlan(1) -- this port is configured to be a non-Private-VLAN port. host(2) -- this port is configured to be a Private-VLAN host port, i.e., private port. promiscuous(3) -- this port is configured to be a Private-VLAN promiscuous port. secondaryTrunk(4) -- this port is configured to be a Private-VLAN isolated trunk port or community trunk port. promiscuousTrunk(5) -- this port is configured to be a Private-VLAN promiscuous trunk port.')
cpvlanTrunkPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4), )
if mibBuilder.loadTexts: cpvlanTrunkPortTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortTable.setDescription('A table containing information of the configuration of a private vlan trunk port in the device. This includes secondary and normal allowed VLAN, encapsulation type, trunk native vlan (as applied to private vlan trunks).')
cpvlanTrunkPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanTrunkPortEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortEntry.setDescription('A conceptual row containing information of the configuration of one private vlan trunk port. An entry is created by the managed system for each interface which can be configured as a private vlan trunk port')
cpvlanTrunkPortDynamicState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("onNoNegotiate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortDynamicState.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortDynamicState.setDescription("For private VLAN trunk ports, this object allows the operator to mandate the trunking behavior of the port on(1) dictates that the private VLAN port will always be a trunk. If the negotiation is supported on this port, negotiation will take place with the far end to attempt to bring the far end into trunking state. onNoNegotiate(2) is used to indicate that the interface is permanently set to be a trunk, and no negotiation takes place with the far end on the link to ensure consistent operation. This is similar to on(1) except no negotiation takes place with the far end. If a port does not support negotiation, the value of on(1) is not allowed. If the port's cpvlanTrunkPortEncapType is set to negotiate(3), onNoNegotiate(2) is not allowed.")
cpvlanTrunkPortEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1Q", 1), ("isl", 2), ("negotiate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortEncapType.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortEncapType.setDescription("The type of VLAN encapsulation desired to be used on this private vlan trunk port. It is either a particular type, or 'negotiate' meaning whatever type results from the negotiation. dot1Q(1) indicates that the port should accept and transmit packets with IEEE 802.1q VLAN encapsulation isl(2) indicates that the port should accept and transmit packets with Inter Switch Link (ISL) VLAN encapsulation negotiate(3) indicates that the VLAN encapsulation is negotiated with the far end. The negotiated VLAN encapsulation can be dot1Q or isl. negotiate(2) is not allowed if the port does not support negotiation of VLAN encapsulation type or if its cpvlanTrunkPortDynamicState is set to onNoNegotiate(2)")
cpvlanTrunkPortNativeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 3), VlanIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNativeVlan.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortNativeVlan.setDescription('The VlanIndex of the VLAN which is represented by native frames on this private vlan trunk port. For private vlan trunk ports that need to drop untagged frames or not supporting the sending and receiving of native frames, this value should be set to zero')
cpvlanTrunkPortSecondaryVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 4), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 0 through 1023 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a secondary VLAN that has already been associated with a primary VLAN, it allows this private VLAN trunk port to remap the secondary VLAN to its primary VLAN for ingress traffic and to remap its associated primary VLAN to the secondary VLAN for egress traffic. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a secondary VLAN, then the local system is enabled to transmit and receive frames with proper VLAN remapping via this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a normal VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port.")
cpvlanTrunkPortSecondaryVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 5), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans2k.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans2k.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 1024 through 2047 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a secondary VLAN that has already been associated with a primary VLAN, it allows this private VLAN trunk port to remap the secondary VLAN to its primary VLAN for ingress traffic and to remap its associated primary VLAN to the secondary VLAN for egress traffic. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a secondary VLAN, then the local system is enabled to transmit and receive frames with proper VLAN remapping via this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a normal VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port. This object is only instantiated on devices which support the range of VLANs up to 4095.")
cpvlanTrunkPortSecondaryVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 6), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans3k.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans3k.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 2048 through 3071 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a secondary VLAN that has already been associated with a primary VLAN, it allows this private VLAN trunk port to remap the secondary VLAN to its primary VLAN for ingress traffic and to remap its associated primary VLAN to the secondary VLAN for egress traffic. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a secondary VLAN, then the local system is enabled to transmit and receive frames with proper VLAN remapping via this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a normal VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port. This object is only instantiated on devices which support the range of up to 4095.")
cpvlanTrunkPortSecondaryVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 7), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans4k.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans4k.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 3072 through 4095 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a secondary VLAN that has already been associated with a primary VLAN, it allows this private VLAN trunk port to remap the secondary VLAN to its primary VLAN for ingress traffic and to remap its associated primary VLAN to the secondary VLAN for egress traffic. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a secondary VLAN, then the local system is enabled to transmit and receive frames with proper VLAN remapping via this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a normal VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port. This object is only instantiated on devices which support the range of up to 4095.")
cpvlanTrunkPortNormalVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 8), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 0 through 1023 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a normal VLAN, it allows packets belonging to this vlan on this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a normal VLAN, then the local system is enabled to transmit and receive frames as normal VLAN If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a secondary VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port.")
cpvlanTrunkPortNormalVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 9), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans2k.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans2k.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 1024 through 2047 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a normal VLAN, it allows packets belonging to this vlan on this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a normal VLAN, then the local system is enabled to transmit and receive frames as normal VLAN If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a secondary VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port. This object is only instantiated on devices which support the range of VlanIndexOrZero up to 4095.")
cpvlanTrunkPortNormalVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 10), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans3k.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans3k.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 2048 through 3071 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a normal VLAN, it allows packets belonging to this vlan on this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a normal VLAN, then the local system is enabled to transmit and receive frames as normal VLAN If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a secondary VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port. This object is only instantiated on devices which support the range of VlanIndexOrZero up to 4095.")
cpvlanTrunkPortNormalVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 11), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans4k.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans4k.setDescription("A string of octets containing one bit per VLAN for VLANs with values of 3072 through 4095 in the management domain on this port. If the VLAN represented by setting a bit to '1' in the bitmap is a normal VLAN, it allows packets belonging to this vlan on this Private VLAN trunk port. If the bit corresponding to a VLAN is set to '1' and if the corresponding VLAN is a normal VLAN, then the local system is enabled to transmit and receive frames as normal VLAN If the bit corresponding to a VLAN is set to '0', and if the corresponding VLAN is not configured as a secondary VLAN, then the system is disabled from sending and receiving frames on that VLAN via this Private VLAN trunk port. This object is only instantiated on devices which support the range of VlanIndexOrZero up to 4095.")
cpvlanTrunkPortDynamicStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trunking", 1), ("notTrunking", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanTrunkPortDynamicStatus.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortDynamicStatus.setDescription('Indicates the current dynamic trunking status of the specified private VLAN port. trunking(1) indicates that the private VLAN port is currently operating as a private VLAN trunk port notTrunking(2) indicates that the private VLAN port is currently not trunking but is operating as an access port.')
cpvlanTrunkPortEncapOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1Q", 1), ("isl", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanTrunkPortEncapOperType.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortEncapOperType.setDescription('The type of VLAN encapsulation in use on this private vlan trunk port. dot1Q(1) indicates that the port accepts and transmits packets with IEEE 802.1q VLAN encapsulation isl(2) indicates that the port accepts and transmits packets with Inter Switch Link (ISL) VLAN encapsulation If the cpvlanTrunkPortDynamicStatus is notTrunking(2) or if the encapsulation type negotiation has not been completed, the object is set to notApplicable(3).')
cpvlanSVIMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1), )
if mibBuilder.loadTexts: cpvlanSVIMappingTable.setStatus('current')
if mibBuilder.loadTexts: cpvlanSVIMappingTable.setDescription('A table containing the configuration of primary VLAN SVI (Switch Virtual Interfaces) mapping for the secondary VLANs for the Private VLAN feature.')
cpvlanSVIMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-PRIVATE-VLAN-MIB", "cpvlanSVIMappingVlanIndex"))
if mibBuilder.loadTexts: cpvlanSVIMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cpvlanSVIMappingEntry.setDescription("A conceptual row containing the Primary VLAN SVI mapping configuration for the existing secondary VLANs. An entry is created by the managed system for each VLAN with corresponding VLAN's cpvlanVlanPrivateVlanType of isolated(3), community(4), and twoWayCommunity(5).")
cpvlanSVIMappingVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1, 1, 1), VlanIndexOrZero())
if mibBuilder.loadTexts: cpvlanSVIMappingVlanIndex.setStatus('current')
if mibBuilder.loadTexts: cpvlanSVIMappingVlanIndex.setDescription('An index value that uniquely identifies the Virtual LAN associated with this information.')
cpvlanSVIMappingPrimarySVI = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1, 1, 2), VlanIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanSVIMappingPrimarySVI.setStatus('current')
if mibBuilder.loadTexts: cpvlanSVIMappingPrimarySVI.setDescription('The Vlan ID of the primary VLAN SVI this secondary VLAN is mapped to for the Private VLAN feature. This object has the value of zero if this secondary VLAN is not mapped to any primary VLAN SVI.')
cpvlanMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 2))
cpvlanMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 1))
cpvlanMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2))
cpvlanMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 1, 1)).setObjects()

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanMIBCompliance = cpvlanMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cpvlanMIBCompliance.setDescription('The compliance statement for Private VLAN feature implementation.')
cpvlanVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 1)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanPrivateVlanType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanAssociatedPrimaryVlan"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEditPrivateVlanType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEditAssocPrimaryVlan"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanVlanGroup = cpvlanVlanGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanVlanGroup.setDescription('A collection of objects providing basic VLAN configuration for Private VLAN feature.')
cpvlanPrivatePortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 2)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPrivatePortSecondaryVlan"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanPrivatePortGroup = cpvlanPrivatePortGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanPrivatePortGroup.setDescription('A collection of objects providing basic private port configuration for Private VLAN feature.')
cpvlanPromPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 3)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortMultiPrimaryVlan"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortTwoWayRemapCapable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanPromPortGroup = cpvlanPromPortGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPortGroup.setDescription('A collection of objects providing basic promiscuous port configuration for Private VLAN feature.')
cpvlanPromPort4kGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 4)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap2k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap3k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap4k"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanPromPort4kGroup = cpvlanPromPort4kGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanPromPort4kGroup.setDescription('A collection of objects providing basic promiscuous port configuration for Private VLAN feature on devices with VlanIndexOrZero range of up to 4095.')
cpvlanPortModeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 5)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPortMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanPortModeGroup = cpvlanPortModeGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanPortModeGroup.setDescription('This is an optional group with a collection of objects providing basic port mode configuration for Private VLAN feature on devices which support Private VLAN port mode feature.')
cpvlanSVIMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 6)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanSVIMappingPrimarySVI"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanSVIMappingGroup = cpvlanSVIMappingGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanSVIMappingGroup.setDescription('This is an optional group with a collection of objects providing primary VLAN SVI mapping configuration for the Private VLAN feature on devices which support Primary VLAN SVI mapping feature.')
cpvlanTrunkPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 7)).setObjects(("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortDynamicState"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortEncapType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNativeVlan"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans2k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans3k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans4k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans2k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans3k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans4k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortDynamicStatus"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortEncapOperType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpvlanTrunkPortGroup = cpvlanTrunkPortGroup.setStatus('current')
if mibBuilder.loadTexts: cpvlanTrunkPortGroup.setDescription('A collection of objects providing basic private VLAN trunk port configuration for Private VLAN feature.')
mibBuilder.exportSymbols("CISCO-PRIVATE-VLAN-MIB", cpvlanTrunkPortEntry=cpvlanTrunkPortEntry, cpvlanSVIMappingPrimarySVI=cpvlanSVIMappingPrimarySVI, cpvlanPromPortSecondaryRemap3k=cpvlanPromPortSecondaryRemap3k, cpvlanVlanPrivateVlanType=cpvlanVlanPrivateVlanType, cpvlanTrunkPortDynamicState=cpvlanTrunkPortDynamicState, cpvlanPromPortSecondaryRemap2k=cpvlanPromPortSecondaryRemap2k, cpvlanVlanTable=cpvlanVlanTable, cpvlanVlanObjects=cpvlanVlanObjects, cpvlanPromPortMultiPrimaryVlan=cpvlanPromPortMultiPrimaryVlan, ciscoPrivateVlanMIB=ciscoPrivateVlanMIB, cpvlanTrunkPortSecondaryVlans4k=cpvlanTrunkPortSecondaryVlans4k, cpvlanTrunkPortNormalVlans3k=cpvlanTrunkPortNormalVlans3k, cpvlanTrunkPortNormalVlans4k=cpvlanTrunkPortNormalVlans4k, cpvlanTrunkPortEncapOperType=cpvlanTrunkPortEncapOperType, cpvlanTrunkPortTable=cpvlanTrunkPortTable, cpvlanPromPortSecondaryRemap=cpvlanPromPortSecondaryRemap, cpvlanSVIMappingEntry=cpvlanSVIMappingEntry, cpvlanPortModeGroup=cpvlanPortModeGroup, cpvlanVlanEditPrivateVlanType=cpvlanVlanEditPrivateVlanType, cpvlanSVIMappingTable=cpvlanSVIMappingTable, cpvlanTrunkPortNativeVlan=cpvlanTrunkPortNativeVlan, cpvlanTrunkPortSecondaryVlans=cpvlanTrunkPortSecondaryVlans, cpvlanVlanAssociatedPrimaryVlan=cpvlanVlanAssociatedPrimaryVlan, cpvlanPromPortEntry=cpvlanPromPortEntry, cpvlanTrunkPortNormalVlans=cpvlanTrunkPortNormalVlans, cpvlanMIBCompliances=cpvlanMIBCompliances, cpvlanTrunkPortGroup=cpvlanTrunkPortGroup, VlanIndexOrZero=VlanIndexOrZero, cpvlanPromPortTable=cpvlanPromPortTable, cpvlanPrivatePortSecondaryVlan=cpvlanPrivatePortSecondaryVlan, cpvlanPrivatePortEntry=cpvlanPrivatePortEntry, cpvlanSVIObjects=cpvlanSVIObjects, cpvlanTrunkPortDynamicStatus=cpvlanTrunkPortDynamicStatus, cpvlanTrunkPortSecondaryVlans3k=cpvlanTrunkPortSecondaryVlans3k, cpvlanPortModeEntry=cpvlanPortModeEntry, cpvlanPromPortTwoWayRemapCapable=cpvlanPromPortTwoWayRemapCapable, cpvlanPrivatePortGroup=cpvlanPrivatePortGroup, cpvlanSVIMappingGroup=cpvlanSVIMappingGroup, VlanIndexBitmap=VlanIndexBitmap, cpvlanTrunkPortNormalVlans2k=cpvlanTrunkPortNormalVlans2k, PYSNMP_MODULE_ID=ciscoPrivateVlanMIB, cpvlanMIBGroups=cpvlanMIBGroups, cpvlanPromPort4kGroup=cpvlanPromPort4kGroup, PrivateVlanType=PrivateVlanType, cpvlanVlanEditTable=cpvlanVlanEditTable, cpvlanPromPortSecondaryRemap4k=cpvlanPromPortSecondaryRemap4k, cpvlanMIBConformance=cpvlanMIBConformance, cpvlanPromPortGroup=cpvlanPromPortGroup, cpvlanSVIMappingVlanIndex=cpvlanSVIMappingVlanIndex, cpvlanVlanEntry=cpvlanVlanEntry, cpvlanTrunkPortEncapType=cpvlanTrunkPortEncapType, cpvlanTrunkPortSecondaryVlans2k=cpvlanTrunkPortSecondaryVlans2k, cpvlanVlanEditAssocPrimaryVlan=cpvlanVlanEditAssocPrimaryVlan, cpvlanPortObjects=cpvlanPortObjects, cpvlanPrivatePortTable=cpvlanPrivatePortTable, cpvlanPortModeTable=cpvlanPortModeTable, cpvlanVlanEditEntry=cpvlanVlanEditEntry, cpvlanMIBObjects=cpvlanMIBObjects, cpvlanMIBCompliance=cpvlanMIBCompliance, cpvlanPortMode=cpvlanPortMode, cpvlanVlanGroup=cpvlanVlanGroup)

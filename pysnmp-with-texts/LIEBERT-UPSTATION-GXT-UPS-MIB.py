#
# PySNMP MIB module LIEBERT-UPSTATION-GXT-UPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIEBERT-UPSTATION-GXT-UPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:07:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysUpTime, = mibBuilder.importSymbols("SNMPv2-MIB", "sysUpTime")
Counter64, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, Gauge32, Bits, ModuleIdentity, Integer32, ObjectIdentity, NotificationType, Unsigned32, NotificationType, TimeTicks, MibIdentifier, IpAddress, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "Gauge32", "Bits", "ModuleIdentity", "Integer32", "ObjectIdentity", "NotificationType", "Unsigned32", "NotificationType", "TimeTicks", "MibIdentifier", "IpAddress", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
emerson = MibIdentifier((1, 3, 6, 1, 4, 1, 476))
liebertCorp = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1))
liebertUps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1))
luExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1))
luExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 2))
luPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 3))
luCore = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1))
lcUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1))
lcUpsIdentManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setDescription('The UPS manufacturer.')
lcUpsIdentModel = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsIdentModel.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentModel.setDescription('The UPS Model designation.')
lcUpsIdentSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setDescription('The UPS SNMP Agent software version.')
lcUpsIdentSpecific = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSpecific.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSpecific.setDescription('A reference to MIB definitions specific to the particular UPS being managed. This object is used to locate the product-specific MIB for this device. If this information is not present, its value should be the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
lcUpsIdentFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentFirmwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentFirmwareVersion.setDescription('The firmware revision level of the UPS.')
lcUpsIdentSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSerialNumber.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSerialNumber.setDescription('The serial number of the UPS.')
lcUpsIdentManufactureDate = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentManufactureDate.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentManufactureDate.setDescription('The date of manufacture of the UPS.')
lcUpsBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2))
lcUpsBatTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setDescription('The estimated time to depletion of battery charge. (Unit of measure: Minute)')
lcUpsBatVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatVoltage.setDescription('The current battery voltage. (Unit of measure: volt)')
lcUpsBatCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCapacity.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCapacity.setDescription('The current battery capacity in percentage of total available.')
lcUpsInput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3))
lcUpsInputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputFrequency.setDescription('The current input frequency. (Unit of measure: Hertz)')
lcUpsInputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputNumLines.setDescription('The number of input lines utilized in this device. This entry indicates the number of rows in the input table.')
lcUpsInputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6), )
if mibBuilder.loadTexts: lcUpsInputTable.setStatus('optional')
lcUpsInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-GXT-UPS-MIB", "lcUpsInputLine"))
if mibBuilder.loadTexts: lcUpsInputEntry.setStatus('optional')
lcUpsInputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputLine.setDescription('The input Line.')
lcUpsInputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVoltage.setDescription('The input voltage. (Unit of measure: Volt)')
lcUpsOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4))
lcUpsOutputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputFrequency.setDescription('The current output frequency. (Unit of measure: Hertz)')
lcUpsOutputLoad = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputLoad.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputLoad.setDescription('The current output load percentage.')
lcUpsOutputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputNumLines.setDescription('The number of output lines utilized in this device. This entry indicates the number of rows in the output table.')
lcUpsOutputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4), )
if mibBuilder.loadTexts: lcUpsOutputTable.setStatus('optional')
lcUpsOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-GXT-UPS-MIB", "lcUpsOutputLine"))
if mibBuilder.loadTexts: lcUpsOutputEntry.setStatus('optional')
lcUpsOutputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputLine.setDescription('The output Line.')
lcUpsOutputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputVoltage.setDescription('The output voltage. (Unit of measure: Volt)')
lcUpsOutputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputCurrent.setDescription('The output current. (Unit of measure: Amp)')
lcUpsOutputWatts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputWatts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputWatts.setDescription('The output power in watts.')
lcUpsInverter = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5))
lcUpsInverterStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterStatus.setDescription('The state of the inverter. Unknown is returned if the state can not be determined.')
lcUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6))
lcUpsAlarms = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarms.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarms.setDescription('The current number of alarm conditions.')
lcUpsAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2), )
if mibBuilder.loadTexts: lcUpsAlarmTable.setStatus('optional')
lcUpsAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-GXT-UPS-MIB", "lcUpsAlarmId"))
if mibBuilder.loadTexts: lcUpsAlarmEntry.setStatus('optional')
lcUpsAlarmId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmId.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmId.setDescription('A unique identifier for an alarm condition. This value must remain constant between agent initializations.')
lcUpsAlarmDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmDescr.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmDescr.setDescription('A reference to an alarm description object. The object referenced should not be accessible, but rather be used to provide a unique description of the alarm condition.')
lcUpsAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmTime.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmTime.setDescription('The value of sysUpTime when the alarm condition occured.')
lcUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3))
lcUpsAlarmLowBatteryWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 1))
lcUpsAlarmLowBatteryShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 2))
lcUpsAlarmUtilFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 3))
lcUpsAlarmOverTempWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 4))
lcUpsAlarmOverTempShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 5))
lcUpsAlarmOutputOverloadWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 6))
lcUpsAlarmOutputOverloadShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 7))
lcUpsAlarmInputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 8))
lcUpsAlarmBatteryBad = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 9))
lcUpsAlarmOnBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 10))
lcUpsAlarmStopNoticeIssued = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 11))
lcUpsAlarmUpsOff = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 12))
lcUpsAlarmInputFreqError = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 13))
lcUpsAlarmOutputUnderVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 15))
lcUpsAlarmOutputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 16))
lcUpsBadBypassPower = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 17))
lcUpsTest = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7))
lcUpsTestBattery = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestBattery.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBattery.setDescription("Setting this variable to 'start' will initiate the battery test. Setting this variable to 'abort' will stop the battery test if the test is in- progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'. If 'lcUpsTestBatteryStatus' is 'failed' the test may not be performed again and the status will remain in the failure state.")
lcUpsTestBatteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setDescription('The status of the battery test.')
lcUpsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8))
lcUpsControlOutputOffDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn off the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOffTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn on the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOnTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOffTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setDescription("When 'lcUpsControlOutputOffDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOffWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlOutputOnTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setDescription("When 'lcUpsControlOutputOnDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOnWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlUnixShutdownDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setDescription("Setting this object causes the agent to instruct the UPS to perform a UNIX Shutdown in the indicated number of seconds. The agent counts down the number of seconds until the event will take place. A Unix shutdown is only valid if the UPS is on Battery. During a UNIX Shutdown, the UPS will turn off the output even if the Utility comes back on line before the shutdown time arrives. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value 'cancel'.")
lcUpsControlUnixShutdownTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setDescription("When 'lcUpsControlUnixShutdownDelay' reaches a value less than or equal to this object's value, an lcUpsUnixShutdownWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlCancelCommands = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setDescription("Setting this variable to 'cancel' will cause the agent to issue instructions to the UPS to cancel all outstanding commands, such as lcUpsControlOutputOff, lcUpsControlOutputOn, lcUpsControlUnixShutdown.")
lcUpsControlRebootAgentDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setDescription('Setting this object causes the agent to reboot after the indicated number of seconds have expired. The value will count down until the event takes place. The command can be cancelled by setting lcUpsControlCancleCommand to the value cancel.')
lcUpsNominal = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9))
lcUpsNominalOutputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setDescription('The nominal output voltage. (Unit of measure: volt)')
lcUpsNominalInputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setDescription('The nominal input voltage. (Unit of measure: volt)')
lcUpsNominalOutputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setDescription('The nominal output frequency. (Unit of measure: Hertz)')
lcUpsNominalInputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setDescription('The nominal input frequency. (Unit of measure: Hertz)')
lcUpsNominalOutputVaRating = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVaRating.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVaRating.setDescription('The nominal Volt-Amp rating.')
lcUpsNominalOutputWattsRating = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputWattsRating.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputWattsRating.setDescription('The nominal power rating. (Unit of measure: watt)')
lcUpsBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13))
lcUpsOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3), ("maintenance", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOnBypass.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOnBypass.setDescription('Indicates that the UPS is currently on bypass.')
lcUpsBypassFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassFrequency.setDescription('The current bypass frequency. (Unit of measure: Hertz)')
lcUpsBypassNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassNumLines.setDescription('The number of bypass lines utilized in this device. This entry indicates the number of rows in the bypass table.')
lcUpsBypassTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4), )
if mibBuilder.loadTexts: lcUpsBypassTable.setStatus('optional')
lcUpsBypassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-GXT-UPS-MIB", "lcUpsBypassLine"))
if mibBuilder.loadTexts: lcUpsBypassEntry.setStatus('optional')
lcUpsBypassLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassLine.setDescription('The bypass Line.')
lcUpsBypassVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassVoltage.setDescription('The bypass voltage. (Unit of measure: Volt)')
lcUpsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14))
lcUpsConfigType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("online", 2), ("offline", 3), ("lineinteractive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsConfigType.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigType.setDescription('Indicates the UPS topology.')
lcUpsConfigBypassInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3), ("dualinput", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsConfigBypassInstalled.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigBypassInstalled.setDescription('Indicates if a bypass is installed in the UPS.')
lcUpsConfigModuleCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsConfigModuleCount.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigModuleCount.setDescription('A number identifying how many multi-module UPS are connected to the System Control Cabinet.')
lcUpsConfigAudibleStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("muted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigAudibleStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigAudibleStatus.setDescription('The requested state of the audible alarm. When in the disabled state, the audible alarm should never sound. The enabled state is self-describing. Setting this object to muted(3) when the audible alarm is sounding shall temporarily silence the alarm.')
lcUpsConfigLowBattTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigLowBattTime.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigLowBattTime.setDescription('The value of lcUpsBatTimeRemaining at which a lowBatteryWarning condition is declared. (Unit of measure: Minute)')
lcUpsConfigAutoRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigAutoRestart.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigAutoRestart.setDescription('Setting this object will start the output after the indicated number of ticks (1 tick = 10 seconds), including starting the UPS, if necessary. Setting this object to 0 will cause the startup to occur immediately. Setting this object to -1 will disable autorestart.')
lcUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11))
lcUpsOverloadWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverloadWarningTrap.setDescription("An lcUpsOverloadWarningTrap signifies that the UPS has detected an Overload condition where the output load has exceeded the UPS's rated capacity.")
lcUpsOverloadShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverloadShutdownTrap.setDescription("An lcUpsOverloadShutdownTrap signifies that the UPS has detected an Overload condition where the output load has exceeded the UPS's rated capacity and has shut off the output.")
lcUpsOnBatteryTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOnBatteryTrap.setDescription('An lcUpsOnBatteryTrap signifies that the UPS is currently on Battery Power.')
lcUpsLowBatteryWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryWarningTrap.setDescription('An lcUpsLowBatteryWarningTrap signifies that the UPS has entered a Low Battery state.')
lcUpsLowBatteryShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,5)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryShutdownTrap.setDescription('An lcUpsLowBatteryShutdownTrap signifies that the UPS has shut off the output due to a Low Battery state.')
lcUpsUtilPowerFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,6)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerFailedTrap.setDescription('An lcUpsUtilPowerFailedTrap signifies that the utility power input to the UPS has been lost.')
lcUpsUtilPowerRestoredTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,7)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerRestoredTrap.setDescription('An lcUpsUtilPowerRestoredTrap signifies that the utility power has been restored to the UPS.')
lcUpsInputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,8)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInputOverVoltageTrap.setDescription('An lcUpsInputOverVoltageTrap signifies that the UPS has detected a high input voltage condition.')
lcUpsOverTempWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,9)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempWarningTrap.setDescription('An lcUpsOverTempWarningTrap signifies that the UPS has detected a excessive temperature condition.')
lcUpsOverTempShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,10)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempShutdownTrap.setDescription('An lcUpsOverTempShutdownTrap signifies that the UPS has detected a excessive temperature condition and shut off the output.')
lcUpsAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,11)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsAlarmTrap.setDescription('An Alarm condition has occurred and is being reported in the lcUpsAlarmTable.')
lcUpsOutputOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,12)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffTrap.setDescription('An lcUpsOutputOffTrap is sent when the UPS turns all of its output off, either at the inverter or via a relay.')
lcUpsOutputOffWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,13)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffWarningTrap.setDescription('An lcUpsOutputOffWarningTrap is sent when the lcUpsControlOutputOffDelay reaches the value of lcUpsControlOutputOffTrapDelay.')
lcUpsOutputOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,14)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnTrap.setDescription('An lcUpsOutputOnTrap is sent when the UPS turns all of its output back on, either at the inverter or via a relay.')
lcUpsOutputOnWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,15)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnWarningTrap.setDescription('An lcUpsOutputOnWarningTrap is sent when the lcUpsControlOutputOnDelay reaches the value of lcUpsControlOutputOnTrapDelay.')
lcUpsUnixShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,16)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownTrap.setDescription('An lcUpsUnixShutodwnTrap is sent 2 seconds before the UPS is scheduled to perform a Unix Shutdown.')
lcUpsUnixShutdownWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,17)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownWarningTrap.setDescription('An lcUpsUnixShutdownWarningTrap is sent when the lcUpsControlUnixShudownDelay reaches the value of lcUpsControlUnixShutdownTrapDelay.')
lcUpsInputFreqErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,22)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInputFreqErrorTrap.setDescription('An ldUpsInputFreqErrorTrap signifies that the UPS has detected that input frequency is outside tolerable variance.')
lcUpsOutputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,24)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOverVoltageTrap.setDescription('An lcUpsOutputOverVoltageTrap signifies that the UPS has detected that the output voltage is too high.')
luUPStationGxt = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 14))
mibBuilder.exportSymbols("LIEBERT-UPSTATION-GXT-UPS-MIB", lcUpsOnBatteryTrap=lcUpsOnBatteryTrap, lcUpsConfigModuleCount=lcUpsConfigModuleCount, lcUpsAlarmOverTempWarning=lcUpsAlarmOverTempWarning, lcUpsOutputWatts=lcUpsOutputWatts, lcUpsOutputOffWarningTrap=lcUpsOutputOffWarningTrap, lcUpsUnixShutdownTrap=lcUpsUnixShutdownTrap, lcUpsAlarmLowBatteryWarning=lcUpsAlarmLowBatteryWarning, lcUpsNominalInputFreq=lcUpsNominalInputFreq, lcUpsOutputEntry=lcUpsOutputEntry, lcUpsAlarmTime=lcUpsAlarmTime, lcUpsOverTempShutdownTrap=lcUpsOverTempShutdownTrap, lcUpsInputEntry=lcUpsInputEntry, lcUpsConfigAudibleStatus=lcUpsConfigAudibleStatus, lcUpsOverloadWarningTrap=lcUpsOverloadWarningTrap, lcUpsControlOutputOffDelay=lcUpsControlOutputOffDelay, lcUpsTraps=lcUpsTraps, lcUpsBypassNumLines=lcUpsBypassNumLines, lcUpsAlarmOverTempShutdown=lcUpsAlarmOverTempShutdown, lcUpsControl=lcUpsControl, lcUpsConfig=lcUpsConfig, lcUpsConfigBypassInstalled=lcUpsConfigBypassInstalled, lcUpsOutputOverVoltageTrap=lcUpsOutputOverVoltageTrap, lcUpsAlarmTrap=lcUpsAlarmTrap, lcUpsOutputLoad=lcUpsOutputLoad, lcUpsBypass=lcUpsBypass, lcUpsBypassFrequency=lcUpsBypassFrequency, lcUpsAlarmUpsOff=lcUpsAlarmUpsOff, lcUpsNominalOutputVoltage=lcUpsNominalOutputVoltage, lcUpsOverTempWarningTrap=lcUpsOverTempWarningTrap, lcUpsInputLine=lcUpsInputLine, lcUpsTestBattery=lcUpsTestBattery, lcUpsIdent=lcUpsIdent, luUPStationGxt=luUPStationGxt, lcUpsAlarmOutputOverloadShutdown=lcUpsAlarmOutputOverloadShutdown, lcUpsBatCapacity=lcUpsBatCapacity, lcUpsControlCancelCommands=lcUpsControlCancelCommands, lcUpsNominalOutputVaRating=lcUpsNominalOutputVaRating, lcUpsInput=lcUpsInput, lcUpsAlarmLowBatteryShutdown=lcUpsAlarmLowBatteryShutdown, lcUpsIdentSoftwareVersion=lcUpsIdentSoftwareVersion, emerson=emerson, lcUpsAlarmOutputOverloadWarning=lcUpsAlarmOutputOverloadWarning, lcUpsAlarmUtilFailed=lcUpsAlarmUtilFailed, lcUpsOutputCurrent=lcUpsOutputCurrent, liebertCorp=liebertCorp, lcUpsAlarmOnBattery=lcUpsAlarmOnBattery, lcUpsAlarmOutputUnderVoltage=lcUpsAlarmOutputUnderVoltage, lcUpsOutputVoltage=lcUpsOutputVoltage, lcUpsControlUnixShutdownTrapDelay=lcUpsControlUnixShutdownTrapDelay, lcUpsBypassTable=lcUpsBypassTable, lcUpsAlarmInputOverVoltage=lcUpsAlarmInputOverVoltage, lcUpsOutputNumLines=lcUpsOutputNumLines, lcUpsNominalInputVoltage=lcUpsNominalInputVoltage, lcUpsIdentSpecific=lcUpsIdentSpecific, lcUpsAlarmConditions=lcUpsAlarmConditions, lcUpsNominalOutputWattsRating=lcUpsNominalOutputWattsRating, lcUpsInverter=lcUpsInverter, luExtensions=luExtensions, lcUpsOnBypass=lcUpsOnBypass, lcUpsNominalOutputFreq=lcUpsNominalOutputFreq, luCore=luCore, lcUpsInverterStatus=lcUpsInverterStatus, lcUpsAlarmEntry=lcUpsAlarmEntry, lcUpsTest=lcUpsTest, lcUpsBattery=lcUpsBattery, lcUpsConfigLowBattTime=lcUpsConfigLowBattTime, lcUpsInputTable=lcUpsInputTable, lcUpsAlarmOutputOverVoltage=lcUpsAlarmOutputOverVoltage, lcUpsLowBatteryWarningTrap=lcUpsLowBatteryWarningTrap, lcUpsInputVoltage=lcUpsInputVoltage, liebertUps=liebertUps, lcUpsConfigAutoRestart=lcUpsConfigAutoRestart, lcUpsControlOutputOffTrapDelay=lcUpsControlOutputOffTrapDelay, lcUpsIdentManufacturer=lcUpsIdentManufacturer, lcUpsUnixShutdownWarningTrap=lcUpsUnixShutdownWarningTrap, lcUpsControlOutputOnDelay=lcUpsControlOutputOnDelay, lcUpsConfigType=lcUpsConfigType, lcUpsInputNumLines=lcUpsInputNumLines, lcUpsAlarmTable=lcUpsAlarmTable, lcUpsNominal=lcUpsNominal, lcUpsOutputOnWarningTrap=lcUpsOutputOnWarningTrap, lcUpsBypassVoltage=lcUpsBypassVoltage, lcUpsInputFreqErrorTrap=lcUpsInputFreqErrorTrap, lcUpsOutputOnTrap=lcUpsOutputOnTrap, lcUpsIdentModel=lcUpsIdentModel, lcUpsBypassLine=lcUpsBypassLine, lcUpsIdentSerialNumber=lcUpsIdentSerialNumber, lcUpsTestBatteryStatus=lcUpsTestBatteryStatus, lcUpsAlarmStopNoticeIssued=lcUpsAlarmStopNoticeIssued, luExperimental=luExperimental, lcUpsUtilPowerRestoredTrap=lcUpsUtilPowerRestoredTrap, lcUpsAlarmBatteryBad=lcUpsAlarmBatteryBad, lcUpsAlarmDescr=lcUpsAlarmDescr, lcUpsInputOverVoltageTrap=lcUpsInputOverVoltageTrap, lcUpsOutputTable=lcUpsOutputTable, lcUpsControlRebootAgentDelay=lcUpsControlRebootAgentDelay, lcUpsUtilPowerFailedTrap=lcUpsUtilPowerFailedTrap, lcUpsInputFrequency=lcUpsInputFrequency, lcUpsOutput=lcUpsOutput, lcUpsControlOutputOnTrapDelay=lcUpsControlOutputOnTrapDelay, lcUpsIdentManufactureDate=lcUpsIdentManufactureDate, lcUpsAlarms=lcUpsAlarms, lcUpsAlarmInputFreqError=lcUpsAlarmInputFreqError, lcUpsLowBatteryShutdownTrap=lcUpsLowBatteryShutdownTrap, lcUpsControlUnixShutdownDelay=lcUpsControlUnixShutdownDelay, lcUpsOverloadShutdownTrap=lcUpsOverloadShutdownTrap, lcUpsBypassEntry=lcUpsBypassEntry, lcUpsAlarm=lcUpsAlarm, lcUpsIdentFirmwareVersion=lcUpsIdentFirmwareVersion, lcUpsOutputLine=lcUpsOutputLine, luPrivate=luPrivate, lcUpsBatTimeRemaining=lcUpsBatTimeRemaining, lcUpsOutputFrequency=lcUpsOutputFrequency, lcUpsAlarmId=lcUpsAlarmId, lcUpsOutputOffTrap=lcUpsOutputOffTrap, lcUpsBatVoltage=lcUpsBatVoltage, lcUpsBadBypassPower=lcUpsBadBypassPower)

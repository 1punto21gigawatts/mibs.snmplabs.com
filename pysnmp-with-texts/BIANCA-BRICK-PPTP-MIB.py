#
# PySNMP MIB module BIANCA-BRICK-PPTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-PPTP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, IpAddress, TimeTicks, Integer32, Unsigned32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ModuleIdentity, Counter32, NotificationType, ObjectIdentity, Bits, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "IpAddress", "TimeTicks", "Integer32", "Unsigned32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ModuleIdentity", "Counter32", "NotificationType", "ObjectIdentity", "Bits", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
vpn = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 23))
pptpProfileTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 1), )
if mibBuilder.loadTexts: pptpProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileTable.setDescription("The pptpProfileTable contains parameters for the Point-to-Point Tunneling Protocol (PPTP) according RFC 2637. Entries are removed by setting an entry's pptpProfileKeepalive object to 'delete'.")
pptpProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1), ).setIndexNames((0, "BIANCA-BRICK-PPTP-MIB", "pptpProfileId"))
if mibBuilder.loadTexts: pptpProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileEntry.setDescription('')
pptpProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileId.setDescription('The profile ID of the PPTP profile.')
pptpProfileKeepalive = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpProfileKeepalive.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileKeepalive.setDescription('When set to on(1), PPTP echo requests as described in RFC 2637 are sent in regular intervals during the connection. If set to off(2), no PPTP echo requests will be performed, delete(3) determines the entry is marked for discard.')
pptpProfileMaxRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpProfileMaxRequests.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileMaxRequests.setDescription('The maximum number of outstanding PPTP echo replies, until the PPTP control connection is droped and all associated calls are terminated.')
pptpProfileMaxBlockTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpProfileMaxBlockTime.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileMaxBlockTime.setDescription('Maximum time (in msec) the GRE Send Window is blocked. If the GRE Send Window is full, no packets can be forwarded and the Maximum Time is passed, the GRE Send Window is resetted to prevent unsolvable situations.')
pptpProfileMaxAckTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2000, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpProfileMaxAckTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileMaxAckTimeout.setDescription('Maximum value the adaptive Acknowledgment Timeout (in msec) can reach while it is calculated. According to RFC 2637.')
pptpProfileReassemblyTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpProfileReassemblyTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: pptpProfileReassemblyTimeout.setDescription('Maximum time (in msec) for rearranging out-of-sequence packets. After this time outstanding packets will be supposed missing.')
pptpCtlConnTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 2), )
if mibBuilder.loadTexts: pptpCtlConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnTable.setDescription('The pptpCtlConnTable displays all currently active PPTP dontrol connections Only the system can add or remove entries to this table. Creating entries: Entries are added when an outgoing or incoming TCP connection (port 1723) is established. Deleting entries: Entries are removed once the respective PPTP control connection is disconnected.')
pptpCtlConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1), ).setIndexNames((0, "BIANCA-BRICK-PPTP-MIB", "pptpCtlConnOriginator"))
if mibBuilder.loadTexts: pptpCtlConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnEntry.setDescription('')
pptpCtlConnOriginator = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnOriginator.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnOriginator.setDescription('The originator of the PPTP control connection.')
pptpCtlConnAge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnAge.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnAge.setDescription('The age of the PPTP control connection. The format is in hh:mm:ss.00.')
pptpCtlConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 1), ("wait-ctl-reply", 2), ("established", 3), ("wait-stop-reply", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCtlConnState.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnState.setDescription('The state of the PPTP control connection according RFC 2637.')
pptpCtlConnRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnRemoteIpAddress.setDescription('The IP address of the remote PPTP tunnel endpoint.')
pptpCtlConnLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnLocalIpAddress.setDescription('The IP address of the local PPTP tunnel endpoint.')
pptpCtlConnVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnVersion.setDescription('This variable contains the negotiated PPTP version.')
pptpCtlConnHost = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnHost.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnHost.setDescription('DNS name of the issuing PAC or PNS.')
pptpCtlConnVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnVendor.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnVendor.setDescription('Vendor specific string describing the type of PAC or PNS being used on remote side.')
pptpCtlConnFirmRev = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCtlConnFirmRev.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCtlConnFirmRev.setDescription('This variable contains the firmware revision number of the issuing PAC or PNS.')
pptpCallTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 3), )
if mibBuilder.loadTexts: pptpCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallTable.setDescription('The pptpCallTable displays all currently active PPTP calls (incoming and outgoing). Only the system can add or remove entries to this table. Creating entries: Entries are added when an outgoing call is made or when an incoming call is connected. Deleting entries: Entries are removed once the respective call is disconnected.')
pptpCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1), ).setIndexNames((0, "BIANCA-BRICK-PPTP-MIB", "pptpCallType"))
if mibBuilder.loadTexts: pptpCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallEntry.setDescription('')
pptpCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pac", 1), ("pns", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallType.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallType.setDescription('The PPTP call type.')
pptpCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallDirection.setDescription('Direction of the PPTP call, incoming(1) or outgoing(2).')
pptpCallAge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallAge.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallAge.setDescription('The age of the call. For outgoing calls, the time since the call began, or for incoming calls, the time since the call was received. The format is in hh:mm:ss.00.')
pptpCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("wait-cs-ans", 2), ("wait-reply", 3), ("wait-connect", 4), ("established", 5), ("wait-disc", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCallState.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallState.setDescription('The state of the PPTP call according RFC 2637.')
pptpCallRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallRemoteIpAddress.setDescription('The called (for outgoing calls) or calling IP address (for incoming calls).')
pptpCallLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallLocalIpAddress.setDescription('The calling (for outgoing calls) or called IP address (for incoming calls).')
pptpCallReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallReceivedPackets.setDescription('Count of received valid GRE-encapsulated packets.')
pptpCallReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallReceivedOctets.setDescription('Count of received valid Octets.')
pptpCallReceivedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallReceivedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallReceivedErrors.setDescription('Count of received invalid GRE-encapsulated packets.')
pptpCallTransmitPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallTransmitPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallTransmitPackets.setDescription('Count of transmitted GRE-encapsulated packets.')
pptpCallTransmitOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallTransmitOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallTransmitOctets.setDescription('Count of transmitted Octets.')
pptpCallTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallTransmitErrors.setDescription('Count of transmit errors.')
pptpCallInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 3, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCallInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCallInfo.setDescription('Additional information to identify the PPTP call')
pptpCreditsTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 23, 4), )
if mibBuilder.loadTexts: pptpCreditsTable.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTable.setDescription('The pptpCreditsTable contains informations about current used resources and maximum allowed resources for each during a specified interval subsystem. Creating entries: Entries are added by the system during startup. Deleting entries: Is not possible.')
pptpCreditsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1), ).setIndexNames((0, "BIANCA-BRICK-PPTP-MIB", "pptpCreditsSubsysNumber"))
if mibBuilder.loadTexts: pptpCreditsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsEntry.setDescription('')
pptpCreditsSubsysNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("any", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsSubsysNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsSubsysNumber.setDescription('Type of Subsystem.')
pptpCreditsSurveillance = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsSurveillance.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsSurveillance.setDescription('Surveillance on or off.')
pptpCreditsMeasuretime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMeasuretime.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMeasuretime.setDescription('Time of one observation interval in seconds.')
pptpCreditsMaxInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxInCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxInCon.setDescription('Maximum number of allowed incoming connections during the observation interval. -1 disables this limit.')
pptpCreditsMaxOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxOutCon.setDescription('Maximum number of allowed outgoing connections during the observation interval. -1 disables this limit.')
pptpCreditsMaxInDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxInDuration.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxInDuration.setDescription('Maximum connect time for incoming connections in seconds during the observation interval. -1 disables this limit.')
pptpCreditsMaxOutDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxOutDuration.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxOutDuration.setDescription('Maximum connect time for outgoing connections in seconds during the observation interval. -1 disables this limit')
pptpCreditsTimeleft = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsTimeleft.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTimeleft.setDescription('Time in seconds left in current interval. Writing to Timeleft will restart the observation interval.')
pptpCreditsCurrentInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsCurrentInCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsCurrentInCon.setDescription('Current number of incoming connections.')
pptpCreditsCurrentOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsCurrentOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsCurrentOutCon.setDescription('Current number of outgoing connections.')
pptpCreditsTotalInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsTotalInCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTotalInCon.setDescription('Total count of incoming connections during the observation interval.')
pptpCreditsTotalOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsTotalOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTotalOutCon.setDescription('Total count of outgoing connections during the observation interval.')
pptpCreditsTotalMaxCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsTotalMaxCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTotalMaxCon.setDescription('Maximum number of simultaniously established connections during the observation interval.')
pptpCreditsTotalInDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsTotalInDuration.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTotalInDuration.setDescription('Total connect time of incoming connections during the observation interval.')
pptpCreditsTotalOutDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pptpCreditsTotalOutDuration.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsTotalOutDuration.setDescription('Total connect time of outgoing connections during the observation interval.')
pptpCreditsMaxCurrentInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxCurrentInCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxCurrentInCon.setDescription('Maximum number of currently allowed incoming connections. -1 disables this limit.')
pptpCreditsMaxCurrentOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxCurrentOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxCurrentOutCon.setDescription('Maximum number of currently allowed outgoing connections. -1 disables this limit.')
pptpCreditsMaxCurrentCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 23, 4, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pptpCreditsMaxCurrentCon.setStatus('mandatory')
if mibBuilder.loadTexts: pptpCreditsMaxCurrentCon.setDescription('Maximum number of currently allowed connections in both directions. -1 disables this limit.')
mibBuilder.exportSymbols("BIANCA-BRICK-PPTP-MIB", pptpCtlConnRemoteIpAddress=pptpCtlConnRemoteIpAddress, pptpCtlConnState=pptpCtlConnState, pptpProfileEntry=pptpProfileEntry, vpn=vpn, pptpCreditsEntry=pptpCreditsEntry, pptpCallType=pptpCallType, pptpCtlConnVersion=pptpCtlConnVersion, enterprises=enterprises, pptpCallLocalIpAddress=pptpCallLocalIpAddress, pptpCtlConnAge=pptpCtlConnAge, pptpProfileMaxRequests=pptpProfileMaxRequests, dod=dod, bintec=bintec, pptpProfileMaxBlockTime=pptpProfileMaxBlockTime, pptpProfileId=pptpProfileId, pptpCtlConnVendor=pptpCtlConnVendor, pptpCreditsTotalInCon=pptpCreditsTotalInCon, private=private, pptpCtlConnLocalIpAddress=pptpCtlConnLocalIpAddress, pptpCallAge=pptpCallAge, pptpCallReceivedOctets=pptpCallReceivedOctets, pptpCreditsMaxCurrentCon=pptpCreditsMaxCurrentCon, pptpCallRemoteIpAddress=pptpCallRemoteIpAddress, pptpCreditsMaxInDuration=pptpCreditsMaxInDuration, internet=internet, pptpCallState=pptpCallState, pptpCallReceivedPackets=pptpCallReceivedPackets, pptpCallReceivedErrors=pptpCallReceivedErrors, pptpCreditsMaxCurrentInCon=pptpCreditsMaxCurrentInCon, pptpCreditsTotalMaxCon=pptpCreditsTotalMaxCon, pptpProfileKeepalive=pptpProfileKeepalive, pptpCallTransmitOctets=pptpCallTransmitOctets, pptpCreditsTable=pptpCreditsTable, pptpCreditsMaxOutCon=pptpCreditsMaxOutCon, pptpCreditsTotalOutCon=pptpCreditsTotalOutCon, pptpCallInfo=pptpCallInfo, pptpCreditsTotalInDuration=pptpCreditsTotalInDuration, pptpCtlConnFirmRev=pptpCtlConnFirmRev, org=org, pptpCreditsMaxOutDuration=pptpCreditsMaxOutDuration, pptpCreditsTimeleft=pptpCreditsTimeleft, pptpProfileReassemblyTimeout=pptpProfileReassemblyTimeout, pptpCtlConnOriginator=pptpCtlConnOriginator, pptpProfileTable=pptpProfileTable, pptpProfileMaxAckTimeout=pptpProfileMaxAckTimeout, pptpCallTable=pptpCallTable, pptpCreditsMeasuretime=pptpCreditsMeasuretime, pptpCtlConnTable=pptpCtlConnTable, pptpCreditsMaxCurrentOutCon=pptpCreditsMaxCurrentOutCon, bibo=bibo, pptpCallEntry=pptpCallEntry, pptpCallTransmitErrors=pptpCallTransmitErrors, pptpCreditsMaxInCon=pptpCreditsMaxInCon, pptpCreditsCurrentOutCon=pptpCreditsCurrentOutCon, pptpCreditsSubsysNumber=pptpCreditsSubsysNumber, pptpCallTransmitPackets=pptpCallTransmitPackets, pptpCtlConnEntry=pptpCtlConnEntry, pptpCallDirection=pptpCallDirection, pptpCreditsSurveillance=pptpCreditsSurveillance, pptpCreditsCurrentInCon=pptpCreditsCurrentInCon, pptpCtlConnHost=pptpCtlConnHost, pptpCreditsTotalOutDuration=pptpCreditsTotalOutDuration)

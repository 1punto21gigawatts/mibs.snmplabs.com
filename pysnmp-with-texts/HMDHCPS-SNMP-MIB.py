#
# PySNMP MIB module HMDHCPS-SNMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HMDHCPS-SNMP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
hmConfiguration, = mibBuilder.importSymbols("HMPRIV-MGMT-SNMP-MIB", "hmConfiguration")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, ModuleIdentity, TimeTicks, NotificationType, Unsigned32, iso, Integer32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, MibIdentifier, ObjectIdentity, Counter64, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "ModuleIdentity", "TimeTicks", "NotificationType", "Unsigned32", "iso", "Integer32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "MibIdentifier", "ObjectIdentity", "Counter64", "Bits")
MacAddress, DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "DisplayString", "TextualConvention", "RowStatus")
hmDhcps = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 14, 16))
hmDhcps.setRevisions(('2013-04-18 12:00', '2011-12-20 12:00', '2007-10-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmDhcps.setRevisionsDescriptions(('Added ICMP echo probe and pool vendor option.', 'Added pools per VLAN.', 'First release in SMIv2',))
if mibBuilder.loadTexts: hmDhcps.setLastUpdated('201304181200Z')
if mibBuilder.loadTexts: hmDhcps.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmDhcps.setContactInfo('Customer Support Postal: Hirschmann Automation and Control GmbH Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Tel: +49 7127 14 1981 Web: http://www.hicomcenter.com/ E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmDhcps.setDescription('The Hirschmann Private DHCP MIB definitions for Platform devices.')
hmDHCPServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1))
hmDHCPServerConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1))
hmDHCPServerLeaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2))
hmDHCPServerInterfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3))
hmDHCPServerCounterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4))
hmDHCPServerMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerMode.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerMode.setDescription('Enable or disable DHCP server global.')
hmDHCPServerMaxPoolEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerMaxPoolEntries.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerMaxPoolEntries.setDescription('Maximum possible entries in hmDHCPServerPoolTable.')
hmDHCPServerMaxLeaseEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerMaxLeaseEntries.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerMaxLeaseEntries.setDescription('Maximum possible entries in hmDHCPServerLeaseTable.')
hmDHCPServerAddrProbe = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerAddrProbe.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerAddrProbe.setDescription('If set to enable the DHCP server probes the allocated address with an ICMP Echo Request before offering to the client.')
hmDHCPServerPoolTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5), )
if mibBuilder.loadTexts: hmDHCPServerPoolTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolTable.setDescription('A table containing the DHCP server pools.')
hmDHCPServerPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerPoolIndex"))
if mibBuilder.loadTexts: hmDHCPServerPoolEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolEntry.setDescription('A logical row in the hmDHCPServerPoolTable.')
hmDHCPServerPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerPoolIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolIndex.setDescription('The index of hmDHCPServerPoolTable.')
hmDHCPServerPoolStartIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerPoolStartIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolStartIpAddress.setDescription('The IPv4 address of the first address in the range. The value of hmDHCPServerPoolStartIpAddress MUST be less than or equal to the value of hmDHCPServerPoolEndIpAddress.')
hmDHCPServerPoolEndIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolEndIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolEndIpAddress.setDescription('The IPv4 address of the last address in the range. The value of hmDHCPServerPoolEndIpAddress MUST be greater than or equal to the value of hmDHCPServerPoolStartIpAddress.')
hmDHCPServerPoolLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 4), Unsigned32().clone(86400)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolLeaseTime.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolLeaseTime.setDescription("The pools lease time in number of seconds. A value of 4294967295 SHOULD be used for leases that have a lease time which is 'infinite' and for BOOTP leases.")
hmDHCPServerPoolFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 5), Bits().clone(namedValues=NamedValues(("interface", 0), ("mac", 1), ("gateway", 2), ("clientid", 3), ("remoteid", 4), ("circuitid", 5), ("dynamic", 6), ("vlanid", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolFlags.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolFlags.setDescription('This object shows the parameters that are used to lease the IP Address.')
hmDHCPServerPoolIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolIfIndex.setDescription('The index of the interface.')
hmDHCPServerPoolMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 7), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolMacAddress.setDescription('The MAC Address of the entry that is used to lease the IP Address.')
hmDHCPServerPoolGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolGateway.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolGateway.setDescription('The IPv4 address of the Gatewayinterface that is used to lease the IP Address.')
hmDHCPServerPoolClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 9), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolClientId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolClientId.setDescription('The Client Identifier of the entry that is used to lease the IP Address.')
hmDHCPServerPoolRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 10), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolRemoteId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolRemoteId.setDescription('The Remote Identifier of the entry that is used to lease the IP Address. The Remote Identifier must be send in Option 82 as defined in RFC 3046.')
hmDHCPServerPoolCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 11), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolCircuitId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolCircuitId.setDescription('The Cicuit Identifier of the entry that is used to lease the IP Address. The Circuit Identifier must be send in Option 82 as defined in RFC 3046.')
hmDHCPServerPoolHirschmannClient = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolHirschmannClient.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolHirschmannClient.setDescription('Enable or disable Hirschmann Multicast.')
hmDHCPServerPoolVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolVlanId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolVlanId.setDescription('The Vlan ID of the entry that is used to lease the IP Address. A value of -1 corresponds to management vlan (the default), any other value (1-4042) represents a specific VLAN')
hmDHCPServerPoolOptionConfFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionConfFileName.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionConfFileName.setDescription('Full specified name of the configuration file e.g. tftp://192.9.200.1/cfg/config1.sav. An empty string zeros the SNAME and the FILE field in the DHCP header.')
hmDHCPServerPoolOptionGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 31), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionGateway.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionGateway.setDescription('The IPv4 address of the Gateway. A value of 0 disables the attachment of the option field in the DHCP message.')
hmDHCPServerPoolOptionNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 32), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionNetmask.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionNetmask.setDescription('The subnet mask. A value of 0 disables the attachment of the option field in the DHCP message.')
hmDHCPServerPoolOptionWINS = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 33), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionWINS.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionWINS.setDescription('The IPv4 address of the WINS Server. A value of 0 disables the attachment of the option field in the DHCP message.')
hmDHCPServerPoolOptionDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 34), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionDNS.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionDNS.setDescription('The IPv4 address of the DNS Server. A value of 0 disables the attachment of the option field in the DHCP message.')
hmDHCPServerPoolOptionHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 35), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionHostname.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionHostname.setDescription('The name of the client (Option 12). An empty string disables the attachment of the option field in the DHCP message.')
hmDHCPServerPoolOptionVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 36), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionVendor.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionVendor.setDescription('Vendor Specific Information (Option 43) as hex string.')
hmDHCPServerPoolErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 99), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerPoolErrorStatus.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolErrorStatus.setDescription('The error Code by create a new Pool.')
hmDHCPServerPoolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 100), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolRowStatus.setDescription('This object indicates the status of this entry.')
hmDHCPServerLeaseTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1), )
if mibBuilder.loadTexts: hmDHCPServerLeaseTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseTable.setDescription('A table containing the DHCP server leases.')
hmDHCPServerLeaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerLeasePoolIndex"), (0, "HMDHCPS-SNMP-MIB", "hmDHCPServerLeaseIpAddress"))
if mibBuilder.loadTexts: hmDHCPServerLeaseEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseEntry.setDescription('A logical row in the hmDHCPServerLeaseTable.')
hmDHCPServerLeasePoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeasePoolIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeasePoolIndex.setDescription('The index of the hmDHCPServerPoolTable above.')
hmDHCPServerLeaseIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseIpAddress.setDescription('This is an IP address from the pool with index hmDHCPServerLeasePoolIndex.')
hmDHCPServerLeaseState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bootp", 1), ("offering", 2), ("requesting", 3), ("bound", 4), ("renewing", 5), ("rebinding", 6), ("declined", 7), ("released", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseState.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseState.setDescription('The state of the lease.')
hmDHCPServerLeaseTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseTimeRemaining.setDescription('The remaining time of the lease configured in hmDHCPServerPoolLeaseTime.')
hmDHCPServerLeaseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseIfIndex.setDescription('The interface index where the lease is currently active.')
hmDHCPServerLeaseClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseClientMacAddress.setDescription('The MAC Address of the entry that has leased the IP Address.')
hmDHCPServerLeaseGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseGateway.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseGateway.setDescription('The IPv4 address of the Gatewayinterface that was used to lease the IP Address.')
hmDHCPServerLeaseClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseClientId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseClientId.setDescription('The Client Identifier of the entry that was used to lease the IP Address.')
hmDHCPServerLeaseRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseRemoteId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseRemoteId.setDescription('The Remote Identifier of the entry that was used to lease the IP Address.')
hmDHCPServerLeaseCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseCircuitId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseCircuitId.setDescription('The Cicuit Identifier of the entry that was used to lease the IP Address.')
hmDHCPServerLeaseStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseStartTime.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseStartTime.setDescription('Lease start Time.')
hmDHCPServerLeaseAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("release", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerLeaseAction.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseAction.setDescription('Manually release this ip address for new assignment.')
hmDHCPServerLeaseVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseVlanId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseVlanId.setDescription('The Vlan ID of the entry that is used to lease the IP Address. A value of -1 corresponds to management vlan (the default), any other value (1-4042) represents a specific VLAN')
hmDHCPServerIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1), )
if mibBuilder.loadTexts: hmDHCPServerIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigTable.setDescription('A table containing current configuration information for each interface.')
hmDHCPServerIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerIfConfigIndex"))
if mibBuilder.loadTexts: hmDHCPServerIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigEntry.setDescription('A logical row in the hmDHCPServerIfConfigTable.')
hmDHCPServerIfConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerIfConfigIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigIndex.setDescription('The index of the interface.')
hmDHCPServerIfConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerIfConfigMode.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigMode.setDescription('Enable or disable DHCP server on this interface.')
hmDHCPServerCounterIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2), )
if mibBuilder.loadTexts: hmDHCPServerCounterIfTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterIfTable.setDescription('A table containing current configuration information for each interface.')
hmDHCPServerCounterIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerCounterIfIndex"))
if mibBuilder.loadTexts: hmDHCPServerCounterIfEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterIfEntry.setDescription('A logical row in the hmDHCPServerCounterIfTable.')
hmDHCPServerCounterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterIfIndex.setDescription('The index of the interface.')
hmDHCPServerCounterBootpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpRequests.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpRequests.setDescription('The number of packets received that contain a Message Type of 1 (BOOTREQUEST) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
hmDHCPServerCounterBootpInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpInvalids.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpInvalids.setDescription('The number of packets received that do not contain a Message Type of 1 (BOOTREQUEST) in the first octet or are not valid BOOTP packets (e.g., too short, invalid field in packet header).')
hmDHCPServerCounterBootpReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpReplies.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpReplies.setDescription('The number of packets sent that contain a Message Type of 2 (BOOTREPLY) in the first octet and do not contain option number 53 (DHCP Message Type) in the options.')
hmDHCPServerCounterBootpDroppedUnknownClients = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedUnknownClients.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedUnknownClients.setDescription('The number of BOOTP packets dropped due to the server not recognizing or not providing service to the hardware address received in the incoming packet.')
hmDHCPServerCounterBootpDroppedNotServingSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedNotServingSubnet.setDescription('The number of BOOTP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
hmDHCPServerCounterDhcpv4Discovers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Discovers.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Discovers.setDescription('The number of DHCPDISCOVER (option 53 with value 1) packets received.')
hmDHCPServerCounterDhcpv4Offers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Offers.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Offers.setDescription('The number of DHCPOFFER (option 53 with value 2) packets sent.')
hmDHCPServerCounterDhcpv4Requests = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Requests.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Requests.setDescription('The number of DHCPREQUEST (option 53 with value 3) packets received.')
hmDHCPServerCounterDhcpv4Declines = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Declines.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Declines.setDescription('The number of DHCPDECLINE (option 53 with value 4) packets received.')
hmDHCPServerCounterDhcpv4Acks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Acks.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Acks.setDescription('The number of DHCPACK (option 53 with value 5) packets sent.')
hmDHCPServerCounterDhcpv4Naks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Naks.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Naks.setDescription('The number of DHCPNACK (option 53 with value 6) packets sent.')
hmDHCPServerCounterDhcpv4Releases = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Releases.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Releases.setDescription('The number of DHCPRELEASE (option 53 with value 7) packets received.')
hmDHCPServerCounterDhcpv4Informs = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Informs.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Informs.setDescription('The number of DHCPINFORM (option 53 with value 8) packets received.')
hmDHCPServerCounterDhcpv4ForcedRenews = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4ForcedRenews.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4ForcedRenews.setDescription('The number of DHCPFORCERENEW (option 53 with value 9) packets sent.')
hmDHCPServerCounterDhcpv4Invalids = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Invalids.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Invalids.setDescription('The number of DHCP packets received whose DHCP message type (i.e., option number 53) is not understood or handled by the server.')
hmDHCPServerCounterDhcpv4DroppedUnknownClient = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedUnknownClient.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedUnknownClient.setDescription('The number of DHCP packets dropped due to the server not recognizing or not providing service to the client-id and/or hardware address received in the incoming packet.')
hmDHCPServerCounterDhcpv4DroppedNotServingSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedNotServingSubnet.setDescription('The number of DHCP packets dropped due to the server not being configured or not otherwise able to serve addresses on the subnet from which this message was received.')
hmDHCPServerCounterMiscOtherDhcpServer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterMiscOtherDhcpServer.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterMiscOtherDhcpServer.setDescription('The number of BOOTP and DHCP packets from another DHCP server seen on this interface.')
mibBuilder.exportSymbols("HMDHCPS-SNMP-MIB", hmDHCPServerIfConfigTable=hmDHCPServerIfConfigTable, hmDHCPServerPoolOptionGateway=hmDHCPServerPoolOptionGateway, hmDHCPServerIfConfigMode=hmDHCPServerIfConfigMode, hmDHCPServerCounterDhcpv4Naks=hmDHCPServerCounterDhcpv4Naks, hmDHCPServerCounterDhcpv4Releases=hmDHCPServerCounterDhcpv4Releases, hmDHCPServerLeaseTimeRemaining=hmDHCPServerLeaseTimeRemaining, hmDHCPServerConfigGroup=hmDHCPServerConfigGroup, hmDHCPServerPoolRemoteId=hmDHCPServerPoolRemoteId, hmDHCPServerLeaseCircuitId=hmDHCPServerLeaseCircuitId, hmDHCPServerLeaseTable=hmDHCPServerLeaseTable, hmDHCPServerCounterBootpRequests=hmDHCPServerCounterBootpRequests, hmDHCPServerCounterGroup=hmDHCPServerCounterGroup, hmDHCPServerCounterDhcpv4DroppedNotServingSubnet=hmDHCPServerCounterDhcpv4DroppedNotServingSubnet, hmDHCPServerIfConfigEntry=hmDHCPServerIfConfigEntry, hmDHCPServerCounterBootpReplies=hmDHCPServerCounterBootpReplies, hmDHCPServerAddrProbe=hmDHCPServerAddrProbe, hmDHCPServerLeaseGroup=hmDHCPServerLeaseGroup, hmDHCPServerPoolErrorStatus=hmDHCPServerPoolErrorStatus, hmDHCPServerCounterIfEntry=hmDHCPServerCounterIfEntry, hmDHCPServerCounterDhcpv4Invalids=hmDHCPServerCounterDhcpv4Invalids, hmDHCPServerPoolOptionDNS=hmDHCPServerPoolOptionDNS, hmDHCPServerCounterDhcpv4Declines=hmDHCPServerCounterDhcpv4Declines, hmDHCPServerPoolOptionNetmask=hmDHCPServerPoolOptionNetmask, hmDHCPServerLeaseClientId=hmDHCPServerLeaseClientId, hmDHCPServerPoolHirschmannClient=hmDHCPServerPoolHirschmannClient, hmDHCPServerCounterIfTable=hmDHCPServerCounterIfTable, hmDHCPServerPoolVlanId=hmDHCPServerPoolVlanId, hmDHCPServerCounterDhcpv4Acks=hmDHCPServerCounterDhcpv4Acks, hmDHCPServerLeaseClientMacAddress=hmDHCPServerLeaseClientMacAddress, hmDHCPServerLeaseAction=hmDHCPServerLeaseAction, hmDHCPServerMaxLeaseEntries=hmDHCPServerMaxLeaseEntries, hmDHCPServerPoolRowStatus=hmDHCPServerPoolRowStatus, hmDHCPServerInterfaceGroup=hmDHCPServerInterfaceGroup, hmDHCPServerPoolOptionConfFileName=hmDHCPServerPoolOptionConfFileName, hmDHCPServerCounterIfIndex=hmDHCPServerCounterIfIndex, hmDHCPServerGroup=hmDHCPServerGroup, hmDHCPServerLeaseIfIndex=hmDHCPServerLeaseIfIndex, hmDHCPServerLeaseStartTime=hmDHCPServerLeaseStartTime, hmDHCPServerCounterBootpDroppedNotServingSubnet=hmDHCPServerCounterBootpDroppedNotServingSubnet, hmDHCPServerCounterDhcpv4Discovers=hmDHCPServerCounterDhcpv4Discovers, hmDHCPServerPoolEndIpAddress=hmDHCPServerPoolEndIpAddress, hmDHCPServerMode=hmDHCPServerMode, hmDHCPServerMaxPoolEntries=hmDHCPServerMaxPoolEntries, hmDHCPServerPoolMacAddress=hmDHCPServerPoolMacAddress, hmDHCPServerLeaseState=hmDHCPServerLeaseState, hmDHCPServerLeaseGateway=hmDHCPServerLeaseGateway, hmDHCPServerPoolIndex=hmDHCPServerPoolIndex, hmDHCPServerCounterBootpInvalids=hmDHCPServerCounterBootpInvalids, hmDHCPServerCounterDhcpv4ForcedRenews=hmDHCPServerCounterDhcpv4ForcedRenews, hmDHCPServerPoolOptionWINS=hmDHCPServerPoolOptionWINS, PYSNMP_MODULE_ID=hmDhcps, hmDHCPServerCounterDhcpv4Offers=hmDHCPServerCounterDhcpv4Offers, hmDHCPServerLeaseEntry=hmDHCPServerLeaseEntry, hmDHCPServerCounterDhcpv4Requests=hmDHCPServerCounterDhcpv4Requests, hmDHCPServerCounterBootpDroppedUnknownClients=hmDHCPServerCounterBootpDroppedUnknownClients, hmDHCPServerPoolCircuitId=hmDHCPServerPoolCircuitId, hmDHCPServerCounterMiscOtherDhcpServer=hmDHCPServerCounterMiscOtherDhcpServer, hmDHCPServerPoolOptionHostname=hmDHCPServerPoolOptionHostname, hmDhcps=hmDhcps, hmDHCPServerPoolOptionVendor=hmDHCPServerPoolOptionVendor, hmDHCPServerPoolIfIndex=hmDHCPServerPoolIfIndex, hmDHCPServerIfConfigIndex=hmDHCPServerIfConfigIndex, hmDHCPServerPoolTable=hmDHCPServerPoolTable, hmDHCPServerLeaseRemoteId=hmDHCPServerLeaseRemoteId, hmDHCPServerPoolFlags=hmDHCPServerPoolFlags, hmDHCPServerCounterDhcpv4Informs=hmDHCPServerCounterDhcpv4Informs, hmDHCPServerLeaseIpAddress=hmDHCPServerLeaseIpAddress, hmDHCPServerPoolStartIpAddress=hmDHCPServerPoolStartIpAddress, hmDHCPServerLeasePoolIndex=hmDHCPServerLeasePoolIndex, hmDHCPServerPoolGateway=hmDHCPServerPoolGateway, hmDHCPServerCounterDhcpv4DroppedUnknownClient=hmDHCPServerCounterDhcpv4DroppedUnknownClient, hmDHCPServerLeaseVlanId=hmDHCPServerLeaseVlanId, hmDHCPServerPoolClientId=hmDHCPServerPoolClientId, hmDHCPServerPoolEntry=hmDHCPServerPoolEntry, hmDHCPServerPoolLeaseTime=hmDHCPServerPoolLeaseTime)

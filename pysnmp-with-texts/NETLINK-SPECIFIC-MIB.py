#
# PySNMP MIB module NETLINK-SPECIFIC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NETLINK-SPECIFIC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:19:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn, mgmt, Gauge32, IpAddress, Counter32, iso, TimeTicks, enterprises, MibIdentifier, Counter64, ObjectIdentity, Unsigned32, Integer32, ModuleIdentity, NotificationType, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mgmt", "Gauge32", "IpAddress", "Counter32", "iso", "TimeTicks", "enterprises", "MibIdentifier", "Counter64", "ObjectIdentity", "Unsigned32", "Integer32", "ModuleIdentity", "NotificationType", "Bits")
PhysAddress, TextualConvention, RowStatus, DisplayString, MacAddress, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "RowStatus", "DisplayString", "MacAddress", "TimeInterval")
class NlSubscriberAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 15)

snaDLC = MibIdentifier((1, 3, 6, 1, 2, 1, 41))
sdlc = MibIdentifier((1, 3, 6, 1, 2, 1, 41, 1))
sdlcLSGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 41, 1, 2))
sdlcLSAdminTable = MibIdentifier((1, 3, 6, 1, 2, 1, 41, 1, 2, 1))
sdlcLSAdminEntry = MibIdentifier((1, 3, 6, 1, 2, 1, 41, 1, 2, 1, 1))
sdlcLSAddress = MibScalar((1, 3, 6, 1, 2, 1, 41, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdlcLSAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sdlcLSAddress.setDescription('This value is the poll address of the secondary link station for this SDLC link. It uniquely identifies the SDLC link station within a single SDLC port.')
netlink = MibIdentifier((1, 3, 6, 1, 4, 1, 173))
network = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 6))
netstat = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 6, 1))
nsMaxNeigh = MibScalar((1, 3, 6, 1, 4, 1, 173, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsMaxNeigh.setStatus('mandatory')
if mibBuilder.loadTexts: nsMaxNeigh.setDescription('Maximum number of neighbor nodes. This value is currently always 64 for FRX8000 and 20 for an N7400 or 7500. A neighbor is the closest node in a path from the local node.')
nsThisNode = MibScalar((1, 3, 6, 1, 4, 1, 173, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsThisNode.setStatus('mandatory')
if mibBuilder.loadTexts: nsThisNode.setDescription('This nodes number. (1-250) ')
nsNodTable = MibTable((1, 3, 6, 1, 4, 1, 173, 6, 1, 3), )
if mibBuilder.loadTexts: nsNodTable.setStatus('mandatory')
if mibBuilder.loadTexts: nsNodTable.setDescription('A table showing all nodes known to this node along with status and neighbor information.')
nsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 6, 1, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nsNodNum"))
if mibBuilder.loadTexts: nsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nsEntry.setDescription('Each entry of the node table is indexed by node number.')
nsNodNum = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 6, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsNodNum.setStatus('mandatory')
if mibBuilder.loadTexts: nsNodNum.setDescription('The node number of the desired node. This is the index into the node table.')
nsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 6, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nsStatus.setDescription('The operational status of the node. The status is given as: 1 = Node is defined in the database; 9 = Node is operational;')
nsNumNeigh = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 6, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsNumNeigh.setStatus('mandatory')
if mibBuilder.loadTexts: nsNumNeigh.setDescription('Current number of neighbor nodes to this node.')
nsNeighTable = MibTable((1, 3, 6, 1, 4, 1, 173, 6, 1, 4), )
if mibBuilder.loadTexts: nsNeighTable.setStatus('mandatory')
if mibBuilder.loadTexts: nsNeighTable.setDescription('The neighbor table lists the status of a nodes neighbors.')
nsNeighEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 6, 1, 4, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nsNTNode"), (0, "NETLINK-SPECIFIC-MIB", "nsNTNeigh"))
if mibBuilder.loadTexts: nsNeighEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nsNeighEntry.setDescription('The table entries are indexed by the node number and the neighbors node number.')
nsNTNode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 6, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsNTNode.setStatus('mandatory')
if mibBuilder.loadTexts: nsNTNode.setDescription("The node number of the node whose neighbor's status is being sought.")
nsNTNeigh = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 6, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsNTNeigh.setStatus('mandatory')
if mibBuilder.loadTexts: nsNTNeigh.setDescription('The node number of the neighbor whose status is being sought.')
nsNTNeighStat = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 6, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notConnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsNTNeighStat.setStatus('mandatory')
if mibBuilder.loadTexts: nsNTNeighStat.setDescription('The status of the neighbor node given as: 1 = previously, but not currently, connected; 2 = Currently connected; ')
local = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7))
node = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 1))
nodeCfgTable = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 1, 1))
nodeAlmTable = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 1, 2))
nodeSNMPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 1, 3))
nodeModel = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("model1", 1), ("model2", 2), ("rackmount", 3), ("highavail", 4), ("netfrad", 5), ("frx4000", 6), ("ss1800", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeModel.setStatus('mandatory')
if mibBuilder.loadTexts: nodeModel.setDescription('Describes the unit model')
nodeTrapText = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeTrapText.setStatus('mandatory')
if mibBuilder.loadTexts: nodeTrapText.setDescription('Text of the last alarm generated')
nodeTrapAdrTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 3), )
if mibBuilder.loadTexts: nodeTrapAdrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nodeTrapAdrTable.setDescription('A table used to define the IP address of end-nodes to receive alarms generated by this node. Up to 16 addresses can be specified.')
tpAdrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "tpAdrIdx"))
if mibBuilder.loadTexts: tpAdrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tpAdrEntry.setDescription('A Trap entry containing objects relating to SNMP traps.')
tpAdrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpAdrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: tpAdrIdx.setDescription('The index into the trap configuration table')
tpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tpAddress.setDescription('The IP Address of the end-station to send alarms')
tpAdrFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableTraps", 1), ("enableTraps", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpAdrFlag.setStatus('mandatory')
if mibBuilder.loadTexts: tpAdrFlag.setDescription('Defines the state of this entry as: 0 = Do not send traps to the Address; 1 = Send traps to the Address; 2 = This Address entry is deleted from the table; ')
tpAdrSLev = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("critical", 1), ("major", 2), ("minor", 3), ("informational", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpAdrSLev.setStatus('mandatory')
if mibBuilder.loadTexts: tpAdrSLev.setDescription('Lowest severity level traps that will be sent to this Address; 1 is the highest, 4 is the lowest.')
nodeBagTable = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 1, 4))
hwcard = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 2))
rlpMaxProtos = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpMaxProtos.setStatus('mandatory')
if mibBuilder.loadTexts: rlpMaxProtos.setDescription('Maximum number of protocols allowed on each RLP. This value is currently 11 for FRX4000s, 9 for FRX6000s, and 5 for FRX7000s and FRX8000s.')
rlpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 2, 2), )
if mibBuilder.loadTexts: rlpConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlpConfigTable.setDescription('A Table to describe each RLP on the node')
rlpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "rlpIndex"))
if mibBuilder.loadTexts: rlpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlpEntry.setDescription('An RLP entry containing objects relating to RLPs.')
rlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlpIndex.setDescription('The RLP number on the node')
rlpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("installed", 1), ("configured", 2), ("load-failed", 3), ("loading", 4), ("ipl-failed", 5), ("ipl-in-progress", 6), ("failed", 7), ("operational", 8), ("power-off", 9), ("power-on", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatus.setDescription('The current state of this RLP')
rlpMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: rlpMemorySize.setDescription('The amount of memory installed on this RLP')
rlpLIC1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13))).clone(namedValues=NamedValues(("none", 1), ("rs232", 2), ("rs422", 3), ("v35", 4), ("hs-rs232", 5), ("x21", 6), ("rs449", 7), ("universal", 8), ("t1", 10), ("e1", 11), ("voice", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpLIC1Type.setStatus('mandatory')
if mibBuilder.loadTexts: rlpLIC1Type.setDescription('The Type of Line Interface card in the first position')
rlpLIC2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13))).clone(namedValues=NamedValues(("none", 1), ("rs232", 2), ("rs422", 3), ("v35", 4), ("hs-rs232", 5), ("x21", 6), ("rs449", 7), ("universal", 8), ("t1", 10), ("e1", 11), ("voice", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpLIC2Type.setStatus('mandatory')
if mibBuilder.loadTexts: rlpLIC2Type.setDescription('The Type of Line Interface card in the second position')
rlpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlpProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: rlpProtocol.setDescription('The protocols configured on this RLP. This is an OCTET STRING where each octet represents a protocol type. The size of this is the maximum number of protocols allowed on an RLP (rlpMaxProtos). The protocol types are defined as: 00 = none 01 = X.25 02 = Frame Relay 03 = Async 04 = SDLC 05 = BSC Interactive 07 = IP 08 = SNMP 09 = RIP 0A = LLC2 0B = Trunk 0C = IPX 0D = Config 0E = LLC2-R 0F = IP-R 10 = NVSP 11 = Bridge ')
rlpGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rlpGroupNumber.setDescription('The group to which this RLP belongs- always 1 if not FRX7000.')
rlpGroupResponsibility = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpGroupResponsibility.setStatus('mandatory')
if mibBuilder.loadTexts: rlpGroupResponsibility.setDescription('The responsibility of this RLP within its group, always primary if not FRX7000.')
port = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3))
portX25Group = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3, 1))
portPhyX25AdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1), )
if mibBuilder.loadTexts: portPhyX25AdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminTable.setDescription('This table contains Netlink Enterprise specific objects to manage an X25 port. Changing one of these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. Most of the objects in this read-write table have corresponding read-only objects in the portX25OperTable that return the current operating value. The operating values may be different from these configured values if a configured parameter was configured after the interface was started.')
portPhyX25AdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portPhyX25AdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminEntry.setDescription('A list of configured values for an X25 port.')
portPhyX25AdminConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10, 11))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10), ("e1", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminConnector.setDescription('Physical port interface connector type.')
portPhyX25AdminSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 2), Integer32().clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminSpeed.setDescription('This object defines the speed of the X25 port. The speed may only be set to one of a series of reasonable values, and if an attempt is made to set the speed to a value which is within the valid range but not equal to one of these values, the speed will be rounded up. If the connector type of the port is RS232, the port could be a standard port or a high speed port. If the port is a high speed RS232 port, the maximum valid speed is 256000. If the port is a standard RS232 port, the maximum valid speed is 64000 on the FRX4000/SS1840 and 19200 on all other products. It may be possible to set the speed of a standard RS232 port to a speed which is valid for a high speed RS232 port but invalid for a standard RS232 port. In this case, the port may not end up having the invalid speed. The default speed for a standard RS232 port on the FRX6000 is 19200.')
portPhyX25AdminGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminGenerateClock.setDescription('Specifies whether the port will generate the clock necessary to synchronize traffic over the link.')
portPhyX25AdminRcvClockFromDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminRcvClockFromDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminRcvClockFromDTE.setDescription('This object defines whether the receive clock will be used from the DTE.')
portPhyX25AdminDialOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("dialIn", 2), ("dialOut", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminDialOut.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminDialOut.setDescription('This flag indicates whether the port is connected to a dial modem, and whethter connections will be initiated through dial-in or dial-out calls.')
portPhyX25AdminInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminInactivityTimer.setDescription('This timer defines in minutes, the period of inactivity allowed between calls. Once the timer expires, the port is disabled untill the next call is placed, if a Dial out port, or the Disconnect Timer expires, if a Dial in port. This variable is only meaningful if the port is a Dial port.')
portPhyX25AdminDisconnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminDisconnectTimer.setDescription('This timer defines, in seconds, the length of time a dial-in port will remain disabled after expiration of the InActivity Timer.')
portPhyX25AdminSetupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminSetupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminSetupTimer.setDescription('This timer determines the length of time, in seconds, that a response must be received by the port, after entering the Linkup state. If a response is not received, the port enters a Failed state.')
portPhyX25AdminTrunkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminTrunkFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminTrunkFlag.setDescription('This flag, when set, indicates the port is associated with a network trunk group. It will be disabled/enabled if the network trunk is not operational.')
portPhyX25AdminTrunkGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminTrunkGroup.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminTrunkGroup.setDescription('This variable contains a string of 8 bytes, with each byte indicating 8 ports on an RLP that may be a part of a trunk group. Since a TurboFrad has only 1 RLP, only the first byte is valid if the node is an FRX4000. Each port is represented by a single bit within the RLP byte. The bit position represents the port number...for example, if port 2 on RLP 0 was in a trunk group, the first byte of the string would contain x04 and all other bytes would be 0.')
portPhyX25AdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 1, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPhyX25AdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25AdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portPhyX25AdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device, and which is supplied by a management station wishing to exercise an on-line update of the existing conceptual row. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portPhyX25OperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2), )
if mibBuilder.loadTexts: portPhyX25OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperTable.setDescription('This table contains Netlink Enterprise specific objects to manage an X25 port. Changing one of these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. All of the objects in this table are read-only. The operating values may be different from these configured values if a configured parameter was configured after the interface was started.')
portPhyX25OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portPhyX25OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperEntry.setDescription('A list of configured values for an X25 port.')
portPhyX25OperConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10, 11))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10), ("e1", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperConnector.setDescription('Physical port interface connector type.')
portPhyX25OperSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperSpeed.setDescription('This object defines the speed of the X25 port. The speed may only be set to one of a series of reasonable values, and if an attempt is made to set the speed to a value which is within the valid range but not equal to one of these values, the speed will be rounded up. If the connector type of the port is RS232, the port could be a standard port or a high speed port. If the port is a high speed RS232 port, the maximum valid speed is 256000. If the port is a standard RS232 port, the maximum valid speed is 64000 on the FRX4000/SS1840 and 19200 on all other products. It may be possible to set the speed of a standard RS232 port to a speed which is valid for a high speed RS232 port but invalid for a standard RS232 port. In this case, the port may not end up having the invalid speed. The default speed for a standard RS232 port on the FRX6000 is 19200.')
portPhyX25OperGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperGenerateClock.setDescription('Specifies whether the port will generate the clock necessary to synchronize traffic over the link.')
portPhyX25OperRcvClockFromDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperRcvClockFromDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperRcvClockFromDTE.setDescription('This object defines whether the receive clock will be used from the DTE.')
portPhyX25OperDialOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("dialIn", 2), ("dialOut", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperDialOut.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperDialOut.setDescription('This flag indicates whether the port is connected to a dial modem, and whethter connections will be initiated through dial-in or dial-out calls.')
portPhyX25OperInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperInactivityTimer.setDescription('This timer defines in minutes, the period of inactivity allowed between calls. Once the timer expires, the port is disabled untill the next call is placed, if a Dial out port, or the Disconnect Timer expires, if a Dial in port. This variable is only meaningful if the port is a Dial port.')
portPhyX25OperDisconnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperDisconnectTimer.setDescription('This timer defines, in seconds, the length of time a dial-in port will remain disabled after expiration of the InActivity Timer.')
portPhyX25OperSetupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperSetupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperSetupTimer.setDescription('This timer determines the length of time, in seconds, that a response must be received by the port, after entering the Linkup state. If a response is not received, the port enters a Failed state.')
portPhyX25OperTrunkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperTrunkFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperTrunkFlag.setDescription('This flag, when set, indicates the port is associated with a network trunk group. It will be disabled/enabled if the network trunk is not operational.')
portPhyX25OperTrunkGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhyX25OperTrunkGroup.setStatus('mandatory')
if mibBuilder.loadTexts: portPhyX25OperTrunkGroup.setDescription('This variable contains a string of 8 bytes, with each byte indicating a port on this RLP that may be a part of a trunk group.')
portLogicalX25AdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3), )
if mibBuilder.loadTexts: portLogicalX25AdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminTable.setDescription('This table contains Netlink Enterprise specific objects to manage an X25 Logical port. Changing one of these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. The operating values may be different from these configured values if a configured parameter was configured after the interface was started.')
portLogicalX25AdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPhyPort"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portLogicalX25AdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminEntry.setDescription('A list of configured values for an X25 logical port.')
portLogicalX25AdminFrDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLogicalX25AdminFrDlci.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminFrDlci.setDescription(' The DLCI number used to identify the entry in the table. The range is 16-991. ')
portLogicalX25AdminCxnPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLogicalX25AdminCxnPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminCxnPriority.setDescription(' This field sets the priority of the connection among others on the physical port. The range is 0 for lowest priority to 9 for the highest priority. ')
portLogicalX25AdminRfc1490 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("annexG", 1), ("rfc1490", 2))).clone('rfc1490')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLogicalX25AdminRfc1490.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminRfc1490.setDescription(' This field indicates the encapsulation method used')
portLogicalX25AdminBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLogicalX25AdminBAG.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminBAG.setDescription('Assigns this DLCI to one of sixteen groups whose parameters regulate bandwidth usage. A 0 value indicates the DLCI does not use BAGs')
portLogicalX25AdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLogicalX25AdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25AdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portLogicalX25AdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device, and which is supplied by a management station wishing to exercise an on-line update of the existing conceptual row. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portLogicalX25OperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 4), )
if mibBuilder.loadTexts: portLogicalX25OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25OperTable.setDescription('This table contains Netlink Enterprise specific objects to manage an X25 Logical port. Changing one of these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. The operating values may be different from these configured values if a configured parameter was configured after the interface was started.')
portLogicalX25OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 4, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPhyPort"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portLogicalX25OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25OperEntry.setDescription('A list of configured values for an X25 port.')
portLogicalX25OperFrDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLogicalX25OperFrDlci.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25OperFrDlci.setDescription(' The DLCI number used to identify the entry in the table. The range is 16-991. ')
portLogicalX25OperCxnPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLogicalX25OperCxnPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25OperCxnPriority.setDescription(' This field sets the priority of the connection among others on the physical port. The range is 0 for lowest priority to 9 for the highest priority. ')
portLogicalX25OperRfc1490 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("annexG", 1), ("rfc1490", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLogicalX25OperRfc1490.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25OperRfc1490.setDescription(' This field indicates the encapsulation method used')
portLogicalX25OperBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLogicalX25OperBAG.setStatus('mandatory')
if mibBuilder.loadTexts: portLogicalX25OperBAG.setDescription('Assigns this DLCI to one of sixteen groups whose parameters regulate bandwidth usage.')
portX25AdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5), )
if mibBuilder.loadTexts: portX25AdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminTable.setDescription('This table contains Netlink Enterprise specific objects to manage an X25 port. Changing one of these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. Most of the objects in this read-write table have corresponding read-only objects in the portX25OperTable that return the current operating value. The operating values may be different from these configured values if a configured parameter was configured after the interface was started.')
portX25AdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portX25AdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminEntry.setDescription('A list of configured values for an X25 port.')
portX25AdminBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminBlockedFlag.setDescription(' A flag which when set, means the port should not be enabled after a boot-up of the node. ')
portX25AdminFlowCtrlNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminFlowCtrlNeg.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminFlowCtrlNeg.setDescription('A flag which if set, permits negotiation of the flow control parameters on a per call basis. If N is selected, the default packet and window sizes will be used. If Y is selected, the packet or window size in a call packet (up to the configured Max Packet Size or Max Window Size) is used.')
portX25AdminThruptClassNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminThruptClassNeg.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminThruptClassNeg.setDescription('A flag which ,if set, permists negotiation of the throughput class for either direction of data transmission on a per call basis. If N is selected, the configured Max Throughput Class value is used. If Y, any throughput class in a call packet (up to the Max Thruput Class) is used.')
portX25AdminLocChgPrev = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminLocChgPrev.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminLocChgPrev.setDescription('If Y is selected, no calls can be charged to port. Incoming calls from the network with reverse charge specified will be rejected. Outgoing calls will insert reverse charge in the call packet if not already included.')
portX25AdminRevChgAccpt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminRevChgAccpt.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminRevChgAccpt.setDescription('A flag, if set, that authorizes transmission of incoming calls that request the reverse charge facility. If N is selected, and a call requests it, it will not be transmitted.')
portX25AdminFastSelAccpt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminFastSelAccpt.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminFastSelAccpt.setDescription('A flag, if set, that authorizes transmission of incoming calls that request the Fast Select facility.')
portX25AdminInCallBar = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminInCallBar.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminInCallBar.setDescription('An X25 facility that prevents transmission of incoming calls to the local DTE.')
portX25AdminOutCallBar = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminOutCallBar.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminOutCallBar.setDescription('An X25 facility that prevents transmission of incoming calls to the local DTE.')
portX25AdminMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminMaxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminMaxPktSize.setDescription(' The maximum data packet size that will be allowed to pass through this port.')
portX25AdminDefPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminDefPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminDefPktSize.setDescription('This is the size that will be assigned to an incoming call setup packet if the packet does not request a packet size.')
portX25AdminMaxWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminMaxWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminMaxWinSize.setDescription('This is the maximum number of unacknowledged packets per logical channel that can pass through this port.')
portX25AdminDefWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminDefWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminDefWinSize.setDescription("This size will be assigned to an incoming call setup packet if the packet doesn't request a window size.")
portX25AdminMaxThruptClass = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminMaxThruptClass.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminMaxThruptClass.setDescription('This specifies the default throughput class that will be inserted into a Call Request packet if Thruput Class negotiation is not enabled or if a thruput class is not requested in the call request.')
portX25AdminCUGPref = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminCUGPref.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminCUGPref.setDescription('This flag, if set, indicates the port belongs to at least one CUG.')
portX25AdminCUGIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminCUGIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminCUGIndex.setDescription('This number is an index into a Closed User Group table which identifies the default Closed User Group for the port.')
portX25AdminCUGIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminCUGIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminCUGIncAccess.setDescription(' This flag, when set, indicates whether this port will be allowed to receive calls from outside its CUGs.')
portX25AdminCUGOutAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portX25AdminCUGOutAccess.setStatus('mandatory')
if mibBuilder.loadTexts: portX25AdminCUGOutAccess.setDescription(' This flag, when set, indicates whether this port will be allowed to make calls outside its CUGs.')
portX25OperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6), )
if mibBuilder.loadTexts: portX25OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperTable.setDescription('This table contains Netlink Enterprise specific objects to manage an X25 port. Changing one of these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. The objects in this read-only table corresponding read-only objects in the portX25OperTable that return the current operating value. The operating values may be different from these configured values if a configured parameter was configured after the interface was started.')
portX25OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portX25OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperEntry.setDescription('A list of configured values for an X25 port.')
portX25OperBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperBlockedFlag.setDescription(' A flag which when set, means the port should not be enabled after a boot-up of the node. ')
portX25OperFlowCtrlNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperFlowCtrlNeg.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperFlowCtrlNeg.setDescription('A flag which if set, permits negotiation of the flow control parameters on a per call basis. If N is selected, the default packet and window sizes will be used. If Y is selected, the packet or window size in a call packet (up to the configured Max Packet Size or Max Window Size) is used.')
portX25OperThruptClassNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperThruptClassNeg.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperThruptClassNeg.setDescription('A flag which ,if set, permists negotiation of the throughput class for either direction of data transmission on a per call basis. If N is selected, the configured Max Throughput Class value is used. If Y, any throughput class in a call packet (up to the Max Thruput Class) is used.')
portX25OperLocChgPrev = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperLocChgPrev.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperLocChgPrev.setDescription('If Y is selected, no calls can be charged to port. Incoming calls from the network with reverse charge specified will be rejected. Outgoing calls will insert reverse charge in the call packet if not already included.')
portX25OperRevChgAccpt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperRevChgAccpt.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperRevChgAccpt.setDescription('A flag, if set, that authorizes transmission of incoming calls that request the reverse charge facility. If N is selected, and a call requests it, it will not be transmitted.')
portX25OperFastSelAccpt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperFastSelAccpt.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperFastSelAccpt.setDescription('A flag, if set, that authorizes transmission of incoming calls that request the Fast Select facility.')
portX25OperInCallBar = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperInCallBar.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperInCallBar.setDescription('An X25 facility that prevents transmission of incoming calls to the local DTE.')
portX25OperOutCallBar = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperOutCallBar.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperOutCallBar.setDescription('An X25 facility that prevents transmission of incoming calls to the local DTE.')
portX25OperMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperMaxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperMaxPktSize.setDescription(' The maximum data packet size that will be allowed to pass through this port.')
portX25OperDefPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperDefPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperDefPktSize.setDescription('This is the size that will be assigned to an incoming call setup packet if the packet does not request a packet size.')
portX25OperMaxWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperMaxWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperMaxWinSize.setDescription('This is the maximum number of unacknowledged packets per logical channel that can pass through this port.')
portX25OperDefWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperDefWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperDefWinSize.setDescription("This size will be assigned to an incoming call setup packet if the packet doesn't request a window size.")
portX25OperMaxThruptClass = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 13))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperMaxThruptClass.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperMaxThruptClass.setDescription('This specifies the default throughput class that will be inserted into a Call Request packet if Thruput Class negotiation is not enabled or if a thruput class is not requested in the call request.')
portX25OperCUGPref = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperCUGPref.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperCUGPref.setDescription('This flag, if set, indicates the port belongs to at least one CUG.')
portX25OperCUGIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperCUGIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperCUGIndex.setDescription('This number is an index into a Closed User Group table which identifies the default Closed User Group for the port.')
portX25OperCUGIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperCUGIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperCUGIncAccess.setDescription(' This flag, when set, indicates whether this port will be able to receive calls from outside its CUGs.')
portX25OperCUGOutAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 1, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portX25OperCUGOutAccess.setStatus('mandatory')
if mibBuilder.loadTexts: portX25OperCUGOutAccess.setDescription(' This flag, when set, indicates whether this port will be able to make calls outside its CUGs.')
portFrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3, 2))
portFrConfigTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1), )
if mibBuilder.loadTexts: portFrConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: portFrConfigTable.setDescription('A list of Frame Relay ports . The number of entries will be the number of Frame Relay ports on the node.')
portFrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portFrRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "portFrPortIndex"))
if mibBuilder.loadTexts: portFrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portFrEntry.setDescription('An Frame Relay Port entry containing objects relating to the port that are configurable by the user.')
portFrRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFrRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portFrRlpIndex.setDescription(' The RLP number of the Frame Relay port. It will be in the range 1-8.')
portFrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portFrPortIndex.setDescription(' The Port number of the Frame Relay port. It will be in the range 1-8 for a physical port. It will be in the range 9-64 for a Frame Relay logical port.')
portFrBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBlockedFlag.setDescription(' A flag which when set, means the port should not be enabled after a boot-up of the node. ')
portFrMaxBytesPerFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096)).clone(1600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrMaxBytesPerFrame.setStatus('mandatory')
if mibBuilder.loadTexts: portFrMaxBytesPerFrame.setDescription(' The maximum number of bytes allowed in an I Frame for this Frame Relay port.')
portFrT392Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrT392Timer.setStatus('mandatory')
if mibBuilder.loadTexts: portFrT392Timer.setDescription('This timer indicates how long the network will wait between Status Enquiry messages before recording an error. It should be greater than or equal to the frDlcmiPollingInterval variable in the RFC1315 Mib.')
portFrOutgoingRateControl = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrOutgoingRateControl.setStatus('mandatory')
if mibBuilder.loadTexts: portFrOutgoingRateControl.setDescription(' This is a flag which, when set, enables the enforcement of the Outgoing Rate Control parameters.')
portFrBandwidthAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrBandwidthAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBandwidthAllocation.setDescription(' This is a flag which, when set, enables whether the bandwidth allocation will be enforced. ')
portFrConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10, 11))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10), ("e1", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portFrConnector.setDescription('This defines the connector type of the Frame Relay port.')
portFrLogicalDCE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrLogicalDCE.setStatus('mandatory')
if mibBuilder.loadTexts: portFrLogicalDCE.setDescription('This defines the port as logical DCE or DTE.')
portFrGenClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrGenClock.setStatus('mandatory')
if mibBuilder.loadTexts: portFrGenClock.setDescription('This specifies whether the port will generate the clock necessary to synchronize traffic over the link.')
portFrRcvClkFrmDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrRcvClkFrmDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portFrRcvClkFrmDTE.setDescription('This allows the clock to be looped back from the DTE using the TT (Terminal Timing) signal, which can be helpful on high-speed lines.')
portFrLLM = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lmi", 2), ("annexd", 3))).clone('annexd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrLLM.setStatus('mandatory')
if mibBuilder.loadTexts: portFrLLM.setDescription('This determines whether, and what type of, configurable network management (status enquiries) will be allowed.')
portFrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portFrRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portFrConfigTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device, and which is supplied by a management station wishing to exercise an on-line update of the existing conceptual row. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portFrSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(75, 2048000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portFrSpeed.setDescription('This object defines the speed of the Frame Relay port. The speed may only be set to one of a series of reasonable values, and if an attempt is made to set the speed to a value which is within the valid range but not equal to one of these values, the speed will be rounded up. If the connector type of the port is RS232, the port could be a standard port or a high speed port. If the port is a high speed RS232 port, the maximum valid speed is 256000. If the port is a standard RS232 port, the maximum valid speed is 64000 on the FRX4000/SS1840 and 19200 on all other products. It may be possible to set the speed of a standard RS232 port to a speed which is valid for a high speed RS232 port but invalid for a standard RS232 port. In this case, the port may not end up having the invalid speed. The default speed for a standard RS232 port on the FRX6000 is 19200.')
portFrBackupUseOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrBackupUseOnly.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupUseOnly.setDescription('This object determines whether all DLCIs on the port will be reserved exclusively as backups for other DLCIs in the same node. If yes is specified for this object, the port will remain disabled until needed for backup.')
portDLCIConfigTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2), )
if mibBuilder.loadTexts: portDLCIConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIConfigTable.setDescription("A list of DLCI's on Frame Relay ports . The number of entries will be the number of DLCIs on all the Frame Relay ports on a node.")
portDLCIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portDLCIRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "portDLCIPortIndex"), (0, "NETLINK-SPECIFIC-MIB", "portDLCIIndex"))
if mibBuilder.loadTexts: portDLCIEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIEntry.setDescription('An Frame Relay Port DLCI entry relating to the Rate Control Information that is configurable by the user.')
portDLCIRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDLCIRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIRlpIndex.setDescription(' The RLP number on which the DLCI is located. The range for this is 1-8. ')
portDLCIPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDLCIPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIPortIndex.setDescription(' The port number on which the DLCI is located. The range for this is 1-8 for a physical FR port and 9-64 for a logical FR port. ')
portDLCIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDLCIIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIIndex.setDescription(' The DLCI number used to identify the entry in the table. The range is 16-991. ')
portDLCIIncomingCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIIncomingCIR.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIIncomingCIR.setDescription(' The committed information rate that is supported on the DLCI for incoming data. ')
portDLCIOutgoingCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIOutgoingCIR.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIOutgoingCIR.setDescription(' The committed information rate that is supported on the DLCI for outgoing data. ')
portDLCIIncomingBc = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIIncomingBc.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIIncomingBc.setDescription(' The committed burst size is the maximum amount of data to be transmitted under normal conditions within the time period defined by Bc/Cir that is supported on the DLCI for incoming data. ')
portDLCIOutgoingBc = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIOutgoingBc.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIOutgoingBc.setDescription(' The committed burst size is the maximum amount of data to be transmitted under normal conditions within the time period defined by Bc/Cir that is supported on the DLCI for Outgoing data. ')
portDLCIIncomingBe = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIIncomingBe.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIIncomingBe.setDescription(' The excess burst size is the maximum amount of incoming data in excess of the committed burst size that the network will try to transfer during the time interval determined by Bc/Cir on this DLCI. ')
portDLCIOutgoingBe = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIOutgoingBe.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIOutgoingBe.setDescription(' The excess burst size is the maximum amount of incoming data in excess of the committed burst size that the network will try to transfer during the time interval determined by Bc/Cir on this DLCI. ')
portDLCIBecnRecoveryCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIBecnRecoveryCnt.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIBecnRecoveryCnt.setDescription(" The BECN recovery Count is a method of controlling the rate of return to max traffic flow after it has been reduced due to congestion. The value determines the number of packets received sequentially without BECN set, before increasing the Excess Burst Size by 1/8 of it's configured value. ")
portDLCIPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIPriority.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIPriority.setDescription(' This field sets the priority of the DLCI among others on the physical port. The range is 0 for lowest priority to 4 for the highest priority. ')
portDLCIRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 12), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portDLCIConfigTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned. Also note that deleting a DLCI entry will only remove it from the database file, and it's existence will still be known by the protocol until the node is rebooted.")
portDLCIBackupGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIBackupGroup.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIBackupGroup.setDescription('This object specifies (if configured as any number other than zero) that this is a primary DLCI, and identifies the backup DLCI(s) (in a Frame Relay backup group) that will take over if this DLCI fails. This is applicable only on an initiating node, which is the node that will initiate the switchover to a backup DLCI. At switchover, the initiating node notifies the remote node of the change.')
portDLCIBackupProtEnb = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDLCIBackupProtEnb.setStatus('mandatory')
if mibBuilder.loadTexts: portDLCIBackupProtEnb.setDescription('This object specifies whether the DLCI will be used as a non-initiating backup DLCI. The DLCI will wait for a backup protocol message from the initiating end, telling the backup where to send the rest of the messages.')
portFrBackupGroupTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3), )
if mibBuilder.loadTexts: portFrBackupGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupGroupTable.setDescription(' A Table describes the Frame Relay Backup MIB . ')
portFrBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portFrBackupRLP"), (0, "NETLINK-SPECIFIC-MIB", "portFrBackupPort"), (0, "NETLINK-SPECIFIC-MIB", "portFrBackupDLCI"), (0, "NETLINK-SPECIFIC-MIB", "portFrBackupGroup"))
if mibBuilder.loadTexts: portFrBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupEntry.setDescription(' This Entry contains the SNMP objects that are used for configurating the Frame Relay Backup. ')
portFrBackupRLP = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFrBackupRLP.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupRLP.setDescription(' This RLP number identifies the RLP containing the primary and backup DLCIs. ')
portFrBackupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFrBackupPort.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupPort.setDescription(' This Port number is the physical port on which the backup DLCI is being configured. ')
portFrBackupDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFrBackupDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupDLCI.setDescription(' This DLCI number is the backup being configured. ')
portFrBackupGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFrBackupGroup.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupGroup.setDescription(' This Group number is the backup being configured. ')
portFrBackupWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrBackupWaitTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupWaitTimer.setDescription(' This is the time after a primary DLCI failure that the software will wait for this DLCI to become active before checking the next backup DLCI. If the backup does not become active before the timer expires, the software will search the backup group for the next available backup.')
portFrBackupProtEnab = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrBackupProtEnab.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupProtEnab.setDescription(' This enables or disables the backup protocol on the specified DLCI. It should be set to yes if and only if the remote device is an FRX4000 or FRX6000 with the backup protocol enabled on the remote DLCI connected to this backup group entry. ')
portFrBackupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 2, 3, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrBackupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portFrBackupRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portFrBackupGroupTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portBsciGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3, 4))
portBsciAdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1), )
if mibBuilder.loadTexts: portBsciAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminTable.setDescription('A list of BSC Interactive ports . The number of entries will be the number of BSC Interactive ports on the node.')
portBsciAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portBsciAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminEntry.setDescription('A BSCI Interactive Port entry containing objects relating to the port that are configurable by the user.')
portBsciAdminBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminBlockedFlag.setDescription('Causes the port to be enabled or disabled at node IPL.')
portBsciAdminConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminConnector.setDescription('Physical port interface connector type.')
portBsciAdminSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(75, 19200)).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminSpeed.setDescription('Data transmission rate in bits per second.')
portBsciAdminRetransmitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminRetransmitInterval.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminRetransmitInterval.setDescription('Length of time before the node will transmit an I-frame if the previous transmission is not acknowledged.')
portBsciAdminMAXRetransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminMAXRetransmits.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminMAXRetransmits.setDescription('Maximum number of times the node will attempt to send an I-frame after a retransmission period expiration.')
portBsciAdminMaxBytesPerFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 4105)).clone(4105)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminMaxBytesPerFrame.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminMaxBytesPerFrame.setDescription('Maximum frame size that will be transmitted on the port.')
portBsciAdminGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminGenerateClock.setDescription('Specifies whether the port will generate the clock necessary to synchronize traffic over the link.')
portBsciAdminRcvClockFromDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminRcvClockFromDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminRcvClockFromDTE.setDescription('Allows the clock to be looped back from the DTE using the TT (Terminal Timing) signal.')
portBsciAdminPadType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tpad", 1), ("hpad", 2))).clone('tpad')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminPadType.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminPadType.setDescription('BSCI Pad Type')
portBsciAdminUseEBCDIC = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminUseEBCDIC.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminUseEBCDIC.setDescription('Specifies whether all devices on a line use the same character set for successive session polls.')
portBsciAdminCallInfoInRequestPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminCallInfoInRequestPacket.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminCallInfoInRequestPacket.setDescription('Specifies whether the user will have the option of including call information in a call request packet.')
portBsciAdminClearVCOnLastDeviceDown = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminClearVCOnLastDeviceDown.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminClearVCOnLastDeviceDown.setDescription('Causes the virtual circuit to be cleared when no terminals are using it.')
portBsciAdminTransTextSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminTransTextSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminTransTextSupported.setDescription('Causes all characters transmitted to be treated as data.')
portBsciAdminEndToEndAck = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminEndToEndAck.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminEndToEndAck.setDescription('Allows management of acknowledgments end to end across the network rather than locally at each end.')
portBsciAdminFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminFullDuplex.setDescription('Specifies full-duplex transmission.')
portBsciAdminMultidrop = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminMultidrop.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminMultidrop.setDescription('Specifies whether transmission will be multidrop.')
portBsciAdminSlowPollRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 150)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminSlowPollRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminSlowPollRetryCount.setDescription('Specifies how many times the control unit will be polled before it is put on the slow poll list.')
portBsciAdminSlowPollRetryFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminSlowPollRetryFreq.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminSlowPollRetryFreq.setDescription('Specifies the number of times active control units will be polled between pollings on the slow poll list.')
portBsciAdminStartSynchChars = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminStartSynchChars.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminStartSynchChars.setDescription('Specifies the number of synchronization characters that will be added to the beginning of each frame.')
portBsciAdminEndPadChars = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminEndPadChars.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminEndPadChars.setDescription('Specifies the number of padding characters that will be added to the end of each frame.')
portBsciAdminPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminPollInterval.setDescription('Specifies the time between passes through the polling list.')
portBsciAdminNoResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminNoResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminNoResponseTimer.setDescription('Activated after transmission of a general poll or a data frame.')
portBsciAdminNoResponseRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminNoResponseRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminNoResponseRetryCount.setDescription('Specifies how many times the user device will be polled before control is passed on the next cluster.')
portBsciAdminErrorRetransmitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminErrorRetransmitCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminErrorRetransmitCount.setDescription('Specifies the number of times the Netlink device will resend a block of data after the receiving device has detected an error in that block.')
portBsciAdminNAKRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminNAKRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminNAKRetryCount.setDescription('Specifies the number of times the Netlink device will send a frame when the receiving device is unable to acknowledge.')
portBsciAdminBlockCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("crc16", 1), ("even-lrc", 2), ("odd-lrc", 3))).clone('even-lrc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminBlockCheck.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminBlockCheck.setDescription('Sets the redundancy check parameter.')
portBsciAdminDataMode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("odd-7bit", 1), ("even-7bit", 2), ("none-8bit", 3))).clone('none-8bit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminDataMode.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminDataMode.setDescription('Sets the parity parameter.')
portBsciAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 28), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portBsciAdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device, and which is supplied by a management station wishing to exercise an on-line update of the existing conceptual row. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portBsciAdminAnswerNonConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminAnswerNonConfigured.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminAnswerNonConfigured.setDescription('Only valid if pad type is HPAD. If yes, the HPAD will respond to all devices on the line. If no, the HPAD will respond only to those devices that are configured on the node.')
portBsciAdminActivateConnectionWithoutPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBsciAdminActivateConnectionWithoutPoll.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciAdminActivateConnectionWithoutPoll.setDescription('Only valid if pad type is TPAD. If yes, will active the TPAD connection without a poll of the connected device.')
portBsciOperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2), )
if mibBuilder.loadTexts: portBsciOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperTable.setDescription('A list of BSC Interactive ports . The number of entries will be the number of BSC Interactive ports on the node.')
portBsciOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portBsciOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperEntry.setDescription('A BSCI Interactive Port entry containing objects relating to the port that are configurable by the user.')
portBsciOperBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperBlockedFlag.setDescription('Causes the port to be enabled or disabled at node IPL.')
portBsciOperConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperConnector.setDescription('Physical port interface connector type.')
portBsciOperSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperSpeed.setDescription('Data transmission rate in bits per second.')
portBsciOperRetransmitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperRetransmitInterval.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperRetransmitInterval.setDescription('Length of time before the node will transmit an I-frame if the previous transmission is not acknowledged.')
portBsciOperMAXRetransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperMAXRetransmits.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperMAXRetransmits.setDescription('Maximum number of times the node will attempt to send an I-frame after a retransmission period expiration.')
portBsciOperMaxBytesPerFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 4105))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperMaxBytesPerFrame.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperMaxBytesPerFrame.setDescription('Maximum frame size that will be transmitted on the port.')
portBsciOperGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperGenerateClock.setDescription('Specifies whether the port will generate the clock necessary to synchronize traffic over the link.')
portBsciOperRcvClockFromDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperRcvClockFromDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperRcvClockFromDTE.setDescription('Allows the clock to be looped back from the DTE using the TT (Terminal Timing) signal.')
portBsciOperPadType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tpad", 1), ("hpad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperPadType.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperPadType.setDescription('BSCI Pad Type')
portBsciOperUseEBCDIC = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperUseEBCDIC.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperUseEBCDIC.setDescription('Specifies whether all devices on a line use the same character set for successive session polls.')
portBsciOperCallInfoInRequestPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperCallInfoInRequestPacket.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperCallInfoInRequestPacket.setDescription('Specifies whether the user will have the option of including call information in a call request packet.')
portBsciOperClearVCOnLastDeviceDown = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperClearVCOnLastDeviceDown.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperClearVCOnLastDeviceDown.setDescription('Causes the virtual circuit to be cleared when no terminals are using it.')
portBsciOperTransTextSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperTransTextSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperTransTextSupported.setDescription('Causes all characters transmitted to be treated as data.')
portBsciOperEndToEndAck = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperEndToEndAck.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperEndToEndAck.setDescription('Allows management of acknowledgments end to end across the network rather than locally at each end.')
portBsciOperFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperFullDuplex.setDescription('Specifies full-duplex transmission.')
portBsciOperMultidrop = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperMultidrop.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperMultidrop.setDescription('Specifies whether transmission will be multidrop.')
portBsciOperSlowPollRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 150))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperSlowPollRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperSlowPollRetryCount.setDescription('Specifies how many times the control unit will be polled before it is put on the slow poll list.')
portBsciOperSlowPollRetryFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperSlowPollRetryFreq.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperSlowPollRetryFreq.setDescription('Specifies the number of times active control units will be polled between pollings on the slow poll list.')
portBsciOperStartSynchChars = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperStartSynchChars.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperStartSynchChars.setDescription('Specifies the number of synchronization characters that will be added to the beginning of each frame.')
portBsciOperEndPadChars = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperEndPadChars.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperEndPadChars.setDescription('Specifies the number of padding characters that will be added to the end of each frame.')
portBsciOperPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperPollInterval.setDescription('Specifies the time between passes through the polling list.')
portBsciOperNoResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperNoResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperNoResponseTimer.setDescription('Activated after transmission of a general poll or a data frame.')
portBsciOperNoResponseRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperNoResponseRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperNoResponseRetryCount.setDescription('Specifies how many times the user device will be polled before control is passed on the next cluster.')
portBsciOperErrorRetransmitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperErrorRetransmitCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperErrorRetransmitCount.setDescription('Specifies the number of times the Netlink device will resend a block of data after the receiving device has detected an error in that block.')
portBsciOperNAKRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperNAKRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperNAKRetryCount.setDescription('Specifies the number of times the Netlink device will send a frame when the receiving device is unable to acknowledge.')
portBsciOperBlockCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("crc16", 1), ("even-lrc", 2), ("odd-lrc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperBlockCheck.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperBlockCheck.setDescription('Sets the redundancy check parameter.')
portBsciOperDataMode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("odd-7bit", 1), ("even-7bit", 2), ("none-8bit", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperDataMode.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperDataMode.setDescription('Sets the parity parameter.')
portBsciOperAnswerNonConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperAnswerNonConfigured.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperAnswerNonConfigured.setDescription('Only valid if pad type is HPAD. If yes, the HPAD will respond to all devices on the line. If no, the HPAD will respond only to those devices that are configured on the node.')
portBsciOperActivateConnectionWithoutPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBsciOperActivateConnectionWithoutPoll.setStatus('mandatory')
if mibBuilder.loadTexts: portBsciOperActivateConnectionWithoutPoll.setDescription('Only valid if pad type is TPAD. If yes, will active the TPAD connection without a poll of the connected device.')
bsciSubscrAdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3), )
if mibBuilder.loadTexts: bsciSubscrAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminTable.setDescription('A list of BSC Interactive port subscribers.')
bsciSubscrAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "bsciSubscrAdminSequence"))
if mibBuilder.loadTexts: bsciSubscrAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminEntry.setDescription('A BSCI Interactive Port Subscriber entry containing objects relating to the port that are configurable by the user.')
bsciSubscrAdminSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrAdminSequence.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminSequence.setDescription('Subscriber index for a specific BSCI port subscriber.')
bsciSubscrAdminLocalID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 2), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminLocalID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminLocalID.setDescription('Subscriber address of the local end of a BSCI connection.')
bsciSubscrAdminRemoteID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 3), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminRemoteID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminRemoteID.setDescription('Subscriber address of the remote end of a BSCI connection.')
bsciSubscrAdminAutocall = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminAutocall.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminAutocall.setDescription('Causes a BSCI TPAD to automatically call its HPAD when the controller becomes active.')
bsciSubscrAdminAutocallRtyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 255)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminAutocallRtyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminAutocallRtyTimer.setDescription('Time between autocall retries.')
bsciSubscrAdminAutocallMaxRtry = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminAutocallMaxRtry.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminAutocallMaxRtry.setDescription('Maximum number of times an autocall will be sent.')
bsciSubscrAdminConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminConnectionID.setDescription('Identifier that will link the BSCI port with a device configured in the BSCI Devices Table.')
bsciSubscrAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 3, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciSubscrAdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrAdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the bsciDevAdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
bsciSubscrOperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4), )
if mibBuilder.loadTexts: bsciSubscrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperTable.setDescription('A list of BSC Interactive port subscribers.')
bsciSubscrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "bsciSubscrOperSequence"))
if mibBuilder.loadTexts: bsciSubscrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperEntry.setDescription('A BSCI Interactive Port Subscriber entry containing objects relating to the port that are configurable by the user.')
bsciSubscrOperSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperSequence.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperSequence.setDescription('Subscriber index for a specific BSCI port subscriber.')
bsciSubscrOperLocalID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 2), NlSubscriberAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperLocalID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperLocalID.setDescription('Subscriber address of the local end of a BSCI connection.')
bsciSubscrOperRemoteID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 3), NlSubscriberAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperRemoteID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperRemoteID.setDescription('Subscriber address of the remote end of a BSCI connection.')
bsciSubscrOperAutocall = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperAutocall.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperAutocall.setDescription('Causes a BSCI TPAD to automatically call its HPAD when the controller becomes active.')
bsciSubscrOperAutocallRtyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperAutocallRtyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperAutocallRtyTimer.setDescription('Time between autocall retries.')
bsciSubscrOperAutocallMaxRtry = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperAutocallMaxRtry.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperAutocallMaxRtry.setDescription('Maximum number of times an autocall will be sent.')
bsciSubscrOperConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciSubscrOperConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciSubscrOperConnectionID.setDescription('Identifier that will link the BSCI port with a device configured in the BSCI Devices Table.')
bsciDevAdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5), )
if mibBuilder.loadTexts: bsciDevAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminTable.setDescription('A list of BSC Interactive devices.')
bsciDevAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "bsciDevAdminControlUnitID"), (0, "NETLINK-SPECIFIC-MIB", "bsciDevAdminDeviceUnitID"))
if mibBuilder.loadTexts: bsciDevAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminEntry.setDescription('A BSCI Interactive Device entry containing objects relating to the device that are configurable by the user.')
bsciDevAdminControlUnitID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevAdminControlUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminControlUnitID.setDescription('Control Unit identifier.')
bsciDevAdminDeviceUnitID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevAdminDeviceUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminDeviceUnitID.setDescription('Device Unit identifier.')
bsciDevAdminConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciDevAdminConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminConnectionID.setDescription('The BSCI port connection ID for the device.')
bsciDevAdminSingleUserVC = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciDevAdminSingleUserVC.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminSingleUserVC.setDescription('Specifies whether each end of the connection is within a same Control Unit/Device Type pair.')
bsciDevAdminTransTextSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciDevAdminTransTextSupported.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminTransTextSupported.setDescription('Causes all characters transmitted to be treated as data.')
bsciDevAdminPrinterAttached = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciDevAdminPrinterAttached.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminPrinterAttached.setDescription('Specifies whether the device has a printer attached.')
bsciDevAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciDevAdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the bsciDevAdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
bsciDevAdminDisableStatusRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("none", 2), ("always-active", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bsciDevAdminDisableStatusRequest.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevAdminDisableStatusRequest.setDescription('Determines how the BSCI port will report the status of the attached device. Normal status- the port will report what the device reports. No status- the port will report status only if the device is active. Always active status- the port will always report the device as active.')
bsciDevOperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6), )
if mibBuilder.loadTexts: bsciDevOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperTable.setDescription('A list of BSC Interactive devices.')
bsciDevOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "bsciDevOperControlUnitID"), (0, "NETLINK-SPECIFIC-MIB", "bsciDevOperDeviceUnitID"))
if mibBuilder.loadTexts: bsciDevOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperEntry.setDescription('A BSCI Interactive Device entry containing objects relating to the device that are configurable by the user.')
bsciDevOperControlUnitID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperControlUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperControlUnitID.setDescription('Control Unit identifier.')
bsciDevOperDeviceUnitID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperDeviceUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperDeviceUnitID.setDescription('Device Unit identifier.')
bsciDevOperConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperConnectionID.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperConnectionID.setDescription('The BSCI port connection ID for the device.')
bsciDevOperSingleUserVC = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperSingleUserVC.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperSingleUserVC.setDescription('Specifies whether each end of the connection is within a same Control Unit/Device Type pair.')
bsciDevOperTransTextSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperTransTextSupported.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperTransTextSupported.setDescription('Causes all characters transmitted to be treated as data.')
bsciDevOperPrinterAttached = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperPrinterAttached.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperPrinterAttached.setDescription('Specifies whether the device has a printer attached.')
bsciDevOperDisableStatusRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 4, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("none", 2), ("always-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bsciDevOperDisableStatusRequest.setStatus('mandatory')
if mibBuilder.loadTexts: bsciDevOperDisableStatusRequest.setDescription('Determines how the BSCI port will report the status of the attached device. Normal status- the port will report what the device reports. No status- the port will report status only if the device is active. Always active status- the port will always report the device as active.')
portSdlcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3, 5))
portSdlcAdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1), )
if mibBuilder.loadTexts: portSdlcAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminTable.setDescription('This table contains Netlink Enterprise specific objects to manage SDLC port. Changing on of the these parameters may take effect in the operating port immediately or may wait until the interface is restarted depending on the details of the implementation. Most of the objects in this read-write table have corresponding read-only objects in the portSdlcOperTable that return the current operating value. The operating values may be different from these configured values if a configured parameter was configured afterthe interface was started.')
portSdlcAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portSdlcAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminEntry.setDescription('A list of configured values for an SDLC port.')
portSdlcAdminCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminCommit.setStatus('obsolete')
if mibBuilder.loadTexts: portSdlcAdminCommit.setDescription('Writing a value to this object commits the the SDLC port related modified configuration values to the database.')
portSdlcAdminMAXRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminMAXRetries.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminMAXRetries.setDescription('This object defines the max. number of retries to a non-responding Link station, before putting the Link station to slow-poll list if it is not Normal response Mode OR disconnecting the link station if it is data txfr state.')
portSdlcAdminMAXOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminMAXOut.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminMAXOut.setDescription('This object defines the number of outstanding frames for triggering window full condition.')
portSdlcAdminPadType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("xpad", 1), ("tpad", 2), ("hpad", 3), ("npad", 4))).clone('tpad')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminPadType.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminPadType.setDescription('This object defines the SNA PAD types.')
portSdlcAdminGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminGenerateClock.setDescription('This object defines if the port would generate clock.')
portSdlcAdminRcvClockFromDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminRcvClockFromDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminRcvClockFromDTE.setDescription('This object defines if the rcv clock will be used from DTE.')
portSdlcAdminNrz = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminNrz.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminNrz.setDescription('This object defines the data encoding at the physical layer')
portSdlcAdminPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminPacketSize.setDescription('This object defines the packet size of the X25 layer used by SNA PAD')
portSdlcAdminDisableRequestDisconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminDisableRequestDisconnect.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminDisableRequestDisconnect.setDescription('This object defines if a Request To Disconnect(RD) will be sent when remote PAD clear the connection')
portSdlcAdminLPDASupport = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lpda-1", 2), ("lpda-2", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminLPDASupport.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminLPDASupport.setDescription('This object defines the type LPDA support on SDLC port.')
portSdlcAdminConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminConnector.setDescription('This object defines the connector type of the SDLC port.')
portSdlcAdminSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(75, 2048000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminSpeed.setDescription('This object defines the speed of the SDLC port. The speed may only be set to one of a series of reasonable values, and if an attempt is made to set the speed to a value which is within the valid range but not equal to one of these values, the speed will be rounded up. If the connector type of the port is RS232, the port could be a standard port or a high speed port. If the port is a high speed RS232 port, the maximum valid speed is 256000. If the port is a standard RS232 port, the maximum valid speed is 64000 on the FRX4000/SS1840 and 19200 on all other products. It may be possible to set the speed of a standard RS232 port to a speed which is valid for a high speed RS232 port but invalid for a standard RS232 port. In this case, the port may not end up having the invalid speed. The default speed for a standard RS232 port on the FRX6000 is 19200.')
portSdlcAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portSdlcAdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device, and which is supplied by a management station wishing to exercise an on-line update of the existing conceptual row. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portSdlcAdminIdleFillChar = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex-ff", 1), ("hex-7e", 2))).clone('hex-ff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminIdleFillChar.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminIdleFillChar.setDescription('This object specifies a character that wll be inserted into the stream when the SNA link is idle.')
portSdlcAdminInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 250)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminInactivityTimer.setDescription('This object determines how long the node will wait with no activity on the port before it will declare the attached device down.')
portSdlcAdminL1Duplex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("full-duplex", 1), ("half-duplex", 2))).clone('full-duplex')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSdlcAdminL1Duplex.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcAdminL1Duplex.setDescription('This object determines whether level-1 (physical layer) transmission can be in one (half duplex) or both (full duplex) directions at once.')
portSdlcOperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2), )
if mibBuilder.loadTexts: portSdlcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperTable.setDescription('This table contains current Netlink enterprise specific port parameters')
portSdlcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portSdlcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperEntry.setDescription('A list of operational values for an SDLC port.')
portSdlcOperCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperCommit.setStatus('obsolete')
if mibBuilder.loadTexts: portSdlcOperCommit.setDescription('This object is not used.')
portSdlcOperMAXRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperMAXRetries.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperMAXRetries.setDescription('This object defines the max. number of retries to a non-responding Link station, before putting the Link station to slow-poll list if it is not Normal response Mode OR disconnecting the link station if it is data txfr state.')
portSdlcOperMAXOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperMAXOut.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperMAXOut.setDescription('This object defines the number of outstanding frames for triggering window full condition.')
portSdlcOperPadType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("xpad", 1), ("tpad", 2), ("hpad", 3), ("npad", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperPadType.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperPadType.setDescription('This object defines the SNA PAD type')
portSdlcOperGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperGenerateClock.setDescription('This object defines if the port would generate clock.')
portSdlcOperRcvClockFromDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperRcvClockFromDTE.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperRcvClockFromDTE.setDescription('This object defines if the rcv clock will be used from DTE.')
portSdlcOperNrz = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperNrz.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperNrz.setDescription('This object defines the data encoding at the physical layer')
portSdlcOperPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperPacketSize.setDescription('This object defines the packet size of the X25 layer used by SNA PAD')
portSdlcOperDisableRequestDisconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperDisableRequestDisconnect.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperDisableRequestDisconnect.setDescription('This object defines if a Request To Disconnect(RD) will be sent when remote PAD clear the connection')
portSdlcOperLPDASupport = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lpda-1", 2), ("lpda-2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperLPDASupport.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperLPDASupport.setDescription('This object defines the type LPDA support on SDLC port.')
portSdlcOperConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 10))).clone(namedValues=NamedValues(("rs232", 3), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("t1", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperConnector.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperConnector.setDescription('This object defines the operational connector type of the SDLC port.')
portSdlcOperSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperSpeed.setDescription('This object defines the operational speed of the SDLC port.')
portSdlcOperIdleFillChar = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex-ff", 1), ("hex-7e", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperIdleFillChar.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperIdleFillChar.setDescription('This object specifies a character that wll be inserted into the stream when the SNA link is idle.')
portSdlcOperInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperInactivityTimer.setDescription('This object determines how long the node will wait with no activity on the port before it will declare the attached device down.')
portSdlcOperL1Duplex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("full-duplex", 1), ("half-duplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSdlcOperL1Duplex.setStatus('mandatory')
if mibBuilder.loadTexts: portSdlcOperL1Duplex.setDescription('This object determines whether level-1 (physical layer) transmission can be in one (half duplex) or both (full duplex) directions at once.')
lSSdlcAdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3), )
if mibBuilder.loadTexts: lSSdlcAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminTable.setDescription('This table contains Enterprise specific Link station configurable parameters to manage the link stations.')
lSSdlcAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "sdlcLSAddress"))
if mibBuilder.loadTexts: lSSdlcAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminEntry.setDescription('A list of configured values for an SDLC port.')
lSSdlcAdminLocalSub = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 1), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminLocalSub.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminLocalSub.setDescription('This object defines the local subscriber ID of the Link Station')
lSSdlcAdminRemoteSub = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 2), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminRemoteSub.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminRemoteSub.setDescription('This object defines the remote subscriber ID used to connect to remote Link Station')
lSSdlcAdminAutoCall = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminAutoCall.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminAutoCall.setDescription('This object defines if auto call is enabled for the link station. If enabled, the link station will initiate connection establishment, when appropriate. Else, it will passively listen to the connection request for establish a connection with the remote PAD')
lSSdlcAdminRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 225)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminRetryTime.setDescription('This object is used, only when lSSdlcAdminAutoCall object is yes. This defines the time interval measured in seconds in which the connection request is retried')
lSSdlcAdminRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminRetryCount.setDescription('This object is used, only when lSSdlcAdminAutoCall object is yes. This defines the number of times the connection initiation is retried before given up. The value of Zero(0) means to try indefinitely')
lSSdlcAdminLlc2Conversion = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminLlc2Conversion.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminLlc2Conversion.setDescription('This object defines if this link station connects to a LLC2 device/host.')
lSSdlcAdminLPDAResourceID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminLPDAResourceID.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminLPDAResourceID.setDescription('This objects the resource ID used during LPDA command support')
lSSdlcAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the lSSdlcAdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned. Also note that deleting a PU entry will only remove it from the database file, and it's existence will still be known by the protocol until the node is rebooted or until an online update of the port is performed.")
lSSdlcAdminL2DatMode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("two-way-alternate", 1), ("two-way-simultaneous", 2))).clone('two-way-alternate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcAdminL2DatMode.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcAdminL2DatMode.setDescription('This object determines whether transmission can be in one (alternate) or two (simultaneous) directions at the same time.')
lSSdlcOperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4), )
if mibBuilder.loadTexts: lSSdlcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperTable.setDescription('This table contains the operational parameters of the SDLC port')
lSSdlcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "sdlcLSAddress"))
if mibBuilder.loadTexts: lSSdlcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperEntry.setDescription('A list of configured values for an SDLC port.')
lSSdlcOperLocalSub = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 1), NlSubscriberAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperLocalSub.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperLocalSub.setDescription('This object defines the local subscriber ID of the Link Station')
lSSdlcOperRemoteSub = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 2), NlSubscriberAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperRemoteSub.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperRemoteSub.setDescription('This object defines the remote subscriber ID used to connect to remote Link Station')
lSSdlcOperAutoCall = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperAutoCall.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperAutoCall.setDescription('This object defines if auto call is enabled for the link station. If enabled, the link station will initiate connection establishment, when appropriate. Else, it will passively listen to the connection request for establish a connection with the remote PAD')
lSSdlcOperRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 225))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperRetryTime.setDescription('This object is valid, only when lSSdlcAdminAutoCall object is yes. This defines the time interval measured in seconds in which the connection request is retried')
lSSdlcOperRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperRetryCount.setDescription('This object is used, only when lSSdlcAdminAutoCall object is yes. This defines the number of times the connection initiation is retried before given up. The value of Zero(0) means to try indefinitely')
lSSdlcOperLlc2Conversion = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperLlc2Conversion.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperLlc2Conversion.setDescription('This object defines if this link station connects to a LLC2 device/host.')
lSSdlcOperLPDAResourceID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperLPDAResourceID.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperLPDAResourceID.setDescription('This objects the resource ID used during LPDA command support')
lSSdlcOperL2DatMode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("two-way-alternate", 1), ("two-way-simultaneous", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcOperL2DatMode.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcOperL2DatMode.setDescription('This object determines whether transmission can be in one (alternate) or two (simultaneous) directions at the same time.')
lSSdlcLlc2AdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5), )
if mibBuilder.loadTexts: lSSdlcLlc2AdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminTable.setDescription('This table contains the LLC2 related parameters used to configure LLC2 session, when the SDLC station is connected to a LLC2 device at the remote end')
lSSdlcLlc2AdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "sdlcLSAddress"))
if mibBuilder.loadTexts: lSSdlcLlc2AdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminEntry.setDescription('A list of configured values for an SDLC port.')
lSSdlcLlc2AdminLocalSap = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 252)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLocalSap.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLocalSap.setDescription('This object defines Local SAP address (multiple of 4)')
lSSdlcLlc2AdminLocalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 2), PhysAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLocalMac.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLocalMac.setDescription('This object defines the local MAC address')
lSSdlcLlc2AdminIdblk = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminIdblk.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminIdblk.setDescription('This object defines idblk used in XID')
lSSdlcLlc2AdminIdnum = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminIdnum.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminIdnum.setDescription('This object defines idnum used in XID')
lSSdlcLlc2AdminLanTi = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanTi.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanTi.setDescription('This object defines LLC2 inactivity timer measured in units of seconds')
lSSdlcLlc2AdminLanT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanT1.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanT1.setDescription('This object defines LLC2 reply timer measured in units of 100 milliseconds')
lSSdlcLlc2AdminLanT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 5000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanT2.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanT2.setDescription('This object defines Receiver Ack Timer measured in units of milliseconds')
lSSdlcLlc2AdminLanN2 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanN2.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanN2.setDescription('This object defines Maximum Retransmissions')
lSSdlcLlc2AdminLanN3 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanN3.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanN3.setDescription("This object defines count of I-format LPDU's before sending Ack")
lSSdlcLlc2AdminLanTw = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanTw.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminLanTw.setDescription('This object defines Outstanding Frames')
lSSdlcLlc2AdminBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminBAG.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminBAG.setDescription('This object defines bandwidth allocation group')
lSSdlcLlc2AdminPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminPriority.setDescription('This object defines priority for traffic within the node')
lSSdlcLlc2AdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the lSSdlcLlc2AdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned. Also note that deleting a PU entry will only remove it from the database file, and it's existence will still be known by the protocol until the node is rebooted or until an online update of the port is performed.")
lSSdlcLlc2AdminSuppressXID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lSSdlcLlc2AdminSuppressXID.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2AdminSuppressXID.setDescription('This object prevents (if yes) the returning of an XID in response to a null XID. This might be desirable if the remote TPAD is not running PU 2.1. It should be noted that even if an XID is sent, an SNRM (Set Normal Response Mode) immediately follows, so the connection will be established.')
lSSdlcLlc2OperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6), )
if mibBuilder.loadTexts: lSSdlcLlc2OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperTable.setDescription('This table contains operartional parameters related to LLC2 session of this link station.')
lSSdlcLlc2OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"), (0, "NETLINK-SPECIFIC-MIB", "sdlcLSAddress"))
if mibBuilder.loadTexts: lSSdlcLlc2OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperEntry.setDescription('A list of configured values for an SDLC port.')
lSSdlcLlc2OperLocalSap = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLocalSap.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLocalSap.setDescription('This object defines Local SAP address (multiple of 4)')
lSSdlcLlc2OperLocalMac = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLocalMac.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLocalMac.setDescription('This object defines the local MAC address')
lSSdlcLlc2OperIdblk = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperIdblk.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperIdblk.setDescription('This object defines idblk used in XID')
lSSdlcLlc2OperIdnum = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperIdnum.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperIdnum.setDescription('This object defines idnum used in XID')
lSSdlcLlc2OperLanTi = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLanTi.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLanTi.setDescription('This object defines LLC2 inactivity timer measured in units of seconds')
lSSdlcLlc2OperLanT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLanT1.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLanT1.setDescription('This object defines LLC2 reply timer measured in units of 100 milliseconds')
lSSdlcLlc2OperLanT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLanT2.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLanT2.setDescription('This object defines Receiver Ack Timer measured in units of milliseconds')
lSSdlcLlc2OperLanN2 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLanN2.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLanN2.setDescription('This object defines Maximum Retransmissions')
lSSdlcLlc2OperLanN3 = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLanN3.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLanN3.setDescription("This object defines count of I-format LPDU's before sending Ack")
lSSdlcLlc2OperLanTw = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperLanTw.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperLanTw.setDescription('This object defines Outstanding Frames')
lSSdlcLlc2OperBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperBAG.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperBAG.setDescription('This object defines bandwidth allocation group')
lSSdlcLlc2OperPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperPriority.setDescription('This object defines priority for traffic within the node')
lSSdlcLlc2OperSuppressXID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 5, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSSdlcLlc2OperSuppressXID.setStatus('mandatory')
if mibBuilder.loadTexts: lSSdlcLlc2OperSuppressXID.setDescription('This object prevents (if yes) the returning of an XID in response to a null XID. This might be desirable if the remote TPAD is not running PU 2.1. It should be noted that even if an XID is sent, an SNRM (Set Normal Response Mode) immediately follows, so the connection will be established.')
portT1Group = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3, 7))
portT1AdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1), )
if mibBuilder.loadTexts: portT1AdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminTable.setDescription('The configuration information pertaining to a T1 port. T1 ports can operate at full T1 bandwidth or DS0A channelized which provides 24 separate channels.')
portT1AdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portT1AdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminEntry.setDescription('A T1 port entry containing objects relating to T1 ports.')
portT1AdminBlockedPortFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminBlockedPortFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminBlockedPortFlag.setDescription('')
portT1AdminGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminGenerateClock.setDescription('')
portT1AdminFramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullT1", 1), ("ds0aT1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminFramingMode.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminFramingMode.setDescription('Specifies how this T1 port is to function. ds0AT1 specifies a 24 channelized T1.')
portT1AdminFrameModelSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("d4", 1), ("esf", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminFrameModelSelect.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminFrameModelSelect.setDescription('')
portT1AdminLineEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("b8zs", 1), ("ami", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminLineEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminLineEncoding.setDescription('')
portT1AdminLineBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("zerodb", 1), ("x133-266ft", 2), ("x266-399ft", 3), ("x399-533ft", 4), ("x533-655ft", 5), ("minus7p5db", 6), ("minus15db", 7), ("minus22p5db", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminLineBuildOut.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminLineBuildOut.setDescription('')
portT1AdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminRowStatus.setDescription('')
portT1AdminProtocolFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("bisync", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminProtocolFraming.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminProtocolFraming.setDescription('')
portT1AdminNRZI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portT1AdminNRZI.setStatus('mandatory')
if mibBuilder.loadTexts: portT1AdminNRZI.setDescription('')
portT1OperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2), )
if mibBuilder.loadTexts: portT1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperTable.setDescription('The configuration information pertaining to a T1 port. T1 ports can operate at full T1 bandwidth or DS0A channelized which provides 24 separate channels.')
portT1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: portT1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperEntry.setDescription('A T1 port entry containing objects relating to T1 ports.')
portT1OperBlockedPortFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperBlockedPortFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperBlockedPortFlag.setDescription('')
portT1OperGenerateClock = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperGenerateClock.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperGenerateClock.setDescription('')
portT1OperFramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullT1", 1), ("ds0aT1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperFramingMode.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperFramingMode.setDescription('Specifies how this T1 port is to function. ds0AT1 specifies a 24 channelized T1.')
portT1OperFrameModelSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("d4", 1), ("esf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperFrameModelSelect.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperFrameModelSelect.setDescription('')
portT1OperLineEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("b8zs", 1), ("ami", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperLineEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperLineEncoding.setDescription('')
portT1OperLineBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("zerodb", 1), ("x133-266ft", 2), ("x266-399ft", 3), ("x399-533ft", 4), ("x533-655ft", 5), ("minus7p5db", 6), ("minus15db", 7), ("minus22p5db", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperLineBuildOut.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperLineBuildOut.setDescription('')
portT1OperProtocolFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("bisync", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperProtocolFraming.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperProtocolFraming.setDescription('')
portT1OperNRZI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portT1OperNRZI.setStatus('mandatory')
if mibBuilder.loadTexts: portT1OperNRZI.setDescription('')
portVoiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 3, 8))
portVoiceAdminTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1), )
if mibBuilder.loadTexts: portVoiceAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminTable.setDescription('A list of Voice ports. The number of entries will be the number of Voice ports on the node.')
portVoiceAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portVoiceAdminRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "portVoiceAdminPortIndex"))
if mibBuilder.loadTexts: portVoiceAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminEntry.setDescription('A Voice Port entry containing objects relating to the port that are configurable by the user.')
portVoiceAdminRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceAdminRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminRlpIndex.setDescription('The RLP number of the Voice port.')
portVoiceAdminPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceAdminPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminPortIndex.setDescription('The Port number of the Voice port.')
portVoiceAdminBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminBlockedFlag.setDescription('The flag which causes the port to be enabled or disabled at node IPL. The port will remain in that state until this flag is changed and the node is rebooted, or until an on- line enable or disable is performed.')
portVoiceAdminSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps-4800", 1), ("bps-8000", 2), ("bps-32000", 3), ("bps-64000", 4))).clone('bps-8000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminSpeed.setDescription('The speed of the port which is transmitted as part of a Call Setup frame. A Voice call will be established if there is enough bandwidth at each end to provide the minimum configured rate.')
portVoiceAdminDTMF = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminDTMF.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminDTMF.setDescription('The flag to enable, disable, or specify a time span over which DTMF (Dual Tone Multi Frequency) tones will be regenerated. 0 = pass tones transparently to the remote device. 1 = detect incoming tones and regenerate as received. 2-255 = regenerate tones for the specified seconds.')
portVoiceAdminInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 10, 11))).clone(namedValues=NamedValues(("em-4w", 1), ("em-2w", 2), ("loop-start", 3), ("ac15-a", 4), ("ac15-b", 6), ("em-4w-te", 10), ("em-2w-te", 11))).clone('loop-start')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminInterface.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminInterface.setDescription('The type of interface (in conjunction with the Telephony Interface Type) that will be used by the Voice channel. This requires rebooting for the change to take effect. Telephony Type Interface Type -------------- -------------- OPX (FXO) Loop Start SLT (FXS) Loop Start E&M 4W E&M, 4W E&M TE, 2W E&M, 2W E&M TE AC15 AC15A, AC15C')
portVoiceAdminTETimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminTETimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminTETimer.setDescription("The delay at which the E&M 'E' lead follows the 'M' lead.")
portVoiceAdminLevelIn = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-22, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminLevelIn.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminLevelIn.setDescription('The local voice level into the voice port. This adjusts the sensitivity of the local voice channel to the signal from the attached device. The purpose of this is to match the voice channel dB level to the input signal. A more negative setting produces a higher input gain. If the level is reduced, the voice channel will be more sensitive to the input. This will also cause the voice output at the remote device to sound louder.')
portVoiceAdminLevelOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-22, 7)).clone(-4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminLevelOut.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminLevelOut.setDescription('The local voice level out of the voice port. A more positive setting produces a higher volume.')
portVoiceAdminCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminCallTimer.setDescription('The amount of time the node will wait for a response to a Call Connect or Call Clear request. When the node issues a request, it will set a timer to the value configured here. If that timer expires with no response from the destination, the node will generate a busy tone.')
portVoiceAdminHuntGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("a", 2), ("b", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminHuntGroup.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminHuntGroup.setDescription('The hunt group that includes the voice channel.')
portVoiceAdminLongDialPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="2A")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminLongDialPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminLongDialPrefix.setDescription('The character that will be required preceeding calls using the long call format. When the user at an attached device dials a long form number, it must be preceeded by the prefix character specified here.')
portVoiceAdminSLTTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminSLTTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminSLTTimeout.setDescription('The time the local port will wait before an actual fax transmission begins. If there is no fax tone when this timer expires, the connection will be terminated.')
portVoiceAdminLinkDownBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminLinkDownBusy.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminLinkDownBusy.setDescription('This flag enables or disables automatic busy-out of channels when the link is down. When enabled, the system will automatically busy-out channels when the composite link is down. When disabled, channels remain on-hook when the link is down. If your application is connected to a PBX that can route calls to another alternate source based on an all busy condition, enable this so the PBX will recognize this condition and reroute the calls while the composite link is down.')
portVoiceAdminFaxSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminFaxSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminFaxSupported.setDescription('The flag to indicate whether or not faxes will be transmitted on the port. If no, all calls will be treated as voice. If yes, both voice and fax will be transmitted.')
portVoiceAdminTelephonyType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("opx", 1), ("slt", 2), ("em", 3), ("ac15", 4))).clone('opx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminTelephonyType.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminTelephonyType.setDescription('The type of interface (in conjunction with the Interface Type) that will be used by the Voice channel. This requires rebooting for the change to take effect. Telephony Type Interface Type -------------- -------------- OPX (FXO) Loop Start SLT (FXS) Loop Start E&M 4W E&M, 4W E&M TE, 2W E&M, 2W E&M TE AC15 AC15A, AC15C')
portVoiceAdminJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 255)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminJitter.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminJitter.setDescription('The amount of jitter delay.')
portVoiceAdminSampleDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminSampleDelay.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminSampleDelay.setDescription('The amount of sample delay.')
portVoiceAdminDialTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminDialTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminDialTimer.setDescription('The delay the node will use to determine when variable length dialing is complete. (Variable length dialing allows the user to place a call without entering the configured number of digits for the speed dial number.)')
portVoiceAdminAutoDial = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminAutoDial.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminAutoDial.setDescription('The flag to enable or disable the auto dial feature. Note that enabling this feature will disable the variable length dialing feature for this channel.')
portVoiceAdminSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("very-low", 1), ("low", 2), ("medium", 3), ("high", 4), ("very-high", 5))).clone('low')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminSuppression.setDescription('The silence suppression level. A larger silence suppression level allows more data channels to operate simultaneously with the voice channels.')
portVoiceAdminAutoDialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminAutoDialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminAutoDialNumber.setDescription('The number to which the node will attempt to connect when the handset attached to this port is taken off-hook. This is applicable only when the Auto Dial feature is enabled.')
portVoiceAdminAutoPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminAutoPoll.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminAutoPoll.setDescription('The flag to enable or disable auto polling. This is applicable only when the Auto Dial feature is enabled. When enabled, the node periodically polls the destination. If the poll is not acknowledged, the node will busy-out the channel. This can be useful in situations where the destination is an emergency number that must always be available. If the destination does not answer the automatic poll, the busy-out condition will notify an attached PBX that the emergency call should be routed to another call routing device.')
portVoiceAdminAutoPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminAutoPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminAutoPollTimer.setDescription('The frequency with which an Auto Poll will be sent. This is applicable only when auto poll is enabled.')
portVoiceAdminExtDigitsSource = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("map", 1), ("user", 2))).clone('map')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminExtDigitsSource.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminExtDigitsSource.setDescription('The source of the extended digits when the user of attached equipment dials a speed dial number. This is applicable only when the number of extended dial digits is greater than zero. When map is specified, extended digits are taken from the extended digits field in the map table. When user is specified, extended digits are taken from the user of attached equipment.')
portVoiceAdminNumDigitsDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminNumDigitsDelete.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminNumDigitsDelete.setDescription('The number of leading dial digits that will be deleted before a dial string is forwarded. This is primarily used to delete leading dial digits that may be inserted by an attached PBX.')
portVoiceAdminForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminForwardDelay.setDescription('The length of a pause that can be inserted in an extended dial string that is being forwarded. This is applicable only when forwarded output digits is all or extended. When a comma is encountered in an extended digits string, the node will pause for the length of time specified here before additional extended digits are forwarded.')
portVoiceAdminForwardedType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2))).clone('dtmf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminForwardedType.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminForwardedType.setDescription('The method how the dial digits will be forwarded. This is applicable only when forwarded output digits is all or extended.')
portVoiceAdminForwardedDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("all", 2), ("extended", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminForwardedDigits.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminForwardedDigits.setDescription('The flag indicating which dial digits, if any, to forward. If none, dial digits are not forwarded to the destination device when a call is initiated on this channel. If all, the dialed speed dial number and associated extended digits are forwarded to the destination device. If extended, only the extended digit string is forwarded.')
portVoiceAdminMakeRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 80)).clone(34)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminMakeRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminMakeRatio.setDescription('The make ratio of each digit pulse that is forwarded. This is applicable only when forwarded output digits is all or extended and forwarded digit type is pulse.')
portVoiceAdminBreakRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 80)).clone(66)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminBreakRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminBreakRatio.setDescription('The break ratio of each digit pulse that is forwarded. This is applicable only when forwarded output digits is all or extended and forwarded digit type is pulse.')
portVoiceAdminDTMFOnDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminDTMFOnDuration.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminDTMFOnDuration.setDescription('The length of a tone that will be used to produce a single DTMF digit. This is applicable only when forwarded output digits is all or extended and forwarded digit type is DTMF.')
portVoiceAdminDTMFOffDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminDTMFOffDuration.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminDTMFOffDuration.setDescription('The length of silence between DTMF tones in a dial digit string. This is applicable only when forwarded output digits is all or extended and forwarded digit type is DTMF.')
portVoiceAdminToneType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("mf", 2))).clone('dtmf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminToneType.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminToneType.setDescription('The tone type to detect/regenerate for forwarding DTMF/MF.')
portVoiceAdminRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 1, 1, 35), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceAdminRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceAdminRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the portVoiceAdminTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device, and which is supplied by a management station wishing to exercise an on-line update of the existing conceptual row. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
portVoiceOperTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2), )
if mibBuilder.loadTexts: portVoiceOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperTable.setDescription('A list of Voice ports. The number of entries will be the number of Voice ports on the node.')
portVoiceOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portVoiceOperRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "portVoiceOperPortIndex"))
if mibBuilder.loadTexts: portVoiceOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperEntry.setDescription('A Voice Port entry containing objects relating to the port that are configurable by the user.')
portVoiceOperRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperRlpIndex.setDescription('The RLP number of the Voice port.')
portVoiceOperPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperPortIndex.setDescription('The Port number of the Voice port.')
portVoiceOperBlockedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperBlockedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperBlockedFlag.setDescription('The flag which causes the port to be enabled or disabled at node IPL. The port will remain in that state until this flag is changed and the node is rebooted, or until an on- line enable or disable is performed.')
portVoiceOperSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps-4800", 1), ("bps-8000", 2), ("bps-32000", 3), ("bps-64000", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperSpeed.setDescription('The speed of the port which is transmitted as part of a Call Setup frame. A Voice call will be established if there is enough bandwidth at each end to provide the minimum configured rate.')
portVoiceOperDTMF = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperDTMF.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperDTMF.setDescription('The flag to enable, disable, or specify a time span over which DTMF (Dual Tone Multi Frequency) tones will be regenerated. 0 = pass tones transparently to the remote device. 1 = detect incoming tones and regenerate as received. 2-255 = regenerate tones for the specified seconds.')
portVoiceOperInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 10, 11))).clone(namedValues=NamedValues(("em-4w", 1), ("em-2w", 2), ("loop-start", 3), ("ac15-a", 4), ("ac15-b", 6), ("em-4w-te", 10), ("em-2w-te", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperInterface.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperInterface.setDescription('The type of interface (in conjunction with the Telephony Interface Type) that will be used by the Voice channel. This requires rebooting for the change to take effect. Telephony Type Interface Type -------------- -------------- OPX (FXO) Loop Start SLT (FXS) Loop Start E&M 4W E&M, 4W E&M TE, 2W E&M, 2W E&M TE AC15 AC15A, AC15C')
portVoiceOperTETimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperTETimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperTETimer.setDescription("The delay at which the E&M 'E' lead follows the 'M' lead.")
portVoiceOperLevelIn = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-22, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperLevelIn.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperLevelIn.setDescription('The local voice level into the voice port. This adjusts the sensitivity of the local voice channel to the signal from the attached device. The purpose of this is to match the voice channel dB level to the input signal. A more negative setting produces a higher input gain. If the level is reduced, the voice channel will be more sensitive to the input. This will also cause the voice output at the remote device to sound louder.')
portVoiceOperLevelOut = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-22, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperLevelOut.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperLevelOut.setDescription('The local voice level out of the voice port. A more positive setting produces a higher volume.')
portVoiceOperCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperCallTimer.setDescription('The amount of time the node will wait for a response to a Call Connect or Call Clear request. When the node issues a request, it will set a timer to the value configured here. If that timer expires with no response from the destination, the node will generate a busy tone.')
portVoiceOperHuntGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("a", 2), ("b", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperHuntGroup.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperHuntGroup.setDescription('The hunt group that includes the voice channel.')
portVoiceOperLongDialPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperLongDialPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperLongDialPrefix.setDescription('The character that will be required preceeding calls using the long call format. When the user at an attached device dials a long form number, it must be preceeded by the prefix character specified here.')
portVoiceOperSLTTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperSLTTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperSLTTimeout.setDescription('The time the local port will wait before an actual fax transmission begins. If there is no fax tone when this timer expires, the connection will be terminated.')
portVoiceOperLinkDownBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperLinkDownBusy.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperLinkDownBusy.setDescription('This flag enables or disables automatic busy-out of channels when the link is down. When enabled, the system will automatically busy-out channels when the composite link is down. When disabled, channels remain on-hook when the link is down. If your application is connected to a PBX that can route calls to another alternate source based on an all busy condition, enable this so the PBX will recognize this condition and reroute the calls while the composite link is down.')
portVoiceOperFaxSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperFaxSupported.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperFaxSupported.setDescription('The flag to indicate whether or not faxes will be transmitted on the port. If no, all calls will be treated as voice. If yes, both voice and fax will be transmitted.')
portVoiceOperTelephonyType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("opx", 1), ("slt", 2), ("em", 3), ("ac15", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperTelephonyType.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperTelephonyType.setDescription('The type of interface (in conjunction with the Interface Type) that will be used by the Voice channel. This requires rebooting for the change to take effect. Telephony Type Interface Type -------------- -------------- OPX (FXO) Loop Start SLT (FXS) Loop Start E&M 4W E&M, 4W E&M TE, 2W E&M, 2W E&M TE AC15 AC15A, AC15C')
portVoiceOperJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperJitter.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperJitter.setDescription('The amount of jitter delay.')
portVoiceOperSampleDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperSampleDelay.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperSampleDelay.setDescription('The amount of sample delay.')
portVoiceOperDialTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperDialTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperDialTimer.setDescription('The delay the node will use to determine when variable length dialing is complete. (Variable length dialing allows the user to place a call without entering the configured number of digits for the speed dial number.)')
portVoiceOperAutoDial = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperAutoDial.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperAutoDial.setDescription('The flag to enable or disable the auto dial feature. Note that enabling this feature will disable the variable length dialing feature for this channel.')
portVoiceOperSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("very-low", 1), ("low", 2), ("medium", 3), ("high", 4), ("very-high", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperSuppression.setDescription('The silence suppression level. A larger silence suppression level allows more data channels to operate simultaneously with the voice channels.')
portVoiceOperAutoDialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperAutoDialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperAutoDialNumber.setDescription('The number to which the node will attempt to connect when the handset attached to this port is taken off-hook. This is applicable only when the Auto Dial feature is enabled.')
portVoiceOperAutoPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperAutoPoll.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperAutoPoll.setDescription('The flag to enable or disable auto polling. This is applicable only when the Auto Dial feature is enabled. When enabled, the node periodically polls the destination. If the poll is not acknowledged, the node will busy-out the channel. This can be useful in situations where the destination is an emergency number that must always be available. If the destination does not answer the automatic poll, the busy-out condition will notify an attached PBX that the emergency call should be routed to another call routing device.')
portVoiceOperAutoPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperAutoPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperAutoPollTimer.setDescription('The frequency with which an Auto Poll will be sent. This is applicable only when auto poll is enabled.')
portVoiceOperExtDigitsSource = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("map", 1), ("user", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperExtDigitsSource.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperExtDigitsSource.setDescription('The source of the extended digits when the user of attached equipment dials a speed dial number. This is applicable only when the number of extended dial digits is greater than zero. When map is specified, extended digits are taken from the extended digits field in the map table. When user is specified, extended digits are taken from the user of attached equipment.')
portVoiceOperNumDigitsDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperNumDigitsDelete.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperNumDigitsDelete.setDescription('The number of leading dial digits that will be deleted before a dial string is forwarded. This is primarily used to delete leading dial digits that may be inserted by an attached PBX.')
portVoiceOperForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperForwardDelay.setDescription('The length of a pause that can be inserted in an extended dial string that is being forwarded. This is applicable only when forwarded output digits is all or extended. When a comma is encountered in an extended digits string, the node will pause for the length of time specified here before additional extended digits are forwarded.')
portVoiceOperForwardedType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("pulse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperForwardedType.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperForwardedType.setDescription('The method how the dial digits will be forwarded. This is applicable only when forwarded output digits is all or extended.')
portVoiceOperForwardedDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("all", 2), ("extended", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperForwardedDigits.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperForwardedDigits.setDescription('The flag indicating which dial digits, if any, to forward. If none, dial digits are not forwarded to the destination device when a call is initiated on this channel. If all, the dialed speed dial number and associated extended digits are forwarded to the destination device. If extended, only the extended digit string is forwarded.')
portVoiceOperMakeRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperMakeRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperMakeRatio.setDescription('The make ratio of each digit pulse that is forwarded. This is applicable only when forwarded output digits is all or extended and forwarded digit type is pulse.')
portVoiceOperBreakRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperBreakRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperBreakRatio.setDescription('The break ratio of each digit pulse that is forwarded. This is applicable only when forwarded output digits is all or extended and forwarded digit type is pulse.')
portVoiceOperDTMFOnDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperDTMFOnDuration.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperDTMFOnDuration.setDescription('The length of a tone that will be used to produce a single DTMF digit. This is applicable only when forwarded output digits is all or extended and forwarded digit type is DTMF.')
portVoiceOperDTMFOffDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperDTMFOffDuration.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperDTMFOffDuration.setDescription('The length of silence between DTMF tones in a dial digit string. This is applicable only when forwarded output digits is all or extended and forwarded digit type is DTMF.')
portVoiceOperToneType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 3, 8, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dtmf", 1), ("mf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portVoiceOperToneType.setStatus('mandatory')
if mibBuilder.loadTexts: portVoiceOperToneType.setDescription('The tone type to detect/regenerate for forwarding DTMF/MF.')
nlInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4))
nlIfTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 1), )
if mibBuilder.loadTexts: nlIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfTable.setDescription('A Table to describe each interface on a node. This table is indexed by RLP and Port number and can be used to identify the corresponding MIB-II ifIndex of a Port as well as additional port information maintained by Netlink.')
nlIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfPort"))
if mibBuilder.loadTexts: nlIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfEntry.setDescription('An Interface entry containing objects relating to interfaces.')
nlIfRlp = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfRlp.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfRlp.setDescription('The RLP number on the node. RLP numbers 1-8 are Physical RLP cards, and RLP number 250, 251 and 252 define IP, IPX and LLC2 interfaces respectively.')
nlIfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfPort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfPort.setDescription('The Port number on the RLP. Port numbers 1-8 are known to be physical ports, and 9-64 are logical ports. If the RLP number identifies an IP, IPX or LLC2 interface, then the port number can be 1-257 (IP), 1-64 (IPX), or 1-96 (LLC2).')
nlIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 200, 201, 202, 203, 204, 205, 206, 207, 208))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddnX25", 4), ("rfc877x25", 5), ("ethernetCsmacd", 6), ("iso88023Csmacd", 7), ("iso88024TokenBus", 8), ("iso88025TokenRing", 9), ("iso88026Man", 10), ("starLan", 11), ("proteon10Mbit", 12), ("proteon80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frameRelay", 32), ("rs232", 33), ("para", 34), ("arcnet", 35), ("arcnetPlus", 36), ("atm", 37), ("miox25", 38), ("sonet", 39), ("x25ple", 40), ("iso88022llc", 41), ("localTalk", 42), ("smdsDxi", 43), ("frameRelayService", 44), ("v35", 45), ("hssi", 46), ("hippi", 47), ("modem", 48), ("aal5", 49), ("sonetPath", 50), ("sonetVT", 51), ("smdsIcip", 52), ("propVirtual", 53), ("propMultiplexor", 54), ("trunk", 200), ("async", 201), ("bsci", 202), ("logicalPort", 203), ("t1", 204), ("ip", 205), ("ipx", 206), ("llc2", 207), ("voice", 208)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfType.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfType.setDescription('The type of interface')
nlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIndex.setDescription('The associated index into the MIB-II ifTable for this port')
nlIfTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfTableIndex.setDescription('The associated index into an enterprise table used to describe additional information for this port. See nlIfTableOid as the pointer to the actual table.')
nlIfTableOid = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfTableOid.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfTableOid.setDescription('The OID of the table Entry that contains additional information about this port. The OID will point to a specific table depending on the type of port.')
nlIfConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13))).clone(namedValues=NamedValues(("none", 2), ("rs232", 3), ("v25bis-dial", 4), ("v35", 5), ("rs449", 6), ("rs530", 7), ("x21", 8), ("csudsu", 9), ("t1", 10), ("e1", 11), ("voice", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfConnectorType.setDescription('The physical connector type used for this port. Valid for ports 1-8 only.')
nlIfPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("linkUp", 1), ("restarting", 2), ("operational", 3), ("disabled", 4), ("disconnect", 5), ("configured", 6), ("dialReady", 7), ("quiesced", 8), ("failed", 9), ("hardwareFault", 10), ("other", 11), ("ipl", 12), ("na", 13), ("remoteLoopback", 14), ("blueAlarm", 15), ("yellowAlarm", 16), ("redAlarm", 17), ("onHook", 18), ("offHook", 19), ("dialing", 20), ("activeVoiceCall", 21), ("onHookPending", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfPortStatus.setDescription('The status of this port state. Valid for ports 1-64 only.')
nlIfPhyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfPhyPort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfPhyPort.setDescription('The Underlying Physical Port number on the RLP of this logical port. Port numbers 1-8 are valid, but this field is only applicable if the nlIfPort field is 9-64.')
nlIfLlc2Interfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 2))
nlIfLlc2LANTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1), )
if mibBuilder.loadTexts: nlIfLlc2LANTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANTable.setDescription('A Table to define LLC2 interfaces over LAN.')
nlIfLlc2LANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfLlc2LANRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfLlc2LANPort"))
if mibBuilder.loadTexts: nlIfLlc2LANEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANEntry.setDescription('An LLC2 LAN Interface entry containing objects relating to LLC2 LAN interfaces.')
nlIfLlc2LANRlp = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2LANRlp.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANRlp.setDescription('The RLP number on the node. For LLC2 LAN interfaces, this must be 252.')
nlIfLlc2LANPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2LANPort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANPort.setDescription('The Port number on the RLP. For LLC2 LAN interfaces, this corresponds to the LAN card number.')
nlIfLlc2LANType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("token-ring", 2))).clone('ethernet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2LANType.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANType.setDescription('The type of the LLC2 interface- either ethernet or token ring.')
nlIfLlc2LANCard = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2LANCard.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANCard.setDescription('The LAN card that the LLC2 interface is running on.')
nlIfLlc2LANID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(4095)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2LANID.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANID.setDescription('Valid only if the type of the LLC2 LAN interface is token ring. Identifies the token ring adapter to the network.')
nlIfLlc2LANInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2LANInterface.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANInterface.setDescription('The LLC2 interface number.')
nlIfLlc2LANRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2LANRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlIfLlc2LANTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlIfLlc2LANPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2LANPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANPriority.setDescription('Interface priority- allows setting a priority for traffic within the node. The higher the number, the higher the priority relative to other intra-nodal traffic.')
nlIfLlc2LANBlockedPortFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2LANBlockedPortFlag.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2LANBlockedPortFlag.setDescription('The blocked port flag.')
nlIfLlc2FrTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2), )
if mibBuilder.loadTexts: nlIfLlc2FrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrTable.setDescription('A Table to define LLC2 interfaces over Frame Relay.')
nlIfLlc2FrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfLlc2FrRlp"), (0, "NETLINK-SPECIFIC-MIB", "nlIfLlc2FrPort"), (0, "NETLINK-SPECIFIC-MIB", "nlIfLlc2FrDLCI"), (0, "NETLINK-SPECIFIC-MIB", "nlIfLlc2FrFormat"))
if mibBuilder.loadTexts: nlIfLlc2FrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrEntry.setDescription('An LLC2 FR Interface entry containing objects relating to LLC2 FR interfaces.')
nlIfLlc2FrRlp = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2FrRlp.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrRlp.setDescription('The RLP number on the node.')
nlIfLlc2FrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2FrPort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrPort.setDescription('The Port number on the RLP. Port numbers 1-8 are known to be physical ports, and channels are 193-241.')
nlIfLlc2FrDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2FrDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrDLCI.setDescription('The DLCI number used to identify the entry in the table. The range is 16-991. ')
nlIfLlc2FrFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("native-llc2", 1), ("tb-8023", 2), ("srb-8025", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2FrFormat.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrFormat.setDescription('The RFC1490 encapsulation method used for LLC2 traffic.')
nlIfLlc2FrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrPriority.setDescription('Interface priority- allows setting a priority for traffic within the node. The higher the number, the higher the priority relative to other intra-nodal traffic.')
nlIfLlc2FrBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrBAG.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrBAG.setDescription('Assigns the interface to one of sixteen groups whose parameters regulate bandwidth usage.')
nlIfLlc2FrHostMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 7), MacAddress().clone(hexValue="400000000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrHostMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrHostMACAddress.setDescription('The MAC address of the host or workstation to which the remote device needs to connect. Valid only if the format is native-llc2.')
nlIfLlc2FrSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("terminated", 1), ("originated", 2), ("not-applicable", 3))).clone('originated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrSessionType.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrSessionType.setDescription('If originated, means that LLC2 connects from the configured Host MAC address can use this interface. If terminated, connections to the configured address can use this interface. Valid only if the format is native-llc2.')
nlIfLlc2FrLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(4095)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrLANID.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrLANID.setDescription('Identifies the ring number used by a frame relay-compliant source-route bridge at the other end of this PVC. Valid only if the format is srb-8025.')
nlIfLlc2FrInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfLlc2FrInterface.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrInterface.setDescription('LLC2 interface number.')
nlIfLlc2FrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlIfLlc2FrTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlIfLlc2FrBlockedPortFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfLlc2FrBlockedPortFlag.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfLlc2FrBlockedPortFlag.setDescription('The blocked port flag.')
ipxConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 3))
ipxConfigRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1))
ipxStaticRouteConfigTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 1), )
if mibBuilder.loadTexts: ipxStaticRouteConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStaticRouteConfigTable.setDescription('The IPX Static Route Configuration Table')
ipxStaticRouteConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "ipxStaticRouteConfigCircIndex"), (0, "NETLINK-SPECIFIC-MIB", "ipxStaticRouteConfigNetNum"))
if mibBuilder.loadTexts: ipxStaticRouteConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStaticRouteConfigEntry.setDescription('Each entry corresponds to one instance of IPX Static Routing on the system')
ipxStaticRouteConfigCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxStaticRouteConfigCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStaticRouteConfigCircIndex.setDescription('The unique identifier of the circuit used to reach the first hop in the static route')
ipxStaticRouteConfigNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxStaticRouteConfigNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStaticRouteConfigNetNum.setDescription("The IPX network number of the route's destination")
ipxStaticRouteConfigRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxStaticRouteConfigRouter.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStaticRouteConfigRouter.setDescription("The hex value of the node address of the router that will forward a packet when this route is used. If Novell's IPXWAN is used on the interface, this field will be ignored ")
ipxStaticRouteConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxStaticRouteConfigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipxStaticRouteConfigRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the ipxStaticRouteTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
ipxServConfigTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2), )
if mibBuilder.loadTexts: ipxServConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigTable.setDescription('The IPX Static Route Configuration Table')
ipxServConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "ipxServConfigServiceType"), (0, "NETLINK-SPECIFIC-MIB", "ipxServConfigServName"))
if mibBuilder.loadTexts: ipxServConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigEntry.setDescription('Each entry corresponds to one instance of IPX Static Routing on the system')
ipxServConfigServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxServConfigServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigServiceType.setDescription('The Service Type, a SAP service code ')
ipxServConfigServName = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxServConfigServName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigServName.setDescription('The Sercice Name, identifies a specific server in the IPX network. ')
ipxServConfigServNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 3), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigServNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigServNetworkAddress.setDescription('The IPX network number portion of the IPX address of the server identified by ServName ')
ipxServConfigServNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigServNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigServNodeAddress.setDescription('The node portion of the IPX address of the service')
ipxServConfigServSocketNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigServSocketNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigServSocketNumber.setDescription('The socket portion of the IPX address of the service')
ipxServConfigInterveningNetworks = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigInterveningNetworks.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigInterveningNetworks.setDescription('The number of routers that a packet must pass through t reach the server')
ipxServConfigGatewayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigGatewayAddress.setDescription('The node address of the router thar will forward a packet')
ipxServConfigInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigInterface.setDescription('The IPX network number assigned to the interface used to send packets that are destined for this server')
ipxServConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 1, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxServConfigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipxServConfigRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the ipxServTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
ipxConfigInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2))
ipxInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6), )
if mibBuilder.loadTexts: ipxInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceTable.setDescription('The IPX Interface Table')
ipxInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "ipxInterfaceNumber"))
if mibBuilder.loadTexts: ipxInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceEntry.setDescription('')
ipxInterfaceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInterfaceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceNumber.setDescription('The Interface Number, a sequential number to identify the interface')
ipxInterfaceBlockedPortFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceBlockedPortFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceBlockedPortFlag.setDescription('This flag causes the IPX interface to be enabled (N) or disabled (Y) at node IPL. The port will remain in that state until this parameter is changed')
ipxInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("eight025", 2), ("x25", 3), ("frl", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceType.setDescription('The interface type. 802.5 is not valid on FRX4000')
ipxInterfaceFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("typeII", 1), ("raw", 2), ("llc", 3), ("snap", 4))).clone('typeII')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceFrameType.setDescription('The frame type - depends on the interfece type. Valid combinations are: Ethernet, 802.5 - typeII, raw, llc, snap Frame relay, X25 - typeII')
ipxInterfaceMaxTransUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 5), Integer32().clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceMaxTransUnit.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceMaxTransUnit.setDescription('Maximum frame size that can be transmitted or received over the IPX interface.: Valid ranges are: Ethernet - (45-1518) 802.5 - (48-4096) Frame relay, X25 - (31-4096) ')
ipxInterfaceNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceNetworkAddress.setDescription('Identifies the local interface to the Novell Network')
ipxInterfaceBandwidthAllocGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceBandwidthAllocGroup.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceBandwidthAllocGroup.setDescription('Assigns the IPX interface to one of sixteen groups whose parameters regulate bandwidth usage')
ipxInterfacePortDiagEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfacePortDiagEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfacePortDiagEnabled.setDescription("Enables/Disables the IPX interface's ability to handle Novell diagonistics packets")
ipxInterfaceNetBIOSEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceNetBIOSEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceNetBIOSEnabled.setDescription('Determines whether Novell-encapsulated NetBIOS frames received on the interface will be processed')
ipxInterfaceNetBIOSHops = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceNetBIOSHops.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceNetBIOSHops.setDescription('Maximum number of hops allowed for routing a Novell-encapsulated NetBIOS frame')
ipxInterfacePeriodicRIPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfacePeriodicRIPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfacePeriodicRIPEnabled.setDescription('Determines whether the node will originate periodic IPX Routing Information Protocol messages from this interface to inform the network that the route through this interface is viable')
ipxInterfacePeriodicRIPTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfacePeriodicRIPTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfacePeriodicRIPTimer.setDescription('This is the interval between the periodic IPX RIP broadcasts from this interface')
ipxInterfacePeriodicSAPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfacePeriodicSAPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfacePeriodicSAPEnabled.setDescription('Determines whether the node will originate periodic IPX SAP messages from this interface to inform the network which SAP entries in the routing table are viable')
ipxInterfacePeriodicSAPTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfacePeriodicSAPTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfacePeriodicSAPTimer.setDescription('The interval between the periodic SAP broadcasts from this interface')
ipxInterfaceRIPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceRIPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceRIPEnabled.setDescription('Datermines whether this interface will support RIP proceswsing ')
ipxInterfaceRIPAgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceRIPAgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceRIPAgeTimer.setDescription('This is used to delete route entries in the routing information table. The timer starts/restarts each time an entry is created/updated. If the timer expires, the router will assume that the entry is no longer valid and the entry will be deleteda from the table ')
ipxInterfaceRIPMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(54, 446)).clone(446)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceRIPMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceRIPMaxSize.setDescription('Maximum possible RIP packet size ')
ipxInterfaceSAPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSAPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSAPEnabled.setDescription('Determines whether the interface will support SAP or not ')
ipxInterfaceSAPAgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSAPAgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSAPAgeTimer.setDescription('This is used to delete route entries from the router information table. The timer starts/restars each time an entry is created/updated. If the timer expires, the router will assume that the entry is no longer valid and the entry will be deleted from the table ')
ipxInterfaceTransportTime = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceTransportTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceTransportTime.setDescription('is the time (in 55 milliseconds unit) that will normally take to forward frames out of interface. Recommmended values are 1 for LAN interfaces and 30 for WAN interfaces. A value of 0 indicates that the back to back frame forwarding is acceptable. This time is used to calculate the least cost path during routing. If IPXWAM\x7fN is (Y), Transport time will be overridden by the value calculated by IPXWAN ')
ipxInterfaceSerializationEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSerializationEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSerializationEnabled.setDescription('Determines whether NetWare file server serialization security frames will be forwarded on the interface. These broadcasts frames are used by Novell to hold informations regarding the licensing of the file server executables ')
ipxInterfaceWatchdogSpoofingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceWatchdogSpoofingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceWatchdogSpoofingEnabled.setDescription('Determines whether this interface will be used by the local node to respond to (keep alive) messages on behalf of the client workstations. Novell servers periodically issue these messages to all clients to determine whether each client is still alive ')
ipxInterfaceLanCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceLanCardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceLanCardNumber.setDescription('The card number installed in an FRX6000. The first or only LAN card installed is always 0, and the second is card 1')
ipxInterfaceWanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 3))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceWanEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceWanEnabled.setDescription("Determines whether Novell's IPXWAN protocol will be used on the interface. IPXWAN specifies a method for IPX routers to communicate across WAN links. FRX6000 and FRX4000 implement IPXWAN running over RFC 1490-complaint frame relay and RFC1356-complaint X.25")
ipxInterfaceSourceSubscriber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSourceSubscriber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSourceSubscriber.setDescription('Subscruber id that defines an IPX interface in the node, by associating itself with port 66 (a number reserved for the IPXinterface) on the RLP that has an IPX installed on it. .. Valid only for type X.25 ')
ipxInterfaceDestinationSubscriber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceDestinationSubscriber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceDestinationSubscriber.setDescription('Subscriber ID associated with the physical X.25 port that will be used for the IPX interface . .. Valid only for type X.25 ')
ipxInterfaceSVCRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSVCRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSVCRetryTimer.setDescription('The frequency with which calls will be placed to try to establish a connection .. Valid only for type X.25 ')
ipxInterfaceSVCIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSVCIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSVCIdleTimer.setDescription('is a period that an IPX connection can remain active with no traffic before the connection is cleared. .. Valid only for type X.25 ')
ipxInterfaceMaxVC = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceMaxVC.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceMaxVC.setDescription('This specifies a number of virtual circuits over which IPX traffic will be transmitted in parallel. .. Valid only for type X.25 ')
ipxInterfacePVCConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("not-applicable", 3))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfacePVCConnection.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfacePVCConnection.setDescription('Identifies this interface as one of a PVC. .. Valid only for type X.25 ')
ipxInterfaceSourceCard = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSourceCard.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSourceCard.setDescription('Identifies the location of this end of the frame relay IPX interface. .. Valid only for frame relay ')
ipxInterfaceSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSourcePort.setDescription('Identifies the location of this end of the frame relay IPX interface. .. Valid only for frame relay ')
ipxInterfaceSourceDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceSourceDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceSourceDLCI.setDescription('Identifies the location of this end of the frame relay IPX interface. .. Valid only for frame relay ')
ipxInterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 2, 6, 1, 34), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxInterfaceRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInterfaceRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the ipxInterfaceTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
ipxConfigNodeDefault = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 3))
ipxNodeDefaultConfigNetworkAddress = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 3, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNodeDefaultConfigNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNodeDefaultConfigNetworkAddress.setDescription('Identifies the node to the IPX network')
ipxNodeDefaultConfigRIPSAPGap = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNodeDefaultConfigRIPSAPGap.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNodeDefaultConfigRIPSAPGap.setDescription('The minimum delay between consecutive RIP and SAP transmissions')
ipxNodeDefaultConfigRouterName = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 4, 3, 3, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxNodeDefaultConfigRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNodeDefaultConfigRouterName.setDescription('An unique identifier within the IPX network')
nlIfIpInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 4))
nlIfIpTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1), )
if mibBuilder.loadTexts: nlIfIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpTable.setDescription('A Table to define IP interfaces over frame relay, X.25, or LAN (ethernet, 802.3, 802.5).')
nlIfIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfIpInterface"))
if mibBuilder.loadTexts: nlIfIpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpEntry.setDescription('An IP Interface entry containing objects relating to IP interfaces.')
nlIfIpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 257))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfIpInterface.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpInterface.setDescription('The interface number which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this number is NOT the same interface as defined by the same value of ifIndex.')
nlIfIpMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpMtu.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpMtu.setDescription('The maximum size (in bytes) of the data field that can be used to encapsulate an IP datagram for transmission over the interface. If the interface type is LAN based, then the maximum size value cannot exceed 1500.')
nlIfIpNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 3), IpAddress().clone(hexValue="FF000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpNetworkMask.setDescription('The mask used during routing to determine the portion of the address associated with the network.')
nlIfIpRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpRouteMetric.setDescription('The number of network hops (network gateways in the overall path over the internet) associated with this interface.')
nlIfIpICMPAddRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpICMPAddRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpICMPAddRoutes.setDescription('The flag which indicates whether IP may add routes obtained by ICMP, whose error and control function is used to send re-direction options back to the source if problems are discovered.')
nlIfIpRIPDeltaUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpRIPDeltaUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpRIPDeltaUpdates.setDescription('The frequency with which RIP messages will be sent to every neighbor node, containing any changes to the routing table that occurred since the last full update.')
nlIfIpRIPFullUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpRIPFullUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpRIPFullUpdates.setDescription('The frequency with which updates of the entire routing table will be sent to every neighbor node, via one or more RIP messages.')
nlIfIpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpPriority.setDescription('The priority setting for traffic within the node. The higher the number, the higher the priority relative to other intra-nodal traffic.')
nlIfIpBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpBAG.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpBAG.setDescription('The bandwidth allocation group to which this interface is assigned to. This object is only valid when the interface type is frame relay or proprietary virtual.')
nlIfIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 9, 32, 53))).clone(namedValues=NamedValues(("other", 1), ("rfc877x25", 5), ("ethernetCsmacd", 6), ("iso88023Csmacd", 7), ("iso88025TokenRing", 9), ("frameRelay", 32), ("propVirtual", 53))).clone('rfc877x25')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpType.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpType.setDescription('The type of IP interface.')
nlIfIpSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 11), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSourceAddress.setDescription('The IP address of the end-to-end sender.')
nlIfIpDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 12), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpDestAddress.setDescription('The IP address of the end-to-end receiver. This object is only valid when the interface type is X.25 or proprietary virtual, or when the interface type is frame relay and the inverse ARP flag indicates disabled.')
nlIfIpBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 13), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpBroadcastAddress.setDescription('The IP address that is used to send to all LAN hosts on the network. This object is only valid when the interface type is LAN based.')
nlIfIpLANCard = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpLANCard.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpLANCard.setDescription('The LAN card that contains the interface. This object is only valid when the interface type is LAN based.')
nlIfIpSourceSub = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 15), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSourceSub.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSourceSub.setDescription('The subscriber ID associated with the source IP interface port. This object is only valid when the interface type is X.25.')
nlIfIpDestSub = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 16), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpDestSub.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpDestSub.setDescription('The subscriber ID associated with the destination IP interface port. This object is only valid when the interface type is X.25.')
nlIfIpSVCRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSVCRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSVCRetryTimer.setDescription('The frequency with which calls will be placed to try to establish a connection. This object is only valid when the interface type is X.25.')
nlIfIpSVCIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSVCIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSVCIdleTimer.setDescription('The period that an IP connection remains active with no traffic before the connection is cleared. This object is only valid when the interface type is X.25.')
nlIfIpMaxSVC = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpMaxSVC.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpMaxSVC.setDescription('The number of virtual circuits over which IP traffic will be transmitted in parallel. This object is only valid when the interface type is X.25.')
nlIfIpPVCConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpPVCConnection.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpPVCConnection.setDescription('The flag which indicates whether this interface is a PVC. This object is only valid when the interface type is X.25.')
nlIfIpSourceRlp = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSourceRlp.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSourceRlp.setDescription('The RLP of the logical interface of this end of the frame relay link. This object is only valid when the interface type is frame relay.')
nlIfIpSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSourcePort.setDescription('The port of the logical interface of this end of the frame relay link. This object is only valid when the interface type is frame relay.')
nlIfIpSourceDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSourceDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSourceDLCI.setDescription('The DLCI of the logical interface of this end of the frame relay link. This object is only valid when the interface type is frame relay.')
nlIfIpRIPSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("receive-only", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpRIPSupport.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpRIPSupport.setDescription('The RIP support that is being run on the interface.')
nlIfIpInverseARP = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpInverseARP.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpInverseARP.setDescription('The flag which indicates whether inverse ARP is enabled or disabled. This object is only valid when the interface type is frame relay.')
nlIfIpProxyARP = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpProxyARP.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpProxyARP.setDescription('The flag which indicates whether proxy ARP is enabled or disabled. This object is only valid when the interface type is LAN based.')
nlIfIpUnnumberedIf = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpUnnumberedIf.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpUnnumberedIf.setDescription('The flag which indicates whether this interface is an unnumbered interface (i.e., does not require a specific source IP address). This object is only valid when the interface type is frame relay or X.25.')
nlIfIpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 1, 1, 28), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlIfIpTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlIfIpSecondaryAddrTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2), )
if mibBuilder.loadTexts: nlIfIpSecondaryAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrTable.setDescription('A Table to define secondary IP interfaces on a LAN (ethernet, 802.3, 802.5) interface.')
nlIfIpSecondaryAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfIpInterface"), (0, "NETLINK-SPECIFIC-MIB", "nlIfIpSecondaryAddrSequence"))
if mibBuilder.loadTexts: nlIfIpSecondaryAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrEntry.setDescription('An IP Secondary Address entry containing objects relating to IP secondary addresses.')
nlIfIpSecondaryAddrSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrSequence.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrSequence.setDescription('The maximum number of secondary IP addresses that may be configured on an interface.')
nlIfIpSecondaryAddrNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrNetworkMask.setDescription('The mask used during routing to determine the portion of the address associated with the network.')
nlIfIpSecondaryAddrRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrRouteMetric.setDescription('The number of network hops (network gateways in the overall path over the internet) associated with this interface.')
nlIfIpSecondaryAddrSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrSourceAddress.setDescription('The IP address of the end-to-end sender.')
nlIfIpSecondaryAddrBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrBroadcastAddress.setDescription('The IP address that is used to send to all LAN hosts on the network.')
nlIfIpSecondaryAddrRIPSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("receive-only", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrRIPSupport.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrRIPSupport.setDescription('The RIP support that is being run on the interface.')
nlIfIpSecondaryAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 4, 2, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfIpSecondaryAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfIpSecondaryAddrRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlIfIpSecondaryAddrTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlIfVoiceInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 4, 5))
nlIfVoiceTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1), )
if mibBuilder.loadTexts: nlIfVoiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceTable.setDescription('A Table to define Voice interfaces over frame relay.')
nlIfVoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlIfVoiceInterface"))
if mibBuilder.loadTexts: nlIfVoiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceEntry.setDescription('A Voice Interface entry containing objects relating to the interface that are configurable by the user.')
nlIfVoiceInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 129))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlIfVoiceInterface.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceInterface.setDescription('The interface number which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this number is NOT the same interface as defined by the same value of ifIndex.')
nlIfVoicePeerNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("netlink", 1), ("act", 2))).clone('act')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoicePeerNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoicePeerNodeType.setDescription('The node type for the node at the remote end of the frame relay connection.')
nlIfVoicePeerNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 61)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoicePeerNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoicePeerNodeNumber.setDescription('The node number of the remote device.')
nlIfVoicePeerNodePort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoicePeerNodePort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoicePeerNodePort.setDescription('The voice port on the remote device.')
nlIfVoiceLocalNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 61)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceLocalNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceLocalNodeNumber.setDescription('The node number of the local device.')
nlIfVoiceLocalNodePort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceLocalNodePort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceLocalNodePort.setDescription('The voice port on the local device.')
nlIfVoiceFrameRelayRlp = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceFrameRelayRlp.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceFrameRelayRlp.setDescription('The RLP of the logical interface of this end of the frame relay link.')
nlIfVoiceFrameRelayPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceFrameRelayPort.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceFrameRelayPort.setDescription('The port of the logical interface of this end of the frame relay link.')
nlIfVoiceFrameRelayDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceFrameRelayDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceFrameRelayDLCI.setDescription('The DLCI of the logical interface of this end of the frame relay link.')
nlIfVoiceEnableFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceEnableFragment.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceEnableFragment.setDescription('')
nlIfVoiceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 4, 5, 1, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIfVoiceRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlIfVoiceRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the noIfVoiceTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
subscriber = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 5))
nlLocalSubscriberTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 5, 1), )
if mibBuilder.loadTexts: nlLocalSubscriberTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberTable.setDescription('A Table to define each local subscriber.')
nlLocalSubscriberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlLocalSubscriberId"))
if mibBuilder.loadTexts: nlLocalSubscriberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberEntry.setDescription('A Local Subscriber entry containing objects relating to local subscribers.')
nlLocalSubscriberId = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 1), NlSubscriberAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLocalSubscriberId.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberId.setDescription("The Subscriber ID. A valid subscriber ID is a string of numeric digits represented by their ASCII equivalents. The ASCII equivalents of the wildcard characters '*' and '?' are also allowed. A '*' is a wildcard that matches any number of digits, including zero. A '?' is a wildcard that matches any single digit.")
nlLocalSubscriberName = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLocalSubscriberName.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberName.setDescription('The Subscriber name. The subscriber name is not accessible from SNMP, and a blank string is always returned.')
nlLocalSubscriberAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("round-robin", 1), ("line-failed", 2), ("line-busy", 3), ("least-lcn", 4))).clone('round-robin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberAlgorithm.setDescription("The Subscriber routing algorithm. The following 4 types of routing algorithms are supported. 1 - round robin selects ports specified cyclicly in numerical order according to the list of Redirection addresses. If the port is unreachable or congested, the call request is sent to the next port. 2. Alternate Route on Line Failure - selects the first port not in a failed state. If a connection is not made, the call will be cleared even if other ports are available. 3. Alternate Route on Line Busy - selects the first port that has LCN's available (not busy). If a port has failed, the next available port is selected. 4. Least LCN with throughput selects the line with the minumum loading, calculated by weight and number of LCN's in use. If use of a routing algorithm is not desired, accept the default and specify only one routing path.")
nlLocalSubscriberSystematicRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberSystematicRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberSystematicRedirect.setDescription('Systematic Redirection.')
nlLocalSubscriberRedirectBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRedirectBusy.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirectBusy.setDescription('Redirect calls according to Redirection Addresses if the primary subscriber device is busy.')
nlLocalSubscriberRedirectOO = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRedirectOO.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirectOO.setDescription('Redirect calls according to Redirection Addresses if the primary subscriber device is out of order.')
nlLocalSubscriberPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberPriority.setDescription('Allows setting a priority for traffic within the node.')
nlLocalSubscriberRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 1, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlLocalSubscriberTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlLocalSubscriberRouteTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 5, 2), )
if mibBuilder.loadTexts: nlLocalSubscriberRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRouteTable.setDescription('A Table to define local subscriber route paths.')
nlLocalSubscriberRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 5, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlLocalSubscriberId"), (0, "NETLINK-SPECIFIC-MIB", "nlLocalSubscriberRouteIndex"))
if mibBuilder.loadTexts: nlLocalSubscriberRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRouteEntry.setDescription('A Local Subscriber Route entry containing objects relating to local subscriber routes.')
nlLocalSubscriberRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLocalSubscriberRouteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRouteIndex.setDescription('Route path index for a specific subscriber route path.')
nlLocalSubscriberRouteConf = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLocalSubscriberRouteConf.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRouteConf.setDescription('Flag to indicate if the LP/port routing path to the subscriber device is configured or not. This object is read- only. The route is always configured for an entry in the table.')
nlLocalSubscriberRouteLP = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRouteLP.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRouteLP.setDescription('Instance of the LP that makes up the routing path')
nlLocalSubscriberRoutePort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRoutePort.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRoutePort.setDescription('Instance of the port that makes up the routing path')
nlLocalSubscriberRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRouteRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlLocalSubscriberRouteTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlLocalSubscriberRedirTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 5, 3), )
if mibBuilder.loadTexts: nlLocalSubscriberRedirTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirTable.setDescription('A Table to list local subscriber redirection addresses.')
nlLocalSubscriberRedirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 5, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlLocalSubscriberId"), (0, "NETLINK-SPECIFIC-MIB", "nlLocalSubscriberRedirIndex"))
if mibBuilder.loadTexts: nlLocalSubscriberRedirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirEntry.setDescription('A Local Subscriber Redirection Address entry containing objects relating to local subscriber redirection addresses.')
nlLocalSubscriberRedirIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLocalSubscriberRedirIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirIndex.setDescription('Redirection entry index for a local subscriber.')
nlLocalSubscriberRedirAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 3, 1, 2), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRedirAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirAddr.setDescription('Subscriber redirection address.')
nlLocalSubscriberRedirRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 5, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLocalSubscriberRedirRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlLocalSubscriberRedirRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlLocalSubscriberRedirTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
llc2 = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 6))
nlLlc2HostTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 6, 1), )
if mibBuilder.loadTexts: nlLlc2HostTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostTable.setDescription('A Table to define LLC2 host entries.')
nlLlc2HostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlLlc2HostGroup"), (0, "NETLINK-SPECIFIC-MIB", "nlLlc2HostIndex"))
if mibBuilder.loadTexts: nlLlc2HostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostEntry.setDescription('An LLC2 Host entry containing objects relating to LLC2 hosts.')
nlLlc2HostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 251))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2HostIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostIndex.setDescription('LLC2 Host Index')
nlLlc2HostMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 2), MacAddress().clone(hexValue="400000000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostMACAddress.setDescription('The LLC2 Host MAC Address.')
nlLlc2HostSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("originated", 1), ("terminated", 2))).clone('terminated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostSessionType.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostSessionType.setDescription('The mode in which the Host is operating')
nlLlc2HostT1ReplyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 4), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(1, 250)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostT1ReplyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostT1ReplyTimer.setDescription('Reply Timer used to detect a failure of the Remote node.')
nlLlc2HostT2RecvAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 5), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(100, 5000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostT2RecvAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostT2RecvAckTimer.setDescription('Receive Ack Timer used to delay sending an acknowledgement of a received information LPDU.')
nlLlc2HostTiInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 6), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostTiInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostTiInactivityTimer.setDescription('Timer used to detect inoperative condition of the remote link station or transmission medium.')
nlLlc2HostN3NumberLPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostN3NumberLPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostN3NumberLPDUs.setDescription('The number of Information LPDUs that need to be received before an acknowledgement is sent.')
nlLlc2HostTwNumberOutstanding = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostTwNumberOutstanding.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostTwNumberOutstanding.setDescription('Maximum number of sequentially numbered information LPDUs that can be outstanding at any time.')
nlLlc2HostN2ExpiredT1LPDUCount = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostN2ExpiredT1LPDUCount.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostN2ExpiredT1LPDUCount.setDescription('Maximum number of LPDU retransmissions occur following the expiration of Timer T1.')
nlLlc2HostPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostPriority.setDescription('Traffic priorities within the node.')
nlLlc2HostBAG = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2HostBAG.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostBAG.setDescription('Bandwidth Allocation group to which the LLC2 Host belongs. This object is read-only. Bandwidth allocation groups do not apply to LLC2 hosts.')
nlLlc2HostRoutingSubscriberId = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 12), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostRoutingSubscriberId.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostRoutingSubscriberId.setDescription('LLC2 hosts Routing Subscriber Id')
nlLlc2HostSrcMACAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 13), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostSrcMACAddressMask.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostSrcMACAddressMask.setDescription("LLC2 Host's Source MAC Address Mask")
nlLlc2HostAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lan", 1), ("frameRelay", 2), ("tokenRing", 3), ("ethernet", 4), ("all", 5), ("not-applicable", 6))).clone('not-applicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2HostAccess.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostAccess.setDescription('Specifies different type(s) of interface(s) that can be used for connections to a terminated host session.')
nlLlc2HostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 15), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2HostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostRowStatus.setDescription('Row status convention for LLC2 Host entry.')
nlLlc2HostInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 16), Integer32().clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2HostInterface.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostInterface.setDescription('LLC2 interface number associated with this host entry, always 300 for non-FRX7000.')
nlLlc2HostGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2HostGroup.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2HostGroup.setDescription('Traffic group associated with LLC2 interface, always 1 for non-FRX7000.')
nlLlc2TermConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 6, 2), )
if mibBuilder.loadTexts: nlLlc2TermConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionTable.setDescription('A Table to describe LLC2 Terminated Host Connections.')
nlLlc2TermConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 6, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlLlc2HostGroup"), (0, "NETLINK-SPECIFIC-MIB", "nlLlc2HostIndex"), (0, "NETLINK-SPECIFIC-MIB", "nlLlc2TermConnectionSequence"))
if mibBuilder.loadTexts: nlLlc2TermConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionEntry.setDescription('An LLC2 Terminated Host Connection entry containing objects relating to LLC2 terminated host connections.')
nlLlc2TermConnectionSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2TermConnectionSequence.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionSequence.setDescription('LLC2 Host connection Sequence number')
nlLlc2TermConnectionHSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2TermConnectionHSAP.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionHSAP.setDescription('Service Access point used to connect to the Host')
nlLlc2TermConnectionLocalSubscriberId = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 2, 1, 3), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2TermConnectionLocalSubscriberId.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionLocalSubscriberId.setDescription("LLC2 Host Connection's Local Subscriber Id")
nlLlc2TermConnectionRemoteSubscriberId = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 2, 1, 4), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2TermConnectionRemoteSubscriberId.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionRemoteSubscriberId.setDescription("LLC2 Host Connection's Remote Subscriber Id")
nlLlc2TermConnectionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2TermConnectionRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2TermConnectionRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlLlc2TermConnectionTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlLlc2OrigConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 6, 3), )
if mibBuilder.loadTexts: nlLlc2OrigConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionTable.setDescription('A Table to describe LLC2 Originated Host Connections.')
nlLlc2OrigConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "nlLlc2HostGroup"), (0, "NETLINK-SPECIFIC-MIB", "nlLlc2HostIndex"), (0, "NETLINK-SPECIFIC-MIB", "nlLlc2OrigConnectionSequence"))
if mibBuilder.loadTexts: nlLlc2OrigConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionEntry.setDescription('An LLC2 Originated Host Connection entry containing objects relating to LLC2 originated host connections.')
nlLlc2OrigConnectionSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2OrigConnectionSequence.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionSequence.setDescription('LLC2 Host connection Sequence number')
nlLlc2OrigConnectionHSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2OrigConnectionHSAP.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionHSAP.setDescription('Service Access point used to connect to the Host')
nlLlc2OrigConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sdlc", 1), ("llc2", 2))).clone('llc2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2OrigConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionType.setDescription('Specifies Remote subscriber device type')
nlLlc2OrigConnectionLocalSubscriberId = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 4), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2OrigConnectionLocalSubscriberId.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionLocalSubscriberId.setDescription("LLC2 Host Connection's Local Subscriber Id")
nlLlc2OrigConnectionRemoteSubscriberId = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 5), NlSubscriberAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2OrigConnectionRemoteSubscriberId.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionRemoteSubscriberId.setDescription("LLC2 Host Connection's Remote Subscriber Id")
nlLlc2OrigConnectionIDBLK = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2OrigConnectionIDBLK.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionIDBLK.setDescription('This field is obsolete')
nlLlc2OrigConnectionIDNUM = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2OrigConnectionIDNUM.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionIDNUM.setDescription('This field is obsolete')
nlLlc2OrigConnectionMAXDATA = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2OrigConnectionMAXDATA.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionMAXDATA.setDescription('This field is obsolete')
nlLlc2OrigConnectionMAXIN = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2OrigConnectionMAXIN.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionMAXIN.setDescription('This field is obsolete')
nlLlc2OrigConnectionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 6, 3, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlLlc2OrigConnectionRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2OrigConnectionRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the nlLlc2OrigConnectionTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
nlLlc2NextHostNumber = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 6, 4), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nlLlc2NextHostNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nlLlc2NextHostNumber.setDescription('The host number to be used for the next created host record, always 1 on non-FRX7000.')
status = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 7))
pinStatusTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 7, 4), )
if mibBuilder.loadTexts: pinStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: pinStatusTable.setDescription('A Table to describe the status of each pin on a physical port. This table is indexed by RLP and Port')
portPinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 7, 4, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portPinRlp"), (0, "NETLINK-SPECIFIC-MIB", "portPinPort"))
if mibBuilder.loadTexts: portPinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portPinEntry.setDescription('A port pin entry containing objects relating to ports.')
portPinRlp = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPinRlp.setStatus('mandatory')
if mibBuilder.loadTexts: portPinRlp.setDescription('The RLP number on the node')
portPinPort = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 7, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPinPort.setStatus('mandatory')
if mibBuilder.loadTexts: portPinPort.setDescription('The Port number on the RLP. Port numbers 0-7 are known to be physical ports.')
portPinStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 7, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPinStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portPinStatus.setDescription('The status of all pins for this physical port. There is one octet value for each of the pins. Each octet value is defined as follows: 00 = unknown 01 = active 02 = inactive 03 = unused ')
statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8))
statGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1))
rlpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2), )
if mibBuilder.loadTexts: rlpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsTable.setDescription('A Table to describe Statistics on each RLP')
rlpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "rlpStatsIndex"))
if mibBuilder.loadTexts: rlpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsEntry.setDescription('An RLP statistics entry containing objects relating to RLP statistics.')
rlpStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsIndex.setDescription('The RLP number')
rlpStatsQMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsQMessages.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsQMessages.setDescription('The number of frames queued on the RLP')
rlpStatsUsedBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsUsedBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsUsedBuffers.setDescription('The percentage of total buffers available being used at the moment of inquiry')
rlpStatsInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsInFrames.setDescription('The number of frames received.')
rlpStatsOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsOutFrames.setDescription('The number of frames transmitted.')
rlpStatsFrameRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsFrameRejects.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsFrameRejects.setDescription('The number of frames rejected.')
rlpStatsFrameRetransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpStatsFrameRetransmits.setStatus('mandatory')
if mibBuilder.loadTexts: rlpStatsFrameRetransmits.setDescription('The number of frames retransmitted . If this value is consistently greater than zero and there are no other problems, then increase the retransmission parameter.')
portStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3), )
if mibBuilder.loadTexts: portStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsTable.setDescription('A Table to describe Statistics on each RLP')
portStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portStatsRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "portStatsIndex"))
if mibBuilder.loadTexts: portStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsEntry.setDescription('A port statistics entry containing objects relating to port statistics.')
portStatsRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsRlpIndex.setDescription('The RLP number')
portStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsIndex.setDescription('The Port number')
portStatsInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsInFrames.setDescription('The number of frames received.')
portStatsOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsOutFrames.setDescription('The number of frames transmitted.')
portStatsFrameRetrans = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsFrameRetrans.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsFrameRetrans.setDescription('The number of frames retransmitted.')
portStatsFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsFCSErrors.setDescription('The number of Frame Check Sequence (FCS) errors. A value consistently greater than zero indicates line probelms.')
portStatsLogicalRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsLogicalRejects.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsLogicalRejects.setDescription('The sum of Rejects and Frame Rejects. A value consistently greater than zero indicates line probelms.')
portStatsInPercentUtils = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsInPercentUtils.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsInPercentUtils.setDescription('The ratio of non-flag characters to total characters being received by the port.')
portStatsOutPercentUtils = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsOutPercentUtils.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsOutPercentUtils.setDescription('The ration of non-flag characters to total characters being transmitted by the port.')
statFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4))
frStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1), )
if mibBuilder.loadTexts: frStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTable.setDescription('A Table to describe Frame Relay Frame Level Statistics on each Port')
frStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "frStatsRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "frStatsPortIndex"))
if mibBuilder.loadTexts: frStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsEntry.setDescription('A frame relay port statistics entry containing objects relating to frame relay port statistics.')
frStatsRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsRlpIndex.setDescription('The RLP Number.')
frStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsPortIndex.setDescription('The Port number.')
frStatsTxDEFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsTxDEFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTxDEFrames.setDescription('The number of frames transmitted on the port with the Discard Eligibility bit set.')
frStatsRxDEFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsRxDEFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsRxDEFrames.setDescription('The number of frames received on the port with the discard eligibility bit set.')
frStatsTxFECNFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsTxFECNFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTxFECNFrames.setDescription('The of number of frames transmitted on the port with FECN.')
frStatsRxFECNFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsRxFECNFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsRxFECNFrames.setDescription('The number of frames received on the port with FECN.')
frStatsTxBECNFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsTxBECNFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTxBECNFrames.setDescription('The number of frames transmitted on the port with BECN.')
frStatsRxBECNFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsRxBECNFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsRxBECNFrames.setDescription('The number of frames received on the port with BECN.')
frStatsTxLMIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsTxLMIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTxLMIFrames.setDescription('The number of LMI frames transmitted on the port.')
frStatsRxLMIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsRxLMIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsRxLMIFrames.setDescription('The number of LMI frames received on the port.')
frStatsTxANXDFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsTxANXDFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTxANXDFrames.setDescription('The number of AnnexD frames transmitted on the port')
frStatsRxANXDFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsRxANXDFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsRxANXDFrames.setDescription('The number of AnnexD frames received on the port')
frStatsTotDiscFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frStatsTotDiscFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frStatsTotDiscFrames.setDescription('The total number of discarded frames on the port.')
x25TxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2), )
if mibBuilder.loadTexts: x25TxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxStatsTable.setDescription('A Table to describe X25 Frame Level Txmit Statistics on each Port')
x25TxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "x25TxRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "x25TxPortIndex"))
if mibBuilder.loadTexts: x25TxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxStatsEntry.setDescription('An X25 frame level transmit statistics entry containing objects relating to x25 frame level transmit statistics.')
x25TxRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxRlpIndex.setDescription('The RLP Number.')
x25TxPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxPortIndex.setDescription('The Port number.')
x25TxSABMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxSABMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxSABMFrames.setDescription("The number of SABM's transmitted on the port.")
x25TxUAFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxUAFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxUAFrames.setDescription('The number of UA Frames transmitted on the port.')
x25TxDISCFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxDISCFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxDISCFrames.setDescription('The number of DISC Frames transmitted on the port.')
x25TxDMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxDMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxDMFrames.setDescription('The number of DM frames transmitted on the port.')
x25TxFRMRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxFRMRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxFRMRFrames.setDescription('The of Number of FRMR frames transmitted on the port.')
x25TxREJFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxREJFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxREJFrames.setDescription('The number of Reject Frames transmitted on the port.')
x25TxRRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxRRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxRRFrames.setDescription('The number of RR frames transmitted on the port.')
x25TxRNRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxRNRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxRNRFrames.setDescription('The number of RNR Frames transmitted on the port.')
x25TxINFOFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TxINFOFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25TxINFOFrames.setDescription('The number of INFO Frames transmitted on the port')
x25RxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3), )
if mibBuilder.loadTexts: x25RxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxStatsTable.setDescription('A Table to describe X25 Frame Level Rxmit Statistics on each Port')
x25RxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "x25RxRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "x25RxPortIndex"))
if mibBuilder.loadTexts: x25RxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxStatsEntry.setDescription('An X25 frame level receive statistics entry containing objects relating to x25 frame level receive statistics.')
x25RxRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxRlpIndex.setDescription('The RLP Number.')
x25RxPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxPortIndex.setDescription('The Port number.')
x25RxSABMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxSABMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxSABMFrames.setDescription("The number of SABM's received on the port.")
x25RxUAFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxUAFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxUAFrames.setDescription('The number of UA Frames received on the port.')
x25RxDISCFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxDISCFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxDISCFrames.setDescription('The number of DISC Frames received on the port.')
x25RxDMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxDMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxDMFrames.setDescription('The number of DM frames received on the port.')
x25RxFRMRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxFRMRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxFRMRFrames.setDescription('The of Number of FRMR frames received on the port.')
x25RxREJFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxREJFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxREJFrames.setDescription('The number of Reject Frames received on the port.')
x25RxRRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxRRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxRRFrames.setDescription('The number of RR frames received on the port.')
x25RxRNRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxRNRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxRNRFrames.setDescription('The number of RNR Frames received on the port.')
x25RxINFOFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 4, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RxINFOFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x25RxINFOFrames.setDescription('The number of INFO Frames received on the port')
statBag = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 5))
statIp = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 6))
statT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7))
t1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1), )
if mibBuilder.loadTexts: t1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsTable.setDescription('A Table to describe T1 Statistics.')
t1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "t1StatsRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "t1StatsPortIndex"))
if mibBuilder.loadTexts: t1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsEntry.setDescription('A T1 port statistics entry containing objects relating to T1 port statistics.')
t1StatsRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRlpIndex.setDescription('The RLP Number.')
t1StatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsPortIndex.setDescription('The Port Number.')
t1StatsRcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRcvFrames.setDescription('Total received frames.')
t1StatsXmitFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsXmitFrames.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsXmitFrames.setDescription('Total transmitted frames.')
t1StatsLCVCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsLCVCnt.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsLCVCnt.setDescription('Line code violation count.')
t1StatsPCVRErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsPCVRErrs.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsPCVRErrs.setDescription('PCVR Bit error count.')
t1StatsOOSCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsOOSCnt.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsOOSCnt.setDescription('Multiframe out of sync count.')
t1StatsBlueAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsBlueAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsBlueAlarms.setDescription('Blue alarm count.')
t1StatsYellowAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsYellowAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsYellowAlarms.setDescription('Yellow alarm count.')
t1StatsRedAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRedAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRedAlarms.setDescription('Red alarm count.')
t1StatsRcvUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRcvUsage.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRcvUsage.setDescription('Receive port utilization.')
t1StatsXmitUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsXmitUsage.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsXmitUsage.setDescription('Transmit port utilization.')
t1StatsXmitAbortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsXmitAbortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsXmitAbortFrames.setDescription('Total aborted transmit frames.')
t1StatsRcvAbortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRcvAbortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRcvAbortFrames.setDescription('Total aborted receive frames.')
t1StatsRcvOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRcvOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRcvOverruns.setDescription('Total receive overruns.')
t1StatsRcvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRcvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRcvErrors.setDescription('Total bad receives.')
t1StatsRcvChannelErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 7, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: t1StatsRcvChannelErrors.setStatus('mandatory')
if mibBuilder.loadTexts: t1StatsRcvChannelErrors.setDescription('Total bad receives.')
statDS0A = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8))
ds0aStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1), )
if mibBuilder.loadTexts: ds0aStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsTable.setDescription('A Table to describe DS0A Statistics.')
ds0aStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "ds0aStatsRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "ds0aStatsPortIndex"), (0, "NETLINK-SPECIFIC-MIB", "ds0aStatsChannelIndex"))
if mibBuilder.loadTexts: ds0aStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsEntry.setDescription('A DS0A port statistics entry containing objects relating to DS0A port statistics.')
ds0aStatsRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsRlpIndex.setDescription('The RLP Number.')
ds0aStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsPortIndex.setDescription('The Port Number.')
ds0aStatsChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsChannelIndex.setDescription('The Channel Number.')
ds0aStatsXmitFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsXmitFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsXmitFrames.setDescription('Total transmitted frames.')
ds0aStatsRcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsRcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsRcvFrames.setDescription('Total received frames.')
ds0aStatsRcvAbortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsRcvAbortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsRcvAbortFrames.setDescription('Total receive aborted frames.')
ds0aStatsRcvOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsRcvOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsRcvOverruns.setDescription('Total receive overruns.')
ds0aStatsRcvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 8, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0aStatsRcvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ds0aStatsRcvErrors.setDescription('Total receive errors.')
statVoice = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9))
voiceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1), )
if mibBuilder.loadTexts: voiceStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsTable.setDescription('A Table to describe Voice over Frame Relay Statistics.')
voiceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "voiceStatsRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "voiceStatsPortIndex"))
if mibBuilder.loadTexts: voiceStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsEntry.setDescription('A voice port statistics entry containing objects relating to voice port statistics.')
voiceStatsRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsRlpIndex.setDescription('The RLP Number.')
voiceStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsPortIndex.setDescription('The Port Number.')
voiceStatsRxCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsRxCalls.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsRxCalls.setDescription('The Number of Calls Received from the Network.')
voiceStatsTxCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsTxCalls.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsTxCalls.setDescription('The Number of Calls Transmitted to the Network.')
voiceStatsRxCallsAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsRxCallsAccepts.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsRxCallsAccepts.setDescription('The Number of Call Accepts Received from the Network.')
voiceStatsTxCallsAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsTxCallsAccepts.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsTxCallsAccepts.setDescription('The Number of Call Accepts Transmitted to the Network.')
voiceStatsRxClears = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsRxClears.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsRxClears.setDescription('The Number of Call Receives cleared.')
voiceStatsTxClears = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsTxClears.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsTxClears.setDescription('The Number of Call Transmitts cleared.')
voiceStatsBusyCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsBusyCalls.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsBusyCalls.setDescription('The Number of calls which received Busy indication.')
voiceStatsCallTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsCallTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsCallTimeouts.setDescription('The Number of calls which transmitted time-out to the network.')
voiceStatsRxCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsRxCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsRxCongestions.setDescription('The number of congestion management frames Received.')
voiceStatsTxCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 1, 9, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceStatsTxCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: voiceStatsTxCongestions.setDescription('The number of congestion management frames Transmitted.')
statThresh = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 8, 2))
rlpThreshTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1), )
if mibBuilder.loadTexts: rlpThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshTable.setDescription('A Table to describe Statistic thresholds on each RLP')
rlpThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "rlpThreshRlpIndex"))
if mibBuilder.loadTexts: rlpThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshEntry.setDescription('An RLP statistics threshold entry containing objects relating to RLP statistics thresholds.')
rlpThreshRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshRlpIndex.setDescription('The RLP Number.')
rlpThreshPercntBufInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshPercntBufInUse.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshPercntBufInUse.setDescription('The threshold for Percent of Buffers in use on the RLP')
rlpThreshMsgQueueLen = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshMsgQueueLen.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshMsgQueueLen.setDescription('The threshold for Percent of Buffers in use on the RLP')
rlpThreshRxFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshRxFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshRxFramesPerSec.setDescription('The threshold for Rcvd frames per second on the RLP')
rlpThreshTxFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshTxFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshTxFramesPerSec.setDescription('The threshold for Txmitted frames per second on the RLP')
rlpThreshRejFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshRejFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshRejFramesPerSec.setDescription('The threshold for Rejected Frames per second on the RLP')
rlpThreshRtxFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlpThreshRtxFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: rlpThreshRtxFramesPerSec.setDescription('The threshold for Retransmitted frames per second on the RLP')
portThreshTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2), )
if mibBuilder.loadTexts: portThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshTable.setDescription('A Table to describe Statistic thresholds on each port')
portThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "portThreshRlpIndex"), (0, "NETLINK-SPECIFIC-MIB", "portThreshIndex"))
if mibBuilder.loadTexts: portThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshEntry.setDescription('A port statistics threshold entry containing objects relating to port statistics thresholds.')
portThreshRlpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshRlpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshRlpIndex.setDescription('The RLP Number.')
portThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshIndex.setDescription('The Port Number.')
portThreshRxFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshRxFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshRxFramesPerSec.setDescription('The threshold for Rcvd frames per second on the port.')
portThreshTxFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshTxFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshTxFramesPerSec.setDescription('The threshold for Txmitted frames per second on the port.')
portThreshRtxFramesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshRtxFramesPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshRtxFramesPerSec.setDescription('The threshold for Retransmitted frames per second on the port.')
portThreshFCSErrPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshFCSErrPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshFCSErrPerSec.setDescription('The threshold for FCS errors per second on the port.')
portThreshLogRejPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshLogRejPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshLogRejPerSec.setDescription('The threshold for Logical Rejects per second on the port.')
portThreshTxErrorRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshTxErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshTxErrorRatio.setDescription('The threshold for Txmit error ratio on the port.')
portThreshRxErrorRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshRxErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshRxErrorRatio.setDescription('The threshold for Rcv error ratio on the port.')
portThreshTxPercentUtl = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshTxPercentUtl.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshTxPercentUtl.setDescription('The threshold for Txmit percent utilization on the port.')
portThreshRxPercentUtl = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 8, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portThreshRxPercentUtl.setStatus('mandatory')
if mibBuilder.loadTexts: portThreshRxPercentUtl.setDescription('The threshold for Rcv percent utilization on the port.')
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 9))
bridgeAdminVirtualLANID = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeAdminVirtualLANID.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeAdminVirtualLANID.setDescription('LAN id inserted into token ring RIF field representing internal virtual ring, for LLC2 or bridged traffic')
bridgeOperVirtualLANID = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeOperVirtualLANID.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeOperVirtualLANID.setDescription('LAN id inserted into token ring RIF field representing internal virtual ring, for LLC2 or bridged traffic')
bridgeEnabled = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeEnabled.setDescription('When yes the spanning tree algorithm is in effect and all traffic types may be bridged. When no only llc/2 terminated traffic is allowed on bridge interfaces.')
bridgeMaxSizeForwardingTable = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeMaxSizeForwardingTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeMaxSizeForwardingTable.setDescription('Number of entries allowed in the bridge forwarding table')
bridgeIPEnabled = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeIPEnabled.setDescription('When yes, and BRIDGING ENABLED, IP traffic will be bridged, otherwise IP traffic will be routed.')
bridgeIPXEnabled = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeIPXEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeIPXEnabled.setDescription('When yes, and BRIDGING ENABLED, IPX traffic will be bridged, otherwise IPX traffic will be routed.')
bridgeAdminSRBID = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeAdminSRBID.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeAdminSRBID.setDescription('bridge ID to be inserted into token ring RIF field, this bridge')
bridgeOperSRBID = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeOperSRBID.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeOperSRBID.setDescription('bridge ID to be inserted into token ring RIF field, this bridge')
bridgeDefaultEthernetFrameType = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("type-II", 1), ("ieee8023", 2))).clone('type-II')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeDefaultEthernetFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeDefaultEthernetFrameType.setDescription('default frame type to be used when forwarding traffic on ethernet interfaces.')
ipNl = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 11))
nlIpDefaultRIPVersion = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ripVersion1", 1), ("rip1Compatible", 2), ("ripVersion2", 3))).clone('ripVersion1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nlIpDefaultRIPVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nlIpDefaultRIPVersion.setDescription('The version of RIP that will be used by IP.')
voice = MibIdentifier((1, 3, 6, 1, 4, 1, 173, 7, 12))
voiceSystemVoiceNodeNum = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemVoiceNodeNum.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemVoiceNodeNum.setDescription('The number that identifies this node.')
voiceSystemRingVolFreq = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("v75-hz-16-66", 1), ("v80-hz-20-00", 2), ("v75-hz-25-00", 3), ("v60-hz-50-00", 4), ("v75-hz-50-00", 5))).clone('v80-hz-20-00')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemRingVolFreq.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemRingVolFreq.setDescription('The frequency and voltage of the telephone ring circuit. In two wire OPX mode, the node provides ring voltage to the telephone when it is called by a remote unit.')
voiceSystemCountryCode = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemCountryCode.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemCountryCode.setDescription('The telephone dialing prefix code that identifies the country in which the node is installed.')
voiceSystemDialDigits = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemDialDigits.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemDialDigits.setDescription('The number of digits that will be used in the speed dialing scheme, as well as the number of digits one can specify for the Auto Dial feature. This requires rebooting for the change to take effect.')
voiceSystemVoiceRatesMin = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps-4800", 1), ("bps-8000", 2), ("bps-32000", 3), ("bps-64000", 4))).clone('bps-4800')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemVoiceRatesMin.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemVoiceRatesMin.setDescription('The minimum operating rate of all voice channels when congestion occurs.')
voiceSystemVoiceRatesMax = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bps-4800", 1), ("bps-8000", 2), ("bps-32000", 3), ("bps-64000", 4))).clone('bps-64000')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemVoiceRatesMax.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemVoiceRatesMax.setDescription('The maximum operating digitization rate of all voice channels when there is no congestion.')
voiceSystemExtDialDigits = MibScalar((1, 3, 6, 1, 4, 1, 173, 7, 12, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSystemExtDialDigits.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSystemExtDialDigits.setDescription('The number of extended dial digits that can be defined in the speed map table and/or entered by the user of attached equipment as part of a dial string. This requires rebooting for the change to take effect.')
voiceSpeedDialTable = MibTable((1, 3, 6, 1, 4, 1, 173, 7, 12, 8), )
if mibBuilder.loadTexts: voiceSpeedDialTable.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSpeedDialTable.setDescription('A list of speed-dial numbers.')
voiceSpeedDialEntry = MibTableRow((1, 3, 6, 1, 4, 1, 173, 7, 12, 8, 1), ).setIndexNames((0, "NETLINK-SPECIFIC-MIB", "voiceSpeedDialDigits"))
if mibBuilder.loadTexts: voiceSpeedDialEntry.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSpeedDialEntry.setDescription('A Voice Speed Dial entry containing objects relating to the speed-dial number that are configurable by the user.')
voiceSpeedDialDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 12, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voiceSpeedDialDigits.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSpeedDialDigits.setDescription('The speed-dial number. A question mark wildcard can be used for any digit, and an asterisk wildcard can be used for any number of digits.')
voiceSpeedDialLongDialMap = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 12, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSpeedDialLongDialMap.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSpeedDialLongDialMap.setDescription('The number for which the speed-dial number is a shortcut.')
voiceSpeedDialExtDialStr = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 12, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSpeedDialExtDialStr.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSpeedDialExtDialStr.setDescription('The extended set of digits that will be forwarded with the call if portVoiceOperExtDigitsSource in the physical port record is set to Map.')
voiceSpeedDialRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 173, 7, 12, 8, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voiceSpeedDialRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: voiceSpeedDialRowStatus.setDescription("This variable is used to manage the creation and deletion of conceptual rows in the voiceSpeedDialTable and follows the SNMPv2 RowStatus conventions by supporting the following values: - `active', which indicates that the conceptual row is available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row does not exist. - `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device. For a management protocol set operation, a genErr response is returned when the row already exists. - `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row. Note that all of the above values may be specified in a management protocol set operation, and only the 'active' value will be returned in response to a management protocol retrieval operation. For a management protocol set operation, if other variable bindings are included in the same PDU, then a genErr response is returned.")
mibBuilder.exportSymbols("NETLINK-SPECIFIC-MIB", portT1AdminFrameModelSelect=portT1AdminFrameModelSelect, portT1OperEntry=portT1OperEntry, ipxServConfigServNetworkAddress=ipxServConfigServNetworkAddress, nlLlc2HostN2ExpiredT1LPDUCount=nlLlc2HostN2ExpiredT1LPDUCount, nlLocalSubscriberRouteEntry=nlLocalSubscriberRouteEntry, nlIfLlc2FrLANID=nlIfLlc2FrLANID, nlIfLlc2LANRowStatus=nlIfLlc2LANRowStatus, nlLlc2HostPriority=nlLlc2HostPriority, portFrEntry=portFrEntry, ipxInterfaceMaxTransUnit=ipxInterfaceMaxTransUnit, nlLlc2HostEntry=nlLlc2HostEntry, ipxInterfacePeriodicRIPTimer=ipxInterfacePeriodicRIPTimer, nlLlc2OrigConnectionEntry=nlLlc2OrigConnectionEntry, ipxServConfigEntry=ipxServConfigEntry, ipxStaticRouteConfigNetNum=ipxStaticRouteConfigNetNum, portPhyX25AdminTable=portPhyX25AdminTable, portSdlcOperGenerateClock=portSdlcOperGenerateClock, t1StatsOOSCnt=t1StatsOOSCnt, portX25AdminEntry=portX25AdminEntry, portSdlcAdminRowStatus=portSdlcAdminRowStatus, portSdlcAdminSpeed=portSdlcAdminSpeed, statBag=statBag, portDLCIPortIndex=portDLCIPortIndex, tpAdrEntry=tpAdrEntry, portBsciAdminBlockCheck=portBsciAdminBlockCheck, llc2=llc2, portSdlcAdminDisableRequestDisconnect=portSdlcAdminDisableRequestDisconnect, x25TxREJFrames=x25TxREJFrames, nlIfVoiceTable=nlIfVoiceTable, portX25AdminFastSelAccpt=portX25AdminFastSelAccpt, frStatsPortIndex=frStatsPortIndex, portX25AdminRevChgAccpt=portX25AdminRevChgAccpt, portVoiceAdminAutoDialNumber=portVoiceAdminAutoDialNumber, portBsciOperStartSynchChars=portBsciOperStartSynchChars, nlLocalSubscriberRedirectOO=nlLocalSubscriberRedirectOO, nlLocalSubscriberId=nlLocalSubscriberId, portSdlcOperConnector=portSdlcOperConnector, nlLocalSubscriberAlgorithm=nlLocalSubscriberAlgorithm, bsciDevOperTable=bsciDevOperTable, bsciSubscrAdminSequence=bsciSubscrAdminSequence, portSdlcOperEntry=portSdlcOperEntry, bsciDevAdminTransTextSupported=bsciDevAdminTransTextSupported, portSdlcOperLPDASupport=portSdlcOperLPDASupport, nlLocalSubscriberName=nlLocalSubscriberName, nlIfIpSourceRlp=nlIfIpSourceRlp, ds0aStatsEntry=ds0aStatsEntry, node=node, bsciSubscrAdminConnectionID=bsciSubscrAdminConnectionID, nsNTNeighStat=nsNTNeighStat, portBsciAdminMaxBytesPerFrame=portBsciAdminMaxBytesPerFrame, ipxInterfaceSAPAgeTimer=ipxInterfaceSAPAgeTimer, lSSdlcLlc2AdminLanN3=lSSdlcLlc2AdminLanN3, portVoiceAdminToneType=portVoiceAdminToneType, portPhyX25AdminConnector=portPhyX25AdminConnector, portT1AdminEntry=portT1AdminEntry, nlIfVoiceLocalNodePort=nlIfVoiceLocalNodePort, nlIfIpProxyARP=nlIfIpProxyARP, lSSdlcLlc2OperLanN3=lSSdlcLlc2OperLanN3, bsciDevAdminDisableStatusRequest=bsciDevAdminDisableStatusRequest, lSSdlcAdminL2DatMode=lSSdlcAdminL2DatMode, portPhyX25AdminRcvClockFromDTE=portPhyX25AdminRcvClockFromDTE, bsciSubscrOperRemoteID=bsciSubscrOperRemoteID, portBsciOperDataMode=portBsciOperDataMode, portSdlcOperSpeed=portSdlcOperSpeed, portX25OperMaxThruptClass=portX25OperMaxThruptClass, portFrRowStatus=portFrRowStatus, lSSdlcLlc2OperTable=lSSdlcLlc2OperTable, portVoiceOperJitter=portVoiceOperJitter, nlIfLlc2LANPort=nlIfLlc2LANPort, rlpStatsUsedBuffers=rlpStatsUsedBuffers, rlpThreshEntry=rlpThreshEntry, portFrRlpIndex=portFrRlpIndex, rlpThreshRlpIndex=rlpThreshRlpIndex, lSSdlcAdminLlc2Conversion=lSSdlcAdminLlc2Conversion, bsciDevOperSingleUserVC=bsciDevOperSingleUserVC, portBsciAdminActivateConnectionWithoutPoll=portBsciAdminActivateConnectionWithoutPoll, nlLocalSubscriberPriority=nlLocalSubscriberPriority, x25TxStatsEntry=x25TxStatsEntry, portPhyX25OperTrunkGroup=portPhyX25OperTrunkGroup, nlLocalSubscriberRedirectBusy=nlLocalSubscriberRedirectBusy, bsciDevOperTransTextSupported=bsciDevOperTransTextSupported, portBsciOperEndPadChars=portBsciOperEndPadChars, portPhyX25AdminDisconnectTimer=portPhyX25AdminDisconnectTimer, ipxInterfaceLanCardNumber=ipxInterfaceLanCardNumber, nlLlc2HostGroup=nlLlc2HostGroup, portSdlcGroup=portSdlcGroup, portT1OperBlockedPortFlag=portT1OperBlockedPortFlag, portPinEntry=portPinEntry, rlpThreshRxFramesPerSec=rlpThreshRxFramesPerSec, ipxServConfigGatewayAddress=ipxServConfigGatewayAddress, portT1OperTable=portT1OperTable, lSSdlcAdminLocalSub=lSSdlcAdminLocalSub, portVoiceOperSuppression=portVoiceOperSuppression, nlLocalSubscriberTable=nlLocalSubscriberTable, lSSdlcOperRetryCount=lSSdlcOperRetryCount, ipxInterfaceNetworkAddress=ipxInterfaceNetworkAddress, statFrame=statFrame, portStatsFCSErrors=portStatsFCSErrors, portSdlcAdminCommit=portSdlcAdminCommit, frStatsTable=frStatsTable, portVoiceOperSLTTimeout=portVoiceOperSLTTimeout, portSdlcAdminMAXOut=portSdlcAdminMAXOut, portFrOutgoingRateControl=portFrOutgoingRateControl, portSdlcAdminGenerateClock=portSdlcAdminGenerateClock, nlIfTableIndex=nlIfTableIndex, portBsciAdminTable=portBsciAdminTable, nlIfLlc2LANType=nlIfLlc2LANType, nlLocalSubscriberRedirAddr=nlLocalSubscriberRedirAddr, lSSdlcAdminRemoteSub=lSSdlcAdminRemoteSub, portVoiceAdminLongDialPrefix=portVoiceAdminLongDialPrefix, portBsciOperClearVCOnLastDeviceDown=portBsciOperClearVCOnLastDeviceDown, ipxInterfaceSVCRetryTimer=ipxInterfaceSVCRetryTimer, t1StatsRcvUsage=t1StatsRcvUsage, nlIfLlc2FrPort=nlIfLlc2FrPort, nlIfIpICMPAddRoutes=nlIfIpICMPAddRoutes, rlpThreshTable=rlpThreshTable, portThreshTxErrorRatio=portThreshTxErrorRatio, portBsciOperPollInterval=portBsciOperPollInterval, frStatsTxBECNFrames=frStatsTxBECNFrames, portFrMaxBytesPerFrame=portFrMaxBytesPerFrame, nlLocalSubscriberRedirEntry=nlLocalSubscriberRedirEntry, nlIfIpRowStatus=nlIfIpRowStatus, nlIfVoiceFrameRelayDLCI=nlIfVoiceFrameRelayDLCI, nlIfIpSecondaryAddrRowStatus=nlIfIpSecondaryAddrRowStatus, bsciSubscrAdminAutocallRtyTimer=bsciSubscrAdminAutocallRtyTimer, nlIfTableOid=nlIfTableOid, sdlc=sdlc, portSdlcOperCommit=portSdlcOperCommit, lSSdlcOperTable=lSSdlcOperTable, nlIfLlc2LANBlockedPortFlag=nlIfLlc2LANBlockedPortFlag, bridgeOperSRBID=bridgeOperSRBID, nodeTrapText=nodeTrapText, lSSdlcLlc2AdminLanN2=lSSdlcLlc2AdminLanN2, portLogicalX25OperRfc1490=portLogicalX25OperRfc1490, nlLlc2HostInterface=nlLlc2HostInterface, nodeBagTable=nodeBagTable, voiceStatsTxCalls=voiceStatsTxCalls, nlIfVoiceFrameRelayPort=nlIfVoiceFrameRelayPort, x25TxRNRFrames=x25TxRNRFrames, lSSdlcLlc2AdminLocalSap=lSSdlcLlc2AdminLocalSap, nlLlc2HostT2RecvAckTimer=nlLlc2HostT2RecvAckTimer, nlLlc2OrigConnectionHSAP=nlLlc2OrigConnectionHSAP, nlLocalSubscriberEntry=nlLocalSubscriberEntry, sdlcLSAdminEntry=sdlcLSAdminEntry, portStatsTable=portStatsTable, portVoiceAdminLevelOut=portVoiceAdminLevelOut, x25RxDISCFrames=x25RxDISCFrames, portX25AdminMaxThruptClass=portX25AdminMaxThruptClass, portT1OperNRZI=portT1OperNRZI, portVoiceOperLevelOut=portVoiceOperLevelOut, portVoiceOperTETimer=portVoiceOperTETimer, nlLlc2HostRowStatus=nlLlc2HostRowStatus, portFrBandwidthAllocation=portFrBandwidthAllocation, portBsciAdminNAKRetryCount=portBsciAdminNAKRetryCount, t1StatsXmitAbortFrames=t1StatsXmitAbortFrames, portVoiceAdminAutoPoll=portVoiceAdminAutoPoll, lSSdlcOperEntry=lSSdlcOperEntry, portVoiceAdminAutoPollTimer=portVoiceAdminAutoPollTimer, nlIfLlc2FrRowStatus=nlIfLlc2FrRowStatus, portDLCIOutgoingBe=portDLCIOutgoingBe, voice=voice, portX25OperDefPktSize=portX25OperDefPktSize, portVoiceOperBreakRatio=portVoiceOperBreakRatio, ipxNodeDefaultConfigNetworkAddress=ipxNodeDefaultConfigNetworkAddress, ipxInterfaceSVCIdleTimer=ipxInterfaceSVCIdleTimer, voiceStatsBusyCalls=voiceStatsBusyCalls, portThreshRlpIndex=portThreshRlpIndex, bsciDevOperDisableStatusRequest=bsciDevOperDisableStatusRequest, nlLlc2HostIndex=nlLlc2HostIndex, portLogicalX25AdminEntry=portLogicalX25AdminEntry, nlIfLlc2LANTable=nlIfLlc2LANTable, ds0aStatsTable=ds0aStatsTable, portVoiceAdminDTMFOffDuration=portVoiceAdminDTMFOffDuration, ds0aStatsRcvErrors=ds0aStatsRcvErrors, lSSdlcLlc2AdminEntry=lSSdlcLlc2AdminEntry, ipxInterfaceRIPAgeTimer=ipxInterfaceRIPAgeTimer, x25TxPortIndex=x25TxPortIndex, bsciDevOperDeviceUnitID=bsciDevOperDeviceUnitID, nlIfLlc2FrInterface=nlIfLlc2FrInterface, portVoiceOperInterface=portVoiceOperInterface, nlIfIpTable=nlIfIpTable, nlLlc2NextHostNumber=nlLlc2NextHostNumber, ipxNodeDefaultConfigRIPSAPGap=ipxNodeDefaultConfigRIPSAPGap, portX25OperLocChgPrev=portX25OperLocChgPrev, frStatsTxLMIFrames=frStatsTxLMIFrames, portVoiceAdminForwardDelay=portVoiceAdminForwardDelay, nlLlc2TermConnectionSequence=nlLlc2TermConnectionSequence, nlIfIpUnnumberedIf=nlIfIpUnnumberedIf, t1StatsBlueAlarms=t1StatsBlueAlarms, portBsciAdminEndToEndAck=portBsciAdminEndToEndAck, x25RxRlpIndex=x25RxRlpIndex, portT1OperGenerateClock=portT1OperGenerateClock, portThreshIndex=portThreshIndex, nlIfPortStatus=nlIfPortStatus, voiceStatsEntry=voiceStatsEntry, portBsciOperEndToEndAck=portBsciOperEndToEndAck, portPhyX25AdminTrunkGroup=portPhyX25AdminTrunkGroup, bsciSubscrOperAutocallMaxRtry=bsciSubscrOperAutocallMaxRtry, ds0aStatsXmitFrames=ds0aStatsXmitFrames, portX25OperEntry=portX25OperEntry, local=local, bsciSubscrAdminRemoteID=bsciSubscrAdminRemoteID, nlIfLlc2LANRlp=nlIfLlc2LANRlp, x25RxUAFrames=x25RxUAFrames, nodeAlmTable=nodeAlmTable, ipxInterfaceBandwidthAllocGroup=ipxInterfaceBandwidthAllocGroup, portSdlcOperRcvClockFromDTE=portSdlcOperRcvClockFromDTE, ipxInterfaceNetBIOSEnabled=ipxInterfaceNetBIOSEnabled, lSSdlcAdminAutoCall=lSSdlcAdminAutoCall, nlIfIpMtu=nlIfIpMtu, bridgeOperVirtualLANID=bridgeOperVirtualLANID, portVoiceAdminForwardedType=portVoiceAdminForwardedType, nlIfLlc2Interfaces=nlIfLlc2Interfaces, portX25AdminCUGOutAccess=portX25AdminCUGOutAccess, nlIfType=nlIfType, portFrBackupUseOnly=portFrBackupUseOnly, ipxConfigInterface=ipxConfigInterface, portStatsRlpIndex=portStatsRlpIndex, portThreshTxFramesPerSec=portThreshTxFramesPerSec, t1StatsRedAlarms=t1StatsRedAlarms, portVoiceAdminSuppression=portVoiceAdminSuppression, portX25AdminDefPktSize=portX25AdminDefPktSize, portVoiceAdminDTMF=portVoiceAdminDTMF, nlLlc2OrigConnectionIDNUM=nlLlc2OrigConnectionIDNUM, portX25OperOutCallBar=portX25OperOutCallBar, nlIfLlc2FrTable=nlIfLlc2FrTable, nsStatus=nsStatus, x25TxRlpIndex=x25TxRlpIndex, ipxInterfaceNetBIOSHops=ipxInterfaceNetBIOSHops, nlLlc2OrigConnectionMAXIN=nlLlc2OrigConnectionMAXIN, portT1OperFramingMode=portT1OperFramingMode, lSSdlcLlc2OperLocalSap=lSSdlcLlc2OperLocalSap, t1StatsXmitFrames=t1StatsXmitFrames, lSSdlcOperLocalSub=lSSdlcOperLocalSub, netlink=netlink, t1StatsRcvAbortFrames=t1StatsRcvAbortFrames, rlpStatsEntry=rlpStatsEntry, portPhyX25AdminDialOut=portPhyX25AdminDialOut, portPhyX25AdminSpeed=portPhyX25AdminSpeed, nlIfLlc2FrBAG=nlIfLlc2FrBAG, nlIfLlc2FrRlp=nlIfLlc2FrRlp, portLogicalX25AdminCxnPriority=portLogicalX25AdminCxnPriority, nodeSNMPGroup=nodeSNMPGroup, nlIfIpInverseARP=nlIfIpInverseARP, t1StatsRcvOverruns=t1StatsRcvOverruns, ipxStaticRouteConfigRowStatus=ipxStaticRouteConfigRowStatus, statT1=statT1, portSdlcOperPacketSize=portSdlcOperPacketSize, ipxInterfaceMaxVC=ipxInterfaceMaxVC, nlLlc2TermConnectionTable=nlLlc2TermConnectionTable, nlIfIpRIPSupport=nlIfIpRIPSupport, portBsciOperNoResponseRetryCount=portBsciOperNoResponseRetryCount, nlLocalSubscriberRouteTable=nlLocalSubscriberRouteTable, ipxInterfaceNumber=ipxInterfaceNumber)
mibBuilder.exportSymbols("NETLINK-SPECIFIC-MIB", nlLlc2OrigConnectionType=nlLlc2OrigConnectionType, bsciDevAdminPrinterAttached=bsciDevAdminPrinterAttached, portT1AdminTable=portT1AdminTable, tpAddress=tpAddress, portBsciAdminSlowPollRetryFreq=portBsciAdminSlowPollRetryFreq, lSSdlcOperLPDAResourceID=lSSdlcOperLPDAResourceID, portPhyX25OperGenerateClock=portPhyX25OperGenerateClock, lSSdlcLlc2OperLanT1=lSSdlcLlc2OperLanT1, subscriber=subscriber, portX25OperBlockedFlag=portX25OperBlockedFlag, portBsciAdminSlowPollRetryCount=portBsciAdminSlowPollRetryCount, nlIfVoicePeerNodeType=nlIfVoicePeerNodeType, bsciSubscrAdminAutocall=bsciSubscrAdminAutocall, nlIfIpDestAddress=nlIfIpDestAddress, voiceSpeedDialExtDialStr=voiceSpeedDialExtDialStr, nlIfIpSourceSub=nlIfIpSourceSub, ipxInterfaceRowStatus=ipxInterfaceRowStatus, t1StatsTable=t1StatsTable, portX25AdminDefWinSize=portX25AdminDefWinSize, nlIfIpSecondaryAddrNetworkMask=nlIfIpSecondaryAddrNetworkMask, nlIfVoicePeerNodePort=nlIfVoicePeerNodePort, nlIfLlc2FrHostMACAddress=nlIfLlc2FrHostMACAddress, portVoiceAdminPortIndex=portVoiceAdminPortIndex, portSdlcOperNrz=portSdlcOperNrz, frStatsRxDEFrames=frStatsRxDEFrames, portBsciOperActivateConnectionWithoutPoll=portBsciOperActivateConnectionWithoutPoll, portVoiceOperDTMFOnDuration=portVoiceOperDTMFOnDuration, nsNeighTable=nsNeighTable, portVoiceOperLongDialPrefix=portVoiceOperLongDialPrefix, nlIfTable=nlIfTable, portBsciOperMultidrop=portBsciOperMultidrop, ipxInterfaceSAPEnabled=ipxInterfaceSAPEnabled, portFrBackupRowStatus=portFrBackupRowStatus, portDLCIOutgoingBc=portDLCIOutgoingBc, portBsciOperErrorRetransmitCount=portBsciOperErrorRetransmitCount, bsciSubscrOperAutocallRtyTimer=bsciSubscrOperAutocallRtyTimer, lSSdlcOperRetryTime=lSSdlcOperRetryTime, lSSdlcLlc2AdminIdnum=lSSdlcLlc2AdminIdnum, ipxInterfaceSourceSubscriber=ipxInterfaceSourceSubscriber, nlLlc2OrigConnectionSequence=nlLlc2OrigConnectionSequence, nlLlc2HostT1ReplyTimer=nlLlc2HostT1ReplyTimer, NlSubscriberAddress=NlSubscriberAddress, portStatsOutPercentUtils=portStatsOutPercentUtils, ipxInterfacePeriodicSAPTimer=ipxInterfacePeriodicSAPTimer, portVoiceOperBlockedFlag=portVoiceOperBlockedFlag, lSSdlcLlc2OperSuppressXID=lSSdlcLlc2OperSuppressXID, nlIfVoiceRowStatus=nlIfVoiceRowStatus, frStatsRlpIndex=frStatsRlpIndex, portBsciAdminRowStatus=portBsciAdminRowStatus, portT1OperFrameModelSelect=portT1OperFrameModelSelect, voiceStatsTxCallsAccepts=voiceStatsTxCallsAccepts, nlLlc2TermConnectionRemoteSubscriberId=nlLlc2TermConnectionRemoteSubscriberId, portVoiceOperRlpIndex=portVoiceOperRlpIndex, portVoiceOperNumDigitsDelete=portVoiceOperNumDigitsDelete, portVoiceAdminEntry=portVoiceAdminEntry, portVoiceAdminSpeed=portVoiceAdminSpeed, rlpMemorySize=rlpMemorySize, nlIfVoiceEnableFragment=nlIfVoiceEnableFragment, nsNTNeigh=nsNTNeigh, portSdlcAdminNrz=portSdlcAdminNrz, portSdlcAdminLPDASupport=portSdlcAdminLPDASupport, portFrBackupPort=portFrBackupPort, lSSdlcAdminLPDAResourceID=lSSdlcAdminLPDAResourceID, lSSdlcLlc2OperLocalMac=lSSdlcLlc2OperLocalMac, nlIfIpPriority=nlIfIpPriority, portStatsLogicalRejects=portStatsLogicalRejects, rlpStatsFrameRejects=rlpStatsFrameRejects, nlIfRlp=nlIfRlp, bsciSubscrAdminLocalID=bsciSubscrAdminLocalID, ipxServConfigRowStatus=ipxServConfigRowStatus, nlLocalSubscriberRedirRowStatus=nlLocalSubscriberRedirRowStatus, portFrConnector=portFrConnector, portBsciAdminRcvClockFromDTE=portBsciAdminRcvClockFromDTE, x25TxStatsTable=x25TxStatsTable, nlLlc2HostAccess=nlLlc2HostAccess, portVoiceOperAutoPollTimer=portVoiceOperAutoPollTimer, portX25AdminTable=portX25AdminTable, frStatsRxLMIFrames=frStatsRxLMIFrames, nlLlc2HostMACAddress=nlLlc2HostMACAddress, portDLCIBackupGroup=portDLCIBackupGroup, lSSdlcLlc2AdminSuppressXID=lSSdlcLlc2AdminSuppressXID, nlLlc2TermConnectionRowStatus=nlLlc2TermConnectionRowStatus, rlpEntry=rlpEntry, portBsciOperAnswerNonConfigured=portBsciOperAnswerNonConfigured, portBsciOperBlockCheck=portBsciOperBlockCheck, portVoiceOperDTMF=portVoiceOperDTMF, portX25AdminOutCallBar=portX25AdminOutCallBar, portX25OperFlowCtrlNeg=portX25OperFlowCtrlNeg, nlIpDefaultRIPVersion=nlIpDefaultRIPVersion, portX25AdminMaxWinSize=portX25AdminMaxWinSize, t1StatsRlpIndex=t1StatsRlpIndex, portX25OperCUGIndex=portX25OperCUGIndex, nlIfLlc2FrPriority=nlIfLlc2FrPriority, portX25AdminInCallBar=portX25AdminInCallBar, portSdlcAdminPacketSize=portSdlcAdminPacketSize, portPhyX25AdminInactivityTimer=portPhyX25AdminInactivityTimer, lSSdlcLlc2OperBAG=lSSdlcLlc2OperBAG, statThresh=statThresh, nlIfLlc2LANPriority=nlIfLlc2LANPriority, portFrBackupEntry=portFrBackupEntry, portT1AdminProtocolFraming=portT1AdminProtocolFraming, lSSdlcLlc2AdminTable=lSSdlcLlc2AdminTable, nlIfVoiceEntry=nlIfVoiceEntry, portVoiceOperAutoPoll=portVoiceOperAutoPoll, portDLCIPriority=portDLCIPriority, bsciDevAdminRowStatus=bsciDevAdminRowStatus, nlLlc2TermConnectionHSAP=nlLlc2TermConnectionHSAP, x25TxRRFrames=x25TxRRFrames, portFrBackupDLCI=portFrBackupDLCI, portThreshEntry=portThreshEntry, portX25AdminLocChgPrev=portX25AdminLocChgPrev, portVoiceAdminTable=portVoiceAdminTable, portX25OperMaxWinSize=portX25OperMaxWinSize, voiceStatsTxClears=voiceStatsTxClears, portBsciOperRetransmitInterval=portBsciOperRetransmitInterval, statDS0A=statDS0A, voiceStatsRlpIndex=voiceStatsRlpIndex, portVoiceOperTable=portVoiceOperTable, portBsciAdminEntry=portBsciAdminEntry, bsciSubscrAdminTable=bsciSubscrAdminTable, nlLlc2TermConnectionLocalSubscriberId=nlLlc2TermConnectionLocalSubscriberId, ipxStaticRouteConfigEntry=ipxStaticRouteConfigEntry, portSdlcOperMAXOut=portSdlcOperMAXOut, nodeTrapAdrTable=nodeTrapAdrTable, bsciSubscrAdminRowStatus=bsciSubscrAdminRowStatus, nlIfIpRIPDeltaUpdates=nlIfIpRIPDeltaUpdates, portT1OperLineBuildOut=portT1OperLineBuildOut, nlIfLlc2LANEntry=nlIfLlc2LANEntry, portVoiceAdminDTMFOnDuration=portVoiceAdminDTMFOnDuration, portLogicalX25AdminTable=portLogicalX25AdminTable, portBsciAdminStartSynchChars=portBsciAdminStartSynchChars, portBsciOperMaxBytesPerFrame=portBsciOperMaxBytesPerFrame, lSSdlcAdminRetryCount=lSSdlcAdminRetryCount, nsNodNum=nsNodNum, portFrLogicalDCE=portFrLogicalDCE, lSSdlcAdminRetryTime=lSSdlcAdminRetryTime, statistics=statistics, nlLocalSubscriberRowStatus=nlLocalSubscriberRowStatus, voiceStatsTable=voiceStatsTable, voiceStatsRxCalls=voiceStatsRxCalls, nlLlc2OrigConnectionTable=nlLlc2OrigConnectionTable, portX25OperThruptClassNeg=portX25OperThruptClassNeg, ipxInterfaceBlockedPortFlag=ipxInterfaceBlockedPortFlag, portVoiceAdminRowStatus=portVoiceAdminRowStatus, portPhyX25OperSetupTimer=portPhyX25OperSetupTimer, ipxServConfigServNodeAddress=ipxServConfigServNodeAddress, x25RxINFOFrames=x25RxINFOFrames, nlLocalSubscriberSystematicRedirect=nlLocalSubscriberSystematicRedirect, nlLlc2HostSrcMACAddressMask=nlLlc2HostSrcMACAddressMask, portT1OperLineEncoding=portT1OperLineEncoding, x25RxSABMFrames=x25RxSABMFrames, portBsciAdminNoResponseRetryCount=portBsciAdminNoResponseRetryCount, nlIfIpEntry=nlIfIpEntry, nlLocalSubscriberRedirTable=nlLocalSubscriberRedirTable, portVoiceAdminSLTTimeout=portVoiceAdminSLTTimeout, lSSdlcLlc2AdminLanTw=lSSdlcLlc2AdminLanTw, portVoiceAdminNumDigitsDelete=portVoiceAdminNumDigitsDelete, ipNl=ipNl, bridgeMaxSizeForwardingTable=bridgeMaxSizeForwardingTable, bsciDevAdminConnectionID=bsciDevAdminConnectionID, ipxServConfigServName=ipxServConfigServName, nlLocalSubscriberRouteConf=nlLocalSubscriberRouteConf, ipxStaticRouteConfigCircIndex=ipxStaticRouteConfigCircIndex, portPhyX25OperDialOut=portPhyX25OperDialOut, ds0aStatsRcvFrames=ds0aStatsRcvFrames, nsNumNeigh=nsNumNeigh, lSSdlcLlc2OperLanTi=lSSdlcLlc2OperLanTi, portDLCIIncomingBc=portDLCIIncomingBc, x25RxRRFrames=x25RxRRFrames, portSdlcOperMAXRetries=portSdlcOperMAXRetries, ipxInterfaceSourceDLCI=ipxInterfaceSourceDLCI, tpAdrFlag=tpAdrFlag, portPhyX25AdminRowStatus=portPhyX25AdminRowStatus, nlIfIpSourcePort=nlIfIpSourcePort, nlIfIpInterfaces=nlIfIpInterfaces, portBsciAdminTransTextSupported=portBsciAdminTransTextSupported, nlIfIpSecondaryAddrTable=nlIfIpSecondaryAddrTable, sdlcLSAddress=sdlcLSAddress, x25TxUAFrames=x25TxUAFrames, portPhyX25OperEntry=portPhyX25OperEntry, nlIfIpSourceDLCI=nlIfIpSourceDLCI, ipxServConfigTable=ipxServConfigTable, nlIfLlc2LANCard=nlIfLlc2LANCard, voiceSystemExtDialDigits=voiceSystemExtDialDigits, portThreshRxErrorRatio=portThreshRxErrorRatio, portBsciOperEntry=portBsciOperEntry, rlpStatsInFrames=rlpStatsInFrames, nlIfIpBAG=nlIfIpBAG, nlLocalSubscriberRedirIndex=nlLocalSubscriberRedirIndex, portT1Group=portT1Group, nlIfVoicePeerNodeNumber=nlIfVoicePeerNodeNumber, portX25OperFastSelAccpt=portX25OperFastSelAccpt, ipxConfig=ipxConfig, portLogicalX25AdminRowStatus=portLogicalX25AdminRowStatus, t1StatsXmitUsage=t1StatsXmitUsage, portVoiceOperAutoDial=portVoiceOperAutoDial, portBsciOperNAKRetryCount=portBsciOperNAKRetryCount, nlIfVoiceInterfaces=nlIfVoiceInterfaces, portSdlcAdminEntry=portSdlcAdminEntry, nlIfVoiceInterface=nlIfVoiceInterface, portDLCIIncomingCIR=portDLCIIncomingCIR, portVoiceAdminBreakRatio=portVoiceAdminBreakRatio, portVoiceOperExtDigitsSource=portVoiceOperExtDigitsSource, ipxInterfaceSerializationEnabled=ipxInterfaceSerializationEnabled, portBsciAdminSpeed=portBsciAdminSpeed, ipxInterfaceWanEnabled=ipxInterfaceWanEnabled, t1StatsPortIndex=t1StatsPortIndex, lSSdlcLlc2AdminLanT1=lSSdlcLlc2AdminLanT1, nlIfEntry=nlIfEntry, ipxServConfigInterveningNetworks=ipxServConfigInterveningNetworks, voiceStatsPortIndex=voiceStatsPortIndex, nlLlc2HostSessionType=nlLlc2HostSessionType, ipxInterfaceRIPEnabled=ipxInterfaceRIPEnabled, portLogicalX25OperEntry=portLogicalX25OperEntry, portDLCIBecnRecoveryCnt=portDLCIBecnRecoveryCnt, bsciSubscrOperLocalID=bsciSubscrOperLocalID, nlIfIpSecondaryAddrSequence=nlIfIpSecondaryAddrSequence, rlpStatsQMessages=rlpStatsQMessages, lSSdlcLlc2OperIdblk=lSSdlcLlc2OperIdblk, portX25OperCUGPref=portX25OperCUGPref, sdlcLSGroup=sdlcLSGroup, nsThisNode=nsThisNode, portFrBackupGroupTable=portFrBackupGroupTable, x25TxFRMRFrames=x25TxFRMRFrames, portFrPortIndex=portFrPortIndex, portVoiceOperFaxSupported=portVoiceOperFaxSupported, lSSdlcLlc2OperLanN2=lSSdlcLlc2OperLanN2, portX25AdminThruptClassNeg=portX25AdminThruptClassNeg, t1StatsEntry=t1StatsEntry, portSdlcOperDisableRequestDisconnect=portSdlcOperDisableRequestDisconnect, rlpMaxProtos=rlpMaxProtos, lSSdlcLlc2AdminLanTi=lSSdlcLlc2AdminLanTi, portLogicalX25AdminFrDlci=portLogicalX25AdminFrDlci, portPhyX25OperSpeed=portPhyX25OperSpeed, nlIfPhyPort=nlIfPhyPort, nlIfLlc2LANInterface=nlIfLlc2LANInterface, portPhyX25AdminEntry=portPhyX25AdminEntry, voiceSystemRingVolFreq=voiceSystemRingVolFreq, rlpThreshRtxFramesPerSec=rlpThreshRtxFramesPerSec, portDLCIEntry=portDLCIEntry, nlIfIpLANCard=nlIfIpLANCard, portFrT392Timer=portFrT392Timer, nlIfLlc2FrSessionType=nlIfLlc2FrSessionType, rlpStatsOutFrames=rlpStatsOutFrames, portVoiceAdminForwardedDigits=portVoiceAdminForwardedDigits, portBsciAdminNoResponseTimer=portBsciAdminNoResponseTimer, portVoiceAdminBlockedFlag=portVoiceAdminBlockedFlag, portX25OperMaxPktSize=portX25OperMaxPktSize, portBsciAdminPadType=portBsciAdminPadType, lSSdlcOperL2DatMode=lSSdlcOperL2DatMode, portVoiceOperLinkDownBusy=portVoiceOperLinkDownBusy, t1StatsRcvFrames=t1StatsRcvFrames, portFrBlockedFlag=portFrBlockedFlag, nlIfIpRouteMetric=nlIfIpRouteMetric)
mibBuilder.exportSymbols("NETLINK-SPECIFIC-MIB", bridgeDefaultEthernetFrameType=bridgeDefaultEthernetFrameType, portBsciOperFullDuplex=portBsciOperFullDuplex, portPhyX25AdminGenerateClock=portPhyX25AdminGenerateClock, portBsciOperTable=portBsciOperTable, portSdlcAdminIdleFillChar=portSdlcAdminIdleFillChar, lSSdlcLlc2AdminLocalMac=lSSdlcLlc2AdminLocalMac, portPhyX25OperInactivityTimer=portPhyX25OperInactivityTimer, portLogicalX25OperTable=portLogicalX25OperTable, portLogicalX25OperBAG=portLogicalX25OperBAG, portX25OperTable=portX25OperTable, lSSdlcLlc2AdminLanT2=lSSdlcLlc2AdminLanT2, portSdlcAdminL1Duplex=portSdlcAdminL1Duplex, bridgeIPEnabled=bridgeIPEnabled, portBsciOperCallInfoInRequestPacket=portBsciOperCallInfoInRequestPacket, nlLlc2TermConnectionEntry=nlLlc2TermConnectionEntry, portVoiceAdminLinkDownBusy=portVoiceAdminLinkDownBusy, rlpThreshMsgQueueLen=rlpThreshMsgQueueLen, ipxInterfaceTransportTime=ipxInterfaceTransportTime, tpAdrSLev=tpAdrSLev, nlIfIpSecondaryAddrBroadcastAddress=nlIfIpSecondaryAddrBroadcastAddress, portVoiceOperCallTimer=portVoiceOperCallTimer, portPhyX25AdminSetupTimer=portPhyX25AdminSetupTimer, portVoiceOperForwardDelay=portVoiceOperForwardDelay, portVoiceOperHuntGroup=portVoiceOperHuntGroup, portDLCIRowStatus=portDLCIRowStatus, rlpLIC1Type=rlpLIC1Type, portVoiceAdminTelephonyType=portVoiceAdminTelephonyType, bsciDevOperEntry=bsciDevOperEntry, nlIfIpSVCRetryTimer=nlIfIpSVCRetryTimer, nsEntry=nsEntry, portBsciAdminConnector=portBsciAdminConnector, voiceStatsRxCongestions=voiceStatsRxCongestions, rlpGroupNumber=rlpGroupNumber, portLogicalX25AdminRfc1490=portLogicalX25AdminRfc1490, portBsciAdminMultidrop=portBsciAdminMultidrop, lSSdlcOperLlc2Conversion=lSSdlcOperLlc2Conversion, frStatsEntry=frStatsEntry, nlIfIpSecondaryAddrSourceAddress=nlIfIpSecondaryAddrSourceAddress, portVoiceAdminRlpIndex=portVoiceAdminRlpIndex, nlIfIpSVCIdleTimer=nlIfIpSVCIdleTimer, portBsciOperBlockedFlag=portBsciOperBlockedFlag, portSdlcOperIdleFillChar=portSdlcOperIdleFillChar, nlIfIpNetworkMask=nlIfIpNetworkMask, portX25AdminBlockedFlag=portX25AdminBlockedFlag, portSdlcAdminTable=portSdlcAdminTable, portVoiceOperDialTimer=portVoiceOperDialTimer, nlIfIpSecondaryAddrRouteMetric=nlIfIpSecondaryAddrRouteMetric, portBsciOperUseEBCDIC=portBsciOperUseEBCDIC, portVoiceAdminDialTimer=portVoiceAdminDialTimer, portX25AdminFlowCtrlNeg=portX25AdminFlowCtrlNeg, portVoiceAdminLevelIn=portVoiceAdminLevelIn, nlLlc2OrigConnectionMAXDATA=nlLlc2OrigConnectionMAXDATA, portFrLLM=portFrLLM, bsciDevOperPrinterAttached=bsciDevOperPrinterAttached, portThreshRxFramesPerSec=portThreshRxFramesPerSec, portPhyX25AdminTrunkFlag=portPhyX25AdminTrunkFlag, voiceSystemDialDigits=voiceSystemDialDigits, ipxInterfaceRIPMaxSize=ipxInterfaceRIPMaxSize, portPinPort=portPinPort, frStatsRxANXDFrames=frStatsRxANXDFrames, portX25Group=portX25Group, ipxConfigRouting=ipxConfigRouting, t1StatsYellowAlarms=t1StatsYellowAlarms, nlLlc2HostN3NumberLPDUs=nlLlc2HostN3NumberLPDUs, portFrBackupRLP=portFrBackupRLP, ipxInterfaceFrameType=ipxInterfaceFrameType, nlLocalSubscriberRouteIndex=nlLocalSubscriberRouteIndex, portBsciAdminAnswerNonConfigured=portBsciAdminAnswerNonConfigured, portBsciAdminRetransmitInterval=portBsciAdminRetransmitInterval, portVoiceOperSampleDelay=portVoiceOperSampleDelay, portX25AdminCUGIndex=portX25AdminCUGIndex, portPhyX25OperTable=portPhyX25OperTable, lSSdlcAdminEntry=lSSdlcAdminEntry, portBsciOperNoResponseTimer=portBsciOperNoResponseTimer, portFrGenClock=portFrGenClock, portVoiceAdminTETimer=portVoiceAdminTETimer, t1StatsRcvErrors=t1StatsRcvErrors, nlLlc2HostRoutingSubscriberId=nlLlc2HostRoutingSubscriberId, ipxInterfaceEntry=ipxInterfaceEntry, status=status, ds0aStatsChannelIndex=ds0aStatsChannelIndex, rlpProtocol=rlpProtocol, portT1AdminBlockedPortFlag=portT1AdminBlockedPortFlag, rlpConfigTable=rlpConfigTable, portT1AdminGenerateClock=portT1AdminGenerateClock, portThreshTxPercentUtl=portThreshTxPercentUtl, lSSdlcOperAutoCall=lSSdlcOperAutoCall, nlLlc2OrigConnectionRemoteSubscriberId=nlLlc2OrigConnectionRemoteSubscriberId, bridgeAdminSRBID=bridgeAdminSRBID, portBsciOperMAXRetransmits=portBsciOperMAXRetransmits, ipxInterfaceSourceCard=ipxInterfaceSourceCard, nsNodTable=nsNodTable, portVoiceAdminExtDigitsSource=portVoiceAdminExtDigitsSource, portBsciOperTransTextSupported=portBsciOperTransTextSupported, x25TxINFOFrames=x25TxINFOFrames, portVoiceAdminAutoDial=portVoiceAdminAutoDial, portVoiceOperSpeed=portVoiceOperSpeed, bsciSubscrOperSequence=bsciSubscrOperSequence, portPinRlp=portPinRlp, x25RxRNRFrames=x25RxRNRFrames, portFrGroup=portFrGroup, portFrRcvClkFrmDTE=portFrRcvClkFrmDTE, portPhyX25OperDisconnectTimer=portPhyX25OperDisconnectTimer, portBsciOperConnector=portBsciOperConnector, nlIfIpBroadcastAddress=nlIfIpBroadcastAddress, portX25AdminCUGIncAccess=portX25AdminCUGIncAccess, bsciSubscrOperTable=bsciSubscrOperTable, portStatsOutFrames=portStatsOutFrames, portVoiceOperDTMFOffDuration=portVoiceOperDTMFOffDuration, portVoiceOperToneType=portVoiceOperToneType, nlIfIndex=nlIfIndex, rlpThreshTxFramesPerSec=rlpThreshTxFramesPerSec, portX25OperCUGOutAccess=portX25OperCUGOutAccess, frStatsRxFECNFrames=frStatsRxFECNFrames, ds0aStatsRcvAbortFrames=ds0aStatsRcvAbortFrames, bsciSubscrOperConnectionID=bsciSubscrOperConnectionID, portVoiceAdminCallTimer=portVoiceAdminCallTimer, voiceSpeedDialRowStatus=voiceSpeedDialRowStatus, frStatsTotDiscFrames=frStatsTotDiscFrames, portSdlcAdminRcvClockFromDTE=portSdlcAdminRcvClockFromDTE, statIp=statIp, voiceStatsCallTimeouts=voiceStatsCallTimeouts, voiceSystemCountryCode=voiceSystemCountryCode, nsMaxNeigh=nsMaxNeigh, nlIfIpType=nlIfIpType, x25RxStatsTable=x25RxStatsTable, portStatsIndex=portStatsIndex, nlInterfaces=nlInterfaces, portBsciOperSlowPollRetryFreq=portBsciOperSlowPollRetryFreq, portThreshLogRejPerSec=portThreshLogRejPerSec, nlIfIpMaxSVC=nlIfIpMaxSVC, portPinStatus=portPinStatus, portStatsInFrames=portStatsInFrames, x25TxSABMFrames=x25TxSABMFrames, bsciSubscrOperEntry=bsciSubscrOperEntry, lSSdlcLlc2OperLanT2=lSSdlcLlc2OperLanT2, voiceSpeedDialTable=voiceSpeedDialTable, portVoiceAdminFaxSupported=portVoiceAdminFaxSupported, portX25OperDefWinSize=portX25OperDefWinSize, lSSdlcLlc2AdminIdblk=lSSdlcLlc2AdminIdblk, ds0aStatsPortIndex=ds0aStatsPortIndex, voiceStatsRxCallsAccepts=voiceStatsRxCallsAccepts, voiceSystemVoiceNodeNum=voiceSystemVoiceNodeNum, portBsciAdminDataMode=portBsciAdminDataMode, portSdlcOperInactivityTimer=portSdlcOperInactivityTimer, ipxInterfacePortDiagEnabled=ipxInterfacePortDiagEnabled, portBsciAdminClearVCOnLastDeviceDown=portBsciAdminClearVCOnLastDeviceDown, frStatsTxFECNFrames=frStatsTxFECNFrames, ipxInterfaceWatchdogSpoofingEnabled=ipxInterfaceWatchdogSpoofingEnabled, bsciDevOperConnectionID=bsciDevOperConnectionID, portVoiceOperAutoDialNumber=portVoiceOperAutoDialNumber, portBsciOperSpeed=portBsciOperSpeed, bsciSubscrAdminAutocallMaxRtry=bsciSubscrAdminAutocallMaxRtry, portVoiceAdminInterface=portVoiceAdminInterface, pinStatusTable=pinStatusTable, nlLocalSubscriberRoutePort=nlLocalSubscriberRoutePort, bsciDevAdminDeviceUnitID=bsciDevAdminDeviceUnitID, ipxInterfacePeriodicRIPEnabled=ipxInterfacePeriodicRIPEnabled, rlpThreshPercntBufInUse=rlpThreshPercntBufInUse, nlIfIpPVCConnection=nlIfIpPVCConnection, bsciDevAdminTable=bsciDevAdminTable, lSSdlcAdminRowStatus=lSSdlcAdminRowStatus, portVoiceAdminMakeRatio=portVoiceAdminMakeRatio, rlpStatsTable=rlpStatsTable, t1StatsPCVRErrs=t1StatsPCVRErrs, portSdlcAdminPadType=portSdlcAdminPadType, portX25AdminMaxPktSize=portX25AdminMaxPktSize, nlIfIpDestSub=nlIfIpDestSub, portBsciAdminBlockedFlag=portBsciAdminBlockedFlag, x25RxREJFrames=x25RxREJFrames, voiceStatsRxClears=voiceStatsRxClears, voiceSpeedDialDigits=voiceSpeedDialDigits, portSdlcAdminMAXRetries=portSdlcAdminMAXRetries, portVoiceOperPortIndex=portVoiceOperPortIndex, ipxInterfaceSourcePort=ipxInterfaceSourcePort, portBsciAdminPollInterval=portBsciAdminPollInterval, snaDLC=snaDLC, portBsciAdminMAXRetransmits=portBsciAdminMAXRetransmits, ipxServConfigInterface=ipxServConfigInterface, portThreshRxPercentUtl=portThreshRxPercentUtl, portSdlcOperTable=portSdlcOperTable, bridgeAdminVirtualLANID=bridgeAdminVirtualLANID, portVoiceGroup=portVoiceGroup, lSSdlcLlc2OperPriority=lSSdlcLlc2OperPriority, tpAdrIdx=tpAdrIdx, lSSdlcLlc2AdminPriority=lSSdlcLlc2AdminPriority, t1StatsRcvChannelErrors=t1StatsRcvChannelErrors, portPhyX25OperConnector=portPhyX25OperConnector, portSdlcAdminConnector=portSdlcAdminConnector, portSdlcAdminInactivityTimer=portSdlcAdminInactivityTimer, nlLlc2OrigConnectionLocalSubscriberId=nlLlc2OrigConnectionLocalSubscriberId, nlLlc2HostTwNumberOutstanding=nlLlc2HostTwNumberOutstanding, portStatsEntry=portStatsEntry, nlIfLlc2FrEntry=nlIfLlc2FrEntry, portX25AdminCUGPref=portX25AdminCUGPref, frStatsTxDEFrames=frStatsTxDEFrames, ds0aStatsRcvOverruns=ds0aStatsRcvOverruns, voiceSpeedDialEntry=voiceSpeedDialEntry, portDLCIIndex=portDLCIIndex, nlIfLlc2FrBlockedPortFlag=nlIfLlc2FrBlockedPortFlag, portDLCIConfigTable=portDLCIConfigTable, nlLlc2HostBAG=nlLlc2HostBAG, portVoiceOperEntry=portVoiceOperEntry, portPhyX25OperRcvClockFromDTE=portPhyX25OperRcvClockFromDTE, portLogicalX25OperCxnPriority=portLogicalX25OperCxnPriority, rlpStatsFrameRetransmits=rlpStatsFrameRetransmits, portVoiceAdminHuntGroup=portVoiceAdminHuntGroup, frStatsTxANXDFrames=frStatsTxANXDFrames, bsciDevAdminSingleUserVC=bsciDevAdminSingleUserVC, portBsciOperGenerateClock=portBsciOperGenerateClock, rlpIndex=rlpIndex, portVoiceOperMakeRatio=portVoiceOperMakeRatio, portX25OperInCallBar=portX25OperInCallBar, portFrBackupWaitTimer=portFrBackupWaitTimer, statGroup=statGroup, t1StatsLCVCnt=t1StatsLCVCnt, ipxServConfigServSocketNumber=ipxServConfigServSocketNumber, ipxConfigNodeDefault=ipxConfigNodeDefault, portBsciAdminCallInfoInRequestPacket=portBsciAdminCallInfoInRequestPacket, portT1AdminFramingMode=portT1AdminFramingMode, portFrBackupProtEnab=portFrBackupProtEnab, lSSdlcAdminTable=lSSdlcAdminTable, portThreshTable=portThreshTable, portVoiceOperForwardedType=portVoiceOperForwardedType, nlIfIpInterface=nlIfIpInterface, nlIfIpRIPFullUpdates=nlIfIpRIPFullUpdates, nlIfLlc2FrFormat=nlIfLlc2FrFormat, lSSdlcLlc2OperEntry=lSSdlcLlc2OperEntry, sdlcLSAdminTable=sdlcLSAdminTable, portPhyX25OperTrunkFlag=portPhyX25OperTrunkFlag, portT1AdminNRZI=portT1AdminNRZI, portDLCIOutgoingCIR=portDLCIOutgoingCIR, rlpThreshRejFramesPerSec=rlpThreshRejFramesPerSec, ipxInterfaceType=ipxInterfaceType, ipxInterfacePeriodicSAPEnabled=ipxInterfacePeriodicSAPEnabled, nlLocalSubscriberRouteLP=nlLocalSubscriberRouteLP, nlLlc2OrigConnectionIDBLK=nlLlc2OrigConnectionIDBLK, lSSdlcLlc2OperLanTw=lSSdlcLlc2OperLanTw, nsNTNode=nsNTNode, x25RxDMFrames=x25RxDMFrames, portBsciGroup=portBsciGroup, ipxStaticRouteConfigRouter=ipxStaticRouteConfigRouter, portT1AdminLineBuildOut=portT1AdminLineBuildOut, nlLlc2HostTable=nlLlc2HostTable, ipxStaticRouteConfigTable=ipxStaticRouteConfigTable, bsciSubscrOperAutocall=bsciSubscrOperAutocall, voiceSystemVoiceRatesMin=voiceSystemVoiceRatesMin, portSdlcOperL1Duplex=portSdlcOperL1Duplex, portT1AdminLineEncoding=portT1AdminLineEncoding, nlLocalSubscriberRouteRowStatus=nlLocalSubscriberRouteRowStatus, portDLCIIncomingBe=portDLCIIncomingBe, frStatsRxBECNFrames=frStatsRxBECNFrames, nodeCfgTable=nodeCfgTable, portStatsFrameRetrans=portStatsFrameRetrans)
mibBuilder.exportSymbols("NETLINK-SPECIFIC-MIB", nlIfVoiceLocalNodeNumber=nlIfVoiceLocalNodeNumber, voiceSpeedDialLongDialMap=voiceSpeedDialLongDialMap, portBsciAdminGenerateClock=portBsciAdminGenerateClock, portDLCIBackupProtEnb=portDLCIBackupProtEnb, lSSdlcLlc2AdminBAG=lSSdlcLlc2AdminBAG, portFrConfigTable=portFrConfigTable, portBsciAdminErrorRetransmitCount=portBsciAdminErrorRetransmitCount, portStatsInPercentUtils=portStatsInPercentUtils, bsciDevAdminEntry=bsciDevAdminEntry, ipxInterfaceTable=ipxInterfaceTable, x25RxPortIndex=x25RxPortIndex, nlIfPort=nlIfPort, bsciDevOperControlUnitID=bsciDevOperControlUnitID, port=port, ipxNodeDefaultConfigRouterName=ipxNodeDefaultConfigRouterName, x25RxStatsEntry=x25RxStatsEntry, nlIfIpSourceAddress=nlIfIpSourceAddress, nsNeighEntry=nsNeighEntry, portLogicalX25AdminBAG=portLogicalX25AdminBAG, portVoiceAdminSampleDelay=portVoiceAdminSampleDelay, nlIfConnectorType=nlIfConnectorType, portThreshFCSErrPerSec=portThreshFCSErrPerSec, bridge=bridge, nodeModel=nodeModel, portT1OperProtocolFraming=portT1OperProtocolFraming, portVoiceOperForwardedDigits=portVoiceOperForwardedDigits, rlpGroupResponsibility=rlpGroupResponsibility, ipxInterfaceDestinationSubscriber=ipxInterfaceDestinationSubscriber, nlIfIpSecondaryAddrEntry=nlIfIpSecondaryAddrEntry, nlLlc2OrigConnectionRowStatus=nlLlc2OrigConnectionRowStatus, bridgeIPXEnabled=bridgeIPXEnabled, nlIfVoiceFrameRelayRlp=nlIfVoiceFrameRelayRlp, nlIfLlc2FrDLCI=nlIfLlc2FrDLCI, portDLCIRlpIndex=portDLCIRlpIndex, nlLlc2HostTiInactivityTimer=nlLlc2HostTiInactivityTimer, statVoice=statVoice, portVoiceOperLevelIn=portVoiceOperLevelIn, x25TxDMFrames=x25TxDMFrames, voiceSystemVoiceRatesMax=voiceSystemVoiceRatesMax, portFrBackupGroup=portFrBackupGroup, portBsciAdminFullDuplex=portBsciAdminFullDuplex, rlpStatus=rlpStatus, bsciSubscrAdminEntry=bsciSubscrAdminEntry, portSdlcOperPadType=portSdlcOperPadType, bsciDevAdminControlUnitID=bsciDevAdminControlUnitID, ipxInterfacePVCConnection=ipxInterfacePVCConnection, portBsciOperPadType=portBsciOperPadType, netstat=netstat, ipxServConfigServiceType=ipxServConfigServiceType, rlpStatsIndex=rlpStatsIndex, portLogicalX25OperFrDlci=portLogicalX25OperFrDlci, voiceStatsTxCongestions=voiceStatsTxCongestions, portT1AdminRowStatus=portT1AdminRowStatus, lSSdlcOperRemoteSub=lSSdlcOperRemoteSub, nlIfLlc2LANID=nlIfLlc2LANID, lSSdlcLlc2OperIdnum=lSSdlcLlc2OperIdnum, portBsciAdminEndPadChars=portBsciAdminEndPadChars, bridgeEnabled=bridgeEnabled, portVoiceOperTelephonyType=portVoiceOperTelephonyType, portBsciAdminUseEBCDIC=portBsciAdminUseEBCDIC, ds0aStatsRlpIndex=ds0aStatsRlpIndex, portX25OperCUGIncAccess=portX25OperCUGIncAccess, nlIfIpSecondaryAddrRIPSupport=nlIfIpSecondaryAddrRIPSupport, lSSdlcLlc2AdminRowStatus=lSSdlcLlc2AdminRowStatus, portFrSpeed=portFrSpeed, portBsciOperSlowPollRetryCount=portBsciOperSlowPollRetryCount, rlpLIC2Type=rlpLIC2Type, x25TxDISCFrames=x25TxDISCFrames, network=network, portBsciOperRcvClockFromDTE=portBsciOperRcvClockFromDTE, hwcard=hwcard, portVoiceAdminJitter=portVoiceAdminJitter, portThreshRtxFramesPerSec=portThreshRtxFramesPerSec, portX25OperRevChgAccpt=portX25OperRevChgAccpt, x25RxFRMRFrames=x25RxFRMRFrames)

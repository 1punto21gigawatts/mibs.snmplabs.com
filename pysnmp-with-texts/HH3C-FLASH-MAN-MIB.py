#
# PySNMP MIB module HH3C-FLASH-MAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-FLASH-MAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:27:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
PhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "PhysicalIndex")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
iso, Gauge32, IpAddress, Integer32, Bits, NotificationType, Counter32, ObjectIdentity, TimeTicks, Unsigned32, MibIdentifier, ModuleIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "IpAddress", "Integer32", "Bits", "NotificationType", "Counter32", "ObjectIdentity", "TimeTicks", "Unsigned32", "MibIdentifier", "ModuleIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, DisplayString, TextualConvention, RowStatus, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "RowStatus", "TimeStamp")
hh3cFlash = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 5))
if mibBuilder.loadTexts: hh3cFlash.setLastUpdated('201006050000Z')
if mibBuilder.loadTexts: hh3cFlash.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cFlash.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085')
if mibBuilder.loadTexts: hh3cFlash.setDescription('This MIB contains objects to manage flash cards and flash card operations. There are no constraints on this MIB.')
class Hh3cFlashOperationStatus(TextualConvention, Integer32):
    description = 'The status of the specified operation can be one of the following. opInProgress : the operation is in process. opSuccess : the operation has been completed successfully. opInvalid : the command is invalid or command-protocol-device combination is unsupported by the system. opInvalidProtocol :invalid protocol is specified opInvalidSourceName :invalid source file name is specified. opInvalidDestName :invalid target name is specified. opInvalidServerAddress :invalid server address is specified opDeviceBusy :the device is in use and locked by another process opDeviceOpenError :invalid device name is specified. opDeviceError : device read, write or erase error opDeviceNotProgrammable :device is read-only but a write or erase operation was specified opDeviceFull : device is filled to capacity opFileOpenError :invalid file name; file not found in partition opFileTransferError :file transfer was unsuccessful opFileChecksumError :file checksum in Flash is invalid opNoMemory :system is running in low on memory opUnknownFailure :failure which is unknown opDeleteFileOpenError :file is in used by another process opDeleteInvalidDevice :invalid device name is specified opDeleteInvalidFunction :deleted operation is unsupported by the device opDeleteOperationError :operation is in a low error opDeleteInvalidFileName :invalid file name is specified pDeleteDeviceBusy :the device is in use and locked by another process opDeleteParaError :the parameters are invalid opDeleteInvalidPath :the file path is invalid'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27))
    namedValues = NamedValues(("opInProgress", 1), ("opSuccess", 2), ("opInvalid", 3), ("opInvalidProtocol", 4), ("opInvalidSourceName", 5), ("opInvalidDestName", 6), ("opInvalidServerAddress", 7), ("opDeviceBusy", 8), ("opDeviceOpenError", 9), ("opDeviceError", 10), ("opDeviceNotProgrammable", 11), ("opDeviceFull", 12), ("opFileOpenError", 13), ("opFileTransferError", 14), ("opFileChecksumError", 15), ("opNoMemory", 16), ("opAuthFail", 17), ("opTimeout", 18), ("opUnknownFailure", 19), ("opDeleteFileOpenError", 20), ("opDeleteInvalidDevice", 21), ("opDeleteInvalidFunction", 22), ("opDeleteOperationError", 23), ("opDeleteInvalidFileName", 24), ("opDeleteDeviceBusy", 25), ("opDeleteParaError", 26), ("opDeleteInvalidPath", 27))

class Hh3cFlashPartitionUpgradeMode(TextualConvention, Integer32):
    description = ' Flash partition upgrade method, i.e., method by which new files can be downloaded into the partition. FLH stands for Flash Load Helper, a feature provided on run-from-Flash systems for upgrading Flash. This feature uses the bootstrap code in ROMs to help in automatic download. This object should be retrieved if the partition status is runFromFlash(2). If the partition status is readOnly(1), the upgrade method would depend on the reason for the readOnly status. For example, it may simply be a matter of installing the programming jumper, or it may require execution of a later version of software that supports the Flash chips. unknown - the current system image does not know how Flash can be programmed. A possible method would be to reload the ROM image and perform the upgrade manually. rxbootFLH - the Flash Load Helper is available to download files to Flash. A copy-to-flash command can be used and this system image will automatically reload the Rxboot image in ROM and direct it to carry out the download request. direct - will be done directly by this image. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("rxbootFLH", 2), ("direct", 3))

class Hh3cFlashPartitionStatus(TextualConvention, Integer32):
    description = "If device is not programmable the value of it will be 'readOnly'; If the current image is running from this partition the value of it will be 'runFromFlash' If device is programmable the value of it will be 'readWrite'. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("readOnly", 1), ("runFromFlash", 2), ("readWrite", 3))

hh3cFlashManMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1))
hh3cFlashDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1))
hh3cFlhSupportNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhSupportNum.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhSupportNum.setDescription(' Specifies the total number of flash which the system supported. The MIB should not be loaded if there is no flash in the system and so the value here will be a minimum of 1. ')
hh3cFlashTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2), )
if mibBuilder.loadTexts: hh3cFlashTable.setStatus('current')
if mibBuilder.loadTexts: hh3cFlashTable.setDescription(' This table gives the properties of all the flashes on the system. ')
hh3cFlashEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1), ).setIndexNames((0, "HH3C-FLASH-MAN-MIB", "hh3cFlhIndex"))
if mibBuilder.loadTexts: hh3cFlashEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cFlashEntry.setDescription('The entry of hh3cFlashTable.')
hh3cFlhIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhIndex.setDescription(' The index of hh3cFlashTable. It has a minimum value of 1, and maximum value of the same as the value of hh3cFlhSupportNum. ')
hh3cFlhSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 2), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhSize.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhSize.setDescription(' Specifies the total size of the flash device indexed by hh3cFlhIndex. The value should be zero if the flash is removed for a removable device. ')
hh3cFlhPos = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 3), PhysicalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPos.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPos.setDescription(' The position of the flash device in system. This object is an index of entPhysicalTable in ENTITY-MIB. If the value of this object is 0, the main processor is indicated. ')
hh3cFlhName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhName.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhName.setDescription('The flash name within the system.')
hh3cFlhChipNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipNum.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipNum.setDescription('The chip numbers in the flash.')
hh3cFlhDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhDescr.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhDescr.setDescription('Description of the purpose of the flash in the system.')
hh3cFlhInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhInitTime.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhInitTime.setDescription(' The initialization time for the flash component or partition, recorded using the system time. This will be the boot time for a fixed device. For a removable component or a partition, it will be the initialization time. ')
hh3cFlhRemovable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhRemovable.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhRemovable.setDescription(' The value indicates whether the flash indexed can be removed or not. The true(1) value indicates the flash device CAN be removed. ')
hh3cFlhPartitionBool = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cFlhPartitionBool.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartitionBool.setDescription(' The value indicates whether the flash indexed can be partitioned or not. The true(1) value indicates the flash CAN be partitioned. ')
hh3cFlhMinPartitionSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 12), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhMinPartitionSize.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhMinPartitionSize.setDescription(' Minimum partition size supported. If hh3cFlhDevicePartitionBool is false, the value of this object is the same as hh3cFlhSize. ')
hh3cFlhMaxPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhMaxPartitions.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhMaxPartitions.setDescription(' The maximum count of partitions which the system supports for this flash. If hh3cFlhPartitionBool is false, the object value is 1. ')
hh3cFlhPartitionNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartitionNum.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartitionNum.setDescription(' The actual number of partitions supported by the system for this flash. If hh3cFlhPartitionBool is false, this value is 1. ')
hh3cFlhKbyteSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 2, 1, 15), Integer32()).setUnits('kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhKbyteSize.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhKbyteSize.setDescription(' Specifies the total size of the flash device indexed by hh3cFlhIndex. The value should be zero if the flash is removed for a removable device. ')
hh3cFlashChips = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3))
hh3cFlhChipTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1), )
if mibBuilder.loadTexts: hh3cFlhChipTable.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipTable.setDescription(' Table of properties for all flash chips. Used mainly for diagnostics. ')
hh3cFlhChipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1), ).setIndexNames((0, "HH3C-FLASH-MAN-MIB", "hh3cFlhIndex"), (0, "HH3C-FLASH-MAN-MIB", "hh3cFlhChipSerialNo"))
if mibBuilder.loadTexts: hh3cFlhChipEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipEntry.setDescription('The entry of hh3cFlhChipTable')
hh3cFlhChipSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: hh3cFlhChipSerialNo.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipSerialNo.setDescription('Index of hh3cFlhChipTable.')
hh3cFlhChipID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipID.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipID.setDescription(' The manufacturer code (the upper byte) and device code (the lower byte) for a chip. Unknown chip code is presented as 00:00. ')
hh3cFlhChipDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipDescr.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipDescr.setDescription(' The description of the flash chip. ')
hh3cFlhChipWriteTimesLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipWriteTimesLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipWriteTimesLimit.setDescription(' The limit for the number of write times (retries) for a flash chip. If the limit is exceeded an error should be reported by the management station. ')
hh3cFlhChipWriteTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipWriteTimes.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipWriteTimes.setDescription(' A count of write times (retries) for the flash chip since initialization. A count of 25 or more for a single chip indicates a write error. Management stations should note the value of this MIB before and after a write operation, and report any errors accordingly. ')
hh3cFlhChipEraseTimesLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipEraseTimesLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipEraseTimesLimit.setDescription(' The limit for the number of erase times (retries) for a flash chip. If the limit is exceeded an error should be reported by the management station. ')
hh3cFlhChipEraseTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhChipEraseTimes.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipEraseTimes.setDescription(' A count of erase times (retries) for the flash chip since initialization. A count of 2000 or more for a single chip indicates a write error. Management stations should note the value of this MIB before and after an erase operation, and report any errors accordingly. ')
hh3cFlashPartitions = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4))
hh3cFlhPartitionTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1), )
if mibBuilder.loadTexts: hh3cFlhPartitionTable.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartitionTable.setDescription(' Properties for the flash partitions. Minimum of one entry in this table. ')
hh3cFlhPartitionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1), ).setIndexNames((0, "HH3C-FLASH-MAN-MIB", "hh3cFlhIndex"), (0, "HH3C-FLASH-MAN-MIB", "hh3cFlhPartIndex"))
if mibBuilder.loadTexts: hh3cFlhPartitionEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartitionEntry.setDescription(' An entry of the hh3cFlhPartitionTable.Indexed by flash number and partition number. ')
hh3cFlhPartIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: hh3cFlhPartIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartIndex.setDescription(' An index which specifies a sequenced partition in the system. ')
hh3cFlhPartFirstChip = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartFirstChip.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartFirstChip.setDescription(" The first chip's sequence number in the partition, by which a chip can be indexed in chip table. ")
hh3cFlhPartLastChip = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartLastChip.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartLastChip.setDescription(" The last chip's sequence number in the partition, by which a chip can be indexed in chip table. ")
hh3cFlhPartSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 4), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartSpace.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartSpace.setDescription(' The total space of the flash partition. The following should be satisfied: hh3cFlhPartSpace = n*hh3cFlhMinPartitionSize ')
hh3cFlhPartSpaceFree = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 5), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartSpaceFree.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartSpaceFree.setDescription("The flash partition's free space.")
hh3cFlhPartFileNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartFileNum.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartFileNum.setDescription('The number of all the files in the flash partition.')
hh3cFlhPartChecksumMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("simpleChecksum", 1), ("undefined", 2), ("simpleCRC", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartChecksumMethod.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartChecksumMethod.setDescription('The Checksum method which the file system uses.')
hh3cFlhPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 8), Hh3cFlashPartitionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartStatus.setDescription('The flash partition status.')
hh3cFlhPartUpgradeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 9), Hh3cFlashPartitionUpgradeMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartUpgradeMode.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartUpgradeMode.setDescription('The upgrade mode of the Flash partition')
hh3cFlhPartName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartName.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartName.setDescription('The name of the flash partition given by the system.')
hh3cFlhPartRequireErase = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartRequireErase.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartRequireErase.setDescription(' Shows whether a write operation is conditional on partition erase. ')
hh3cFlhPartFileNameLen = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhPartFileNameLen.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartFileNameLen.setDescription('The maximum length of file name in the system.')
hh3cFlhFiles = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2))
hh3cFlhFileTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1), )
if mibBuilder.loadTexts: hh3cFlhFileTable.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileTable.setDescription('Table of file information.')
hh3cFlhFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1, 1), ).setIndexNames((0, "HH3C-FLASH-MAN-MIB", "hh3cFlhIndex"), (0, "HH3C-FLASH-MAN-MIB", "hh3cFlhPartIndex"), (0, "HH3C-FLASH-MAN-MIB", "hh3cFlhFileIndex"))
if mibBuilder.loadTexts: hh3cFlhFileEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileEntry.setDescription(' An entry representing a file. Indexed using flash number, partition number, and file number. ')
hh3cFlhFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cFlhFileIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileIndex.setDescription('Index of the table, whose range is from 1 to 2147483647')
hh3cFlhFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhFileName.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileName.setDescription('A valid file name supported by the file system.')
hh3cFlhFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhFileSize.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileSize.setDescription(' The file size in bytes excluding the file header of file system. The value should be greater than zero. ')
hh3cFlhFileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("deleted", 1), ("invalidChecksum", 2), ("valid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhFileStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileStatus.setDescription(' The status should be as follows: deleted(1): The file is in recycle bin. invalidChecksum(2): The checksum of file is invalid; valid(3): A valid file. ')
hh3cFlhFileChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 1, 4, 2, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhFileChecksum.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileChecksum.setDescription('The file checksum in the header of file.')
hh3cFlashOperate = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2))
hh3cFlhOpTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1), )
if mibBuilder.loadTexts: hh3cFlhOpTable.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOpTable.setDescription('Table used to operate flash.')
hh3cFlhOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1), ).setIndexNames((0, "HH3C-FLASH-MAN-MIB", "hh3cFlhOperIndex"))
if mibBuilder.loadTexts: hh3cFlhOpEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOpEntry.setDescription(' Note an operation can not be stopped until it is finished. If notification is configured, NMS will receive a notification at the end of the operation. Entries in the table will be removed automatically in 5 minutes. It can also be deleted by NMS directly. ')
hh3cFlhOperIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cFlhOperIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperIndex.setDescription(' Specifies the index of an entry. It is a random value when creating an entry. ')
hh3cFlhOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("net2FlashWithErase", 1), ("net2FlashWithoutErase", 2), ("flash2Net", 3), ("delete", 4), ("rename", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperType.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperType.setDescription(" Specifies the operation to be executed. net2FlashWithErase Copy a file to flash; erase flash beforehand. net2FlashWithoutErase Copy a file to flash; do not erase flash beforehand. flash2Net Copy a file from flash. delete Delete a file from flash, the file name is specified by hh3cFlhOperSourceFile; rename Change a file's name. ")
hh3cFlhOperProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ftp", 1), ("tftp", 2), ("clusterftp", 3), ("clustertftp", 4))).clone('ftp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperProtocol.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperProtocol.setDescription(" Specifies the protocol used to transfer file. The default protocol is ftp. when 'clusterftp' or 'clustertftp' is selected, the hh3cFlhOperServerAddress needn't be set, the server address can be acquired automatically, the value of hh3cFlhOperServerAddress is uncertain during operation. Both member switch and commander switch can use them if they support HGMP v2. ")
hh3cFlhOperServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 4), IpAddress().clone(hexValue="FFFFFFFF")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperServerAddress.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperServerAddress.setDescription(' The address of remote host acting as server for operation. The default value is 255.255.255.255 ')
hh3cFlhOperServerUser = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperServerUser.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperServerUser.setDescription(' When using ftp to transfer files, the user name must be specified through this node. ')
hh3cFlhOperPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 6), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperPassword.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperPassword.setDescription(' Remote user password for copying via ftp protocol. Optionally, This object may be ignored for protocols other than ftp. ')
hh3cFlhOperSourceFile = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperSourceFile.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperSourceFile.setDescription(' Specifies the source file name to be transferred. It may be located on flash or remote server. It may include the file path if it is applicable. It must be specified. ')
hh3cFlhOperDestinationFile = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 8), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperDestinationFile.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperDestinationFile.setDescription(' Specifies the destination file name. It may be located on flash or remote server. It may include the file path if it is applicable. If it is not specified, the destination file name is the same as source file name for application. ')
hh3cFlhOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 9), Hh3cFlashOperationStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhOperStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperStatus.setDescription('The status of operation.')
hh3cFlhOperEndNotification = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperEndNotification.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperEndNotification.setDescription(" If the value of it is specified 'true', a notification will be generated at the end of the operation. Else no notification will be generated. ")
hh3cFlhOperProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhOperProgress.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperProgress.setDescription('The progress described as the time taken for the operation. ')
hh3cFlhOperRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperRowStatus.setDescription('The row status of this table entry.')
hh3cFlhOperServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cFlhOperServerPort.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperServerPort.setDescription('The port of remote host acting as server for operation. If the value of this object is not specified, the server port is the known protocol port.')
hh3cFlhOperFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 2, 1, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhOperFailReason.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperFailReason.setDescription('The failure reasons of operation.')
hh3cFlashNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 3))
hh3cFlhOperNotification = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 5, 1, 3, 1)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhOperStatus"))
if mibBuilder.loadTexts: hh3cFlhOperNotification.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperNotification.setDescription(' A hh3cFlhOperNotification is sent at the completion of a flash copy operation if hh3cFlhOperEndNotification is true. ')
hh3cFlashMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2))
hh3cFlhMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 1))
hh3cFlhMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 1, 1)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhGroup"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartitionGroup"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhFileGroup"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperationGroup"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhNotificationGroup"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhMIBCompliance = hh3cFlhMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhMIBCompliance.setDescription(' The statement of compliance for those implementing this MIB. ')
hh3cFlashMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2))
hh3cFlhGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2, 1)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhSupportNum"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhSize"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPos"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhName"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipNum"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhDescr"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhInitTime"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhRemovable"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartitionBool"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhMinPartitionSize"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhMaxPartitions"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartitionNum"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhIndex"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhKbyteSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhGroup = hh3cFlhGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhGroup.setDescription('A collection of objects on Flash level information.')
hh3cFlhChipGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2, 3)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhChipID"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipDescr"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipWriteTimesLimit"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipWriteTimes"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipEraseTimesLimit"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhChipEraseTimes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhChipGroup = hh3cFlhChipGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhChipGroup.setDescription('A collection of objects on chip level information.')
hh3cFlhPartitionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2, 4)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhPartFirstChip"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartLastChip"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartSpace"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartSpaceFree"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartFileNum"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartChecksumMethod"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartStatus"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartUpgradeMode"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartName"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartRequireErase"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhPartFileNameLen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhPartitionGroup = hh3cFlhPartitionGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhPartitionGroup.setDescription('A collection of objects providing on partition level information.')
hh3cFlhFileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2, 5)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhFileName"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhFileSize"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhFileStatus"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhFileChecksum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhFileGroup = hh3cFlhFileGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhFileGroup.setDescription('A collection of objects on file level information.')
hh3cFlhOperationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2, 6)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhOperType"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperProtocol"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperServerAddress"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperServerUser"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperPassword"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperSourceFile"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperDestinationFile"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperStatus"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperEndNotification"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperProgress"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperRowStatus"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperServerPort"), ("HH3C-FLASH-MAN-MIB", "hh3cFlhOperFailReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhOperationGroup = hh3cFlhOperationGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhOperationGroup.setDescription('A collection of objects of flash operations.')
hh3cFlhNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 25506, 2, 5, 2, 2, 7)).setObjects(("HH3C-FLASH-MAN-MIB", "hh3cFlhOperNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cFlhNotificationGroup = hh3cFlhNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhNotificationGroup.setDescription('The collection of notifications in the module')
mibBuilder.exportSymbols("HH3C-FLASH-MAN-MIB", hh3cFlhOperServerUser=hh3cFlhOperServerUser, hh3cFlhOperDestinationFile=hh3cFlhOperDestinationFile, hh3cFlhPos=hh3cFlhPos, hh3cFlhOperProgress=hh3cFlhOperProgress, hh3cFlhMIBCompliances=hh3cFlhMIBCompliances, hh3cFlhPartSpace=hh3cFlhPartSpace, hh3cFlashManMIBObjects=hh3cFlashManMIBObjects, hh3cFlhChipWriteTimesLimit=hh3cFlhChipWriteTimesLimit, hh3cFlashTable=hh3cFlashTable, PYSNMP_MODULE_ID=hh3cFlash, hh3cFlash=hh3cFlash, hh3cFlhOperServerPort=hh3cFlhOperServerPort, hh3cFlhChipNum=hh3cFlhChipNum, hh3cFlhOperRowStatus=hh3cFlhOperRowStatus, hh3cFlhChipEraseTimesLimit=hh3cFlhChipEraseTimesLimit, hh3cFlhPartIndex=hh3cFlhPartIndex, hh3cFlhPartitionGroup=hh3cFlhPartitionGroup, hh3cFlhGroup=hh3cFlhGroup, hh3cFlashChips=hh3cFlashChips, hh3cFlhMinPartitionSize=hh3cFlhMinPartitionSize, Hh3cFlashPartitionUpgradeMode=Hh3cFlashPartitionUpgradeMode, hh3cFlhPartChecksumMethod=hh3cFlhPartChecksumMethod, hh3cFlhFileIndex=hh3cFlhFileIndex, hh3cFlhFileTable=hh3cFlhFileTable, Hh3cFlashOperationStatus=Hh3cFlashOperationStatus, hh3cFlashMIBGroups=hh3cFlashMIBGroups, hh3cFlhMaxPartitions=hh3cFlhMaxPartitions, hh3cFlhOperType=hh3cFlhOperType, hh3cFlhMIBCompliance=hh3cFlhMIBCompliance, hh3cFlhDescr=hh3cFlhDescr, hh3cFlhOpEntry=hh3cFlhOpEntry, hh3cFlhKbyteSize=hh3cFlhKbyteSize, hh3cFlhChipEraseTimes=hh3cFlhChipEraseTimes, hh3cFlhFileEntry=hh3cFlhFileEntry, hh3cFlhPartitionTable=hh3cFlhPartitionTable, hh3cFlashMIBConformance=hh3cFlashMIBConformance, hh3cFlashDevice=hh3cFlashDevice, hh3cFlhChipEntry=hh3cFlhChipEntry, hh3cFlhChipSerialNo=hh3cFlhChipSerialNo, hh3cFlhOperStatus=hh3cFlhOperStatus, hh3cFlhPartFileNameLen=hh3cFlhPartFileNameLen, hh3cFlhFileGroup=hh3cFlhFileGroup, hh3cFlhPartSpaceFree=hh3cFlhPartSpaceFree, hh3cFlashEntry=hh3cFlashEntry, hh3cFlhPartFirstChip=hh3cFlhPartFirstChip, hh3cFlhOperEndNotification=hh3cFlhOperEndNotification, hh3cFlhPartitionBool=hh3cFlhPartitionBool, hh3cFlhFileStatus=hh3cFlhFileStatus, hh3cFlhOpTable=hh3cFlhOpTable, hh3cFlhPartFileNum=hh3cFlhPartFileNum, hh3cFlhFileSize=hh3cFlhFileSize, hh3cFlhPartUpgradeMode=hh3cFlhPartUpgradeMode, hh3cFlhSupportNum=hh3cFlhSupportNum, hh3cFlhPartitionEntry=hh3cFlhPartitionEntry, hh3cFlhFiles=hh3cFlhFiles, hh3cFlhInitTime=hh3cFlhInitTime, hh3cFlhPartLastChip=hh3cFlhPartLastChip, hh3cFlhChipID=hh3cFlhChipID, hh3cFlhOperServerAddress=hh3cFlhOperServerAddress, hh3cFlhPartName=hh3cFlhPartName, hh3cFlhPartRequireErase=hh3cFlhPartRequireErase, hh3cFlhSize=hh3cFlhSize, hh3cFlhOperationGroup=hh3cFlhOperationGroup, hh3cFlashOperate=hh3cFlashOperate, hh3cFlhFileName=hh3cFlhFileName, hh3cFlhChipDescr=hh3cFlhChipDescr, hh3cFlhName=hh3cFlhName, hh3cFlhPartitionNum=hh3cFlhPartitionNum, hh3cFlhFileChecksum=hh3cFlhFileChecksum, hh3cFlhOperPassword=hh3cFlhOperPassword, hh3cFlhOperFailReason=hh3cFlhOperFailReason, hh3cFlashPartitions=hh3cFlashPartitions, hh3cFlhPartStatus=hh3cFlhPartStatus, hh3cFlashNotification=hh3cFlashNotification, hh3cFlhChipGroup=hh3cFlhChipGroup, hh3cFlhNotificationGroup=hh3cFlhNotificationGroup, hh3cFlhOperIndex=hh3cFlhOperIndex, hh3cFlhChipTable=hh3cFlhChipTable, hh3cFlhOperNotification=hh3cFlhOperNotification, hh3cFlhRemovable=hh3cFlhRemovable, Hh3cFlashPartitionStatus=Hh3cFlashPartitionStatus, hh3cFlhOperProtocol=hh3cFlhOperProtocol, hh3cFlhOperSourceFile=hh3cFlhOperSourceFile, hh3cFlhIndex=hh3cFlhIndex, hh3cFlhChipWriteTimes=hh3cFlhChipWriteTimes)

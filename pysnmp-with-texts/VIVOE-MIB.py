#
# PySNMP MIB module VIVOE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/VIVOE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:34:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
ModuleIdentity, Integer32, TimeTicks, Gauge32, IpAddress, NotificationType, iso, Bits, enterprises, ObjectIdentity, Counter32, Unsigned32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Integer32", "TimeTicks", "Gauge32", "IpAddress", "NotificationType", "iso", "Bits", "enterprises", "ObjectIdentity", "Counter32", "Unsigned32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier")
MacAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TextualConvention", "DisplayString")
vivoeMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 35990, 3, 1))
vivoeMIB.setRevisions(('2012-02-16 13:24', '2010-11-04 15:53',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: vivoeMIB.setRevisionsDescriptions(('Issue 2, published in Def Stan 00-82 Part 1 Issue 2. Summary of corrections and additions: 1. DisplayString textual conventions modified to only allow printable characters. 2. deviceMibVersion description updated to reflect the new version number. 3. New ethernetIfIpAddressConflict object replacing the ethernetIfMtu object. 4. New deviceNatoStockNumber, deviceMode and deviceReset objects added. 5. Ranges added to the bit depth, FPS and SAP message interval objects in the video format and channel control tables. 6. New videoFormatColorimetry object added to the preset video format table. 7. New compression, ROI and RPT payload type objects added to the video format table to support default configuration start-up. 8. channelReset object allows one or more channels to be reset independently from the rest of the device. 9. channelStatus object includes single frame mode. 10. New channelColorimetry object added. 11. channelCompressionFactor changed to read-only access and loaded from videoFormatTable when setting channel. 12. New ROI bottom and right extent objects added with changes to resolution and ROI objects to support decimation and interpolation of ROIs, and scaling and cropping of display images. 13. New channelDefaultVideoFormatIndex and channelDefaultReceiveIpAddress objects added to support default configuration start-up. 14. Notification objects added for device errors and IP address conflicts. 15. Conformance group replace with groups to identify preset objects, channel configuration objects, maintenance mode objects and volatile objects.', 'Initial version, published in Def Stan 00-82 Issue 1.',))
if mibBuilder.loadTexts: vivoeMIB.setLastUpdated('201202161324Z')
if mibBuilder.loadTexts: vivoeMIB.setOrganization('Defence Equipment and Support (DE&S) Land Equipment')
if mibBuilder.loadTexts: vivoeMIB.setContactInfo('Portfolio and Programme Support Team Defence Equipment and Support (DE&S) Land Equipment UK Ministry of Defence Email: desle-defstans@mod.uk')
if mibBuilder.loadTexts: vivoeMIB.setDescription('The private MIB module definition for the management and control of devices in a digital video architecture compliant with the Vetronics Infrastructure for Video Over Ethernet (VIVOE) Defence Standard. The MIB is defined in Appendix A of Def Stan 00-82 Part 1 Issue 2.')
class DisplayString16(TextualConvention, OctetString):
    description = 'This data type shall conform to the NVT ASCII character set, as defined in RFC 854, but shall be limited to only the displayable characters and shall exclude 0x00 (NUL), 0x0A (CR) and 0x0D (LF). It is based on the SNMPv2-TC DisplayString type limited to 16 displayable characters.'
    status = 'current'
    displayHint = '16a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 16)

class DisplayString32(TextualConvention, OctetString):
    description = 'This data type shall conform to the NVT ASCII character set, as defined in RFC 854, but shall be limited to only the displayable characters and shall exclude 0x00 (NUL), 0x0A (CR) and 0x0D (LF). It is based on the SNMPv2-TC DisplayString type limited to 32 displayable characters.'
    status = 'current'
    displayHint = '32a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class DisplayString64(TextualConvention, OctetString):
    description = 'This data type shall conform to the NVT ASCII character set, as defined in RFC 854, but shall be limited to only the displayable characters and shall exclude 0x00 (NUL), 0x0A (CR) and 0x0D (LF). It is based on the SNMPv2-TC DisplayString type limited to 64 displayable characters.'
    status = 'current'
    displayHint = '64a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

desle = MibIdentifier((1, 3, 6, 1, 4, 1, 35990))
desleProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 35990, 3))
deviceInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1))
deviceDesc = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 1), DisplayString32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceDesc.setStatus('current')
if mibBuilder.loadTexts: deviceDesc.setDescription('A textual description of the main function of the device, i.e. whether it is a colour camera, a sensor interface or a display interface etc.')
deviceManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 2), DisplayString64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceManufacturer.setStatus('current')
if mibBuilder.loadTexts: deviceManufacturer.setDescription('A textual name for the manufacturer of the device.')
devicePartNumber = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 3), DisplayString32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devicePartNumber.setStatus('current')
if mibBuilder.loadTexts: devicePartNumber.setDescription("The manufacturer's part number for the device.")
deviceSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 4), DisplayString32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSerialNumber.setStatus('current')
if mibBuilder.loadTexts: deviceSerialNumber.setDescription('The serial number of the device.')
deviceHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 5), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: deviceHardwareVersion.setDescription('The hardware version of the device, if applicable.')
deviceSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 6), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: deviceSoftwareVersion.setDescription('The software version of the device, if applicable.')
deviceFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 7), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: deviceFirmwareVersion.setDescription('The firmware version of the device, if applicable.')
deviceMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 8), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMibVersion.setStatus('current')
if mibBuilder.loadTexts: deviceMibVersion.setDescription("The MIB version implemented on the device. For this version of MIB the object shall be set to 'Issue 2' by the SNMP agent on the device.")
deviceType = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("serviceProvider", 1), ("serviceUser", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceType.setStatus('current')
if mibBuilder.loadTexts: deviceType.setDescription("The basic functionality of the device, whether it is a service provider (a transmitter, camera etc.) or a service user (receiver, display etc). If the device can be both a service provider and user (e.g. an image processor) the object value shall be 'both'.")
deviceUserDesc = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 10), DisplayString64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceUserDesc.setStatus('current')
if mibBuilder.loadTexts: deviceUserDesc.setDescription('A textual description assigned by the user or the system integrator to uniquely identify the device in a system, e.g. rear driving camera, image processor etc. The object can be set (when the device is in the maintenance mode) by a manager to allow the description to be changed when the device is moved or its function reconfigured. The new value shall only become active after a reset or reboot.')
ethernetIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetIfNumber.setStatus('current')
if mibBuilder.loadTexts: ethernetIfNumber.setDescription('The number of Ethernet network interfaces on the device that communicate with the VIVOE system. Up to 255 interfaces may be supported.')
ethernetIfTable = MibTable((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12), )
if mibBuilder.loadTexts: ethernetIfTable.setStatus('current')
if mibBuilder.loadTexts: ethernetIfTable.setDescription('A table of Ethernet network interfaces on the device that communicate with the VIVOE system. The number of entries is specified by ethernetIfNumber.')
ethernetIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1), ).setIndexNames((0, "VIVOE-MIB", "ethernetIfIndex"))
if mibBuilder.loadTexts: ethernetIfEntry.setStatus('current')
if mibBuilder.loadTexts: ethernetIfEntry.setDescription('An entry in the table of Ethernet network interfaces on the device. A row in this table cannot be created or deleted by SNMP operations on columns in the table. The interface in the first column in the table shall be designated the primary interface.')
ethernetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: ethernetIfIndex.setStatus('current')
if mibBuilder.loadTexts: ethernetIfIndex.setDescription('The index for each entry in the table of Ethernet network interfaces on the device. The index value range shall be from 1 to the number of entries is specified by ethernetIfNumber.')
ethernetIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1, 2), Integer32()).setUnits('Mbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetIfSpeed.setStatus('current')
if mibBuilder.loadTexts: ethernetIfSpeed.setDescription('The maximum speed of the Ethernet interface in Mbps (e.g. for a Gigabit Ethernet interface the value would be 1000). This figure shall not necessary reflect the actual link speed that the interface is running at if auto- negotiation has been undertaken. The actual speed for the link can be obtained from the switch port the interface is connected to.')
ethernetIfMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetIfMacAddress.setStatus('current')
if mibBuilder.loadTexts: ethernetIfMacAddress.setDescription('The MAC address of the Ethernet interface represented as a string of 6 octets as defined in SNMPv2-TC (i.e. a MAC address of 01:02:03:F4:F5:F6 shall be stored as 0x010203F4F5F6). A unique address shall be assigned by the device manufacturer.')
ethernetIfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetIfIpAddress.setStatus('current')
if mibBuilder.loadTexts: ethernetIfIpAddress.setDescription('This is the statically assigned IP address of the interface on the device. An SNMP manager may change the IP address (if the device is in the maintenance mode) but the new value shall only become active after a reset or reboot. Def Stan 00-82 specifies the ranges from which the IP address shall be selected. The first entry in the table shall be designated as the primary interface with subsequent entries designated as secondary interfaces in a multi-interface device. All SNMP control on the device shall be undertaken using the primary interface. There is no requirement for the addresses of secondary interfaces to be on the same subnet as the primary address as long as the subnet masks are configured correctly. If the device is a service provider the last byte of the primary IP address shall also be used as the last byte of the multicast IP address that the device transmits on, as defined in Def Stan 00-82 Part 1.')
ethernetIfSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetIfSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ethernetIfSubnetMask.setDescription('This is the subnet mask associated with the IP address of this interface. The value of the mask is an IP address with all the network bits set to 1 and all the host bits set to 0. The valid subnet masks are defined in Def Stan 00-82 Part 1. An SNMP manager may change the subnet mask (if the device is in the maintenance mode) but the new value shall only become active after a reset or reboot.')
ethernetIfIpAddressConflict = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 12, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetIfIpAddressConflict.setStatus('current')
if mibBuilder.loadTexts: ethernetIfIpAddressConflict.setDescription('If the device detected conflicting IP addresses on power up or after reset it shall store the last conflicting address in this object. The object shall be sent during the IP address conflict notification procedure and shall be reset to 0.0.0.0 (when in the maintenance mode) by a manager when the notification is acknowledged.')
deviceNatoStockNumber = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 13), DisplayString32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceNatoStockNumber.setStatus('current')
if mibBuilder.loadTexts: deviceNatoStockNumber.setDescription('The NATO stock number (NSN) of the device.')
deviceMode = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("defaultStartUp", 2), ("maintenanceMode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceMode.setStatus('current')
if mibBuilder.loadTexts: deviceMode.setDescription("This object shall be used to set the mode of the device. 1 - In the normal mode the device shall boot into a 'stopped' state and . The device shall require the channelStatus object to be set to 'start' to initiate transmission or reception of a video stream. 2 - In the default configuration start-up mode the device shall boot into a pre-defined state e.g. a service provider may automatically start transmitting a pre- defined video format or a service user may be set-up to receive a pre-defined video stream. 3 - In the maintenance mode the objects listed in the maintenanceModeGroup may be set to perform maintenance and configuration tasks on the device.")
deviceReset = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceReset.setStatus('current')
if mibBuilder.loadTexts: deviceReset.setDescription('This object can be used to initiate a reboot or reset on the device and thus enable a currently disabled video format. 1 - Normal denotes that the device is in running mode. 2 - Setting this object to 2 initiates the reboot or reset. When the device has rebooted this object shall be reset to 1 by the device.')
videoFormatInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2))
videoFormatNumber = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatNumber.setStatus('current')
if mibBuilder.loadTexts: videoFormatNumber.setDescription('The number of distinct video formats supported by the device. Up to 255 video formats may be supported.')
videoFormatTable = MibTable((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2), )
if mibBuilder.loadTexts: videoFormatTable.setStatus('current')
if mibBuilder.loadTexts: videoFormatTable.setDescription('A table of all the distinct video formats supported by the device. The number of entries is specified by videoFormatNumber.')
videoFormatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1), ).setIndexNames((0, "VIVOE-MIB", "videoFormatIndex"))
if mibBuilder.loadTexts: videoFormatEntry.setStatus('current')
if mibBuilder.loadTexts: videoFormatEntry.setDescription('An entry in the table of distinct video formats supported by the device. A row in this table cannot be created or deleted by SNMP operations on columns of the table. The objects in the row can be read to determine the video formats supported and the capabilities of the device. This information can be used to determine how to control the device using the objects in channelTable.')
videoFormatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: videoFormatIndex.setStatus('current')
if mibBuilder.loadTexts: videoFormatIndex.setDescription('The index for each entry in the table of distinct video formats supported by the device. The index value range shall be from 1 to the number of entries is specified by videoFormatNumber.')
videoFormatType = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("videoChannel", 1), ("roi", 2), ("serviceUser", 3), ("rawData", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatType.setStatus('current')
if mibBuilder.loadTexts: videoFormatType.setDescription('The main function of the format. The types defined are: 1 - A service provider format supporting full frame video. 2 - A service provider format supporting a Region of Interest (ROI). 3 - The format is a service user format. 4 - The format is a data format using the mechanisms defined in Appendix E of Def Stan 00-82 Part 1. 5 - The format is an undefined, system specific type.')
videoFormatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatStatus.setStatus('current')
if mibBuilder.loadTexts: videoFormatStatus.setDescription('This object denotes whether the video format described in this entry in the table is currently enabled or disabled. The status types defined are: 1 - Enabled denotes that the video format can be used by a channel without the device needing to be reset or rebooted. A channel can therefore simply be set-up to start transmitting or receiving this video format by a manager. 2 - Disabled denotes that to use this video format the device will need to be reset or rebooted after a manager has set a channel to use the format. The channel video format shall be set using the channelVideoFormatIndex object. The device shall be reset or rebooted using either the deviceReset or channelReset objects, as appropriate. The status and performance of the channel cannot be guaranteed after it has been set to this video format until a reset or reboot has been undertaken.')
videoFormatBase = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 4), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatBase.setStatus('current')
if mibBuilder.loadTexts: videoFormatBase.setDescription("The basic video format for this entry. For uncompressed video this shall be set to 'raw' and for compressed video, the compression scheme used will be designated using the relevant IANA MIME media type specifier from the RTP payload format name (e.g. jpeg2000, H264).")
videoFormatSampling = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 5), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatSampling.setStatus('current')
if mibBuilder.loadTexts: videoFormatSampling.setDescription("The video pixel sampling format for this entry. This shall be the same as the 'sampling' parameter from the SDP description (e.g. YCbCr-4:2:2, RGB, GRAYSCALE). If not required (e.g. the format is MPEG-4 compressed) the value shall be 'none'.")
videoFormatBitDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatBitDepth.setStatus('current')
if mibBuilder.loadTexts: videoFormatBitDepth.setDescription("The number of bits used to encode a pixel or series of pixels for this entry. This shall be the same as the 'depth' parameter from the SDP mapping description. If not required (e.g. the format is MPEG-4 compressed) the value shall be 0.")
videoFormatFps = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setUnits('Frame per Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatFps.setStatus('current')
if mibBuilder.loadTexts: videoFormatFps.setDescription('The maximum number of frames per second. If the format is interlaced the number of fields per second will be twice this figure.')
videoFormatColorimetry = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 8), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatColorimetry.setStatus('current')
if mibBuilder.loadTexts: videoFormatColorimetry.setDescription("The colorimetry specification for this entry. This shall be the same as the 'colorimetry' parameter from the SDP description (e.g. BT601-5). If not required the value shall be 'none'.")
videoFormatInterlaced = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("interlaced", 1), ("progressive", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatInterlaced.setStatus('current')
if mibBuilder.loadTexts: videoFormatInterlaced.setDescription("Denotes whether the video format is interlaced or progressive scan. If not required the value shall be 'none'. The scan types defined are: 1 - Interlaced. 2 - Progressive scan. 3 - None.")
videoFormatCompressionFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("targetRate", 1), ("targetQuality", 2), ("lossless", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatCompressionFactor.setStatus('current')
if mibBuilder.loadTexts: videoFormatCompressionFactor.setDescription('If the format employs compression, this object specifies the factor on which the video compression rate is based. The compression factors defined are: 1 - Target Rate: The compression factor shall be set to achieve the target rate specified in Mbps in videoFormatCompressionRate. 2 - Target Quality: The compression factor shall be set to achieve the subjective quality factor specified in videoFormatCompressionRate. 3 - Lossless compression employed. 4 - None.')
videoFormatCompressionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatCompressionRate.setStatus('current')
if mibBuilder.loadTexts: videoFormatCompressionRate.setDescription('When the videoFormatCompressionFactor object is set to targetRate, this object shall specify the maximum target rate in Mbps. When the videoFormatCompressionFactor object is set to targetQuality, this object shall specify a subjective quality factor with 1 being the lowest quality and 16 being the highest (virtually lossless) quality. The object may be set (when in the maintenance mode) to configure a default start-up rate for the format. If the format is uncompressed the value shall be 0.')
videoFormatMaxHorzRes = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 12), Integer32()).setUnits('pixels').setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatMaxHorzRes.setStatus('current')
if mibBuilder.loadTexts: videoFormatMaxHorzRes.setDescription('The maximum horizontal resolution supported by this video format for a service provider or a ROI.')
videoFormatMaxVertRes = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 13), Integer32()).setUnits('pixels').setMaxAccess("readonly")
if mibBuilder.loadTexts: videoFormatMaxVertRes.setStatus('current')
if mibBuilder.loadTexts: videoFormatMaxVertRes.setDescription('The maximum vertical resolution supported by this video format for a service provider or a ROI.')
videoFormatRoiHorzRes = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 14), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRoiHorzRes.setStatus('current')
if mibBuilder.loadTexts: videoFormatRoiHorzRes.setDescription('If the format is a ROI this object shall specify the horizontal resolution of the ROI. If the format is not a ROI the value shall be 0. The relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. The object may be set (when in the maintenance mode) to configure a default start-up ROI.')
videoFormatRoiVertRes = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 15), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRoiVertRes.setStatus('current')
if mibBuilder.loadTexts: videoFormatRoiVertRes.setDescription('If the format is a ROI this object shall specify the vertical resolution of the ROI. If the format is not a ROI the value shall be 0. The relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. The object may be set (when in the maintenance mode) to configure a default start-up ROI.')
videoFormatRoiOriginTop = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 16), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRoiOriginTop.setStatus('current')
if mibBuilder.loadTexts: videoFormatRoiOriginTop.setDescription('If the format is a ROI this object shall specify the top origin of the ROI. If the format is not a ROI the value shall be 0. The relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. The object may be set (when in the maintenance mode) to configure a default start-up ROI.')
videoFormatRoiOriginLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 17), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRoiOriginLeft.setStatus('current')
if mibBuilder.loadTexts: videoFormatRoiOriginLeft.setDescription('If the format is a ROI this object shall specify the left origin of the ROI. If the format is not a ROI the value shall be 0. The relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. The object may be set (when in the maintenance mode) to configure a default start-up ROI.')
videoFormatRoiExtentBottom = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 18), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRoiExtentBottom.setStatus('current')
if mibBuilder.loadTexts: videoFormatRoiExtentBottom.setDescription('If the format is a scalable ROI this object shall specify the bottom extent of the ROI. If the format is not a ROI or is a non-scalable ROI the value shall be 0. The relationship between this object and the other ROI objects shall determine what scaling is required, as specified in Def Stan 00-82. The object may be set (when in the maintenance mode) to configure a default start-up ROI.')
videoFormatRoiExtentRight = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 19), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRoiExtentRight.setStatus('current')
if mibBuilder.loadTexts: videoFormatRoiExtentRight.setDescription('If the format is a scalable ROI this object shall specify the default right extent of the ROI. If the format is not a ROI or is a non-scalable ROI the value shall be 0. The relationship between this object and the other ROI objects shall determine what scaling is required, as specified in Def Stan 00-82. The object may be set (when in the maintenance mode) to configure a default start-up ROI.')
videoFormatRtpPt = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: videoFormatRtpPt.setStatus('current')
if mibBuilder.loadTexts: videoFormatRtpPt.setDescription('For a service provider this is the RTP Payload Type number in the RTP header for this format. Payload Types from 0 to 95 are statically assigned or reserved, while 96 to 127 are dynamically assigned. The object may be set (when in the maintenance mode) to configure a default start-up Payload Type for the format.')
channelControl = MibIdentifier((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3))
channelReset = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelReset.setStatus('current')
if mibBuilder.loadTexts: channelReset.setDescription('In the maintenance mode this object may be used to initiate a reboot or reset on a particular channel. This will set the channel to its default state. 0 - Normal denotes that the device is in the normal running mode. 1..254 - Setting the object to these values will initiate a reboot or reset on the specified channel When the device has rebooted or reset the channel, this object shall be reset to 0 by the device. 255 - Setting the object to 255 will initiate a reboot or reset all the channels. When the device has rebooted or reset the channels, this object shall be reset to 0 by the device.')
channelNumber = MibScalar((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelNumber.setStatus('current')
if mibBuilder.loadTexts: channelNumber.setDescription('The number of video channels supported by the device. For a service provider channels may be multiple video streams or ROIs. For service users it may be the number of digital video streams that can be simultaneously supported. Up to 254 channels may be supported.')
channelTable = MibTable((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3), )
if mibBuilder.loadTexts: channelTable.setStatus('current')
if mibBuilder.loadTexts: channelTable.setDescription('A table of channels supported by the device. The number of entries is specified by channelNumber.')
channelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1), ).setIndexNames((0, "VIVOE-MIB", "channelIndex"))
if mibBuilder.loadTexts: channelEntry.setStatus('current')
if mibBuilder.loadTexts: channelEntry.setDescription('An entry in the table of channels supported by the device. A row in this table cannot be created or deleted by SNMP operations on columns of the table. The objects in the row can be read to obtain the current status of the channel and set to control the functionality of the channel. For service providers, part of the multicast IP address that the service provider transmits on is derived from this number, as defined in Def Stan 00-82 Part 1.')
channelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: channelIndex.setStatus('current')
if mibBuilder.loadTexts: channelIndex.setDescription('The index for each entry in the table of channels supported by the device. The index value range shall be from 1 to the number of entries is specified by channelNumber.')
channelType = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("videoChannel", 1), ("roi", 2), ("serviceUser", 3), ("rawData", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelType.setStatus('current')
if mibBuilder.loadTexts: channelType.setDescription('The main function of the channel. The types defined are: 1 - A service provider channel providing full frame video. 2 - A service provider channel providing a ROI. The size of the ROI is designated by channelHorzRes and channelVertRes objects and the position by the origin and extent objects. 3 - The channel is a service user channel. 4 - The channel is a data channel using the mechanisms defined in Appendix E of Def Stan 00-82 Part 1. 5 - The channel is an undefined, system specific type.')
channelUserDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 3), DisplayString64()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelUserDesc.setStatus('current')
if mibBuilder.loadTexts: channelUserDesc.setDescription('A textual description assigned by the user or the system integrator to uniquely identify the channel on the device in a system, e.g. front LSA camera etc. The object can be set (when the device is in the maintenance mode) by a manager to allow the description to be changed when the device is moved or its function reconfigured. The new value shall only become active after a reset or reboot. This object shall also be used to set the SDP Session Name field for SAP announcement messages for the channel, when it may be combined with the deviceUserDesc object in multi-channel devices.')
channelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("start", 1), ("stop", 2), ("singleFrame", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelStatus.setStatus('current')
if mibBuilder.loadTexts: channelStatus.setDescription('The current status of the channel. Setting the value of this object shall also be used to start or stop the encoding or decoding on the channel. Other objects shall be used to set parameters and settings on the channel before the channel is started or re-started. The status types defined are: 1 - Start encoding or decoding on the channel. 2 - Stop encoding or decoding on the channel. 3 - When the object is set to single frame, a service provider will immediately transmit a single frame of video, if this functionality is implemented.')
channelVideoFormatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelVideoFormatIndex.setStatus('current')
if mibBuilder.loadTexts: channelVideoFormatIndex.setDescription('This object cross-references the videoFormatIndex object in the videoFormatTable and may be set to select the corresponding video format for the channel. The device shall then update the objects listed in the setChannelGroup to the corresponding values for the video format. The object shall default to 0 until a video format is specified and shall always be 0 in a service user.')
channelVideoFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 6), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelVideoFormat.setStatus('current')
if mibBuilder.loadTexts: channelVideoFormat.setDescription("The video format currently being processed on the channel. For uncompressed video this shall be set to 'raw' and for compressed video, the compression scheme used will be designated using the relevant IANA MIME media type specifier from the RTP payload format name (e.g. jpeg2000, H264). If the device is not processing video on the channel the value shall be 'none'.")
channelVideoSampling = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 7), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelVideoSampling.setStatus('current')
if mibBuilder.loadTexts: channelVideoSampling.setDescription("The video pixel sampling format currently being processed on the channel. This shall be the same as the 'sampling' parameter from the SDP mapping description (e.g. YCbCr-4:2:2, RGB, GRAYSCALE). If the device is not processing video on the channel or the value is not required (e.g. the format is MPEG-4 compressed) the value shall be 'none'.")
channelVideoBitDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelVideoBitDepth.setStatus('current')
if mibBuilder.loadTexts: channelVideoBitDepth.setDescription("The number of bits used to encode a pixel or series of pixels in the current video format on this channel. This shall be the same as the 'depth' parameter from the SDP mapping description. If not required (e.g. the format is MPEG-4 compressed) the value shall be 0.")
channelFps = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('Frames per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: channelFps.setStatus('current')
if mibBuilder.loadTexts: channelFps.setDescription('The maximum number of frames per second for the format on this channel. If the format is interlaced the number of fields per second will be twice this figure.')
channelColorimetry = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 10), DisplayString16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelColorimetry.setStatus('current')
if mibBuilder.loadTexts: channelColorimetry.setDescription("The colorimetry specification for the format on this channel. This shall be the same as the 'colorimetry' parameter from the SDP description (e.g. BT601-5). If not required the value shall be 'none'.")
channelInterlaced = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("interlaced", 1), ("progressive", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelInterlaced.setStatus('current')
if mibBuilder.loadTexts: channelInterlaced.setDescription("Denotes whether the video format currently be processed by the channel is interlaced or progressive scan video. If the device is not processing video on the channel the value shall be 'none'. The scan types defined are: 1 - Interlaced. 2 - Progressive scan. 3 - None.")
channelCompressionFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("targetRate", 1), ("targetQuality", 2), ("lossless", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelCompressionFactor.setStatus('current')
if mibBuilder.loadTexts: channelCompressionFactor.setDescription('The factor on which the video compression rate is based, if applicable. The compression types defined are: 1 - Target Rate: The compression factor shall be set to achieve the target rate specified in Mbps in channelCompressionRate. 2 - Target Quality: The compression factor shall be set to achieve the subjective quality factor specified in channelCompressionRate. 3 - Lossless compression employed. 4 - None.')
channelCompressionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelCompressionRate.setStatus('current')
if mibBuilder.loadTexts: channelCompressionRate.setDescription('When the channelCompressionFactor object is set to targetRate, this object shall specify the maximum target rate in Mbps. When the channelCompressionFactor object is set to targetQuality, this object shall specify a subjective quality factor with 1 being the lowest quality and 16 being the highest (virtually lossless) quality. If the device is not processing compressed video the value shall be 0. This object can be set to request a new compression rate.')
channelHorzRes = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 14), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelHorzRes.setStatus('current')
if mibBuilder.loadTexts: channelHorzRes.setDescription('The current horizontal resolution of the channel. If the channel is a ROI, this object can be set to request a new horizontal resolution for the ROI. The relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. If the channel is a service user, the relationship shall determine whether the image shall be scaled or cropped and how it is windowed on a display, as specified in Def Stan 00-82.')
channelVertRes = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 15), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelVertRes.setStatus('current')
if mibBuilder.loadTexts: channelVertRes.setDescription('The current vertical resolution of the channel. If the channel is a ROI, this object can be set to request a new vertical resolution for the ROI. The relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. If the channel is a service user, the relationship shall determine whether the image shall be scaled or cropped and how it is windowed on a display, as specified in Def Stan 00-82.')
channelRoiOriginTop = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 16), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelRoiOriginTop.setStatus('current')
if mibBuilder.loadTexts: channelRoiOriginTop.setDescription('If the channel is a ROI, this object shall specify the top origin of the ROI. The object can be set to move the ROI and the relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. If the channel is a service user, the relationship shall determine whether the image shall be scaled or cropped and how it is windowed on a display, as specified in Def Stan 00-82. If the channel is a service provider the value shall be 0.')
channelRoiOriginLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 17), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelRoiOriginLeft.setStatus('current')
if mibBuilder.loadTexts: channelRoiOriginLeft.setDescription('If the channel is a ROI, this object shall specify the left origin of the ROI. The object can be set to move the ROI and the relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. If the channel is a service user, the relationship shall determine whether the image shall be scaled or cropped and how it is windowed on a display, as specified in Def Stan 00-82. If the channel is a service provider the value shall be 0.')
channelRoiExtentBottom = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 18), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelRoiExtentBottom.setStatus('current')
if mibBuilder.loadTexts: channelRoiExtentBottom.setDescription('If the channel is a scalable ROI, this object shall specify the bottom extent of the ROI. The object can be set to modify the ROI and the relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. If the channel is a service user, the relationship shall determine whether the image shall be scaled or cropped and how it is windowed on a display, as specified in Def Stan 00-82. If the channel is a service provider or a non-scaled ROI the value shall be 0.')
channelRoiExtentRight = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 19), Integer32()).setUnits('pixels').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelRoiExtentRight.setStatus('current')
if mibBuilder.loadTexts: channelRoiExtentRight.setDescription('If the channel is a scalable ROI, this object shall specify the right extent of the ROI. The object can be set to modify the ROI and the relationship between this object and the other ROI objects shall determine whether the ROI is scalable and what scaling is required, as specified in Def Stan 00-82. If the channel is a service user, the relationship shall determine whether the image shall be scaled or cropped and how it is windowed on a display, as specified in Def Stan 00-82. If the channel is a service provider or a non-scaled ROI the value shall be 0.')
channelRtpPt = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelRtpPt.setStatus('current')
if mibBuilder.loadTexts: channelRtpPt.setDescription('For a service provider this is the RTP Payload Type ID in the RTP header associated with this channel. The Payload Type IDs from 0 to 95 are statically assigned or reserved in RFC 3551 to particular audio or video formats, while the IDs from 96 to 127 are dynamically assigned. The same ID can be used for multiple channels. For service users it shall be set to the RTP Payload Type ID for the RTP currently being received.')
channelReceiveIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelReceiveIpAddress.setStatus('current')
if mibBuilder.loadTexts: channelReceiveIpAddress.setDescription('For a service user channel this object is the multicast IP address to receive RTP encoded video or data on and can be changed to select a new RTP stream. A service user channel shall not start processing the stream (or join the relevant multicast group) until it is re-started using the channelStatus object unless it is in the default start-up mode. If a service user channel is not currently receiving a stream or the channel is a service provider channel or ROI the value shall be null or 0.0.0.0.')
channelInterPacketDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 22), Integer32()).setUnits('microseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelInterPacketDelay.setStatus('current')
if mibBuilder.loadTexts: channelInterPacketDelay.setDescription('This object may be used to set the delay in microseconds between RTP packets on this channel. The time is measured from the end of the previous packet to the beginning of the next packet in the stream. The value of this object can be set (when in the maintenance mode) to request a new delay time to implement simple flow control on the network. If a service provider does not have a programmable inter- packet delay then it shall ignore this object and set it to the default value of 0. Not applicable for service users.')
channelSapMessageInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelSapMessageInterval.setStatus('current')
if mibBuilder.loadTexts: channelSapMessageInterval.setDescription('The interval (in milliseconds) between transmitted SAP/SDP messages. The value of this object can be set (when in the maintenance mode) to request a new interval. The default value shall be 1000 (1 second). If a service provider does not have a programmable interval then it shall ignore this object. Not applicable for service users.')
channelDefaultVideoFormatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelDefaultVideoFormatIndex.setStatus('current')
if mibBuilder.loadTexts: channelDefaultVideoFormatIndex.setDescription('This object cross-references the videoFormatIndex object in the videoFormatTable and may be set (when in the maintenance mode) to define the default video format that a service provider shall transmit if the deviceMode object is set to defaultStartUp. At start-up the device shall update all the objects listed in the setChannelGroup to the corresponding values in the default video format. If no default mode is specified or the device is a service user the value shall be 0.')
channelDefaultReceiveIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 35990, 3, 1, 3, 3, 1, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelDefaultReceiveIpAddress.setStatus('current')
if mibBuilder.loadTexts: channelDefaultReceiveIpAddress.setDescription('For a service user channel this object is the default multicast IP address that that a service user shall receive RTP encoded video or data on at start-up if the deviceMode object is set to defaultStartUp. A service user channel shall join the relevant multicast group and start processing the stream regardless of the state of the channelStatus object. If no default is set or channel is a service provider channel the value shall be null or 0.0.0.0. The object may be set (when in the maintenance mode) to define the default receive address.')
vivoeNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 35990, 3, 1, 4))
deviceError = NotificationType((1, 3, 6, 1, 4, 1, 35990, 3, 1, 4, 1)).setObjects(("VIVOE-MIB", "deviceUserDesc"), ("VIVOE-MIB", "deviceMode"))
if mibBuilder.loadTexts: deviceError.setStatus('current')
if mibBuilder.loadTexts: deviceError.setDescription('This trap is sent when an unspecified error has been detected on the device. The message shall be sent using the broadcast IP address specified in Def Stan 00-82 Part 1.')
ipAddressConflict = NotificationType((1, 3, 6, 1, 4, 1, 35990, 3, 1, 4, 2)).setObjects(("VIVOE-MIB", "ethernetIfIpAddress"), ("VIVOE-MIB", "ethernetIfIpAddressConflict"))
if mibBuilder.loadTexts: ipAddressConflict.setStatus('current')
if mibBuilder.loadTexts: ipAddressConflict.setDescription('This notification message is sent when an IP address conflict has been detected by the device. The notification includes the last IP address a conflict was detected on. The message shall be sent using the broadcast IP address specified in Def Stan 00-82 Part 1.')
vivoeGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 35990, 3, 1, 5))
presetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 35990, 3, 1, 5, 1)).setObjects(("VIVOE-MIB", "deviceDesc"), ("VIVOE-MIB", "deviceManufacturer"), ("VIVOE-MIB", "devicePartNumber"), ("VIVOE-MIB", "deviceSerialNumber"), ("VIVOE-MIB", "deviceHardwareVersion"), ("VIVOE-MIB", "deviceSoftwareVersion"), ("VIVOE-MIB", "deviceFirmwareVersion"), ("VIVOE-MIB", "deviceMibVersion"), ("VIVOE-MIB", "deviceType"), ("VIVOE-MIB", "ethernetIfNumber"), ("VIVOE-MIB", "ethernetIfSpeed"), ("VIVOE-MIB", "ethernetIfMacAddress"), ("VIVOE-MIB", "deviceNatoStockNumber"), ("VIVOE-MIB", "videoFormatNumber"), ("VIVOE-MIB", "videoFormatType"), ("VIVOE-MIB", "videoFormatStatus"), ("VIVOE-MIB", "videoFormatBase"), ("VIVOE-MIB", "videoFormatSampling"), ("VIVOE-MIB", "videoFormatBitDepth"), ("VIVOE-MIB", "videoFormatFps"), ("VIVOE-MIB", "videoFormatColorimetry"), ("VIVOE-MIB", "videoFormatInterlaced"), ("VIVOE-MIB", "videoFormatCompressionFactor"), ("VIVOE-MIB", "videoFormatMaxHorzRes"), ("VIVOE-MIB", "videoFormatMaxVertRes"), ("VIVOE-MIB", "channelNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    presetGroup = presetGroup.setStatus('current')
if mibBuilder.loadTexts: presetGroup.setDescription('The objects whose values shall be preset by the manufacturer of the device and cannot be subsequently changed via the MIB.')
setChannelGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 35990, 3, 1, 5, 2)).setObjects(("VIVOE-MIB", "channelType"), ("VIVOE-MIB", "channelVideoFormat"), ("VIVOE-MIB", "channelVideoSampling"), ("VIVOE-MIB", "channelVideoBitDepth"), ("VIVOE-MIB", "channelFps"), ("VIVOE-MIB", "channelColorimetry"), ("VIVOE-MIB", "channelInterlaced"), ("VIVOE-MIB", "channelCompressionFactor"), ("VIVOE-MIB", "channelCompressionRate"), ("VIVOE-MIB", "channelHorzRes"), ("VIVOE-MIB", "channelVertRes"), ("VIVOE-MIB", "channelRoiOriginTop"), ("VIVOE-MIB", "channelRoiOriginLeft"), ("VIVOE-MIB", "channelRoiExtentBottom"), ("VIVOE-MIB", "channelRoiExtentRight"), ("VIVOE-MIB", "channelRtpPt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    setChannelGroup = setChannelGroup.setStatus('current')
if mibBuilder.loadTexts: setChannelGroup.setDescription('The list of objects that a service provider shall update when setting a channel to a particular video format. In the normal mode the format shall be selected by the channelVideoFormatIndex object and by the channelDefaultVideoFormatIndex object in the default configuration start-up mode.')
maintenanceModeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 35990, 3, 1, 5, 3)).setObjects(("VIVOE-MIB", "deviceUserDesc"), ("VIVOE-MIB", "ethernetIfIpAddress"), ("VIVOE-MIB", "ethernetIfSubnetMask"), ("VIVOE-MIB", "ethernetIfIpAddressConflict"), ("VIVOE-MIB", "deviceReset"), ("VIVOE-MIB", "videoFormatCompressionRate"), ("VIVOE-MIB", "videoFormatRoiHorzRes"), ("VIVOE-MIB", "videoFormatRoiVertRes"), ("VIVOE-MIB", "videoFormatRoiOriginTop"), ("VIVOE-MIB", "videoFormatRoiOriginLeft"), ("VIVOE-MIB", "videoFormatRoiExtentBottom"), ("VIVOE-MIB", "videoFormatRoiExtentRight"), ("VIVOE-MIB", "videoFormatRtpPt"), ("VIVOE-MIB", "channelReset"), ("VIVOE-MIB", "channelUserDesc"), ("VIVOE-MIB", "channelInterPacketDelay"), ("VIVOE-MIB", "channelSapMessageInterval"), ("VIVOE-MIB", "channelDefaultVideoFormatIndex"), ("VIVOE-MIB", "channelDefaultReceiveIpAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    maintenanceModeGroup = maintenanceModeGroup.setStatus('current')
if mibBuilder.loadTexts: maintenanceModeGroup.setDescription('The objects whose values shall only be settable when the device is in the maintenance mode (the deviceMode object is set to maintenanceMode. If the device is not in this mode the agent shall return a resourceUnavailable error if a set operation is performed on these objects. Any values set during the maintenance mode period shall only become active after a reset, reboot or power cycle.')
volatileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 35990, 3, 1, 5, 4)).setObjects(("VIVOE-MIB", "deviceMode"), ("VIVOE-MIB", "deviceReset"), ("VIVOE-MIB", "channelReset"), ("VIVOE-MIB", "channelType"), ("VIVOE-MIB", "channelStatus"), ("VIVOE-MIB", "channelVideoFormatIndex"), ("VIVOE-MIB", "channelVideoFormat"), ("VIVOE-MIB", "channelVideoSampling"), ("VIVOE-MIB", "channelVideoBitDepth"), ("VIVOE-MIB", "channelFps"), ("VIVOE-MIB", "channelColorimetry"), ("VIVOE-MIB", "channelInterlaced"), ("VIVOE-MIB", "channelCompressionFactor"), ("VIVOE-MIB", "channelCompressionRate"), ("VIVOE-MIB", "channelHorzRes"), ("VIVOE-MIB", "channelVertRes"), ("VIVOE-MIB", "channelRoiOriginTop"), ("VIVOE-MIB", "channelRoiOriginLeft"), ("VIVOE-MIB", "channelRoiExtentBottom"), ("VIVOE-MIB", "channelRoiExtentRight"), ("VIVOE-MIB", "channelRtpPt"), ("VIVOE-MIB", "channelReceiveIpAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    volatileGroup = volatileGroup.setStatus('current')
if mibBuilder.loadTexts: volatileGroup.setDescription('The objects whose values shall be stored in volatile memory and shall not maintained during a reset, reboot or power cycle. The values for all other objects shall be maintained during a reset, reboot or power cycle.')
notificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 35990, 3, 1, 5, 5)).setObjects(("VIVOE-MIB", "deviceError"), ("VIVOE-MIB", "ipAddressConflict"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    notificationGroup = notificationGroup.setStatus('current')
if mibBuilder.loadTexts: notificationGroup.setDescription('The group of objects specifying the notifications (Traps) that can be sent by the device.')
mibBuilder.exportSymbols("VIVOE-MIB", ethernetIfIpAddressConflict=ethernetIfIpAddressConflict, deviceType=deviceType, channelDefaultVideoFormatIndex=channelDefaultVideoFormatIndex, channelVertRes=channelVertRes, videoFormatFps=videoFormatFps, vivoeNotifications=vivoeNotifications, videoFormatCompressionRate=videoFormatCompressionRate, presetGroup=presetGroup, videoFormatNumber=videoFormatNumber, channelRtpPt=channelRtpPt, channelCompressionRate=channelCompressionRate, channelReceiveIpAddress=channelReceiveIpAddress, ethernetIfTable=ethernetIfTable, videoFormatRoiExtentRight=videoFormatRoiExtentRight, maintenanceModeGroup=maintenanceModeGroup, deviceSerialNumber=deviceSerialNumber, videoFormatRtpPt=videoFormatRtpPt, ethernetIfIpAddress=ethernetIfIpAddress, channelInterlaced=channelInterlaced, videoFormatRoiExtentBottom=videoFormatRoiExtentBottom, volatileGroup=volatileGroup, videoFormatRoiVertRes=videoFormatRoiVertRes, channelTable=channelTable, videoFormatBitDepth=videoFormatBitDepth, channelDefaultReceiveIpAddress=channelDefaultReceiveIpAddress, channelVideoFormatIndex=channelVideoFormatIndex, videoFormatType=videoFormatType, videoFormatMaxVertRes=videoFormatMaxVertRes, channelVideoFormat=channelVideoFormat, channelSapMessageInterval=channelSapMessageInterval, deviceDesc=deviceDesc, channelCompressionFactor=channelCompressionFactor, channelType=channelType, deviceFirmwareVersion=deviceFirmwareVersion, channelNumber=channelNumber, videoFormatRoiOriginLeft=videoFormatRoiOriginLeft, videoFormatRoiOriginTop=videoFormatRoiOriginTop, videoFormatEntry=videoFormatEntry, DisplayString64=DisplayString64, ipAddressConflict=ipAddressConflict, ethernetIfIndex=ethernetIfIndex, channelFps=channelFps, deviceHardwareVersion=deviceHardwareVersion, channelVideoBitDepth=channelVideoBitDepth, ethernetIfSubnetMask=ethernetIfSubnetMask, channelHorzRes=channelHorzRes, channelRoiExtentRight=channelRoiExtentRight, videoFormatRoiHorzRes=videoFormatRoiHorzRes, deviceSoftwareVersion=deviceSoftwareVersion, channelRoiOriginTop=channelRoiOriginTop, channelRoiOriginLeft=channelRoiOriginLeft, videoFormatInterlaced=videoFormatInterlaced, videoFormatMaxHorzRes=videoFormatMaxHorzRes, channelStatus=channelStatus, deviceManufacturer=deviceManufacturer, deviceError=deviceError, channelColorimetry=channelColorimetry, channelUserDesc=channelUserDesc, videoFormatSampling=videoFormatSampling, channelEntry=channelEntry, videoFormatColorimetry=videoFormatColorimetry, channelVideoSampling=channelVideoSampling, devicePartNumber=devicePartNumber, setChannelGroup=setChannelGroup, channelInterPacketDelay=channelInterPacketDelay, vivoeMIB=vivoeMIB, deviceUserDesc=deviceUserDesc, ethernetIfEntry=ethernetIfEntry, deviceInfo=deviceInfo, ethernetIfMacAddress=ethernetIfMacAddress, desleProducts=desleProducts, deviceNatoStockNumber=deviceNatoStockNumber, DisplayString16=DisplayString16, channelRoiExtentBottom=channelRoiExtentBottom, videoFormatTable=videoFormatTable, channelIndex=channelIndex, DisplayString32=DisplayString32, videoFormatInfo=videoFormatInfo, ethernetIfNumber=ethernetIfNumber, deviceMibVersion=deviceMibVersion, videoFormatStatus=videoFormatStatus, vivoeGroups=vivoeGroups, notificationGroup=notificationGroup, videoFormatIndex=videoFormatIndex, deviceMode=deviceMode, desle=desle, channelReset=channelReset, videoFormatBase=videoFormatBase, ethernetIfSpeed=ethernetIfSpeed, videoFormatCompressionFactor=videoFormatCompressionFactor, channelControl=channelControl, deviceReset=deviceReset, PYSNMP_MODULE_ID=vivoeMIB)

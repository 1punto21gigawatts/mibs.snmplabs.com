#
# PySNMP MIB module AP553-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AP553-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:22:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
linkProbe, = mibBuilder.importSymbols("INNOVX-CORE-MIB", "linkProbe")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, MibIdentifier, Gauge32, Counter32, ObjectIdentity, Integer32, TimeTicks, Counter64, ModuleIdentity, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "MibIdentifier", "Gauge32", "Counter32", "ObjectIdentity", "Integer32", "TimeTicks", "Counter64", "ModuleIdentity", "iso", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
probeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1))
probeStat = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2))
probePerform = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3))
trapStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4))
chanConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 1))
lmiConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2))
proFunConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3))
trapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4))
pvcConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5))
probeVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 6))
alarmStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4, 1))
frProbeMIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 6, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProbeMIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: frProbeMIBversion.setDescription("Identifies the version of the MIB as 'X.YZT' where: X: Major Revision (1-9) Y: Minor Revision (0-9) Z: Typographical Revision (0-9) T: Test Revision (A-Z) ")
lmiOperation = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiOperation.setStatus('mandatory')
if mibBuilder.loadTexts: lmiOperation.setDescription(' LMI operation, on -- enabled, off -- disabled WEBFLAG Off On WEBEND ')
lmiDLCI = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("dlci-0", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: lmiDLCI.setDescription('The DLCI # used for LMI polls, the default value is dlci-0 WEBFLAG DLCI-0 WEBEND ')
ipDLCI = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: ipDLCI.setDescription('Valid Inband IP DLCI ranges from 16 to 991')
ipEncapp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rawIP", 1), ("ietf-IP", 2), ("snap-IP", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipEncapp.setStatus('mandatory')
if mibBuilder.loadTexts: ipEncapp.setDescription(' Defines the IP DLCI Encapsulation method WEBFLAG RAW IETF SNAP WEBEND ')
chanAggregateRate = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(56000, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanAggregateRate.setStatus('mandatory')
if mibBuilder.loadTexts: chanAggregateRate.setDescription('Displays the current aggregate channel rate.')
lmiType = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("annexA", 1), ("annexD", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiType.setStatus('mandatory')
if mibBuilder.loadTexts: lmiType.setDescription("Defines the network's LMI type. WEBFLAG Annex-A Annex-D WEBEND ")
lmiN391 = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiN391.setStatus('mandatory')
if mibBuilder.loadTexts: lmiN391.setDescription(' N391 Full Enquiry Interval Counter ranges from 1 to 255, the default value is 6.')
lmiNet392 = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiNet392.setStatus('mandatory')
if mibBuilder.loadTexts: lmiNet392.setDescription(' N392 Network Interface Down Threshold Counter ranges from 1 to 10, the default value is 3.')
lmiUser392 = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiUser392.setStatus('mandatory')
if mibBuilder.loadTexts: lmiUser392.setDescription(' N392 User Interface Down Threshold Counter ranges from 1 to 10, the default value is 3.')
lmiNet393 = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiNet393.setStatus('mandatory')
if mibBuilder.loadTexts: lmiNet393.setDescription(' N393 Network Interface Down Window Counter ranges from 1 to 10, the default value is 4.')
lmiUser393 = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmiUser393.setStatus('mandatory')
if mibBuilder.loadTexts: lmiUser393.setDescription(' N393 User Interface Down Window Counter ranges from 1 to 10, the default value is 4.')
t391Timer = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: t391Timer.setStatus('mandatory')
if mibBuilder.loadTexts: t391Timer.setDescription(' T391 Status Poll Interval Timer ranges from 5 to 30, the default value is 10, which would always less than to T392 Timer.')
t392Timer = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: t392Timer.setStatus('mandatory')
if mibBuilder.loadTexts: t392Timer.setDescription(' T392 Polling Verification Interval Timer ranges from 5 to 30, the default value is 15 should always be greater than T391 Timer.')
maxInfoLength = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(400, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxInfoLength.setStatus('mandatory')
if mibBuilder.loadTexts: maxInfoLength.setDescription('Maximum supported frame information length ranges from 400 to 4000, the default value is 4000.')
unitType = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unitType.setStatus('mandatory')
if mibBuilder.loadTexts: unitType.setDescription('Defines the ap553 as a master or remote unit in the network. This option is used to define the probe(s) installed on the local management network. As a master, PVC hiding is disabled, which allows discovery of remotely managed probes. WEBFLAG Master Remote WEBEND ')
probeMode = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("generator", 1), ("responder", 2), ("both", 3), ("disabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeMode.setStatus('mandatory')
if mibBuilder.loadTexts: probeMode.setDescription(' Defines the probe mode as a generator, responder, or both or disabled. WEBFLAG Generator Responder Generator & Responder Disabled WEBEND ')
pollPeriod = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: pollPeriod.setDescription('Defines the frequency of sending the polling frame by the link probe, from 1 to 60 seconds. pollPeriod applies to all PVCs that are probed.')
globalTC = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTC.setStatus('mandatory')
if mibBuilder.loadTexts: globalTC.setDescription('This parameter defines the committed rate measurement time interval (in seconds) which can be calculated as Bc/CIR, currently we only allow this value to be 1 sec.')
pvcCount = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCount.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCount.setDescription('PVC count defines the total number of PVCs which are being probed. The value is between 1 to 127. ')
probeTokenSize = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(19, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeTokenSize.setStatus('mandatory')
if mibBuilder.loadTexts: probeTokenSize.setDescription('Defines the probe token size.')
pvcAdd = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: pvcAdd.setStatus('mandatory')
if mibBuilder.loadTexts: pvcAdd.setDescription('This object allows for manual addition of a PVC to the existing PVC table, the added PVC must not exist before it is added.')
pvcDelete = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: pvcDelete.setStatus('mandatory')
if mibBuilder.loadTexts: pvcDelete.setDescription('This object allows for manual deletion of a PVC from the existing PVC table, the deleted PVC must exist before it was deleted.')
pvcDiscovery = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("initiate", 1), ("inProgress", 2), ("complete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: pvcDiscovery.setDescription('This object automatically adds PVCs as seen by the LMI protocol. It controls the probe ability to read all pvcs as reported by the LMI process and update the probe pvc data table as controlled by the pvcCirEirTable. Values of 2 and 3 cannot be set and have no affect.')
pvcOperStateChangeTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOperStateChangeTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOperStateChangeTrapSeverity.setDescription("Controls the reporting of and defines the severity of the pvc state change trap which may be sent when a PVC's operational status is changed via the pvcOperation object. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ")
realTimeTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimeTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: realTimeTrapSeverity.setDescription('Controls the reporting of and defines the severity of ALL real time alarm conditions: Channel Load To DTE, Channel Load TO DCE, PVC Load To DCE, PVC Load To DTE, and PVC Round Trip Delay. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
realTimeChanLoadToDCEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimeChanLoadToDCEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: realTimeChanLoadToDCEThresh.setDescription('Defines the maximum allowed real-time channel load calculated every second, expressed in percentage. If the actual load is more than this threshold, a realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
realTimeChanLoadToDCEThreshVar = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimeChanLoadToDCEThreshVar.setStatus('mandatory')
if mibBuilder.loadTexts: realTimeChanLoadToDCEThreshVar.setDescription('Defines the variation range for real-time channel load, expressed in percentage.. If within the current TC interval, the variation of the actual utilization is more than that range compared with the previous trap value, another realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
avgChanLoadToDCETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgChanLoadToDCETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgChanLoadToDCETrapSeverity.setDescription('Controls the reporting of and defines severity of the 15 minute average load exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgChanLoadToDCEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgChanLoadToDCEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgChanLoadToDCEThresh.setDescription('Defines the maximum allowed frame relay channel utilization in a 15 minute period, expressed in percentage. If the actual average utilization is more than this threshold, an avgChanLoadToDCETrap trap may be sent as specified by the avgChanLoadToDCETrapSeverity object value.')
realTimeChanLoadToDTEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimeChanLoadToDTEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: realTimeChanLoadToDTEThresh.setDescription('Defines the maximum allowed real-time channel load calculated every second, expressed in percentage. If the actual load is more than this threshold, a realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
realTimeChanLoadToDTEThreshVar = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimeChanLoadToDTEThreshVar.setStatus('mandatory')
if mibBuilder.loadTexts: realTimeChanLoadToDTEThreshVar.setDescription('Defines the variation range for real-time channel load, expressed in percentage.. If within the current TC interval, the variation of the actual utilization is more than that range compared with the previous trap value, another realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
avgChanLoadToDTETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgChanLoadToDTETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgChanLoadToDTETrapSeverity.setDescription('Controls the reporting of and defines severity of the 15 minute average load exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgChanLoadToDTEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgChanLoadToDTEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgChanLoadToDTEThresh.setDescription('Defines the maximum allowed frame relay channel utilization in a 15 minute period, expressed in percentage. If the actual average utilization is more than this threshold, an avgChanLoadToDTETrap trap may be sent as specified by the avgChanLoadToDTETrapSeverity object value.')
realTimePvcLoadToDCEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimePvcLoadToDCEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: realTimePvcLoadToDCEThresh.setDescription('Defines the maximum allowed real-time PVC load calculated every second, expressed in percentage. If the actual load is more than this threshold, a realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
realTimePvcLoadToDCEThreshVar = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimePvcLoadToDCEThreshVar.setStatus('mandatory')
if mibBuilder.loadTexts: realTimePvcLoadToDCEThreshVar.setDescription('Defines the variation range for real-time PVC load, expressed in percentage.. If within the current TC interval, the variation of the actual utilization is more than that range compared with the previous trap value, another realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
avgPvcLoadToDCETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcLoadToDCETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcLoadToDCETrapSeverity.setDescription('Controls the reporting of and defines severity of the 15 minute average load exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcLoadToDCEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcLoadToDCEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcLoadToDCEThresh.setDescription('Defines the maximum allowed PVC load in a 15 minute period, expressed in percentage. If the actual average PVC loading is more than this threshold, an avgPvcLoadToDCETrap trap may be sent as specified by the avgPvcLoadToDCETrapSeverity object value.')
realTimePvcLoadToDTEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimePvcLoadToDTEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: realTimePvcLoadToDTEThresh.setDescription('Defines the maximum allowed real-time PVC load calculated every second, expressed in percentage. If the actual load is more than this threshold, a realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
realTimePvcLoadToDTEThreshVar = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimePvcLoadToDTEThreshVar.setStatus('mandatory')
if mibBuilder.loadTexts: realTimePvcLoadToDTEThreshVar.setDescription('Defines the variation range for real-time PVC load, expressed in percentage. If within the current TC interval, the variation of the actual utilization is more than that range compared with the previous trap value, another realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
avgPvcLoadToDTETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcLoadToDTETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcLoadToDTETrapSeverity.setDescription('Controls the reporting of and defines severity of the 15 minute average load exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcLoadToDTEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcLoadToDTEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcLoadToDTEThresh.setDescription('Defines the maximum allowed PVC load in a 15 minute period, expressed in percentage. If the actual average utilization is more than this threshold, an avgPvcLoadToDTETrap trap may be sent as specified by the avgPvcLoadToDTETrapSeverity object value.')
realTimePvcRoundTripDelayThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimePvcRoundTripDelayThresh.setStatus('mandatory')
if mibBuilder.loadTexts: realTimePvcRoundTripDelayThresh.setDescription('Defines the maximum allowed real-time PVC round trip delay, calculated every second, expressed in percentage. If the actual load is more than this threshold, a realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
realTimePvcRoundTripDelayThreshVar = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realTimePvcRoundTripDelayThreshVar.setStatus('mandatory')
if mibBuilder.loadTexts: realTimePvcRoundTripDelayThreshVar.setDescription('Defines the variation range for real-time PVC round trip delay, expressed in percentage.. If within the current TC interval, the variation of the actual round trip delay is more than that range compared with the previous trap value, another realTimeTrapSeverity exception trap may be sent as specified by the realTimeTrapSeverity object value.')
avgPvcRoundTripDelayTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcRoundTripDelayTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcRoundTripDelayTrapSeverity.setDescription('Controls the reporting of and defines severity of the 15 minute average round trip delay exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcRoundTripDelayThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcRoundTripDelayThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcRoundTripDelayThresh.setDescription('Defines the maximum allowed PVC round trip delay in a 15 minute period, expressed in percentage. If the actual average PVC round trip delay is more than this threshold, an avgPvcRoundTripDelayTrap trap may be sent as specified by the avgPvcRoundTripDelayTrapSeverity object value.')
avgPvcNotAvailToDCETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcNotAvailToDCETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcNotAvailToDCETrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcNotAvailToDCE exception trap. This condition may be reported when the avgPvcNotAvailToDCEThresh object value is exceeded within a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcNotAvailToDCEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcNotAvailToDCEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcNotAvailToDCEThresh.setDescription('Defines the maximum allowed average unavailability in a 15 minute period, expressed in percentage. If the actual value is more than this threshold, an avgPvcNotAvailToDCE trap may be sent as specified by the avgPvcNotAvailToDCETrapSeverity object value.')
avgPvcNotAvailToDTETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcNotAvailToDTETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcNotAvailToDTETrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcNotAvailToDTE exception trap. This condition may be reported when the avgPvcNotAvailToDTEThresh object value is exceeded within a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcNotAvailToDTEThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcNotAvailToDTEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcNotAvailToDTEThresh.setDescription('Defines the maximum allowed average unavailability in a 15 minute period, expressed in percentage. If the actual value is more than this threshold, an avgPvcNotAvailToDTE trap may be sent as specified by the avgPvcNotAvailToDTETrapSeverity object value.')
avgPvcFecnFramesTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcFecnFramesTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcFecnFramesTrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcFecnFrames exception trap. This condition may be reported when the avgPvcFecnFramesThresh object value is exceeded within a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcFecnFramesThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcFecnFramesThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcFecnFramesThresh.setDescription('Defines the maximum allowed number of FECN frames which may be received in a 15 minute period.')
avgPvcBecnFramesTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcBecnFramesTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcBecnFramesTrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcBecnFrames exception trap. This condition may be reported when the avgPvcFecnFramesThresh object value is exceeded within a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcBecnFramesThresh = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcBecnFramesThresh.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcBecnFramesThresh.setDescription('Defines the maximum allowed number of BECN frames which may be received in a 15 minute period.')
avgPvcCIRExceedToDTETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcCIRExceedToDTETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcCIRExceedToDTETrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcCIRExceedToDTE exception trap. This trap may be reported if this condition occurs over a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcEIRExceedToDTETrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcEIRExceedToDTETrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcEIRExceedToDTETrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcEIRExceedToDTE exception trap. This trap may be reported if this condition occurs over a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcLossFrameTxTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcLossFrameTxTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcLossFrameTxTrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcLossFrameTx exception trap. This trap may be reported if this condition occurs over a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
avgPvcLossFrameRxTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avgPvcLossFrameRxTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: avgPvcLossFrameRxTrapSeverity.setDescription('Controls the reporting of and defines severity of the avgPvcLossFrameTx exception trap. This trap may be reported if this condition occurs over a 15 minute period. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
networkLmiInterfaceDownTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkLmiInterfaceDownTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: networkLmiInterfaceDownTrapSeverity.setDescription('Controls the reporting of and defines severity of the networkLmiInterfaceDown exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
userLmiInterfaceDownTrapSeverity = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 4, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inhibit", 1), ("critical", 2), ("major", 3), ("minor", 4), ("warning", 5), ("info", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userLmiInterfaceDownTrapSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: userLmiInterfaceDownTrapSeverity.setDescription('Controls the reporting of and defines severity of the userLmiInterfaceDown exception trap. WEBFLAG Inhibit Critical Major Minor Warning Info WEBEND ')
pvcCirEirTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1), )
if mibBuilder.loadTexts: pvcCirEirTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCirEirTable.setDescription('PVC table, which lists PVCs for which the statistic data are collected.')
pvcCirEirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1), ).setIndexNames((0, "AP553-MIB", "pvcCirEirTableIndex"))
if mibBuilder.loadTexts: pvcCirEirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCirEirEntry.setDescription('Identifies an entry (row) in PVC CIR/EIR table.')
pvcCirEirTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCirEirTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCirEirTableIndex.setDescription('Identifies an entry (row) in PVC table.')
pvcCirToDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcCirToDTE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCirToDTE.setDescription('Defines the committed information rate, in bps, under normal conditions in the direction of to DTE.')
pvcCirToDCE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcCirToDCE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCirToDCE.setDescription('Defines the committed information rate, in bps, under normal conditions in the direction of to DCE.')
pvcEirToDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcEirToDTE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcEirToDTE.setDescription('Defines the maximum transfer information rate, in bps, which the network is accepting in the direction of to DTE.')
pvcEirToDCE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcEirToDCE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcEirToDCE.setDescription('Defines the maximum transfer information rate, in bps, which the network is accepting in the direction of to DCE.')
pvcOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pvcNotProbed", 1), ("pvcWaitForProbe", 2), ("pvcProbed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcOperation.setStatus('mandatory')
if mibBuilder.loadTexts: pvcOperation.setDescription('Defines the monitored state of a PVC. pvcNotProbed - specifies that the PVC will not be probed, round trip delay and frame loss measurements will not be tabulated. pvcWaitForProbe specifies that this PVC is in a transition state, and will be probed at the start of the next 15 minute poll cycle for statistic data collection. pvcProbed is a read only value that indicates this PVC is used for both statistic data and probing. WEBFLAG Not Probed Probe Pending Probed WEBEND ')
pvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unavailable", 1), ("inactive", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcState.setStatus('mandatory')
if mibBuilder.loadTexts: pvcState.setDescription("Reflects the state of the PVC as seen by the probe. `unavailable' indicates that the PVC is not included in the DLCI list. `inactive indicates that the PVC is no longer responding. `active' indicates that the PVC is in operational state. ")
pvcIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 1, 5, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIdentifier.setDescription('Comment field for annotation.')
chStCurrent = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1))
chCurrDteFrames = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrDteFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrDteFrames.setDescription(' Identifies total frames received from DTE device within current 15 minutes interval. ')
chCurrDceFrames = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrDceFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrDceFrames.setDescription(' Identifies total frames received from DCE device within current 15 minutes interval. ')
chCurrDteOctets = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrDteOctets.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrDteOctets.setDescription(' Identifies total octets received from DTE device within current 15 minutes interval. ')
chCurrDceOctets = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrDceOctets.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrDceOctets.setDescription(' Identifies total octets received from DTE device within current 15 minutes interval. ')
chCurrLmiTxEnq = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrLmiTxEnq.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrLmiTxEnq.setDescription(' Identifies the total number of LMI enquiries sent to DCE within current 15 minutes interval. ')
chCurrLmiTxResp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrLmiTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrLmiTxResp.setDescription(' Identifies the total number of LMI responses sent to DTE within current 15 minutes interval. ')
chCurrLmiRxEnq = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrLmiRxEnq.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrLmiRxEnq.setDescription(' Identifies the total number of LMI enquiries from the DTE within current 15 minutes interval. ')
chCurrLmiRxResp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrLmiRxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrLmiRxResp.setDescription(' Identifies the total number of LMI status responses received from the DCE within current 15 minutes interval. ')
chCurrDTELmiTimeout = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrDTELmiTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrDTELmiTimeout.setDescription(' Identifies the total number of lmi timeouts received within current 15 minutes interval. ')
chCurrDCELmiTimeout = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrDCELmiTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrDCELmiTimeout.setDescription(' Identifies the total number of lmi timeouts received within current 15 minutes interval. ')
chCurrFecnFrames = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrFecnFrames.setDescription(' Identifies total number of frames with FECN set received within current 15 minutes interval. ')
chCurrBecnFrames = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrBecnFrames.setDescription(' Identifies total number of frames with BECN set received within current 15 minutes interval. ')
chCurrTxIp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrTxIp.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrTxIp.setDescription(' Identifies total number of IP packets sent on inband DLCI within current 15 minutes interval. ')
chCurrRxIp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrRxIp.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrRxIp.setDescription(' Identifies total number of IP packets received on inband DLCI within current 15 minutes interval. ')
chCurrTxPoll = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrTxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrTxPoll.setDescription(' Identifies total number of probe polls sent to DCE within current 15 minutes interval. ')
chCurrTxResp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrTxResp.setDescription(' Identifies total number of probe responses sent to DCE within current 15 minutes interval. ')
chCurrRxPoll = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrRxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrRxPoll.setDescription(' Identifies total number of probe polls received from DCE within current 15 minutes interval. ')
chCurrRxResp = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chCurrRxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chCurrRxResp.setDescription(' Identifies total number of probe responses received from DCE within current 15 minutes interval. ')
intervalComplete = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intervalComplete.setStatus('mandatory')
if mibBuilder.loadTexts: intervalComplete.setDescription(' This object identifies the the percent completeion of the interval. ')
chStIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2), )
if mibBuilder.loadTexts: chStIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: chStIntervalTable.setDescription(' probe statistic table, row 1 to row 96, which defines the time interval for every 15 minutes. ')
chStIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1), ).setIndexNames((0, "AP553-MIB", "chIntvIndex"))
if mibBuilder.loadTexts: chStIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chStIntervalEntry.setDescription(' Identifies an entry (row) in probe statistic table.')
chIntvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvIndex.setDescription(' Identifies an entry (row) in channel statistic table, 1-96 time intervals. ')
chIntvDteFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvDteFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvDteFrames.setDescription(' Identifies total frames received from DTE device within a 15 minutes interval. ')
chIntvDceFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvDceFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvDceFrames.setDescription(' Identifies total frames received from DCE device within a 15 minutes interval. ')
chIntvDteOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvDteOctets.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvDteOctets.setDescription(' Identifies total octets received from DTE device within a 15 minutes interval. ')
chIntvDceOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvDceOctets.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvDceOctets.setDescription(' Identifies total octets received from DTE device within a 15 minutes interval. ')
chIntvLmiTxEnq = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvLmiTxEnq.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvLmiTxEnq.setDescription(' Identifies the total number of LMI enquiries sent to DCE within a 15 minutes interval. ')
chIntvLmiTxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvLmiTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvLmiTxResp.setDescription(' Identifies the total number of LMI responses send to DTE within a 15 minutes interval. ')
chIntvLmiRxEnq = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvLmiRxEnq.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvLmiRxEnq.setDescription(' Identifies the total number of LMI enquiries received within a 15 minutes interval. ')
chIntvLmiRxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvLmiRxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvLmiRxResp.setDescription(' Identifies the total number of LMI status responses received from the DCE within a 15 minutes interval. ')
chIntvDTELmiTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvDTELmiTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvDTELmiTimeout.setDescription(' Identifies the total number of LMI timeouts received within a 15 minutes interval. ')
chIntvDCELmiTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvDCELmiTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvDCELmiTimeout.setDescription(' Identifies the total number of LMI timeouts received within a 15 minutes interval. ')
chIntvFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvFecnFrames.setDescription(' Identifies total number of frames with FECN set received within a 15 minutes interval. ')
chIntvBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvBecnFrames.setDescription(' Identifies total number of frames with BECN set received within a 15 minutes interval. ')
chIntvTxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvTxIp.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvTxIp.setDescription(' Identifies total number of IP packets sent on inband DLCI within a 15 minutes interval. ')
chIntvRxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvRxIp.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvRxIp.setDescription(' Identifies total number of IP packets received on inband DLCI within a 15 minutes interval. ')
chIntvTxPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvTxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvTxPoll.setDescription(' Identifies total number of probe polls sent to DCE within a 15 minutes interval. ')
chIntvTxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvTxResp.setDescription(' Identifies total number of probe response sent to DCE within a 15 minutes interval. ')
chIntvRxPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvRxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvRxPoll.setDescription(' Identifies total number of probe polls received from DCE within a 15 minutes interval. ')
chIntvRxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chIntvRxResp.setStatus('mandatory')
if mibBuilder.loadTexts: chIntvRxResp.setDescription(' Identifies total number of probe responses received from DCE within a 15 minutes interval. ')
pvcStCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3), )
if mibBuilder.loadTexts: pvcStCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcStCurrentTable.setDescription(' PVC statistic table.')
pvcStCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1), ).setIndexNames((0, "AP553-MIB", "pvcCurrDlciIndex"))
if mibBuilder.loadTexts: pvcStCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcStCurrentEntry.setDescription(' Identifies an entry (row) in PVC statistic table')
pvcCurrDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDlciIndex.setDescription(' Index in PVC statistics table, which identifies the PVC number, up to 20 PVCs can exist. ')
pvcCurrDteFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDteFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDteFrames.setDescription(' Identifies total frames received from DTE device for a specific PVC within current 15 minutes interval. ')
pvcCurrDceFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDceFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDceFrames.setDescription(' Identifies total frames received from DCE device for a specific PVC within current 15 minutes interval. ')
pvcCurrDteOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDteOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDteOctets.setDescription(' Identifies total octets received from DTE device for a specific PVC within current 15 minutes interval. ')
pvcCurrDceOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDceOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDceOctets.setDescription(' Identifies total octets received from DTE device for a specific PVC within current 15 minutes interval. ')
pvcCurrDteFramesWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDteFramesWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDteFramesWithDE.setDescription(' Identifies total frames with DE bit set received from DTE device for a specific PVC within current 15 minutes interval. ')
pvcCurrDceFramesWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrDceFramesWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrDceFramesWithDE.setDescription(' Identifies total frames with DE bit set received from DCE device for a specific PVC within current 15 minutes interval. ')
pvcCurrFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrFecnFrames.setDescription(' Identifies total number of frames for a specific PVC with FECN set received within current 15 minutes interval. ')
pvcCurrBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrBecnFrames.setDescription(' Identifies total number of frames for a specific PVC with BECN set received within current 15 minutes interval. ')
pvcCurrTxPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrTxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrTxPoll.setDescription(' Identifies total number of probe polls sent to DCE within current 15 minutes interval. ')
pvcCurrTxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrTxResp.setDescription(' Identifies total number of probe responses sent to DCE within current 15 minutes interval. ')
pvcCurrRxPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrRxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrRxPoll.setDescription(' Identifies total number of probe polls received from DCE on a specific PVC within current 15 minutes interval. ')
pvcCurrRxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrRxResp.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrRxResp.setDescription(' Identifies total number of probe responses received from DCE on a specific PVC within current 15 minutes interval. ')
pvcCurrLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopback", 1), ("noLoopback", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcCurrLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCurrLoopback.setDescription(" Identifies whether the specific PVC has been found to be in a loop back state by link probe's generator process. ")
pvcStIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4), )
if mibBuilder.loadTexts: pvcStIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcStIntervalTable.setDescription(' PVC statistic interval table: ')
pvcStIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1), ).setIndexNames((0, "AP553-MIB", "pvcIntvDlciIndex"), (0, "AP553-MIB", "pvcIntvIndex"))
if mibBuilder.loadTexts: pvcStIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcStIntervalEntry.setDescription(' Identifies an entry (row) in pvc statistic table')
pvcIntvDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDlciIndex.setDescription(' This index value which uniquely identifies the PVC number to which this entry is applicable. ')
pvcIntvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvIndex.setDescription(' A number between 1 and 96, where 1 is the most recently completed 15 minutes interval and 96 is the least recently completed 15 minutes interval. ')
pvcIntvDteFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDteFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDteFrames.setDescription(' Identifies total frames received from DTE device for a specific PVC within a 15 minutes interval. ')
pvcIntvDceFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDceFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDceFrames.setDescription(' Identifies total frames received from DCE device for a specific PVC within a 15 minutes interval. ')
pvcIntvDteOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDteOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDteOctets.setDescription(' Identifies total octets received from DTE device for a specific PVC within a 15 minutes interval. ')
pvcIntvDceOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDceOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDceOctets.setDescription(' Identifies total octets received from DCE device for a specific PVC within a 15 minutes interval. ')
pvcIntvDteFramesWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDteFramesWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDteFramesWithDE.setDescription(' Identifies the frames with DE bit set received from DTE device for a specific PVC within a 15 minutes interval. ')
pvcIntvDceFramesWithDE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvDceFramesWithDE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvDceFramesWithDE.setDescription(' Identifies the frames with DE bit set received from DCE device for a specific PVC within a 15 minutes interval. ')
pvcIntvFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvFecnFrames.setDescription(' Identifies total number of frames for a specific PVC with FECN set received within a 15 minutes interval. ')
pvcIntvBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvBecnFrames.setDescription(' Identifies total number of frames for a specific PVC with BECN set received within a 15 minutes interval. ')
pvcIntvTxPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvTxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvTxPoll.setDescription(' Identifies total number of probe polls sent to DCE within a 15 minutes interval. ')
pvcIntvTxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvTxResp.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvTxResp.setDescription(' Identifies total number of probe responses sent to DCE within a 15 minutes interval. ')
pvcIntvRxPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvRxPoll.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvRxPoll.setDescription(' Identifies total number of probe polls received from DCE on a specific PVC within a 15 minutes interval. ')
pvcIntvRxResp = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvRxResp.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvRxResp.setDescription(' Identifies total number of probe responses received from DCE on a specific PVC within a 15 minutes interval. ')
pvcIntvLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 2, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopback", 1), ("noLoopback", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcIntvLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: pvcIntvLoopback.setDescription(" Identifies whether the specific PVC has been found to be in a loop back state by link probe's generator process. ")
chanPerfCurr = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1))
chPerfCurrUnavailToDte = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrUnavailToDte.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrUnavailToDte.setDescription(' This object identifies the channel unavailability due to remote DTE fault within the latest 15 minutes. This statistic datum is calculated by the channel unavailable time over the full time interval.')
chPerfCurrUnavailToDce = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrUnavailToDce.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrUnavailToDce.setDescription(' This object identifies the channel unavailability due to local DTE fault within the latest 15 minutes. This statistic datum is calculated by the channel unavailable time over the full time interval.')
chPerfCurrTxLoad = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrTxLoad.setDescription(' channel average user tx load within the latest 15 minutes, this statistic datum is calculated by user data octets sent by the channel within the 15 minutes over the total channel available load ( which depends on physical interface speed). ')
chPerfCurrRxLoad = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrRxLoad.setDescription(' Channel average user rx load within the latest 15 minutes, this statistic datum is calculated by user data octets received by the channel within the 15 minutes over the total channel available load ( which depends on physical interface speed). ')
chPerfCurrTotalTxLoad = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrTotalTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrTotalTxLoad.setDescription(' channel total tx load within the latest 15 minutes, this statistic datum is calculated by the total data octets sent by the channel within the 15 minutes over the channel available load ( which depends on physical interface speed). ')
chPerfCurrTotalRxLoad = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrTotalRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrTotalRxLoad.setDescription('channel total rx load within the latest 15 minutes, this statistic datum is calculated by total data octets received by the channel within the 15 minutes over the channel total available load ( which depends on physical interface speed). ')
chPerfCurrLoadToDceRealTime = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrLoadToDceRealTime.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrLoadToDceRealTime.setDescription(' This object displays the channel load tx within current TC ( 1 sec.), this variable is calculated by total octets transmitted over the capacity of this channel. ')
chPerfCurrLoadToDteRealTime = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfCurrLoadToDteRealTime.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfCurrLoadToDteRealTime.setDescription(' This object displays the channel load rx within current TC ( 1 sec.), this variable is calculated by total octets received over the capacity of this channel. ')
chanPerfIntvTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2), )
if mibBuilder.loadTexts: chanPerfIntvTable.setStatus('mandatory')
if mibBuilder.loadTexts: chanPerfIntvTable.setDescription(' Probe channel performance table, which displays the performance statistic data based on the probe channel within previous 24 hours.')
chanPerfIntvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1), ).setIndexNames((0, "AP553-MIB", "chPerfIntvIndex"))
if mibBuilder.loadTexts: chanPerfIntvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chanPerfIntvEntry.setDescription(' Identifies an entry (row) in probe channel performance table.')
chPerfIntvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvIndex.setDescription(' Identifies an entry (row) in historical PVC performance table, total 96 time intervals, where 1 is the most recently completed 15 minutes interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid). ')
chPerfIntvUnavailToDte = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvUnavailToDte.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvUnavailToDte.setDescription(' This object identifies the channel unavailability due to remote DTE fault within a 15 minutes interval. This statistic datum is calculated by the channel unavailable time over the full time interval.')
chPerfIntvUnavailToDce = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvUnavailToDce.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvUnavailToDce.setDescription(' This object identifies the channel unavailability due to local DTE fault within a 15 minutes interval. This statistic datum is calculated by the channel unavailable time over the full time interval.')
chPerfIntvTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvTxLoad.setDescription(' channel average user tx load within a 15 minutes interval,this statistic datum is calculated by user data octets sent by the channel within the 15 minutes over the total channel available load ( which depends on physical interface speed). ')
chPerfIntvRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvRxLoad.setDescription(' channel average user rx load within a 15 minutes interval, this statistic datum is calculated by user data octets received by the channel within the 15 minutes over the total channel available load( which depends on physical interface speed). ')
chPerfIntvTotalTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvTotalTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvTotalTxLoad.setDescription(' channel total tx load within a 15 minutes interval, this statistic datum is calculated by the total data octets sent by the channel within the 15 minutes over the total channel available load ( which depends on physical interface speed). ')
chPerfIntvTotalRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chPerfIntvTotalRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: chPerfIntvTotalRxLoad.setDescription(' Channel total rx load within a 15 minutes interval, this statistic datum is calculated by the total data octets received by the channel within the 15 minutes over the total channel available load ( which depends on physical interface speed). ')
pvcPerfCurrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3), )
if mibBuilder.loadTexts: pvcPerfCurrTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrTable.setDescription(' PVC performance table, which displays the performance statistic data based on each PVC.')
pvcPerfCurrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1), ).setIndexNames((0, "AP553-MIB", "pvcPerfCurrDlciIndex"))
if mibBuilder.loadTexts: pvcPerfCurrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrEntry.setDescription(' Identifies an entry (row) in pvc statistic table')
pvcPerfCurrDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrDlciIndex.setDescription(' This index value which uniquely identifies the PVC number to which this entry is applicable. ')
pvcPerfCurrRtd = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrRtd.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrRtd.setDescription(' Probe token average round trip time within the latest 15 minutes for a specific PVC. ')
pvcPerfCurrUnavailToDte = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrUnavailToDte.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrUnavailToDte.setDescription(' This object identifies the PVC average unavailability within the latest 15 minutes. This statistic datum is calculated by a PVC unavailable time due to the network or remote DTE fault over the full time interval.')
pvcPerfCurrUnavailToDce = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrUnavailToDce.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrUnavailToDce.setDescription(' This object identifies the PVC average unavailability within the latest 15 minutes. This statistic datum is calculated by a PVC unavailable time due to the local DTE fault over the full time interval.')
pvcPerfCurrTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrTxLoad.setDescription(' This object identifies the PVC average user tx load within the latest 15 minutes. This statistic datum is calculated by user data octets sent by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfCurrRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrRxLoad.setDescription(' This object identifies the PVC average user rx load within the latest 15 minutes. This statistic datum is calculated by user data octets received by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfCurrTotalTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrTotalTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrTotalTxLoad.setDescription(' This object identifies the PVC total tx load within the latest 15 minutes. This statistic datum is calculated by total data octets sent by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfCurrTotalRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrTotalRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrTotalRxLoad.setDescription(' This object identifies the PVC total rx load within the latest 15 minutes. This statistic datum is calculated by total data octets received by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfCurrCirToNetExceed = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrCirToNetExceed.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrCirToNetExceed.setDescription(' This object identifies the number of exceeding CIR times that the network detected within the current interval. The measurement is done for every Tc, and the direction is to the network.')
pvcPerfCurrEirToNetExceed = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrEirToNetExceed.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrEirToNetExceed.setDescription(' This object identifies the number of exceeding EIR times that the network detected within the current interval. The measurement is done for every Tc, and the direction is to the network.')
pvcPerfCurrTxFrameLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("notAvail", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrTxFrameLoss.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrTxFrameLoss.setDescription(' This object identifies the percentage of tx loss of frames within the total tx frames for this PVC.')
pvcPerfCurrRxFrameLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("notAvail", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfCurrRxFrameLoss.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfCurrRxFrameLoss.setDescription(' This object identifies the percentage of rx loss of frames within the total rx frames for this PVC.')
pvcPerfIntvTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4), )
if mibBuilder.loadTexts: pvcPerfIntvTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvTable.setDescription(' PVC performance interval table, which displays the performance statistic data based on each PVC in previous 24 hours.')
pvcPerfIntvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1), ).setIndexNames((0, "AP553-MIB", "pvcPerfIntvDlciIndex"), (0, "AP553-MIB", "pvcPerfIntvIndex"))
if mibBuilder.loadTexts: pvcPerfIntvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvEntry.setDescription(' Identifies an entry (row) in pvc statistic table')
pvcPerfIntvDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvDlciIndex.setDescription(' This index value which uniquely identifies the PVC number to which this entry is applicable. ')
pvcPerfIntvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvIndex.setDescription(' Identifies an entry (row) in historical PVC performance table,total 96 time intervals, where 1 is the most recently completed 15 minutes interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid). ')
pvcPerfIntvRtd = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvRtd.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvRtd.setDescription(' Probe token average round trip time within a 15 minutes interval for a specific PVC. ')
pvcPerfIntvUnavailToDte = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvUnavailToDte.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvUnavailToDte.setDescription(' This object identifies the PVC average unavailability within a 15 minutes. This statistic datum is calculated by a PVC unavailable time due to the network or remote DTE fault over the full time interval.')
pvcPerfIntvUnavailToDce = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvUnavailToDce.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvUnavailToDce.setDescription(' This object identifies the PVC average unavailability within a 15 minutes. This statistic datum is calculated by a PVC unavailable time due to the local DTE fault over the full time interval.')
pvcPerfIntvTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvTxLoad.setDescription(' This object identifies the PVC average user tx load within a 15 minutes interval. This statistic datum is calculated by user data octets sent by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfIntvRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvRxLoad.setDescription(' This object identifies the PVC average user rx load within a 15 minutes interval. This statistic datum is calculated by user data octets received by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfIntvTotalTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvTotalTxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvTotalTxLoad.setDescription(' This object identifies the PVC total tx load within a 15 minutes interval. This statistic datum is calculated by total data octets sent by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfIntvTotalRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvTotalRxLoad.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvTotalRxLoad.setDescription(' This object identifies the PVC total rx load within a 15 minutes interval. This statistic datum is calculated by total data octets received by a specific PVC within the 15 minutes over the PVC total available load. If the CIR is correctly defined for this PVC, PVC available load will depend on CIR, otherwise, it will get from interface speed. ')
pvcPerfIntvCirToNetExceed = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvCirToNetExceed.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvCirToNetExceed.setDescription(' This object identifies the number of exceeding CIR times that the network detected within an interval. The measurement is done for every Tc, and the direction is to the network.')
pvcPerfIntvEirToNetExceed = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvEirToNetExceed.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvEirToNetExceed.setDescription(' This object identifies the number of exceeding EIR times that the network detected within an interval. The measurement is done for every Tc, and the direction is to the network.')
pvcPerfIntvTxFrameLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("notAvail", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvTxFrameLoss.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvTxFrameLoss.setDescription(' This object identifies the percentage of tx loss of frames within the total tx frames for this PVC in this interval.')
pvcPerfIntvRxFrameLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("notAvail", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfIntvRxFrameLoss.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfIntvRxFrameLoss.setDescription(' This object identifies the percentage of rx loss of frames within the total rx frames for this PVC in this interval.')
pvcPerfRealTimeTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 5), )
if mibBuilder.loadTexts: pvcPerfRealTimeTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfRealTimeTable.setDescription(' PVC performance table, which displays the performance statistic data based on each PVC.')
pvcPerfRealTimeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 5, 1), ).setIndexNames((0, "AP553-MIB", "pvcPerfRealTimeDlciIndex"))
if mibBuilder.loadTexts: pvcPerfRealTimeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfRealTimeEntry.setDescription(' Identifies an entry (row) in pvc statistic table')
pvcPerfRealTimeDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfRealTimeDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfRealTimeDlciIndex.setDescription(' This index value which uniquely identifies the PVC number to which this entry is applicable. ')
pvcPerfRealTimeRtd = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfRealTimeRtd.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfRealTimeRtd.setDescription(' Probe token real time round trip delay in msec. for a PVC, it is calculated every Probe Poll interval (1 to 60 sec.). ')
pvcPerfRealTimeLoadToDCE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfRealTimeLoadToDCE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfRealTimeLoadToDCE.setDescription(' This object displays the PVC load to DCE within current TC ( 1 sec.), this variable is calculated by total octets transmitted to DTE over the CIR of this PVC.')
pvcPerfRealTimeLoadToDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 3, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcPerfRealTimeLoadToDTE.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPerfRealTimeLoadToDTE.setDescription(' This object displays the PVC load to DTE within current TC ( 1 sec.), this variable is calculated by total octets transmitted to DCE over the CIR of this PVC.')
alarmCurrentStatusBitsMap = MibScalar((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmCurrentStatusBitsMap.setStatus('mandatory')
if mibBuilder.loadTexts: alarmCurrentStatusBitsMap.setDescription('This parameter is a bitmap for the 6 enterprise specific traps. A bit value of one means the trap is active. A bit value of zero means the trap is clear. 1st bit = avgChanLoadToDTE_trap; 2nd bit = realTimeChanLoadToDTE_trap; 3rd bit = avgChanLoadToDCE_trap; 4th bit = realTimeChanLoadToDCE_trap; 5th bit = networkLmiInterfaceDown_trap; 6th bit = userLmiInterfaceDown_trap; ')
alarmCurrentStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4, 1, 2), )
if mibBuilder.loadTexts: alarmCurrentStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: alarmCurrentStatusTable.setDescription(' PVC table which lists PVCs and alarm status. ')
alarmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4, 1, 2, 1), ).setIndexNames((0, "AP553-MIB", "alarmStatusTableIndex"))
if mibBuilder.loadTexts: alarmStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStatusEntry.setDescription(' Identifies an entry (row) in PVC alarm status table.')
alarmStatusTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmStatusTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStatusTableIndex.setDescription(' Identifies an entry (row) in the alarm status table. ')
currentStatusBitsMap = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 22, 1, 2, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentStatusBitsMap.setStatus('mandatory')
if mibBuilder.loadTexts: currentStatusBitsMap.setDescription('This parameter is a bitmap for the 14 enterprise specific traps. A bit value of one means the trap is active. A bit value of zero means the trap is clear. 1st bit = avgPvcNotAvailToDCE_trap; 2nd bit = avgPvcNotAvailToDTE_trap; 3rd bit = avgPvcRoundTripDelay_trap; 4th bit = realTimePvcRoundTripDelay_trap; 5th bit = avgPvcBecnFrames_trap; 6th bit = avgPvcFecnFrames_trap; 7th bit = avgPvcLoadToDTE_trap; 8th bit = realTimePvcLoadToDTE_trap; 9th bit = avgPvcLoadToDCE_trap; 10th bit = realTimePvcLoadToDCE_trap; 11th bit = avgPvcCIRExceedToDTE_trap; 12th bit = avgPvcEIRExceedToDTE_trap; 13th bit = avgPvcLossFrameTx_trap; 14th bit = avgPvcLossFrameRx_trap; ')
mibBuilder.exportSymbols("AP553-MIB", pollPeriod=pollPeriod, realTimeChanLoadToDTEThreshVar=realTimeChanLoadToDTEThreshVar, chCurrTxResp=chCurrTxResp, pvcIntvDteOctets=pvcIntvDteOctets, alarmCurrentStatusBitsMap=alarmCurrentStatusBitsMap, lmiDLCI=lmiDLCI, pvcPerfIntvTxLoad=pvcPerfIntvTxLoad, avgPvcNotAvailToDCEThresh=avgPvcNotAvailToDCEThresh, frProbeMIBversion=frProbeMIBversion, pvcCurrLoopback=pvcCurrLoopback, chIntvLmiRxResp=chIntvLmiRxResp, chPerfIntvRxLoad=chPerfIntvRxLoad, pvcPerfIntvEntry=pvcPerfIntvEntry, pvcPerfRealTimeDlciIndex=pvcPerfRealTimeDlciIndex, chCurrRxPoll=chCurrRxPoll, chPerfIntvIndex=chPerfIntvIndex, realTimePvcLoadToDTEThreshVar=realTimePvcLoadToDTEThreshVar, avgPvcFecnFramesThresh=avgPvcFecnFramesThresh, pvcPerfIntvRxLoad=pvcPerfIntvRxLoad, avgChanLoadToDTETrapSeverity=avgChanLoadToDTETrapSeverity, pvcCurrFecnFrames=pvcCurrFecnFrames, pvcIntvFecnFrames=pvcIntvFecnFrames, chanPerfCurr=chanPerfCurr, avgChanLoadToDTEThresh=avgChanLoadToDTEThresh, pvcPerfRealTimeLoadToDTE=pvcPerfRealTimeLoadToDTE, pvcPerfCurrUnavailToDte=pvcPerfCurrUnavailToDte, proFunConfig=proFunConfig, realTimeTrapSeverity=realTimeTrapSeverity, chPerfCurrTxLoad=chPerfCurrTxLoad, t391Timer=t391Timer, chanPerfIntvEntry=chanPerfIntvEntry, pvcDiscovery=pvcDiscovery, pvcCirToDTE=pvcCirToDTE, pvcCirEirTable=pvcCirEirTable, chanAggregateRate=chanAggregateRate, chIntvDCELmiTimeout=chIntvDCELmiTimeout, pvcState=pvcState, chCurrDceOctets=chCurrDceOctets, pvcPerfRealTimeRtd=pvcPerfRealTimeRtd, chPerfCurrTotalTxLoad=chPerfCurrTotalTxLoad, maxInfoLength=maxInfoLength, pvcStIntervalEntry=pvcStIntervalEntry, chPerfCurrUnavailToDte=chPerfCurrUnavailToDte, pvcIntvDteFramesWithDE=pvcIntvDteFramesWithDE, pvcIntvTxPoll=pvcIntvTxPoll, unitType=unitType, avgPvcRoundTripDelayThresh=avgPvcRoundTripDelayThresh, pvcPerfIntvTotalTxLoad=pvcPerfIntvTotalTxLoad, avgPvcBecnFramesTrapSeverity=avgPvcBecnFramesTrapSeverity, probePerform=probePerform, currentStatusBitsMap=currentStatusBitsMap, chIntvDteOctets=chIntvDteOctets, chIntvDceFrames=chIntvDceFrames, pvcAdd=pvcAdd, pvcPerfIntvTxFrameLoss=pvcPerfIntvTxFrameLoss, probeVersion=probeVersion, avgPvcLoadToDTETrapSeverity=avgPvcLoadToDTETrapSeverity, pvcPerfIntvEirToNetExceed=pvcPerfIntvEirToNetExceed, trapConfig=trapConfig, pvcPerfIntvUnavailToDce=pvcPerfIntvUnavailToDce, avgChanLoadToDCETrapSeverity=avgChanLoadToDCETrapSeverity, chanConfig=chanConfig, chPerfCurrTotalRxLoad=chPerfCurrTotalRxLoad, chIntvRxPoll=chIntvRxPoll, pvcCurrTxResp=pvcCurrTxResp, pvcCirEirTableIndex=pvcCirEirTableIndex, pvcIdentifier=pvcIdentifier, lmiN391=lmiN391, chCurrDceFrames=chCurrDceFrames, chIntvTxPoll=chIntvTxPoll, pvcIntvDteFrames=pvcIntvDteFrames, realTimeChanLoadToDCEThresh=realTimeChanLoadToDCEThresh, chCurrRxIp=chCurrRxIp, pvcIntvRxPoll=pvcIntvRxPoll, pvcPerfCurrEirToNetExceed=pvcPerfCurrEirToNetExceed, chCurrLmiTxEnq=chCurrLmiTxEnq, avgPvcBecnFramesThresh=avgPvcBecnFramesThresh, chCurrLmiRxResp=chCurrLmiRxResp, chStIntervalEntry=chStIntervalEntry, pvcCurrDceOctets=pvcCurrDceOctets, chIntvLmiTxResp=chIntvLmiTxResp, avgPvcLoadToDCEThresh=avgPvcLoadToDCEThresh, pvcStCurrentTable=pvcStCurrentTable, lmiUser393=lmiUser393, realTimePvcRoundTripDelayThreshVar=realTimePvcRoundTripDelayThreshVar, chIntvLmiTxEnq=chIntvLmiTxEnq, chPerfIntvTxLoad=chPerfIntvTxLoad, realTimeChanLoadToDCEThreshVar=realTimeChanLoadToDCEThreshVar, pvcPerfCurrEntry=pvcPerfCurrEntry, pvcPerfCurrCirToNetExceed=pvcPerfCurrCirToNetExceed, pvcCurrTxPoll=pvcCurrTxPoll, chCurrDteFrames=chCurrDteFrames, chanPerfIntvTable=chanPerfIntvTable, avgPvcNotAvailToDTEThresh=avgPvcNotAvailToDTEThresh, networkLmiInterfaceDownTrapSeverity=networkLmiInterfaceDownTrapSeverity, pvcCurrBecnFrames=pvcCurrBecnFrames, lmiConfig=lmiConfig, pvcPerfCurrRxLoad=pvcPerfCurrRxLoad, pvcPerfIntvRtd=pvcPerfIntvRtd, realTimeChanLoadToDTEThresh=realTimeChanLoadToDTEThresh, pvcPerfCurrTable=pvcPerfCurrTable, pvcCurrDceFramesWithDE=pvcCurrDceFramesWithDE, pvcIntvDlciIndex=pvcIntvDlciIndex, lmiUser392=lmiUser392, pvcPerfIntvDlciIndex=pvcPerfIntvDlciIndex, t392Timer=t392Timer, alarmStatusTableIndex=alarmStatusTableIndex, avgPvcCIRExceedToDTETrapSeverity=avgPvcCIRExceedToDTETrapSeverity, chPerfIntvTotalTxLoad=chPerfIntvTotalTxLoad, realTimePvcRoundTripDelayThresh=realTimePvcRoundTripDelayThresh, chIntvDteFrames=chIntvDteFrames, pvcCurrDceFrames=pvcCurrDceFrames, pvcStIntervalTable=pvcStIntervalTable, alarmCurrentStatusTable=alarmCurrentStatusTable, pvcIntvTxResp=pvcIntvTxResp, probeConfig=probeConfig, avgPvcNotAvailToDTETrapSeverity=avgPvcNotAvailToDTETrapSeverity, userLmiInterfaceDownTrapSeverity=userLmiInterfaceDownTrapSeverity, pvcDelete=pvcDelete, pvcIntvDceFramesWithDE=pvcIntvDceFramesWithDE, pvcIntvLoopback=pvcIntvLoopback, realTimePvcLoadToDCEThreshVar=realTimePvcLoadToDCEThreshVar, avgPvcRoundTripDelayTrapSeverity=avgPvcRoundTripDelayTrapSeverity, pvcPerfCurrUnavailToDce=pvcPerfCurrUnavailToDce, globalTC=globalTC, pvcOperation=pvcOperation, ipDLCI=ipDLCI, chCurrRxResp=chCurrRxResp, chCurrLmiRxEnq=chCurrLmiRxEnq, chIntvDceOctets=chIntvDceOctets, avgPvcLossFrameTxTrapSeverity=avgPvcLossFrameTxTrapSeverity, pvcPerfCurrTxLoad=pvcPerfCurrTxLoad, ipEncapp=ipEncapp, chPerfCurrLoadToDteRealTime=chPerfCurrLoadToDteRealTime, lmiNet392=lmiNet392, pvcCount=pvcCount, chPerfIntvUnavailToDce=chPerfIntvUnavailToDce, chPerfCurrRxLoad=chPerfCurrRxLoad, pvcPerfRealTimeLoadToDCE=pvcPerfRealTimeLoadToDCE, lmiOperation=lmiOperation, chCurrLmiTxResp=chCurrLmiTxResp, pvcPerfCurrRtd=pvcPerfCurrRtd, pvcConfig=pvcConfig, avgPvcFecnFramesTrapSeverity=avgPvcFecnFramesTrapSeverity, chCurrTxPoll=chCurrTxPoll, chStIntervalTable=chStIntervalTable, avgPvcNotAvailToDCETrapSeverity=avgPvcNotAvailToDCETrapSeverity, pvcCurrDteOctets=pvcCurrDteOctets, pvcEirToDTE=pvcEirToDTE, pvcPerfCurrTxFrameLoss=pvcPerfCurrTxFrameLoss, chCurrBecnFrames=chCurrBecnFrames, pvcPerfCurrRxFrameLoss=pvcPerfCurrRxFrameLoss, avgPvcEIRExceedToDTETrapSeverity=avgPvcEIRExceedToDTETrapSeverity, pvcCurrDteFrames=pvcCurrDteFrames, pvcStCurrentEntry=pvcStCurrentEntry, trapStatus=trapStatus, pvcIntvDceFrames=pvcIntvDceFrames, pvcIntvIndex=pvcIntvIndex, pvcPerfCurrTotalTxLoad=pvcPerfCurrTotalTxLoad, chPerfIntvUnavailToDte=chPerfIntvUnavailToDte, probeMode=probeMode, pvcEirToDCE=pvcEirToDCE, chIntvTxIp=chIntvTxIp, avgChanLoadToDCEThresh=avgChanLoadToDCEThresh, pvcPerfRealTimeTable=pvcPerfRealTimeTable, pvcPerfIntvUnavailToDte=pvcPerfIntvUnavailToDte, chIntvRxResp=chIntvRxResp, chPerfCurrUnavailToDce=chPerfCurrUnavailToDce, chIntvDTELmiTimeout=chIntvDTELmiTimeout, lmiNet393=lmiNet393, probeStat=probeStat, chCurrFecnFrames=chCurrFecnFrames, pvcPerfIntvTable=pvcPerfIntvTable, chIntvBecnFrames=chIntvBecnFrames, chIntvLmiRxEnq=chIntvLmiRxEnq, chPerfIntvTotalRxLoad=chPerfIntvTotalRxLoad, pvcCurrDteFramesWithDE=pvcCurrDteFramesWithDE, chIntvFecnFrames=chIntvFecnFrames, realTimePvcLoadToDTEThresh=realTimePvcLoadToDTEThresh, pvcPerfIntvRxFrameLoss=pvcPerfIntvRxFrameLoss, pvcPerfIntvCirToNetExceed=pvcPerfIntvCirToNetExceed, lmiType=lmiType, intervalComplete=intervalComplete, chIntvTxResp=chIntvTxResp, pvcCurrRxResp=pvcCurrRxResp, pvcCirToDCE=pvcCirToDCE, pvcIntvDceOctets=pvcIntvDceOctets, chIntvIndex=chIntvIndex, chPerfCurrLoadToDceRealTime=chPerfCurrLoadToDceRealTime, pvcPerfCurrTotalRxLoad=pvcPerfCurrTotalRxLoad, pvcPerfIntvTotalRxLoad=pvcPerfIntvTotalRxLoad, alarmStatus=alarmStatus, probeTokenSize=probeTokenSize, avgPvcLoadToDTEThresh=avgPvcLoadToDTEThresh, chCurrDCELmiTimeout=chCurrDCELmiTimeout, pvcPerfCurrDlciIndex=pvcPerfCurrDlciIndex, alarmStatusEntry=alarmStatusEntry, avgPvcLoadToDCETrapSeverity=avgPvcLoadToDCETrapSeverity, pvcOperStateChangeTrapSeverity=pvcOperStateChangeTrapSeverity, chCurrTxIp=chCurrTxIp, pvcPerfIntvIndex=pvcPerfIntvIndex, pvcIntvBecnFrames=pvcIntvBecnFrames, realTimePvcLoadToDCEThresh=realTimePvcLoadToDCEThresh, chStCurrent=chStCurrent, chCurrDteOctets=chCurrDteOctets, pvcCurrRxPoll=pvcCurrRxPoll, pvcCurrDlciIndex=pvcCurrDlciIndex, pvcPerfRealTimeEntry=pvcPerfRealTimeEntry, chIntvRxIp=chIntvRxIp, avgPvcLossFrameRxTrapSeverity=avgPvcLossFrameRxTrapSeverity, chCurrDTELmiTimeout=chCurrDTELmiTimeout, pvcCirEirEntry=pvcCirEirEntry, pvcIntvRxResp=pvcIntvRxResp)

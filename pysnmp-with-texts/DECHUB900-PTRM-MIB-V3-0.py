#
# PySNMP MIB module DECHUB900-PTRM-MIB-V3-0 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DECHUB900-PTRM-MIB-V3-0
# Produced by pysmi-0.3.4 at Wed May  1 12:37:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, Counter64, NotificationType, enterprises, Bits, ModuleIdentity, ObjectIdentity, TimeTicks, Unsigned32, Counter32, Gauge32, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter64", "NotificationType", "enterprises", "Bits", "ModuleIdentity", "ObjectIdentity", "TimeTicks", "Unsigned32", "Counter32", "Gauge32", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decHub900 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11))
ptrm = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3))
ptrmBase = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 1))
ptrmBaseForceSpeed = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notForced", 1), ("force-4Mbps", 2), ("force-16Mbps", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptrmBaseForceSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmBaseForceSpeed.setDescription('This object selects the speed at which to token ring linecard operates. When set to notForced(1), the linecard will not be forced. Based on the line-card its speed may change by a voting algorithm on its lobe ports or by console selection. Forcing the speed to 4 or 16 only applies when stand-alone; in a hub, the ring to which the module is forced determines the speed at which it operates. The value of this object is maintained across power cycles and resets.')
ptrmBaseSpeed = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoBauding", 1), ("speed-4Mbps", 2), ("speed-16Mbps", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmBaseSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmBaseSpeed.setDescription('Indicates the speed at which the linecard is operating. Devices like the DECmau 900TL autobaud when they are not forced via ptrmBaseForceSpeed and if there are no stations plugged into the lobe ports. Devices like the DECmau 900TH (Dtmxm) have a default speed of 16Mbps which can also be changed via a console interface.')
ptrmBaseNumLobes = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmBaseNumLobes.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmBaseNumLobes.setDescription('The number of end station lobes supported by this module. This is the number of rows in the ptrmLobeTable. This variable is zero for repeaters.')
ptrmTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2), )
if mibBuilder.loadTexts: ptrmTrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkTable.setDescription("Defines a table with rows for each token ring connection not otherwise associated with an end-user 'lobe' port. The following rows are implemented: ptrmTrunkType Leaf VIDs Port ------------ ---------- ---- RingIn (1) 3.2.1.x.1 Copper Ring In RingOut (2) 3.2.1.x.2 Copper Ring Out HubA-1 (3) 3.2.1.x.3 Hub token ring A port 1 HubB-1 (4) 3.2.1.x.4 Hub token ring B port 1 FibreIn (5) 3.2.1.x.5 FibreRingIn FibreOut(6) 3.2.1.x.6 FibreRingOut HubA-2 (7) 3.2.1.x.3 Hub token ring A port 2 HubB-2 (8) 3.2.1.x.4 Hub token ring B port 2 ")
ptrmTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1), ).setIndexNames((0, "DECHUB900-PTRM-MIB-V3-0", "ptrmTrunkType"))
if mibBuilder.loadTexts: ptrmTrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkEntry.setDescription('A collection of trunk objects.')
ptrmTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("copperRingIn", 1), ("copperRingOut", 2), ("hubA", 3), ("hubB", 4), ("fiberRingIn", 5), ("fiberRingOut", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkType.setDescription("Identifies a trunk (i.e. non-lobe) port. All token ring modules implement all four rows defined by the ptrmTrunkType values. If a module's configuration does not allow it to implement the particular trunk ptrmTrunkOperStatus is notPresent(3). For example, linecards in a hub do not have a RingIn or RingOut port and therefore contain the value notPreset(3) as the ptrmTrunkOperStatus for ringIn(1) and ringOut(2) rows of the trunk table. Linecards that do not have a fiber interface need not implement rows FiberIn(5) and FiberOut(6). NOTE - If a Trunk is notPresent, the rest of the values in this table are to be ignored.")
ptrmTrunkOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inserted", 1), ("wrapped", 2), ("notPresent", 3), ("badSpeed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkOperStatus.setDescription("Indicates whether the trunk port is wrapped or inserted into the linecard's internal ring. If the trunk port is not implemented in the linecard's current configuration, then this is notPresent(3). If a trunk is notPresent(3), then the values read from all other columns of the row are undefined. If the port is enabled and an incompatible speed is detected, the value of this object is 'badSpeed(4)'. The trunk TCU is wrapped when in the badSpeed state. When there is a change in this object, a csnmp Trap is sent to the MAM.")
ptrmTrunkAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptrmTrunkAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkAdminStatus.setDescription('Used to disable the trunk port of the linecard during operation. When disabled, the trunk port is forced to wrap. The value of this object is maintained across power cycles and resets.')
ptrmTrunkMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("otherMedia", 1), ("utpMedia", 2), ("stpMedia", 3), ("ibmMedia", 4), ("fiberMedia", 5), ("hubDirect", 6), ("hubTCU", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkMedia.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkMedia.setDescription("The media type of the trunk port. Different module types have different trunk connectors. If a module implements an STP/UTP switch, this variable indicates the setting of that switch. linecards feature Trunk Coupling Units (TCUs) on the module for their hub trunk connection, so they have 'media' type hubTCU(7). Repeaters have a direct connection to the hub backplane, so their hub trunk 'media' type is hubDirect(6).")
ptrmTrunkAutoWrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptrmTrunkAutoWrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkAutoWrapEnable.setDescription("The value of the physical Auto Wrap Enable (AWE) switch for the trunk port. AWE is provided only for RingIn and RingOut trunks. AWE should be set ON for connection to DEChub token ring linecards. It should be set OFF when an IBM 8228 or equivalent 'dumb' linecard is connected. It MUST be physically switched to ON when no cable is inserted into the RI port, in order to cause RI to wrap. This value of this object is notApplicable(3) for hub trunks. The value of this object is maintained across power cycles and resets.")
ptrmTrunkAutoPartitionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkAutoPartitionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkAutoPartitionStatus.setDescription('Indicates whether the trunk port has been auto-partitioned. When autopartitioned(2) a trunk is automatically wrapped.')
ptrmTrunkDetectedSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("speed-4Mbps", 2), ("speed-16Mbps", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkDetectedSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkDetectedSpeed.setDescription('Indicates the speed detected on the incoming data pair. invalid(1) indicates that a valid token ring speed was not detected. notApplicable(4) indicates that the trunk port does not implement speed detect. Hub trunks do not detect speed.')
ptrmTrunkPhantomDrive = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("noDrive", 2), ("driveReceive", 3), ("wireFault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkPhantomDrive.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkPhantomDrive.setDescription("Indicates the state of the RingIn port's phantom current drive and return detect circuits. It is notApplicable(1) on all other trunk types. The noDrive(2) status indicates RingIn is not driving phantom current. driveReceive(3) is the normal case where an active linecard drives phantom current on RingIn and it is returned correctly from the upstream linecard. wireFault(4) indicates the linecard is driving phantom current but the current is not returned correctly, due to either an open or short circuit.")
ptrmTrunkPhantomDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("noDetectPhantom", 2), ("detectPhantom", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmTrunkPhantomDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmTrunkPhantomDetect.setDescription('Indicates the state of the incoming phantom current detect circuit for the RingIn/RingOut Trunk. It is notApplicable(1) to all other trunk types.')
ptrmLobeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3), )
if mibBuilder.loadTexts: ptrmLobeTable.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeTable.setDescription('A table with entries to manage individual end station lobe ports of the linecard.')
ptrmLobeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1), ).setIndexNames((0, "DECHUB900-PTRM-MIB-V3-0", "ptrmLobeIndex"))
if mibBuilder.loadTexts: ptrmLobeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeEntry.setDescription('A lobe entry.')
ptrmLobeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeIndex.setDescription("Port number for the lobe, as it appears externally to the user, i.e. 1 for the port labeled '1'.")
ptrmLobeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inserted", 1), ("wrapped", 2), ("notPresent", 3), ("badSpeed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobeOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeOperStatus.setDescription("Indicates whether the lobe port is wrapped or inserted into the linecard's internal ring. If the lobe port is not implemented in the linecard's current configuration the value of this object is notPresent(3). If a lobe is notPresent(3) then the values of other variables in the row are undefined. If the port is enabled and an incompatible speed is detected, this variable becomes 'badSpeed(4)'. The lobe TCU is wrapped when in the badSpeed state. When there is a change in this object, a CSNMP trap is sent to the MAM.")
ptrmLobeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptrmLobeAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeAdminStatus.setDescription('Used to disable the lobe port during network troubleshooting. If set to disabled(2), the lobe port is forced to wrap. This object must be set to enabled(1) for normal operation. The value of this object is maintained across power cycles and resets.')
ptrmLobeMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("otherMedia", 1), ("utpMedia", 2), ("stpMedia", 3), ("ibmMedia", 4), ("fiberMedia", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobeMedia.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeMedia.setDescription('The media type of the lobe port. Different module types have different lobe connectors. If a module implements an STP/UTP switch for lobes, this variable indicates the setting of that switch.')
ptrmLobeAutoWrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptrmLobeAutoWrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeAutoWrapEnable.setDescription("Software configuration variable set by network management. Auto Wrap Enabled (AWE) should be set on(1) for connection to end stations and the RingIn ports of DEC token ring products. It may be set off(2) for lobe connection to IBM 8228 or equivalent 'dumb' linecards which do not drive phantom current. The factory default is on(1). The value of this object is maintained across power cycles and resets.")
ptrmLobeAutoPartitionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobeAutoPartitionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeAutoPartitionStatus.setDescription('Indicates whether the lobe port has been auto-partitioned. When autoPartitioned(2), a lobe is automatically wrapped.')
ptrmLobeDetectedSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("speed-4Mbps", 2), ("speed-16Mbps", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobeDetectedSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobeDetectedSpeed.setDescription('Indicates the speed detected on the incoming data pair. If invalid(1) a valid token ring speed was not detected. If notApplicable(4), the lobe port does not implement speed detect.')
ptrmLobePhantomDrive = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("notApplicable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobePhantomDrive.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobePhantomDrive.setDescription('This variable is not applicable to lobe ports, and is defined only as a place holder for the corresponding trunk variable.')
ptrmLobePhantomDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("noDetectPhantom", 2), ("detectPhantom", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmLobePhantomDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmLobePhantomDetect.setDescription('Indicates the state of the incoming phantom current detect circuit for the lobe port. Lobe ports are required to implement phantom detect circuitry; the notApplicable code is provided only for the corresponding trunk port variable.')
ptrmMacTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 4), )
if mibBuilder.loadTexts: ptrmMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMacTable.setDescription('A table with entries. The table has 1 entry per MAC chip it contains. ')
ptrmMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 4, 1), ).setIndexNames((0, "DECHUB900-PTRM-MIB-V3-0", "ptrmMacIndex"))
if mibBuilder.loadTexts: ptrmMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMacEntry.setDescription('An entry for the Mac .')
ptrmMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMacIndex.setDescription('An index into the table. There is 1 entry in the table per MAC chip')
ptrmMacRingInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmMacRingInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMacRingInterface.setDescription('Indicates the Ring Interface number corresponding to this MAC. Typically single-ring devices will have only 1 Ring Interface. Devices like the Active Retimed concentartor which suppport multiple segements may have more than 1 ring interface. Note - the interface number must match that reported in the dot5.mib')
ptrmMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMacAddress.setDescription('The Mac address in MSB form for this interface.')
ptrmMacPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmMacPosition.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMacPosition.setDescription('This is the position of the Mac Chip. For modules like the DTMXM, the position of the MAC is settable via software. It can be either before port 1 (MacForward) or after its last port (MacBackward) This makes it easy to partition the ports on its own ring for an accurate ring map. Modules that are end-stations and hence have no lobe ports may report Mac position as 1. if the Mac is in MacForward position the ptrmMacPosition should be reported as 255. For all other Ports, if the Mac is between port A and port B, the Mac postion should be reported as port A.')
ptrmMultiBp = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5))
ptrmNumBackplanePorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmNumBackplanePorts.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmNumBackplanePorts.setDescription(' Number of physical TokenRing backplane ports. ')
ptrmNumLobePorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmNumLobePorts.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmNumLobePorts.setDescription(' Number of lobe ports the linecard has ')
ptrmMultiBpPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 3), )
if mibBuilder.loadTexts: ptrmMultiBpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMultiBpPortTable.setDescription(' This table MUST be supported by TR linecards like the MIPPY, which support multiple physical Token Ring backplane ports. The number of rows in ptrmMultiBpPortTable will be ptrmNumBackplanePorts The ptrmBase group does not have to supported in this configuration. ')
ptrmMultiBpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 3, 1), ).setIndexNames((0, "DECHUB900-PTRM-MIB-V3-0", "ptrmMultiBpPortIndex"))
if mibBuilder.loadTexts: ptrmMultiBpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMultiBpPortEntry.setDescription(' ')
ptrmMultiBpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmMultiBpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMultiBpPortIndex.setDescription(' Index into the table. Corresponds to backplane port number. ')
ptrmMultiBpPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("speed-4Mbps", 2), ("speed-16Mbps", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptrmMultiBpPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMultiBpPortSpeed.setDescription(' Indicates the speed at which the backplane port is operating. The port MUST have a default speed of 4Mbps or 16Mbps to support plug and play operation ')
ptrmMultiBpPortForceSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 3, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notForced", 1), ("force-4Mbps", 2), ("force-16Mbps", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptrmMultiBpPortForceSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ptrmMultiBpPortForceSpeed.setDescription(' This is used only for STANDALONE operation. This object selects the speed at which to token ring port operates. The value of this object is maintained across power cycles and resets. ')
mibBuilder.exportSymbols("DECHUB900-PTRM-MIB-V3-0", ptrmMacPosition=ptrmMacPosition, ptrmMultiBpPortIndex=ptrmMultiBpPortIndex, ptrm=ptrm, ptrmBaseForceSpeed=ptrmBaseForceSpeed, ptrmMultiBpPortEntry=ptrmMultiBpPortEntry, ptrmLobeIndex=ptrmLobeIndex, ptrmLobeAutoWrapEnable=ptrmLobeAutoWrapEnable, ptrmTrunkOperStatus=ptrmTrunkOperStatus, ptrmLobeAutoPartitionStatus=ptrmLobeAutoPartitionStatus, ptrmTrunkDetectedSpeed=ptrmTrunkDetectedSpeed, decHub900=decHub900, ptrmBase=ptrmBase, ptrmTrunkEntry=ptrmTrunkEntry, ptrmMultiBpPortTable=ptrmMultiBpPortTable, ptrmMultiBpPortSpeed=ptrmMultiBpPortSpeed, ptrmBaseNumLobes=ptrmBaseNumLobes, ptrmMacAddress=ptrmMacAddress, ptrmMacTable=ptrmMacTable, ptrmMultiBpPortForceSpeed=ptrmMultiBpPortForceSpeed, ptrmNumLobePorts=ptrmNumLobePorts, ptrmTrunkMedia=ptrmTrunkMedia, ptrmTrunkAutoPartitionStatus=ptrmTrunkAutoPartitionStatus, ptrmLobeAdminStatus=ptrmLobeAdminStatus, ptrmLobeEntry=ptrmLobeEntry, ptrmLobeDetectedSpeed=ptrmLobeDetectedSpeed, ptrmTrunkType=ptrmTrunkType, ptrmMacRingInterface=ptrmMacRingInterface, ptrmMacEntry=ptrmMacEntry, ptrmTrunkPhantomDrive=ptrmTrunkPhantomDrive, ptrmTrunkPhantomDetect=ptrmTrunkPhantomDetect, ptrmTrunkTable=ptrmTrunkTable, ptrmMultiBp=ptrmMultiBp, ptrmLobePhantomDetect=ptrmLobePhantomDetect, ptrmTrunkAutoWrapEnable=ptrmTrunkAutoWrapEnable, ptrmNumBackplanePorts=ptrmNumBackplanePorts, ptrmLobeMedia=ptrmLobeMedia, ema=ema, ptrmLobeTable=ptrmLobeTable, ptrmLobePhantomDrive=ptrmLobePhantomDrive, ptrmLobeOperStatus=ptrmLobeOperStatus, ptrmTrunkAdminStatus=ptrmTrunkAdminStatus, ptrmMacIndex=ptrmMacIndex, ptrmBaseSpeed=ptrmBaseSpeed, decMIBextension=decMIBextension, dec=dec)

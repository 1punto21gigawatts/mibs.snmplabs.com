#
# PySNMP MIB module INXNTS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INXNTS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:55:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits, Gauge32, IpAddress, NotificationType, ModuleIdentity, TimeTicks, Counter64, Counter32, ObjectIdentity, MibIdentifier, Unsigned32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits", "Gauge32", "IpAddress", "NotificationType", "ModuleIdentity", "TimeTicks", "Counter64", "Counter32", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
internet = MibIdentifier((1, 3, 6, 1))
experimental = MibIdentifier((1, 3, 6, 1, 3))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
dot3 = MibIdentifier((1, 3, 6, 1, 3, 3))
interlan = MibIdentifier((1, 3, 6, 1, 4, 1, 28))
riTelnet = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 3))
riTs = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 4))
riBoot = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 16))
riThresh = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 17))
riSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 18))
riTsRates = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 22))
riInternext = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 21))
riProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1))
riProdNts = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1, 2))
riProdLdc = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1, 3))
riLdcNts = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1, 3, 4))
dot3Table = MibTable((1, 3, 6, 1, 3, 3, 1), )
if mibBuilder.loadTexts: dot3Table.setStatus('mandatory')
if mibBuilder.loadTexts: dot3Table.setDescription('A list of the INX-NTS Ethernet interface`s operational attributes, such as whether it is configured for multicast receive and the status of the MAC sublayer. You cannot access this variable; it is only a table marker in the MIB.')
dot3Entry = MibTableRow((1, 3, 6, 1, 3, 3, 1, 1), ).setIndexNames((0, "INXNTS-MIB", "dot3Index"))
if mibBuilder.loadTexts: dot3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3Entry.setDescription('An entry in the INX-NTS Interface table. (See the previous variable, INX-NTS Interface Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Table Index MAC Initialization Status MAC Operational Status Multicast Receive Status Nonaligned Frames Recd FCS Errored Frames Received')
dot3Index = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3Index.setStatus('mandatory')
if mibBuilder.loadTexts: dot3Index.setDescription('The value assigned to the INX-NTS Ethernet interface. Because the INX-NTS has only one interface, this variable always returns 1.')
dot3InitializeMAC = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("initialize", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3InitializeMAC.setStatus('mandatory')
if mibBuilder.loadTexts: dot3InitializeMAC.setDescription('The initialization status of the MAC and PLS subsystems of the interface. Because the MAC and PLS subsystems on the INX-NTS are initialized at power-up and remain so, this variable always returns initialized(1), and may only be set to initialized(1).')
dot3MACSubLayerStatus = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3MACSubLayerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dot3MACSubLayerStatus.setDescription('The operational status of the MAC sublayer, i.e., whether it is ready to transmit and receive frames. Because this sublayer is always active in the INX-NTS, this variable always returns enabled(1), and can only be set to enabled(1).')
dot3MulticastReceiveEnabled = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3MulticastReceiveEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: dot3MulticastReceiveEnabled.setDescription('The Multicast Receive status, i.e., whether the INX-NTS is configured to receive frames with a multicast address. Because Multicast Receive is always enabled on the INX-NTS, this variable always returns true(1), and can only be set to true(1).')
dot3AlignmentErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3AlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3AlignmentErrors.setDescription('The number of frames received on the interface that are not an integral number of octets in length (i.e., the number of bits they contain is not a multiple of eight) and do not pass the FCS check. This condition indicates that the frames were corrupted during transmission.')
dot3FCSErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3FCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3FCSErrors.setDescription('The number of frames received on the interface that are an integral number of octets in length (i.e., the number of bits they contain is a multiple of eight) that do not pass the FCS check, indicating that the frames were corrupted during transmission.')
dot3TxTable = MibTable((1, 3, 6, 1, 3, 3, 2), )
if mibBuilder.loadTexts: dot3TxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxTable.setDescription('A list of transmit errors and statistics for the INX-NTS Ethernet interface. You cannot access this variable; it is only a table marker in the MIB.')
dot3TxEntry = MibTableRow((1, 3, 6, 1, 3, 3, 2, 1), ).setIndexNames((0, "INXNTS-MIB", "dot3TxIndex"))
if mibBuilder.loadTexts: dot3TxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxEntry.setDescription('An entry in the Interface Transmit table. (See the previous variable, Interface Transmit Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Transmit Index Single Collisions Transmitted Multiple Collisions Xmitted Total SQE Test Errors')
dot3TxIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxIndex.setDescription('The value assigned to the INX-NTS Ethernet interface. Because the INX-NTS has only one interface, this variable always returns 1.')
dot3TxSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxSingleCollisionFrames.setDescription('The number of frames that were successfully transmitted after experiencing one and only one collision.')
dot3TxMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxMultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxMultipleCollisionFrames.setDescription('The number of frames that were successfully transmitted after experiencing more than one collision.')
dot3TxSQETestErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxSQETestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxSQETestErrors.setDescription("The number of frames for which the INX-NTS's collision detect logic did not detect a Signal-Quality-Error-Test (SQE-Test) signal immediately after a packet transmission. The INX-NTS does not generate SQE-Test error messages, so this variable always returns 0.")
dot3XRxTable = MibTable((1, 3, 6, 1, 3, 3, 3), )
if mibBuilder.loadTexts: dot3XRxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxTable.setDescription('A list of receive errors and statistics for the INX-NTS Ethernet interface. You cannot access this variable; it is only a table marker in the MIB.')
dot3XRxEntry = MibTableRow((1, 3, 6, 1, 3, 3, 3, 1), ).setIndexNames((0, "INXNTS-MIB", "dot3XRxIndex"))
if mibBuilder.loadTexts: dot3XRxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxEntry.setDescription('An entry in the Interface Receive table. (See the previous variable, Interface Receive Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Receive Index Too Long Frames Recd In-Range Length Errors Recd Out-Range Length Errors Recd MAC Errors Received Autopartition Status Autopartition Disconnects Last Good Source Address Recd Source Address Changes Count')
dot3XRxIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxIndex.setDescription('The value assigned to the INX-NTS Ethernet interface. Because the INX-NTS has only one interface, this variable always returns 1.')
dot3XRxFrameTooLongs = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxFrameTooLongs.setDescription('The number of frames received on the interface that exceed the maximum permitted frame size, i.e., 1180 octets.')
dot3XRxInRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxInRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxInRangeLengthErrors.setDescription('The number of in-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error. The INX-NTS receives Ethernet frames that do not have a length in the length field. It therefore cannot detect this error, and this variable always returns 0.')
dot3XRxOutOfRangeLengthFields = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxOutOfRangeLengthFields.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxOutOfRangeLengthFields.setDescription('The number of out-of-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside 802.3 parameters, the receiving device returns an out-of-range error. The INX-NTS receives Ethernet frames that do not have a length in the length field. It therefore cannot detect this error, and this variable always returns 0.')
dot3XRxInternalMACReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxInternalMACReceiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxInternalMACReceiveErrors.setDescription('The number of frames the interface could not receive because of an internal MAC sublayer receive error. This variable returns frames not counted by the Too Long Frames Received, Nonaligned Frames Received, FCS Errored Frames Received, In-Range Length Errors Recd, and Out-Range Length Errors Recd variables.')
dot3XRxAutoPartitionStatus = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("notpartitioned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3XRxAutoPartitionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxAutoPartitionStatus.setDescription('The autopartition status of the INX-NTS. Devices that support autopartitioning have the ability to autonomously disconnect from the network when they sense trouble, e.g., a device with a jabber condition. Because the INX-NTS interface does not support autopartitioning, this variable always returns notpartitioned(2). This object may be written to with the value notpartitioned(2).')
dot3XRxAutoPartitionLog = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxAutoPartitionLog.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxAutoPartitionLog.setDescription('The number of autopartitions the INX-NTS has performed. Devices that support autopartitioning maintain a log of the number of times they disconnected from the network. Because the INX-NTS interface does not support auto-partitioning, this variable always returns 0.')
dot3XRxLastSourceAddress = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxLastSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxLastSourceAddress.setDescription('The source address of the last frame successfully received. Because this value changes too often to be useful, the INX-NTS interface does not record the last source address of received frames; therefore, this variable always returns a null value.')
dot3XRxSourceAddressLog = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxSourceAddressLog.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxSourceAddressLog.setDescription('The number of times that the value of Last Good Source Address Recd has changed. The INX-NTS interface does not log source address changes; therefore, this variable always returns 0.')
dot3XTxTable = MibTable((1, 3, 6, 1, 3, 3, 4), )
if mibBuilder.loadTexts: dot3XTxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxTable.setDescription('A list of transmit errors and statistics for the INX-NTS Ethernet interface. You cannot access this variable; it is only a table marker in the MIB.')
dot3XTxEntry = MibTableRow((1, 3, 6, 1, 3, 3, 4, 1), ).setIndexNames((0, "INXNTS-MIB", "dot3XTxIndex"))
if mibBuilder.loadTexts: dot3XTxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxEntry.setDescription('An entry in the Interface Xmit Error/Stat table. (See the previous variable, Interface Xmit Error/Stat Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Xmit Error/Stat Index Interface Transmit Status Transmissions Deferred Late Collisions Detected Excessive Collisions Detected MAC Transmit Errors Carrier Sense Errors Deferred Frames TDR Status')
dot3XTxIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxIndex.setDescription('The value assigned to the INX-NTS Ethernet interface. Because the INX-NTS has only one interface, this variable always returns 1.')
dot3XTxEnabled = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3XTxEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxEnabled.setDescription('The transmit status of the interface, i.e., whether it is able to transmit frames. Because transmit is always enabled on the INX-NTS, this variable always returns true(1), and can only be set to true(1).')
dot3XTxDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxDeferredTransmissions.setDescription('The number of times the INX-NTS deferred transmission of data because it sensed traffic on the network. Because the INX-NTS does not record deferrals, this variable always returns 0.')
dot3XTxLateCollisions = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxLateCollisions.setDescription('The number of times that a collision has been detected on this bus later than 512 bit times from frame start.')
dot3XTxExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxExcessiveCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxExcessiveCollisions.setDescription('The number of frames the interface could not transmit because of excessive collisions.')
dot3XTxInternalMACTransmitErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxInternalMACTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxInternalMACTransmitErrors.setDescription('The number of frames the interface could not transmit because of an internal MAC sublayer transmit error. This variable counts frames not counted by the Late Collisions Detected, Excessive Collisions Detected, Carrier Sense Errors, and Deferred Frames variables.')
dot3XTxCarrierSenseErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxCarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxCarrierSenseErrors.setDescription('The number of times that the carrier-sense condition was lost or never asserted when the INX-NTS attempted to transmit a frame on the interface. This count is incremented at most once per transmission attempt, even if the carrier-sense condition fluctuates during the transmit attempt.')
dot3XTxExcessiveDeferrals = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxExcessiveDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxExcessiveDeferrals.setDescription('The number of frames the INX-NTS deferred transmitting for an excessive period of time. Because the INX-NTS interface does not record deferrals, this variable always returns 0.')
dot3XTxTDR = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxTDR.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxTDR.setDescription('The status of Time Domain Reflectometry (TDR) on the INX-NTS. TDR is the ability of a device to check the viability of a cable by sending a signal to the end of the cable. The INX-NTS interface does not support Time Domain Reflectometry,so this variable always returns 0.')
dot3CollTable = MibTable((1, 3, 6, 1, 3, 3, 5), )
if mibBuilder.loadTexts: dot3CollTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollTable.setDescription('A histogram representing the frequency of collisions on the interface. In the Collision Frequency histogram, one dimension of each cell represents Collisions per Frame, and the other dimension represents Collision Frequency. You cannot access this variable; it is only a table marker in the MIB.')
dot3CollEntry = MibTableRow((1, 3, 6, 1, 3, 3, 5, 1), ).setIndexNames((0, "INXNTS-MIB", "dot3CollIndex"), (0, "INXNTS-MIB", "dot3CollCount"))
if mibBuilder.loadTexts: dot3CollEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollEntry.setDescription('An entry in the Collision Frequency table. (See the previous variable, Collision Frequency Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Collision Frequency Index Collisions per Frame Collision Frequency')
dot3CollIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3CollIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollIndex.setDescription('The value assigned to the INX-NTS Ethernet interface. Because the INX-NTS has only one interface, this variable always returns 1.')
dot3CollCount = MibTableColumn((1, 3, 6, 1, 3, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3CollCount.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollCount.setDescription('The number of media collisions per frame indicated by one cell in the collision histogram. The INX-NTS tracks the number of collisions up to 15.')
dot3CollFrequency = MibTableColumn((1, 3, 6, 1, 3, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3CollFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollFrequency.setDescription('The number of frames that were transmitted after experiencing exactly Collisions per Frame collisions on the INX-NTS Ethernet interface (see the previous variable, Collisions per Frame).')
riNumBoots = MibScalar((1, 3, 6, 1, 4, 1, 28, 16, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riNumBoots.setStatus('mandatory')
if mibBuilder.loadTexts: riNumBoots.setDescription('The number of entries in the boot table. Because there are two files that can be booted (chassis management protocol and high-level protocol), there will always be two entries in the INX-NTS boot table. Therefore, this variable will always return a 2, and can only be set to 2.')
riBootServiceOffered = MibScalar((1, 3, 6, 1, 4, 1, 28, 16, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootServiceOffered.setStatus('mandatory')
if mibBuilder.loadTexts: riBootServiceOffered.setDescription('The setting of this variable determines whether this INX-NTS can provide boot images to other systems, returning true(2) if it can and false(1) if it cannot.')
riBootTable = MibTable((1, 3, 6, 1, 4, 1, 28, 16, 3), )
if mibBuilder.loadTexts: riBootTable.setStatus('mandatory')
if mibBuilder.loadTexts: riBootTable.setDescription('This table contains boot information for the INX-NTS. You cannot access this variable; it is only a table marker in the MIB.')
riBootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 16, 3, 1), ).setIndexNames((0, "INXNTS-MIB", "riBootIndex"))
if mibBuilder.loadTexts: riBootEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riBootEntry.setDescription('An entry in the Boot table. (See the previous variable, Boot Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Boot Table Index Boot File Name IP Address for TFTP Boot Boot File Version Gateway Address for Booting')
riBootIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riBootIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riBootIndex.setDescription('A unique value for each entry in the boot table. This variable returns 1 for the Chassis Management Protocol file and 2 for the operating software image file.')
riBootFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootFileName.setStatus('mandatory')
if mibBuilder.loadTexts: riBootFileName.setDescription('The name of the boot file that the INX-NTS will attempt to load.')
riBootIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: riBootIPAddress.setDescription('The IP address of the node from which the INX-NTS will attempt a TFTP boot.')
riBootVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootVersion.setStatus('mandatory')
if mibBuilder.loadTexts: riBootVersion.setDescription('The revision level of the boot file.')
riBootGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootGateway.setStatus('mandatory')
if mibBuilder.loadTexts: riBootGateway.setDescription('The IP address of the gateway through which the INX-NTS can access the boot server.')
riSystemHardwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemHardwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemHardwareRev.setDescription('The hardware revision level of the INX-NTS.')
riSystemFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemFirmwareRev.setDescription('The firmware revision level of the INX-NTS.')
riSystemSoftwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemSoftwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemSoftwareRev.setDescription('The software revision level of the INX-NTS.')
riSystemSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemSerialNumber.setDescription('The serial number of the INX-NTS.')
riSystemReset = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("notreset", 1), ("resetupdate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riSystemReset.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemReset.setDescription('The reset state of the INX-NTS. o resetupdate(3) causes the INX-NTS to reset following the next NVRAM update. o notreset(1) has no effect.')
riSystemTicksPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemTicksPerSecond.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemTicksPerSecond.setDescription('The number of internal clock ticks that occur each second on the INX-NTS.')
riSystemRateInterval = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riSystemRateInterval.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemRateInterval.setDescription('How often, in seconds, any rate statistic maintained by the INX-NTS is checked. The default is 20 seconds.')
riSystemNVRamWriteCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemNVRamWriteCount.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemNVRamWriteCount.setDescription('The number of times that the NVRAM has been changed.')
riTsPortCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortCount.setDescription('The number of terminal ports on the INX-NTS. Because there are 16 ports on the INX-NTS, this variable always returns 16.')
riTsSignOn = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsSignOn.setStatus('mandatory')
if mibBuilder.loadTexts: riTsSignOn.setDescription('Allows you to view or change the INX-NTS sign-on message. This message is displayed when you enter command mode from idle mode, and when you connect to a slave port. The message can be up to 120 characters long.')
riTsPrompt = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPrompt.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPrompt.setDescription('Allows you to view or change the INX-NTS command-mode prompt. The default is inx-nts>. The prompt can contain up to 80 characters.')
riTsAdminPW = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsAdminPW.setStatus('mandatory')
if mibBuilder.loadTexts: riTsAdminPW.setDescription('The password to use when entering administrative mode in the INX-NTS. For security reasons, this variable always returns the string PASSWORD-RESTRICTED. If you are using the INX-LCD, the default password is 123456. (Press each of the function keys located to the left of the Unit key in order from left to right.) If you are accessing the INX-NTS by another means, the default password is hello. To change this password, use the administrative command PASSWORD. Your new password can be up to 20 characters long.')
riTsDomainName = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: riTsDomainName.setDescription('The name that is appended to the host name when the INX-NTS requests a name server and the string entered by the user contains no period. (If the string does contain a period, the INX-NTS assumes it is a fully qualified domain name.)')
riTsUpTimeNodeName = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsUpTimeNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: riTsUpTimeNodeName.setDescription('The node name to be contained in future RWHO (UPTIME) broadcasts. The name can contain up to seven characters.')
riTsNumBuffers = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsNumBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: riTsNumBuffers.setDescription('The number of buffers that a Telnet, RLOGIN, or LAT process can use for receiving inbound traffic.')
riTsReadBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsReadBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: riTsReadBufferSize.setDescription('The TCP read buffer size, in octets.')
riTsWriteBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(48, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsWriteBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: riTsWriteBufferSize.setDescription('The TCP write buffer size, in octets.')
riTsTcpWindowSize = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsTcpWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: riTsTcpWindowSize.setDescription('The TCP default window size, in octets.')
riTsTcpMaxSeg = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsTcpMaxSeg.setStatus('mandatory')
if mibBuilder.loadTexts: riTsTcpMaxSeg.setDescription('The TCP maximum segment size, in octets.')
riTsBreakChar = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsBreakChar.setStatus('mandatory')
if mibBuilder.loadTexts: riTsBreakChar.setDescription('Allows you to view or change the INX-NTS break-in character, which permits you to escape from a connection and return to command mode. This variable returns the value of the ASCII character to use as the break-in character. The default value is 256, which sets the Break key as the break-in character.')
riTsFarMemoryFree = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsFarMemoryFree.setStatus('mandatory')
if mibBuilder.loadTexts: riTsFarMemoryFree.setDescription('The number of available octets in the far memory pool.')
riTsFarMemoryLowest = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsFarMemoryLowest.setStatus('mandatory')
if mibBuilder.loadTexts: riTsFarMemoryLowest.setDescription('The lowest number of octets available in the far memory pool since the INX-NTS was reset.')
riTsTcpAckTimer = MibScalar((1, 3, 6, 1, 4, 1, 28, 4, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsTcpAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: riTsTcpAckTimer.setDescription('The number of milliseconds that the INX-NTS TCP implementation waits between TCP protocol ACK packets. This variable must be set to a multiple of 50. If it is set to some value that is not a multiple of 50, then the value will be rounded down to a multiple of 50. For example, if you specify this variable as 199, it will actually be set to 150.')
riTsPortTable = MibTable((1, 3, 6, 1, 4, 1, 28, 4, 28), )
if mibBuilder.loadTexts: riTsPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortTable.setDescription('A table containing management information for a specific port on the INX-NTS. There are 16 entries in this table, one for each port. You cannot access this variable; it is only a table marker in the MIB.')
riTsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 4, 28, 1), ).setIndexNames((0, "INXNTS-MIB", "riTsPortIndex"))
if mibBuilder.loadTexts: riTsPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortEntry.setDescription("An entry in the Port table (see the previous variable, Port Table, for an explanation of this table). You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the Port Table: Port Index First Session Type Current Session Type Current Number of Sessions Baud Rate for Received Data Baud Rate for Transmitted Data Port Parity Data Bits Sent Modem Control Type Flow Control for Data Received Flow Control for Data Sent RS-232 Ring Indicator Connection Password Telnet Abort Out Character Telnet Interrupt Character Inactivity Timeout Value Time Until Timer Expires Suppress Software Messages Port Function Port State Octets Rec'd Octets Trans XON Character XOFF Character Maximum Allowed Sessions TCP Port Number TCP Port Mode Transparent Mode for the Port Port Echo Setting Domain Name Server IP Addr")
riTsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortIndex.setDescription('A unique value for each port. Because there are 16 ports on the INX-NTS, this variable always returns a value from 1 through 16.')
riTsPortFirstType = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 1))).clone(namedValues=NamedValues(("telnet", 4), ("dummy", 5), ("none", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortFirstType.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortFirstType.setDescription('The protocol used by the first session in the set of sessions for this port. For the INX-NTS, this variable returns telnet(4) for Telnet connections and dummy(5) for all other connections. If there are no sessions for this port, the variable returns none(1).')
riTsPortActiveType = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 1))).clone(namedValues=NamedValues(("telnet", 4), ("dummy", 5), ("none", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortActiveType.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortActiveType.setDescription('The protocol that the currently active session is using to communicate with the other end of the connection. For the INX-NTS, this variable returns telnet(4) for Telnet connections and dummy(5) for all other connections. If there are no sessions for this port, the variable returns none(1).')
riTsPortNumSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortNumSessions.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortNumSessions.setDescription('The current number of sessions that are associated with this port. This number includes sessions for which there is no MIB entry (i.e., any session other than a Telnet session).')
riTsPortBaudIn = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(110, 300, 600, 1200, 2400, 4800, 9600, 19200, 38400))).clone(namedValues=NamedValues(("br-110", 110), ("br-300", 300), ("br-600", 600), ("br-1200", 1200), ("br-2400", 2400), ("br-4800", 4800), ("br-9600", 9600), ("br-19200", 19200), ("br-38400", 38400)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortBaudIn.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortBaudIn.setDescription('The baud rate for data received by the port, in bits per second (bps). If you want the INX-NTS to automatically determine baud rates, you can configure it to do so by setting this variable to 0. If this variable returns 0, automatic baud rate determination is already in effect. If this variable returns a value other than 0, that value is the current baud rate. The default baud rate is 9600. Note: The INX-NTS uses only a single baud rate parameter, which is used in both directions. Therefore, you cannot set this variable and the following one, Baud Rate for Transmitted Data, to different values; the INX-NTS will use whichever value was last received by the management agent as the baud rate.')
riTsPortBaudOut = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(110, 300, 600, 1200, 2400, 4800, 9600, 19200, 38400))).clone(namedValues=NamedValues(("br-110", 110), ("br-300", 300), ("br-600", 600), ("br-1200", 1200), ("br-2400", 2400), ("br-4800", 4800), ("br-9600", 9600), ("br-19200", 19200), ("br-38400", 38400)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortBaudOut.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortBaudOut.setDescription('The baud rate for data transmitted by the port, in bits per second (bps). If you want the INX-NTS to automatically determine baud rates, you can configure it to do so by setting this variable to 0. If this variable returns 0, automatic baud rate determination is already in effect. If this variable returns a value other than 0, that value is the current baud rate. The default baud rate is 9600. Note: The INX-NTS uses only a single baud rate parameter, which is used in both directions. Therefore, you cannot set this variable and the previous one, Baud Rate for Received Data, to different values; the INX-NTS will use whichever value was last received by the management agent as the baud rate.')
riTsPortParity = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortParity.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortParity.setDescription('The parity of the port. Enter a value for parity that matches the parity setting of the device attached to the INX-NTS port. The default is none(1). The parity bit is stripped before the data is sent across the network.')
riTsPortDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortDataBits.setDescription('The number of data bits in each character transmitted between the INX-NTS port and an attached device. Enter a value that matches the setting of the device attached to the port. The default is 8.')
riTsPortModemControl = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("dce", 2), ("dte", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortModemControl.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortModemControl.setDescription('The type of modem control, if any, on this port. This setting determines the use of the modem control RS-232 signals. Enter a value that matches the setting of the attached device. o none(1) means that no modem control signals are in use. This is the default. o dce(2) means that the INX-NTS port will act as a DCE device in monitoring the modem control signals. This is the appropriate setting if you are attaching a DTE device (for example, a terminal) that uses these signals to the INX-NTS port. (Ports are always wired as DCE, regardless of modem settings.) o dte(3) means that the INX-NTS port will act as a DTE (Data Terminal Equipment) device in monitoring the modem control signals. Use this setting when attaching a DCE (Data Communication Equipment) device (such as a modem) to the INX-NTS port. Note: Setting Modem Control to DTE can require the use of a cabling adapter at the device.')
riTsPortFlowControlIn = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("hardware", 3), ("handx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortFlowControlIn.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortFlowControlIn.setDescription('The type of flow control used on the port for received data. o None(1) indicates that no flow control is in use o Xonxoff(2) indicates that software flow control is in use. o Hardware(3) indicates that hardware flow control is in use. (This setting is not valid for use with an NTS-TELCO.) 0 Handx(4) indicates that both hardware and software flow control are in use. (This setting is not valid for use with an NTS-TELCO.)')
riTsPortFlowControlOut = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("hardware", 3), ("handx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortFlowControlOut.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortFlowControlOut.setDescription('The type of flow control used on the port for data being sent. o None(1) indicates that no flow control is in use. o Xonxoff(2) indicates that software flow control is in use. For a terminal attached to an INX-NTS port, this setting allows you to press the XOFF control character (Ctrl-S by default) in order to halt output from the INX-NTS port to the screen, and the XON control character (Ctrl-Q by default) to resume output to the screen. o Hardware(3) indicates that hardware flow control is in use. (This setting not valid for use with an NTS-TELCO.) o Handx(4) indicates that both hardware and software flow control are in use. (This setting not valid for use with an NTS-TELCO.)')
riTsPortRing = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortRing.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortRing.setDescription('The status of the Ring Indicator (RI) RS-232 signal. If you have set modem control (see the Modem Control Type variable) to DCE, you must set Ring to no(1). If you have set modem control to DTE, yes(2) means that the INX-NTS port will use the RI signal; no(1) means the signal will not be used.')
riTsPortPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 18), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortPassword.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortPassword.setDescription('The password needed to connect to the port. The port password can be up to seven characters long.')
riTsPortAbortOut = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortAbortOut.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortAbortOut.setDescription('The ASCII value of the character that invokes a Telnet Abort Output for this port. You use this character to suspend output to the screen for a current process.')
riTsPortIntProc = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortIntProc.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortIntProc.setDescription('The ASCII value of the character that invokes a Telnet Interrupt Process for this port. You use this character to kill a current process on a UNIX machine.')
riTsPortInactiveTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortInactiveTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortInactiveTimeOut.setDescription('The number of minutes a port can be inactive before the INX-NTS closes all existing virtual circuits on that port. The timeout range can be from 1 to 255 minutes. This feature works on all ports except permanent. It is disabled for slave ports configured with network port numbers 7 (echo); 9 (sink); or 19 (source). To disable the inactivity timeout function, set this variable to 0.')
riTsPortInactiveTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortInactiveTimer.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortInactiveTimer.setDescription('Number of minutes left before the inactivity timer (see the previous variable, Inactivity Timeout Value) expires, and all virtual circuits for this port are closed. Setting this variable to 0 temporarily disables the inactivity timer, so virtual circuits are maintained as long as the port remains inactive. When port activity resumes, however, the inactivity timer is reactivated, and this variable is set to the value of Inactivity Timeout Value.')
riTsPortMachineInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortMachineInterface.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortMachineInterface.setDescription('Whether software-generated messages are passed through the port. To suppress the sending of all messages generated by the LAT/TCP software, set this variable to yes(2). To enable the sending of such messages, set it to no(1). Traffic from network connections continues to pass through the port regardless of the setting of this variable.')
riTsPortFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("slave", 1), ("terminal", 2), ("permckt", 3), ("both", 4), ("demandckt", 5), ("queue", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortFunction.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortFunction.setDescription('The ability of the port to initiate and accept connections. o slave(1) indicates that the port can only accept connections. If it is busy, it will reject a connection request. o terminal(2) indicates that this port can only initiate connections. o permckt(3) indicates that this port initiates and automatically maintains connections. o both(4) means this port can both accept and initiate connections. o demandckt(5) indicates the same status as permckt except that you must first press a key on the keyboard to activate the port. o queue(6) means this port accepts and holds connections. It will act like a slave port, except that instead of rejecting a request when it is busy, it stores the request until a resource becomes available.')
riTsPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("disabled", 1), ("active", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortState.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortState.setDescription('The state of the port. o disabled(1) indicates that the port cannot be used o active(3) means the port is enabled, and a device is connected. Setting an active(3) port to the disabled(1) state resets the port. All error conditions are cleared, and connections and sessions are terminated.')
riTsPortOctetsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortOctetsIn.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortOctetsIn.setDescription('Total number of octets received on the port from the network connection(s).')
riTsPortOctetsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortOctetsOut.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortOctetsOut.setDescription('Total number of octets sent onto the network connection(s) by the port.')
riTsPortXONChar = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortXONChar.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortXONChar.setDescription('The ASCII value of the XON character. This setting is meaningful only if XON/XOFF flow control is in use. (See the Flow Control for Data Received and Flow Control for Data Sent variables for more information.)')
riTsPortXOFFChar = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortXOFFChar.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortXOFFChar.setDescription('The ASCII value of the XOFF character. This setting is meaningful only if XON/XOFF flow control is in use. (See the Flow Control for Data Received and Flow Control for Data Sent variables for more information.)')
riTsPortMaxSess = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riTsPortMaxSess.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortMaxSess.setDescription('Maximum number of sessions allowed on this port.')
riTsPortServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortServerPort.setDescription('The TCP port number that this serial port uses when listening for Telnet connections. If this port is not configured to listen for inbound connection requests, this variable returns 65535. The default TCP port number is 23.')
riTsPortTCPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rawsocket", 1), ("nvt7bit", 2), ("nvt8bit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortTCPMode.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortTCPMode.setDescription('The TCP operating mode for the port. o rawsocket(1) means there is no application protocol; data is transferred to and from a TCP socket without interpretation. o nvt7bit(2) is for standard seven-bit NVT mode, in which the Telnet utility transfers 7-bit data. o nvt8bit(3) is for a modified Telnet NVT mode (data is transferred using eight bits per character).')
riTsPortDefXparent = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortDefXparent.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortDefXparent.setDescription('The default mode of the port. When this variable is set to on(1), you make it possible to enable full eight-bit transparency so that you can send binary or image files across the network. To set the port to non-transparent mode, set this variable to off(2).')
riTsPortDefEcho = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 28, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsPortDefEcho.setStatus('mandatory')
if mibBuilder.loadTexts: riTsPortDefEcho.setDescription('The echo setting for the port. This echo setting determines whether echoing and such functions as line editing are done by the remote host or the local host. Remote echoing is the default and the recommended setting for your terminal. Local echoing allows you to connect to hosts that do not support remote echoing.')
riTsDomainServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 4, 29), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riTsDomainServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: riTsDomainServerAddress.setDescription('The Internet address of the host you want to have act as the domain name server.')
tnCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnCount.setStatus('mandatory')
if mibBuilder.loadTexts: tnCount.setDescription('The number of Telnet sessions that have been initiated from the INX-NTS.')
tnTable = MibTable((1, 3, 6, 1, 4, 1, 28, 3, 2), )
if mibBuilder.loadTexts: tnTable.setStatus('mandatory')
if mibBuilder.loadTexts: tnTable.setDescription('A table containing Telnet session-specific information that is appropriate to whatever side of a session the INX-NTS happens to be. There is one entry in the table for each telnet session that is active. You cannot access this variable; it is only a table marker in the MIB.')
tnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 3, 2, 1), ).setIndexNames((0, "INXNTS-MIB", "tnLocalIpAddress"), (0, "INXNTS-MIB", "tnLocalPort"), (0, "INXNTS-MIB", "tnRemoteIpAddress"), (0, "INXNTS-MIB", "tnRemotePort"))
if mibBuilder.loadTexts: tnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tnEntry.setDescription('Information about a particular Telnet session. This variable is an entry in the Telnet Session table. (See the previous variable, Telnet Session Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Telnet Port Identifier Local IP Addr of TCP Cxn Remote IP Addr of TCP Cxn Local Port of TCP Connection Remote Port of TCP Connection UpTime at Session Start Session Options Telnet Session State Telnet User ID Octets Recd Octets Sent Protocol Type of Next Session Name of Next Session')
tnPort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnPort.setStatus('mandatory')
if mibBuilder.loadTexts: tnPort.setDescription('The index value that uniquely identifies the terminal port table entry to which this entry is applicable.')
tnLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tnLocalIpAddress.setDescription('The local IP address of the TCP connection that this Telnet session is using.')
tnRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tnRemoteIpAddress.setDescription('The remote IP address of the TCP connection that this Telnet session is using.')
tnLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: tnLocalPort.setDescription('The local port number of the TCP connection that this Telnet session is using.')
tnRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: tnRemotePort.setDescription('The remote port number of the TCP connection that this Telnet session is using.')
tnUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: tnUpTime.setDescription('The amount of time that has elapsed since the Telnet session was established.')
tnOptionsOn = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnOptionsOn.setStatus('mandatory')
if mibBuilder.loadTexts: tnOptionsOn.setDescription('Indicates which options are on/enabled/in the will/do state. Each octet in the string contains the numerical value of an option that is on. For example, if a session had options 1, 4, 10, 15, and 20 on, then Session Options On would return 5 octets, and the octets would contain the values 1, 4, 10, 15, and 20. The option values in the octet would contain the values 1, 4, 10, 15, and 20. The option values in the octet string can be in any order.')
tnState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("serverActive", 1), ("client", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnState.setStatus('mandatory')
if mibBuilder.loadTexts: tnState.setDescription("The state of the session. o serverActive(1) indicates that the INX-NTS is the Telnet server, and that a session is active-i.e., a user has logged in to this end of the connection. o client(3) indicates that the INX-NTS is the client end of the connection. In a typical Telnet session, this is the user's terminal.")
tnUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnUserId.setStatus('mandatory')
if mibBuilder.loadTexts: tnUserId.setDescription('The identification of the user at the INX-NTS end of the Telnet session. Because user IDs are not implemented in the INX-NTS, this variable always returns a null string.')
tnOctetsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnOctetsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: tnOctetsReceived.setDescription('The number of octets of data received from the other end of the session. Because the INX-NTS does not keep octet counts for Telnet connections, this variable always returns 0.')
tnOctetsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnOctetsSent.setStatus('mandatory')
if mibBuilder.loadTexts: tnOctetsSent.setDescription('The number of octets of data sent to the other end of the session. Because the INX-NTS does not keep octet counts for Telnet connections, this variable always returns 0.')
tnNextType = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnNextType.setStatus('mandatory')
if mibBuilder.loadTexts: tnNextType.setDescription('The protocol used by the next session in the set of sessions currently established on this port. Because the INX-NTS does not keep this information for Telnet connections, this variable always returns 0.')
tnNextName = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnNextName.setStatus('mandatory')
if mibBuilder.loadTexts: tnNextName.setDescription('The entry in the application protocol table identified by Protocol Type of Next Session. Because the INX-NTS does not keep this information, this variable always returns a null value (0.0).')
riInxSlot = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlot.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlot.setDescription('The INTERNExT chassis slot in which the INX-NTS is located')
riInxBus = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("bus-a", 2), ("bus-b", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxBus.setStatus('mandatory')
if mibBuilder.loadTexts: riInxBus.setDescription('The Ethernet bus connected to the INX-NTS in this slot.')
riInxSlotConnectivityType = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlotConnectivityType.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlotConnectivityType.setDescription('The type of connectivity module attached to the INX-NTS in this slot. If this variable returns the object identifier 1.3.6.1.4.1.28.1.3.4.1.1.1, the connectivity module is an NTS-RJ45. If this variable returns the object identifier 1.3.6.1.4.1.28.1.3.4.1.2.1, the connectivity module is an NTS-TELCO.')
riInxSlotConnectivityRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlotConnectivityRev.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlotConnectivityRev.setDescription('The hardware revision level of the connectivity module attached to the INX-NTS in this slot.')
riInxSlotConnectivitySerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlotConnectivitySerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlotConnectivitySerialNumber.setDescription('The serial number of the connectivity module attached to the INX-NTS in this slot.')
riInxSlotConnectivityState = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlotConnectivityState.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlotConnectivityState.setDescription('The state of the connectivity module attached to the INX-NTS in this slot. For the INX-NTS, this variable always returns enabled(2).')
riInxSlotConnectivityBus = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlotConnectivityBus.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlotConnectivityBus.setDescription('The bus connected to the connectivity module in this slot. Because the connectivity module is connected to the INX-NTS logic module, rather than to the internal chassis buses, this variable always returns other(3).')
riInxSlotConnectivityMedia = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxSlotConnectivityMedia.setStatus('mandatory')
if mibBuilder.loadTexts: riInxSlotConnectivityMedia.setDescription('The Ethernet media type setting for the connectivity module in this slot. This information is not relevant to the INX-NTS connectivity module, so this variable always returns other(3).')
riInxChassisType = MibScalar((1, 3, 6, 1, 4, 1, 28, 21, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riInxChassisType.setStatus('mandatory')
if mibBuilder.loadTexts: riInxChassisType.setDescription('The type of chassis (i.e., 3-slot or 12-slot) in which the INX-NTS is located.')
riThCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThCount.setStatus('mandatory')
if mibBuilder.loadTexts: riThCount.setDescription('the number of active entries in the threshold table.')
riThMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: riThMaxCount.setDescription('The maximum number of active thresholds allowed.')
riThUniqueIndex = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThUniqueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riThUniqueIndex.setDescription('Setting this variable creates a new entry in the Threshold table. You must type a number for the entry when you set this variable, but the INX-NTS assigns the actual entry number; that number is the one returned in the response to the set command. If you read this variable, it returns the number of the most recently generated threshold entry. Each threshold entry must have a unique index number, but the number assigned to an entry can be reused after you have deleted it.')
riThInterval = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThInterval.setStatus('mandatory')
if mibBuilder.loadTexts: riThInterval.setDescription('How often, in seconds, thresholds exceeded are checked. To disable threshold checking, set this variable to 0.')
riThTable = MibTable((1, 3, 6, 1, 4, 1, 28, 17, 5), )
if mibBuilder.loadTexts: riThTable.setStatus('mandatory')
if mibBuilder.loadTexts: riThTable.setDescription('A table containing information about the thresholds that have been set. You cannot access this variable; it is only a table marker in the MIB.')
riThEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 17, 5, 1), ).setIndexNames((0, "INXNTS-MIB", "riThIndex"))
if mibBuilder.loadTexts: riThEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riThEntry.setDescription('An entry in the Threshold table. (See the previous variable, Threshold Table, for an explanation of this table). You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Threshold Table Index Threshold Status Threshold Object ID Threshold Value Threshold Hysteresis Direction of Approach to Thresh Threshold Trigger Count Threshold Community Name Threshold Eth Addr Destination Threshold IP Addr Destination')
riThIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riThIndex.setDescription('A unique value for each threshold.')
riThStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("unset", 2), ("armed", 3), ("safety", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riThStatus.setDescription('The current status of the threshold. o delete(1) deletes the threshold entry specified. o unset(2) means that the threshold is newly created, currently being configured, or disabled. o armed(3) means that the threshold is active and generates a trap PDU when it is triggered. o safety(4) means that the threshold is active, but does not generate trap PDUs.')
riThObject = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThObject.setStatus('mandatory')
if mibBuilder.loadTexts: riThObject.setDescription('The complete object identifier of the variable on which this threshold is set. Threshold Object ID can be set only for Counter or Gauge variables. If you attempt to set a threshold for a variable of any other type, you receive a badValue error.')
riThThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: riThThreshold.setDescription('The threshold value for the variable identified by Threshold Object ID. If this particular variable is a gauge, then whenever its value rises above or drops below (depending on the setting of the Direction of Approach to Thresh variable) the value of Threshold Value, the threshold is considered to have been triggered. If this particular variable is a counter, then whenever its value increments by the value of Threshold Value, the threshold is considered to have been triggered.')
riThHysteresis = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThHysteresis.setStatus('mandatory')
if mibBuilder.loadTexts: riThHysteresis.setDescription("The hysteresis value for the threshold. After a variable's threshold is triggered, the value of the variable must either drop below or rise above a certain value (depending on the setting of the Direction of Approach to Thresh variable), the hysteresis, before another trigger can be recognized. For example, if you set the threshold for module temperature to 80, the threshold is triggered the first time the temperature rises above 80. If you also set the hysteresis for this threshold to 60, the threshold will only be triggered again if the temperature drops below 60, and then rises past 80. If the temperature drops from 80 to 70, and then goes back to 80, the threshold is not triggered. If the hysteresis value is less than the threshold value, the variable's value must drop below the hysteresis before another trigger is recognized. If the hysteresis value is greater than the threshold value, the variable's value must rise above the hysteresis before another trigger is recognized. The value of the hysteresis depends on the value of the threshold and whether the value of the variable is rising or falling; therefore, set this variable in conjunction with both the Threshold Value and Direction of Approach to Thresh variables. This variable is relevant only to thresholds set on Gauge variables.")
riThDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThDirection.setStatus('mandatory')
if mibBuilder.loadTexts: riThDirection.setDescription("The direction in which a change in a Gauge variable's value causes a threshold to trigger. If its direction is up, a trigger occurs when the variable's value rises above the threshold value. In this case, the hysteresis must be less than or equal to the threshold value. If its direction is down, a trigger occurs when the variable's value falls below the threshold value. In this case, the hysteresis must be greater than or equal to the threshold value. This variable is relevant only to thresholds set on Gauge variables.")
riThTriggeredCount = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThTriggeredCount.setStatus('mandatory')
if mibBuilder.loadTexts: riThTriggeredCount.setDescription('The number of times that this threshold has been triggered.')
riThCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: riThCommunity.setDescription('The community name to place in the authentication header of the trap PDU. This variable specifies the community to which the trap is to be sent when a threshold is triggered.')
riThPhysDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThPhysDestination.setStatus('mandatory')
if mibBuilder.loadTexts: riThPhysDestination.setDescription('The Ethernet address of the node to which the trap is to be sent when the threshold is triggered.')
riThIPDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThIPDestination.setStatus('mandatory')
if mibBuilder.loadTexts: riThIPDestination.setDescription('The IP address of the node to which the trap is to be sent when the threshold is triggered.')
riRateTxSingleCollisionFrames = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxSingleCollisionFrames.setDescription('The rate of frames that were successfully transmitted after experiencing one and only one collision. This variable corresponds to the Single Collisions Transmitted variable in the dot3 group.')
riRateTxMultipleCollisionFrames = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxMultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxMultipleCollisionFrames.setDescription('The rate of frames that were successfully transmitted after experiencing more than one collision. This variable corresponds to the Multiple Collisions Xmitted variable in the dot3 group.')
riRateTxDeferredTransmissions = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxDeferredTransmissions.setDescription('The rate of times the INX-NTS deferred transmission of data because it sensed traffic on the network. Because the INX-NTS does not record deferrals, this variable always returns 0. This variable corresponds to the Transmissions Deferred variable in the dot3 group.')
riRateTxLateCollisions = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxLateCollisions.setDescription('The rate of times that a collision has been detected on this bus later than 512 bit times from frame start. This count is not maintained by the INX-NTS, so this variable always returns 0. This variable corresponds to the Late Collisions Detected variable in the dot3 group.')
riRateTxInternalMACTransmitErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxInternalMACTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxInternalMACTransmitErrors.setDescription('The rate of frames the interface could not transmit because of an internal MAC sublayer transmit error. This variable corresponds to the MAC Transmit Errors variable in the dot3 group.')
riRateTxCarrierSenseErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxCarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxCarrierSenseErrors.setDescription('The rate of times that the carrier-sense condition was lost or never asserted when the INX-NTS attempted to transmit a frame on the interface. This variable corresponds to the Carrier Sense Errors variable in the dot3 group.')
riRateTxExcessiveDeferrals = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxExcessiveDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxExcessiveDeferrals.setDescription('The rate of frames the INX-NTS deferred transmitting for an excessive period of time. Because the INX-NTS interface does not record deferrals, this variable always returns 0. This variable corresponds to the Deferred Frames variable in the dot3 group.')
riRateRxInternalMACReceiveErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxInternalMACReceiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxInternalMACReceiveErrors.setDescription('The rate of frames the interface could not receive because of an internal MAC sublayer receive error. This variable corresponds to the MAC Errors Received variable in the dot3 group.')
riRateRxFCSErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxFCSErrors.setDescription('The rate of frames received on the interface that are an integral number of octets in length (i.e., the number of bits they contain is a multiple of eight) that do not pass the FCS check, indicating that the frames were corrupted during transmission. This variable corresponds to the FCS Errored Frames Received variable in the dot3 group.')
riRateRxAlignmentErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxAlignmentErrors.setDescription('The rate of frames received on the interface that are not an integral number of octets in length (i.e., the number of bits they contain is not a multiple of eight) and do not pass the FCS check. This indicates that the frames were corrupted during transmission. This variable corresponds to the Nonaligned Frames Recd variable in the dot3 group.')
riRateRxInRangeLengthErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxInRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxInRangeLengthErrors.setDescription('The rate of in-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error. The INX-NTS receives Ethernet frames that do not have a length field. It therefore cannot detect this error, and this variable always returns 0. This variable corresponds to the In-Range Length Errors Recd variable in the dot3 group.')
riRateRxOutofRangeLengthFields = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxOutofRangeLengthFields.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxOutofRangeLengthFields.setDescription('The rate of out-of-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside 802.3 parameters, the receiving device returns an out-of-range error. The INX-NTS receives Ethernet frames that do not have a length field. It therefore cannot detect this error, and this variable always returns 0. This variable corresponds to the Out-Range Length Errors Recd variable in the dot3 group.')
riRateRxFrameTooLongs = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxFrameTooLongs.setDescription('The rate of frames received on the interface that exceed the maximum permitted frame size, i.e., 1012 octets. This variable corresponds to the Too Long Frames Recd variable in the dot3 group.')
mibBuilder.exportSymbols("INXNTS-MIB", riSystemRateInterval=riSystemRateInterval, dot3XTxCarrierSenseErrors=dot3XTxCarrierSenseErrors, tnRemotePort=tnRemotePort, riInxSlotConnectivityRev=riInxSlotConnectivityRev, dot3XRxLastSourceAddress=dot3XRxLastSourceAddress, tnPort=tnPort, riSystemHardwareRev=riSystemHardwareRev, riRateRxAlignmentErrors=riRateRxAlignmentErrors, dot3XTxLateCollisions=dot3XTxLateCollisions, dot3MACSubLayerStatus=dot3MACSubLayerStatus, dot3InitializeMAC=dot3InitializeMAC, internet=internet, dot3MulticastReceiveEnabled=dot3MulticastReceiveEnabled, riBootGateway=riBootGateway, riTsPortIndex=riTsPortIndex, riTsPortBaudIn=riTsPortBaudIn, dot3XRxOutOfRangeLengthFields=dot3XRxOutOfRangeLengthFields, riInxBus=riInxBus, riBootIndex=riBootIndex, riTsPortTCPMode=riTsPortTCPMode, dot3XTxIndex=dot3XTxIndex, dot3TxSQETestErrors=dot3TxSQETestErrors, dot3XTxDeferredTransmissions=dot3XTxDeferredTransmissions, riTsPortOctetsOut=riTsPortOctetsOut, dot3XRxTable=dot3XRxTable, riThresh=riThresh, dot3XTxTDR=dot3XTxTDR, riTsPortFlowControlOut=riTsPortFlowControlOut, enterprises=enterprises, dot3XTxEntry=dot3XTxEntry, dot3TxMultipleCollisionFrames=dot3TxMultipleCollisionFrames, riSystemNVRamWriteCount=riSystemNVRamWriteCount, riBootServiceOffered=riBootServiceOffered, riTsPortPassword=riTsPortPassword, riTsPortCount=riTsPortCount, dot3CollFrequency=dot3CollFrequency, riTsReadBufferSize=riTsReadBufferSize, riTsPortEntry=riTsPortEntry, dot3TxSingleCollisionFrames=dot3TxSingleCollisionFrames, riTsSignOn=riTsSignOn, riRateTxSingleCollisionFrames=riRateTxSingleCollisionFrames, dot3XTxInternalMACTransmitErrors=dot3XTxInternalMACTransmitErrors, tnRemoteIpAddress=tnRemoteIpAddress, riInxChassisType=riInxChassisType, riRateTxCarrierSenseErrors=riRateTxCarrierSenseErrors, riThEntry=riThEntry, riTsPrompt=riTsPrompt, riThIndex=riThIndex, experimental=experimental, riThPhysDestination=riThPhysDestination, riThStatus=riThStatus, dot3Entry=dot3Entry, dot3CollEntry=dot3CollEntry, riRateRxInRangeLengthErrors=riRateRxInRangeLengthErrors, tnTable=tnTable, riTsPortAbortOut=riTsPortAbortOut, tnOctetsReceived=tnOctetsReceived, dot3CollCount=dot3CollCount, dot3XRxAutoPartitionStatus=dot3XRxAutoPartitionStatus, riRateTxMultipleCollisionFrames=riRateTxMultipleCollisionFrames, riInxSlotConnectivitySerialNumber=riInxSlotConnectivitySerialNumber, tnUpTime=tnUpTime, riTsUpTimeNodeName=riTsUpTimeNodeName, riInxSlot=riInxSlot, riThIPDestination=riThIPDestination, riThMaxCount=riThMaxCount, tnUserId=tnUserId, riTsPortFlowControlIn=riTsPortFlowControlIn, dot3TxIndex=dot3TxIndex, riTsPortIntProc=riTsPortIntProc, dot3Table=dot3Table, riBootVersion=riBootVersion, riProdNts=riProdNts, riTsPortMaxSess=riTsPortMaxSess, riTsPortXONChar=riTsPortXONChar, riTsTcpMaxSeg=riTsTcpMaxSeg, riTsPortDefXparent=riTsPortDefXparent, riTsPortParity=riTsPortParity, riTsPortInactiveTimer=riTsPortInactiveTimer, riTsFarMemoryFree=riTsFarMemoryFree, riSystemSerialNumber=riSystemSerialNumber, riBootEntry=riBootEntry, dot3AlignmentErrors=dot3AlignmentErrors, riTsPortNumSessions=riTsPortNumSessions, dot3XRxInRangeLengthErrors=dot3XRxInRangeLengthErrors, riInxSlotConnectivityMedia=riInxSlotConnectivityMedia, dot3XRxEntry=dot3XRxEntry, riInxSlotConnectivityBus=riInxSlotConnectivityBus, dot3XTxEnabled=dot3XTxEnabled, riTsPortState=riTsPortState, riThThreshold=riThThreshold, tnNextType=tnNextType, riThTriggeredCount=riThTriggeredCount, riTsBreakChar=riTsBreakChar, interlan=interlan, riSystemTicksPerSecond=riSystemTicksPerSecond, tnEntry=tnEntry, riRateRxFrameTooLongs=riRateRxFrameTooLongs, riTsPortServerPort=riTsPortServerPort, dot3XTxExcessiveCollisions=dot3XTxExcessiveCollisions, riTsPortInactiveTimeOut=riTsPortInactiveTimeOut, riTsPortDataBits=riTsPortDataBits, riTsPortModemControl=riTsPortModemControl, tnLocalIpAddress=tnLocalIpAddress, riBootFileName=riBootFileName, riTsPortBaudOut=riTsPortBaudOut, riTsPortFunction=riTsPortFunction, dot3FCSErrors=dot3FCSErrors, riTs=riTs, riSystemFirmwareRev=riSystemFirmwareRev, riProdLdc=riProdLdc, private=private, riTelnet=riTelnet, tnLocalPort=tnLocalPort, riTsWriteBufferSize=riTsWriteBufferSize, riTsTcpAckTimer=riTsTcpAckTimer, riRateTxInternalMACTransmitErrors=riRateTxInternalMACTransmitErrors, riRateTxDeferredTransmissions=riRateTxDeferredTransmissions, dot3XRxFrameTooLongs=dot3XRxFrameTooLongs, riInxSlotConnectivityType=riInxSlotConnectivityType, riTsPortFirstType=riTsPortFirstType, riThCommunity=riThCommunity, riBootTable=riBootTable, tnOptionsOn=tnOptionsOn, riTsFarMemoryLowest=riTsFarMemoryLowest, riLdcNts=riLdcNts, dot3XRxIndex=dot3XRxIndex, riTsPortActiveType=riTsPortActiveType, riTsTcpWindowSize=riTsTcpWindowSize, riTsNumBuffers=riTsNumBuffers, dot3XTxTable=dot3XTxTable, riRateTxLateCollisions=riRateTxLateCollisions, riRateRxFCSErrors=riRateRxFCSErrors, riThDirection=riThDirection, riTsPortTable=riTsPortTable, riRateRxOutofRangeLengthFields=riRateRxOutofRangeLengthFields, tnCount=tnCount, riBoot=riBoot, riSystem=riSystem, riThUniqueIndex=riThUniqueIndex, riTsPortXOFFChar=riTsPortXOFFChar, riTsPortDefEcho=riTsPortDefEcho, riInternext=riInternext, riTsRates=riTsRates, riTsDomainName=riTsDomainName, riThInterval=riThInterval, dot3XRxInternalMACReceiveErrors=dot3XRxInternalMACReceiveErrors, riInxSlotConnectivityState=riInxSlotConnectivityState, dot3CollTable=dot3CollTable, dot3XRxSourceAddressLog=dot3XRxSourceAddressLog, tnOctetsSent=tnOctetsSent, tnNextName=tnNextName, riRateTxExcessiveDeferrals=riRateTxExcessiveDeferrals, riRateRxInternalMACReceiveErrors=riRateRxInternalMACReceiveErrors, tnState=tnState, riTsPortRing=riTsPortRing, riThObject=riThObject, riNumBoots=riNumBoots, riSystemReset=riSystemReset, dot3XRxAutoPartitionLog=dot3XRxAutoPartitionLog, riThHysteresis=riThHysteresis, dot3TxEntry=dot3TxEntry, dot3Index=dot3Index, riThTable=riThTable, riTsDomainServerAddress=riTsDomainServerAddress, riTsAdminPW=riTsAdminPW, riTsPortOctetsIn=riTsPortOctetsIn, dot3XTxExcessiveDeferrals=dot3XTxExcessiveDeferrals, dot3=dot3, dot3CollIndex=dot3CollIndex, riBootIPAddress=riBootIPAddress, riThCount=riThCount, riProducts=riProducts, dot3TxTable=dot3TxTable, riTsPortMachineInterface=riTsPortMachineInterface, riSystemSoftwareRev=riSystemSoftwareRev)

#
# PySNMP MIB module FIBRONICS-PROPRIETARY-FX8210-B-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/FIBRONICS-PROPRIETARY-FX8210-B-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:13:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Gauge32, TimeTicks, ModuleIdentity, ObjectIdentity, Counter64, IpAddress, iso, Integer32, NotificationType, enterprises, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Gauge32", "TimeTicks", "ModuleIdentity", "ObjectIdentity", "Counter64", "IpAddress", "iso", "Integer32", "NotificationType", "enterprises", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
spartacus = MibIdentifier((1, 3, 6, 1, 4, 1, 22))
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2))
trap = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3))
dec2 = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 4))
propSys = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 5))
propIp = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 6))
propFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 7))
decrun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1))
decperm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 2))
traprun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3, 1))
traperm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 3, 2))
dec2run = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 4, 1))
dec2perm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 4, 2))
propSysRun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 5, 1))
propSysPerm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 5, 2))
propIpRun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 6, 1))
propIpPerm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 6, 2))
rcircs = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1, 1))
rnodes = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1, 2))
rareas = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1, 3))
pcircs = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 2, 1))
pnodes = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 2, 2))
pnRtParms = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1))
rIpRipStats = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 6, 1, 15))
rIpArpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 6, 1, 16))
rIpPArp = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 6, 1, 17))
rnNmParms = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 1))
rnRtParms = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2))
rnRtCount = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3))
rCircNum = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rCircNum.setStatus('mandatory')
if mibBuilder.loadTexts: rCircNum.setDescription('')
rccTable = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2), )
if mibBuilder.loadTexts: rccTable.setStatus('mandatory')
if mibBuilder.loadTexts: rccTable.setDescription('')
rccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rccIndex"))
if mibBuilder.loadTexts: rccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rccEntry.setDescription('')
rccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rccIndex.setDescription('')
rccState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rccState.setStatus('mandatory')
if mibBuilder.loadTexts: rccState.setDescription('')
rccType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rccType.setStatus('mandatory')
if mibBuilder.loadTexts: rccType.setDescription('')
rccCost = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rccCost.setStatus('mandatory')
if mibBuilder.loadTexts: rccCost.setDescription('')
rccBSize = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rccBSize.setStatus('mandatory')
if mibBuilder.loadTexts: rccBSize.setDescription('')
rccHTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rccHTimer.setStatus('mandatory')
if mibBuilder.loadTexts: rccHTimer.setDescription('')
rccLine = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rccLine.setStatus('mandatory')
if mibBuilder.loadTexts: rccLine.setDescription('')
rbcTable = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 3), )
if mibBuilder.loadTexts: rbcTable.setStatus('mandatory')
if mibBuilder.loadTexts: rbcTable.setDescription('')
pysmiFakeCol1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 3, 1) + (1000, ), Integer32())
rbcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 3, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1000"))
if mibBuilder.loadTexts: rbcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rbcEntry.setDescription('The INDEX value specified should correspond to the index of the circuit of the desired entry.')
rbcDrout = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbcDrout.setStatus('mandatory')
if mibBuilder.loadTexts: rbcDrout.setDescription('')
rbcMrout = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbcMrout.setStatus('mandatory')
if mibBuilder.loadTexts: rbcMrout.setDescription('')
rbcRpri = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rbcRpri.setStatus('mandatory')
if mibBuilder.loadTexts: rbcRpri.setDescription('')
rCCntrs = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4), )
if mibBuilder.loadTexts: rCCntrs.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntrs.setDescription('')
pysmiFakeCol1001 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1) + (1001, ), Integer32())
rCCntrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1001"))
if mibBuilder.loadTexts: rCCntrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntrEntry.setDescription('The INDEX value specified should correspond to the index of the circuit of the desired entry.')
rCCntTePktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rCCntTePktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntTePktsIn.setDescription('')
rCCntOPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rCCntOPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntOPktsOut.setDescription('')
rCCntTrPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rCCntTrPktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntTrPktsIn.setDescription('')
rCCntTrPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rCCntTrPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntTrPktsOut.setDescription('')
rCCntAdjDown = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rCCntAdjDown.setStatus('mandatory')
if mibBuilder.loadTexts: rCCntAdjDown.setDescription('')
rnNmId = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnNmId.setStatus('mandatory')
if mibBuilder.loadTexts: rnNmId.setDescription('')
rnNmPaddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnNmPaddr.setStatus('mandatory')
if mibBuilder.loadTexts: rnNmPaddr.setDescription('')
rnRpAMaxC = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpAMaxC.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpAMaxC.setDescription('')
rnRpAMaxH = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpAMaxH.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpAMaxH.setDescription('')
rnRpBRtTmr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpBRtTmr.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpBRtTmr.setDescription('')
rnRpBSize = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpBSize.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpBSize.setDescription('')
rnRpMAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMAddr.setDescription('')
rnRpMArea = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMArea.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMArea.setDescription('')
rnRpMaxBNR = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMaxBNR.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMaxBNR.setDescription('')
rnRpMaxBR = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMaxBR.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMaxBR.setDescription('')
rnRpMaxCir = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRpMaxCir.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMaxCir.setDescription('')
rnRpMaxCost = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMaxCost.setDescription('')
rnRpMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMaxHops.setDescription('')
rnRpMaxV = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpMaxV.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpMaxV.setDescription('')
rnRpVers = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRpVers.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpVers.setDescription('')
rnRpSegBuf = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRpSegBuf.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpSegBuf.setDescription('')
rnRpType = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpType.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpType.setDescription('')
rnRpAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpAddr.setDescription('')
rnRpUseL2A = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 2, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rnRpUseL2A.setStatus('mandatory')
if mibBuilder.loadTexts: rnRpUseL2A.setDescription('')
rnRcAgedPkt = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRcAgedPkt.setStatus('mandatory')
if mibBuilder.loadTexts: rnRcAgedPkt.setDescription('')
rnRcUnReach = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRcUnReach.setStatus('mandatory')
if mibBuilder.loadTexts: rnRcUnReach.setDescription('')
rnRcBadRange = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRcBadRange.setStatus('mandatory')
if mibBuilder.loadTexts: rnRcBadRange.setDescription('')
rnRcOversize = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRcOversize.setStatus('mandatory')
if mibBuilder.loadTexts: rnRcOversize.setDescription('')
rnRcFormErr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRcFormErr.setStatus('mandatory')
if mibBuilder.loadTexts: rnRcFormErr.setDescription('')
rnRcRtUpLoss = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnRcRtUpLoss.setStatus('mandatory')
if mibBuilder.loadTexts: rnRcRtUpLoss.setDescription('')
rnAdjTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4), )
if mibBuilder.loadTexts: rnAdjTbl.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjTbl.setDescription('')
rnAdjEnt = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rnAdjAddr"))
if mibBuilder.loadTexts: rnAdjEnt.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjEnt.setDescription('')
rnAdjAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjAddr.setDescription('')
rnAdjState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjState.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjState.setDescription('')
rnAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjType.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjType.setDescription('')
rnAdjCIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjCIdx.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjCIdx.setDescription('')
rnAdjBSize = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjBSize.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjBSize.setDescription('')
rnAdjLTmr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjLTmr.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjLTmr.setDescription('')
rnAdjPri = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnAdjPri.setStatus('mandatory')
if mibBuilder.loadTexts: rnAdjPri.setDescription('')
rnLvl1Tbl = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5), )
if mibBuilder.loadTexts: rnLvl1Tbl.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Tbl.setDescription('')
rnLvl1Ent = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rnLvl1Addr"))
if mibBuilder.loadTexts: rnLvl1Ent.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Ent.setDescription('')
rnLvl1Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnLvl1Addr.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Addr.setDescription('')
rnLvl1Cidx = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnLvl1Cidx.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Cidx.setDescription('')
rnLvl1Cost = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnLvl1Cost.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Cost.setDescription('')
rnLvl1Hops = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnLvl1Hops.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Hops.setDescription('')
rnLvl1Next = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 2, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rnLvl1Next.setStatus('mandatory')
if mibBuilder.loadTexts: rnLvl1Next.setDescription('')
raParmTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1), )
if mibBuilder.loadTexts: raParmTbl.setStatus('mandatory')
if mibBuilder.loadTexts: raParmTbl.setDescription('')
raParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "raNum"))
if mibBuilder.loadTexts: raParmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: raParmEntry.setDescription('')
raNum = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: raNum.setStatus('mandatory')
if mibBuilder.loadTexts: raNum.setDescription('')
raCIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: raCIdx.setStatus('mandatory')
if mibBuilder.loadTexts: raCIdx.setDescription('')
raCost = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: raCost.setStatus('mandatory')
if mibBuilder.loadTexts: raCost.setDescription('')
raHops = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: raHops.setStatus('mandatory')
if mibBuilder.loadTexts: raHops.setDescription('')
raNext = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 1, 3, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: raNext.setStatus('mandatory')
if mibBuilder.loadTexts: raNext.setDescription('')
pccTable = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 1), )
if mibBuilder.loadTexts: pccTable.setStatus('mandatory')
if mibBuilder.loadTexts: pccTable.setDescription('')
pccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pccIndex"))
if mibBuilder.loadTexts: pccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pccEntry.setDescription('')
pccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pccIndex.setDescription('')
pccState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pccState.setStatus('mandatory')
if mibBuilder.loadTexts: pccState.setDescription('')
pccCost = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pccCost.setStatus('mandatory')
if mibBuilder.loadTexts: pccCost.setDescription('')
pccHTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pccHTimer.setStatus('mandatory')
if mibBuilder.loadTexts: pccHTimer.setDescription('')
pbcTable = MibTable((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 2), )
if mibBuilder.loadTexts: pbcTable.setStatus('mandatory')
if mibBuilder.loadTexts: pbcTable.setDescription('')
pysmiFakeCol1002 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 2, 1) + (1002, ), Integer32())
pbcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 2, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1002"))
if mibBuilder.loadTexts: pbcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pbcEntry.setDescription('The INDEX value specified should correspond to the index of the circuit of the desired entry.')
pbcMrout = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pbcMrout.setStatus('mandatory')
if mibBuilder.loadTexts: pbcMrout.setDescription('')
pbcRpri = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 2, 2, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pbcRpri.setStatus('mandatory')
if mibBuilder.loadTexts: pbcRpri.setDescription('')
pnRpAMaxC = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpAMaxC.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpAMaxC.setDescription('')
pnRpAMaxH = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpAMaxH.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpAMaxH.setDescription('')
pnRpBRtTmr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpBRtTmr.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpBRtTmr.setDescription('')
pnRpBSize = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpBSize.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpBSize.setDescription('')
pnRpMAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMAddr.setDescription('')
pnRpMArea = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMArea.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMArea.setDescription('')
pnRpMaxBNR = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMaxBNR.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMaxBNR.setDescription('')
pnRpMaxBR = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMaxBR.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMaxBR.setDescription('')
pnRpMaxCost = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMaxCost.setDescription('')
pnRpMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMaxHops.setDescription('')
pnRpMaxV = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpMaxV.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpMaxV.setDescription('')
pnRpType = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpType.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpType.setDescription('')
pnRpAddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 13), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpAddr.setDescription('')
pnRpUseL2A = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpUseL2A.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpUseL2A.setDescription('')
pnRpRstDaddr = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 2, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnRpRstDaddr.setStatus('mandatory')
if mibBuilder.loadTexts: pnRpRstDaddr.setDescription('')
pDecDefaults = MibScalar((1, 3, 6, 1, 4, 1, 22, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset-defaults", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pDecDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: pDecDefaults.setDescription('When this object is set to 1, the side effect will be to cause the unit to reset all the objects defined under the subtree decperm to their default values. Reading this object has no meaning. The integer value 1 will be returned to a get or get-next request.')
rTrapAddrTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 3, 1, 1), )
if mibBuilder.loadTexts: rTrapAddrTbl.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrTbl.setDescription('This table contains runtime information about destinations to which traps should be directed. Setting the rTrapAddrState to INACTIVE removes an entry from the table.')
rTrapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rTrapAddrAddr"))
if mibBuilder.loadTexts: rTrapAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrEntry.setDescription('This object contains runtime information about an individual trap destination.')
rTrapAddrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrAddr.setDescription('The IP address of the network management entity to which traps (of the type specified in this table entry) should be sent.')
rTrapAddrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrComm.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrComm.setDescription('Community string to be used in SNMP message generated to the receiving SNMP protocol entity.')
rTrapAddrVer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrVer.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrVer.setDescription('The trap address table version number. The current (and only valid) version number is 1.')
rTrapAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrType.setDescription('A bit-encoded string, 1 byte in length, which contains information about which trap(s) should be directed to the management entity described by this table entry. The following list identifies the trap types and corresponding bit values. TRAP-STANDARD-MIB 1000 0000 TRAP-DIAG 0100 0000 TRAP-GNRL-PROPRIETARY 0010 0000 TRAP-ROUT 0001 0000 TRAP-DEBUG 0000 1000 TRAP-PROP-DEC4 0000 0100')
rTrapAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrapAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: rTrapAddrState.setDescription('The state of this entry in the trap address table. Setting this object to INACTIVE removes the corresponding entry from the table.')
pTrapAddrTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 3, 2, 1), )
if mibBuilder.loadTexts: pTrapAddrTbl.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrTbl.setDescription('This table contains permanent information about destinations to which traps should be directed. Setting the pTrapAddrState to INACTIVE removes an entry from the table. This information is used to initialize the rTrapAddrTbl on unit startup.')
pTrapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pTrapAddrAddr"))
if mibBuilder.loadTexts: pTrapAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrEntry.setDescription('This object contains permanent information about an individual trap destination.')
pTrapAddrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrAddr.setDescription('The IP address of the network management entity to which traps (of the type specified in this table entry) should be sent.')
pTrapAddrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrComm.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrComm.setDescription('Community string to be used in SNMP message generated to the receiving SNMP protocol entity.')
pTrapAddrVer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrVer.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrVer.setDescription('The trap address table version number. The current (and only valid) version number is 1.')
pTrapAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrType.setDescription('A bit-encoded string, 1 byte in length, which contains information about which trap(s) should be directed to the management entity described by this table entry. The following list identifies the trap types and corresponding bit values. TRAP-STANDARD-MIB 1000 0000 TRAP-DIAG 0100 0000 TRAP-GNRL-PROPRIETARY 0010 0000 TRAP-ROUT 0001 0000 TRAP-DEBUG 0000 1000 TRAP-PROP-DEC4 0000 0100')
pTrapAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapAddrState.setDescription('The state of this entry in the trap address table. Setting this object to INACTIVE removes the corresponding entry from the table.')
pTrapDefaults = MibScalar((1, 3, 6, 1, 4, 1, 22, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset-defautls", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pTrapDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: pTrapDefaults.setDescription('When this object is set to 1, the side effect will be to cause the unit to reset all the objects defined under the subtree traperm to their default values. Reading this object has no meaning. The integer value 1 will be returned to a get or get-next request.')
rClParmTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 4, 1, 1), )
if mibBuilder.loadTexts: rClParmTbl.setStatus('mandatory')
if mibBuilder.loadTexts: rClParmTbl.setDescription('')
pysmiFakeCol1003 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 1, 1) + (1003, ), Integer32())
rClParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 4, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1003"))
if mibBuilder.loadTexts: rClParmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rClParmEntry.setDescription('The INDEX value specified should correspond to the index of the interface of the desired entry.')
rClState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rClState.setStatus('mandatory')
if mibBuilder.loadTexts: rClState.setDescription('')
rClSubSt = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rClSubSt.setStatus('mandatory')
if mibBuilder.loadTexts: rClSubSt.setDescription('')
rBlParmTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 4, 1, 2), )
if mibBuilder.loadTexts: rBlParmTbl.setStatus('mandatory')
if mibBuilder.loadTexts: rBlParmTbl.setDescription('')
pysmiFakeCol1004 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 2, 1) + (1004, ), Integer32())
rBlParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 4, 1, 2, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1004"))
if mibBuilder.loadTexts: rBlParmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rBlParmEntry.setDescription('The INDEX value specified should correspond to the index of the interface of the desired entry.')
rBlHAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rBlHAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rBlHAddr.setDescription('')
rElCountTbl = MibTable((1, 3, 6, 1, 4, 1, 22, 4, 1, 3), )
if mibBuilder.loadTexts: rElCountTbl.setStatus('mandatory')
if mibBuilder.loadTexts: rElCountTbl.setDescription('')
pysmiFakeCol1005 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1) + (1005, ), Integer32())
rElCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1005"))
if mibBuilder.loadTexts: rElCountEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rElCountEntry.setDescription('The INDEX value specified should correspond to the index of the interface of the desired entry.')
rElFrIn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElFrIn.setStatus('mandatory')
if mibBuilder.loadTexts: rElFrIn.setDescription('')
rElFrOut = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElFrOut.setStatus('mandatory')
if mibBuilder.loadTexts: rElFrOut.setDescription('')
rElBcBIn = MibScalar((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElBcBIn.setStatus('mandatory')
if mibBuilder.loadTexts: rElBcBIn.setDescription('')
rElBcFIn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElBcFIn.setStatus('mandatory')
if mibBuilder.loadTexts: rElBcFIn.setDescription('')
rElMcBIn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElMcBIn.setStatus('mandatory')
if mibBuilder.loadTexts: rElMcBIn.setDescription('')
rElMcFIn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElMcFIn.setStatus('mandatory')
if mibBuilder.loadTexts: rElMcFIn.setDescription('')
rElFDef = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElFDef.setStatus('mandatory')
if mibBuilder.loadTexts: rElFDef.setDescription('')
rElF1Col = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElF1Col.setStatus('mandatory')
if mibBuilder.loadTexts: rElF1Col.setDescription('')
rElFMCol = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElFMCol.setStatus('mandatory')
if mibBuilder.loadTexts: rElFMCol.setDescription('')
rElOutF = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElOutF.setStatus('mandatory')
if mibBuilder.loadTexts: rElOutF.setDescription('')
rElCDetF = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElCDetF.setStatus('mandatory')
if mibBuilder.loadTexts: rElCDetF.setDescription('')
rElInF = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElInF.setStatus('mandatory')
if mibBuilder.loadTexts: rElInF.setDescription('')
rElBadD = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElBadD.setStatus('mandatory')
if mibBuilder.loadTexts: rElBadD.setDescription('')
rElOvRun = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElOvRun.setStatus('mandatory')
if mibBuilder.loadTexts: rElOvRun.setDescription('')
rElNoBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 4, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rElNoBuf.setStatus('mandatory')
if mibBuilder.loadTexts: rElNoBuf.setDescription('')
rTod = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTod.setStatus('mandatory')
if mibBuilder.loadTexts: rTod.setDescription('This is a 15 byte string containing the Greenwich Mean Time formatted as: YYMMDDHHMMSSUUU, where: YY = year DD = day HH = hours MM = minutes SS = seconds UUU = microseconds')
rFddiIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFddiIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rFddiIfIndex.setDescription('The snmp Fddi interface Number')
rPingTable = MibTable((1, 3, 6, 1, 4, 1, 22, 5, 1, 3), )
if mibBuilder.loadTexts: rPingTable.setStatus('mandatory')
if mibBuilder.loadTexts: rPingTable.setDescription('A table of requests for ping via ICMP echo. No modification of existing table entries is allowed, only addition of new entries.')
rPingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 5, 1, 3, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rPProto"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rPDest"))
if mibBuilder.loadTexts: rPingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rPingEntry.setDescription('The list of parameters required to perform a ping request')
rPProto = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("icmp-echo", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rPProto.setStatus('mandatory')
if mibBuilder.loadTexts: rPProto.setDescription('The protocol to be used for the ping request. Future versions will also support Loopback Mirror and Decnet Circuit Loopback.')
rPDest = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rPDest.setStatus('mandatory')
if mibBuilder.loadTexts: rPDest.setDescription('The network address of the node to ping.')
rPTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rPTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rPTimeOut.setDescription('Timeout in seconds to allow for the remote node to respond.')
rPReply = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alive", 1), ("no-response", 2), ("in-process", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rPReply.setStatus('mandatory')
if mibBuilder.loadTexts: rPReply.setDescription('Reply to ICMP echo received by agent. NOTE: Although this object is defined as read-write, attempting to write any value results in an error.')
rPState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rPState.setStatus('mandatory')
if mibBuilder.loadTexts: rPState.setDescription('The state of the entry. When this state is set to ACTIVE, the appropriate ping request will be issued by Brouter. A table entry with a state of INACTIVE is an invalidated entry and will not be returned to a get request.')
rDebugTable = MibTable((1, 3, 6, 1, 4, 1, 22, 5, 1, 4), )
if mibBuilder.loadTexts: rDebugTable.setStatus('mandatory')
if mibBuilder.loadTexts: rDebugTable.setDescription('A table of entries used to manage debug reporting from the Brouter.')
rDebugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 5, 1, 4, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rDTaskId"))
if mibBuilder.loadTexts: rDebugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rDebugEntry.setDescription('Variables needed to maintain the FPP debug mechanisms.')
rDTaskId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rDTaskId.setStatus('mandatory')
if mibBuilder.loadTexts: rDTaskId.setDescription('Task-id assigned to the task being debugged. Task-id`s are assigned as follows: IP-ID 2 ICMP-ID 3 RIP-ID 4 UDP-ID 6 ARP-ID 7 KSMAP-ID 8 FMAINP-ID 9 SYSTEM-ID 10 PROXY-ARP-ID 11')
rDDevStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rDDevStat.setStatus('mandatory')
if mibBuilder.loadTexts: rDDevStat.setDescription('Indicates whether the development level debug messages for this module should be reported to the NMS.')
rDRunStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rDRunStat.setStatus('mandatory')
if mibBuilder.loadTexts: rDRunStat.setDescription('Indicates whether the runtime network diagnostic messages for this module should be reported to the NMS.')
rUDnld = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUDnld.setStatus('mandatory')
if mibBuilder.loadTexts: rUDnld.setDescription('Setting this object to 1 has the side effect of causing the unit to perform a cold reset. Reading this object has no meaning. The value 1 is returned in response to a get or get-next request.')
rURset = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rURset.setStatus('mandatory')
if mibBuilder.loadTexts: rURset.setDescription('Setting this object to 1 has the side effect of causing the unit to perform a warm reset. Reading this object has no meaning. The value 1 is returned in response to a get or get-next request.')
rUIpSw = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUIpSw.setStatus('mandatory')
if mibBuilder.loadTexts: rUIpSw.setDescription("Indicates the state of the IP routing feature. If this switch is turned OFF, IP traffic will not be routed through the brouter. IP messages destined for the brouter will be delivered to the unit's upper layers. This leaves the SNMP agent accessible to its manager even when IP routing is de-activated. If bridging is activated, the IP traffic will be bridged.")
rUDecSw = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUDecSw.setStatus('mandatory')
if mibBuilder.loadTexts: rUDecSw.setDescription('Indicates the state of the Decnet feature. If this switch is turned OFF, no Decnet traffic will be routed through this unit. If bridging is activated, the Decnet trafic will be bridged.')
rUBrSw = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUBrSw.setStatus('mandatory')
if mibBuilder.loadTexts: rUBrSw.setDescription('Indicates the state of the bridging feature. If this switch is turned OFF, no traffic will be bridged through this unit. All traffic will be required to be sent through one of the active routing functions.')
rUIpCfg = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rt-cfg-host-only", 1), ("rt-cfg-br-ether", 2), ("rt-cfg-br-all", 3), ("rt-cfg-rte-all", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUIpCfg.setStatus('mandatory')
if mibBuilder.loadTexts: rUIpCfg.setDescription('Indicates the state of IP routing based on its (sub)net configuration. RT-CFG-HOST-ONLY indicates that there is only one IP address in the unit. All IP packets received while in this state will be bridged as an unknown protocol.')
rURunningVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rURunningVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rURunningVersion.setDescription('Indicates the running version.')
rUDnldAllowed = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUDnldAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: rUDnldAllowed.setDescription("Indicates whether downloading to the brouter's Flash memory will be permitted. If this flag is set to OFF the agent will refuse to download into its flash memory. At system start-up this parameter will be initialized to OFF. Once this has been set to ON, it will remain ON until either the user sets it to OFF or a download has been performed at which time the agent will set it to OFF.")
rUInitFlash = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rUInitFlash.setStatus('mandatory')
if mibBuilder.loadTexts: rUInitFlash.setDescription('Indicates if the flash bank states are being initialized. If this object is set to TRUE, the side effect will be to cause the flash states to be initialized. If the flash is in the process of being initialized, a get or getnext operation performed on this object will return 1 (TRUE), otherwise it will return 2 (FALSE).')
pPMibVer = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pPMibVer.setStatus('mandatory')
if mibBuilder.loadTexts: pPMibVer.setDescription('Proprietary mib version number.')
pEepVer = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("single-eth", 1), ("dual-eth", 2), ("brouter", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pEepVer.setStatus('mandatory')
if mibBuilder.loadTexts: pEepVer.setDescription('Version number supported in the EEPROM.')
pUIpSw = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pUIpSw.setStatus('mandatory')
if mibBuilder.loadTexts: pUIpSw.setDescription('Permanently stored (EEPROM) value for IP routing status. See rUIpSw for a complete description. The default value for this object is ON.')
pUDecSw = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pUDecSw.setStatus('mandatory')
if mibBuilder.loadTexts: pUDecSw.setDescription('Permanently stored (EEPROM) value for DECnet routing status. See rUDecSw for a complete description. The default value for this object is ON.')
pUBrSw = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pUBrSw.setStatus('mandatory')
if mibBuilder.loadTexts: pUBrSw.setDescription('Permanently stored (EEPROM) value for bridging status. See rUBrSw for a complete description. The default value for this object is ON.')
pUIpCfg = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pUIpCfg.setStatus('mandatory')
if mibBuilder.loadTexts: pUIpCfg.setDescription('Permanently stored (EEPROM) value for IP configuration. See rUIpCfg for a complete description. The default value for this object is determined by the IP address stored in the permanent database.')
pULoadVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pULoadVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pULoadVersion.setDescription('Permanently stored (EEPROM) value for the desired load version. This value of this object indicates which flash-stored version is to be initiated upon reset of this unit.')
pUDefaults = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pUDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: pUDefaults.setDescription('When this object is set to 1, the side effect will be to cause the unit to reset all the objects defined under the subtree propSysPerm to their default values. Reading this object has no meaning. The integer value 1 will be returned to a get or get-next request.')
pUFlashTable = MibTable((1, 3, 6, 1, 4, 1, 22, 5, 2, 12), )
if mibBuilder.loadTexts: pUFlashTable.setStatus('mandatory')
if mibBuilder.loadTexts: pUFlashTable.setDescription('Contains the information needed for Flash memory maintenance.')
pUFlashEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 5, 2, 12, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "FlashIndex"))
if mibBuilder.loadTexts: pUFlashEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pUFlashEntry.setDescription('Information about a particular bank of flash memory.')
flashIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 2, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashIndex.setStatus('mandatory')
if mibBuilder.loadTexts: flashIndex.setDescription('A unique index value for each flash memory bank.')
flashVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 2, 12, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashVersion.setStatus('mandatory')
if mibBuilder.loadTexts: flashVersion.setDescription('Indicates the version contained in this flash memory bank. If the flash memory bank is uninitialized or invalid, this object will contain a NULL string')
flashState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 5, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2), ("dnloading-in-process", 3), ("reset-in-progress", 4), ("reset-complete", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashState.setStatus('mandatory')
if mibBuilder.loadTexts: flashState.setDescription('')
sysPermBridgeAvailable = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPermBridgeAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: sysPermBridgeAvailable.setDescription('Indicates whether the unit supports bridging functionality or not.')
sysPermIpAvailable = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPermIpAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: sysPermIpAvailable.setDescription('Indicates whether the unit supports IP functionality or not. IP host functionality is always present.')
sysPermDecAvailable = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPermDecAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: sysPermDecAvailable.setDescription('Indicates whether the unit supports DECnet functionality or not.')
pUloadType = MibScalar((1, 3, 6, 1, 4, 1, 22, 5, 2, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pUloadType.setStatus('mandatory')
if mibBuilder.loadTexts: pUloadType.setDescription('This object indicates the type of download to be exercised the next time the unit is loaded. It is a choice of: USER 1 MFG 2 DEV 3')
rIpMaskTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 1), )
if mibBuilder.loadTexts: rIpMaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: rIpMaskTable.setDescription('The list of address masks used by this router for determining its subnets.')
rIpMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rMaskNet"))
if mibBuilder.loadTexts: rIpMaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rIpMaskEntry.setDescription('Items contained in the runtime Address Mask Table.')
rMaskNet = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rMaskNet.setStatus('mandatory')
if mibBuilder.loadTexts: rMaskNet.setDescription('The IP network this mask is defined for.')
rMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rMask.setStatus('mandatory')
if mibBuilder.loadTexts: rMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
rMaskState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rMaskState.setStatus('mandatory')
if mibBuilder.loadTexts: rMaskState.setDescription('The state of this entry. To remove an entry from the table, simply set this field to INACTIVE.')
rIpOurAddrTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 2), )
if mibBuilder.loadTexts: rIpOurAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: rIpOurAddrTable.setDescription('Proprietary extensions for the rfc1156 defined ipAddrTable.')
rIpOurAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 2, 1), ).setIndexNames((0, "SNMPv2-SMI", "IpAddress"))
if mibBuilder.loadTexts: rIpOurAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rIpOurAddrEntry.setDescription("Proprietary extensions for the rfc1156 defined ipAddrEntry. A proprietary ipAddrTable entry contains 4 standard objects and the 4 proprietary objects listed below. The standard objects are: ipAdEntAddr, ipAdEntIfIndex, ipAdEntNetMask and ipAdEntBcastAddr. To add an ipAddrEntry to the ipAddrTable, the rAddrState is the validating item. Therefore, rAddrState must be the last item in the message when adding an entry. The ipAdEntNetMask is determined by the agent. There is a separate mechanism that allows the user to define address masks for the unit. See rIpMaskTable and pIpMaskTable. To add to the ipAddrTable the agent requires the ipAdEntAddr, ipAdEntIfIndex, ipAdEntBcastAddr, rAddrDBcast, rAddrRipMetric and the rAddrRipState followed by the rAddrState. There are 4 default values provided by the agent for this entry: ipAdEntBcastAddr defaults to 'all ones', rAddrDbcast defaults to 'no directed broadcast', rAddrRipState defaults to ON and rAddrRipMetric defaults to 1. To remove an ipAddrEntry, the rAddrState should be set to INACTIVE. The INDEX value specified should correspond to the IP address of the desired entry.")
rAddrDbcast = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-directed-bdcst", 1), ("bdcst-host", 2), ("bdcst-net", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAddrDbcast.setStatus('mandatory')
if mibBuilder.loadTexts: rAddrDbcast.setDescription("Allows the user to set the directed broadcast parameter of an IP network. Default value is 'no directed broadcast'.")
rAddrRipMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAddrRipMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rAddrRipMetric.setDescription('A number from 1 to 15 used to calculate the metrics to given destinations, RIP will add this metric to metrics received from other RIP gateways on this (sub)network. In effect, this can be used to prioritize the (sub)network used for a destination reachable via more than one Brouter (sub)network. Default value is 1.')
rAddrRipState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("quiet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAddrRipState.setStatus('mandatory')
if mibBuilder.loadTexts: rAddrRipState.setDescription('Defines the current state of the RIP protocol for this IP network. The default value is ON.')
rAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: rAddrState.setDescription('The state of this entry. To remove an entry from the table, simply set this field to INACTIVE.')
rIpIfTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 3), )
if mibBuilder.loadTexts: rIpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rIpIfTable.setDescription('Proprietary extensions for the rfc1156 defined ifTable.')
pysmiFakeCol1006 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 3, 1) + (1006, ), Integer32())
rIpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 3, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1006"))
if mibBuilder.loadTexts: rIpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rIpIfEntry.setDescription('Proprietary extensions for the rfc1156 defined ifEntry. The INDEX value specified should correspond to the index of the interface of the desired entry.')
rIfArpStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rIfArpStat.setStatus('mandatory')
if mibBuilder.loadTexts: rIfArpStat.setDescription('Allows the user to turn ARP on and off for the interface.')
rIfPArpStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rIfPArpStat.setStatus('mandatory')
if mibBuilder.loadTexts: rIfPArpStat.setDescription('Allows the user to turn proxy ARP on and off for the interface.')
rIfBcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rIfBcMask.setStatus('mandatory')
if mibBuilder.loadTexts: rIfBcMask.setDescription('When set to ON, Brouter will broadcast its address mask on start up. When set to OFF, the Brouter will not broadcast its address mask on start up.')
rDftGw = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rDftGw.setStatus('mandatory')
if mibBuilder.loadTexts: rDftGw.setDescription('The IP address of the default gateway.')
rIpAtTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 5), )
if mibBuilder.loadTexts: rIpAtTable.setStatus('mandatory')
if mibBuilder.loadTexts: rIpAtTable.setDescription('Proprietary extensions for the rfc1156 defined atTable.')
pysmiFakeCol1007 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 5, 1) + (1007, ), Integer32())
pysmiFakeCol1008 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 5, 1) + (1008, ), Integer32())
rIpAtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 5, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1007"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pysmiFakeCol1008"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "NetworkAddress"))
if mibBuilder.loadTexts: rIpAtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rIpAtEntry.setDescription('Proprietary extensions for the rfc1156 defined atEntry. A proprietary atTable entry contains 3 standard objects and the 2 proprietary objects listed below. The standard objects are: atIfIndex, atPhysAddress and atNetAddress. To add an atEntry to the atTable, MIB-II defines the atPhysAddress as the validating item. Therefore, atPhysAddress must be the last item in the message when adding an entry. To add to the atTable the user must provide the atNetAddress followed by the atPhysAddress. The 2 proprietary objects associated with this entry are provided by the agent. The rAtAge is incremented as the entry ages and the rAtStatic entry is set to static. All atEntries manually defined are considered static and are not removed by the agent until specifically requested by the manager. To remove an atEntry, the atPhysAddress should be set to a NULL string. The INDEX value is constructed from the interface index of the desired entry, the integer value 1, and the network address of the desired entry.')
rAtStatic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rAtStatic.setStatus('mandatory')
if mibBuilder.loadTexts: rAtStatic.setDescription('Defines an entry as static or dynamic. A static entry is one that has been entered manually by the network administrator and can be changed only by the network administrator. The routing protocols never overwrite a static entry. A dynamic entry is one created by the routing protocols and is updated by them as per standard definitions.')
rAtAge = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rAtAge.setStatus('mandatory')
if mibBuilder.loadTexts: rAtAge.setDescription('The age of the entry in minutes.')
rIpRtTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 6), )
if mibBuilder.loadTexts: rIpRtTable.setStatus('mandatory')
if mibBuilder.loadTexts: rIpRtTable.setDescription('Proprietary extensions for the rfc1156 defined ipRoutingTable.')
rIpRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 6, 1), ).setIndexNames((0, "SNMPv2-SMI", "IpAddress"))
if mibBuilder.loadTexts: rIpRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rIpRtEntry.setDescription("Proprietary extensions for the rfc1156 defined ipRoutingEntry. A proprietary ipRouteEntry entry contains 10 standard objects and the proprietary object listed below. The standard objects are: ipRouteDest, ipRouteIfIndex, ipRouteMetric1, ipRouteMetric2, ipRouteMetric3, ipRouteMetric4, ipRouteNextHop, ipRouteType, ipRouteProto and ipRouteAge. To add an atEntry to the ipRoutingTable, MIB-II defines the ipRouteType as the validating item. Therefore, ipRouteType must be the last item in the message when adding an entry. All items, both proprietary and standard, except the ipRouteDest, ipRouteNextHop, ipRouteMetric1, and ipRouteType are determined by the agent. To add to the ipRouteEntry the agent requires the ipRouteDest, ipRouteNextHop, and the ipRouteMetric1 followed by the ipRouteType. The ipRouteIfIndex is determined by the agent based on the ipRouteDest. The ipRouteMetric2, ipRouteMetric3 and ipRouteMetric4 are not used by the router and are set to zero. The ipRouteProto is set to local and rRtStatic is set to static. All ipRouteEntries manually defined are considered static and are not removed by the agent until specifically requested by the manager. If the ipRouteMetric1 is not provided, it's value defaults to 1. To remove an ipRouteEntry, the ipRouteType should be set to invalid. The INDEX value specified should correspond to the destination IP address of the desired entry.")
rRtStatic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRtStatic.setStatus('mandatory')
if mibBuilder.loadTexts: rRtStatic.setDescription('Defines an entry as static or dynamic. A static entry is one that has been entered manually by the network administrator and can be changed only by the network administrator. The routing protocols never overwrite a static entry. A dynamic entry is one created by the routing protocols and is updated by them as per standard definitions.')
rRipTrInd = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("trusted", 3), ("not-trusted", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rRipTrInd.setStatus('mandatory')
if mibBuilder.loadTexts: rRipTrInd.setDescription('This flag indicates whether the rRipTrustTable is used to list trusted or not-trusted gateways. When the state is changed, all existing entries in the table are cleared. The default value is OFF. Setting this object to OFF causes the trust list to be removed and the router is returned to the default state of TRUST ALL.')
rRipTrustTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 8), )
if mibBuilder.loadTexts: rRipTrustTable.setStatus('mandatory')
if mibBuilder.loadTexts: rRipTrustTable.setDescription("This table has 2 possible meanings depending on the value of rRipTrInd. These 2 configuration options allow the network administrator to limit RIP's scope for inbound processing. Outbound processing in not affected by this table. If rRipTrInd is set to TRUSTED, RIP listens only to the indicated gateways and no others. If rRipTrInd is set to NOT-TRUSTED, RIP does not listen to the indicated gateways but will accept updates from all other gateways. If the value of rRipTrInd is changed, this table is cleared. If the table is empty, it is assumed that all gateways are to be trusted or not-trusted depending on the value of rRipTrInd. The default for initialization is all gateways are trusted.")
rRipTrustEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 8, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rTrRestGw"))
if mibBuilder.loadTexts: rRipTrustEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rRipTrustEntry.setDescription('The list of fields needed to support the rRipTrustTable.')
rTrRestGw = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 8, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrRestGw.setStatus('mandatory')
if mibBuilder.loadTexts: rTrRestGw.setDescription('The IP address of the gateway being restricted.')
rTrRestState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rTrRestState.setStatus('mandatory')
if mibBuilder.loadTexts: rTrRestState.setDescription('The state of this entry. To add an entry to the list, set this field to ACTIVE. To remove an entry from the table, simply set this field to INACTIVE.')
rRipLsnIndTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 9), )
if mibBuilder.loadTexts: rRipLsnIndTable.setStatus('mandatory')
if mibBuilder.loadTexts: rRipLsnIndTable.setDescription('The rRipLsnIndTable contains the flags that indicate the type of listen restriction that is active for a given destination address.')
rRipLsnIndEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 9, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rRipLsnIndDest"))
if mibBuilder.loadTexts: rRipLsnIndEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rRipLsnIndEntry.setDescription('The variables needed to maintain an entry in the rRipLsnIndTable.')
rRipLsnIndDest = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 9, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rRipLsnIndDest.setStatus('mandatory')
if mibBuilder.loadTexts: rRipLsnIndDest.setDescription('The restricted destination address. For the LISTEN list this address will be the address of a gateway on a locally attached (sub)network. For the DO-NOT-LISTEN list this address will be a locally attached (sub)network.')
rRipLsnType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("listen", 3), ("do-not-listen", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rRipLsnType.setStatus('mandatory')
if mibBuilder.loadTexts: rRipLsnType.setDescription('Indicates whether the restricted list for this destination is a LISTEN list or a DO-NOT-LISTEN list. When the restriction indicator is changed, the associated LISTEN/DO-NOT-LISTEN list is removed. This field is the validation field to add/delete an entry in this table.')
rRipLsnTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 10), )
if mibBuilder.loadTexts: rRipLsnTable.setStatus('mandatory')
if mibBuilder.loadTexts: rRipLsnTable.setDescription("Setting this table causes RIP to select inbound update information about a specific network or host. This table allows the network administrator to limit RIP's scope for inbound processing. Outbound processing is not affected by this table. If the rRipLsnType for this destination is set to LISTEN, RIP will use updates received from the specified gateways only. If the rRipLsnType is set to DO-NOT-LISTEN, RIP will discard updates received from the specified gateways and process all others. If the value of rRipLsnType is changed, this table is cleared. This table is maintained on a per destination basis. If the table is empty, it is assumed that all gateways are LISTEN for all destination addresses. This is also the default setting. To change the state of an entry in this table from LISTEN to DO-NOT-LISTEN or vice versa, change the rRipLsnType for the destination address and then define the new restriction list for that address.")
rRipLsnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 10, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rLsnAddr"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rLsnRstAddr"))
if mibBuilder.loadTexts: rRipLsnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rRipLsnEntry.setDescription('The list of fields needed to support the rRipLsnTable.')
rLsnAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rLsnAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rLsnAddr.setDescription('The destination address being restricted by this command.')
rLsnRstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rLsnRstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rLsnRstAddr.setDescription('The IP address of the gateway/network being restricted.')
rLsnRstState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rLsnRstState.setStatus('mandatory')
if mibBuilder.loadTexts: rLsnRstState.setDescription('The state of this entry. To remove an entry from the table, set this field to INACTIVE. To add an item to this table set the state to ACTIVE. However, please note that before entries be added to this list it must have a corresponding entry in the rRipLsnIndTable.')
rRipAnncIndTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 11), )
if mibBuilder.loadTexts: rRipAnncIndTable.setStatus('mandatory')
if mibBuilder.loadTexts: rRipAnncIndTable.setDescription('The rRipAnncIndTable contains the flags that indicate the type of announce restriction(s) that are active for each (sub)network supported by the unit. Please note that before any entries can be defined here or in the rRipAnncTable, the (sub)network must be defined to the router via an ipAddrEntry.')
rRipAnncIndEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 11, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rRipAnncIndNet"))
if mibBuilder.loadTexts: rRipAnncIndEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rRipAnncIndEntry.setDescription('The variables needed to maintain an entry in the rRipAnncIndTable.')
rRipAnncIndNet = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 11, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rRipAnncIndNet.setStatus('mandatory')
if mibBuilder.loadTexts: rRipAnncIndNet.setDescription('The IP address this unit recognizes on the (sub)network being restricted.')
rRipAnncType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("announce", 3), ("do-not-announce", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rRipAnncType.setStatus('mandatory')
if mibBuilder.loadTexts: rRipAnncType.setDescription('Indicates whether this (sub)network has an ANNOUNCE list, a DO-NOT-ANNOUNCE list or if the restriction is shut OFF. When the restriction indicator is changed, the associated ANNOUNCE/DO-NOT-ANNOUNCE list is removed.')
rRipAnncTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 12), )
if mibBuilder.loadTexts: rRipAnncTable.setStatus('mandatory')
if mibBuilder.loadTexts: rRipAnncTable.setDescription("Setting this table causes RIP to taylor its update announcements. This table allows the network administrator to limit RIP's scope for outbound processing. Inbound processing is not affected by this table. If the rRipAnncType is set to ANNOUNCE, RIP will adjust its outbound announcments on the indicated (sub)network by propogating announcements for those gateways listed in the rRipAnncTable only. All announcements for gateways not on the ANNOUNCE list will not be sent over the associated (sub)network. If the rRipAnncType is set to DO-NOT-ANNOUNCE, RIP will adjust its outbound announcements on the indicated (sub)network by not propogating announcements for those gateways listed in the rRipAnncTable. All other announcements will be propogated on the indicated (sub)network. If the value of ripAnncType is changed, this table is cleared. This table is maintained on a per (sub)network basis. If the table is empty, it is assumed that all gateways on all (sub)networks are ANNOUNCE. This is also the default state. To change the state of an entry from ANNOUNCE to DO-NOT-ANNOUNCE or vice versa, change the rRipAnncType in the ripAnncIndTable for the (sub)network and then define the new restriction list for the (sub)network. Please note that before any entries can be defined here or in the rRipAnncIndTable, the (sub)network must be defined to the router via an ipAddrEntry.")
rRipAnncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 12, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rAnncDestAddr"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rAnncNet"))
if mibBuilder.loadTexts: rRipAnncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rRipAnncEntry.setDescription('The list of fields needed to support the rRipAnncTable.')
rAnncNet = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 12, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAnncNet.setStatus('mandatory')
if mibBuilder.loadTexts: rAnncNet.setDescription('The IP address this unit recognizes on the (sub)network being restricted.')
rAnncDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 12, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAnncDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rAnncDestAddr.setDescription('The IP address of the gateway being restricted.')
rAnncRstState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAnncRstState.setStatus('mandatory')
if mibBuilder.loadTexts: rAnncRstState.setDescription('The state of this entry. To remove an entry from the table, simply set this field to INACTIVE.')
rRipSrcTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 13), )
if mibBuilder.loadTexts: rRipSrcTable.setStatus('mandatory')
if mibBuilder.loadTexts: rRipSrcTable.setDescription("Setting this table causes RIP broadcasting to be shut off by indicating which gateways should receive directed RIP information. No broadcast RIP update massages will be sent on the specified network. This table allows the network administrator to limit RIP's scope for outbound processing. Inbound processing is not affected by this table. As stated above, this table is maintained on a per (sub)network basis. If the table is empty, it is assumed that all gateways are to receive updates, i.e. broadcast is turned on. The default is broadcast all updates on all (sub)networks. Please note that before any entries can be defined here, the (sub)network must be defined to the router via an ipAddrEntry.")
rRipSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 13, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rSrcAddr"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rSrcRstGw"))
if mibBuilder.loadTexts: rRipSrcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rRipSrcEntry.setDescription('The list of fields needed to support the rRipSrcTable.')
rSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 13, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rSrcAddr.setDescription('The IP address this unit recognizes on the (sub)network being restricted.')
rSrcRstGw = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 13, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rSrcRstGw.setStatus('mandatory')
if mibBuilder.loadTexts: rSrcRstGw.setDescription('The IP address of the gateway being restricted.')
rSrcRstState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rSrcRstState.setStatus('mandatory')
if mibBuilder.loadTexts: rSrcRstState.setDescription('The state of this entry. To remove an entry from the table, simply set this field to INACTIVE.')
rIpRtEvTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 1, 14), )
if mibBuilder.loadTexts: rIpRtEvTable.setStatus('mandatory')
if mibBuilder.loadTexts: rIpRtEvTable.setDescription('Table containing the status of each routing event supported in the brouter.')
rIpRtEvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 1, 14, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rRtEvTskId"), (0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "rRtEvCode"))
if mibBuilder.loadTexts: rIpRtEvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rIpRtEvEntry.setDescription('The entry containing the status of a specific routing event.')
rRtEvTskId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRtEvTskId.setStatus('mandatory')
if mibBuilder.loadTexts: rRtEvTskId.setDescription('The task id of the reporting entity.')
rRtEvCode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRtEvCode.setStatus('mandatory')
if mibBuilder.loadTexts: rRtEvCode.setDescription('The event id assigned to the specific routing event.')
rRtEvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rRtEvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rRtEvStatus.setDescription('Status of this routing event.')
rRipTotRef = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipTotRef.setStatus('mandatory')
if mibBuilder.loadTexts: rRipTotRef.setDescription('Total number of RIP lookups.')
rRipTotFnd = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipTotFnd.setStatus('mandatory')
if mibBuilder.loadTexts: rRipTotFnd.setDescription('Number of times when routing destination was found.')
rRipUdpRcv = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipUdpRcv.setStatus('mandatory')
if mibBuilder.loadTexts: rRipUdpRcv.setDescription('Number of received RIP responses.')
rRipUdpXmt = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipUdpXmt.setStatus('mandatory')
if mibBuilder.loadTexts: rRipUdpXmt.setDescription('Number of transmitted RIP responses.')
rRipUdpTrig = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipUdpTrig.setStatus('mandatory')
if mibBuilder.loadTexts: rRipUdpTrig.setDescription('Total number of triggered RIP updates.')
rRipReqRcv = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipReqRcv.setStatus('mandatory')
if mibBuilder.loadTexts: rRipReqRcv.setDescription('Number of received RIP requests.')
rRipReqXmt = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipReqXmt.setStatus('mandatory')
if mibBuilder.loadTexts: rRipReqXmt.setDescription('Number of transmitted RIP requests.')
rRipInvRcv = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 15, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rRipInvRcv.setStatus('mandatory')
if mibBuilder.loadTexts: rRipInvRcv.setDescription('Number of invalid RIP messages received.')
rArpInMsgs = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInMsgs.setDescription("The total number of ARP messages which the entity received. Note that this counter includes all those counted by 'Inbound Errors'.")
rArpInErr = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInErr.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInErr.setDescription('The number of ARP messages which the entity received but determined as having errors (bad ARP opcode, bad protocol, bad hardware type).')
rArpInIll = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInIll.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInIll.setDescription('The number of illegal ARP messages received: Target Protocol Address (tpa) and Sender Protocol Address (spa) belongs to different networks, tpa, spa are illegal, tpa is broadcast etc.')
rArpInOpCd = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInOpCd.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInOpCd.setDescription('The number of ARP messages received, with bad opcode. Neither request nor reply.')
rArpInReq = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInReq.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInReq.setDescription('The number of ARP Request messages received.')
rArpInRep = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInRep.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInRep.setDescription('The number of ARP Reply messages received.')
rArpInNotMe = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpInNotMe.setStatus('mandatory')
if mibBuilder.loadTexts: rArpInNotMe.setDescription("The number of ARP Requests 'Not For Me messages' received.")
rArpOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: rArpOutMsgs.setDescription("The total number of ARP messages which this entity attempted to send. Note that this counter includes all those counted by 'Outbound Errors'.")
rArpOutErr = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpOutErr.setStatus('mandatory')
if mibBuilder.loadTexts: rArpOutErr.setDescription('The number of ARP messages which this entity did not send due to problems discovered within ARP such as a lack of buffers. This value should not include errors discovered outside the ARP layer such as the inability of the data link layer to send the message.')
rArpOutReq = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpOutReq.setStatus('mandatory')
if mibBuilder.loadTexts: rArpOutReq.setDescription('The number of ARP Request messages sent.')
rArpOutRep = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpOutRep.setStatus('mandatory')
if mibBuilder.loadTexts: rArpOutRep.setDescription('The number of ARP Reply messages sent.')
rArpResReq = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 16, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rArpResReq.setStatus('mandatory')
if mibBuilder.loadTexts: rArpResReq.setDescription('The number of resolve requests to this entity made by an upper level protocol.')
rPArpInRep = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpInRep.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpInRep.setDescription('The number of ARP replies recognized as a reply to a previous arp-request issued by proxy arp.')
rPArpInReqSrch = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpInReqSrch.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpInReqSrch.setDescription("The number of ARP requests recognized as 'naive request' that were put on the Proxy Search List.")
rPArpOutReq = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpOutReq.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpOutReq.setDescription('The number of ARP request sent on behalf of another host by proxy arp.')
rPArpOutRep = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpOutRep.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpOutRep.setDescription('The number of ARP replies sent by proxy arp, back to a naive host, as a result of passive proxy (the sought host was in the table).')
rPArpOutActRep = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpOutActRep.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpOutActRep.setDescription('The number of ARP replies sent by proxy arp, back to a naive host, as the result of an active proxy search.')
rPArpToutSrch = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpToutSrch.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpToutSrch.setDescription('The number of entries that were timed out from proxy arp search list (these entries got no reply during the proxy life-time interval).')
rPArpNaiveReq = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 1, 17, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rPArpNaiveReq.setStatus('mandatory')
if mibBuilder.loadTexts: rPArpNaiveReq.setDescription("The number of ARP requests recognized as 'naive request' and to be handled by proxy arp mechanism. (A 'naive host' is a host with no subnetting knowledge.)")
pIpMaskTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 2, 1), )
if mibBuilder.loadTexts: pIpMaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: pIpMaskTable.setDescription("The permanent list of address masks used by this router to initialize it's rIpMaskTable.")
pIpMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pMaskNet"))
if mibBuilder.loadTexts: pIpMaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pIpMaskEntry.setDescription('Items contained in the permanent Address Mask Table.')
pMaskNet = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pMaskNet.setStatus('mandatory')
if mibBuilder.loadTexts: pMaskNet.setDescription('The IP network this mask is defined for.')
pMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pMask.setStatus('mandatory')
if mibBuilder.loadTexts: pMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
pMaskState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pMaskState.setStatus('mandatory')
if mibBuilder.loadTexts: pMaskState.setDescription('The state of this entry. To remove an entry from the table, simply set this field to INACTIVE.')
pIpOurAddrTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 2, 2), )
if mibBuilder.loadTexts: pIpOurAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: pIpOurAddrTable.setDescription('The permanent list of parameters used by this router to initialize its ipAddrTable as well as the extention table rIpOurAddrTable.')
pIpOurAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pAddrOurAddr"))
if mibBuilder.loadTexts: pIpOurAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pIpOurAddrEntry.setDescription("Objects required for a single entry in the pIpOurAddrTable. To add a pIpOurAddrEntry to the pIpOurAddrTable, the pAddrState is the validating item. Therefore, pAddrState must be the last item in the message when adding an entry. To add to the pIpOurAddrTable the agent requires all 7 items listed below. There are 3 default values provided by the agent for this entry: pAddrBcAddr defaults to -1, pAddrDbcast defaults to 'no directed broadcast' and pAddrRipMetric defaults to 1. To remove an pIpOurAddrEntry, the pAddrState should be set to INACTIVE.")
pAddrOurAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrOurAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrOurAddr.setDescription('The IP Address being defined in this entry.')
pAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrIfIndex.setDescription('The interface this IP Address being defined on.')
pAddrBcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrBcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrBcAddr.setDescription("As defined in rfc1156. 'The value of the least-significant bit in the IP broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this entry. For example, when the Internet standard all-ones broadcast address is used, the value will be 1.' The default value for this item is all-ones.")
pAddrDbcast = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrDbcast.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrDbcast.setDescription("Allows the user to set the directed broadcast parameter of an IP network. The default is 'no directed broadcast'.")
pAddrRipMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrRipMetric.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrRipMetric.setDescription('A number from 1 to 15 used to calculate the metrics to given destinations, RIP will add this metric to metrics received from other RIP gateways on this (sub)network. In effect, this can be used to prioritize the (sub)network used for a destination reachable via more than one Brouter (sub)network. Default value is 1.')
pAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrState.setDescription('The state of this entry. To remove an entry from the table, simply set this field to INACTIVE.')
pAddrRipState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("quiet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pAddrRipState.setStatus('mandatory')
if mibBuilder.loadTexts: pAddrRipState.setDescription('The state of RIP for this entry.')
pIpIfTable = MibTable((1, 3, 6, 1, 4, 1, 22, 6, 2, 3), )
if mibBuilder.loadTexts: pIpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: pIpIfTable.setDescription('The permanent list of parameters used by this router to initialize its ifTable as well as the extention table rIpIfTable.')
pIpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1), ).setIndexNames((0, "FIBRONICS-PROPRIETARY-FX8210-B-MIB", "pIfIndex"))
if mibBuilder.loadTexts: pIpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pIpIfEntry.setDescription('Objects required for a single entry in the pIpIfEntry.')
pIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pIfIndex.setDescription('Interface ID that uniquely identifies this interface among all other interfaces in this brouter.')
pIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIfType.setStatus('mandatory')
if mibBuilder.loadTexts: pIfType.setDescription('Specifies the type of Physical and Data-Link layers. See rfc1156 for protocol codes.')
pIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: pIfMtu.setDescription('Maximum Transmission Unit size that is supported on this network. The largest value acceptable for Ethernet is 1500 and for FDDI is 4500.')
pIfArpStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIfArpStat.setStatus('mandatory')
if mibBuilder.loadTexts: pIfArpStat.setDescription('Allows the user to turn ARP on and off for the interface.')
pIfPArpStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIfPArpStat.setStatus('mandatory')
if mibBuilder.loadTexts: pIfPArpStat.setDescription('Allows the user to turn proxy ARP on and off for the interface.')
pIfAdminStat = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIfAdminStat.setStatus('mandatory')
if mibBuilder.loadTexts: pIfAdminStat.setDescription('Specifies the desired initial state of the interface (i.e., should the interface be started without direction from the operator). See rfc1156 for state codes.')
pIfBcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 6, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIfBcMask.setStatus('mandatory')
if mibBuilder.loadTexts: pIfBcMask.setDescription('When set to ON, the brouter will broadcast its address mask on start up. When set to OFF, the brouter will not broadcast its address mask on start up.')
pDftGw = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 2, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pDftGw.setStatus('mandatory')
if mibBuilder.loadTexts: pDftGw.setDescription('The IP address of the permanent default gateway.')
pIpDefaults = MibScalar((1, 3, 6, 1, 4, 1, 22, 6, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset-defaults", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pIpDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: pIpDefaults.setDescription('When this object is set to 1, the side effect will be to cause the unit to reset all the objects defined under the subtree propIpPerm to their default values. Reading this object has no meaning. The integer value 1 will be returned to a get or get-next request.')
fddiSmtChge = MibScalar((1, 3, 6, 1, 4, 1, 22, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiSmtChge.setStatus('mandatory')
if mibBuilder.loadTexts: fddiSmtChge.setDescription('At system startup, this object is set to FALSE. The SNMP agent then sets this flag to TRUE when any SMT object in the system is set by the manager.')
fddiMacChge = MibScalar((1, 3, 6, 1, 4, 1, 22, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiMacChge.setStatus('mandatory')
if mibBuilder.loadTexts: fddiMacChge.setDescription('At system startup, this object is set to FALSE. The SNMP agent then sets this flag to TRUE when any MAC object in the system is set by the manager.')
fddiPortChge = MibScalar((1, 3, 6, 1, 4, 1, 22, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiPortChge.setStatus('mandatory')
if mibBuilder.loadTexts: fddiPortChge.setDescription('At system startup, this object is set to FALSE. The SNMP agent then sets this flag to TRUE when any PORT object in the system is set by the manager.')
fddiAttachChge = MibScalar((1, 3, 6, 1, 4, 1, 22, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiAttachChge.setStatus('mandatory')
if mibBuilder.loadTexts: fddiAttachChge.setDescription('At system startup, this object is set to FALSE. The SNMP agent then sets this flag to TRUE when any ATTACHMENT object in the system is set by the manager.')
mibBuilder.exportSymbols("FIBRONICS-PROPRIETARY-FX8210-B-MIB", raParmTbl=raParmTbl, raNum=raNum, rRipLsnIndEntry=rRipLsnIndEntry, pbcRpri=pbcRpri, pnRpMaxCost=pnRpMaxCost, rElFrOut=rElFrOut, rccIndex=rccIndex, pIpIfEntry=pIpIfEntry, fddiPortChge=fddiPortChge, rTod=rTod, rIpIfEntry=rIpIfEntry, propIpPerm=propIpPerm, pnRpMaxHops=pnRpMaxHops, pIfType=pIfType, rTrapAddrComm=rTrapAddrComm, rElOvRun=rElOvRun, pDecDefaults=pDecDefaults, rRipAnncIndTable=rRipAnncIndTable, rIpMaskEntry=rIpMaskEntry, traprun=traprun, propSysRun=propSysRun, pnRpMaxBR=pnRpMaxBR, rArpInOpCd=rArpInOpCd, pcircs=pcircs, rElCDetF=rElCDetF, pnRpRstDaddr=pnRpRstDaddr, rnRpUseL2A=rnRpUseL2A, rnLvl1Cidx=rnLvl1Cidx, pnodes=pnodes, rnRcAgedPkt=rnRcAgedPkt, rArpOutMsgs=rArpOutMsgs, flashVersion=flashVersion, rElF1Col=rElF1Col, rAddrDbcast=rAddrDbcast, rbcRpri=rbcRpri, rIpRtEvTable=rIpRtEvTable, pIpMaskTable=pIpMaskTable, dec=dec, rPArpOutRep=rPArpOutRep, rnRcOversize=rnRcOversize, rTrapAddrEntry=rTrapAddrEntry, rCCntrEntry=rCCntrEntry, rnLvl1Tbl=rnLvl1Tbl, rIfBcMask=rIfBcMask, rMaskState=rMaskState, rIpAtTable=rIpAtTable, pTrapAddrAddr=pTrapAddrAddr, rPArpInReqSrch=rPArpInReqSrch, rnRcBadRange=rnRcBadRange, rPingTable=rPingTable, rRipTotFnd=rRipTotFnd, rPingEntry=rPingEntry, pIpOurAddrEntry=pIpOurAddrEntry, rDebugEntry=rDebugEntry, spartacus=spartacus, rLsnRstState=rLsnRstState, rAnncRstState=rAnncRstState, fddiMacChge=fddiMacChge, pAddrBcAddr=pAddrBcAddr, pUloadType=pUloadType, rCCntOPktsOut=rCCntOPktsOut, rMask=rMask, rLsnRstAddr=rLsnRstAddr, pnRpMaxBNR=pnRpMaxBNR, rIpRtTable=rIpRtTable, pTrapAddrState=pTrapAddrState, rArpInIll=rArpInIll, rnAdjEnt=rnAdjEnt, pAddrDbcast=pAddrDbcast, rRipAnncType=rRipAnncType, rnRpMaxCir=rnRpMaxCir, rnAdjLTmr=rnAdjLTmr, rTrapAddrTbl=rTrapAddrTbl, rElNoBuf=rElNoBuf, rnNmParms=rnNmParms, rnRpSegBuf=rnRpSegBuf, pysmiFakeCol1000=pysmiFakeCol1000, rMaskNet=rMaskNet, rnLvl1Cost=rnLvl1Cost, decperm=decperm, rTrapAddrAddr=rTrapAddrAddr, dec2run=dec2run, rDftGw=rDftGw, rClParmTbl=rClParmTbl, fddiAttachChge=fddiAttachChge, rElInF=rElInF, rElMcFIn=rElMcFIn, pDftGw=pDftGw, sysPermBridgeAvailable=sysPermBridgeAvailable, rPArpOutReq=rPArpOutReq, rccCost=rccCost, rAddrState=rAddrState, pbcMrout=pbcMrout, sysPermIpAvailable=sysPermIpAvailable, rccState=rccState, rSrcAddr=rSrcAddr, pnRpUseL2A=pnRpUseL2A, rIpRipStats=rIpRipStats, rRipReqXmt=rRipReqXmt, rCCntTrPktsIn=rCCntTrPktsIn, rnRpType=rnRpType, pULoadVersion=pULoadVersion, rnAdjTbl=rnAdjTbl, pAddrOurAddr=pAddrOurAddr, rArpInErr=rArpInErr, rUInitFlash=rUInitFlash, rnRpBSize=rnRpBSize, pTrapAddrTbl=pTrapAddrTbl, rClParmEntry=rClParmEntry, rPDest=rPDest, rnLvl1Ent=rnLvl1Ent, rRipLsnType=rRipLsnType, rElFrIn=rElFrIn, rcircs=rcircs, fddiSmtChge=fddiSmtChge, rIpPArp=rIpPArp, rTrapAddrType=rTrapAddrType, rRipTrustEntry=rRipTrustEntry, rPArpNaiveReq=rPArpNaiveReq, pAddrIfIndex=pAddrIfIndex, rAtAge=rAtAge, rRipReqRcv=rRipReqRcv, rnRpAMaxH=rnRpAMaxH, rnRpVers=rnRpVers, rArpInRep=rArpInRep, rPArpToutSrch=rPArpToutSrch, pIpOurAddrTable=pIpOurAddrTable, pAddrState=pAddrState, pIpDefaults=pIpDefaults, pAddrRipState=pAddrRipState, rIpMaskTable=rIpMaskTable, rUDnldAllowed=rUDnldAllowed, rLsnAddr=rLsnAddr, pTrapAddrEntry=pTrapAddrEntry, raCIdx=raCIdx, pccState=pccState, pMask=pMask, rRtEvStatus=rRtEvStatus, pUFlashEntry=pUFlashEntry, pUFlashTable=pUFlashTable, pPMibVer=pPMibVer, rTrRestState=rTrRestState, rnRtParms=rnRtParms, raNext=raNext, pnRpAMaxH=pnRpAMaxH, rIpOurAddrTable=rIpOurAddrTable, decrun=decrun, rURset=rURset, rccLine=rccLine, rnRpMArea=rnRpMArea, pIpIfTable=pIpIfTable, rRipTotRef=rRipTotRef, rnNmPaddr=rnNmPaddr, rSrcRstState=rSrcRstState, rArpResReq=rArpResReq, pTrapAddrType=pTrapAddrType, pMaskState=pMaskState, rnAdjAddr=rnAdjAddr, pUDefaults=pUDefaults, rElCountTbl=rElCountTbl, rCCntAdjDown=rCCntAdjDown, raCost=raCost, rnLvl1Next=rnLvl1Next, rElFDef=rElFDef, pnRpMAddr=pnRpMAddr, dec2perm=dec2perm, rIpRtEntry=rIpRtEntry, rPState=rPState, rRtStatic=rRtStatic, rnRtCount=rnRtCount, rRipLsnIndTable=rRipLsnIndTable, rRipAnncIndEntry=rRipAnncIndEntry, rbcMrout=rbcMrout, rnRpMaxBR=rnRpMaxBR, rRipLsnIndDest=rRipLsnIndDest, pIpMaskEntry=pIpMaskEntry, raParmEntry=raParmEntry, rArpOutReq=rArpOutReq, rnLvl1Hops=rnLvl1Hops, rElOutF=rElOutF, propIpRun=propIpRun, rRipInvRcv=rRipInvRcv, rURunningVersion=rURunningVersion, rRipTrInd=rRipTrInd, rRipSrcEntry=rRipSrcEntry, rnodes=rnodes, sysPermDecAvailable=sysPermDecAvailable, pnRpAMaxC=pnRpAMaxC, rBlHAddr=rBlHAddr, rnAdjBSize=rnAdjBSize, rIpAtEntry=rIpAtEntry, rnRpAddr=rnRpAddr, pTrapDefaults=pTrapDefaults, rnRpMaxHops=rnRpMaxHops, rRtEvCode=rRtEvCode, pAddrRipMetric=pAddrRipMetric, pIfAdminStat=pIfAdminStat, rccHTimer=rccHTimer, rPArpInRep=rPArpInRep, rnNmId=rnNmId, rTrRestGw=rTrRestGw, rPProto=rPProto, rCircNum=rCircNum, pccTable=pccTable, rAddrRipState=rAddrRipState, rAnncDestAddr=rAnncDestAddr, pIfIndex=pIfIndex, rnRpMaxCost=rnRpMaxCost, rRipUdpTrig=rRipUdpTrig, rIpRtEvEntry=rIpRtEvEntry, rPTimeOut=rPTimeOut, rBlParmTbl=rBlParmTbl, rArpInMsgs=rArpInMsgs, traperm=traperm, rElBadD=rElBadD, rPArpOutActRep=rPArpOutActRep, rbcDrout=rbcDrout, pnRpAddr=pnRpAddr, rArpInReq=rArpInReq, pnRpBSize=pnRpBSize, rDRunStat=rDRunStat, rnRcRtUpLoss=rnRcRtUpLoss, rRipAnncEntry=rRipAnncEntry, rnAdjPri=rnAdjPri, rUDnld=rUDnld, pnRpMaxV=pnRpMaxV, pIfPArpStat=pIfPArpStat, rArpOutRep=rArpOutRep, flashIndex=flashIndex, pysmiFakeCol1007=pysmiFakeCol1007, pysmiFakeCol1003=pysmiFakeCol1003, pMaskNet=pMaskNet, pccIndex=pccIndex, pUDecSw=pUDecSw, rnAdjType=rnAdjType, rUDecSw=rUDecSw, rDDevStat=rDDevStat, dec2=dec2, rnLvl1Addr=rnLvl1Addr, pTrapAddrComm=pTrapAddrComm, rbcEntry=rbcEntry, rnRcUnReach=rnRcUnReach, rDebugTable=rDebugTable, pEepVer=pEepVer, pysmiFakeCol1005=pysmiFakeCol1005, rRtEvTskId=rRtEvTskId, rIpArpStats=rIpArpStats, rRipLsnEntry=rRipLsnEntry, rnRpBRtTmr=rnRpBRtTmr, rnRpMaxV=rnRpMaxV, pUIpCfg=pUIpCfg, rbcTable=rbcTable, raHops=raHops, rAnncNet=rAnncNet)
mibBuilder.exportSymbols("FIBRONICS-PROPRIETARY-FX8210-B-MIB", pIfArpStat=pIfArpStat, rnRpMAddr=rnRpMAddr, rRipUdpRcv=rRipUdpRcv, pccEntry=pccEntry, propSys=propSys, pysmiFakeCol1008=pysmiFakeCol1008, propSysPerm=propSysPerm, rBlParmEntry=rBlParmEntry, rIpIfTable=rIpIfTable, rFddiIfIndex=rFddiIfIndex, pbcEntry=pbcEntry, rRipAnncIndNet=rRipAnncIndNet, propIp=propIp, rAtStatic=rAtStatic, pnRpBRtTmr=pnRpBRtTmr, rElCountEntry=rElCountEntry, rRipSrcTable=rRipSrcTable, rnRpAMaxC=rnRpAMaxC, pUBrSw=pUBrSw, rUIpSw=rUIpSw, rnAdjCIdx=rnAdjCIdx, rIfArpStat=rIfArpStat, pysmiFakeCol1002=pysmiFakeCol1002, rccTable=rccTable, rCCntTePktsIn=rCCntTePktsIn, pIfMtu=pIfMtu, pysmiFakeCol1006=pysmiFakeCol1006, flashState=flashState, rCCntrs=rCCntrs, rIfPArpStat=rIfPArpStat, rUBrSw=rUBrSw, rccType=rccType, rCCntTrPktsOut=rCCntTrPktsOut, pysmiFakeCol1001=pysmiFakeCol1001, rArpInNotMe=rArpInNotMe, rRipLsnTable=rRipLsnTable, trap=trap, rPReply=rPReply, pnRpType=pnRpType, rUIpCfg=rUIpCfg, pUIpSw=pUIpSw, rareas=rareas, rnRpMaxBNR=rnRpMaxBNR, pysmiFakeCol1004=pysmiFakeCol1004, rRipTrustTable=rRipTrustTable, rTrapAddrVer=rTrapAddrVer, rSrcRstGw=rSrcRstGw, rElBcFIn=rElBcFIn, rIpOurAddrEntry=rIpOurAddrEntry, pccCost=pccCost, pTrapAddrVer=pTrapAddrVer, rccBSize=rccBSize, pIfBcMask=pIfBcMask, rAddrRipMetric=rAddrRipMetric, rnRcFormErr=rnRcFormErr, propFddi=propFddi, rElFMCol=rElFMCol, rElMcBIn=rElMcBIn, rccEntry=rccEntry, rnAdjState=rnAdjState, rRipUdpXmt=rRipUdpXmt, rTrapAddrState=rTrapAddrState, pccHTimer=pccHTimer, rClSubSt=rClSubSt, rElBcBIn=rElBcBIn, pbcTable=pbcTable, rDTaskId=rDTaskId, rRipAnncTable=rRipAnncTable, rArpOutErr=rArpOutErr, rClState=rClState, pnRpMArea=pnRpMArea, pnRtParms=pnRtParms)

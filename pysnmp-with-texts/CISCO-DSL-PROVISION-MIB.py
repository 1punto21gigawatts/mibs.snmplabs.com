#
# PySNMP MIB module CISCO-DSL-PROVISION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-DSL-PROVISION-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:56:15 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Integer32, iso, NotificationType, TimeTicks, ObjectIdentity, MibIdentifier, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ModuleIdentity, Bits, Counter32, Gauge32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "iso", "NotificationType", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ModuleIdentity", "Bits", "Counter32", "Gauge32", "IpAddress")
TruthValue, RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "DisplayString", "TextualConvention")
ciscoDslProvisionMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 30))
if mibBuilder.loadTexts: ciscoDslProvisionMIB.setLastUpdated('990618000000Z')
if mibBuilder.loadTexts: ciscoDslProvisionMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoDslProvisionMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-dsl@cisco.com')
if mibBuilder.loadTexts: ciscoDslProvisionMIB.setDescription('Cisco DSL (Digital Subscriber Line) Provision MIB Module. It is used to create subscriber PPP over ATM sessions and related tasks.')
ciscoDslProvMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 1))
cdslNrpSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1))
cdslVirtualTemplate = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2))
cdslLocalIpAddrPool = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3))
cdslAtmPvc = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4))
cdslVcClass = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5))
cdslMaxNrps = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslMaxNrps.setStatus('current')
if mibBuilder.loadTexts: cdslMaxNrps.setDescription('Maximum number of the node routing processors (NRP) allowed in the system.')
cdslNrpNumber = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslNrpNumber.setStatus('current')
if mibBuilder.loadTexts: cdslNrpNumber.setDescription('The number of NRPs that are present in this system.')
cdslNrpIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1, 3), )
if mibBuilder.loadTexts: cdslNrpIpAddressTable.setStatus('current')
if mibBuilder.loadTexts: cdslNrpIpAddressTable.setDescription('This table reflects the IP addresses of each NRP in the system.')
cdslNrpIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"))
if mibBuilder.loadTexts: cdslNrpIpAddressEntry.setStatus('current')
if mibBuilder.loadTexts: cdslNrpIpAddressEntry.setDescription('These entries are used to store the IP Addresses of NRP cards that are inserted in the indexed slot. The IP addresses are used to access these cards.')
cdslNrpSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cdslNrpSlotIndex.setStatus('current')
if mibBuilder.loadTexts: cdslNrpSlotIndex.setDescription('The object specifies the identifier of a slot containing a NRP.')
cdslNrpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 1, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslNrpIpAddress.setStatus('current')
if mibBuilder.loadTexts: cdslNrpIpAddress.setDescription('The object specifies the IP addresses associated with the NRP contained in the slot identified by cdslNrpSlotIndex.')
cdslVirtualTemplateNumberTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 1), )
if mibBuilder.loadTexts: cdslVirtualTemplateNumberTable.setStatus('current')
if mibBuilder.loadTexts: cdslVirtualTemplateNumberTable.setDescription('This table reflects the number of virtual template that are presently set up in each NRP. A virtual template interface is a logical entity a configuration for a serial-interface but not tied to a physical interface - thatcan be applied dynamically as needed.')
cdslVirtualTemplateNumberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"))
if mibBuilder.loadTexts: cdslVirtualTemplateNumberEntry.setStatus('current')
if mibBuilder.loadTexts: cdslVirtualTemplateNumberEntry.setDescription('Entries are read only.')
cdslMaxVirtualTemplates = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslMaxVirtualTemplates.setStatus('current')
if mibBuilder.loadTexts: cdslMaxVirtualTemplates.setDescription('The object specifies the maximum number of virtual templates allowed in one single NRP.')
cdslVirtualTemplates = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslVirtualTemplates.setStatus('current')
if mibBuilder.loadTexts: cdslVirtualTemplates.setDescription('This object indicates the number of virtual templates presently set up in each NRP identified by cdslNrpSlotIndex.')
cdslVirtualTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2), )
if mibBuilder.loadTexts: cdslVirtualTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cdslVirtualTemplateTable.setDescription('This table includes the virtual templates in the NRP identified by cNrpSlotIndex. Though a virtual template is often called a virtual template interface, it is not reflected in the ifTable.')
cdslVirtualTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"), (0, "CISCO-DSL-PROVISION-MIB", "cdslVTIndex"))
if mibBuilder.loadTexts: cdslVirtualTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cdslVirtualTemplateEntry.setDescription("User may create a new entry or delete an existing entry. Entries may be created without explicitly setting cdslVTRowStatus. While the row status is 'active', objects having read-create access can be changed.")
cdslVTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cdslVTIndex.setStatus('current')
if mibBuilder.loadTexts: cdslVTIndex.setDescription('This object represents an arbitrary index used to identify the virtual template entry.')
cdslVTIpAddressMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ipAddress", 1), ("interfaceIp", 2), ("negotiate", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTIpAddressMethod.setStatus('current')
if mibBuilder.loadTexts: cdslVTIpAddressMethod.setDescription('This object indicates how an IP address is obtained to be associated with this virtual template. The actual parameters of these methods are indicated by the objects defined after. none -- means no IP address associated. ipAddress -- means an explicit IP address and mask. interfaceIp -- uses the IP address of an interface if it has one. negotiate -- obtains IP address from a pre-configured DHCP server. In the set operation, only the parameter corresponding to this object is considered. All other parameters are ignored and forgotten.')
cdslVTIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTIpAddress.setStatus('current')
if mibBuilder.loadTexts: cdslVTIpAddress.setDescription("This object specifies the IP address associated with this virtual template entry. This object is only valid when cdslVTIpAddressMethod is 'ipAddress'. To set the value correctly, this object shall be set in the same packet as cdslVTIpAddressMethod.")
cdslVTIpAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 4), IpAddress().clone(hexValue="ffffffff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTIpAddressMask.setStatus('current')
if mibBuilder.loadTexts: cdslVTIpAddressMask.setDescription("This object specifies the IP address mask. This object is only valid when cdslVTIpAddressMethod is 'ipAddress'. To set the value correctly, this object shall be set in the same packet as cdslVTIpAddressMethod.")
cdslVTIpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTIpIfIndex.setStatus('current')
if mibBuilder.loadTexts: cdslVTIpIfIndex.setDescription("This object specifies the ifIndex of the interface, whose IP address will be used for the virtual template entry. Any interface with an IP address in the routing processor can be selected. This object is only valid when cdslVTIpAddressMethod is 'interfaceIp'. To set the value correctly, this object shall be set in the same packet as cdslVTIpAddressMethod.")
cdslVTPeerIpAddressMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("negotiate", 1), ("ipAddressPool", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPeerIpAddressMethod.setStatus('current')
if mibBuilder.loadTexts: cdslVTPeerIpAddressMethod.setDescription('This object indicates how an IP address is obtained when a peer requesting one. The actual parameters of these methods are indicated by the objects defined after. none -- means no IP address associated. negotiate -- obtains IP address from a pre-configured DHCP server. ipAddressPool -- obtains IP address from an ip address pool specified by cdslVTPeerIpAddrPool to be defined. In the set operation, only the parameter corresponding to the value of this object is considered. All other parameters are ignored and forgotten.')
cdslVTPeerIpAddrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPeerIpAddrPool.setStatus('current')
if mibBuilder.loadTexts: cdslVTPeerIpAddrPool.setDescription("This object is used to specify peer default local IP address pool name. This object is only valid when cdslVTPeerIpAddressMethod is 'ipAddressPool'. To set the value correctly, this object shall be set in the same packet as cdslVTPeerIpAddressMethod. If set this object to a pool name that does not correspond to any entry in the cdslLocalIpAddrPoolTable, then the global IP address mechanism shall be applied. So to use the global IP address mechanism, one should set this object to a non-existent cdslLocalIpAddrPoolName or an empty string.")
cdslVTPppAuthChap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppAuthChap.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppAuthChap.setDescription('This object is used to specify to use Challenge Handshake Authentication Protocol (CHAP) authentication method and the order it is used. The value zero indicates that CHAP is not used. See the description of object cdslVTPppAuthPap for the meaning of non-zero value.')
cdslVTPppAuthMSChap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppAuthMSChap.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppAuthMSChap.setDescription("This object is used to specify the use of Microsoft's CHAP (MSCHAP) authentication method and the order it is used. The value zero indicates that MSCHAP is not used. See the description of object cdslVTPppAuthPap for the meaning of non-zero value.")
cdslVTPppAuthPap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppAuthPap.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppAuthPap.setDescription('This object is used to specify whether to use Password Authentication Protocol (PAP) authentication method and the order it is used. This object is one of multiple objects used to specify authentication methods. The other authentication method objects are cdslVTPppAuthChap and cdslVTPppAuthMSChap. A non-zero value for any of these authentication method objects indicates that its associated authentication method is to be employed. The value of these objects indicates the order in which their respective methods should be applied to the process of authenticating users. The lowest non-zero valued authentication method object is used first. If it fails, the second lowest is applied. If all methods fail, the user is rejected. If multiple objects are set to the same value, then the order of the corresponding methods will be adjusted in the order of CHAP, MSCHAP and PAP. Each time one of these auth method value is set, all the auth method object values will be re-assigned to reflect the order change and the values will be in an incremental order started from one. So the return value(s) of a snmpget request for these objects may be different from what they are set. However the order is preserved.')
cdslVTPppChapHost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppChapHost.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppChapHost.setDescription('This object is used to specify the PPP CHAP host name.')
cdslVTPppChapPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppChapPassword.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppChapPassword.setDescription('This object is used to specify the PPP CHAP password.')
cdslVTPppChapEncrypType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppChapEncrypType.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppChapEncrypType.setDescription('This object is used to specify whether to encrypt the PPP CHAP password. Only effective when cdslVTPppChapPassword is non-empty.')
cdslVTPppChapRefuse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("refuse", 2), ("refuseCallinOnly", 3))).clone('no')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppChapRefuse.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppChapRefuse.setDescription('The object is used to refuse CHAP authentication from peers requesting it. To disable this function set the value to no. RefuseCallinOnly indicating the system to refuse to answer CHAP authentication challenges received from the peer, but will still require the peer to answer any CHAP challenges this system sends. ')
cdslVTPppChapWaitPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 15), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppChapWaitPeer.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppChapWaitPeer.setDescription("This object is used to specify that the system will not authenticate to a peer requesting CHAP authentication until after the peer has authenticated to this system. To disable this function, set this object to 'false'. That is the system will handle the peer authentication requesting even if a peer has not authenticate itself yet.")
cdslVTPppPapUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppPapUserName.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppPapUserName.setDescription('This object is used to specify the PPP PAP user name that will be sent to a peer device. Please refer to the description of cdslVTPppPassword to see the interaction.')
cdslVTPppPapPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppPapPassword.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppPapPassword.setDescription('This object is used to specify the PPP PAP authentication password. The system only utilizes the user name and password when both cdslVTPppUserName and cdslVTPppPassword are non-empty strings. To enforce this the following mechanism is applied. When both are empty strings, set any single one into non-empty string would automatically set the other into the same string. When set any into empty string, the other object would be set to empty string too automatically.')
cdslVTPppPapEncrypType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppPapEncrypType.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppPapEncrypType.setDescription('This object is used to specify whether to encrypt the PAP password. Only effective when cdslVTPppPapPassword is non-empty.')
cdslVTPppUseTacacs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("singleLine", 3))).clone('no')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTPppUseTacacs.setStatus('current')
if mibBuilder.loadTexts: cdslVTPppUseTacacs.setDescription('This object is used to specify whether to enable TACACS for PPP authentication. SingleLine means yes and plus to accept username and password in the username field that is in single line.')
cdslVTRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 2, 2, 1, 20), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVTRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdslVTRowStatus.setDescription('This object is used to create a new row or modify or delete an existing row in this table.')
cdslLocalIpAddrPoolNumberTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 1), )
if mibBuilder.loadTexts: cdslLocalIpAddrPoolNumberTable.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolNumberTable.setDescription('This table indicates the number of IP address pools that are presently set up in each NRP.')
cdslLocalIpAddrPoolNumberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"))
if mibBuilder.loadTexts: cdslLocalIpAddrPoolNumberEntry.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolNumberEntry.setDescription('Entries are read only.')
cdslMaxLocalIpAddrPools = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslMaxLocalIpAddrPools.setStatus('current')
if mibBuilder.loadTexts: cdslMaxLocalIpAddrPools.setDescription('Maximum number of local IP address pools allowed in a NRP.')
cdslLocalIpAddrPools = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslLocalIpAddrPools.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPools.setDescription('The number of local IP address pools presently set up.')
cdslLocalIpAddrPoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 2), )
if mibBuilder.loadTexts: cdslLocalIpAddrPoolTable.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolTable.setDescription('This table defines the IP local address pool. An IP address pool may have a single entry in the table. The ranges of a pool are represented in the cdslLocalIPAddrRangeTable.')
cdslLocalIpAddrPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"), (1, "CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrPoolName"))
if mibBuilder.loadTexts: cdslLocalIpAddrPoolEntry.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolEntry.setDescription('This list contains IP pool entry. The entry is read-only. The creation or the deletion of an entry will be a by-product of the entry in the cdslLocalIPAddrRangeTable. When an entry is created and activated in that table, an entry in this table will come into existance if it is not already so. When an entry is deleted in that table, if there is no other entry existing in that table with the same cdslNrpSlotIndex and cdslLocalIpAddrPoolName, the netry in this table with the same indices will diappear from the table.')
cdslLocalIpAddrPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: cdslLocalIpAddrPoolName.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolName.setDescription('A unique and non-empty string for the pool. The name can not be modified once created.')
cdslLocalIpAddrPoolFreeAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslLocalIpAddrPoolFreeAddresses.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolFreeAddresses.setDescription('The number of IP addresses still available for use in the pool. Please notice that the number is for the whole pool, not for the individual range.')
cdslLocalIpAddrPoolInUseAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslLocalIpAddrPoolInUseAddresses.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrPoolInUseAddresses.setDescription('The number of addresses currently in use in the pool. Please notice that the number is for the whole pool, not for the individual range.')
cdslLocalIpAddrRangeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 3), )
if mibBuilder.loadTexts: cdslLocalIpAddrRangeTable.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrRangeTable.setDescription('This table defines the IP local address pool ranges. An IP address pool may have a single entry or multiple entries in the table, since an IP address pool can have multiple dis-continuous ranges. Each range will have a separate entry in the table.')
cdslLocalIpAddrRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 3, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"), (0, "CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrRangeLowAddr"), (0, "CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrRangeHighAddr"), (1, "CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrPoolName"))
if mibBuilder.loadTexts: cdslLocalIpAddrRangeEntry.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrRangeEntry.setDescription('This list contains IP pool range entry. User may create a new entry or delete an existing entry. When creating an entry, after its activation, an entry in the cdslLocalIpAddrPoolTable will exist if it is not already so. When destroying an entry, if the range is the only range in the pool, the range entry will be destroyed and the pool entry will disappear from the cdslLocalIpAddrPoolTable.')
cdslLocalIpAddrRangeLowAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: cdslLocalIpAddrRangeLowAddr.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrRangeLowAddr.setDescription("The low range of this IP address pool range. This must be lower than the pool's high range.")
cdslLocalIpAddrRangeHighAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 3, 1, 2), IpAddress())
if mibBuilder.loadTexts: cdslLocalIpAddrRangeHighAddr.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrRangeHighAddr.setDescription("The high range of this IP address pool range. This must be higher than the pool's low range.")
cdslLocalIpAddrRangeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 3, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslLocalIpAddrRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdslLocalIpAddrRangeRowStatus.setDescription('This object is used to create a new row or delete an existing row in this table.')
cdslPppOverAtmPvcNumberTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 1), )
if mibBuilder.loadTexts: cdslPppOverAtmPvcNumberTable.setStatus('current')
if mibBuilder.loadTexts: cdslPppOverAtmPvcNumberTable.setDescription('This table reflects the number of PVCs of PPP encapsulation presently set up in each NRP.')
cdslPppOverAtmPvcNumberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"))
if mibBuilder.loadTexts: cdslPppOverAtmPvcNumberEntry.setStatus('current')
if mibBuilder.loadTexts: cdslPppOverAtmPvcNumberEntry.setDescription('Each entry represents the responding NRP.')
cdslPppOverAtmPvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 1, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslPppOverAtmPvcs.setStatus('current')
if mibBuilder.loadTexts: cdslPppOverAtmPvcs.setDescription('The number of atm pvcs that are presently set up with PPP encapsulation. The number of all atm PVCs and the maximum number of PVCs are provided by AToM Mib.')
cdslAtmPvcTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2), )
if mibBuilder.loadTexts: cdslAtmPvcTable.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcTable.setDescription("This table includes configuration parameters for ATM PVCs with PPP encapsulation. The vc-mode ATM PVC management approach is used as the PVC creating method, which greatly simplifies configuration by using of vc-class. The PVCs which were created using atm pvc cli commands can only be read or deleted from snmp. In case of reading, only the values of vpi, vci, sub-interface number, encapsulation, virtual template number and row status are meaningful. When trying to set any object of these PVCs, a GEN_ERROR returns except for the row status object. To indicate a PVC is created with old pvc syntax, the value of cdslAtmPvcClass will be set into '!'.")
cdslAtmPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"), (0, "IF-MIB", "ifIndex"), (0, "CISCO-DSL-PROVISION-MIB", "cdslAtmPvcVpi"), (0, "CISCO-DSL-PROVISION-MIB", "cdslAtmPvcVci"))
if mibBuilder.loadTexts: cdslAtmPvcEntry.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcEntry.setDescription("The IfIndex by which the table is indexed, is the ATM interface index in which the PVC is created. The only object that is allowed to change the value while the row status is 'active' is cdslAtmPvcClass. Please refer to the description of cdslAtmPvcRowStatus for more information.")
cdslAtmPvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: cdslAtmPvcVpi.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcVpi.setDescription("The virtual path identifier of the PVC. Please note that it is routing processor's VPI number.")
cdslAtmPvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: cdslAtmPvcVci.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcVci.setDescription("The virtual channel identifier of the PVC. Please note that it is routing processor's VCI number.")
cdslAtmPvcName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslAtmPvcName.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcName.setDescription('This object can be used to identify the PVC. Unique name for each PVC is desired if assigned.')
cdslAtmPvcSubIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslAtmPvcSubIfNumber.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcSubIfNumber.setDescription('This object indicates the ios sub-interface number if this PVC belongs to an atm sub-interface. Once the pvc exists, the value can not be modified. If the PVC is created under the ATM interface level and not a subinterface level, the object shall be zero.')
cdslAtmPvcClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('default-vc-class')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslAtmPvcClass.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcClass.setDescription("This object indicates the vc-class to inherit when the named vc-class exists. If the object is to set into an empty string, the default value 'default-vc-class' will be used. If the 'default-vc-class' class does exist, it will be created and the encapsulation is set to aal5ciscoppp and the virtual template number is set to the largest virtual template number allowed. If the specified virtual template does not exist, it will be created with no specific configuration. If the specified vc-class does not exist, a new vc-class will be created in the same way as the default-vc-class is. If the specified vc-class exists and its encapsulation is not 'aal5mux' or 'aal5ciscoppp', an error will be returned.")
cdslAtmPvcQosType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ubrDefault", 0), ("cbr", 1), ("ubr", 2), ("ubrPlus", 3), ("vbrRt", 4), ("vbrNrt", 5), ("abr", 6), ("max", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcQosType.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcQosType.setDescription('Quality of Service type of this PVC.')
cdslAtmPvcAbrPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcAbrPCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcAbrPCR.setDescription('Availabe bit rate (Abr) peak cell rate(PCR) of this PVC.')
cdslAtmPvcAbrMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcAbrMCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcAbrMCR.setDescription('Abr Minimum Guaranteed Cell Rate(MCR) of this PVC.')
cdslAtmPvcAbrIORIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcAbrIORIF.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcAbrIORIF.setDescription('Abr inverse of rate increase factor (1/rif) of this PVC.')
cdslAtmPvcAbrIORDF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcAbrIORDF.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcAbrIORDF.setDescription('Abr inverse of rate decrease factor (1/rdf) of this PVC.')
cdslAtmPvcBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcBroadcast.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcBroadcast.setDescription('This object indicates whether to allow broadcast or not.')
cdslAtmPvcEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("default", 0), ("aal5snap", 1), ("aal5mux", 2), ("aal5nlpid", 3), ("aal34smds", 4), ("aal5ilmi", 5), ("aal5qsaal", 6), ("aal5ciscoppp", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcEncapsulation.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcEncapsulation.setDescription('This object indicates encapsulation method of this PVC.')
cdslAtmPvcMuxLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ip", 1), ("ppp", 2))).clone('ppp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslAtmPvcMuxLinkType.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcMuxLinkType.setDescription('This object can be used to This object is used to specify the link type if the encapsulation is aal5mux. 1 -- ip and 2 -- ppp.')
cdslAtmPvcVirtualTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslAtmPvcVirtualTemplate.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcVirtualTemplate.setDescription('The virtual template number configured for the PVC.')
cdslAtmPvcILMIManage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcILMIManage.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcILMIManage.setDescription('This object indicates whether to ilmi manage or not.')
cdslAtmPvcInarp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcInarp.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcInarp.setDescription('This object indicates the InARP Frequency in minutes (Only meaningful in aal5snap encapsulation).')
cdslAtmPvcOamRetryUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcOamRetryUpCount.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcOamRetryUpCount.setDescription('This object indicates the OAM retry count before declaring a VC is up.')
cdslAtmPvcOamRetryDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcOamRetryDownCount.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcOamRetryDownCount.setDescription('This object indicates the OAM retry count before declaring a VC is down.')
cdslAtmPvcOamPvcManaged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcOamPvcManaged.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcOamPvcManaged.setDescription('This object indicates whether to enable VC management on OAM in this PVC.')
cdslAtmPvcOamPvcLF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcOamPvcLF.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcOamPvcLF.setDescription('This object indicates the OAM loopback frequency(seconds) for this PVC.')
cdslAtmPvcProtocolIpBC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcProtocolIpBC.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcProtocolIpBC.setDescription('Pseudo-broadcast on the protocol IP inarp connections or not (Only meaningful in aal5snap encapsulation).')
cdslAtmPvcProtocolIpxBC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcProtocolIpxBC.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcProtocolIpxBC.setDescription('This object indicates whether to allow Pseudo-broadcast on the protocol IPX inarp connections or not (Only meaningful in aal5snap encapsulation).')
cdslAtmPvcUbrPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcUbrPCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcUbrPCR.setDescription('This object indicates the Ubr Peak Cell Rate.')
cdslAtmPvcUbrPlusPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcUbrPlusPCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcUbrPlusPCR.setDescription('This object indicates the Ubr+ Peak Cell Rate.')
cdslAtmPvcUbrPlusMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcUbrPlusMCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcUbrPlusMCR.setDescription('This object indicates the Ubr+ Minimum Guaranteed Cell Rate.')
cdslAtmPvcVbrNrtPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcVbrNrtPCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcVbrNrtPCR.setDescription('This object indicates the Vbr-Nrt Peak Cell Rate.')
cdslAtmPvcVbrNrtSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslAtmPvcVbrNrtSCR.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcVbrNrtSCR.setDescription('This object indicates the Vbr-Nrt Sustainable Cell Rate.')
cdslAtmPvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 4, 2, 1, 28), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslAtmPvcRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdslAtmPvcRowStatus.setDescription("This object is used to create a new row or modify or delete an existing row in this table. When the row is created, but the minimun set of parameters is not all set, the status is 'notReady'. There is no PVC corresponding to it. The minimum set of parameters required to activate an entry is cdslAtmPvcSubIfNumber.")
cdslVcClassNumberTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 1), )
if mibBuilder.loadTexts: cdslVcClassNumberTable.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassNumberTable.setDescription('This table reflects the number of VC classes that are presently set up in each NRP.')
cdslVcClassNumberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"))
if mibBuilder.loadTexts: cdslVcClassNumberEntry.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassNumberEntry.setDescription('Entries are read only.')
cdslMaxVcClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslMaxVcClasses.setStatus('current')
if mibBuilder.loadTexts: cdslMaxVcClasses.setDescription('This object indicates the maximum number of VC classes allowed.')
cdslVcClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslVcClasses.setStatus('current')
if mibBuilder.loadTexts: cdslVcClasses.setDescription('This object indicates the number of VC classes presently set in each NRP identified by cdslNrpSlotIndex.')
cdslVcClassTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2), )
if mibBuilder.loadTexts: cdslVcClassTable.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassTable.setDescription('The entries in this table are vc-classes with at least one parameter configured. In other words, empty classes (with name only) will not be present in this table.')
cdslVcClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1), ).setIndexNames((0, "CISCO-DSL-PROVISION-MIB", "cdslNrpSlotIndex"), (1, "CISCO-DSL-PROVISION-MIB", "cdslVcClassName"))
if mibBuilder.loadTexts: cdslVcClassEntry.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassEntry.setDescription('The VC Class entry is read-create. Each entry represents a VC class.')
cdslVcClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: cdslVcClassName.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassName.setDescription('This object is used to identify the vc class.')
cdslVcClassType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("atm", 1), ("funi", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdslVcClassType.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassType.setDescription('This object indicates the type of the vc class. Atm is for Asynchronous transfer mode and funi for frame user network interface.')
cdslVcClassQosType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ubrDefault", 0), ("cbr", 1), ("ubr", 2), ("ubrPlus", 3), ("vbrRt", 4), ("vbrNrt", 5), ("abr", 6), ("max", 7))).clone('ubrDefault')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassQosType.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassQosType.setDescription('This object specifies the QOS type of the vc class.')
cdslVcClassAbrPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(56, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassAbrPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassAbrPCR.setDescription('This object specifies Abr Peak Cell Rate.')
cdslVcClassAbrMcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassAbrMcr.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassAbrMcr.setDescription('This object specifies Minimum Guaranteed Cell Rate. It shall be smaller than cdslVcClassAbrPCR.')
cdslVcClassAbrIORIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassAbrIORIF.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassAbrIORIF.setDescription('This object specifies Abr inverse of rate increase factor (1/rif) to the power of two. Note that the actual value in the system is the power of two of this object. That is, for example, a value 5 of this object means 2**5 = 32 in the system for AbrIORIF. Range (0..15) to the power of two is the range (1..32768).')
cdslVcClassAbrIORDF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassAbrIORDF.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassAbrIORDF.setDescription('Abr inverse of rate decrease factor (1/rdf) to the power of two. Note that the actual value is the power of two of this object. For example, value 5 of this object means 2**5 = 32. Range (0..15) to the power of two is the range (1..32768).')
cdslVcClassBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2))).clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassBroadcast.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassBroadcast.setDescription('This object indicates whether to allow broadcast or not. When set the value, do not use unknown.')
cdslVcClassEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("default", 0), ("aal5snap", 1), ("aal5mux", 2), ("aal5nlpid", 3), ("aal34smds", 4), ("aal5ilmi", 5), ("aal5qsaal", 6), ("aal5ciscoppp", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassEncapsulation.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassEncapsulation.setDescription('This object specifies encapsulation method.')
cdslVcClassMuxLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ip", 1), ("ppp", 2))).clone('ppp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassMuxLinkType.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassMuxLinkType.setDescription('This object is used to specify the link type if the encapsulation is aal5mux. 1 for IP and 2 for PPP.')
cdslVcClassVirtualTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVirtualTemplate.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVirtualTemplate.setDescription('The virtual template number. Value zero means not configured.')
cdslVcClassIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassIdleTimeout.setDescription('This object specifies idle timeout.')
cdslVcClassIdleMTR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassIdleMTR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassIdleMTR.setDescription('This object specifies the minimum traffic rate to keep the connection.')
cdslVcClassILMIManage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2))).clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassILMIManage.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassILMIManage.setDescription('This object specifies whether to allow ilmi manage or not. When set the value, do not use unknown.')
cdslVcClassInarp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassInarp.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassInarp.setDescription('This object specifies InARP Frequency in minutes.')
cdslVcClassOamRetryUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassOamRetryUpCount.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassOamRetryUpCount.setDescription('OAM retry count before declaring a VC is up')
cdslVcClassOamRetryDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassOamRetryDownCount.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassOamRetryDownCount.setDescription('OAM retry count before declaring a VC is down')
cdslVcClassOamPvcManaged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2))).clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassOamPvcManaged.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassOamPvcManaged.setDescription('This object specifies whether to enable VC management on OAM in a PVC. When set the value, do not use unknown.')
cdslVcClassOamPvcLF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassOamPvcLF.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassOamPvcLF.setDescription('This object specifies the OAM loopback frequency.')
cdslVcClassOamSvcManaged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2))).clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassOamSvcManaged.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassOamSvcManaged.setDescription('This object specifies whether to enable VC management on OAM on SVC SVC. When set the value, do not use unknown.')
cdslVcClassOamSvcLF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassOamSvcLF.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassOamSvcLF.setDescription('This object specifies the OAM loopback frequency for SVC')
cdslVcClassProtocolIpBC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 22), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassProtocolIpBC.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassProtocolIpBC.setDescription('This object specifies whether to allow the pseudo-broadcast on the protocol IP inarp connections or not.')
cdslVcClassProtocolIpxBC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 23), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassProtocolIpxBC.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassProtocolIpxBC.setDescription('This object specifies whether to allow the pseudo-broadcast on the protocol IPX inarp connections or not.')
cdslVcClassTransmitPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassTransmitPriority.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassTransmitPriority.setDescription('This object specifies the transmit priority.')
cdslVcClassUbrPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassUbrPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassUbrPCR.setDescription('This object specifies the Ubr Peak Cell Rate.')
cdslVcClassUbrInputPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassUbrInputPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassUbrInputPCR.setDescription('This object specifies the Ubr Input Peak Cell Rate.')
cdslVcClassUbrPlusPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassUbrPlusPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassUbrPlusPCR.setDescription('This object specifies the Ubr+ Peak Cell Rate.')
cdslVcClassUbrPlusMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassUbrPlusMCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassUbrPlusMCR.setDescription('This object specifies the Ubr+ Minimum Guaranteed Cell Rate. It shall be smaller than cdslVcClassUbrPlusPCR.')
cdslVcClassUbrPlusInputPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassUbrPlusInputPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassUbrPlusInputPCR.setDescription('This object specifies the Ubr+ Input Peak Cell Rate.')
cdslVcClassUbrPlusInputMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassUbrPlusInputMCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassUbrPlusInputMCR.setDescription('This object specifies the Ubr+ Input Minimum Cell Rate. It shall be smaller than cdslVcClassUbrPlusInputPCR.')
cdslVcClassVbrNrtPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVbrNrtPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVbrNrtPCR.setDescription('This object specifies the Vbr-Nrt Peak Cell Rate.')
cdslVcClassVbrNrtSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVbrNrtSCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVbrNrtSCR.setDescription('This object specifies the Vbr-Nrt Sustainable Cell Rate. It shall be smaller than cdslVcClassVbrNrtPCR.')
cdslVcClassVbrNrtInputBP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputBP.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputBP.setDescription('This object specifies the Vbr-Nrt Input Burst Parameter: rounded on AIP to the nearest 32, used as is on NPM.')
cdslVcClassVbrNrtInputPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 155000))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputPCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputPCR.setDescription('This object specifies the Vbr-Nrt Input Peak Cell Rate.')
cdslVcClassVbrNrtInputSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputSCR.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputSCR.setDescription('This object specifies the Vbr-Nrt Input Sustainable Cell Rate. It shall be smaller than cdslVcClassVbrNrtInputPCR.')
cdslVcClassVbrNrtInputMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536))).setUnits('cells').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputMBS.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassVbrNrtInputMBS.setDescription('This object specifies the Input Maximum Burst Size.')
cdslVcClassRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 30, 1, 5, 2, 1, 37), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdslVcClassRowStatus.setStatus('current')
if mibBuilder.loadTexts: cdslVcClassRowStatus.setDescription("This object is used to create a new row or modify or delete an existing row in this table. The return value of this object is always 'active', if the row exists. To delete the row, set the value to 'destroy'. When creating a new row, 'createAndGo' is the default value and method even if 'createAndWait' is specified. The row and the VC class will be created. When deleting a vc class, if there is still reference to it, it is made invisibile. Otherwise, it is removed physically.")
ciscoDslProvMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 2))
ciscoDslProvMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 3))
ciscoDslProvMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 1))
ciscoDslProvMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 2))
ciscoDslProvMIBBasicCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 1, 1)).setObjects(("CISCO-DSL-PROVISION-MIB", "ciscoNrpSlotGroup"), ("CISCO-DSL-PROVISION-MIB", "ciscoVirtualTemplateGroup"), ("CISCO-DSL-PROVISION-MIB", "ciscoIpPoolGroup"), ("CISCO-DSL-PROVISION-MIB", "ciscoDslPVCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoDslProvMIBBasicCompliance = ciscoDslProvMIBBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoDslProvMIBBasicCompliance.setDescription('The compliance statement for entities which implement the Cisco DSL Provision Management MIB. ')
ciscoNrpSlotGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 2, 1)).setObjects(("CISCO-DSL-PROVISION-MIB", "cdslMaxNrps"), ("CISCO-DSL-PROVISION-MIB", "cdslNrpNumber"), ("CISCO-DSL-PROVISION-MIB", "cdslNrpIpAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoNrpSlotGroup = ciscoNrpSlotGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoNrpSlotGroup.setDescription('The DSL Provision NRP Slot Group.')
ciscoVirtualTemplateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 2, 2)).setObjects(("CISCO-DSL-PROVISION-MIB", "cdslMaxVirtualTemplates"), ("CISCO-DSL-PROVISION-MIB", "cdslVirtualTemplates"), ("CISCO-DSL-PROVISION-MIB", "cdslVTIpAddressMethod"), ("CISCO-DSL-PROVISION-MIB", "cdslVTIpAddress"), ("CISCO-DSL-PROVISION-MIB", "cdslVTIpAddressMask"), ("CISCO-DSL-PROVISION-MIB", "cdslVTIpIfIndex"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPeerIpAddressMethod"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPeerIpAddrPool"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppAuthPap"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppAuthChap"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppAuthMSChap"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppChapHost"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppChapPassword"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppChapEncrypType"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppChapRefuse"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppChapWaitPeer"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppPapUserName"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppPapPassword"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppPapEncrypType"), ("CISCO-DSL-PROVISION-MIB", "cdslVTPppUseTacacs"), ("CISCO-DSL-PROVISION-MIB", "cdslVTRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVirtualTemplateGroup = ciscoVirtualTemplateGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVirtualTemplateGroup.setDescription('The DSL Provision Virtual Template Interface Group.')
ciscoIpPoolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 2, 3)).setObjects(("CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrPools"), ("CISCO-DSL-PROVISION-MIB", "cdslMaxLocalIpAddrPools"), ("CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrPoolFreeAddresses"), ("CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrPoolInUseAddresses"), ("CISCO-DSL-PROVISION-MIB", "cdslLocalIpAddrRangeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoIpPoolGroup = ciscoIpPoolGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoIpPoolGroup.setDescription('The DSL Provision IP Pool Group.')
ciscoDslPVCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 2, 4)).setObjects(("CISCO-DSL-PROVISION-MIB", "cdslPppOverAtmPvcs"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcName"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcSubIfNumber"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcClass"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcAbrPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcAbrIORIF"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcAbrIORDF"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcBroadcast"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcEncapsulation"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcMuxLinkType"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcILMIManage"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcInarp"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcOamRetryUpCount"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcOamRetryDownCount"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcOamPvcManaged"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcOamPvcLF"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcProtocolIpBC"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcProtocolIpxBC"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcUbrPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcUbrPlusPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcUbrPlusMCR"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcVbrNrtPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcVbrNrtSCR"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcVirtualTemplate"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcRowStatus"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcQosType"), ("CISCO-DSL-PROVISION-MIB", "cdslAtmPvcAbrMCR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoDslPVCGroup = ciscoDslPVCGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoDslPVCGroup.setDescription('The DSL Provision PVC Group.')
ciscoVcClassGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 30, 3, 2, 5)).setObjects(("CISCO-DSL-PROVISION-MIB", "cdslVcClasses"), ("CISCO-DSL-PROVISION-MIB", "cdslMaxVcClasses"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassType"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassQosType"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassAbrPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassAbrMcr"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassAbrIORIF"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassAbrIORDF"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassBroadcast"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassEncapsulation"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassMuxLinkType"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassIdleTimeout"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassIdleMTR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassILMIManage"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassInarp"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassOamRetryUpCount"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassOamRetryDownCount"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassOamPvcManaged"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassOamPvcLF"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassOamSvcManaged"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassOamSvcLF"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassProtocolIpBC"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassProtocolIpxBC"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassTransmitPriority"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassUbrPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassUbrInputPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassUbrPlusPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassUbrPlusMCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassUbrPlusInputPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassUbrPlusInputMCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVbrNrtPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVbrNrtSCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVbrNrtInputBP"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVbrNrtInputPCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVbrNrtInputSCR"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVbrNrtInputMBS"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassVirtualTemplate"), ("CISCO-DSL-PROVISION-MIB", "cdslVcClassRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVcClassGroup = ciscoVcClassGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVcClassGroup.setDescription('The DSL Provision VC Class Group.')
mibBuilder.exportSymbols("CISCO-DSL-PROVISION-MIB", cdslVcClass=cdslVcClass, cdslAtmPvcOamRetryDownCount=cdslAtmPvcOamRetryDownCount, cdslLocalIpAddrPoolTable=cdslLocalIpAddrPoolTable, cdslVcClassType=cdslVcClassType, cdslAtmPvc=cdslAtmPvc, cdslVTPppChapWaitPeer=cdslVTPppChapWaitPeer, cdslAtmPvcVpi=cdslAtmPvcVpi, cdslVcClassEncapsulation=cdslVcClassEncapsulation, cdslVcClassMuxLinkType=cdslVcClassMuxLinkType, cdslVTPppChapRefuse=cdslVTPppChapRefuse, cdslVTRowStatus=cdslVTRowStatus, cdslVcClassUbrPlusInputMCR=cdslVcClassUbrPlusInputMCR, cdslNrpSlotIndex=cdslNrpSlotIndex, cdslLocalIpAddrPool=cdslLocalIpAddrPool, cdslNrpIpAddressEntry=cdslNrpIpAddressEntry, cdslPppOverAtmPvcs=cdslPppOverAtmPvcs, cdslVcClassEntry=cdslVcClassEntry, cdslLocalIpAddrRangeLowAddr=cdslLocalIpAddrRangeLowAddr, cdslLocalIpAddrPoolFreeAddresses=cdslLocalIpAddrPoolFreeAddresses, cdslVcClassBroadcast=cdslVcClassBroadcast, cdslMaxVcClasses=cdslMaxVcClasses, cdslVcClassName=cdslVcClassName, cdslAtmPvcOamRetryUpCount=cdslAtmPvcOamRetryUpCount, cdslVcClassProtocolIpBC=cdslVcClassProtocolIpBC, cdslAtmPvcVci=cdslAtmPvcVci, cdslAtmPvcProtocolIpxBC=cdslAtmPvcProtocolIpxBC, cdslAtmPvcClass=cdslAtmPvcClass, cdslAtmPvcAbrIORDF=cdslAtmPvcAbrIORDF, ciscoIpPoolGroup=ciscoIpPoolGroup, cdslVirtualTemplateNumberEntry=cdslVirtualTemplateNumberEntry, cdslVTPeerIpAddressMethod=cdslVTPeerIpAddressMethod, cdslVTPppPapEncrypType=cdslVTPppPapEncrypType, cdslVcClassAbrMcr=cdslVcClassAbrMcr, cdslLocalIpAddrRangeEntry=cdslLocalIpAddrRangeEntry, cdslAtmPvcUbrPCR=cdslAtmPvcUbrPCR, cdslVcClassVbrNrtPCR=cdslVcClassVbrNrtPCR, cdslAtmPvcAbrPCR=cdslAtmPvcAbrPCR, cdslVTIpAddress=cdslVTIpAddress, cdslLocalIpAddrRangeTable=cdslLocalIpAddrRangeTable, cdslVcClassVbrNrtInputMBS=cdslVcClassVbrNrtInputMBS, cdslVTPppAuthChap=cdslVTPppAuthChap, cdslVTPppAuthMSChap=cdslVTPppAuthMSChap, cdslVTPeerIpAddrPool=cdslVTPeerIpAddrPool, cdslLocalIpAddrPoolEntry=cdslLocalIpAddrPoolEntry, cdslMaxLocalIpAddrPools=cdslMaxLocalIpAddrPools, cdslAtmPvcOamPvcLF=cdslAtmPvcOamPvcLF, cdslVTPppAuthPap=cdslVTPppAuthPap, cdslPppOverAtmPvcNumberTable=cdslPppOverAtmPvcNumberTable, cdslAtmPvcBroadcast=cdslAtmPvcBroadcast, cdslVcClassAbrIORIF=cdslVcClassAbrIORIF, cdslVcClassVbrNrtSCR=cdslVcClassVbrNrtSCR, ciscoNrpSlotGroup=ciscoNrpSlotGroup, cdslVcClassVbrNrtInputPCR=cdslVcClassVbrNrtInputPCR, ciscoDslProvMIBObjects=ciscoDslProvMIBObjects, ciscoDslProvMIBGroups=ciscoDslProvMIBGroups, cdslVirtualTemplateNumberTable=cdslVirtualTemplateNumberTable, cdslVcClassOamSvcLF=cdslVcClassOamSvcLF, ciscoDslProvMIBConformance=ciscoDslProvMIBConformance, cdslAtmPvcAbrMCR=cdslAtmPvcAbrMCR, cdslVcClassILMIManage=cdslVcClassILMIManage, cdslVcClassOamRetryUpCount=cdslVcClassOamRetryUpCount, cdslVcClassVbrNrtInputSCR=cdslVcClassVbrNrtInputSCR, cdslLocalIpAddrPoolNumberEntry=cdslLocalIpAddrPoolNumberEntry, cdslLocalIpAddrRangeHighAddr=cdslLocalIpAddrRangeHighAddr, cdslAtmPvcVbrNrtSCR=cdslAtmPvcVbrNrtSCR, cdslVcClassNumberTable=cdslVcClassNumberTable, cdslMaxVirtualTemplates=cdslMaxVirtualTemplates, cdslVTIpIfIndex=cdslVTIpIfIndex, ciscoDslProvMIBBasicCompliance=ciscoDslProvMIBBasicCompliance, cdslMaxNrps=cdslMaxNrps, ciscoDslPVCGroup=ciscoDslPVCGroup, cdslVTPppUseTacacs=cdslVTPppUseTacacs, cdslVcClassInarp=cdslVcClassInarp, cdslNrpNumber=cdslNrpNumber, cdslVcClassVirtualTemplate=cdslVcClassVirtualTemplate, cdslAtmPvcUbrPlusPCR=cdslAtmPvcUbrPlusPCR, cdslVTPppChapHost=cdslVTPppChapHost, cdslVcClassNumberEntry=cdslVcClassNumberEntry, cdslVirtualTemplateTable=cdslVirtualTemplateTable, cdslVcClassAbrPCR=cdslVcClassAbrPCR, cdslVcClassOamRetryDownCount=cdslVcClassOamRetryDownCount, cdslVirtualTemplateEntry=cdslVirtualTemplateEntry, cdslAtmPvcMuxLinkType=cdslAtmPvcMuxLinkType, cdslVirtualTemplates=cdslVirtualTemplates, cdslVcClassTransmitPriority=cdslVcClassTransmitPriority, cdslVcClassUbrPlusInputPCR=cdslVcClassUbrPlusInputPCR, cdslVTPppPapPassword=cdslVTPppPapPassword, cdslNrpSlot=cdslNrpSlot, cdslAtmPvcVirtualTemplate=cdslAtmPvcVirtualTemplate, cdslVcClasses=cdslVcClasses, cdslVcClassAbrIORDF=cdslVcClassAbrIORDF, cdslAtmPvcProtocolIpBC=cdslAtmPvcProtocolIpBC, ciscoVirtualTemplateGroup=ciscoVirtualTemplateGroup, ciscoVcClassGroup=ciscoVcClassGroup, cdslVcClassQosType=cdslVcClassQosType, cdslVcClassOamSvcManaged=cdslVcClassOamSvcManaged, cdslVirtualTemplate=cdslVirtualTemplate, cdslVcClassUbrPCR=cdslVcClassUbrPCR, cdslAtmPvcQosType=cdslAtmPvcQosType, ciscoDslProvisionMIB=ciscoDslProvisionMIB, cdslVcClassIdleTimeout=cdslVcClassIdleTimeout, cdslAtmPvcRowStatus=cdslAtmPvcRowStatus, cdslAtmPvcTable=cdslAtmPvcTable, cdslVcClassUbrPlusMCR=cdslVcClassUbrPlusMCR, cdslVcClassVbrNrtInputBP=cdslVcClassVbrNrtInputBP, cdslPppOverAtmPvcNumberEntry=cdslPppOverAtmPvcNumberEntry, cdslAtmPvcAbrIORIF=cdslAtmPvcAbrIORIF, cdslAtmPvcOamPvcManaged=cdslAtmPvcOamPvcManaged, cdslVcClassOamPvcManaged=cdslVcClassOamPvcManaged, cdslVcClassUbrPlusPCR=cdslVcClassUbrPlusPCR, cdslLocalIpAddrPoolNumberTable=cdslLocalIpAddrPoolNumberTable, cdslLocalIpAddrRangeRowStatus=cdslLocalIpAddrRangeRowStatus, cdslLocalIpAddrPoolName=cdslLocalIpAddrPoolName, cdslLocalIpAddrPools=cdslLocalIpAddrPools, cdslAtmPvcEncapsulation=cdslAtmPvcEncapsulation, cdslVcClassRowStatus=cdslVcClassRowStatus, cdslVTIpAddressMask=cdslVTIpAddressMask, cdslAtmPvcInarp=cdslAtmPvcInarp, cdslNrpIpAddressTable=cdslNrpIpAddressTable, cdslAtmPvcVbrNrtPCR=cdslAtmPvcVbrNrtPCR, ciscoDslProvMIBCompliances=ciscoDslProvMIBCompliances, cdslLocalIpAddrPoolInUseAddresses=cdslLocalIpAddrPoolInUseAddresses, cdslVTPppChapPassword=cdslVTPppChapPassword, cdslAtmPvcName=cdslAtmPvcName, cdslVcClassOamPvcLF=cdslVcClassOamPvcLF, cdslVcClassUbrInputPCR=cdslVcClassUbrInputPCR, cdslAtmPvcUbrPlusMCR=cdslAtmPvcUbrPlusMCR, cdslNrpIpAddress=cdslNrpIpAddress, cdslVcClassProtocolIpxBC=cdslVcClassProtocolIpxBC, cdslVTPppPapUserName=cdslVTPppPapUserName, cdslVTIpAddressMethod=cdslVTIpAddressMethod, cdslVcClassIdleMTR=cdslVcClassIdleMTR, ciscoDslProvMIBNotificationPrefix=ciscoDslProvMIBNotificationPrefix, cdslAtmPvcSubIfNumber=cdslAtmPvcSubIfNumber, cdslAtmPvcEntry=cdslAtmPvcEntry, cdslVcClassTable=cdslVcClassTable, cdslVTPppChapEncrypType=cdslVTPppChapEncrypType, cdslVTIndex=cdslVTIndex, cdslAtmPvcILMIManage=cdslAtmPvcILMIManage, PYSNMP_MODULE_ID=ciscoDslProvisionMIB)

#
# PySNMP MIB module SS-OPT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SS-OPT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:10:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibIdentifier, iso, NotificationType, Counter32, IpAddress, Unsigned32, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Bits, TimeTicks, Counter64, ModuleIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibIdentifier", "iso", "NotificationType", "Counter32", "IpAddress", "Unsigned32", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Bits", "TimeTicks", "Counter64", "ModuleIdentity", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
codex = MibIdentifier((1, 3, 6, 1, 4, 1, 449))
cdxProductSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2))
cdx6500 = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1))
cdx6500Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2))
cdx6500CfgGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2))
cdx6500Statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3))
cdx6500StatOtherStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2))
class DisplayString(OctetString):
    pass

cdx6500GCTLSSTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14), )
if mibBuilder.loadTexts: cdx6500GCTLSSTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500GCTLSSTable.setDescription('A list of Configuration parameters that makeup the Switched Service/LBU Table.')
cdx6500SSCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1), ).setIndexNames((0, "SS-OPT-MIB", "cdx6500SSEntryNumber"))
if mibBuilder.loadTexts: cdx6500SSCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSCfgEntry.setDescription('Each entry contains the Configuration parameters for each switched Service/backup link.')
cdx6500SSEntryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSEntryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSEntryNumber.setDescription('This identifies the particular Switched Service/LBU Table entry being configured. The number of instances defined by this entry depends on the configured value of the Maximum Switch Service Entry parameter in the Node record (upto a maximum of 1024 entries). If this value is 0, no switched Service/backup links may be configured i.e. this table will be empty.')
cdx6500SSDestinationName = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSDestinationName.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSDestinationName.setDescription('This is a unique name that identifies this entry.')
cdx6500SSCfgMonitoredPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort.setDescription('The X.25 port to be monitored for link failure. This is the port whose calls are rerouted in the event of port failure. The format must be the following: X25-n, FRI-nSm OR BRI-nCp where n is the port number, m is the station number and p is BRI channel number.')
cdx6500SSCfgRestoralPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSCfgRestoralPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSCfgRestoralPort.setDescription('This is the port or channel that acts as the backup when there is a port failure on the port specified by the parameter Monitored port, or primary destination port (activated by call) The format must be the following: X25-n or BRI-nCm, where n is the port number and m is the channel number.')
cdx6500SSDialSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSDialSequence.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSDialSequence.setDescription("This specifies the telephone numbers that will be dialed when the backup port is activated. To enter your own telephone number, use any combination of the following characters: 0-9 Decimal : Wait Tone < Pause = Seperator 3 > Seperator 4 P or p Dialing to be continued in PULSE mode. T or t Dialing to be continued in DTMF mode. & Flash To have the modem dial one of its pre-programmed telephone numbers, enter: #n where 'n' identifies the pre-programmed telephone number stored in the modem.")
cdx6500SSActivationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("fail", 0), ("call", 1), ("either", 2), ("newvalFail", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSActivationMode.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSActivationMode.setDescription("This specifies how the switched service/backup port will be activated. fail - Activate the backup port upon link failure. call - Activate the backup port upon a call request. either - Activate the backup port upon link failure or a call request. newvalFail - same functionality as 'fail', new enumeration added for RFC1155 compatibility.")
cdx6500SSDeactivationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50))).clone(namedValues=NamedValues(("none", 0), ("busyOut", 1), ("imm", 2), ("newvalNone", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSDeactivationMode.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSDeactivationMode.setDescription("This specifies how the switched service/backup port is deactivated after the original link is up. none - Backup port can only be deactivated by operator intervention. busyOut - The backup port is deactivated after all the calls on that port are cleared for a predetermined amount of time. This substitutes the value assigned to the parameter Link Hold Time with the value assigned to the parameter Idle Disconnect Time in the X.25 Port Record. The Idle Disconnect Time will then work as described in the Operators Guide. When Deactivation Mode = BUSY OUT and Link Hold Time = 0 (zero) the overall effect is the same as setting this entry to NONE. imm - The backup link is terminated IMMediately when the monitored port is restored regardless of how many calls are present. newvalNone - same functionality as 'none', new enumeration added for RFC1155 compatibility.")
cdx6500SSLinkHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSLinkHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSLinkHoldTime.setDescription('This replaces the value of the parameter Idle Disconnect Timer in the X.25 Port Record and specifies how long (in seconds) the backup link remains active after the original link is back up.')
cdx6500SSOutBoundPass = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSOutBoundPass.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSOutBoundPass.setDescription('This is the password used by the remote station to determine if dial access is authorized.')
cdx6500SSRedialTime = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSRedialTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSRedialTime.setDescription('This is the time in seconds between dial attempts when bringing up a switched service call.')
cdx6500SSRedialCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSRedialCounter.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSRedialCounter.setDescription('This parameter is used to specify the number of times that the Switched Service will attempt to redial when redial timer is expired. A value of zero will allow unlimited attempts.')
cdx6500SSSecurityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 50))).clone(namedValues=NamedValues(("none", 0), ("password", 1), ("callingId", 2), ("both", 3), ("newvalNone", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSSecurityMode.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSSecurityMode.setDescription("This specifies under what conditions the port/channel authorizes call request. none - A call request not be rejected based on password of calling party id validation. password - A call request will only be accepted if the password it provides matches the switched services password configured in the node record. callingId - A call request will only be accepted if the calling party id of the caller matches one of the entries found in the calling party id table. both - A call request is accepted only if both the password and the calling party id are valid. newvalNone - same functionality as 'none', new enumeration added for RFC1155 compatibility.")
cdx6500SSSetupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSSetupTime.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSSetupTime.setDescription('This is the time in seconds the monitor port(s) are given to come up after node boot before the backup port is activated.')
cdx6500SSCfgMonitoredPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort2.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort2.setDescription('The X.25 port to be monitored for link failure. This is the port whose calls are rerouted in the event of port failure. The format must be the following: X25-n, FRI-nSm OR BRI-nCp where n is the port number, m is the station number and p is BRI channel number.')
cdx6500SSCfgMonitoredPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort3.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort3.setDescription('The X.25 port to be monitored for link failure. This is the port whose calls are rerouted in the event of port failure. The format must be the following: X25-n, FRI-nSm OR BRI-nCp where n is the port number, m is the station number and p is BRI channel number.')
cdx6500SSCfgMonitoredPort4 = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort4.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSCfgMonitoredPort4.setDescription('The X.25 port to be monitored for link failure. This is the port whose calls are rerouted in the event of port failure. The format must be the following: X25-n, FRI-nSm OR BRI-nCp where n is the port number, m is the station number and p is BRI channel number.')
cdx6500SSDialSequence2 = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSDialSequence2.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSDialSequence2.setDescription("This specifies the telephone numbers that will be dialed when the backup port is activated. To enter your own telephone number, use any combination of the following characters: 0-9 Decimal : Wait Tone < Pause = Seperator 3 > Seperator 4 P or p Dialing to be continued in PULSE mode. T or t Dialing to be continued in DTMF mode. & Flash To have the modem dial one of its pre-programmed telephone numbers, enter: #n where 'n' identifies the pre-programmed telephone number stored in the modem.")
cdx6500SSDialSequence3 = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSDialSequence3.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSDialSequence3.setDescription("This specifies the telephone numbers that will be dialed when the backup port is activated. To enter your own telephone number, use any combination of the following characters: 0-9 Decimal : Wait Tone < Pause = Seperator 3 > Seperator 4 P or p Dialing to be continued in PULSE mode. T or t Dialing to be continued in DTMF mode. & Flash To have the modem dial one of its pre-programmed telephone numbers, enter: #n where 'n' identifies the pre-programmed telephone number stored in the modem.")
cdx6500SSDialSequence4 = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 14, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSDialSequence4.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSDialSequence4.setDescription("This specifies the telephone numbers that will be dialed when the backup port is activated. To enter your own telephone number, use any combination of the following characters: 0-9 Decimal : Wait Tone < Pause = Seperator 3 > Seperator 4 P or p Dialing to be continued in PULSE mode. T or t Dialing to be continued in DTMF mode. & Flash To have the modem dial one of its pre-programmed telephone numbers, enter: #n where 'n' identifies the pre-programmed telephone number stored in the modem.")
cdx6500CallIDTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 18), )
if mibBuilder.loadTexts: cdx6500CallIDTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500CallIDTable.setDescription('A list of Configuration calling ID that makeup the Calling ID Table.')
cdx6500CallIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 18, 1), ).setIndexNames((0, "SS-OPT-MIB", "cdx6500CallIDEntryNumber"))
if mibBuilder.loadTexts: cdx6500CallIDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500CallIDEntry.setDescription('Each entry contains the Configuration Calling ID.')
cdx6500CallIDEntryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500CallIDEntryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500CallIDEntryNumber.setDescription('This is not a configurable parameter. This identifies the particular calling ID Table entry being configured by the other parameters in the record.')
cdx6500CallIDString = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 2, 18, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500CallIDString.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500CallIDString.setDescription('Each calling id entry is a numeric value which may contain periods or dashes. Only calls matching these ids will be allowed when calling id security is enabled.')
cdx6500OSTSSTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3), )
if mibBuilder.loadTexts: cdx6500OSTSSTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500OSTSSTable.setDescription('A list of statistics parameters for the Switch Service/Link Backup port,station,and channel.')
cdx6500SSStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1), ).setIndexNames((0, "SS-OPT-MIB", "cdx6500SSStatRestoralPort"))
if mibBuilder.loadTexts: cdx6500SSStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSStatEntry.setDescription('Each entry on this table pertains to the Switched Service/Link Backup port,station and channel, and can be accessed using the following index: the switched/backup port number, switched/backup station number and the switched/backup channel number.')
cdx6500SSStatRestoralPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSStatRestoralPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSStatRestoralPort.setDescription('This is the backup port number, used as an index to access Switched Service/LBU statistics.')
cdx6500SSPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSPortType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSPortType.setDescription('The port type of the backup port.')
cdx6500SSConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSConnType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSConnType.setDescription('The connection type of the backup port.')
cdx6500SSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 50))).clone(namedValues=NamedValues(("down", 0), ("up", 1), ("activating", 2), ("redial", 3), ("idle", 4), ("deactivating", 5), ("newvalDown", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSStatus.setDescription("The status of the backup port. newvalDown - same functionality as 'down', new enumeration added for RFC1155 compatibility.")
cdx6500SSReason = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 50))).clone(namedValues=NamedValues(("none", 0), ("call", 1), ("fail", 2), ("remote", 3), ("ctp", 4), ("newvalNone", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSReason.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSReason.setDescription("The reason that the backup port is active. none : Backup port is deactivated. call : A call request was made on the backup port. fail : Due to a link failure on the monitored port. remote : A call request was made to the backup port. ctp : Backup port was activated from the control terminal. newvalNone : same functionality as 'none', new enumeration added for RFC1155 compatibility.")
cdx6500SSRedial = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSRedial.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSRedial.setDescription('This parameter is used to specify the number of times that the Switched Service will attempt to redial when the redial timer is expired. A value of zero will allow unlimited attempts.')
cdx6500SSLastActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSLastActivated.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSLastActivated.setDescription('The last time the backup port was activated.')
cdx6500SSLastPhoneDialed = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSLastPhoneDialed.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSLastPhoneDialed.setDescription('The phone number dialed the last time the backup port was activated.')
cdx6500OSTSSMonTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 4), )
if mibBuilder.loadTexts: cdx6500OSTSSMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500OSTSSMonTable.setDescription("A list of statistics parameters for the Link Backup's monitored port.")
cdx6500SSMonStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 4, 1), ).setIndexNames((0, "SS-OPT-MIB", "cdx6500SSStatRestMonPort"), (0, "SS-OPT-MIB", "cdx6500SSStatMonitoredPort"))
if mibBuilder.loadTexts: cdx6500SSMonStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSMonStatEntry.setDescription('Each entry on this table pertains to one of the monitored ports/station/channel that is monitored by the backup port/ station/channel and should be accessed using the following index, * the backup port number * the backup station number * the backup channel number * the monitored port * the monitored station * the monitored channel.')
cdx6500SSStatRestMonPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSStatRestMonPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSStatRestMonPort.setDescription('This is the backup port number, used as a primary index to access monitored port statistics.')
cdx6500SSStatMonitoredPort = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSStatMonitoredPort.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSStatMonitoredPort.setDescription('This is the port being monitored by the backup port, used as a secondary index to access monitored port statistics.')
cdx6500SSMonPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 50))).clone(namedValues=NamedValues(("down", 0), ("up", 1), ("activating", 2), ("redial", 3), ("idle", 4), ("deactivating", 5), ("newvalDown", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSMonPortState.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSMonPortState.setDescription("State of the monitored port. newvalDown : same functionality as 'down', new enumeration added for RFC1155 compatibility.")
cdx6500SSRestPhoneNum = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500SSRestPhoneNum.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500SSRestPhoneNum.setDescription('Phone number that the backup port will dial when a monitored port has a link failure.')
mibBuilder.exportSymbols("SS-OPT-MIB", cdx6500CallIDEntryNumber=cdx6500CallIDEntryNumber, cdx6500SSDestinationName=cdx6500SSDestinationName, cdx6500SSDialSequence2=cdx6500SSDialSequence2, cdx6500SSCfgMonitoredPort3=cdx6500SSCfgMonitoredPort3, cdx6500SSRedialCounter=cdx6500SSRedialCounter, cdx6500SSMonPortState=cdx6500SSMonPortState, DisplayString=DisplayString, cdx6500SSDeactivationMode=cdx6500SSDeactivationMode, cdx6500SSCfgMonitoredPort4=cdx6500SSCfgMonitoredPort4, cdx6500SSDialSequence=cdx6500SSDialSequence, cdx6500SSRedialTime=cdx6500SSRedialTime, cdx6500SSRestPhoneNum=cdx6500SSRestPhoneNum, cdx6500SSDialSequence3=cdx6500SSDialSequence3, cdx6500SSConnType=cdx6500SSConnType, cdx6500SSDialSequence4=cdx6500SSDialSequence4, cdx6500GCTLSSTable=cdx6500GCTLSSTable, cdx6500SSLastActivated=cdx6500SSLastActivated, cdx6500SSActivationMode=cdx6500SSActivationMode, cdx6500CallIDString=cdx6500CallIDString, cdx6500CfgGeneralGroup=cdx6500CfgGeneralGroup, cdx6500CallIDTable=cdx6500CallIDTable, cdxProductSpecific=cdxProductSpecific, cdx6500SSStatRestoralPort=cdx6500SSStatRestoralPort, cdx6500=cdx6500, cdx6500Statistics=cdx6500Statistics, cdx6500SSStatEntry=cdx6500SSStatEntry, cdx6500SSRedial=cdx6500SSRedial, codex=codex, cdx6500StatOtherStatsGroup=cdx6500StatOtherStatsGroup, cdx6500SSStatRestMonPort=cdx6500SSStatRestMonPort, cdx6500SSLinkHoldTime=cdx6500SSLinkHoldTime, cdx6500CallIDEntry=cdx6500CallIDEntry, cdx6500SSReason=cdx6500SSReason, cdx6500SSMonStatEntry=cdx6500SSMonStatEntry, cdx6500SSCfgEntry=cdx6500SSCfgEntry, cdx6500SSLastPhoneDialed=cdx6500SSLastPhoneDialed, cdx6500SSCfgMonitoredPort=cdx6500SSCfgMonitoredPort, cdx6500SSCfgMonitoredPort2=cdx6500SSCfgMonitoredPort2, cdx6500OSTSSTable=cdx6500OSTSSTable, cdx6500SSEntryNumber=cdx6500SSEntryNumber, cdx6500SSStatMonitoredPort=cdx6500SSStatMonitoredPort, cdx6500OSTSSMonTable=cdx6500OSTSSMonTable, cdx6500Configuration=cdx6500Configuration, cdx6500SSPortType=cdx6500SSPortType, cdx6500SSOutBoundPass=cdx6500SSOutBoundPass, cdx6500SSSetupTime=cdx6500SSSetupTime, cdx6500SSStatus=cdx6500SSStatus, cdx6500SSSecurityMode=cdx6500SSSecurityMode, cdx6500SSCfgRestoralPort=cdx6500SSCfgRestoralPort)

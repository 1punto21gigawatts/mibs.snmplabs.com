#
# PySNMP MIB module TPM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TPM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:26:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
apmAppDirAppLocalIndex, AppLocalIndex, apmAppDirResponsivenessType, apmExceptionGroup, RmonClientID, TransactionAggregationType, apmReportGroup, DataSourceOrZero, apmExceptionIndex = mibBuilder.importSymbols("APM-MIB", "apmAppDirAppLocalIndex", "AppLocalIndex", "apmAppDirResponsivenessType", "apmExceptionGroup", "RmonClientID", "TransactionAggregationType", "apmReportGroup", "DataSourceOrZero", "apmExceptionIndex")
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ZeroBasedCounter64, = mibBuilder.importSymbols("HCNUM-TC", "ZeroBasedCounter64")
rmon, OwnerString = mibBuilder.importSymbols("RMON-MIB", "rmon", "OwnerString")
protocolDirLocalIndex, ZeroBasedCounter32 = mibBuilder.importSymbols("RMON2-MIB", "protocolDirLocalIndex", "ZeroBasedCounter32")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Unsigned32, Counter64, IpAddress, ModuleIdentity, Integer32, MibIdentifier, ObjectIdentity, Bits, iso, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Gauge32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter64", "IpAddress", "ModuleIdentity", "Integer32", "MibIdentifier", "ObjectIdentity", "Bits", "iso", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Gauge32", "Counter32")
StorageType, DisplayString, TimeStamp, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "DisplayString", "TimeStamp", "RowStatus", "TextualConvention")
SspmClockMaxSkew, SspmMicroSeconds, SspmClockSource = mibBuilder.importSymbols("SSPM-MIB", "SspmClockMaxSkew", "SspmMicroSeconds", "SspmClockSource")
tpmMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 30))
tpmMIB.setRevisions(('2005-07-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: tpmMIB.setRevisionsDescriptions(('The original version of this MIB module, published as RFC 4150.',))
if mibBuilder.loadTexts: tpmMIB.setLastUpdated('200507280000Z')
if mibBuilder.loadTexts: tpmMIB.setOrganization('IETF RMON MIB Working Group')
if mibBuilder.loadTexts: tpmMIB.setContactInfo('E-mail: rmonmib@ietf.org Subscribe: rmonmib-request@ietf.org w/ msg body: subscribe rmonmib Russell Dietz Hifn, Inc. Postal: 750 University Ave Los Gatos, CA 95032-7695 USA Tel: +1 408 399-3623 Fax: +1 408 399-3501 E-mail: rdietz@hifn.com Robert G. Cole Johns Hopkins University Applied Physics Laboratory Postal: MP2-170 11100 Johns Hopkins Road Laurel, MD 20723-6099 USA Tel: +1 443 778-6951 E-mail: robert.cole@jhuapl.edu')
if mibBuilder.loadTexts: tpmMIB.setDescription("This module defines extensions to the RMON2-MIB module for the collection of Performance Metrics related to application traffic in a network. In particular, it describes managed objects used for monitoring selectable performance metrics and statistics derived from the monitoring of network packets and sub-application level transactions. In order to maintain the RMON 'look-and-feel', some of the text from the RMON2 [RFC2021] and HC-RMON [RFC3273] MIBs by Steve Waldbusser have been used in this MIB module. Copyright (C) The Internet Society (2005). This version of this MIB module is part of RFC 4150; see the RFC itself for full legal notices.")
tpmCapabilities = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 30, 1))
tpmReports = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 30, 2))
tpmConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 30, 3))
class TpmTransactionMetricIndex(TextualConvention, Unsigned32):
    description = 'An index used to identify an entry in the tpmTransMetricDir table uniquely. Each such entry defines the protocol transaction and metric instance to be monitored for a specific application.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 65535)

class TpmMetricDefID(TextualConvention, Unsigned32):
    description = 'An index that identifies through reference to a specific performance metrics. The metrics are referenced through their type (connect, delay, loss, etc.), their directional characteristics (one-way, round trip, etc.), their name, and their reference to a documented definition.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

tpmClockResolution = MibScalar((1, 3, 6, 1, 2, 1, 16, 30, 1, 1), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmClockResolution.setStatus('current')
if mibBuilder.loadTexts: tpmClockResolution.setDescription('A read-only variable indicating the resolution of the measurements possible by this device.')
tpmClockMaxSkew = MibScalar((1, 3, 6, 1, 2, 1, 16, 30, 1, 2), SspmClockMaxSkew()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmClockMaxSkew.setStatus('current')
if mibBuilder.loadTexts: tpmClockMaxSkew.setDescription('A read-only variable indicating the maximum offset error due to skew of the local clock over the time interval 86400 seconds, in seconds.')
tpmClockSource = MibScalar((1, 3, 6, 1, 2, 1, 16, 30, 1, 3), SspmClockSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmClockSource.setStatus('current')
if mibBuilder.loadTexts: tpmClockSource.setDescription('A read-only variable indicating the source of the clock. This is provided to allow a user to determine how accurate the timing mechanism is compared with other devices.')
tpmTransMetricDirLastChange = MibScalar((1, 3, 6, 1, 2, 1, 16, 30, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmTransMetricDirLastChange.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricDirLastChange.setDescription('The value of sysUpTime at the time the tpmTransMetricDirTable was last modified, through modifications of the tpmTransMetricDirConfig object.')
tpmTransMetricDirTable = MibTable((1, 3, 6, 1, 2, 1, 16, 30, 1, 5), )
if mibBuilder.loadTexts: tpmTransMetricDirTable.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricDirTable.setDescription('This table is used to describe and link sets of performance metrics and protocols to an entry in the application directory. This table, with the tpmMetricDefTable, describes the capability of the agent to collection sub-application level data related to each entry in the apmAppDirectoryTable. This table lists the protocol transactions and their corresponding performance metrics that this agent has the capability to compute and collect, for the specified application. There is one entry in this table for each such application, protocol transaction, and metric combination supported by this agent. The entries in this table represent the metrics that are collected for each protocol transaction that comprise the application. The agent should boot up with this table pre-configured with those combinations of applications, protocol transactions, and metrics that it knows about and wishes to monitor. Implementations must populate the table with all possible application, protocol transaction, and metric combinations and have the default configuration objects set to supportedOff(2). This table does not support the creation of new combinations by the management application. The deletion of an entry in the apmAppDirectoryTable will cause the removal of entries from this table. These entries must be removed because the appLocalIndex value will no longer be visible in the apmAppDirectoryTable. When an entry is created in the apmAppDirectoryTable and the agent has the ability to support metrics for these protocol transactions, the appropriate entries must be made in the tpmTransMetricDefTable.')
tpmTransMetricDirEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 30, 1, 5, 1), ).setIndexNames((0, "TPM-MIB", "tpmTransMetricAppLocalIndex"), (0, "TPM-MIB", "tpmTransMetricIndex"))
if mibBuilder.loadTexts: tpmTransMetricDirEntry.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricDirEntry.setDescription('A conceptual row in the tpmTransMetricDirTable. An example of the indexing of this entry is tpmTransMetricDirConfig.5.2 where 5 is the value of a valid and visible appLocalIndex object in the appLocalDir table. The entries describe the transaction and metric pairs monitored for this application. The tpmTransMetricProtocolIndex identifies the protocol transaction and the tpmMetricDefIndex describes the metric monitored.')
tpmTransMetricAppLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 5, 1, 1), AppLocalIndex())
if mibBuilder.loadTexts: tpmTransMetricAppLocalIndex.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricAppLocalIndex.setDescription('An index used to uniquely identify the application with which the entries in the tpmTransMetricDir table are associated.')
tpmTransMetricIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 5, 1, 2), TpmTransactionMetricIndex())
if mibBuilder.loadTexts: tpmTransMetricIndex.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricIndex.setDescription('An index used to uniquely identify an entry in the tpmTransMetricDir table. Each such entry defines protocol transaction and metric instance to be monitored for a specific application.')
tpmTransMetricProtocolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmTransMetricProtocolIndex.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricProtocolIndex.setDescription('The protocolDirLocalIndex of the particular transaction to be analyzed when computing and generating the selected metric for a specific application.')
tpmTransMetricMetricIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmTransMetricMetricIndex.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricMetricIndex.setDescription('The tpmMetricDefinitionID of the particular metric to be generated.')
tpmTransMetricDirConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpmTransMetricDirConfig.setStatus('current')
if mibBuilder.loadTexts: tpmTransMetricDirConfig.setDescription("This object describes and configures the probe's support for this performance metric in relationship to the specified transaction and application. The agent creates entries in this table for all metric and transaction combinations that it can generate. Because the probe will only populate this table with supported entries, and the table cannot have entries added, the notSupported(1) setting is only used to signify that other configuration parameters are causing the agent currently not to support the generation and collection of this metric for the specified protocol and application. Also, the status of this object will not change to notSupported(1) due to a change to supportedOff(2) in the tpmMetricDir table. If the value of this object is notSupported(1), the probe will not perform computations for this performance metric and transaction combination and will not allow this object to be changed to any other value. If the value of this object is supportedOn(3), the probe supports computations for this performance metric and protocol and is configured to perform the computations for this performance metric and protocol combination for the application for all interfaces. If the value of this object is supportedOff(2), the probe supports computations for this performance metric for the specified protocol, but is configured not to perform the computations for this performance metric and protocol for the application for any interfaces. Whenever this value changes from supportedOn(3) to supportedOff(2), the probe shall cause the deletion of all entries in the tpmReportGroup tables, for all appropriate studies configured in the tpmAggrReportCntrlTable. The value of this object must persist across reboots.")
tpmMetricDefTable = MibTable((1, 3, 6, 1, 2, 1, 16, 30, 1, 6), )
if mibBuilder.loadTexts: tpmMetricDefTable.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefTable.setDescription("The tpmMetricDefTable describes the metrics available to the TPM-MIB. The tpmMetricDefTable can define metrics by referencing existing IETF, ITU, and other standards organizations' documents, including enterprise-specific documents. Examples of appropriate references include the ITU-T Recommendation Y.1540 [Y.1540] on IP packet transfer performance metrics and the IETF documents from the IPPM WG; e.g., RFC2681 on the round trip delay metric [RFC2681] or RFC3393 on the delay variation metric [RFC3393]. Other examples include RFC2679 [RFC2679], RFC2680 [RFC2680], and RFC3432 [RFC3432]. Although no specific metric is mandatory, implementations should, at a minimum, support a round-trip delay and a round-trip loss metric. This table contains one row per metric supported by this agent, and it should be populated during system initialization.")
tpmMetricDefEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1), ).setIndexNames((0, "TPM-MIB", "tpmMetricDefinitionID"))
if mibBuilder.loadTexts: tpmMetricDefEntry.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefEntry.setDescription('Information about a particular metric.')
tpmMetricDefinitionID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1, 1), TpmMetricDefID())
if mibBuilder.loadTexts: tpmMetricDefinitionID.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefinitionID.setDescription('The index for this entry. This object identifies the particular metric in this MIB module.')
tpmMetricDefType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("connectMetric", 2), ("delayMetric", 3), ("lossMetric", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmMetricDefType.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefType.setDescription("The basic type of metric indicated by this entry. The value 'other(1)' indicates that this metric cannot be characterized by any of the remaining enumerations specified for this object. The value 'connectMetric(2)' indicates that this metric measures connectivity characteristics. The value 'delayMetric(3)' indicates that this metric measures delay characteristics. The value 'lossMetric(4)' indicates that this metric measures loss characteristics.")
tpmMetricDefDirType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("oneWay", 1), ("twoWay", 2), ("multiWay", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmMetricDefDirType.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefDirType.setDescription("The directional characteristics of the this metric. The value 'oneWay(1)' indicates that this metric is measured with some sort of unidirectional test. The value 'twoWay(2)' indicates that this metric is measured with some sort of bidirectional test. The value 'multiWay(3)' indicates that this metric is measured with some combination of unidirectional and/or bidirectional tests.")
tpmMetricDefName = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmMetricDefName.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefName.setDescription("The textual name of this metric. For example, if this tpmMetricDefEntry identified the IPPM metric for round trip delay, then this object should contain the value, e.g., 'Type-P-Round-Trip-Delay'.")
tpmMetricDefReference = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmMetricDefReference.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefReference.setDescription("This object contains a reference to the document that defines this metric. If this document is available online via electronic download, then a de-referencable URL should be specified in this object. The implementation must support an HTTP URL type and may support additional types of de-referencable URLs such as an FTP type. For example, if this tpmMetricDefName identified the IPPM metric 'Type-P-Round-Trip-Delay', then this object should contain the value, e.g., 'http://www.ietf.org/rfc/rfc2681.txt'.")
tpmMetricDefGlobalID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 1, 6, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmMetricDefGlobalID.setStatus('current')
if mibBuilder.loadTexts: tpmMetricDefGlobalID.setDescription('This object contains a reference to the Object ID in a metrics registration MIB being developed in the IPPM WG at the IETF; e.g., the IPPM-REGISTRY-MIB [RFC4148], which defines the metric. In the event that this metric has no corresponding object identifier (OID) or until the IPPM-REGISTRY-MIB is defined, then the value should be set to 0.0 for none.')
tpmAggrReportCntrlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 30, 2, 1), )
if mibBuilder.loadTexts: tpmAggrReportCntrlTable.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlTable.setDescription('The tpmAggrReportCntrlTable is the controlling entry that manages the population of studies in the Transport Aggregate Report for selected interfaces, metrics, and transaction protocols and applications. Note that this is not like the typical RMON controlTable and dataTable in which each entry creates its own data table. Each entry in this table enables the creation of multiple data tables on a study basis. For each interval, the study is updated in place, and the current data content of the table becomes invalid. The control table entries are persistent across system reboots.')
tpmAggrReportCntrlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1), ).setIndexNames((0, "TPM-MIB", "tpmAggrReportCntrlIndex"))
if mibBuilder.loadTexts: tpmAggrReportCntrlEntry.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlEntry.setDescription('A conceptual row in the tpmAggrReportCntrlTable. An example of the indexing of this entry is tpmAggrReportCntrlDataSource.1')
tpmAggrReportCntrlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: tpmAggrReportCntrlIndex.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlIndex.setDescription('An index that uniquely identifies an entry in the tpmAggrReportCntrlTable. Each such entry defines a unique report whose results are placed in the tpmAggrReportTable on behalf of this tpmAggrReportCntrlEntry.')
tpmAggrReportCntrlApmCntrlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlApmCntrlIndex.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlApmCntrlIndex.setDescription('This index associates this TpmAggrReportCntrlEntry directly with an existing ApmReportControlEntry. This link is used to synchronize reports in the associated tpmAggrReportTable. A value of 0 (zero) enables an independent control table that will report entries to tpmAggrReportTable based only on the other objects in this table. A non-zero value indicates that this row is defined through the APM-MIB. In this case, all row objects are set to their corresponding values in the APM-MIB. In the event that a SET is issued to a row object, while the value of the tpmAggrReportCntrlApmCntrlIndex is non-zero, the agent MUST respond as if the object of the SET command had MAX-ACCESS of read-only. This object may not be modified if the associated tpmAggrReportCntrlStatus object is equal to active(1).')
tpmAggrReportCntrlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 3), DataSourceOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlDataSource.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlDataSource.setDescription("The source of the data for TPM Reports generated on behalf of this tpmAggrReportCntrlEntry. If the measurement is being performed by a probe, this should be set to the interface or port where data was received for analysis. If the measurement isn't being performed by a probe this should be set to the primary interface over which the measurement is being performed. If the measurement isn't being performed by a probe and there is no primary interface, or if this information isn't known, this object should be set to 0.0. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object is set to the corresponding apmReportControlTable object in the APM-MIB [RFC3729]. This object may not be modified if the associated tpmAggrReportCntrlStatus object is equal to active(1).")
tpmAggrReportCntrlAggrType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 4), TransactionAggregationType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlAggrType.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlAggrType.setDescription('The type of aggregation being performed for this set of reports. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlAggregationType object. This object may not be modified if the associated tpmAggrReportCntrlStatus object is equal to active(1).')
tpmAggrReportCntrlInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 5), Unsigned32().clone(3600)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlInterval.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlInterval.setDescription('The interval in seconds over which data is accumulated before being aggregated into a report in the tpmAggrReportTable. All reports with the same tpmAggrReportCntrlIndex will be based on the same interval. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlControlInterval object. This object may not be modified if the associated tpmReportAggregateCntrlStatus object is equal to active(1).')
tpmAggrReportCntrlReqSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlReqSize.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlReqSize.setDescription('The maximum number of Client and Server combination entries requested for this report. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlRequestedSize object. When this object is created or modified, the probe should set tpmReportCntrlGrantedSize as closely to this object as is possible for the particular probe implementation and available resources. It is important to note that this value is the number of requested entries in the tpmAggrReportTable only. Because the probe can derive this table from the apmReportTable, the probe must make sure that sufficient resources exist to support the creation of the apmReportTable, plus any additional resources required to convert or support this table. This object may not be modified if the associated tpmReportAggregateCntrlStatus object is equal to active(1).')
tpmAggrReportCntrlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportCntrlGrantedSize.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlGrantedSize.setDescription('The maximum number of performance entries in this report. When the associated tpmAggrReportCntrlReqSize object is created or modified, the probe should set this object as closely to the requested value as is possible for the particular implementation and available resources. The probe must not lower this value except as a result of a set to the associated tpmAggrReportCntrlReqSize object. It is an implementation-specific matter as to whether zero-valued entries are available.')
tpmAggrReportCntrlReqReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlReqReports.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlReqReports.setDescription('The number of saved reports requested to be allocated on behalf of this entry. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlcwRequestedReportsDataSource object. This object may not be modified if the associated tpmReportAggregateCntrlStatus object is equal to active(1).')
tpmAggrReportCntrlGrantedReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportCntrlGrantedReports.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlGrantedReports.setDescription("The number of saved reports the agent has allocated based on the requested amount in tpmAggrReportCntrlReqReports. Because each report can have many entries, the total number of entries allocated will be this number multiplied by the value of tpmAggrReportCntrlGrantedSize, or by 1 if that object doesn't exist. When the associated tpmAggrReportCntrlReqReports object is created or modified, the agent should set this object as closely to the requested value as is possible for the particular implementation and available resources. When considering available resources, the agent must consider its ability to allocate this many reports, each with the number of entries represented by tpmAggrReportCntrlGrantedSize, or by 1 if that object doesn't exist. Note that although the storage required for each report may fluctuate due to changing conditions, the agent must continue to have storage available to satisfy the full report size for all reports, when necessary. Further, the agent must not lower this value except as a result of a set to the associated tpmAggrReportCntrlReqSize object.")
tpmAggrReportCntrlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportCntrlStartTime.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlStartTime.setDescription("The value of sysUpTime when the system began processing the report in progress. Note that the report in progress is not available. This object may be used by the management station to figure out the start time for all previous reports saved for this tpmAggrReportCntrlEntry, as reports are started at fixed intervals. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object is set to the corresponding apmReportControlTable object in the APM-MIB defined in the IETF's RMONMIB WG.")
tpmAggrReportCntrlReportNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportCntrlReportNumber.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlReportNumber.setDescription('The number of the report in progress. When an tpmAggrReportCntrlEntry is activated, the first report will be numbered zero. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlReportNumber object.')
tpmAggrReportCntrlInsertsDenied = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportCntrlInsertsDenied.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlInsertsDenied.setDescription("The number of attempts to add an entry to reports for this TpmAggrReportCntrlEntry that failed because the number of entries would have exceeded tpmAggrReportCntrlGrantedSize. This number is valuable in determining if enough entries have been allocated for reports in light of fluctuating network usage. Note that an entry that is denied will often be attempted again, so this number will not predict the exact number of additional entries needed, but it can be used to understand the relative magnitude of the problem. Also note that there is no ordering specified for the entries in the report; thus, there are no rules for which entries will be omitted when not enough entries are available. As a consequence, the agent is not required to delete 'least valuable' entries first.")
tpmAggrReportCntrlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportCntrlDroppedFrames.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlDroppedFrames.setDescription('The total number of frames that were received by the agent and therefore not accounted for in the *StatsDropEvents, but for which the agent chose not to count for this entry for whatever reason. Most often, this event occurs when the agent is out of some resources and decides to shed load from this collection. This count does not include packets that were not counted because they had MAC-layer errors. Note that if the alMatrixTables are not implemented or are inactive because no protocols are enabled in the protocol directory, this value should be 0. Note that, unlike the dropEvents counter, this number is the exact number of frames dropped.')
tpmAggrReportCntrlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 14), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlOwner.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlReportNumber object. This object may not be modified if the associated tpmReportAggregateCntrlStatus object is equal to active(1).')
tpmAggrReportCntrlStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 15), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlStorageType.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlStorageType.setDescription("The storage type of this tpmAggrReportCntrlEntry. If the value of this object is 'permanent', no objects in this row need to be writable.")
tpmAggrReportCntrlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 1, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tpmAggrReportCntrlStatus.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportCntrlStatus.setDescription('The status of this performance control entry. An entry may not exist in the active state unless each object in the entry has an appropriate value. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object should be set by the agent to the value of the apmReportControlReportNumber object. Once this object is set to active(1), no objects in the tpmAggrReportCntrlTable can be changed. If this object is not equal to active(1), all associated entries in the tpmAggrReportTable shall be deleted.')
tpmAggrReportTable = MibTable((1, 3, 6, 1, 2, 1, 16, 30, 2, 2), )
if mibBuilder.loadTexts: tpmAggrReportTable.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportTable.setDescription('This table contains transport performance metric studies for each of the control table entries in tpmAggrReportCntrlTable. These studies are provided based on the selections and parameters found for the entry in the tpmAggregateReportCntrlTable. The performance statistics are specified in the tpmTransMetricDirTable associated with the application in question and indexed by appLocalIndex and tpmTransMetricIndex.')
tpmAggrReportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1), ).setIndexNames((0, "TPM-MIB", "tpmAggrReportCntrlIndex"), (0, "TPM-MIB", "tpmAggrReportIndex"), (0, "TPM-MIB", "tpmAggrReportAppLocalIndex"), (0, "TPM-MIB", "tpmAggrReportTransMetricIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "TPM-MIB", "tpmAggrReportServerAddress"), (0, "TPM-MIB", "tpmAggrReportApmNameClientID"))
if mibBuilder.loadTexts: tpmAggrReportEntry.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportEntry.setDescription('A conceptual row in the tpmAggrReportTable. The tpmAggrReportCntrlIndex value in the index identifies the tpmAggrReportCntrlEntry on whose behalf this entry was created. The tpmAggrReportIndex value in the index identifies which report (in the series of reports) this entry is a part of. The tpmAggrReportAppLocalIndex value in the index identifies the application protocol that is being reported. The tpmTransMetricIndex value in the index identifies the transaction protocol-metric pair for the traffic flows aggregated in this entry. The protocolDirLocalIndex value in the index identifies the network layer protocol of the tpmAggrReportServerAddress. When the associated tpmAggrReportCntrlAggrType value is equal to applications(4) or clients(2), this value will equal 0. The tpmAggrReportServerAddress value in the index identifies the network layer address of the server in traffic flows aggregated in this entry. The tpmAggrReportApmNameClientID value in the index identifies the client in traffic flows aggregated in this entry. If the associated tpmAggrReportCntrlAggrType is equal to applications(4) or servers(3), then this object will be set to 0. An example of the indexing of this entry is tpmAggrReportStatN.3.15.34.262.18.4.128.2.6.7.3256521')
tpmAggrReportIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: tpmAggrReportIndex.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportIndex.setDescription('The value of tpmAggrReportCntrlNumber for the report to which this entry belongs.')
tpmAggrReportAppLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 2), AppLocalIndex())
if mibBuilder.loadTexts: tpmAggrReportAppLocalIndex.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportAppLocalIndex.setDescription('The common application of the transactions aggregated in this entry.')
tpmAggrReportTransMetricIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 3), TpmTransactionMetricIndex())
if mibBuilder.loadTexts: tpmAggrReportTransMetricIndex.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportTransMetricIndex.setDescription('A unique index that identifies the transaction and metric associated with the statistics reported here.')
tpmAggrReportServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)))
if mibBuilder.loadTexts: tpmAggrReportServerAddress.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportServerAddress.setDescription('The network layer address of the server host in this conversation. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. Because this object is an index variable, it is encoded in the index according to the index encoding rules. For example, if the protocolDirLocalIndex indicates an encapsulation of IPv4, this object is encoded as a length octet of 4, followed by the 4 octets of the IPv4 address, in network byte order. If the associated tpmAggrReportCntrlAggrType is equal to application(4) or client(2), then this object will be a null string and will be encoded simply as a length octet of 0.')
tpmAggrReportApmNameClientID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 5), RmonClientID())
if mibBuilder.loadTexts: tpmAggrReportApmNameClientID.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportApmNameClientID.setDescription('A unique ID assigned to the machine represented by this mapping. This ID is assigned by the agent using an implementation-specific algorithm.')
tpmAggrReportStatN = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatN.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatN.setDescription('The count of the total number of data points for the specified metric. This number always represents the total size of the statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results for one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmAggrReportOverflowStatN = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportOverflowStatN.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportOverflowStatN.setDescription('The number of times the associated tpmAggrReportStatN counter has overflowed. Note that this object will only be instantiated if the associated tpmAggrReportHCStatN object is also instantiated for a particular dataSource.')
tpmAggrReportHCStatN = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportHCStatN.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportHCStatN.setDescription('The high-capacity version of tpmAggrReportStatN. Note that this object will only be instantiated if the agent supports high-capacity monitoring for a particular dataSource.')
tpmAggrReportStatSumX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 9), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatSumX.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatSumX.setDescription('The sum of all the data point values for the specified metric. This number always represents the total values of the statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmAggrReportOverflowStatSumX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 10), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumX.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumX.setDescription('The number of times the associated tpmAggrReportStatSumX counter has overflowed. Note that this object will only be instantiated if the associated tpmAggrReportHCStatSumX object is also instantiated for a particular dataSource.')
tpmAggrReportHCStatSumX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 11), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportHCStatSumX.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportHCStatSumX.setDescription('The high-capacity version of tpmAggrReportStatSumX. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmAggrReportStatMaximum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 12), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatMaximum.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatMaximum.setDescription('The single maximum data point value observed during the study period for the specified metric. This number always represents the maximum value of any single statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmAggrReportStatMinimum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 13), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatMinimum.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatMinimum.setDescription('The single minimum data point value observed during the study period for the specified metric. This number always represents the minimum value of any single statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmAggrReportStatSumSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 14), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatSumSq.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatSumSq.setDescription('The sum of all the squared data point values for the specified metric. This number always represents the total of the squared values of the statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmAggrReportOverflowStatSumSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 15), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumSq.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumSq.setDescription('The number of times the associated tpmAggrReportStatSumSq counter has overflowed. Note that this object will only be instantiated if the associated tpmAggrReportHCStatSumSq object is also instantiated for a particular dataSource.')
tpmAggrReportHCStatSumSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 16), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportHCStatSumSq.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportHCStatSumSq.setDescription('The high-capacity version of tpmAggrReportStatSumSq. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmAggrReportStatSumIX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 17), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatSumIX.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatSumIX.setDescription('For each interval, each data point is associated with a value I, I = 1..N where N is the number of data points; tpmAggrReportStatSumIX is the multiplication of the data point value with the current I. This value along with the other statistics values allow the calculation of the slope of the least-squares line through the data points.')
tpmAggrReportOverflowStatSumIX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 18), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumIX.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumIX.setDescription('The number of times the associated tpmAggrReportStatSumIX counter has overflowed. Note that this object will only be instantiated if the associated tpmAggrReportHCStatSumIX object is also instantiated for a particular dataSource.')
tpmAggrReportHCStatSumIX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 19), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportHCStatSumIX.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportHCStatSumIX.setDescription('The high-capacity version of tpmAggrReportStatSumIX. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmAggrReportStatSumIXSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 20), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportStatSumIXSq.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportStatSumIXSq.setDescription('For each interval, each data point is associated with a value I, I = 1..N where N is the number of data points; tpmAggrReportStatSumIXSq is the multiplication of the data point value with the current I. This value along with the other statistics values allow the calculation of the slope of the least-squares line through the data points.')
tpmAggrReportOverflowStatSumIXSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 21), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumIXSq.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportOverflowStatSumIXSq.setDescription('The number of times the associated tpmAggrReportStatSumIXSq counter has overflowed. Note that this object will only be instantiated if the associated tpmAggrReportHCStatSumIXSq object is also instantiated for a particular dataSource.')
tpmAggrReportHCStatSumIXSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 2, 1, 22), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmAggrReportHCStatSumIXSq.setStatus('current')
if mibBuilder.loadTexts: tpmAggrReportHCStatSumIXSq.setDescription('The high-capacity version of tpmAggrReportStatSumIXSq. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmCurReportTable = MibTable((1, 3, 6, 1, 2, 1, 16, 30, 2, 3), )
if mibBuilder.loadTexts: tpmCurReportTable.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportTable.setDescription("This table will contain entries associated with an apmReportControlEntry that consitute a current 'snapshot' of the metrics being collected in association with a set of TPM-related application transactions. This table contains all sub-flow metrics for transactions that have been started but have not yet finished (i.e., current) and a history of those that have finished (i.e., completed). It may not always be obvious from the context whether a transaction is currently in-progress or has been completed. Therefore, the completion status of a transaction is indicated by the value of the tpmCurReportCompletion object.")
tpmCurReportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1), ).setIndexNames((0, "TPM-MIB", "tpmAggrReportCntrlIndex"), (0, "TPM-MIB", "tpmCurReportAppLocalIndex"), (0, "TPM-MIB", "tpmCurReportTransMetricIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "TPM-MIB", "tpmCurReportServerAddress"), (0, "TPM-MIB", "tpmCurReportApmNameClientID"), (0, "TPM-MIB", "tpmCurReportApmTransactionID"))
if mibBuilder.loadTexts: tpmCurReportEntry.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportEntry.setDescription('A conceptual row in the tpmCurReportTable. The tpmAggrReportControlIndex value in the index identifies the tpmAggrReportCntrlEntry on whose behalf this entry was created. The tpmCurReportAppLocalIndex value in the index identifies the application protocol that is being reported. The protocolDirLocalIndex value in the index identifies the network layer protocol of the tpmAggrReportServerAddress. When the associated tpmAggrReportCntrlAggrType value is equal to applications(4), this value will equal 0. The tpmCurReportServerAddress value in the index identifies the network layer address of the server in traffic flows aggregated in this entry. The tpmCurReportCurrentApmNameClientID value in the index identifies the network layer address of the client in traffic flows aggregated in this entry. The tpmCurReportCurrentMetricIndex value in the index identifies the transported application protocol of the traffic flows aggregated in this entry. Note that the order of protocolDirLocalIndex variables is the opposite of that in the RMON2 MIB (application.network instead of network.application); the report entries are sorted by application first, server second, and client third. The tpmCurReportCntrIndex value in the index identifies the tpmAggrReportCntrlEntry on whose behalf this entry was created. The tpmCurReportMetricIndex value in the index identifies the metric and protocol of the tpmCurReportServerAddress, via the tpmTransMetricDir table. An example of the indexing of this table is tpmCurReportStatisticN.3.34.262.18.4.128.2.6.6.3256521.29667')
tpmCurReportAppLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 1), AppLocalIndex())
if mibBuilder.loadTexts: tpmCurReportAppLocalIndex.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportAppLocalIndex.setDescription('The common application of the transactions reported in this entry.')
tpmCurReportTransMetricIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 2), TpmTransactionMetricIndex())
if mibBuilder.loadTexts: tpmCurReportTransMetricIndex.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportTransMetricIndex.setDescription('A unique index that identifies the transaction and metric associated with the statistics reported here.')
tpmCurReportServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)))
if mibBuilder.loadTexts: tpmCurReportServerAddress.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportServerAddress.setDescription('The network server address for this tpmCurReportEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of IPv4, this object is encoded as a length octet of 4, followed by the 4 octets of the IPv4 address, in network byte order.')
tpmCurReportApmNameClientID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 4), RmonClientID())
if mibBuilder.loadTexts: tpmCurReportApmNameClientID.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportApmNameClientID.setDescription('A unique ID assigned to the machine represented by this mapping. This ID is assigned by the agent using an implementation-specific algorithm.')
tpmCurReportApmTransactionID = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: tpmCurReportApmTransactionID.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportApmTransactionID.setDescription("A unique value for this transaction amongst other transactions sharing the same application, transaction-layer protocol and metric, and server and client addresses. Implementations may choose to use the value of the client's source port, when possible. If the tpmAggrReportCntrlApmCntrlIndex is non-zero, then this object is set to the corresponding apmTransactionID object in the APM-MIB developed in the IETF's RMONMIB WG.")
tpmCurReportMetricValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmCurReportMetricValue.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportMetricValue.setDescription('The current value of the metric being evaluated. For some transaction types this value may be 0, e.g., the current round-trip time for a DNS query. For other transaction types, this will represent the current value of a continuously measured metric, e.g., the current throughput of an FTP transaction.')
tpmCurReportCompletion = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("current", 1), ("completed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmCurReportCompletion.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportCompletion.setDescription('The status of this transaction. It is not always obvious from context whether a transaction is ongoing or completed. E.g., an ftp-GET transaction may last several minutes or hours, and a value found in the tpmCurReportMetricValue object lists to observed throughput for the transaction up to this point in time. The value of the tpmCurReportCompletion indicates whether the transaction has been completed.')
tpmCurReportSize = MibScalar((1, 3, 6, 1, 2, 1, 16, 30, 2, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tpmCurReportSize.setStatus('current')
if mibBuilder.loadTexts: tpmCurReportSize.setDescription("The maximum number of completed transactions desired to be retained in the tpmCurReportTable. If the agent doesn't have enough resources to retain this many, it will retain as many as possible. Regardless of this value, the agent must attempt to keep records for all current transactions it is monitoring. The agent should consider this value to give a hint as to how many transactions to save. This is not a hard limit, just a hint to a maximum value of interest. If this value is reduced by the management station, the agent can take note, it may free some records, or it may do nothing. The value of this object must persist across reboots.")
tpmExcpReportTable = MibTable((1, 3, 6, 1, 2, 1, 16, 30, 2, 5), )
if mibBuilder.loadTexts: tpmExcpReportTable.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportTable.setDescription('This table contains all sub-flow metrics for transactions that have been tagged by the apmExceptionTable filter as having had poor performance.')
tpmExcpReportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1), ).setIndexNames((0, "APM-MIB", "apmAppDirAppLocalIndex"), (0, "APM-MIB", "apmAppDirResponsivenessType"), (0, "APM-MIB", "apmExceptionIndex"), (0, "TPM-MIB", "tpmExcpReportTransMetricIndex"))
if mibBuilder.loadTexts: tpmExcpReportEntry.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportEntry.setDescription('A conceptual row in the tpmExcpReportTable. This table contains aggregated information associated with exceptions counted in the apmExceptionTable. The information is aggregated in a manner identical to the aggregation in the tpmAggrReportTable, with the exception that data only from transactions associated with a flagged application is included. The indexing into this table follows the indexing in the APM-MIB but adds the tpmTransMetricIndex to identify the sub-application transaction and metric pair.')
tpmExcpReportTransMetricIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 1), TpmTransactionMetricIndex())
if mibBuilder.loadTexts: tpmExcpReportTransMetricIndex.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportTransMetricIndex.setDescription('A unique index that identifies the transaction and metric associated with the data reported here.')
tpmExcpReportStatN = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatN.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatN.setDescription('The count of the total number of data points for the specified metric. This number always represents the total size of the statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmExcpReportOverflowStatN = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportOverflowStatN.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportOverflowStatN.setDescription('The number of times the associated tpmExcpReportStatN counter has overflowed. Note that this object will only be instantiated if the associated tpmExcpReportHCStatN object is also instantiated for a particular dataSource.')
tpmExcpReportHCStatN = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportHCStatN.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportHCStatN.setDescription('The high-capacity version of tpmExcpReportStatN. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmExcpReportStatSumX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatSumX.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatSumX.setDescription('The sum of all the data point values for the specified metric. This number always represents the total values of the statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmExcpReportOverflowStatSumX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumX.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumX.setDescription('The number of times the associated tpmExcpReportStatSumX counter has overflowed. Note that this object will only be instantiated if the associated tpmExcpReportHCStatSumX object is also instantiated for a particular dataSource.')
tpmExcpReportHCStatSumX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 7), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportHCStatSumX.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportHCStatSumX.setDescription('The high-capacity version of tpmExcpReportStatSumX. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmExcpReportStatMaximum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 8), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatMaximum.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatMaximum.setDescription('The single maximum data point value observed during the study period for the specified metric. This number always represents the maximum value of any single statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmExcpReportStatMinimum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 9), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatMinimum.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatMinimum.setDescription('The single minimum data point value observed during the study period for the specified metric. This number always represents the minimum value of any single statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmExcpReportStatSumSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 10), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatSumSq.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatSumSq.setDescription('The sum of all the squared data point values for the specified metric. This number always represents the total of the squared values of the statistical datum analyzed. Each metric specifies the exact meaning of this object. This value represents the results of one metric and is related directly to the specific parameters of the metric and the Server and Client addresses involved.')
tpmExcpReportOverflowStatSumSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 11), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumSq.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumSq.setDescription('The number of times the associated tpmExcpReportStatSumSq counter has overflowed. Note that this object will only be instantiated if the associated tpmExcpReportHCStatSumSq object is also instantiated for a particular dataSource.')
tpmExcpReportHCStatSumSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 12), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportHCStatSumSq.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportHCStatSumSq.setDescription('The high-capacity version of tpmExcpReportStatSumSq. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmExcpReportStatSumIX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 13), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatSumIX.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatSumIX.setDescription('For each interval, each data point is associated with a value I, I = 1..N where N is the number of data points; tpmExcpReportStatSumIX is the multiplication of the data point value with the current I. This value along with the other statistics values allow the calculation of the slope of the least-squares line through the data points.')
tpmExcpReportOverflowStatSumIX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 14), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumIX.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumIX.setDescription('The number of times the associated tpmExcpReportStatSumIX counter has overflowed. Note that this object will only be instantiated if the associated tpmExcpReportHCStatSumIX object is also instantiated for a particular dataSource.')
tpmExcpReportHCStatSumIX = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 15), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportHCStatSumIX.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportHCStatSumIX.setDescription('The high-capacity version of tpmExcpReportStatSumIX. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmExcpReportStatSumIXSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 16), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportStatSumIXSq.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportStatSumIXSq.setDescription('For each interval, each data point is associated with a value I, I = 1..N where N is the number of data points; tpmExcpReportStatSumIXSq is the multiplication of the data point value with the current I. This value along with the other statistics values allow the calculation of the slope of the least-squares line through the data points.')
tpmExcpReportOverflowStatSumIXSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 17), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumIXSq.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportOverflowStatSumIXSq.setDescription('The number of times the associated tpmExcpReportStatSumIXSq counter has overflowed. Note that this object will only be instantiated if the associated tpmExcpReportHCStatSumIXSq object is also instantiated for a particular dataSource.')
tpmExcpReportHCStatSumIXSq = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 30, 2, 5, 1, 18), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpmExcpReportHCStatSumIXSq.setStatus('current')
if mibBuilder.loadTexts: tpmExcpReportHCStatSumIXSq.setDescription('The high-capacity version of tpmExcpReportStatSumIXSq. Note that this object will only be instantiated if the agent supports High Capacity monitoring for a particular dataSource.')
tpmMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 30, 3, 1))
tpmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 30, 3, 2))
tpmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 30, 3, 1, 1)).setObjects(("TPM-MIB", "tpmCapabilitiesGroup"), ("TPM-MIB", "tpmAggregateReportsGroup"), ("TPM-MIB", "tpmCurrentReportsGroup"), ("TPM-MIB", "tpmExceptionReportsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmMIBCompliance = tpmMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: tpmMIBCompliance.setDescription('Describes the requirements for conformance to the TPM-MIB. This compliance statement defines the following TPM-MIB implementation: - tpmCapabilitiesGroup (minimum) - tpmAggregateReportsGroup (minimum) - tpmCurrentReportsGroup (optional) - tpmExceptionReportsGroup (optional). In order to implement the (optional) tpmExceptionReportsGroup, it is necessary to implement pieces of the APM-MIB as described in the tpmApmMIBCompliance MODULE below. Further, in the event that the TPM-MIB is used to provide a drill-down capability, which is the true value of this MIB, then the tpmApmReportControlGroup must be implemented.')
tpmCurrentReportsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 30, 3, 1, 2)).setObjects(("TPM-MIB", "tpmCapabilitiesGroup"), ("TPM-MIB", "tpmAggregateReportsGroup"), ("TPM-MIB", "tpmCurrentReportsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmCurrentReportsCompliance = tpmCurrentReportsCompliance.setStatus('current')
if mibBuilder.loadTexts: tpmCurrentReportsCompliance.setDescription('This defines the Current Reports compliance. This is useful when information on in-progress and historical transaction-level data is desired.')
tpmExceptionReportsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 30, 3, 1, 3)).setObjects(("TPM-MIB", "tpmCapabilitiesGroup"), ("TPM-MIB", "tpmAggregateReportsGroup"), ("TPM-MIB", "tpmExceptionReportsGroup"), ("APM-MIB", "apmReportGroup"), ("APM-MIB", "apmExceptionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmExceptionReportsCompliance = tpmExceptionReportsCompliance.setStatus('current')
if mibBuilder.loadTexts: tpmExceptionReportsCompliance.setDescription('This defines the Exception Reports compliance. This is useful when information on transactions whose performance is deemed out-of-bounds.')
tpmCapabilitiesGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 30, 3, 2, 1)).setObjects(("TPM-MIB", "tpmClockResolution"), ("TPM-MIB", "tpmClockMaxSkew"), ("TPM-MIB", "tpmClockSource"), ("TPM-MIB", "tpmTransMetricDirLastChange"), ("TPM-MIB", "tpmTransMetricProtocolIndex"), ("TPM-MIB", "tpmTransMetricMetricIndex"), ("TPM-MIB", "tpmTransMetricDirConfig"), ("TPM-MIB", "tpmMetricDefType"), ("TPM-MIB", "tpmMetricDefDirType"), ("TPM-MIB", "tpmMetricDefName"), ("TPM-MIB", "tpmMetricDefReference"), ("TPM-MIB", "tpmMetricDefGlobalID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmCapabilitiesGroup = tpmCapabilitiesGroup.setStatus('current')
if mibBuilder.loadTexts: tpmCapabilitiesGroup.setDescription('The tpmCapabilitiesGroup specifies various capabilities associated with the monitoring agent.')
tpmAggregateReportsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 30, 3, 2, 2)).setObjects(("TPM-MIB", "tpmAggrReportCntrlApmCntrlIndex"), ("TPM-MIB", "tpmAggrReportCntrlDataSource"), ("TPM-MIB", "tpmAggrReportCntrlAggrType"), ("TPM-MIB", "tpmAggrReportCntrlInterval"), ("TPM-MIB", "tpmAggrReportCntrlReqSize"), ("TPM-MIB", "tpmAggrReportCntrlGrantedSize"), ("TPM-MIB", "tpmAggrReportCntrlReqReports"), ("TPM-MIB", "tpmAggrReportCntrlGrantedReports"), ("TPM-MIB", "tpmAggrReportCntrlStartTime"), ("TPM-MIB", "tpmAggrReportCntrlReportNumber"), ("TPM-MIB", "tpmAggrReportCntrlInsertsDenied"), ("TPM-MIB", "tpmAggrReportCntrlDroppedFrames"), ("TPM-MIB", "tpmAggrReportCntrlOwner"), ("TPM-MIB", "tpmAggrReportCntrlStorageType"), ("TPM-MIB", "tpmAggrReportCntrlStatus"), ("TPM-MIB", "tpmAggrReportStatN"), ("TPM-MIB", "tpmAggrReportOverflowStatN"), ("TPM-MIB", "tpmAggrReportHCStatN"), ("TPM-MIB", "tpmAggrReportStatSumX"), ("TPM-MIB", "tpmAggrReportOverflowStatSumX"), ("TPM-MIB", "tpmAggrReportHCStatSumX"), ("TPM-MIB", "tpmAggrReportStatMaximum"), ("TPM-MIB", "tpmAggrReportStatMinimum"), ("TPM-MIB", "tpmAggrReportStatSumSq"), ("TPM-MIB", "tpmAggrReportOverflowStatSumSq"), ("TPM-MIB", "tpmAggrReportHCStatSumSq"), ("TPM-MIB", "tpmAggrReportStatSumIX"), ("TPM-MIB", "tpmAggrReportOverflowStatSumIX"), ("TPM-MIB", "tpmAggrReportHCStatSumIX"), ("TPM-MIB", "tpmAggrReportStatSumIXSq"), ("TPM-MIB", "tpmAggrReportOverflowStatSumIXSq"), ("TPM-MIB", "tpmAggrReportHCStatSumIXSq"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmAggregateReportsGroup = tpmAggregateReportsGroup.setStatus('current')
if mibBuilder.loadTexts: tpmAggregateReportsGroup.setDescription('The tpmAggregateReportsGroup provides control and reporting of aggregate measurement statistics.')
tpmCurrentReportsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 30, 3, 2, 3)).setObjects(("TPM-MIB", "tpmCurReportMetricValue"), ("TPM-MIB", "tpmCurReportCompletion"), ("TPM-MIB", "tpmCurReportSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmCurrentReportsGroup = tpmCurrentReportsGroup.setStatus('current')
if mibBuilder.loadTexts: tpmCurrentReportsGroup.setDescription('The tpmCurrentReportsGroup contains metric information relating to ongoing measurements as well as historical values.')
tpmExceptionReportsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 30, 3, 2, 4)).setObjects(("TPM-MIB", "tpmExcpReportStatN"), ("TPM-MIB", "tpmExcpReportOverflowStatN"), ("TPM-MIB", "tpmExcpReportHCStatN"), ("TPM-MIB", "tpmExcpReportStatSumX"), ("TPM-MIB", "tpmExcpReportOverflowStatSumX"), ("TPM-MIB", "tpmExcpReportHCStatSumX"), ("TPM-MIB", "tpmExcpReportStatMaximum"), ("TPM-MIB", "tpmExcpReportStatMinimum"), ("TPM-MIB", "tpmExcpReportStatSumSq"), ("TPM-MIB", "tpmExcpReportOverflowStatSumSq"), ("TPM-MIB", "tpmExcpReportHCStatSumSq"), ("TPM-MIB", "tpmExcpReportStatSumIX"), ("TPM-MIB", "tpmExcpReportOverflowStatSumIX"), ("TPM-MIB", "tpmExcpReportHCStatSumIX"), ("TPM-MIB", "tpmExcpReportStatSumIXSq"), ("TPM-MIB", "tpmExcpReportOverflowStatSumIXSq"), ("TPM-MIB", "tpmExcpReportHCStatSumIXSq"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tpmExceptionReportsGroup = tpmExceptionReportsGroup.setStatus('current')
if mibBuilder.loadTexts: tpmExceptionReportsGroup.setDescription('The tpmExceptionReportsGroup reports sub-application level statistics associated with errant applications.')
mibBuilder.exportSymbols("TPM-MIB", tpmMetricDefName=tpmMetricDefName, tpmAggregateReportsGroup=tpmAggregateReportsGroup, tpmAggrReportCntrlApmCntrlIndex=tpmAggrReportCntrlApmCntrlIndex, tpmAggrReportHCStatSumIX=tpmAggrReportHCStatSumIX, tpmExcpReportOverflowStatSumSq=tpmExcpReportOverflowStatSumSq, tpmAggrReportCntrlGrantedSize=tpmAggrReportCntrlGrantedSize, tpmGroups=tpmGroups, tpmAggrReportApmNameClientID=tpmAggrReportApmNameClientID, tpmAggrReportHCStatSumX=tpmAggrReportHCStatSumX, tpmExcpReportHCStatSumSq=tpmExcpReportHCStatSumSq, tpmExcpReportStatMinimum=tpmExcpReportStatMinimum, tpmExcpReportOverflowStatN=tpmExcpReportOverflowStatN, tpmMetricDefEntry=tpmMetricDefEntry, tpmCurReportApmTransactionID=tpmCurReportApmTransactionID, tpmAggrReportIndex=tpmAggrReportIndex, tpmAggrReportHCStatSumSq=tpmAggrReportHCStatSumSq, tpmExceptionReportsCompliance=tpmExceptionReportsCompliance, tpmMetricDefinitionID=tpmMetricDefinitionID, tpmExcpReportStatMaximum=tpmExcpReportStatMaximum, tpmExceptionReportsGroup=tpmExceptionReportsGroup, tpmCurReportTransMetricIndex=tpmCurReportTransMetricIndex, tpmClockSource=tpmClockSource, tpmExcpReportOverflowStatSumX=tpmExcpReportOverflowStatSumX, tpmAggrReportCntrlStorageType=tpmAggrReportCntrlStorageType, tpmExcpReportStatSumIX=tpmExcpReportStatSumIX, tpmExcpReportOverflowStatSumIXSq=tpmExcpReportOverflowStatSumIXSq, tpmAggrReportCntrlReqSize=tpmAggrReportCntrlReqSize, tpmCurReportAppLocalIndex=tpmCurReportAppLocalIndex, tpmMIBCompliance=tpmMIBCompliance, TpmTransactionMetricIndex=TpmTransactionMetricIndex, tpmAggrReportOverflowStatSumX=tpmAggrReportOverflowStatSumX, tpmCurrentReportsCompliance=tpmCurrentReportsCompliance, tpmAggrReportCntrlStatus=tpmAggrReportCntrlStatus, tpmMetricDefReference=tpmMetricDefReference, tpmAggrReportStatSumIX=tpmAggrReportStatSumIX, tpmAggrReportHCStatN=tpmAggrReportHCStatN, tpmMIB=tpmMIB, tpmAggrReportEntry=tpmAggrReportEntry, tpmReports=tpmReports, tpmTransMetricDirEntry=tpmTransMetricDirEntry, tpmClockResolution=tpmClockResolution, tpmAggrReportCntrlStartTime=tpmAggrReportCntrlStartTime, tpmCurrentReportsGroup=tpmCurrentReportsGroup, tpmTransMetricMetricIndex=tpmTransMetricMetricIndex, tpmCapabilities=tpmCapabilities, tpmAggrReportStatSumIXSq=tpmAggrReportStatSumIXSq, tpmTransMetricDirLastChange=tpmTransMetricDirLastChange, tpmAggrReportOverflowStatSumIXSq=tpmAggrReportOverflowStatSumIXSq, tpmCurReportTable=tpmCurReportTable, tpmAggrReportCntrlIndex=tpmAggrReportCntrlIndex, tpmAggrReportTransMetricIndex=tpmAggrReportTransMetricIndex, tpmMetricDefDirType=tpmMetricDefDirType, tpmExcpReportStatSumSq=tpmExcpReportStatSumSq, tpmExcpReportHCStatSumIX=tpmExcpReportHCStatSumIX, tpmExcpReportHCStatSumIXSq=tpmExcpReportHCStatSumIXSq, tpmMIBCompliances=tpmMIBCompliances, tpmAggrReportServerAddress=tpmAggrReportServerAddress, tpmAggrReportCntrlGrantedReports=tpmAggrReportCntrlGrantedReports, tpmAggrReportCntrlTable=tpmAggrReportCntrlTable, tpmAggrReportHCStatSumIXSq=tpmAggrReportHCStatSumIXSq, PYSNMP_MODULE_ID=tpmMIB, tpmExcpReportTransMetricIndex=tpmExcpReportTransMetricIndex, tpmAggrReportOverflowStatSumIX=tpmAggrReportOverflowStatSumIX, tpmAggrReportOverflowStatSumSq=tpmAggrReportOverflowStatSumSq, tpmConformance=tpmConformance, tpmCurReportCompletion=tpmCurReportCompletion, tpmExcpReportHCStatSumX=tpmExcpReportHCStatSumX, tpmMetricDefGlobalID=tpmMetricDefGlobalID, tpmCurReportMetricValue=tpmCurReportMetricValue, tpmExcpReportStatSumX=tpmExcpReportStatSumX, tpmAggrReportStatSumSq=tpmAggrReportStatSumSq, tpmExcpReportEntry=tpmExcpReportEntry, tpmAggrReportStatMinimum=tpmAggrReportStatMinimum, tpmAggrReportCntrlDataSource=tpmAggrReportCntrlDataSource, tpmCurReportSize=tpmCurReportSize, tpmExcpReportStatSumIXSq=tpmExcpReportStatSumIXSq, tpmClockMaxSkew=tpmClockMaxSkew, tpmAggrReportCntrlAggrType=tpmAggrReportCntrlAggrType, tpmAggrReportCntrlInsertsDenied=tpmAggrReportCntrlInsertsDenied, tpmTransMetricDirConfig=tpmTransMetricDirConfig, tpmCurReportEntry=tpmCurReportEntry, tpmAggrReportCntrlInterval=tpmAggrReportCntrlInterval, tpmAggrReportStatSumX=tpmAggrReportStatSumX, tpmCurReportServerAddress=tpmCurReportServerAddress, tpmTransMetricProtocolIndex=tpmTransMetricProtocolIndex, tpmTransMetricIndex=tpmTransMetricIndex, tpmTransMetricAppLocalIndex=tpmTransMetricAppLocalIndex, tpmAggrReportOverflowStatN=tpmAggrReportOverflowStatN, TpmMetricDefID=TpmMetricDefID, tpmExcpReportHCStatN=tpmExcpReportHCStatN, tpmAggrReportStatN=tpmAggrReportStatN, tpmAggrReportCntrlOwner=tpmAggrReportCntrlOwner, tpmAggrReportCntrlEntry=tpmAggrReportCntrlEntry, tpmAggrReportAppLocalIndex=tpmAggrReportAppLocalIndex, tpmAggrReportTable=tpmAggrReportTable, tpmAggrReportCntrlReportNumber=tpmAggrReportCntrlReportNumber, tpmCurReportApmNameClientID=tpmCurReportApmNameClientID, tpmExcpReportTable=tpmExcpReportTable, tpmExcpReportOverflowStatSumIX=tpmExcpReportOverflowStatSumIX, tpmCapabilitiesGroup=tpmCapabilitiesGroup, tpmAggrReportCntrlDroppedFrames=tpmAggrReportCntrlDroppedFrames, tpmExcpReportStatN=tpmExcpReportStatN, tpmAggrReportStatMaximum=tpmAggrReportStatMaximum, tpmAggrReportCntrlReqReports=tpmAggrReportCntrlReqReports, tpmMetricDefTable=tpmMetricDefTable, tpmTransMetricDirTable=tpmTransMetricDirTable, tpmMetricDefType=tpmMetricDefType)

#
# PySNMP MIB module HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:25:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
TimeTicks, MibIdentifier, NotificationType, IpAddress, Gauge32, Counter32, Bits, Unsigned32, enterprises, ModuleIdentity, Integer32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibIdentifier", "NotificationType", "IpAddress", "Gauge32", "Counter32", "Bits", "Unsigned32", "enterprises", "ModuleIdentity", "Integer32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
healthMonitor = ModuleIdentity((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11))
healthMonitor.setRevisions(('1999-07-20 15:05', '1900-09-18 14:35',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: healthMonitor.setRevisionsDescriptions(('Rev 1.0 20th July 1999 15:05, Initial version Of MIB.', 'Rev 1.1 18th Sep 2000 14:35. Changed the type of mibnode hmDNLCHits and hmDNLCMisses from Integer32 to Unsigned32.',))
if mibBuilder.loadTexts: healthMonitor.setLastUpdated('0009181435Z')
if mibBuilder.loadTexts: healthMonitor.setOrganization('Sun Microsystems Inc.')
if mibBuilder.loadTexts: healthMonitor.setContactInfo(' Sun Microsystems Inc. Customer Support Postal: 901 San Antonio Road Palo Alto, CA-94303-4900 USA Tel: 650-960-1300 E-mail: service@sun.com')
if mibBuilder.loadTexts: healthMonitor.setDescription('Health Monitor allows to monitor the overall state of the machine, including the state of the disk, networks, RAM, and so on. This module uses a set of performance rules to determine valid component states.')
sun = MibIdentifier((1, 3, 6, 1, 4, 1, 42))
prod = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2))
sunsymon = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12))
agent = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2))
modules = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2))
hmSwap = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 1))
hmKernelcontention = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 2))
hmNFS = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3))
hmCPU = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 4))
hmDiskGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDiskName"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDiskAliasName"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmAvgWaitTransactions"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDiskBusyPcnt"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmAvgDiskSvcTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDiskGroup = hmDiskGroup.setStatus('current')
if mibBuilder.loadTexts: hmDiskGroup.setDescription('Disk related statistics.')
hmRAM = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 6))
hmKMEM = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 7))
hmDNLC = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 8))
hmSwapSpaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 1, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmAvailableSwapSpace"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmReservedSwapSpace"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmAllocatedSwapSpace"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmUsedSwapSpace"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmSwapSpaceGroup = hmSwapSpaceGroup.setStatus('current')
if mibBuilder.loadTexts: hmSwapSpaceGroup.setDescription('Swap space related statistics.')
hmAvailableSwapSpace = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 1, 1, 1), Integer32()).setUnits('kB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAvailableSwapSpace.setStatus('current')
if mibBuilder.loadTexts: hmAvailableSwapSpace.setDescription('The total swap space (in 1024 byte blocks) that is currently available for reservation and allocation.')
hmReservedSwapSpace = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 1, 1, 2), Integer32()).setUnits('kB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmReservedSwapSpace.setStatus('current')
if mibBuilder.loadTexts: hmReservedSwapSpace.setDescription('The total amount of swap space (in 1024 byte blocks) that is not currently allocated, but is claimed by memory mappings for possible future use.')
hmAllocatedSwapSpace = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 1, 1, 3), Integer32()).setUnits('kB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAllocatedSwapSpace.setStatus('current')
if mibBuilder.loadTexts: hmAllocatedSwapSpace.setDescription('The total amount of swap space (in 1024 byte blocks) currently allocated for use.')
hmUsedSwapSpace = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 1, 1, 4), Integer32()).setUnits('kB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmUsedSwapSpace.setStatus('current')
if mibBuilder.loadTexts: hmUsedSwapSpace.setDescription('The total amount of swap space (in 1024 byte blocks) that is either allocated or reserved.')
hmMutexGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 2, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmSpinsOnMutexes"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotNumOfCPUs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmMutexGroup = hmMutexGroup.setStatus('current')
if mibBuilder.loadTexts: hmMutexGroup.setDescription('Mutex related statistics.')
hmSpinsOnMutexes = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSpinsOnMutexes.setStatus('current')
if mibBuilder.loadTexts: hmSpinsOnMutexes.setDescription('Sum of spins on mutexes (lock not acquired on first try) for all CPUs.')
hmTotNumOfCPUs = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotNumOfCPUs.setStatus('current')
if mibBuilder.loadTexts: hmTotNumOfCPUs.setDescription('Total number of CPUs.')
hmNFSClientRPCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotRPCCalls"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotBadRPCCalls"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotRPCRetransmissions"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotBadRPCReplies"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotRPCCallsTimedOut"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotNumOfAuthRefresh"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotFailedCallsBV"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTimers"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotMemAllocFails"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotSendFails"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmNFSClientRPCGroup = hmNFSClientRPCGroup.setStatus('current')
if mibBuilder.loadTexts: hmNFSClientRPCGroup.setDescription('Client RPC call-related statistics.')
hmTotRPCCalls = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotRPCCalls.setStatus('current')
if mibBuilder.loadTexts: hmTotRPCCalls.setDescription('Total number of RPC calls received.')
hmTotBadRPCCalls = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotBadRPCCalls.setStatus('current')
if mibBuilder.loadTexts: hmTotBadRPCCalls.setDescription('Total number of calls rejected by the RPC layer.')
hmTotRPCRetransmissions = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotRPCRetransmissions.setStatus('current')
if mibBuilder.loadTexts: hmTotRPCRetransmissions.setDescription('Total number of calls retransmitted due to a timeout.')
hmTotBadRPCReplies = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotBadRPCReplies.setStatus('current')
if mibBuilder.loadTexts: hmTotBadRPCReplies.setDescription('Number of replies from server that do not correspond to any outside call.')
hmTotRPCCallsTimedOut = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotRPCCallsTimedOut.setStatus('current')
if mibBuilder.loadTexts: hmTotRPCCallsTimedOut.setDescription('Number of calls timed out while waiting for a reply from server.')
hmTotNumOfAuthRefresh = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotNumOfAuthRefresh.setStatus('current')
if mibBuilder.loadTexts: hmTotNumOfAuthRefresh.setDescription('Number of times authentication information was refreshed.')
hmTotFailedCallsBV = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotFailedCallsBV.setStatus('current')
if mibBuilder.loadTexts: hmTotFailedCallsBV.setDescription('Number of calls failed due to a bad verifier in response.')
hmTimers = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTimers.setStatus('current')
if mibBuilder.loadTexts: hmTimers.setDescription('Number of times calculated time-out exceeds minimum specified timeout value for a call.')
hmTotMemAllocFails = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotMemAllocFails.setStatus('current')
if mibBuilder.loadTexts: hmTotMemAllocFails.setDescription('Number of failures to allocate memory.')
hmTotSendFails = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotSendFails.setStatus('current')
if mibBuilder.loadTexts: hmTotSendFails.setDescription('Number of failures where client is not able to send the packets for any reason.')
hmCPUProcInStatesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 4, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotProcInRunQueue"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotProcBlocked"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmTotProcReadyInSwap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmCPUProcInStatesGroup = hmCPUProcInStatesGroup.setStatus('current')
if mibBuilder.loadTexts: hmCPUProcInStatesGroup.setDescription('Statistics related to the number of processes in different states.')
hmTotProcInRunQueue = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotProcInRunQueue.setStatus('current')
if mibBuilder.loadTexts: hmTotProcInRunQueue.setDescription('Number of processes in the run queue.')
hmTotProcBlocked = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotProcBlocked.setStatus('current')
if mibBuilder.loadTexts: hmTotProcBlocked.setDescription('Number of processes blocked for resources.')
hmTotProcReadyInSwap = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTotProcReadyInSwap.setStatus('current')
if mibBuilder.loadTexts: hmTotProcReadyInSwap.setDescription('Number of processes runnable but swapped.')
hmDiskTable = MibTable((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1), )
if mibBuilder.loadTexts: hmDiskTable.setStatus('current')
if mibBuilder.loadTexts: hmDiskTable.setDescription('Table of information for all the disks installed on the system.')
hmDiskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1, 1), ).setIndexNames((0, "HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDiskName"))
if mibBuilder.loadTexts: hmDiskEntry.setStatus('current')
if mibBuilder.loadTexts: hmDiskEntry.setDescription('Monitoring information for one disk on the system.')
hmDiskName = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDiskName.setStatus('current')
if mibBuilder.loadTexts: hmDiskName.setDescription('Name of the disk.')
hmDiskAliasName = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDiskAliasName.setStatus('current')
if mibBuilder.loadTexts: hmDiskAliasName.setDescription('Name of the disk alias (for example, c0t0d0).')
hmAvgWaitTransactions = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAvgWaitTransactions.setStatus('current')
if mibBuilder.loadTexts: hmAvgWaitTransactions.setDescription('Average number of transactions waiting for service.')
hmDiskBusyPcnt = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1, 1, 4), DisplayString()).setUnits('%').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDiskBusyPcnt.setStatus('current')
if mibBuilder.loadTexts: hmDiskBusyPcnt.setDescription('Percent of time the disk is busy.')
hmAvgDiskSvcTime = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 5, 1, 1, 5), DisplayString()).setUnits('msec').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAvgDiskSvcTime.setStatus('current')
if mibBuilder.loadTexts: hmAvgDiskSvcTime.setDescription('Average service time.')
hmRamMemoryPagingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 6, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmHandspread"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmPageScanRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmRamMemoryPagingGroup = hmRamMemoryPagingGroup.setStatus('current')
if mibBuilder.loadTexts: hmRamMemoryPagingGroup.setDescription('Memory paging-related statistics.')
hmHandspread = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 6, 1, 1), Integer32()).setUnits('MB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmHandspread.setStatus('current')
if mibBuilder.loadTexts: hmHandspread.setDescription('The distance (in pages) between front and back pageout daemon hands. The pageout daemon manages two hands on the clock. The front hand moves through memory, clearing the reference bit, and stealing pages from processes that exceed the value maxrss. The back hand travels behind the front hand, freeing pages that have not been referenced since the front hand passed. If the pages have been modified, they are pushed to the swap space before being freed. After pageout examines a page of memory, the amount of time that is needed to reclaim the page increases as the distance increases between the two hands, and decreases as the scan rate rises.')
hmPageScanRate = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPageScanRate.setStatus('current')
if mibBuilder.loadTexts: hmPageScanRate.setDescription('Number of pages scanned per second.')
hmKmemStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 7, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmKmemErrors"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmKmemFreeMem"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmKmemStatisticsGroup = hmKmemStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: hmKmemStatisticsGroup.setDescription('Kernel-memory-related statistics.')
hmKmemErrors = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmKmemErrors.setStatus('current')
if mibBuilder.loadTexts: hmKmemErrors.setDescription('Total number of error occured related to kernel memory. These errors may be.. KMERR_MODIFIED: buffer modified after being fread KMERR_READZONE: readzone violation, write past end of buffer KMERR_BADADDR: invalid free KMERR_DUPFREE: duplicate free KMERR_BADBUFTAG: boundary tag corrupted etc.')
hmKmemFreeMem = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 7, 1, 2), Integer32()).setUnits('MB').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmKmemFreeMem.setStatus('current')
if mibBuilder.loadTexts: hmKmemFreeMem.setDescription('Total amount of free kernel memory in MB.')
hmDNLCStatGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 8, 1)).setObjects(("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDNLCHits"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDNLCMisses"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDNLCHitRate"), ("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", "hmDNLCRefRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDNLCStatGroup = hmDNLCStatGroup.setStatus('current')
if mibBuilder.loadTexts: hmDNLCStatGroup.setDescription('DNLC related statistics.')
hmDNLCHits = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 8, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDNLCHits.setStatus('current')
if mibBuilder.loadTexts: hmDNLCHits.setDescription('The number of times a name is looked up and is found in DNLC (Directory Name Lookup Cache).')
hmDNLCMisses = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 8, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDNLCMisses.setStatus('current')
if mibBuilder.loadTexts: hmDNLCMisses.setDescription('The number of times a name is looked up and is not found in DNLC (Directory Name Lookup Cache). ')
hmDNLCHitRate = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 8, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDNLCHitRate.setStatus('current')
if mibBuilder.loadTexts: hmDNLCHitRate.setDescription('The number of DNLC hits as a proportion of all DNLC lookups.')
hmDNLCRefRate = MibScalar((1, 3, 6, 1, 4, 1, 42, 2, 12, 2, 2, 11, 8, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDNLCRefRate.setStatus('current')
if mibBuilder.loadTexts: hmDNLCRefRate.setDescription('The number of times per second, the DNLC is looked up.')
mibBuilder.exportSymbols("HEALTH-MONITOR-SUNMANAGEMENTCENTER-MIB", hmAllocatedSwapSpace=hmAllocatedSwapSpace, hmSwapSpaceGroup=hmSwapSpaceGroup, hmTotBadRPCCalls=hmTotBadRPCCalls, prod=prod, hmTotNumOfAuthRefresh=hmTotNumOfAuthRefresh, hmDiskTable=hmDiskTable, hmRAM=hmRAM, hmReservedSwapSpace=hmReservedSwapSpace, healthMonitor=healthMonitor, hmTotRPCRetransmissions=hmTotRPCRetransmissions, hmNFS=hmNFS, hmTotProcBlocked=hmTotProcBlocked, hmDiskGroup=hmDiskGroup, hmPageScanRate=hmPageScanRate, hmHandspread=hmHandspread, hmCPU=hmCPU, hmTotRPCCallsTimedOut=hmTotRPCCallsTimedOut, hmDNLCHitRate=hmDNLCHitRate, hmSpinsOnMutexes=hmSpinsOnMutexes, hmAvgWaitTransactions=hmAvgWaitTransactions, hmDiskBusyPcnt=hmDiskBusyPcnt, hmKmemFreeMem=hmKmemFreeMem, hmDNLCHits=hmDNLCHits, hmSwap=hmSwap, sunsymon=sunsymon, hmDNLC=hmDNLC, hmDNLCMisses=hmDNLCMisses, modules=modules, hmUsedSwapSpace=hmUsedSwapSpace, hmNFSClientRPCGroup=hmNFSClientRPCGroup, hmDiskEntry=hmDiskEntry, hmDNLCRefRate=hmDNLCRefRate, hmTotSendFails=hmTotSendFails, hmKernelcontention=hmKernelcontention, hmTotProcInRunQueue=hmTotProcInRunQueue, hmDiskAliasName=hmDiskAliasName, hmAvgDiskSvcTime=hmAvgDiskSvcTime, hmKmemErrors=hmKmemErrors, hmDiskName=hmDiskName, hmTimers=hmTimers, hmRamMemoryPagingGroup=hmRamMemoryPagingGroup, sun=sun, hmTotBadRPCReplies=hmTotBadRPCReplies, hmDNLCStatGroup=hmDNLCStatGroup, hmTotMemAllocFails=hmTotMemAllocFails, hmTotProcReadyInSwap=hmTotProcReadyInSwap, hmMutexGroup=hmMutexGroup, hmKMEM=hmKMEM, hmTotRPCCalls=hmTotRPCCalls, hmCPUProcInStatesGroup=hmCPUProcInStatesGroup, PYSNMP_MODULE_ID=healthMonitor, hmTotNumOfCPUs=hmTotNumOfCPUs, hmAvailableSwapSpace=hmAvailableSwapSpace, hmKmemStatisticsGroup=hmKmemStatisticsGroup, agent=agent, hmTotFailedCallsBV=hmTotFailedCallsBV)

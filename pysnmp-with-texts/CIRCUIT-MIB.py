#
# PySNMP MIB module CIRCUIT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CIRCUIT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:49:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
circuit, coriolisMibs = mibBuilder.importSymbols("CORIOLIS-MIB", "circuit", "coriolisMibs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, IpAddress, Integer32, iso, Gauge32, Counter64, MibIdentifier, NotificationType, TimeTicks, Unsigned32, Counter32, Bits, NotificationType, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "IpAddress", "Integer32", "iso", "Gauge32", "Counter64", "MibIdentifier", "NotificationType", "TimeTicks", "Unsigned32", "Counter32", "Bits", "NotificationType", "ModuleIdentity")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
circuitMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 5812, 6, 1))
if mibBuilder.loadTexts: circuitMIB.setLastUpdated('0010300000Z')
if mibBuilder.loadTexts: circuitMIB.setOrganization('Coriolis Networks')
if mibBuilder.loadTexts: circuitMIB.setContactInfo(' Srivathsan Srinivasagopalan Postal: 330 Codman Hill Road, Boxboro MA, 01719. Tel: +1 978 264 1904 Fax: +1 978 264 1929 E-mail: sri@coriolisnet.com')
if mibBuilder.loadTexts: circuitMIB.setDescription(' The MIB module for transport channels ')
circuitLoadBalanceInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitLoadBalanceInterval.setStatus('current')
if mibBuilder.loadTexts: circuitLoadBalanceInterval.setDescription('The default load balancing schedule is to examine 1 circuit every 3 minutes at the GNE. Regardless of whether the circuit is moved to a better ring path or not, the next circuit is not examined until another 3 minutes (default) had expired. The duration of the load balance timer will be configurable from a range of 0 to 65535 seconds. Using a value of 0 will turn off load balancing.')
circuitLoadBalanceNumPerInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitLoadBalanceNumPerInterval.setStatus('current')
if mibBuilder.loadTexts: circuitLoadBalanceNumPerInterval.setDescription('Indicates the number of circuits being loadbalanced in a fixed interval. The maximum value is 10 circuits per second.')
circuitOldIpAddrToSwap = MibScalar((1, 3, 6, 1, 4, 1, 5812, 6, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitOldIpAddrToSwap.setStatus('current')
if mibBuilder.loadTexts: circuitOldIpAddrToSwap.setDescription('When a chassis running several circuits has to be moved to a new location with a new different IpAddress, then all the associated circuits has to be properly modified with the new IpAddress. This object will specify the old-IpAddress. This process is almost transparent to the user, but, he will notice traffic loss due to the circuits being brought down and up.')
circuitNewIpAddrToSwap = MibScalar((1, 3, 6, 1, 4, 1, 5812, 6, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitNewIpAddrToSwap.setStatus('current')
if mibBuilder.loadTexts: circuitNewIpAddrToSwap.setDescription('When a chassis running several circuits has to be moved to a new location with a new different IpAddress, then all the associated circuits has to be properly modified with the new IpAddress. This object will specify the old-IpAddress. This process is almost transparent to the user, but, he will notice traffic loss due to the circuits being brought down and up.')
circuitEventInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 6, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitEventInterval.setStatus('current')
if mibBuilder.loadTexts: circuitEventInterval.setDescription('For any circuit related events, events are generated at a specific time interval. circuitEventInterval specifies that. The default value is 1 second.')
circuitEventNumPerInterval = MibScalar((1, 3, 6, 1, 4, 1, 5812, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitEventNumPerInterval.setStatus('current')
if mibBuilder.loadTexts: circuitEventNumPerInterval.setDescription('This object specifies the number of events generated per interval. The default is 10 per second.')
circuitTable = MibTable((1, 3, 6, 1, 4, 1, 5812, 6, 8), )
if mibBuilder.loadTexts: circuitTable.setStatus('current')
if mibBuilder.loadTexts: circuitTable.setDescription('A table containing information about the transport channels in the system')
circuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1), ).setIndexNames((0, "CIRCUIT-MIB", "circuitSrcIpAddr"), (0, "CIRCUIT-MIB", "circuitSrcInterfaceNum"), (0, "CIRCUIT-MIB", "circuitSrcConnectionID"))
if mibBuilder.loadTexts: circuitEntry.setStatus('current')
if mibBuilder.loadTexts: circuitEntry.setDescription('Entry in the table for a single transport channel')
circuitSrcIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitSrcIpAddr.setStatus('current')
if mibBuilder.loadTexts: circuitSrcIpAddr.setDescription('IP address of the source circuit endpoint.')
circuitSrcInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitSrcInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: circuitSrcInterfaceNum.setDescription('The interface number of the source circuit endpoint.')
circuitSrcConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitSrcConnectionID.setStatus('current')
if mibBuilder.loadTexts: circuitSrcConnectionID.setDescription('Connection Identifier of the source circuit endpoint. Based on the protocol type, further information may be required to completely specify a circuit on a channel. For example, Ethernet VLAN requires a VLAN Id, Frame Relay requires a DLCI and ATM requires VPI and VCI. For ATM, this field is encoded as 12 bits of VPI and 16 bits of VCI.')
circuitSrcDescString = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitSrcDescString.setStatus('current')
if mibBuilder.loadTexts: circuitSrcDescString.setDescription('Textual description of the source side of the circuit endpoint.')
circuitDestIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitDestIpAddr.setStatus('current')
if mibBuilder.loadTexts: circuitDestIpAddr.setDescription('IP address of the destination circuit endpoint.')
circuitDestInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitDestInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: circuitDestInterfaceNum.setDescription('The interface number of the destination circuit endpoint.')
circuitDestConnectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitDestConnectionID.setStatus('current')
if mibBuilder.loadTexts: circuitDestConnectionID.setDescription('Connection Identifier of the destination circuit endpoint. Based on the protocol type, further information may be required to completely specify a circuit on a channel. For example, Ethernet VLAN requires a VLAN Id, Frame Relay requires a DLCI and ATM requires VPI and VCI. For ATM, this field is encoded as 12 bits of VPI and 16 bits of VCI.')
circuitDestDescString = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitDestDescString.setStatus('current')
if mibBuilder.loadTexts: circuitDestDescString.setDescription('Textual description of the destination side of the circuit endpoint.')
circuitName = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitName.setStatus('current')
if mibBuilder.loadTexts: circuitName.setDescription('CircuitName is a unique name given to a circuit.')
circuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitID.setStatus('current')
if mibBuilder.loadTexts: circuitID.setDescription('CircuitID is a unique ID given to a circuit. It is equal to the TC-ID in the PM.')
circuitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitRowStatus.setStatus('current')
if mibBuilder.loadTexts: circuitRowStatus.setDescription('Indicates if a row has been created or deleted. See SNMPv2-TC for complete description.')
circuitReasonText = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitReasonText.setStatus('current')
if mibBuilder.loadTexts: circuitReasonText.setDescription('Provides the reason for the error indicated.')
circuitFailLocIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocIpAddr.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocIpAddr.setDescription('IP address of location where circuit failure code is encountered.')
circuitFailLocSlot1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 26))).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocSlot1.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocSlot1.setDescription('Slot number where circuit failure code is encountered.')
circuitFailLocPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocPort1.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocPort1.setDescription('Port number where circuit failure code is encountered.')
circuitFailLocInterfaceNum1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocInterfaceNum1.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocInterfaceNum1.setDescription('Interface number where circuit failure code is encountered.')
circuitFailLocConnectionID1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocConnectionID1.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocConnectionID1.setDescription('Connection Identifier of the failed circuit endpoint.')
circuitFailLocSlot2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 26))).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocSlot2.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocSlot2.setDescription('Slot number where circuit failure code is encountered.')
circuitFailLocPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocPort2.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocPort2.setDescription('Port number where circuit failure code is encountered.')
circuitFailLocInterfaceNum2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocInterfaceNum2.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocInterfaceNum2.setDescription('Interface number where circuit failure code is encountered.')
circuitFailLocConnectionID2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitFailLocConnectionID2.setStatus('current')
if mibBuilder.loadTexts: circuitFailLocConnectionID2.setDescription('Connection Identifier of the failed circuit endpoint.')
circuitEndPoint1Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet", 1), ("frameRelay", 2), ("atm", 3), ("vt", 4), ("axData", 5), ("axTdm", 6), ("isl", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitEndPoint1Protocol.setStatus('current')
if mibBuilder.loadTexts: circuitEndPoint1Protocol.setDescription('Protocol determines the connectionID.')
circuitFwdTDType = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet", 1), ("frameRelay", 2), ("tdm", 3), ("atm-cbr", 4), ("atm-vbr-rt", 5), ("atm-vbr-nrt", 6), ("atm-vbr-ubr", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitFwdTDType.setStatus('current')
if mibBuilder.loadTexts: circuitFwdTDType.setDescription("Specifies the traffic descriptor type associated with the forward traffic descriptor parameters. The forward direction is 'into the network' from the circuit endpoint. TDType is independent of the end-point protocol.")
circuitFwdTDParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 24), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitFwdTDParam1.setStatus('current')
if mibBuilder.loadTexts: circuitFwdTDParam1.setDescription('Parameter 1 of the forward traffic descriptor of type circuitFwdTdType. For type Ethernet, this value corresponds to CIR. For type Frame Relay, this value corresponds to CIR. For type ATM-CBR, this value corresponds to PCR(0+1).')
circuitFwdTDParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 25), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitFwdTDParam2.setStatus('current')
if mibBuilder.loadTexts: circuitFwdTDParam2.setDescription('Parameter 2 of the forward traffic descriptor of type circuitFwdTdType. For type Ethernet, this value corresponds to Bc. For type Frame Relay, this value corresponds to Bc.')
circuitFwdTDParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 26), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitFwdTDParam3.setStatus('current')
if mibBuilder.loadTexts: circuitFwdTDParam3.setDescription('Parameter 3 of the forward traffic descriptor of type circuitFwdTdType. For type Ethernet, this value corresponds to Be. For type Frame Relay, this value corresponds to Be.')
circuitFwdTDParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 27), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitFwdTDParam4.setStatus('current')
if mibBuilder.loadTexts: circuitFwdTDParam4.setDescription('Parameter 4 of the forward traffic descriptor of type circuitFwdTdType.')
circuitEndPoint2Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet", 1), ("frameRelay", 2), ("atm", 3), ("vt", 4), ("axData", 5), ("axTdm", 6), ("isl", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitEndPoint2Protocol.setStatus('current')
if mibBuilder.loadTexts: circuitEndPoint2Protocol.setDescription('Protocol determines the connectionID.')
circuitBwdTDType = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet", 1), ("frameRelay", 2), ("tdm", 3), ("atm-cbr", 4), ("atm-vbr-rt", 5), ("atm-vbr-nrt", 6), ("atm-vbr-ubr", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitBwdTDType.setStatus('current')
if mibBuilder.loadTexts: circuitBwdTDType.setDescription("Specifies the traffic descriptor type associated with the backward traffic descriptor parameters. The backward direction is 'out of the network' from the circuit endpoint. TDType is independent to of the end-point protocol.")
circuitBwdTDParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 30), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitBwdTDParam1.setStatus('current')
if mibBuilder.loadTexts: circuitBwdTDParam1.setDescription('Parameter 1 of the backward traffic descriptor of type circuitBwdTdType. For type Ethernet, this value corresponds to CIR. For type Frame Relay, this value corresponds to CIR. For type ATM-CBR, this value corresponds to PCR(0+1).')
circuitBwdTDParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 31), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitBwdTDParam2.setStatus('current')
if mibBuilder.loadTexts: circuitBwdTDParam2.setDescription('Parameter 2 of the backward traffic descriptor of type circuitBwdTdType. For type Ethernet, this value corresponds to Bc. For type Frame Relay, this value corresponds to Bc.')
circuitBwdTDParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 32), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitBwdTDParam3.setStatus('current')
if mibBuilder.loadTexts: circuitBwdTDParam3.setDescription('Parameter 3 of the backward traffic descriptor of type circuitBwdTdType. For type Ethernet, this value corresponds to Be. For type Frame Relay, this value corresponds to Be.')
circuitBwdTDParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 33), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitBwdTDParam4.setStatus('current')
if mibBuilder.loadTexts: circuitBwdTDParam4.setDescription('Parameter 4 of the backward traffic descriptor of type circuitBwdTdType.')
circuitClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitClassOfService.setStatus('current')
if mibBuilder.loadTexts: circuitClassOfService.setDescription('Specifies the class of service for Data or non-TDM circuits. This value is in the range of 0-7 where 1 has the highest priority and 7 has the lowest.')
circuitAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledButNotUsed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitAdminState.setStatus('current')
if mibBuilder.loadTexts: circuitAdminState.setDescription("Administrative state of the circuit. Circuits in the disabled state do not consume network resources such as bandwidth. The network continuously attempts to establish circuits until successful while in the enabled state. The 'enabledButNotUsed' state tells that the transport segment is established and network resources are assigned to it, but, traffic is not allowed to pass though it.")
circuitOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("test", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOperState.setStatus('current')
if mibBuilder.loadTexts: circuitOperState.setDescription('Aperational state of the circuit. Circuits in the disabled state do not consume network resources such as bandwidth. The network continuously attempts to establish circuits until successful while in the enabled state.')
circuitTimeSinceStatusChange = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 37), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitTimeSinceStatusChange.setStatus('current')
if mibBuilder.loadTexts: circuitTimeSinceStatusChange.setDescription('Gives the time (in seconds) since the most recent status change.')
circuitSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 38), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitSetupPriority.setStatus('current')
if mibBuilder.loadTexts: circuitSetupPriority.setDescription('If there are insufficient network resources for establishing all transport channels, this field specifies the priority of the transport channel.')
circuitHoldPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 39), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitHoldPriority.setStatus('current')
if mibBuilder.loadTexts: circuitHoldPriority.setDescription('If a number of transport channels of a low Setup Priority need to be cleared in order to release resources allowing for a higher priority (Setup) transport channel to be established, this field specifies the Hold priority where low Hold priority transport channels are cleared before higher Hold priority transport channels.')
circuitIsRedundancyReqd = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 40), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitIsRedundancyReqd.setStatus('current')
if mibBuilder.loadTexts: circuitIsRedundancyReqd.setDescription("Specifies if the circuit is to be established over rings that are logically configured as 'protected'. A protected ring could physically be in a fault state where one fiber has failed. A circuit that requires redundancy will be established over rings logically configured as 'protected' even though the current physical state of a protected ring may be in a fault state.")
circuitPreferredEP1OptSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 26))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitPreferredEP1OptSlot.setStatus('current')
if mibBuilder.loadTexts: circuitPreferredEP1OptSlot.setDescription('If the circuit spans one or two rings, this is the slot number of the first preferred ring. Preferred rings allow a manual overide of the routed circuit path.')
circuitPreferredEP1OptPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitPreferredEP1OptPort.setStatus('current')
if mibBuilder.loadTexts: circuitPreferredEP1OptPort.setDescription('If the circuit spans one or two rings, this is the port number of the first preferred ring.')
circuitPreferredEP1OptVport = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitPreferredEP1OptVport.setStatus('current')
if mibBuilder.loadTexts: circuitPreferredEP1OptVport.setDescription('If the circuit spans one or two rings, this is the lambda number of the first preferred ring.')
circuitPreferredEP2OptSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 26))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitPreferredEP2OptSlot.setStatus('current')
if mibBuilder.loadTexts: circuitPreferredEP2OptSlot.setDescription('If the circuit spans two rings, this is the slot number of the second preferred ring. Preferred rings allow a manual overide of the routed circuit path.')
circuitPreferredEP2OptPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitPreferredEP2OptPort.setStatus('current')
if mibBuilder.loadTexts: circuitPreferredEP2OptPort.setDescription('If the circuit spans two rings, this is the port number of the second preferred ring.')
circuitPreferredEP2OptVport = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitPreferredEP2OptVport.setStatus('current')
if mibBuilder.loadTexts: circuitPreferredEP2OptVport.setDescription('If the circuit spans two rings, this is the lambda number of the second preferred ring.')
circuitUseAlternateRing = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: circuitUseAlternateRing.setStatus('current')
if mibBuilder.loadTexts: circuitUseAlternateRing.setDescription('Allows operator to specify whether an alternate ring can be used if the preferred ring(s) fail. This requires the ability to load-balance back onto the preferred ring once it becomes available. The format for this field is Boolean.')
circuitInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 48), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInFrames.setStatus('current')
if mibBuilder.loadTexts: circuitInFrames.setDescription('Number of frames received at the ingress point and passed on to the circuit.')
circuitInDEFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 49), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInDEFrames.setStatus('current')
if mibBuilder.loadTexts: circuitInDEFrames.setDescription('Number of frames received at the ingress point and passed on to the circuit.')
circuitInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 50), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInOctets.setStatus('current')
if mibBuilder.loadTexts: circuitInOctets.setDescription('Number of octets received at the ingress point and passed on to the circuit.')
circuitInDEOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 51), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInDEOctets.setStatus('current')
if mibBuilder.loadTexts: circuitInDEOctets.setDescription('Number of octets received at the ingress point and passed on to the circuit.')
circuitInCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 52), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInCLP0Cells.setStatus('current')
if mibBuilder.loadTexts: circuitInCLP0Cells.setDescription('Number of cells received at the ingress point and passed on to the circuit.')
circuitInCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 53), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInCLP1Cells.setStatus('current')
if mibBuilder.loadTexts: circuitInCLP1Cells.setDescription('Number of cells received at the ingress point and passed on to the circuit.')
circuitInFramesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 54), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInFramesDiscard.setStatus('current')
if mibBuilder.loadTexts: circuitInFramesDiscard.setDescription('Number of frames received at the ingress point but are discarded due to the non-conformance of the contract, i.e., it exceeds the traffic contract (BE).')
circuitInDEFramesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 55), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInDEFramesDiscard.setStatus('current')
if mibBuilder.loadTexts: circuitInDEFramesDiscard.setDescription('Number of frames received at the ingress point but are discarded due to the non-conformance of the contract, i.e., it exceeds the traffic contract (BE).')
circuitInOctetsDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 56), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInOctetsDiscard.setStatus('current')
if mibBuilder.loadTexts: circuitInOctetsDiscard.setDescription('Number of octets received at the ingress point but are discarded due to the non-conformance of the contract, i.e., it exceeds the traffic contract (BE).')
circuitInDEOctetsDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 57), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInDEOctetsDiscard.setStatus('current')
if mibBuilder.loadTexts: circuitInDEOctetsDiscard.setDescription('Number of octets received at the ingress point but are discarded due to the non-conformance of the contract, i.e., it exceeds the traffic contract (BE).')
circuitInCLP0CellsDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 58), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInCLP0CellsDiscard.setStatus('current')
if mibBuilder.loadTexts: circuitInCLP0CellsDiscard.setDescription('Number of octets received at the ingress point but are discarded due to the non-conformance of the contract, i.e., it exceeds the traffic contract (BE).')
circuitInCLP1CellsDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 59), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInCLP1CellsDiscard.setStatus('current')
if mibBuilder.loadTexts: circuitInCLP1CellsDiscard.setDescription('Number of octets received at the ingress point but are discarded due to the non-conformance of the contract, i.e., it exceeds the traffic contract (BE).')
circuitInFramesTagged = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 60), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInFramesTagged.setStatus('current')
if mibBuilder.loadTexts: circuitInFramesTagged.setDescription('Number of tagged frames received. A tagged frame represents non-conforming frames to the contract (when CIR < frame contract < BE). In these frames, the DE (Discard Enable) is set. ')
circuitInOctetsTagged = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 61), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInOctetsTagged.setStatus('current')
if mibBuilder.loadTexts: circuitInOctetsTagged.setDescription('Number of tagged octets received. A tagged octet represents non-conforming octet to the contract (when CIR < octet contract < BE).In these octets, the DE (Discard Enable) is set.')
circuitInCLP0CellsTagged = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 62), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitInCLP0CellsTagged.setStatus('current')
if mibBuilder.loadTexts: circuitInCLP0CellsTagged.setDescription('Number of tagged octets received. A tagged octet represents non-conforming octet to the contract (when CIR < octet contract < BE).In these octets, the DE (Discard Enable) is set.')
circuitOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 63), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOutFrames.setStatus('current')
if mibBuilder.loadTexts: circuitOutFrames.setDescription('Number of frames sent out through the circuit.')
circuitOutDEFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 64), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOutDEFrames.setStatus('current')
if mibBuilder.loadTexts: circuitOutDEFrames.setDescription('Number of frames sent out through the circuit.')
circuitOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 65), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOutOctets.setStatus('current')
if mibBuilder.loadTexts: circuitOutOctets.setDescription('Number of octets sent out through the circuit.')
circuitOutDEOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 66), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOutDEOctets.setStatus('current')
if mibBuilder.loadTexts: circuitOutDEOctets.setDescription('Number of octets sent out through the circuit.')
circuitOutCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 67), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOutCLP0Cells.setStatus('current')
if mibBuilder.loadTexts: circuitOutCLP0Cells.setDescription('Number of cells sent out through the circuit.')
circuitOutCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 5812, 6, 8, 1, 68), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitOutCLP1Cells.setStatus('current')
if mibBuilder.loadTexts: circuitOutCLP1Cells.setDescription('Number of cells sent out through the circuit.')
circuitInactive = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,24)).setObjects(("CIRCUIT-MIB", "circuitReasonText"))
if mibBuilder.loadTexts: circuitInactive.setDescription('Indicates that the circuit became inactive and specifies the reason for it becoming inactive')
circuitActive = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,25)).setObjects(("CIRCUIT-MIB", "circuitReasonText"))
if mibBuilder.loadTexts: circuitActive.setDescription('Indicates that the circuit became active')
circuitLoadBalancing = NotificationType((1, 3, 6, 1, 4, 1, 5812) + (0,26)).setObjects(("CIRCUIT-MIB", "circuitReasonText"))
if mibBuilder.loadTexts: circuitLoadBalancing.setDescription('Indicates that the circuit underwent load balancing')
mibBuilder.exportSymbols("CIRCUIT-MIB", circuitEndPoint2Protocol=circuitEndPoint2Protocol, circuitInDEOctets=circuitInDEOctets, circuitID=circuitID, circuitInOctetsDiscard=circuitInOctetsDiscard, circuitInCLP1CellsDiscard=circuitInCLP1CellsDiscard, circuitInFrames=circuitInFrames, circuitFwdTDParam4=circuitFwdTDParam4, circuitPreferredEP1OptVport=circuitPreferredEP1OptVport, circuitInCLP1Cells=circuitInCLP1Cells, circuitMIB=circuitMIB, circuitInDEFrames=circuitInDEFrames, circuitBwdTDParam1=circuitBwdTDParam1, circuitInCLP0CellsTagged=circuitInCLP0CellsTagged, circuitEventNumPerInterval=circuitEventNumPerInterval, circuitSrcIpAddr=circuitSrcIpAddr, circuitFailLocPort2=circuitFailLocPort2, circuitFwdTDType=circuitFwdTDType, circuitDestInterfaceNum=circuitDestInterfaceNum, circuitSrcConnectionID=circuitSrcConnectionID, circuitRowStatus=circuitRowStatus, circuitFailLocInterfaceNum2=circuitFailLocInterfaceNum2, circuitInFramesTagged=circuitInFramesTagged, circuitInCLP0CellsDiscard=circuitInCLP0CellsDiscard, circuitOutOctets=circuitOutOctets, circuitFwdTDParam1=circuitFwdTDParam1, circuitOutDEOctets=circuitOutDEOctets, circuitFailLocSlot1=circuitFailLocSlot1, circuitFwdTDParam3=circuitFwdTDParam3, circuitPreferredEP2OptSlot=circuitPreferredEP2OptSlot, circuitInDEFramesDiscard=circuitInDEFramesDiscard, circuitBwdTDParam2=circuitBwdTDParam2, circuitBwdTDParam3=circuitBwdTDParam3, circuitDestDescString=circuitDestDescString, circuitLoadBalanceInterval=circuitLoadBalanceInterval, circuitFailLocPort1=circuitFailLocPort1, circuitSetupPriority=circuitSetupPriority, circuitActive=circuitActive, circuitIsRedundancyReqd=circuitIsRedundancyReqd, circuitInFramesDiscard=circuitInFramesDiscard, circuitAdminState=circuitAdminState, circuitPreferredEP1OptSlot=circuitPreferredEP1OptSlot, circuitSrcInterfaceNum=circuitSrcInterfaceNum, circuitBwdTDParam4=circuitBwdTDParam4, circuitBwdTDType=circuitBwdTDType, circuitFailLocConnectionID2=circuitFailLocConnectionID2, circuitPreferredEP1OptPort=circuitPreferredEP1OptPort, circuitName=circuitName, circuitOperState=circuitOperState, circuitClassOfService=circuitClassOfService, circuitInDEOctetsDiscard=circuitInDEOctetsDiscard, circuitFailLocIpAddr=circuitFailLocIpAddr, circuitInCLP0Cells=circuitInCLP0Cells, circuitOutDEFrames=circuitOutDEFrames, circuitOldIpAddrToSwap=circuitOldIpAddrToSwap, circuitFwdTDParam2=circuitFwdTDParam2, circuitDestConnectionID=circuitDestConnectionID, circuitLoadBalancing=circuitLoadBalancing, circuitDestIpAddr=circuitDestIpAddr, circuitInOctetsTagged=circuitInOctetsTagged, circuitUseAlternateRing=circuitUseAlternateRing, circuitHoldPriority=circuitHoldPriority, PYSNMP_MODULE_ID=circuitMIB, circuitInactive=circuitInactive, circuitFailLocInterfaceNum1=circuitFailLocInterfaceNum1, circuitReasonText=circuitReasonText, circuitEndPoint1Protocol=circuitEndPoint1Protocol, circuitNewIpAddrToSwap=circuitNewIpAddrToSwap, circuitFailLocConnectionID1=circuitFailLocConnectionID1, circuitOutFrames=circuitOutFrames, circuitPreferredEP2OptVport=circuitPreferredEP2OptVport, circuitLoadBalanceNumPerInterval=circuitLoadBalanceNumPerInterval, circuitTimeSinceStatusChange=circuitTimeSinceStatusChange, circuitOutCLP0Cells=circuitOutCLP0Cells, circuitTable=circuitTable, circuitPreferredEP2OptPort=circuitPreferredEP2OptPort, circuitFailLocSlot2=circuitFailLocSlot2, circuitSrcDescString=circuitSrcDescString, circuitEntry=circuitEntry, circuitOutCLP1Cells=circuitOutCLP1Cells, circuitEventInterval=circuitEventInterval, circuitInOctets=circuitInOctets)

#
# PySNMP MIB module Com-Server-Intern-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Com-Server-Intern-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:36:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, Gauge32, NotificationType, ModuleIdentity, Counter64, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, NotificationType, MibIdentifier, Unsigned32, ObjectIdentity, Integer32, Bits, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "NotificationType", "ModuleIdentity", "Counter64", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "NotificationType", "MibIdentifier", "Unsigned32", "ObjectIdentity", "Integer32", "Bits", "IpAddress", "TimeTicks")
PhysAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "DisplayString", "TextualConvention")
wut = MibIdentifier((1, 3, 6, 1, 4, 1, 5040))
wtComServer = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1))
wtComServerIntern = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1))
wtConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1))
wtDeaDriver = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2))
wtSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1))
wtNetSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2))
wtSeriPortSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3))
wtDeaPortSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4))
wtCableType = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 8, 16))).clone(namedValues=NamedValues(("wtCoax", 1), ("wtTwistedPair", 2), ("wtAui", 3), ("wtTwistedPair10FD", 4), ("wtTwistedPair100HD", 8), ("wtTwistedPair100FD", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtCableType.setStatus('mandatory')
if mibBuilder.loadTexts: wtCableType.setDescription('Displays the Ethernet connection type used on the Com-Server.')
wtMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wtMacAddress.setDescription('Displays the Ethernet address of the Com-Server.')
wtSwDate = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSwDate.setStatus('mandatory')
if mibBuilder.loadTexts: wtSwDate.setDescription("Displays the creation date 'month/year' of the firmware.")
wtSwRev = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSwRev.setStatus('mandatory')
if mibBuilder.loadTexts: wtSwRev.setDescription('Displays the revision number of the firmware.')
wtDevType = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDevType.setStatus('mandatory')
if mibBuilder.loadTexts: wtDevType.setDescription('Displays the Com-Server model.')
wtMibRev = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtMibRev.setStatus('mandatory')
if mibBuilder.loadTexts: wtMibRev.setDescription('Displays the revision number of the Wiesemann & Theis MIB.')
wtRunTime = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtRunTime.setStatus('mandatory')
if mibBuilder.loadTexts: wtRunTime.setDescription('Displays the time since the last restart of the Com-Server in 1/100 seconds.')
wtPhysPorts = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtPhysPorts.setStatus('mandatory')
if mibBuilder.loadTexts: wtPhysPorts.setDescription('Displays the total number of ports available in the Com-Server (RS232 port, digital I/O port, ...).')
wtConfigMode = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("wtConfigModeOff", 1), ("wtConfigModeOn", 2), ("wtSaveConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: wtConfigMode.setDescription('Defining this entry allows changing (wtConfigModeOn) and saving (stSaveConfig) of all other entries in the Management Information Base of the Com-Server. If the value is 1 (wtCOnfigModeOff), all other entries can be read only.')
wtPassword = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtPassword.setStatus('mandatory')
if mibBuilder.loadTexts: wtPassword.setDescription("8-character Com-Server password for unrestricted access to the Com-Server configuration menu (Telnet port 1111). Only digits '0' to '9' and letters 'a' to 'f' may be used (e.g.: 'abcdef12').")
wtSysPswd = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 18), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSysPswd.setStatus('mandatory')
if mibBuilder.loadTexts: wtSysPswd.setDescription('The system password, which may consist of maximum 32 characters and is terminated by a zero, is of a higher order than the Telnet password and protects all the following configuration and control accesses of the Com-Server: Port 1111: Telnet configuration menu Port 8003/8004: Reading/writing the configuration file Port 8888: Reset Com-Server Port 9084, 9184,9284, 9384: Reset Port Status A-D Port 9094, 9194,9294, 9394: Control port A-D Port 161: SNMP requests are only replied if the community corresponds to the system password If the first character in the system password is a zero, this is deactivated.')
wtSysName = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 1, 19), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSysName.setStatus('mandatory')
if mibBuilder.loadTexts: wtSysName.setDescription('The system name, which may consist of maximum 32 characters and is terminated by a zero, is used for identifying the Com-Server and is displayed as an opening message for all Telnet connections. If the first character in the system password is a zero, this is deactivated.')
wtIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wtIpAddress.setDescription('IP address of the Com-Server.')
wtSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtSubnetMask.setDescription('Subnet mask of the Com-Server.')
wtGateway = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtGateway.setStatus('mandatory')
if mibBuilder.loadTexts: wtGateway.setDescription('IP address of the gateway for making the connections to other networks.')
wtMtu = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wtMtu.setDescription('Maximum Transfer Unit of the Com-Server (maximum length of a datagram which the Com-Server can send or receive).')
wtBootpClient = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtBootpClientOff", 1), ("wtBootpClientOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtBootpClient.setStatus('mandatory')
if mibBuilder.loadTexts: wtBootpClient.setDescription('Activates and deactivates sending of a BOOTP request after the Com-Server is restarted')
wtKeepAlive = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: wtKeepAlive.setDescription('Period of time without network traffic after the first Keep Alive Packet will be sent')
wtRetransmTimeout = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtRetransmTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtRetransmTimeout.setDescription('Packet retransmission timeout in ms')
wtDhcpClient = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtDhcpClientOff", 1), ("wtChcpClientOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDhcpClient.setStatus('mandatory')
if mibBuilder.loadTexts: wtDhcpClient.setDescription('Activates/deactivates the DHCP client')
wtWbmPort = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtWbmPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtWbmPort.setDescription('TCP port number for WebBasedManagement, 0=deactive')
wtDnsSrv = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDnsSrv.setStatus('mandatory')
if mibBuilder.loadTexts: wtDnsSrv.setDescription('IP adress of DNS server.')
wtLinkSpeed = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("wtLinkSpeedAutonegotiation", 1), ("wtLinkSpeed10HD", 2), ("wtLinkSpeed10FD", 3), ("wtLinkSpeed100HD", 4), ("wtLinkSpeed100FD", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtLinkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wtLinkSpeed.setDescription('Autonegotiation mode = ON or fix link speed')
wtSerialPorts = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSerialPorts.setStatus('mandatory')
if mibBuilder.loadTexts: wtSerialPorts.setDescription('Number of serial ports on Com-Server')
wtSeriInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 2), )
if mibBuilder.loadTexts: wtSeriInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriInterfaceTable.setDescription('List of interface numbers for all serial ports.')
wtSeriInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 2, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriInterfaceEntry.setDescription('Interface number.')
wtSeriInterfaceNo = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSeriInterfaceNo.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriInterfaceNo.setDescription('Interface number of the serial port.')
wtSeriUartTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3), )
if mibBuilder.loadTexts: wtSeriUartTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUartTable.setDescription('List of the UART configurations relevant to the interface number of the serial port.')
wtSeriUartEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriUartEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUartEntry.setDescription('UART parameters for the serial port.')
wtBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("wtBaudrate-57600", 1), ("wtBaudrate-38400", 2), ("wtBaudrate-19200", 3), ("wtBaudrate-14400", 4), ("wtBaudrate-9600", 5), ("wtBaudrate-4800", 6), ("wtBaudrate-2400", 7), ("wtBaudrate-1200", 8), ("wtBaudrate-600", 9), ("wtBaudrate-300", 10), ("wtBaudrate-150", 11), ("wtBaudrate-110", 12), ("wtBaudrate-75", 13), ("wtBaudrate-50", 14), ("wtBaudrate-230400", 15), ("wtBaudrate-115200", 16), ("wtBaudrate-7200", 17), ("wtBaudrate-special", 18)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtBaudrate.setStatus('mandatory')
if mibBuilder.loadTexts: wtBaudrate.setDescription('Baud rate of the serial CPU port. wtBaudrate-special is read only. If wtBaudDivisor is >0 the value of wtBaudrate is 18 wtBaudrate-14400 is on available with Com-Servers 58211,58411 and 58412. wtBaudrate=11 to wtBaudrate=18 are only available with Com-Servers 58631 and 58431')
wtParity = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("wtNoParity", 1), ("wtOddParity", 2), ("wtEvenParity", 3), ("wtMarkOddParity", 4), ("wtMarkEvenParity", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtParity.setStatus('mandatory')
if mibBuilder.loadTexts: wtParity.setDescription('Parity')
wtDatabits = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("wtDataBits-8", 1), ("wtDataBits-7", 2), ("wtDataBits-6", 3), ("wtDataBits-5", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDatabits.setStatus('mandatory')
if mibBuilder.loadTexts: wtDatabits.setDescription('Number of data bits')
wtStopbits = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtStopBits-1", 1), ("wtStopBits-2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtStopbits.setStatus('mandatory')
if mibBuilder.loadTexts: wtStopbits.setDescription('Number of stop bits')
wtHsLines = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtHsLines.setStatus('mandatory')
if mibBuilder.loadTexts: wtHsLines.setDescription('These two octets are interpreted bit-by-bit and describe individual values for configuring the handshake procedure. Bit 0 corresponds to the LSB. Octet Bit Name Description ---- ---- ------------ ------------------------ 1 0,1,6,7 not used 2 inxfilter 1: enable xon/xoff filter while receiving 3 outxfilter 1: enable xon/xoff filter while sending 4 rts-default 1: while RTS is not used, RTS is active 5 dtr-default 1: while DTR is not used, DTR is active 2 0 rts-disable 1: RTS will not change at LOCK/UNLOCK 1 dtr-disable 1: DTR will not change at LOCK/UNLOCK 2 outx 1: enable software handshake while sending 3 inx 1: enable software handshake while receiving 4 outx-cts 1: enable hardware handshake on CTS 5 outx-dsr 1: enable hardware handshake on DSR 6 inx-dtr 1: enable hardware handshake on DTR 7 inx-rts 1: enable hardware handshake on RTS Standard default settings: OCTET 1 OCTET 2 Function -------- -------- ---------------- 30h 03h No Handshake 00h 91h Hardware Handshake 3Ch 0Fh Software Handshake (Send/Receive Filter ON)')
wtHsFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtHsFunctions.setStatus('mandatory')
if mibBuilder.loadTexts: wtHsFunctions.setDescription('This octet is interpreted bit-by-bit and describes functions which can be assigned to the handshake lines. Bit 0 corresponds to the LSB. Octet Bit Name Description ---- ---- ------------ ------------------------ 1 0 cts-connect 1: connect/disconnect with CTS (HIGH/LOW) 1 dsr-connect 1: connect/disconnect with DSR (HIGH/LOW) 2 cts-accept 1: accept connection only by CTS=HIGH 3 dsr-accept 1: accept connection only by DSR=HIGH 4-7 not used')
wtUartFifo = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 5, 7))).clone(namedValues=NamedValues(("wtUartFifo-disable", 0), ("wtUartFifo-8-8", 1), ("wtUartFifo-16-16", 3), ("wtUartFifo-32-56", 5), ("wtUartFifo-56-60", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtUartFifo.setStatus('mandatory')
if mibBuilder.loadTexts: wtUartFifo.setDescription('Send/Receive Fifo Trigger Level of the UART port')
wtUartBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("wtUartBaudrate-230400", 1), ("wtUartBaudrate-153600", 2), ("wtUartBaudrate-115200", 3), ("wtUartBaudrate-57600", 4), ("wtUartBaudrate-38400", 5), ("wtUartBaudrate-19200", 6), ("wtUartBaudrate-9600", 7), ("wtUartBaudrate-7200", 8), ("wtUartBaudrate-4800", 9), ("wtUartBaudrate-2400", 10), ("wtUartBaudrate-1200", 11), ("wtUartBaudrate-600", 12), ("wtUartBaudrate-300", 13), ("wtUartBaudrate-150", 14), ("wtUartBaudrate-75", 15), ("wtUartBaudrate-50", 16), ("wtUartBaudrate-110", 17), ("wtUartBaudrate-special", 18)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtUartBaudrate.setStatus('mandatory')
if mibBuilder.loadTexts: wtUartBaudrate.setDescription('Baud rate of the UART port. With Com-Server 58631 and 58431 wtBaudrate istead of wtUartBaudrate must be used. wtUartBaudrate-special is read only. If wtUartBaudDivisor is >0 the value of wtUartBaudrate is 18')
wtBaudDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtBaudDivisor.setStatus('mandatory')
if mibBuilder.loadTexts: wtBaudDivisor.setDescription('Baud Divisor of the serial p ort (special baud rate).')
wtSeriInQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriInQueue.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriInQueue.setDescription("Serial Receive Buffer in Bytes. The value must be even. The maximum value for all models with more than one serial port and also the Office, Compact and 19' versions is 3070 bytes. For all other Com-Server models the maximum value is 4094.")
wtSeriPortTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4), )
if mibBuilder.loadTexts: wtSeriPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPortTable.setDescription('List of the general port entries relevant to the interface number of the serial port.')
wtSeriPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPortEntry.setDescription('Port entries for the serial port.')
wtSeriLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriLocalPort.setDescription('Local TCP/UDP port number of the Com-Server port on which the Com-Server accepts a TCP connection or which it used in TCP client mode or UDP mode as a local port.')
wtSeriPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("wtSeriServerMode", 1), ("wtSeriTcpClient", 2), ("wtSeriTelnetClient", 3), ("wtSeriFtpClient", 4), ("wtSeriBox2BoxMaster", 5), ("wtSeriUdpMode", 6), ("wtSeriMultiportProtokoll", 7), ("wtSeriBox2BoxSlave", 8), ("wtSeriSlipMode", 9), ("wtSeriIpBusSlave", 10), ("wtSeriIpBusMaster", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPortMode.setDescription('This parameter specifies the mode of the Com-Server port. Depending on which mode is set, the corresponding list of the relevant parameters is available. If for example Upd mode (wtSeriPortMode = 6) is configured, only the list wtSeriUdpClientTable is available. In Server Mode (wtSeriPortMode = 1) no list of the port mode configuration is available.')
wtSeriControlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriControlPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriControlPort.setDescription("TCP port number of the Com-Server's control port. In TCP client or TCP server mode this port allows to change settings like baud rate, parity etc. of the serial interface. The control port can be opened in addition to the data connection.")
wtSeriPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("wtSeriPortFree", 0), ("wtSeriPortInUse", 1), ("wtSeriPortLockScanning", 2), ("wtSeriPortLockConnected", 3), ("wtSeriPortLockUnconnected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSeriPortState.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPortState.setDescription('This value specifies the the connection state of the serial port. 0=Server mode, no connection 1=Server mode, active connection 2=Special mode, attempting to establish a connection 3=Special mode, active connection or special mode configured (e.g. SLIP router) 4=Special mode, no connection The values wtSeriRemotePort and wtSeriRemoteIP includes the belonging connection parameters')
wtSeriRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSeriRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriRemotePort.setDescription('If the serial port has an active TCP or UDP connection, this value shows the port number of the remote host.')
wtSeriRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSeriRemoteIP.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriRemoteIP.setDescription('If the serial port has an active TCP or UDP connection, this value shows the IP address of the remote host.')
wtSeriNetPckDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriNetPckDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriNetPckDelay.setDescription('This value indicates the minimum wait time in 10ms ticks of the Com-Server after the arrival of serial data. After this time has expired, it packs the data into a network packet and sends them to the respective communication partner. Default setting 0 means an attempt is made to send the data as quickly as possible. The resulting high time transparency comes with the drawback of a higher number of network packets. If the serial transmission is done in predictable block sizes, adjusting this value will optimize the network load. In addition, there is the advantage that the serial blocks are sent within a network packet and thus reach the recipient at the same time. Please refer also to the Com-Server manual.')
wtSeriFlushBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriFlushBufOff", 1), ("wtSeriFlushBufOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFlushBuf.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFlushBuf.setDescription('If this switch is active (2), the serial buffer is flushed each time a new connection is opened; any residual data which could not be sent (e.g., handshake stop of the serial terminal device) are therefore lost. But if you connect a terminal device to the Com-Server which for example requires a longer handshake, you can prevent flushing of the buffer by deactivating the switch (1). Then several connections can be opened in turn on the network side and the data are accumulated in the buffer until they are sent.')
wtSeriTelnetEcho = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriTelnetEchoOff", 1), ("wtSeriTelnetEchoOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetEcho.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetEcho.setDescription('When opening a Telnet connection, there is negotiation on the network side to determine who generates the echo of the characters sent by the client. Either the client application generates a local echo, or the Telnet server generates a remote echo by immediately sending back all received characters. The Telnet echo option on the Com-Server is defined as follows: Telnet echo = active (2) The Com-Server negotiates a remote echo with the client application and local echo is deactivated. In this case the device serially connected to the Com-Server must generate the echo. Telnet echo = deactivated (1) The Com-Server tells the client application when the connection is opened that is not generating an echo, which results in activation of local echo. Local echo may have to be manually turned on on the Telnet client.')
wtSeriTcpClientTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5), )
if mibBuilder.loadTexts: wtSeriTcpClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpClientTable.setDescription('List of all serial ports in TCP client mode relevant to their interface number.')
wtSeriTcpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriTcpClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpClientEntry.setDescription('TCP-Client-Mode parameters')
wtSeriTcpServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpServerPort.setDescription('Port number which the application (TCP server process) addresses on the computer.')
wtSeriTcpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpServerIp.setDescription('IP address of the computer on which the application (TCP server process) is active.')
wtSeriTcpInactTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpInactTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpInactTimeout.setDescription('Connection timeout in seconds. If no data are exchanged within the specified time, the Com-Server closes the connection to the server. The value 0 deactivates the timer.')
wtSeriTcpConnectTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpConnectTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpConnectTimeout.setDescription('Connection timeout in seconds. This value is only effective in conjunction with an activated Inactivity Timeout. After the Inactivity Timeout has expired, the Com-Server attempts for the duration of the Connection Timeout to transmit any user data not yet sent. If it does not receive a reply from the TCP server within this time, it may be assumed that the server is hung. The data are then rejected and the connection reset. To prevent unintended data loss, choose a value which is appropriately large. Value 0 deactivates the timeout.')
wtSeriTcpDisconnectChar = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpDisconnectChar.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpDisconnectChar.setDescription('If the Com-Server receives the character set here on the serial port, the connection to the TCP server is closed. The character itself is not sent to the TCP server. The value 0 deactivates this mode.')
wtSeriTcpDispString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpDispString1.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpDispString1.setDescription('These parameters allow compact sending of serial data to the network; the serial data stream is not broken up randomly, but rather serial packets can be sent in their original context even over the network as one packet. Enter in wtSeriTcpDispString1 and/or wtSeriTcpDispString2 two characters each that you want the serial data stream searched for. Only if one of the two strings is found are the data from the serial port packed into network packets. If you only want to look for one character, set wtSeriTcpDispString2 to 0. If for example you configure wtSeriTcpDispString1 to 3100h and wtSeriTcpDispString2 to 0, only character 1 is searched for. Both Dispatch Strings = 0 deactivates the mode. IMPORTANT: These characters are sent to the TCP server!')
wtSeriTcpDispString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpDispString2.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpDispString2.setDescription('See DESCRIPTION of wtSeriTcpDispString1.')
wtSeriTcpCAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriTcpCAddressOff", 1), ("wtSeriTcpCAddressOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpCAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpCAddress.setDescription("Activating this switch activates TCP client mode for changing TCP servers. The address of the TCP server does not have to be permanently configured, but rather is sent on the serial interface before the user data as an ASCII string. The string for the addressing is not sent. There are two possibilities for string format: 1. The parameters 'wtSeriTcpServerPort' and 'wtSeriTcpServerIp' are equal to zero. Format: C IP address, Port number<CR> (e.g. 'C172.16.231.101,4800<CR>') C URL, Port number<CR> (e.g. 'Cworkpc.homeip.net,4800<CR>') 2. The parameter 'wtSeriTcpServerPort' contains the Default Port (e.g., 4800), 'wtSeriTcpServerIP' contains the first three bytes of the IP address (e.g., 172.16.231.0) Format: C4.byte IP address (e.g., 'C101<CR>') The string is not allowed to contain any spaces!")
wtSeriTcpResponseMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriTcpRespModeOff", 1), ("wtSeriTcpRespModeOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpResponseMode.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpResponseMode.setDescription('In Response Mode the application, special characters are output which are used to inform the application in the serial terminal device about the network-side connection status of the Com-Server This function is only available in TCP client mode. The following messages are output on the serial port: C (connected): The connection was opened successfully. There is a TCP connection to the server. N (not connected): The connection was not opened successfully. The TCP server is not responding. D (disconnected): The connection query was rejected by the TCP server or a previously open connection was properly ended by the TCP server or by the Com-Server. Ixxx.xxx.xxx.xxx (invoked by...): A client application on the indicated station has successfully opened a TCP connection to the Com-Server (e.g., I172.20.20.1).')
wtSeriTcpServerUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 5, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTcpServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTcpServerUrl.setDescription('URL of the computer on which your application (TCP server process) is active. The URL can be used instead of an IP address and only in conjunction with a valid DNS server. The URL contains a maximum of 64 characters and is terminated with a 0x00. If the fist character is 0x00, the URL is empty.')
wtSeriUdpClientTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6), )
if mibBuilder.loadTexts: wtSeriUdpClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpClientTable.setDescription('List of all serial ports in UDP mode relevant to their interface number')
wtSeriUdpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriUdpClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpClientEntry.setDescription('UDP mode parameters')
wtSeriUdpServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpServerPort.setDescription('Port number which the application (UDP server process) addresses on the computer.')
wtSeriUdpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpServerIp.setDescription('IP address of the computer on which the application (UDP server process) is active.')
wtSeriUdpDispString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpDispString1.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpDispString1.setDescription('These parameters allow compact sending of serial data to the network; the serial data stream is not broken up randomly, but rather serial packets can be sent in their original context even over the network as one packet. Enter in wtSeriUdpDispString1 and/or wtSeriUdpDispString2 two characters each that you want the serial data stream searched for. Only if one of the two strings is found are the data from the serial port packed into network packets. If you only want to look for one character, set wtSeriUdpDispString2 to 0. If for example you configure wtSeriTcpDispString1 to 3100h and wtSeriUdpDispString2 to 0, only character 1 is searched for. Both Dispatch Strings = 0 deactivates the mode. IMPORTANT: These characters are sent to the UDP server!')
wtSeriUdpDispString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpDispString2.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpDispString2.setDescription('See DESCRIPTION of wtSeriUdpDispString1.')
wtSeriUdpSeriProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriUdpProtocolOff", 1), ("wtSeriUdpProtocolOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpSeriProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpSeriProtocol.setDescription("The protocol mode which can be activated here has been replaced by the 'Serial Socket Interface' (Mode: Multiport Protocol). For reasons of downward compatibility the functions are still available, but for new projects you should use the 'Serial Socket Interface'.")
wtSeriUdpSeriCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriUdpSeriCodingOff", 1), ("wtSeriUdpSeriCodingOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpSeriCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpSeriCoding.setDescription('See DESCRIPTION of wtSeriUdpSeriProtocol.')
wtSeriUdpCAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriUdpCAddressOff", 1), ("wtSeriUdpCAddressOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpCAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpCAddress.setDescription("Activating this option activates UDP client mode for changing UDP servers. The address of the UDP server does not have to be permanently configured, but rather is sent on the serial interface before the user data as an ASCII string. The string for the addressing is not sent. There are two possibilities for string format: 1. The parameters 'wtSeriUdpServerPort' and 'wtSeriUdpServerIp' are equal to zero. Format: C IP address, Port number<CR> (e.g. 'C172.16.231.101,4800<CR>') C URL, Portnummer<CR> (e.g. 'Cworkpc.homeip.net,4800<CR>') 2. The parameter 'wtSeriUdpServerPort' contains the Default Port (e.g., 4800), 'wtSeriUdpServerIP' contains the first three bytes of the IP address (e.g., 172.16.231.0) Format: C4.byte IP address (e.g., 'C101<CR>') The string is not allowed to contain any spaces!")
wtSeriUdpWrCAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriUdpWrCAddressOff", 1), ("wtSeriUdpWrCAddressOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpWrCAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpWrCAddress.setDescription("Set this switch to active (2) to output the address of the sender in ASCII format before sending the data of a UDP datagram to the serial port. The string always contains 22 characters. Format: C IP address, port number (e.g., 'C172.016.231.101,04800')")
wtSeriUdpDisconnectChar = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpDisconnectChar.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpDisconnectChar.setDescription('This parameter is only evaluated if the variable wtSeriUdpCAddress is activated. If the Com-Server port on the serial interface receives the character configured here, it deletes the last serially received UDP server address. The character itself is not send. A value of 0 deactivates this mode.')
wtSeriUdpServerUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 6, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriUdpServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriUdpServerUrl.setDescription('URL of the computer on which your application (UDP process) is active. The URL can be used instead of an IP address and only in conjunction with a valid DNS server. The URL contains a maximum of 64 characters and is terminated with a 0x00. If the fist character is 0x00, the URL is empty.')
wtSeriTelnetClientTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7), )
if mibBuilder.loadTexts: wtSeriTelnetClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetClientTable.setDescription('List of all serial ports in Telnet client mode relevant to their interface number')
wtSeriTelnetClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriTelnetClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetClientEntry.setDescription('Telnet client mode parameters')
wtSeriTelnetServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetServerPort.setDescription('Port number addressed by the Telnet server (Standard Telnet-Port: 23).')
wtSeriTelnetServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetServerIp.setDescription('IP address of the computer on which the Telnet server is active.')
wtSeriTelnetInactTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetInactTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetInactTimeout.setDescription('Timeout in seconds after which the Com-Server port closes the connection. The timer is reset when there is an active network connection if data are being exchanged. If however no data are sent during the specified time, the Com-Server port closes the connection to the Telnet server.')
wtSeriTelnetDisconnectChar = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetDisconnectChar.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetDisconnectChar.setDescription('If the Com-Server port receives the character configured here on the serial port, the Com-Server port closes the connection to the Telnet server. It is important that this value not be used within a Telnet session, since this would result in premature closing of the connection. The character itself is not sent.')
wtSeriTelnetChangeLineout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriTelnetChangeLineoutOff", 1), ("wtSeriTelnetChangeLineoutOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetChangeLineout.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetChangeLineout.setDescription('If this switch is activated, a 00H is appended to the serially received character 0DH: 0DH 00H is thus sent over the network. This option may need to be activated when sending binary data.')
wtSeriTelnetServerUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 7, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriTelnetServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriTelnetServerUrl.setDescription('URL of the computer on which your application (Telnet server process) is active. The URL can be used instead of an IP address and only in conjunction with a valid DNS server. The URL contains a maximum of 64 characters and is terminated with a 0x00. If the fist character is 0x00, the URL is empty.')
wtSeriFtpClientTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8), )
if mibBuilder.loadTexts: wtSeriFtpClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpClientTable.setDescription('List of all serial ports in FTP client mode relevant to their interface number')
wtSeriFtpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriFtpClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpClientEntry.setDescription('FTP client mode parameters')
wtSeriFtpServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpServerPort.setDescription('Port number which addresses the FTP server (Standard FTP-Port: 21).')
wtSeriFtpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpServerIp.setDescription('IP address of the computer on which the FTP server is active.')
wtSeriFtpAutoFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriAutoFtpOff", 1), ("wtSeriAutoFtpOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpAutoFtp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpAutoFtp.setDescription('Set this switch to 2 to activate the automatic FTP client. This mode is recommended when the same command needs to be executed over and over. The FTP commands are stored in the Com-Server. The latter opens a connection to the FTP server when it receives data on the serial port. It sends the login and runs the configured file command. Then the connection is closed again. Configure the command in the following parameter wtSeriFtpLoginString. Set this switch to 1 to activate the FTP client with serial protocol. See section FTP client mode in the corresponding manual for the Com-Server.')
wtSeriFtpLoginString = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpLoginString.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpLoginString.setDescription("Command sequence for the FTP login in 'Automatic FTP-Client' mode. FTP client commands: TYPE A or I Activation of ASCII or binary mode STOR File Saves all serially received data to a file APPE File Appends all serially received data to the end of a file RETR File Outputs file to the serial port DELE File Deletes file LIST Directory Lists the directory contents on the serial port RESET Initiates a software reset of the Com-Server. This command may only be used when there is no active connection to the FTP server. Command sequence format: 1. login<lf> password<lf> TYPE I or TYPE A<lf> STOR, RETR, APPE or LIST remote file/dir<lf> ProtocolChar<lf> 3. login<lf> 2. RESET<lf> password<lf> ProtocolChar<lf> DELE remote file/dir <lf> ProtocolChar<lf> The character 'ProtocolChar' is configured in the variable wtSeriFtpProtocolChar. Ex.: egon<lf>happy<lf>TYPE A<lf>RETR /etc/hosts<lf><Ctrl C> For additional explanations, please see the chapter 'FTP client mode' in the corresponding manual for the Com-Server.")
wtSeriFtpInactTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpInactTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpInactTimeout.setDescription('Configure the commands STOR and APPE(nd) with a timeout in seconds for closing the connection. If during this time no serial data are received, the FTP client closes the connection to the FTP server.')
wtSeriFtpConnectTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpConnectTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpConnectTimeout.setDescription('Connection timeout in seconds. This value is only effective in conjunction with an activated Inactivity Timeout. After the Inactivity Timeout has expired, the Com-Server attempts for the duration of the Connection Timeout to transmit any user data not yet sent. If it does not receive a reply from the FTP server within this time, it may be assumed that the server is hung. The data are then rejected and the connection reset. To prevent unintended data loss, choose a value which is appropriately large. Value 0 deactivates the timeout.')
wtSeriFtpProtocolChar = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpProtocolChar.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpProtocolChar.setDescription('When the Com-Server receives the character configured here on its serial port, the Com-Server port closes the connection to the FTP server. This is also used as a final character for the login string (Variable wtSeriFtpLoginString).')
wtSeriFtpServerUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 8, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriFtpServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriFtpServerUrl.setDescription('URL of the computer on which your application (FTP server process) is active. The URL can be used instead of an IP address and only in conjunction with a valid DNS server. The URL contains a maximum of 64 characters and is terminated with a 0x00. If the fist character is 0x00, the URL is empty.')
wtSeriMultiPortPrtTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 9), )
if mibBuilder.loadTexts: wtSeriMultiPortPrtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriMultiPortPrtTable.setDescription('List of all serial ports in multiport protocol mode relevant to their interface number')
wtSeriMultiPortPrtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 9, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriMultiPortPrtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriMultiPortPrtEntry.setDescription('Multiport-Protocol-Mode parameters')
wtSeriPrtSeriProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriPrtSeriProtocolOff", 1), ("wtSeriPrtSeriProtocolOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriPrtSeriProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPrtSeriProtocol.setDescription('This switch activates/deactivates the Serial Socket Interface. Detailed protocol documentation is available on our Web site (http://www.wut.de) for downloading.')
wtSeriPrtSeriCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriPrtSeriCodingOff", 1), ("wtSeriPrtSeriCodingOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriPrtSeriCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPrtSeriCoding.setDescription('This switch activated character doubling. It ensures reliable packet frame detection when transmitting binary data, without having to exclude certain characters.')
wtSeriPrtProtocolChar = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriPrtProtocolChar.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriPrtProtocolChar.setDescription('If character doubling is not used, configure here a packet frame character. This character is not allowed to be used in the data stream.')
wtSeriB2bMasterTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 10), )
if mibBuilder.loadTexts: wtSeriB2bMasterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bMasterTable.setDescription('List of all serial ports in Box-to-Box Master Mode relevant to their interface number.')
wtSeriB2bMasterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 10, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriB2bMasterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bMasterEntry.setDescription('Box-to-Box-Master-Mode parameters.')
wtSeriB2bMaster_SlavePort = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setLabel("wtSeriB2bMaster-SlavePort").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriB2bMaster_SlavePort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bMaster_SlavePort.setDescription('Port number of the serial Com-Server-Slave port.')
wtSeriB2bMaster_SlaveIp = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 10, 1, 2), IpAddress()).setLabel("wtSeriB2bMaster-SlaveIp").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriB2bMaster_SlaveIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bMaster_SlaveIp.setDescription('IP address of the Com-Server in which the slave port is located.')
wtSeriB2bMaster_DispString1 = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("wtSeriB2bMaster-DispString1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriB2bMaster_DispString1.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bMaster_DispString1.setDescription('This mode allows compact sending of serial data to the network; the serial data stream is not broken up randomly, but rather serial packets can be sent in their original context even over the network as one packet. Enter in wtSeriB2bMaster-DispString1 and/or wtSeriB2bMaster-DispString2 two characters each that you want the serial data stream searched for. Only if one of the two strings is found are the data from the serial port packed into network packets. If you only want to look for one character, set wtSeriB2bMaster-DispString2 to 0. If for example you configure wtSeriB2bMaster-DispString1 to 3100h and wtSeriB2bMaster-DispString2 to 0, only character 1 is searched for. Both Dispatch Strings = 0 deactivates the mode. IMPORTANT: These characters are sent over the network!')
wtSeriB2bMaster_DispString2 = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("wtSeriB2bMaster-DispString2").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriB2bMaster_DispString2.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bMaster_DispString2.setDescription('See DESCRIPTION for wtSeriB2bMaster-DispString1.')
wtSeriB2bSlaveTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 11), )
if mibBuilder.loadTexts: wtSeriB2bSlaveTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bSlaveTable.setDescription('List of all serial ports in Box-to-Box-Slave-Mode relevant to their interface number')
wtSeriB2bSlaveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 11, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriB2bSlaveEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bSlaveEntry.setDescription('Box-to-Box-Slave-Mode parameters.')
wtSeriB2bSlave_MasterPort = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setLabel("wtSeriB2bSlave-MasterPort").setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSeriB2bSlave_MasterPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bSlave_MasterPort.setDescription('Port number of the serial Com-Server Master port.')
wtSeriB2bSlave_MasterIp = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 11, 1, 2), IpAddress()).setLabel("wtSeriB2bSlave-MasterIp").setMaxAccess("readonly")
if mibBuilder.loadTexts: wtSeriB2bSlave_MasterIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bSlave_MasterIp.setDescription('IP address of the Com-Server in which the Master port is located.')
wtSeriB2bSlave_DispString1 = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 11, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("wtSeriB2bSlave-DispString1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriB2bSlave_DispString1.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bSlave_DispString1.setDescription('This mode allow compact sending of serial data to the network; the serial data stream is not broken up randomly, but rather serial packets can be sent in their original context even over the network as one packet. Enter two characters each in wtSeriB2bSlave-DispString1 and/or wtSeriB2bSlave-DispString2 to search for in the serial data stream. Only when one of the two strings has been found does the serial port pack the data into network packets. To search for only one character, set wtSeriB2bSlave-DispString2 to 0. If for example you configure wtSeriB2bSlave-DispString1 to 3100h and wtSeriB2bSlave-DispString2 to 0, only the character 1 is searched for. Both Dispatch Strings = 0 deactivates this mode. IMPORTANT: These characters are sent over the network!')
wtSeriB2bSlave_DispString2 = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("wtSeriB2bSlave-DispString2").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriB2bSlave_DispString2.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriB2bSlave_DispString2.setDescription('See DESCRIPTION of wtSeriB2bSlave-DispString1.')
wtSeriIpBusTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 12), )
if mibBuilder.loadTexts: wtSeriIpBusTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriIpBusTable.setDescription('List of all serial ports in IP-Bus-Mode relevant to their interface number')
wtSeriIpBusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 12, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriIpBusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriIpBusEntry.setDescription('IP-Bus-Mode parameters.')
wtSeriBusSlave_MasterIp = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 12, 1, 1), IpAddress()).setLabel("wtSeriBusSlave-MasterIp").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriBusSlave_MasterIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriBusSlave_MasterIp.setDescription('Setting on Com-Server ports connected to Slaves: Set here the complete IP address of the Com-Server with the Master port.')
wtSeriBusMaster_SubnetIp = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 12, 1, 2), IpAddress()).setLabel("wtSeriBusMaster-SubnetIp").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriBusMaster_SubnetIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriBusMaster_SubnetIp.setDescription('Setting on a Com-Server port connected to the Master: Enter here the network address of the Subnet in which the Master and Slaves are located. It is sufficient to entry any value not equal to zero (e.g., 1.0.0.0); the Com-Server itself will calculate the Subnet IP address from its own IP number and the Subnet mask (binary AND-operation) and enter it.')
wtSeriSlipTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 13), )
if mibBuilder.loadTexts: wtSeriSlipTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriSlipTable.setDescription('List of all ports in SLIP-Mode relevant to their interface number')
wtSeriSlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 13, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtSeriInterfaceNo"))
if mibBuilder.loadTexts: wtSeriSlipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriSlipEntry.setDescription('SLIP-Mode parameters.')
wtSeriSlipNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 13, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriSlipNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriSlipNetAddress.setDescription('Enter here the network address of the serially connected Subnet to which you want to route using SLIP.')
wtSeriSlipNetRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtSeriSlipNetRoutingOff", 1), ("wtSeriSlipNetRoutingOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtSeriSlipNetRouting.setStatus('mandatory')
if mibBuilder.loadTexts: wtSeriSlipNetRouting.setDescription('If this parameter has a value of 2, the Com-Server operates as a router for the Subnet specified under wtSeriSlipNetAddress. If the parameter has a value of 1, the Com-Server is transparent, i.e. all packets sent to the IP address of the Com-Server are passed on as SLIP packets to the serial port. The destination IP address (IP address of the Com-Server) is replaced by the parameter wtSeriSlipNetAddress. This allows assigning of individual IP addresses to the connected SLIP computers (=wtSeriSlipNetAddress), without having to assign an individual Subnet for each connection.')
wtDeaPorts = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDeaPorts.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaPorts.setDescription('Number of Com-Server digital I/O ports')
wtDeaInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 2), )
if mibBuilder.loadTexts: wtDeaInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaInterfaceTable.setDescription('List of interface numbers of all digital I/O ports.')
wtDeaInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 2, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaInterfaceEntry.setDescription('Interface number')
wtDeaInterfaceNo = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDeaInterfaceNo.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaInterfaceNo.setDescription('Interface number of the digital I/O ports.')
wtDeaPortTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 3), )
if mibBuilder.loadTexts: wtDeaPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaPortTable.setDescription('List of the general port entries relevant to the interface number of the digital I/O ports.')
wtDeaPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 3, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaPortEntry.setDescription('Port entries of the digital I/O ports.')
wtDeaLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(49152, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaLocalPort.setDescription('Local TCP/UDP port number of the Com-Server port. Port number on which the Com-Server accepts a TCP connection or which it uses as a local port in TCP client mode or UDP mode.')
wtDeaPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("wtDeaServerMode", 1), ("wtDeaTcpClient", 2), ("wtDeaBox2BoxMaster", 3), ("wtDeaUdpMode", 4), ("wtDeaSnmpAgent", 5), ("wtDeaBox2BoxSlave", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaPortMode.setDescription('This parameter specifies the mode for the Com-Server port. Depending on which mode is set, the corresponding list of the relevant parameters is available. If for example UDP mode (wtDeaPortMode = 4) is configured, only the list wtDeaUdpClientTable is available. In Server Mode (wtDeaPortMode = 1) no list of the port mode configurations is available.')
wtDeaDrvWatchdog = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaDrvWatchdog.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvWatchdog.setDescription('This parameter allows control of all instances which are active between the card driver in the Com-Server and the application on the computer, including the computer itself (e.g., TCP/IP stack in the computer, network card, network, ..). If one of these instances drops out, i.e., communication between the application and the card driver is no longer ensured, the card driver switches all outputs off after expiration of the driver watchdog (in 100ms ticks). IMPORTANT: If this parameter is activated, the application must poll the card driver regularly by sending an I/O structure. The value of the variable wtDeaDrvWatchdog should be a multiple of the poll rate. Monitoring is always active. If a TCP connection is closed without deactivating the outputs, this is done after expiration of the driver watchdog.')
wtDeaTcpClientTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4), )
if mibBuilder.loadTexts: wtDeaTcpClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpClientTable.setDescription('List of all digital I/O ports in TCP-Client-Mode relevant to their interface number')
wtDeaTcpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaTcpClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpClientEntry.setDescription('TCP-Client-Mode parameters')
wtDeaTcpServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaTcpServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpServerPort.setDescription('Port number which the application (TCP server process) addresses on the computer.')
wtDeaTcpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaTcpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpServerIp.setDescription('IP address of the computer on which the application (TCP server process) is active.')
wtDeaTcpInactTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaTcpInactTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpInactTimeout.setDescription('Connection timeout in seconds. If no data are exchanged within the specified time, the Com-Server closes the connection to the TCP server. The value 0 deactivates the timer.')
wtDeaTcpConnectTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaTcpConnectTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpConnectTimeout.setDescription('Connection timeout in seconds. This value is only effective in conjunction with an activated inactivity timeout. After the inactivity timeout has expired, the Com-Server attempts to send any remaining unsent user data for the duration of the connection timeout. If it does not receive a reply from the TCP server within this time, it assumes the server is hung. The data are the rejected and the connection reset. To prevent unintended data loss, select a sufficiently high value. The value 0 deactivates the timeout.')
wtDeaTcpInputMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaTcpInputMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaTcpInputMask.setDescription("Here the inputs to be polled by the card driver are configured. When a level change occurs on one or more inputs, the TCP connection to the application (TCP server) is opened and the I/O structure 'Write Register' is sent. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an input. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital inputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital inputs 0-7")
wtDeaUdpClientTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5), )
if mibBuilder.loadTexts: wtDeaUdpClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpClientTable.setDescription('List of all digital I/O ports in UDP-Mode relevant to their interface number')
wtDeaUdpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaUdpClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpClientEntry.setDescription('UDP-Mode parameters')
wtDeaUdpServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaUdpServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpServerPort.setDescription('Port number which the application (UPD server process) on the computer addresses.')
wtDeaUdpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaUdpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpServerIp.setDescription('IP address of the computer on which the application (UDP server process) is active.')
wtDeaUdpPacketProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wtDeaUdpPacketProtocolOff", 1), ("wtDeaUdpPacketProtocolOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaUdpPacketProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpPacketProtocol.setDescription('This switch activates (2) or deactivates (1) of the control procedure for the packet sequence in UDP mode (see also manual for I/O Com-Server.')
wtDeaUdpInputMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaUdpInputMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpInputMask.setDescription("Here the inputs to be polled by the card driver are configured. When a level change occurs on one or more inputs, the TCP connection to the application (TCP server) is opened and the I/O structure 'Write Register' is sent. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an input. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital inputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital inputs 0-7")
wtDeaUdpSendInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaUdpSendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaUdpSendInterval.setDescription("Configurable interval with a 100ms base, in which the card driver sends the I/O structure 'Write Register' with the contents of the input register to the configured application (UDP server). The value 0 deactivates this mode.")
wtDeaSnmpAgentTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 6), )
if mibBuilder.loadTexts: wtDeaSnmpAgentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaSnmpAgentTable.setDescription('List of all digital I/O ports in Snmp-Agent-Mode relevant to their interface number')
wtDeaSnmpAgentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 6, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaSnmpAgentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaSnmpAgentEntry.setDescription('Snmp-Agent-Mode parameters')
wtDeaSnmpManagerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 6, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaSnmpManagerIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaSnmpManagerIp.setDescription('IP address of the computer on which the SNMP Manager is located to which the Com-Server should send SNMP traps.')
wtDeaSnmpInputMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaSnmpInputMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaSnmpInputMask.setDescription('Here the inputs to be polled by the card driver are configured. When a level change occurs on one or more inputs, an SNMP trap with the variable dDrvInputRegister (see TRAP-DEFINITIONS) is sent to the configured SNMP Manager. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an input. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital inputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital inputs 0-7')
wtDeaSnmpSendInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaSnmpSendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaSnmpSendInterval.setDescription('Configurable interval with a 100ms base, in which the card driver reads the input register and sends an SNMP trap with the variable dDrvInputRegister (see TRAP-DEFINITIONS) to the configured SNMP Manager. A value of 0 deactivates this mode.')
wtDeaB2bMasterTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 7), )
if mibBuilder.loadTexts: wtDeaB2bMasterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bMasterTable.setDescription('List of all digital I/O ports in Box-to-Box-Master-Mode relevant to their interface number')
wtDeaB2bMasterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 7, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaB2bMasterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bMasterEntry.setDescription('Box-to-Box-Master-Mode parameters')
wtDeaB2bMaster_SlavePort = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setLabel("wtDeaB2bMaster-SlavePort").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaB2bMaster_SlavePort.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bMaster_SlavePort.setDescription('Port number of the digital I/O Com-Server-Slave port.')
wtDeaB2bMaster_SlaveIp = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 7, 1, 2), IpAddress()).setLabel("wtDeaB2bMaster-SlaveIp").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaB2bMaster_SlaveIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bMaster_SlaveIp.setDescription('IP address of the I/O Com-Server in which the Slave port is located.')
wtDeaB2bMaster_InputMask = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 7, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("wtDeaB2bMaster-InputMask").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaB2bMaster_InputMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bMaster_InputMask.setDescription('Here the inputs to be polled by the card drive are configured. When a level change occurs on one or more inputs, the entire input register is sent over the network and mapped in the output register of the other Com- Server I/O port. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an input. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital inputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital inputs 0-7')
wtDeaB2bMaster_SendInterval = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setLabel("wtDeaB2bMaster-SendInterval").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaB2bMaster_SendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bMaster_SendInterval.setDescription('Configurable interval with a 100ms base, in which the card driver maps the input register to the output register of the other I/O port. A value of 0 deactivates this mode.')
wtDeaB2bSlaveTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 8), )
if mibBuilder.loadTexts: wtDeaB2bSlaveTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bSlaveTable.setDescription('List of all digital I/O ports in Box-to-Box-Slave-Mode relevant to their interface number')
wtDeaB2bSlaveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 8, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaInterfaceNo"))
if mibBuilder.loadTexts: wtDeaB2bSlaveEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bSlaveEntry.setDescription('Box-to-Box-Slave-Mode parameters')
wtDeaB2bSlave_MasterPort = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setLabel("wtDeaB2bSlave-MasterPort").setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDeaB2bSlave_MasterPort.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bSlave_MasterPort.setDescription('Port number of the digital I/O Com-Server-Master port.')
wtDeaB2bSlave_MasterIp = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 8, 1, 2), IpAddress()).setLabel("wtDeaB2bSlave-MasterIp").setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDeaB2bSlave_MasterIp.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bSlave_MasterIp.setDescription('IP address of the I/O Com-Server in which the Master port is located.')
wtDeaB2bSlave_InputMask = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setLabel("wtDeaB2bSlave-InputMask").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaB2bSlave_InputMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bSlave_InputMask.setDescription('Here the inputs to be polled by the card driver are configured. When a level change occurs on one or more inputs, the entire input register is sent over the network and mapped in the output register of the other Com- Server I/O port. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an input. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital inputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital inputs 0-7')
wtDeaB2bSlave_SendInterval = MibScalar((1, 3, 6, 1, 4, 1, 5040, 1, 1, 1, 4, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setLabel("wtDeaB2bSlave-SendInterval").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaB2bSlave_SendInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaB2bSlave_SendInterval.setDescription('Configurable interval with a 100ms base, in which the card driver maps the input register to the output register of the other I/O port. The value 0 deactivates this mode.')
wtDeaDrvTable = MibTable((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1), )
if mibBuilder.loadTexts: wtDeaDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvTable.setDescription('List of all functions for managing the digital I/O port relevant to their interface number.')
wtDeaDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1), ).setIndexNames((0, "Com-Server-Intern-MIB", "wtDeaDrvInterfaceNo"))
if mibBuilder.loadTexts: wtDeaDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvEntry.setDescription('Functions for managing a digital I/O port.')
wtDeaDrvInterfaceNo = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDeaDrvInterfaceNo.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvInterfaceNo.setDescription('Interface number of the digital I/O port.')
wtDeaDrvInputRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wtDeaDrvInputRegister.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvInputRegister.setDescription('This variable is used to read the outputs of the digital I/O port. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an output. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital outputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital outputs 0-7')
wtDeaDrvOutputRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaDrvOutputRegister.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvOutputRegister.setDescription('This variable is used to read and write the outputs of the digital I/O port. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an output. Bit 0 corresponds to the LSB. OCTET 1, Bit 0-3: Digital outputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Digital outputs 0-7')
wtDeaDrvSetBit = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaDrvSetBit.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvSetBit.setDescription('This variable allows setting of individual digital outputs. The OCTETS are interpreted bit-by-bit, with each bit corresponding to an output. Bit 0 corresponds to the LSB. The first two OCTETS contain the mask which determines which of the outputs are to be set (corresponding bit = 1) and which outputs are to remain unchanged (corresponding bit = 0): OCTET 1, Bit 0-3: Mask for digital outputs 8-11 Bit 4-7: unused OCTET 2, Bit 0-7: Mask for digital outputs 0-7 OCTETS 3 and 4 contain the level (1=HIGH, 0=LOW) which the outputs to be changed should assume: OCTET 3, Bit 0-3: Level of digital outputs 8-11 Bit 4-7: unused OCTET 4, Bit 0-7: Level of digital outputs 0-7')
wtDeaDrvTrapInputMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaDrvTrapInputMask.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvTrapInputMask.setDescription('Here the inputs to be polled by the card driver are configured. When a level change occurs on one or more inputs, an SNMP trap is sent to the configured SNMP Manager with the variable wtDeaDrvInputRegister (see TRAP-DEFINITIONS). The OCTETS are interpreted bit-by-bit, with each bit corresponding to an input. Bit 0 corresponds to the LSB. OCTET 1, Bit 4-7: unused Bit 0-3: Digital inputs 8-11 OCTET 2, Bit 0-7: Digital inputs 0-7 This setting is no longer valid after a Com-Server restart. If you want the setting to be permanent, configure the variable wtDeaSnmpInputMask in the list wtDeaSnmpAgentTable.')
wtDeaDrvTrapInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wtDeaDrvTrapInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wtDeaDrvTrapInterval.setDescription('Configurable variable with a 100ms basis, in which the card driver reads the input register and sends an SNMP trap to the configured SNMP Manager with the variable wtDeaSnmpSendInterval. This setting is no longer valid after a Com-Server restart If you want the setting to be permanent, configure the variable wtDeaSnmpSendInterval in the list wtDeaSnmpAgentTable.')
deaInputChangedAlert = NotificationType((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1) + (0,1)).setObjects(("Com-Server-Intern-MIB", "wtDeaDrvInputRegister"))
if mibBuilder.loadTexts: deaInputChangedAlert.setDescription('This SNMP trap is generated when the level of an input on the digital I/O port has changed.')
deaIntervalExpiredAlert = NotificationType((1, 3, 6, 1, 4, 1, 5040, 1, 1, 2, 1, 1) + (0,2)).setObjects(("Com-Server-Intern-MIB", "wtDeaDrvInputRegister"))
if mibBuilder.loadTexts: deaIntervalExpiredAlert.setDescription('This SNMP trap is generated in the interval configured in the variable wtDeaDrvTrapInterval or variable wtDeaSnmpSendInterval.')
mibBuilder.exportSymbols("Com-Server-Intern-MIB", deaIntervalExpiredAlert=deaIntervalExpiredAlert, wtHsLines=wtHsLines, wtSeriLocalPort=wtSeriLocalPort, wtDeaB2bSlave_SendInterval=wtDeaB2bSlave_SendInterval, wtDevType=wtDevType, wtSeriUdpServerPort=wtSeriUdpServerPort, wtDeaB2bMaster_SlavePort=wtDeaB2bMaster_SlavePort, wtGateway=wtGateway, wtSysName=wtSysName, wtCableType=wtCableType, wtSeriUdpServerUrl=wtSeriUdpServerUrl, wtSeriFtpLoginString=wtSeriFtpLoginString, wtDeaDrvInputRegister=wtDeaDrvInputRegister, wtSeriInterfaceNo=wtSeriInterfaceNo, wtSeriBusSlave_MasterIp=wtSeriBusSlave_MasterIp, wtDeaB2bSlave_InputMask=wtDeaB2bSlave_InputMask, wtSeriUdpDispString2=wtSeriUdpDispString2, wtDeaUdpClientTable=wtDeaUdpClientTable, wtNetSetup=wtNetSetup, wtDeaB2bMaster_SendInterval=wtDeaB2bMaster_SendInterval, wtDeaTcpInputMask=wtDeaTcpInputMask, wtSeriTcpServerPort=wtSeriTcpServerPort, wtDeaB2bMaster_SlaveIp=wtDeaB2bMaster_SlaveIp, wtSeriUdpClientEntry=wtSeriUdpClientEntry, wtSubnetMask=wtSubnetMask, wtBootpClient=wtBootpClient, wtDeaDrvWatchdog=wtDeaDrvWatchdog, wtSeriPortState=wtSeriPortState, wtSeriSlipNetAddress=wtSeriSlipNetAddress, wtSeriFtpAutoFtp=wtSeriFtpAutoFtp, wtSeriTcpResponseMode=wtSeriTcpResponseMode, wtRetransmTimeout=wtRetransmTimeout, wtSeriB2bMaster_DispString2=wtSeriB2bMaster_DispString2, wtHsFunctions=wtHsFunctions, wtSeriUdpClientTable=wtSeriUdpClientTable, wtSeriUdpServerIp=wtSeriUdpServerIp, wtKeepAlive=wtKeepAlive, wtSeriB2bMaster_SlaveIp=wtSeriB2bMaster_SlaveIp, wtSeriFlushBuf=wtSeriFlushBuf, wtSeriTelnetClientTable=wtSeriTelnetClientTable, wtSeriB2bSlave_MasterIp=wtSeriB2bSlave_MasterIp, wtSeriTelnetClientEntry=wtSeriTelnetClientEntry, wtSeriB2bMasterEntry=wtSeriB2bMasterEntry, wtSeriTcpDisconnectChar=wtSeriTcpDisconnectChar, wtWbmPort=wtWbmPort, wtSeriFtpProtocolChar=wtSeriFtpProtocolChar, wtDeaTcpServerIp=wtDeaTcpServerIp, wtSeriTcpCAddress=wtSeriTcpCAddress, wtDeaB2bSlaveTable=wtDeaB2bSlaveTable, wtSeriSlipTable=wtSeriSlipTable, wtDeaDrvTable=wtDeaDrvTable, wtComServerIntern=wtComServerIntern, wtSeriB2bSlave_DispString2=wtSeriB2bSlave_DispString2, wtDeaSnmpInputMask=wtDeaSnmpInputMask, wtPassword=wtPassword, wtDeaB2bMaster_InputMask=wtDeaB2bMaster_InputMask, wtSeriB2bSlave_MasterPort=wtSeriB2bSlave_MasterPort, wtSeriTelnetServerUrl=wtSeriTelnetServerUrl, wtDeaDrvInterfaceNo=wtDeaDrvInterfaceNo, wtSeriPortSetup=wtSeriPortSetup, wtSeriPortTable=wtSeriPortTable, wtSeriB2bMasterTable=wtSeriB2bMasterTable, wtMtu=wtMtu, wtDeaDrvOutputRegister=wtDeaDrvOutputRegister, wtLinkSpeed=wtLinkSpeed, wtSeriIpBusEntry=wtSeriIpBusEntry, wtSwRev=wtSwRev, wtSeriTcpDispString2=wtSeriTcpDispString2, wtDeaTcpInactTimeout=wtDeaTcpInactTimeout, wtSeriMultiPortPrtEntry=wtSeriMultiPortPrtEntry, wtMacAddress=wtMacAddress, wtSysPswd=wtSysPswd, deaInputChangedAlert=deaInputChangedAlert, wtSeriTelnetServerIp=wtSeriTelnetServerIp, wtBaudrate=wtBaudrate, wtDeaPortTable=wtDeaPortTable, wtDeaTcpClientEntry=wtDeaTcpClientEntry, wtDeaUdpSendInterval=wtDeaUdpSendInterval, wtDeaSnmpSendInterval=wtDeaSnmpSendInterval, wtDeaSnmpAgentTable=wtDeaSnmpAgentTable, wtSeriInterfaceTable=wtSeriInterfaceTable, wtSeriTelnetDisconnectChar=wtSeriTelnetDisconnectChar, wtDeaDriver=wtDeaDriver, wtDatabits=wtDatabits, wtSeriPortEntry=wtSeriPortEntry, wtIpAddress=wtIpAddress, wtSeriTcpInactTimeout=wtSeriTcpInactTimeout, wtComServer=wtComServer, wtSeriIpBusTable=wtSeriIpBusTable, wtUartBaudrate=wtUartBaudrate, wtSeriMultiPortPrtTable=wtSeriMultiPortPrtTable, wtSeriFtpServerPort=wtSeriFtpServerPort, wtSeriB2bMaster_SlavePort=wtSeriB2bMaster_SlavePort, wtDeaTcpServerPort=wtDeaTcpServerPort, wtSeriUdpSeriCoding=wtSeriUdpSeriCoding, wtSeriTelnetServerPort=wtSeriTelnetServerPort, wtDeaSnmpAgentEntry=wtDeaSnmpAgentEntry, wtConfiguration=wtConfiguration, wtSeriRemoteIP=wtSeriRemoteIP, wtSeriFtpServerUrl=wtSeriFtpServerUrl, wtSeriB2bSlave_DispString1=wtSeriB2bSlave_DispString1, wtDeaInterfaceNo=wtDeaInterfaceNo, wtSeriPrtProtocolChar=wtSeriPrtProtocolChar, wtDeaDrvSetBit=wtDeaDrvSetBit, wtSeriTelnetEcho=wtSeriTelnetEcho, wtMibRev=wtMibRev, wtDeaTcpConnectTimeout=wtDeaTcpConnectTimeout, wut=wut, wtSeriPortMode=wtSeriPortMode, wtStopbits=wtStopbits, wtSeriUdpDispString1=wtSeriUdpDispString1, wtSwDate=wtSwDate, wtDeaUdpInputMask=wtDeaUdpInputMask, wtSeriB2bMaster_DispString1=wtSeriB2bMaster_DispString1, wtSeriUdpSeriProtocol=wtSeriUdpSeriProtocol, wtSeriTcpClientEntry=wtSeriTcpClientEntry, wtSeriTelnetInactTimeout=wtSeriTelnetInactTimeout, wtSeriFtpClientTable=wtSeriFtpClientTable, wtDhcpClient=wtDhcpClient, wtSeriInQueue=wtSeriInQueue, wtDeaB2bSlave_MasterPort=wtDeaB2bSlave_MasterPort, wtDeaPortEntry=wtDeaPortEntry, wtDeaTcpClientTable=wtDeaTcpClientTable, wtSerialPorts=wtSerialPorts, wtDeaUdpPacketProtocol=wtDeaUdpPacketProtocol, wtSeriUdpCAddress=wtSeriUdpCAddress, wtSeriPrtSeriCoding=wtSeriPrtSeriCoding, wtDeaB2bSlave_MasterIp=wtDeaB2bSlave_MasterIp, wtUartFifo=wtUartFifo, wtDeaInterfaceTable=wtDeaInterfaceTable, wtParity=wtParity, wtSystem=wtSystem, wtDeaDrvEntry=wtDeaDrvEntry, wtSeriUartTable=wtSeriUartTable, wtSeriFtpInactTimeout=wtSeriFtpInactTimeout, wtSeriTcpConnectTimeout=wtSeriTcpConnectTimeout, wtSeriTcpServerUrl=wtSeriTcpServerUrl, wtDeaDrvTrapInterval=wtDeaDrvTrapInterval, wtSeriTcpClientTable=wtSeriTcpClientTable, wtDeaB2bMasterEntry=wtDeaB2bMasterEntry, wtSeriB2bSlaveTable=wtSeriB2bSlaveTable, wtSeriBusMaster_SubnetIp=wtSeriBusMaster_SubnetIp, wtPhysPorts=wtPhysPorts, wtDeaB2bSlaveEntry=wtDeaB2bSlaveEntry, wtSeriNetPckDelay=wtSeriNetPckDelay, wtSeriTcpServerIp=wtSeriTcpServerIp, wtSeriUartEntry=wtSeriUartEntry, wtDeaDrvTrapInputMask=wtDeaDrvTrapInputMask, wtDnsSrv=wtDnsSrv, wtDeaLocalPort=wtDeaLocalPort, wtBaudDivisor=wtBaudDivisor, wtDeaUdpClientEntry=wtDeaUdpClientEntry, wtSeriFtpServerIp=wtSeriFtpServerIp, wtDeaPortMode=wtDeaPortMode, wtDeaB2bMasterTable=wtDeaB2bMasterTable, wtSeriSlipNetRouting=wtSeriSlipNetRouting, wtSeriRemotePort=wtSeriRemotePort, wtSeriB2bSlaveEntry=wtSeriB2bSlaveEntry, wtRunTime=wtRunTime, wtDeaInterfaceEntry=wtDeaInterfaceEntry, wtSeriFtpConnectTimeout=wtSeriFtpConnectTimeout, wtDeaPorts=wtDeaPorts, wtDeaPortSetup=wtDeaPortSetup, wtSeriPrtSeriProtocol=wtSeriPrtSeriProtocol, wtSeriTelnetChangeLineout=wtSeriTelnetChangeLineout, wtSeriTcpDispString1=wtSeriTcpDispString1, wtSeriSlipEntry=wtSeriSlipEntry, wtSeriInterfaceEntry=wtSeriInterfaceEntry, wtDeaSnmpManagerIp=wtDeaSnmpManagerIp, wtSeriFtpClientEntry=wtSeriFtpClientEntry, wtSeriUdpWrCAddress=wtSeriUdpWrCAddress, wtSeriControlPort=wtSeriControlPort, wtDeaUdpServerIp=wtDeaUdpServerIp, wtSeriUdpDisconnectChar=wtSeriUdpDisconnectChar, wtDeaUdpServerPort=wtDeaUdpServerPort, wtConfigMode=wtConfigMode)

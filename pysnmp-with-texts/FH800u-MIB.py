#
# PySNMP MIB module FH800u-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/FH800u-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:13:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, TimeTicks, Counter32, ModuleIdentity, enterprises, ObjectIdentity, Unsigned32, Integer32, MibIdentifier, iso, Bits, IpAddress, NotificationType, Gauge32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "TimeTicks", "Counter32", "ModuleIdentity", "enterprises", "ObjectIdentity", "Unsigned32", "Integer32", "MibIdentifier", "iso", "Bits", "IpAddress", "NotificationType", "Gauge32", "Counter64")
DisplayString, PhysAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "PhysAddress", "TextualConvention")
alliedTelesyn = MibIdentifier((1, 3, 6, 1, 4, 1, 207))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1))
dualHub = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 10))
fh812u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 10, 1))
fh824u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 10, 2))
mibObject = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8))
repeaterMib = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1))
newRepeaterMib = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20))
acctonHubMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3))
atactDualHubMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11))
fh800uMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1))
fh800uBasicCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1))
fh800uPerfMonCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2))
fh800uSwitchCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3))
fh800uSecurityCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5))
fh800uStackInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1))
stackInusedIP = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackInusedIP.setStatus('mandatory')
if mibBuilder.loadTexts: stackInusedIP.setDescription('The IP address currently used by the Dual-Speed Hub system. ')
stackInusedNetMask = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackInusedNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: stackInusedNetMask.setDescription('The subnet maskcurrently used by the Dual-Speed Hub system. ')
stackInusedGateway = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackInusedGateway.setStatus('mandatory')
if mibBuilder.loadTexts: stackInusedGateway.setDescription('The prefered gateway used to send traps.')
stackInusedServerSlipAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackInusedServerSlipAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackInusedServerSlipAddr.setDescription('The Server SLIP addresscurrently used by the Dual-Speed Hub system.')
stackInusedHostSlipAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackInusedHostSlipAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackInusedHostSlipAddr.setDescription('The Host SLIP address currently used by the Dual-Speed Hub system.')
stackInusedBootUpIP = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackInusedBootUpIP.setStatus('mandatory')
if mibBuilder.loadTexts: stackInusedBootUpIP.setDescription('The Bootup IP address currently used by the Dual-Speed Hub system. The Bootup IP must reside in the same subnet as the stackIP.')
stackTemporalIP = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackTemporalIP.setStatus('mandatory')
if mibBuilder.loadTexts: stackTemporalIP.setDescription('Used to change the IP address of the Dual-Speed Hub system. ')
stackTemporalNetMask = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackTemporalNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: stackTemporalNetMask.setDescription('Used to change the subnet mask of the Dual-Speed Hub system. ')
stackTemporalGateway = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackTemporalGateway.setStatus('mandatory')
if mibBuilder.loadTexts: stackTemporalGateway.setDescription('Used to change the prefered gateway to send traps.')
stackTemporalServerSlipAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackTemporalServerSlipAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackTemporalServerSlipAddr.setDescription('Used to change the Server SLIP address of the Dual-Speed Hub system. The SLIP address must reside in the same subnet as the stackIP.')
stackTemporalHostSlipAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackTemporalHostSlipAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackTemporalHostSlipAddr.setDescription('Used to change the Host SLIP address of the Dual-Speed Hub system.')
stackTemporalBootUpIP = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackTemporalBootUpIP.setStatus('mandatory')
if mibBuilder.loadTexts: stackTemporalBootUpIP.setDescription('Used to change the Bootup IP address of the Dual-Speed Hub system. The Bootup IP must reside in the same subnet as the stackIP.')
ipInformationReset = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipInformationReset.setStatus('mandatory')
if mibBuilder.loadTexts: ipInformationReset.setDescription('Setting the stackIP, stackNetMask,stackGateway, stackSlipAddr, and stackBootUpIP will not immediately enable parameters take effect . They will take effect when ipInformationReset is set to reset(2).')
stackHealthMonitor = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackHealthMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: stackHealthMonitor.setDescription(' < FOR fh800u Dual-Speed Hub DEFINITION : > There are two kinds of hubs : 12 ports need (1+ 12 + 1 + 1 + 1 + 1 +1 +1 +1) 20 bytes and 24 ports need (1+ 24 + 1 + 1 + 1 + 1 +1 +1 +1) 32 bytes The maximun size : 256 bytes (total for 8 hubs)=8 hub * (1+ 24 + 1 + 1 + 1 +1 +1 +1 +1) bytes | byte256 byte255......................byte2 byte1 | bit7 bit6 ... bit1 bit0 Use the first byte of each hub to indicate whether 20 or 32 bytes is used. BYTE 1: total number of ports on a hub 00001100 : 12 ports | | bit7... bit0 00011000 : 24 ports | | bit7... bit0 For 12-port hub BYTE 2 - 13 : port status for port 1 - 12 *BYTE 2 : port status for port 1 bit 0-4 : LED status bit 0 : link status 0 - no link; 1 - link bit 1 : partition status 0 - no part.; 1 - part. bit 2 : port operation status 0 - disabled; 1 - enabled bit 3-4 : port type status 00 - not present 01 - tenMb 10 - onehundredMb 11 - reserved bit 5-7 : reserved BYTE 14-25 :reserved BYTE 26 : Expansion Port (EP) status1 bit 0-2: EP Type 000 - not present 100 - 100BASE-TX(ST) FEM 010 - 100BASE-TX(SC) FEM 1001 to 1111 - reserved bit 3-4 : FEM forwarding mode status Applicable only to FEM module 00 - adaptive cut through 01 - reserved 10 - reserved 11 - store and forward bit 5: FEM back pressure status 0 - disabled; 1 - enabled bit 6-7 : reserved BYTE 27 : Expansion Port (EP) status2 bit 0-1 : LED status bit 0 : FEM link status 0 - no link; 1 - link bit 1 : FEM half/full duplex status 0 - full duplex; 1 - half duplex bit 2 : EP collision led status 0 - off; 1 - on bit 3-4 : bit 3 : tx LED status 0 - off; 1 - tx on bit 4 : rx LED status 0 - off; 1 - rx on bit 5-7 : reserved BYTE 28 : tenMb segment traffic/collision bit 0-1 : tenMb traffic LED status 00 - no traffic 01 - low traffic 10 - middle traffic 11 - high traffic bit 2-5 : tenMb collision LED status 0000 - none 0001 - 1 % 0010 - 3 % 0011 - 5 % 0100 - 10 % 0101 - >= 15 % bit 6-7 : reserved BYTE 29 : onehundredMb segment traffic/collision /Power/Switch LED status bit 0-1 : onehundredMb traffic LED status 00 - no traffic 01 - low traffic 10 - middle traffic 11 - high traffic bit 2-5 : onehundredMb collision LED status 0000 - none 0001 - 1 % 0010 - 3 % 0011 - 5 % 0100 - 10 % 0101 - >= 15 % bit 6 : Power LED 0 - OFF; 1 - ON bit 7 : Switch LED 0 - OFF; 1 - ON BYTE 30 :SNMP agent & switch status bit 0: internal switch bit 0 - not exist; 1 - exist bit 1: internal switch status 0 - inactive; 1 - active bit 2: expension switch bit 0 - bad; 1 - good bit 3: expension switch status 0 - inactive; 1 - active bit 4: agent bit 0 - not exist; 1 - exist bit 5 : master status 0 - Slave; 1 - Master bit 6 - 7 : reserved BYTE 31 : Rmon status bit 0 : rmon bit 0 - not exist; 1 - exist bit 1 - 2 :rmon segment 00 - all stack 01 - segment tenMb 10 - segment onehundredMb 11 - reserved bit 3 - 5 : RMON group Status 000 - not-present 001 - disabled 010 - Rmon-4Group 011 - Rmon-7Group 100 - Rmon-all 101 to 111 - reserved bit 6 -7 : reserved BYTE 32 : Hub Position(Hub ID)/Bus Termination bit 0 - 3 : hub position 0000 - invalid 0001 - 1 0010 - 2 0011 - 3 0100 - 4 0101 - 5 0110 - 6 0111 - 7 1000 - 8 1001 to 1111 - reserved bit 4 : termination status 0 - not end hub 1 - end hub in the stack bit 5 - 7 : reserved For 24-port hub BYTE 2 - 25 : port status for port 1 - 24 *BYTE 2 : port status for port 1 bit 0-4 : LED status bit 0 : link status 0 - no link; 1 - link bit 1 : partition status 0 - no part.; 1 - part. bit 2 : port operation status 0 - disabled; 1 - enabled bit 3-4 : port type status 00 - not present 01 - tenMb 10 - onehundredMb 11 - reserved bit 5-7 : reserved BYTE 26 : Expansion Port (EP) status1 bit 0-2: EP Type 000 - not present 100 - 100BASE-TX(ST) FEM 010 - 100BASE-TX(SC) FEM 1001 to 1111 - reserved bit 3-4 : FEM forwarding mode status Applicable only to FEM module 00 - adaptive cut through 01 - reserved 10 - reserved 11 - store and forward bit 5: FEM back pressure status 0 - disabled; 1 - enabled bit 6-7 : reserved BYTE 27 : Expansion Port (EP) status2 bit 0-1 : LED status bit 0 : FEM link status 0 - no link; 1 - link bit 1 : FEM half/full duplex status 0 - full duplex; 1 - half duplex bit 2 : EP collision led status 0 - off; 1 - on bit 3-4 : bit 3 : tx LED status 0 - off; 1 - tx on bit 4 : rx LED status 0 - off; 1 - rx on bit 5-7 : reserved BYTE 28 : tenMb segment traffic/collision bit 0-1 : tenMb traffic LED status 00 - no traffic 01 - low traffic 10 - middle traffic 11 - high traffic bit 2-5 : tenMb collision LED status 0000 - none 0001 - 1 % 0010 - 3 % 0011 - 5 % 0100 - 10 % 0101 - >= 15 % bit 6-7 : reserved BYTE 29 : onehundredMb segment traffic/collision /Power/Switch LED status bit 0-1 : onehundredMb traffic LED status 00 - no traffic 01 - low traffic 10 - middle traffic 11 - high traffic bit 2-5 : onehundredMb collision LED status 0000 - none 0001 - 1 % 0010 - 3 % 0011 - 5 % 0100 - 10 % 0101 - >= 15 % bit 6 : Power LED 0 - OFF; 1 - ON bit 7 : Switch LED 0 - OFF; 1 - ON BYTE 30 :SNMP agent & switch status bit 0: internal switch bit 0 - not exist; 1 - exist bit 1: internal switch status 0 - inactive; 1 - active bit 2: expension switch bit 0 - bad; 1 - good bit 3: expension switch status 0 - inactive; 1 - active bit 4: agent bit 0 - not exist; 1 - exist bit 5 : master status 0 - Slave; 1 - Master bit 6 - 7 : reserved BYTE 31 : Rmon status bit 0 : rmon bit 0 - not exist; 1 - exist bit 1 - 2 :rmon segment 00 - all stack 01 - segment tenMb 10 - segment onehundredMb 11 - reserved bit 3 - 5 : RMON group Status 000 - not-present 001 - disabled 010 - Rmon-4Group 011 - Rmon-7Group 100 - Rmon-all 101 to 111 - reserved bit 6 -7 : reserved BYTE 32 : Hub Position(Hub ID)/Bus Termination bit 0 - 3 : hub position 0000 - invalid 0001 - 1 0010 - 2 0011 - 3 0100 - 4 0101 - 5 0110 - 6 0111 - 7 1000 - 8 1001 to 1111 - reserved bit 4 : termination status 0 - not end hub 1 - end hub in the stack bit 5 - 7 : reserved')
fh800uGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2))
groupTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1), )
if mibBuilder.loadTexts: groupTable.setStatus('mandatory')
if mibBuilder.loadTexts: groupTable.setDescription('A group means a hub unit')
groupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1), ).setIndexNames((0, "FH800u-MIB", "groupID"))
if mibBuilder.loadTexts: groupEntry.setStatus('mandatory')
groupID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupID.setStatus('mandatory')
if mibBuilder.loadTexts: groupID.setDescription('The ID number of a hub unit, used to select it')
groupType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fh824u", 1), ("fh812u", 2), ("eh3024a", 3), ("eh3012a", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupType.setStatus('mandatory')
if mibBuilder.loadTexts: groupType.setDescription('Type of hub unit')
groupCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: groupCounterReset.setStatus('mandatory')
if mibBuilder.loadTexts: groupCounterReset.setDescription('Write any value to this variable to reset the counters of the hub unit. 2 is a value commonly used to reset things')
groupPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupPosition.setStatus('mandatory')
if mibBuilder.loadTexts: groupPosition.setDescription('Physical position of a hub unit in top-down order, only supported if hardware permits such as Dual-Speed Hub systems')
groupRptrHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupRptrHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: groupRptrHwVer.setDescription('Hardware version of the repeater board.')
groupRptrSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupRptrSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: groupRptrSerialNo.setDescription('Serial number of the repeater board.')
groupSysMajorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupSysMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: groupSysMajorVer.setDescription('Microcode major version of this hub.')
groupSysMinorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupSysMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: groupSysMinorVer.setDescription('Microcode minor version of this hub.')
groupPostCodeMajorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupPostCodeMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: groupPostCodeMajorVer.setDescription('POST microcode major version of this hub.')
groupPostCodeMinorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupPostCodeMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: groupPostCodeMinorVer.setDescription('POST microcode minor version of this hub.')
groupAgentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-present", 1), ("primary", 2), ("backup", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupAgentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: groupAgentStatus.setDescription('Status of this hub agent. Each stack allows an SNMP primary agent. primary(2): The agent in this stack is a primary agent. backup(3): The agent in this stack is a backup agent.')
groupAgentHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupAgentHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: groupAgentHwVer.setDescription('Hardware version of the agent board.')
groupAgentSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 13), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupAgentSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: groupAgentSerialNo.setDescription('Serial number of the agent board.')
groupAgentPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 14), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: groupAgentPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: groupAgentPhysAddr.setDescription('MAC address of this hub agent')
groupAgentBootupOption = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("tftp-download", 2), ("bootp-get-ip", 3), ("bootp-download", 4), ("bootp-upgrade", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: groupAgentBootupOption.setStatus('mandatory')
if mibBuilder.loadTexts: groupAgentBootupOption.setDescription('This variable defines how to start the microcode in the segment. normal(1): Use NVRAM information and flash ROM microcode to start up the system. tftp-download(2): Always download the new version of microcode into RAM and start it. bootp-get-ip(3): Get the IP information from the BootP server, and then start up the microcode in flash ROM. bootp-download(4): Get the IP information from the BootP server, and then download the microcode from the TFTP server. bootp-upgrade(5): Get the IP information from the BootP server, and then download the microcode from the TFTP server. After the download has been completed, upgrade the microcode in system flash ROM.')
groupAgentBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("baud-9600", 1), ("baud-14400", 2), ("baud-19200", 3), ("baud-38400", 4), ("baud-57600", 5), ("baud-115200", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: groupAgentBaudrate.setStatus('mandatory')
if mibBuilder.loadTexts: groupAgentBaudrate.setDescription('Baud rate of the console port')
fh800uPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3))
portTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1), )
if mibBuilder.loadTexts: portTable.setStatus('mandatory')
if mibBuilder.loadTexts: portTable.setDescription(' information about ports in a system. Each port belongs to a group.')
portEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1, 1), ).setIndexNames((0, "FH800u-MIB", "portGroupID"), (0, "FH800u-MIB", "portID"))
if mibBuilder.loadTexts: portEntry.setStatus('mandatory')
portGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupID.setDescription('ID of the hub unit')
portID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portID.setStatus('mandatory')
if mibBuilder.loadTexts: portID.setDescription('ID of the port unit')
portSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tenMb", 1), ("onehundredMbClassI", 2), ("onehundredMbClassII", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portSpeed.setDescription('Ethernet connector type of a port')
portSpeedConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tenMb", 1), ("onehundredMbClassI", 2), ("onehundredMbClassII", 3), ("autoDetected", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSpeedConfig.setStatus('mandatory')
if mibBuilder.loadTexts: portSpeedConfig.setDescription('Select the Ethernet connector type of a port')
portSegmtID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSegmtID.setStatus('mandatory')
if mibBuilder.loadTexts: portSegmtID.setDescription(' ID of the Segment unit')
fh800uSegmentInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 4))
fh800uRmonConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5))
nicAttachSegment = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nicAttachSegment.setStatus('mandatory')
if mibBuilder.loadTexts: nicAttachSegment.setDescription('The value represents the segment that the NIC is attached to.')
fullRmonSegment = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fullRmonSegment.setStatus('mandatory')
if mibBuilder.loadTexts: fullRmonSegment.setDescription('The value shows if the segment supports all rmon or only 4 rmon groups.')
rmonConfigTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5, 3), )
if mibBuilder.loadTexts: rmonConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: rmonConfigTable.setDescription('RMON configuration table information; the index is the ID of of the segment the rmon montioring .')
rmonConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5, 3, 1), ).setIndexNames((0, "FH800u-MIB", "rmonConfigSegmtID"))
if mibBuilder.loadTexts: rmonConfigEntry.setStatus('mandatory')
rmonConfigSegmtID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonConfigSegmtID.setStatus('mandatory')
if mibBuilder.loadTexts: rmonConfigSegmtID.setDescription(' ID of the Segment rmon is montioring.')
rmonConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rmonConfigStatus.setDescription('Status of this RMON segment.')
fh800uPerfMonSegmentInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3))
perfMonSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1), )
if mibBuilder.loadTexts: perfMonSegmentTable.setStatus('optional')
perfMonSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1), ).setIndexNames((0, "FH800u-MIB", "segmentPerfID"))
if mibBuilder.loadTexts: perfMonSegmentEntry.setStatus('mandatory')
segmentPerfID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentPerfID.setStatus('mandatory')
if mibBuilder.loadTexts: segmentPerfID.setDescription('ID used to select a segment')
segmentCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: segmentCRCErrors.setDescription('Total CRC errors received by a segment.')
segmentAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: segmentAlignmentErrors.setDescription('Total frame alignment errors received by a segment')
segmentCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: segmentCollisions.setDescription('Total collisions received in a segment')
segmentTotalPortIsolates = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentTotalPortIsolates.setStatus('mandatory')
if mibBuilder.loadTexts: segmentTotalPortIsolates.setDescription(' Total isolated ports in a segment. ')
segmentSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentSymbolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: segmentSymbolErrors.setDescription('Total frame symbol errors received by a segment ')
fh800uSwitchStatsInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1))
switchPortStatsTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1), )
if mibBuilder.loadTexts: switchPortStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortStatsTable.setDescription('This table provides statistics on each port on each switch module in the stack. Note that statistics for the external port on media and switch/media modules are unavailable to the agent and are reported as 0. Statistics for port 2 (the internal 10Mbps port) on media modules are also reported as 0.')
switchPortStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1), ).setIndexNames((0, "FH800u-MIB", "switchPortStatsGroupID"), (0, "FH800u-MIB", "switchPortStatsID"))
if mibBuilder.loadTexts: switchPortStatsEntry.setStatus('mandatory')
switchPortStatsGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortStatsGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortStatsGroupID.setDescription('The group ID of the switch module port being referenced. If the group is not present, or if there is no switch module installed in the group, GetRequests and SetRequests are rejected with an error-status of noSuchName(2). GetNextRequests skip entries for nonexistent modules.')
switchPortStatsID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortStatsID.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortStatsID.setDescription('The port ID of the switch module port being referenced. Port 1 is always the internal 100Mbps port. Port 2 is always the internal 10Mbps port. Port 3 is always the external port. Note that port 2 is inactive on media modules and port 3 is inactive on internal switch modules. Note: Statistics for the external port are unavailable to the agent and are reported as 0.')
switchPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortReadableFrames.setDescription('The number of valid frames received by the port.')
switchPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortReadableOctets.setDescription('The number of octets (bytes) in all valid frames received by the port.')
switchPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortFCSErrors.setDescription('The number of valid-length frames received by the port that had FCS (frame check sequence) errors.')
switchPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortAlignmentErrors.setDescription('The number of valid-length frames received by the port that had alignment errors.')
switchPortFramesTooLong = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortFramesTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortFramesTooLong.setDescription('The number of frames received by the port that were longer than 1518 bytes.')
switchPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortShortEvents.setDescription('The number of frames received by the port that were shorter than 82 bits.')
switchPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortRunts.setDescription('The number of frames received by the port that were longer than 82 bits but shorter than 512 bits (64 bytes).')
switchPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortCollisions.setDescription('The number of collisions detected on the port.')
switchPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortLateEvents.setDescription('The number of collisions detected on the port that occurred later than 512 bit-times into the transmission of a packet.')
switchPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortVeryLongEvents.setDescription('The number of times any activity continued for more than 4 to 7.5 milliseconds.')
switchPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortDataRateMismatches.setDescription('The number of times the incoming data rate mismatched the local clock source enough to cause a FIFO overflow or underflow.')
switchPortBroadcastPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortBroadcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortBroadcastPackets.setDescription('The number of good broadcast frames received by the port.')
switchPortMulticastPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 3, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchPortMulticastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortMulticastPackets.setDescription('The number of good multicast (not broadcast) frames received by the port.')
fh800uSecurityInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3))
securityPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3), )
if mibBuilder.loadTexts: securityPortTable.setStatus('mandatory')
securityPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3, 1), ).setIndexNames((0, "FH800u-MIB", "securityPortGroupID"), (0, "FH800u-MIB", "securityPortID"))
if mibBuilder.loadTexts: securityPortEntry.setStatus('mandatory')
securityPortGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityPortGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: securityPortGroupID.setDescription('ID of a hub unit')
securityPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityPortID.setStatus('mandatory')
if mibBuilder.loadTexts: securityPortID.setDescription('Port ID in a hub unit')
securityPortAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: securityPortAddr.setDescription('MAC address')
securityAutoLearnAction = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("learned", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityAutoLearnAction.setStatus('mandatory')
if mibBuilder.loadTexts: securityAutoLearnAction.setDescription("Setting this object to inactive(1) disables the auto-learn function for the physical address authorized access to this port. Once this object is set to active(2), the agent will set the authorized address to 0 first and then start the auto-learn process, and the hub will begin to read the source address of the first incoming error-free frame. The source address obtained will become the authorized address and the object securityAuthorizedAddr will be changed accordingly. When the authorized address has been learned successfully, the status of this port will be reflected as learned(3). Otherwise the status will remain as active(2). Setting to the last value, learned(3), is not acceptable; 'snmpBadValue' will be returned.")
securityPortIntrusion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11, 1, 5, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("warning-and-disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityPortIntrusion.setStatus('mandatory')
if mibBuilder.loadTexts: securityPortIntrusion.setDescription('Set this variable to set function active or inactive')
fh800uIntrusionHappen = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 11) + (0,1)).setObjects(("FH800u-MIB", "securityPortIntrusion"), ("FH800u-MIB", "securityPortGroupID"), ("FH800u-MIB", "securityPortID"))
if mibBuilder.loadTexts: fh800uIntrusionHappen.setDescription('There were some intruders on some port in this system')
mibBuilder.exportSymbols("FH800u-MIB", groupEntry=groupEntry, stackTemporalIP=stackTemporalIP, rmonConfigTable=rmonConfigTable, segmentCRCErrors=segmentCRCErrors, stackInusedGateway=stackInusedGateway, groupRptrHwVer=groupRptrHwVer, rmonConfigStatus=rmonConfigStatus, portSpeed=portSpeed, segmentTotalPortIsolates=segmentTotalPortIsolates, segmentCollisions=segmentCollisions, groupPostCodeMinorVer=groupPostCodeMinorVer, perfMonSegmentTable=perfMonSegmentTable, fh800uPerfMonSegmentInfo=fh800uPerfMonSegmentInfo, mibObject=mibObject, groupPostCodeMajorVer=groupPostCodeMajorVer, portTable=portTable, fh800uIntrusionHappen=fh800uIntrusionHappen, securityPortTable=securityPortTable, switchPortRunts=switchPortRunts, fh800uPortInfo=fh800uPortInfo, switchPortLateEvents=switchPortLateEvents, fh800uSegmentInfo=fh800uSegmentInfo, switchPortStatsID=switchPortStatsID, fh812u=fh812u, groupPosition=groupPosition, ipInformationReset=ipInformationReset, groupAgentSerialNo=groupAgentSerialNo, fh800uPerfMonCapability=fh800uPerfMonCapability, groupAgentStatus=groupAgentStatus, stackTemporalHostSlipAddr=stackTemporalHostSlipAddr, groupSysMajorVer=groupSysMajorVer, groupSysMinorVer=groupSysMinorVer, portSpeedConfig=portSpeedConfig, switchPortMulticastPackets=switchPortMulticastPackets, alliedTelesyn=alliedTelesyn, switchPortBroadcastPackets=switchPortBroadcastPackets, acctonHubMIB=acctonHubMIB, fh800uSecurityInfo=fh800uSecurityInfo, securityPortEntry=securityPortEntry, fh800uSecurityCapability=fh800uSecurityCapability, switchPortAlignmentErrors=switchPortAlignmentErrors, fh800uRmonConfig=fh800uRmonConfig, switchPortStatsGroupID=switchPortStatsGroupID, groupRptrSerialNo=groupRptrSerialNo, perfMonSegmentEntry=perfMonSegmentEntry, stackTemporalNetMask=stackTemporalNetMask, newRepeaterMib=newRepeaterMib, switchPortVeryLongEvents=switchPortVeryLongEvents, dualHub=dualHub, groupAgentBaudrate=groupAgentBaudrate, atactDualHubMgt=atactDualHubMgt, fh800uMgt=fh800uMgt, fullRmonSegment=fullRmonSegment, segmentAlignmentErrors=segmentAlignmentErrors, fh800uBasicCapability=fh800uBasicCapability, stackTemporalGateway=stackTemporalGateway, rmonConfigEntry=rmonConfigEntry, stackInusedHostSlipAddr=stackInusedHostSlipAddr, groupID=groupID, switchPortReadableOctets=switchPortReadableOctets, switchPortStatsTable=switchPortStatsTable, stackHealthMonitor=stackHealthMonitor, securityPortGroupID=securityPortGroupID, securityPortID=securityPortID, nicAttachSegment=nicAttachSegment, fh800uSwitchCapability=fh800uSwitchCapability, portSegmtID=portSegmtID, groupCounterReset=groupCounterReset, products=products, repeaterMib=repeaterMib, stackInusedServerSlipAddr=stackInusedServerSlipAddr, stackInusedBootUpIP=stackInusedBootUpIP, stackInusedIP=stackInusedIP, fh800uStackInfo=fh800uStackInfo, securityAutoLearnAction=securityAutoLearnAction, switchPortReadableFrames=switchPortReadableFrames, switchPortCollisions=switchPortCollisions, securityPortAddr=securityPortAddr, switchPortFCSErrors=switchPortFCSErrors, rmonConfigSegmtID=rmonConfigSegmtID, groupType=groupType, stackTemporalServerSlipAddr=stackTemporalServerSlipAddr, portID=portID, fh800uSwitchStatsInfo=fh800uSwitchStatsInfo, groupAgentPhysAddr=groupAgentPhysAddr, groupAgentHwVer=groupAgentHwVer, portGroupID=portGroupID, switchPortFramesTooLong=switchPortFramesTooLong, stackTemporalBootUpIP=stackTemporalBootUpIP, groupTable=groupTable, segmentSymbolErrors=segmentSymbolErrors, switchPortStatsEntry=switchPortStatsEntry, switchPortDataRateMismatches=switchPortDataRateMismatches, fh800uGroupInfo=fh800uGroupInfo, stackInusedNetMask=stackInusedNetMask, portEntry=portEntry, groupAgentBootupOption=groupAgentBootupOption, securityPortIntrusion=securityPortIntrusion, segmentPerfID=segmentPerfID, switchPortShortEvents=switchPortShortEvents, fh824u=fh824u)

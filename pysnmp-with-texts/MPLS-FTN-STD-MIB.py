#
# PySNMP MIB module MPLS-FTN-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-FTN-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:14:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
Dscp, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
ifGeneralInformationGroup, InterfaceIndexOrZero, ifCounterDiscontinuityGroup = mibBuilder.importSymbols("IF-MIB", "ifGeneralInformationGroup", "InterfaceIndexOrZero", "ifCounterDiscontinuityGroup")
InetAddress, InetAddressType, InetPortNumber = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetPortNumber")
mplsStdMIB, = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ModuleIdentity, NotificationType, Counter64, ObjectIdentity, IpAddress, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, TimeTicks, MibIdentifier, Unsigned32, iso, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "NotificationType", "Counter64", "ObjectIdentity", "IpAddress", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "TimeTicks", "MibIdentifier", "Unsigned32", "iso", "Integer32")
RowPointer, StorageType, DisplayString, TimeStamp, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "StorageType", "DisplayString", "TimeStamp", "RowStatus", "TextualConvention")
mplsFTNStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 8))
mplsFTNStdMIB.setRevisions(('2004-06-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsFTNStdMIB.setRevisionsDescriptions(('Initial version issued as part of RFC 3814.',))
if mibBuilder.loadTexts: mplsFTNStdMIB.setLastUpdated('200406030000Z')
if mibBuilder.loadTexts: mplsFTNStdMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsFTNStdMIB.setContactInfo(' Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-244-3051 Email: tnadeau@cisco.com Cheenu Srinivasan Postal: Bloomberg L.P. 499 Park Avenue New York, NY 10022 Tel: +1-212-893-3682 Email: cheenu@bloomberg.net Arun Viswanathan Postal: Force10 Networks, Inc. 1440 McCarthy Blvd Milpitas, CA 95035 Tel: +1-408-571-3516 Email: arunv@force10networks.com IETF MPLS Working Group email: mpls@uu.net')
if mibBuilder.loadTexts: mplsFTNStdMIB.setDescription('Copyright (C) The Internet Society (2004). The initial version of this MIB module was published in RFC 3814. For full legal notices see the RFC itself or see: http://www.ietf.org/copyrights/ianamib.html This MIB module contains managed object definitions for specifying FEC to NHLFE (FTN) mappings and corresponding performance for MPLS.')
class MplsFTNEntryIndex(TextualConvention, Unsigned32):
    description = 'Index for an entry in mplsFTNTable.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class MplsFTNEntryIndexOrZero(TextualConvention, Unsigned32):
    description = 'Index for an entry in mplsFTNTable or the special value zero. The value zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax. Examples of the usage of zero might include situations when none or all entries in mplsFTNTable need to be referenced.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

mplsFTNNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 8, 0))
mplsFTNObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 8, 1))
mplsFTNConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 8, 2))
mplsFTNIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 1), MplsFTNEntryIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsFTNIndexNext.setDescription('This object contains the next available valid value to be used for mplsFTNIndex when creating entries in the mplsFTNTable. When creating a new conceptual row (configuration entry) in mplsFTNTable with an SNMP SET operation the command generator (Network Management Application) must first issue a management protocol retrieval operation to obtain the current value of this object. If the command responder (agent) does not wish to allow creation of more entries in mplsFTNTable, possibly because of resource exhaustion, this object MUST return a value of 0. If a non-zero value is returned the Network Management Application must determine whether the value is indeed still unused since two Network Management Applications may attempt to create a row simultaneously and use the same value. If it is currently unused and the SET succeeds, the agent MUST change the value of this object to a currently unused non-zero value (according to an implementation specific algorithm) or zero (if no further row creation will be permitted). If the value is in use, however, the SET fails and the Network Management Application must then reread this object to obtain a new usable value.')
mplsFTNTableLastChanged = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: mplsFTNTableLastChanged.setDescription('Indicates the last time an entry was added, deleted or modified in mplsFTNTable. Management stations should consult this object to determine if mplsFTNTable requires their attention. This object is particularly useful for applications performing a retrieval on mplsFTNTable to ensure that the table is not modified during the retrieval operation.')
mplsFTNTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3), )
if mibBuilder.loadTexts: mplsFTNTable.setReference('J. Postel, Internet Protocol, RFC 791, STD 5, September 1981 Deering, S., and R. Hinden, Internet Protocol, Version 6 (IPv6) Specification, RFC 2460, December 1998 Nichols, K, Blake, S., Baker, F. and D. Black, Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers, RFC 2474, December 1998 Srinivasan, C., A. Viswanathan, and T. Nadeau, MPLS Label Switch Router Management Information Base, RFC 3813 Srinivasan, C., A. Viswanathan, and T. Nadeau, MPLS Traffic Engineering Management Information Base, RFC 3812')
if mibBuilder.loadTexts: mplsFTNTable.setStatus('current')
if mibBuilder.loadTexts: mplsFTNTable.setDescription('This table contains the currently defined FTN entries. This table allows FEC to NHLFE mappings to be specified. Each entry in this table defines a rule to be applied to incoming packets (on interfaces that the FTN entry is activated on using mplsFTNMapTable) and an action to be taken on matching packets (mplsFTNActionPointer). This table supports 6-tuple matching rules based on one or more of source address range, destination address range, source port range, destination port range, IPv4 Protocol field or IPv6 next-header field and the DiffServ Code Point (DSCP) to be specified. The action pointer points either to instance of mplsXCEntry in MPLS-LSR-STD-MIB when the NHLFE is a non- TE LSP, or to an instance of mplsTunnelEntry in the MPLS-TE-STD-MIB when the NHLFE is an originating TE tunnel.')
mplsFTNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1), ).setIndexNames((0, "MPLS-FTN-STD-MIB", "mplsFTNIndex"))
if mibBuilder.loadTexts: mplsFTNEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFTNEntry.setDescription('Each entry represents one FTN entry which defines a rule to compare incoming packets with and an action to be taken on matching packets.')
mplsFTNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 1), MplsFTNEntryIndex())
if mibBuilder.loadTexts: mplsFTNIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNIndex.setDescription('This is the unique index for a conceptual row in mplsFTNTable. To create a new conceptual row in mplsFTNTable a Network Management Application SHOULD retrieve the current value of mplsFTNIndexNext to determine the next valid available value of mplsFTNIndex.')
mplsFTNRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsFTNRowStatus.setDescription("Used for controlling the creation and deletion of this row. All writeable objects in this row may be modified at any time. If a Network Management Application attempts to delete a conceptual row by setting this object to 'destroy' and there are one or more entries in mplsFTNMapTable pointing to the row (i.e., when mplsFTNIndex of the conceptual row being deleted is equal to mplsFTNMapCurrIndex for one or more entries in mplsFTNMapTable), the agent MUST also destroy the corresponding entries in mplsFTNMapTable.")
mplsFTNDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDescr.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDescr.setDescription('The description of this FTN entry. Since the index for this table has no particular significance or meaning, this object should contain some meaningful text that an operator could use to further distinguish entries in this table.')
mplsFTNMask = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 4), Bits().clone(namedValues=NamedValues(("sourceAddr", 0), ("destAddr", 1), ("sourcePort", 2), ("destPort", 3), ("protocol", 4), ("dscp", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNMask.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMask.setDescription('This bit map indicates which of the fields described next, namely source address range, destination address range, source port range, destination port range, IPv4 Protocol field or IPv6 next-header field and Differentiated Services Code Point (DSCP) is active for this FTN entry. If a particular bit is set to zero then the corresponding field in the packet MUST be ignored for comparison purposes.')
mplsFTNAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNAddrType.setDescription('This object determines the type of address contained in the source and destination address objects (mplsFTNSourceAddrMin, mplsFTNSourceAddrMax, mplsFTNDestAddrMin and mplsFTNDestAddrMax) of a conceptual row. This object MUST NOT be set to unknown(0) when mplsFTNMask has bit positions sourceAddr(0) or destAddr(1) set to one. When both these bit positions of mplsFTNMask are set to zero the value of mplsFTNAddrType SHOULD be set to unknown(0) and the corresponding source and destination address objects SHOULD be set to zero-length strings.')
mplsFTNSourceAddrMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourceAddrMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourceAddrMin.setDescription('The lower end of the source address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNSourceAddrMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourceAddrMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourceAddrMax.setDescription('The upper end of the source address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNDestAddrMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 8), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestAddrMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestAddrMin.setDescription('The lower end of the destination address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNDestAddrMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 9), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestAddrMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestAddrMax.setDescription('The higher end of the destination address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNSourcePortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 10), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourcePortMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourcePortMin.setDescription('The lower end of the source port range.')
mplsFTNSourcePortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 11), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourcePortMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourcePortMax.setDescription('The higher end of the source port range ')
mplsFTNDestPortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 12), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestPortMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestPortMin.setDescription('The lower end of the destination port range.')
mplsFTNDestPortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 13), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestPortMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestPortMax.setDescription('The higher end of the destination port range.')
mplsFTNProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNProtocol.setStatus('current')
if mibBuilder.loadTexts: mplsFTNProtocol.setDescription('The IP protocol to match against the IPv4 protocol number or IPv6 Next-Header number in the packet. A value of 255 means match all. Note that the protocol number of 255 is reserved by IANA, and Next-Header number of 0 is used in IPv6.')
mplsFTNDscp = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 15), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDscp.setReference('Nichols, K., Blake, S., Baker, F. and D. Black, Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers, RFC 2474, December 1998.')
if mibBuilder.loadTexts: mplsFTNDscp.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDscp.setDescription('The contents of the DSCP field.')
mplsFTNActionType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redirectLsp", 1), ("redirectTunnel", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNActionType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNActionType.setDescription('The type of action to be taken on packets matching this FTN entry.')
mplsFTNActionPointer = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 17), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNActionPointer.setStatus('current')
if mibBuilder.loadTexts: mplsFTNActionPointer.setDescription('If mplsFTNActionType is redirectLsp(1), then this object MUST contain zeroDotZero or point to a instance of mplsXCEntry indicating the LSP to redirect matching packets to. If mplsFTNActionType is redirectTunnel(2), then this object MUST contain zeroDotZero or point to a instance of mplsTunnelEntry indicating the MPLS TE tunnel to redirect matching packets to. If this object points to a conceptual row instance in a table consistent with mplsFTNActionType but this instance does not currently exist then no action will be taken on packets matching such an FTN entry till this instance comes into existence. If this object contains zeroDotZero then no action will be taken on packets matching such an FTN entry till it is populated with a valid pointer consistent with the value of mplsFTNActionType as explained above.')
mplsFTNStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 3, 1, 18), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNStorageType.setDescription("The storage type for this FTN entry. Conceptual rows having the value 'permanent' need not allow write- access to any columnar objects in the row.")
mplsFTNMapTableLastChanged = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNMapTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapTableLastChanged.setDescription('Indicates the last time an entry was added, deleted or modified in mplsFTNMapTable. Management stations should consult this object to determine if the table requires their attention. This object is particularly useful for applications performing a retrieval on mplsFTNMapTable to ensure that the table is not modified during the retrieval operation.')
mplsFTNMapTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5), )
if mibBuilder.loadTexts: mplsFTNMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapTable.setDescription("This table contains objects which provide the capability to apply or map FTN rules as defined by entries in mplsFTNTable to specific interfaces in the system. FTN rules are compared with incoming packets in the order in which they are applied on an interface. The indexing structure of mplsFTNMapTable is as follows. - mplsFTNMapIndex indicates the interface to which the rule is being applied. A value of 0 represents the application of the rule to all interfaces. - mplsFTNMapPrevIndex specifies the rule on the interface prior to the one being applied. A value of 0 specifies that the rule is being inserted at the head of the list of rules currently applied to the interface. - mplsFTNMapCurrIndex is the index in mplsFTNTable corresponding to the rule being applied. This indexing structure makes the entries in the table behave like items in a linked-list. The object mplsFTNMapPrevIndex in each conceptual row is a pointer to the previous entry that is applied to a particular interface. This allows a new entry to be 'inserted' at an arbitrary position in a list of entries currently applied to an interface. This object is self- adjusting, i.e., its value is automatically adjusted by the agent, if necessary, after an insertion or deletion operation. Using this linked-list structure, one can retrieve FTN entries in the order of application on a per-interface basis as follows: - To determine the first FTN entry on an interface with index ifIndex perform a GETNEXT retrieval operation on mplsFTNMapRowStatus.ifIndex.0.0; the returned object, if one exists, is (say) mplsFTNMapRowStatus.ifIndex.0.n (mplsFTNMapRowStatus is the first accessible columnar object in the conceptual row). Then the index of the first FTN entry applied on this interface is n. - To determine the FTN entry applied to an interface after the one indexed by n perform a GETNEXT retrieval operation on mplsFTNMapRowStatus.ifIndex.n.0. If such an entry exists the returned object would be of the form mplsFTNMapRowStatus.ifIndex.n.m. Then the index of the next FTN entry applied on this interface is m. - If the FTN entry indexed by n is the last entry applied to the interface with index ifIndex then the object returned would either be: 1.mplsFTNMapRowStatus.ifIndexNext.0.k, where ifIndexNext is the index of the next interface in ifTable to which an FTN entry has been applied, in which case k is the index of the first FTN entry applied to the interface with index ifIndexNext; or: 2.mplsFTNMapStorageType.firstIfIndex.0.p, if there are no more entries in mplsFTNMapTable, where firstIfIndex is the first entry in ifTable to which an FTN entry has been mapped. Use the above steps to retrieve all the applied FTN entries on a per-interface basis in application order. Note that the number of retrieval operations is the same as the number of applied FTN entries (i.e., the minimum number of GETNEXT operations needed using any indexing scheme). Agents MUST NOT allow the same FTN entry as specified by mplsFTNMapCurrIndex to be applied multiple times to the same interface. Agents MUST NOT allow the creation of rows in this table until the corresponding rows are created in the mplsFTNTable. If a row in mplsFTNTable is destroyed, the agent MUST destroy the corresponding entries (i.e., ones with a matching value of mplsFTNCurrIndex) in this table as well.")
mplsFTNMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5, 1), ).setIndexNames((0, "MPLS-FTN-STD-MIB", "mplsFTNMapIndex"), (0, "MPLS-FTN-STD-MIB", "mplsFTNMapPrevIndex"), (0, "MPLS-FTN-STD-MIB", "mplsFTNMapCurrIndex"))
if mibBuilder.loadTexts: mplsFTNMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapEntry.setDescription('Each conceptual row represents the application of an FTN rule at a specific position in the list of FTN rules applied on an interface. ')
mplsFTNMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsFTNMapIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapIndex.setDescription('The interface index that this FTN entry is being applied to. A value of zero indicates an entry that is applied all interfaces. Entries mapped to an interface by specifying its (non- zero) interface index in mplsFTNMapIndex are applied ahead of entries with mplsFTNMapIndex equal to zero.')
mplsFTNMapPrevIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5, 1, 2), MplsFTNEntryIndexOrZero())
if mibBuilder.loadTexts: mplsFTNMapPrevIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapPrevIndex.setDescription('The index of the previous FTN entry that was applied to this interface. The special value zero indicates that this should be the first FTN entry in the list.')
mplsFTNMapCurrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5, 1, 3), MplsFTNEntryIndex())
if mibBuilder.loadTexts: mplsFTNMapCurrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapCurrIndex.setDescription('Index of the current FTN entry that is being applied to this interface.')
mplsFTNMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5, 1, 4), RowStatus().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapRowStatus.setDescription('Used for controlling the creation and deletion of this row. All writable objects in this row may be modified at any time. If a conceptual row in mplsFTNMapTable points to a conceptual row in mplsFTNTable which is subsequently deleted, the corresponding conceptual row in mplsFTNMapTable MUST also be deleted by the agent.')
mplsFTNMapStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 5, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNMapStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapStorageType.setDescription("The storage type for this entry. Conceptual rows having the value 'permanent' need not allow write- access to any columnar objects in this row.")
mplsFTNPerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6), )
if mibBuilder.loadTexts: mplsFTNPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfTable.setDescription('This table contains performance statistics on FTN entries on a per-interface basis.')
mplsFTNPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6, 1), ).setIndexNames((0, "MPLS-FTN-STD-MIB", "mplsFTNPerfIndex"), (0, "MPLS-FTN-STD-MIB", "mplsFTNPerfCurrIndex"))
if mibBuilder.loadTexts: mplsFTNPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfEntry.setDescription('Each entry contains performance information for the specified interface and an FTN entry mapped to this interface.')
mplsFTNPerfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsFTNPerfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfIndex.setDescription('The interface index of an interface that an FTN entry has been applied/mapped to. Each instance of this object corresponds to an instance of mplsFTNMapIndex.')
mplsFTNPerfCurrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6, 1, 2), MplsFTNEntryIndex())
if mibBuilder.loadTexts: mplsFTNPerfCurrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfCurrIndex.setDescription('Index of an FTN entry that has been applied/mapped to the specified interface. Each instance of this object corresponds to an instance of mplsFTNMapCurrIndex.')
mplsFTNPerfMatchedPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNPerfMatchedPackets.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfMatchedPackets.setDescription('Number of packets that matched the specified FTN entry if it is applied/mapped to the specified interface. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of mplsFTNDiscontinuityTime.')
mplsFTNPerfMatchedOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNPerfMatchedOctets.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfMatchedOctets.setDescription('Number of octets that matched the specified FTN entry if it is applied/mapped to the specified interface. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of mplsFTNDiscontinuityTime.')
mplsFTNPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 8, 1, 6, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this entry's counters suffered a discontinuity. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
mplsFTNGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 1))
mplsFTNCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 2))
mplsFTNModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 2, 1)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("MPLS-FTN-STD-MIB", "mplsFTNRuleGroup"), ("MPLS-FTN-STD-MIB", "mplsFTNMapGroup"), ("MPLS-FTN-STD-MIB", "mplsFTNPerfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNModuleFullCompliance = mplsFTNModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsFTNModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for MPLS-FTN-STD-MIB.')
mplsFTNModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 2, 2)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("MPLS-FTN-STD-MIB", "mplsFTNRuleGroup"), ("MPLS-FTN-STD-MIB", "mplsFTNMapGroup"), ("MPLS-FTN-STD-MIB", "mplsFTNPerfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNModuleReadOnlyCompliance = mplsFTNModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsFTNModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only provide read-only support for MPLS-FTN-STD-MIB. Such devices can then be monitored but cannot be configured using this MIB module.')
mplsFTNRuleGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 1, 1)).setObjects(("MPLS-FTN-STD-MIB", "mplsFTNIndexNext"), ("MPLS-FTN-STD-MIB", "mplsFTNTableLastChanged"), ("MPLS-FTN-STD-MIB", "mplsFTNRowStatus"), ("MPLS-FTN-STD-MIB", "mplsFTNDescr"), ("MPLS-FTN-STD-MIB", "mplsFTNMask"), ("MPLS-FTN-STD-MIB", "mplsFTNAddrType"), ("MPLS-FTN-STD-MIB", "mplsFTNSourceAddrMin"), ("MPLS-FTN-STD-MIB", "mplsFTNSourceAddrMax"), ("MPLS-FTN-STD-MIB", "mplsFTNDestAddrMin"), ("MPLS-FTN-STD-MIB", "mplsFTNDestAddrMax"), ("MPLS-FTN-STD-MIB", "mplsFTNSourcePortMin"), ("MPLS-FTN-STD-MIB", "mplsFTNSourcePortMax"), ("MPLS-FTN-STD-MIB", "mplsFTNDestPortMin"), ("MPLS-FTN-STD-MIB", "mplsFTNDestPortMax"), ("MPLS-FTN-STD-MIB", "mplsFTNProtocol"), ("MPLS-FTN-STD-MIB", "mplsFTNActionType"), ("MPLS-FTN-STD-MIB", "mplsFTNActionPointer"), ("MPLS-FTN-STD-MIB", "mplsFTNDscp"), ("MPLS-FTN-STD-MIB", "mplsFTNStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNRuleGroup = mplsFTNRuleGroup.setStatus('current')
if mibBuilder.loadTexts: mplsFTNRuleGroup.setDescription('Collection of objects that implement MPLS FTN rules.')
mplsFTNMapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 1, 2)).setObjects(("MPLS-FTN-STD-MIB", "mplsFTNMapTableLastChanged"), ("MPLS-FTN-STD-MIB", "mplsFTNMapRowStatus"), ("MPLS-FTN-STD-MIB", "mplsFTNMapStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNMapGroup = mplsFTNMapGroup.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapGroup.setDescription('Collection of objects that implement activation of MPLS FTN entries on interfaces.')
mplsFTNPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 8, 2, 1, 3)).setObjects(("MPLS-FTN-STD-MIB", "mplsFTNPerfMatchedPackets"), ("MPLS-FTN-STD-MIB", "mplsFTNPerfMatchedOctets"), ("MPLS-FTN-STD-MIB", "mplsFTNPerfDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNPerfGroup = mplsFTNPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfGroup.setDescription('Collection of objects providing MPLS FTN performance information.')
mibBuilder.exportSymbols("MPLS-FTN-STD-MIB", mplsFTNSourcePortMin=mplsFTNSourcePortMin, mplsFTNDestAddrMax=mplsFTNDestAddrMax, mplsFTNDescr=mplsFTNDescr, PYSNMP_MODULE_ID=mplsFTNStdMIB, mplsFTNPerfGroup=mplsFTNPerfGroup, mplsFTNDestPortMin=mplsFTNDestPortMin, mplsFTNSourcePortMax=mplsFTNSourcePortMax, mplsFTNTableLastChanged=mplsFTNTableLastChanged, MplsFTNEntryIndex=MplsFTNEntryIndex, mplsFTNSourceAddrMax=mplsFTNSourceAddrMax, mplsFTNDestPortMax=mplsFTNDestPortMax, mplsFTNActionType=mplsFTNActionType, mplsFTNModuleReadOnlyCompliance=mplsFTNModuleReadOnlyCompliance, mplsFTNRuleGroup=mplsFTNRuleGroup, mplsFTNSourceAddrMin=mplsFTNSourceAddrMin, mplsFTNPerfMatchedOctets=mplsFTNPerfMatchedOctets, mplsFTNProtocol=mplsFTNProtocol, mplsFTNMapTableLastChanged=mplsFTNMapTableLastChanged, mplsFTNNotifications=mplsFTNNotifications, mplsFTNConformance=mplsFTNConformance, mplsFTNStorageType=mplsFTNStorageType, mplsFTNMapPrevIndex=mplsFTNMapPrevIndex, mplsFTNRowStatus=mplsFTNRowStatus, mplsFTNStdMIB=mplsFTNStdMIB, mplsFTNModuleFullCompliance=mplsFTNModuleFullCompliance, mplsFTNMapIndex=mplsFTNMapIndex, mplsFTNMapGroup=mplsFTNMapGroup, mplsFTNObjects=mplsFTNObjects, mplsFTNMapEntry=mplsFTNMapEntry, mplsFTNMapTable=mplsFTNMapTable, mplsFTNMask=mplsFTNMask, mplsFTNPerfCurrIndex=mplsFTNPerfCurrIndex, mplsFTNPerfEntry=mplsFTNPerfEntry, mplsFTNMapStorageType=mplsFTNMapStorageType, mplsFTNAddrType=mplsFTNAddrType, mplsFTNPerfDiscontinuityTime=mplsFTNPerfDiscontinuityTime, mplsFTNIndexNext=mplsFTNIndexNext, mplsFTNDscp=mplsFTNDscp, mplsFTNTable=mplsFTNTable, mplsFTNPerfTable=mplsFTNPerfTable, MplsFTNEntryIndexOrZero=MplsFTNEntryIndexOrZero, mplsFTNMapCurrIndex=mplsFTNMapCurrIndex, mplsFTNMapRowStatus=mplsFTNMapRowStatus, mplsFTNEntry=mplsFTNEntry, mplsFTNIndex=mplsFTNIndex, mplsFTNActionPointer=mplsFTNActionPointer, mplsFTNPerfMatchedPackets=mplsFTNPerfMatchedPackets, mplsFTNDestAddrMin=mplsFTNDestAddrMin, mplsFTNPerfIndex=mplsFTNPerfIndex, mplsFTNCompliances=mplsFTNCompliances, mplsFTNGroups=mplsFTNGroups)

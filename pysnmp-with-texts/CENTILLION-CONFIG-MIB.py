#
# PySNMP MIB module CENTILLION-CONFIG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CENTILLION-CONFIG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:47:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
MacAddress, StatusIndicator, EnableIndicator, sysConfig, BitField = mibBuilder.importSymbols("CENTILLION-ROOT-MIB", "MacAddress", "StatusIndicator", "EnableIndicator", "sysConfig", "BitField")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, MibIdentifier, Integer32, TimeTicks, Gauge32, NotificationType, Unsigned32, Bits, ModuleIdentity, Counter64, ObjectIdentity, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "MibIdentifier", "Integer32", "TimeTicks", "Gauge32", "NotificationType", "Unsigned32", "Bits", "ModuleIdentity", "Counter64", "ObjectIdentity", "iso", "Counter32")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
class VlanId(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 4095)

sysTableConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 1))
sysImgInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2))
sysMcpRedundInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3))
sysNetProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14))
sysTFTPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 18))
sysSNMPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19))
netbiosGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21))
lnmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 25))
sysIpProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1))
sysImgGbl = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 1))
sysImgGblInvokeSrc = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("image1", 2), ("image2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysImgGblInvokeSrc.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgGblInvokeSrc.setDescription('The source of system image to be invoked at next boot. Default setting is image1. If the desired image cannot be invoked, another image (if found and valid) will be invoked automatically at next boot. Note that if the system does not support dual boot image, then image1 should be used.')
sysImgGblLoadDst = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("location1", 2), ("location2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysImgGblLoadDst.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgGblLoadDst.setDescription('The non volatile memory destination where the system image will be (programmed by boot loader) down loaded to at next boot. Default setting is location1. Note that if the system does not support dual boot image, then location1 should be used.')
sysImgTable = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 2), )
if mibBuilder.loadTexts: sysImgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgTable.setDescription('A table that provides additional information about the system images. The number of entries in the table is determined by the number of index of the system image.')
sysImgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 2, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "sysImgIndx"))
if mibBuilder.loadTexts: sysImgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgEntry.setDescription('A row in the table of additional information about the system images. Entries can not be created or deleted via SNMP requests.')
sysImgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysImgIndx.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgIndx.setDescription('The index of the system image.')
sysImgVer = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysImgVer.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgVer.setDescription('The version of the system image stored in non volatile memory. Note that if the system does not support dual boot image, then zero length string should be returned for image2.')
sysImgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("good", 2), ("bad", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysImgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysImgStatus.setDescription('The status of system image stored in non volatile memory.')
sysMcpRedundGbl = MibIdentifier((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 1))
sysMcpRedundNxtGblState = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMcpRedundNxtGblState.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundNxtGblState.setDescription('State of the Redundant MCP during next boot. Request to enable or disable redundant MCP. This will update the configuration information for the redundant MCP pair. It takes effect during next reset.')
sysMcpRedundTable = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2), )
if mibBuilder.loadTexts: sysMcpRedundTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundTable.setDescription('A table that provides additional information about the system MCP redundancy. The number of entries in the table is determined by the number of index of the system MCP redundancy.')
sysMcpRedundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "sysMcpRedundIndx"))
if mibBuilder.loadTexts: sysMcpRedundEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundEntry.setDescription('A row in the table of additional information about the system MCP redundancy. Entries can not be created or deleted via SNMP requests.')
sysMcpRedundIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMcpRedundIndx.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundIndx.setDescription('The index of the system MCP redundancy. Currently represents the slot number that this MCP is in.')
sysMcpRedundPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMcpRedundPriority.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundPriority.setDescription('The MCP redundancy priority which is used for primary MCP selection. Default setting is zero.')
sysMcpRedundType = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("regular", 2), ("primary", 3), ("secondary", 4), ("switching", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMcpRedundType.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundType.setDescription('Functional type of MCP in the chassis. Currently only ATM MCPs can be used for the redundant function. Only MCPs in slots 1 and 2 can participate in redundancy. But other ATM MCPs can still be plugged into the chasis. This field represents the way that an MCP is participating in the redundancy.')
sysMcpRedundOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMcpRedundOperState.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundOperState.setDescription('Current state of this MCP')
sysMcpRedundCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("user-enable", 2), ("user-disable", 3), ("default-enable", 4), ("default-disable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMcpRedundCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysMcpRedundCfgStatus.setDescription('State of the Redundant MCP. Other(1) is used when the MCP is not participating in redundancy, default enable/disable used to represent the factory default case. User enable/disable used when a user changes from the factory default state.')
rifTable = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5), )
if mibBuilder.loadTexts: rifTable.setStatus('mandatory')
if mibBuilder.loadTexts: rifTable.setDescription('This table contains Routing Information Field (RIF) parameters. Entries may be used by one or more stations on the switch.')
rifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "rifPath"))
if mibBuilder.loadTexts: rifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rifEntry.setDescription('A single entry in the RIF table.')
rifPath = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 28))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rifPath.setStatus('mandatory')
if mibBuilder.loadTexts: rifPath.setDescription('RIF field, read from left to right, i.e. read from the switch.')
rifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rifIndex.setDescription('Index into the RIF table. This index is used to enter a RIF in the station table.')
rifInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 3), BitField()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rifInUse.setStatus('mandatory')
if mibBuilder.loadTexts: rifInUse.setDescription('Indicates that this RIF entry is valid if set. A unique RIF entry may be deleted only if it is not in use by a station.')
rifCount = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rifCount.setStatus('mandatory')
if mibBuilder.loadTexts: rifCount.setDescription('The number stations that this RIF is associated with.')
rifLength = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rifLength.setStatus('mandatory')
if mibBuilder.loadTexts: rifLength.setDescription('Byte length of the RIF entry.')
rifNext = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rifNext.setStatus('mandatory')
if mibBuilder.loadTexts: rifNext.setDescription('Next RIF field.')
rifPrevious = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rifPrevious.setStatus('mandatory')
if mibBuilder.loadTexts: rifPrevious.setDescription('Previous RIF field.')
systemMaxPacketInfoSize = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(516, 17800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemMaxPacketInfoSize.setStatus('mandatory')
if mibBuilder.loadTexts: systemMaxPacketInfoSize.setDescription('The system maximum packet information field size. Changing the maximum information size does not take effect until the next system reset.')
systemConfigMode = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("transparentSwitchingNoSTP", 2), ("source-route-bridging", 3), ("transparent-bridging", 4), ("noVirtualRingBridging", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: systemConfigMode.setDescription('This variable describes the current mode of bridging configuration in the switch. The bridging mode applies to all ports. The value other(1) is a read-only indication that the system is in a user customized the system configuration. Setting this object will save the configuration into flash and issue a system reset command.')
systemConfigIpOption = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("eraseIP", 2), ("preservedIP", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemConfigIpOption.setStatus('mandatory')
if mibBuilder.loadTexts: systemConfigIpOption.setDescription('Reading this object always returns other(1). Setting of this object, which is optional, must be accomplished in the same SNMP request that set systemConfigMode.')
maxPerfMode = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 8), EnableIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxPerfMode.setStatus('mandatory')
if mibBuilder.loadTexts: maxPerfMode.setDescription('The current value of the system maximum performance mode. Setting this value to enabled causes the system to perform in maximum performance mode. Default is disabled. This variable does not take effect until the next system reset.')
configSave = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 10), BitField()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSave.setStatus('mandatory')
if mibBuilder.loadTexts: configSave.setDescription('Save the current configuration into flash memory. When read, this value is always clear (1). The value may only be set to the set (2) state.')
localAdminMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 12), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localAdminMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: localAdminMacAddress.setDescription("The system's locally administered MAC address. The current operation MAC address may be obtained by the ifPhysAddress entry in the ifTable. This parameter will take effect only after a reset is issued.")
configLogin = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 13), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configLogin.setStatus('mandatory')
if mibBuilder.loadTexts: configLogin.setDescription('The system login object. This object is used to login a network management station to the system for configuration. The format of the login request follows: login indicator.login password, where the login indicator is a single byte of the value 1 = logoff, 2 = login, or 3 = set password and the password is the system password. The password must be supplied for upon login or altering the password. A manager must first login to the system before altering the password. When read, the first octet is returned, indicating whether a managment station is currently logged in to the system.')
configProtocol = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("flash", 1), ("tftpNoSave", 2), ("tftpSave", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: configProtocol.setDescription('The protocol used to retrieve system configuration. Flash indicates that the configuration is read from the flash. tftpNoSave indicates that the TFTP protocol should be used to retrieve the current configuration. The new configuration is not saved into flash, it is up to the user to save the configuration is desired. The new configuration will not take effect until the next system reset. tftpSave indicates that the newly uploaded configuration will be saved into flash, thus may be use to permanently update a configuration. The system is automatically reset.')
configFilename = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configFilename.setStatus('mandatory')
if mibBuilder.loadTexts: configFilename.setDescription('The name of the configuration file that is sent to the server. The actual boot protocol used to retrieve the file is determined by configProtocol. This parameter may be configured via the network boot protocol.')
configSource = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flashConfig", 1), ("remoteConfig", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configSource.setStatus('mandatory')
if mibBuilder.loadTexts: configSource.setDescription('An indication of how the system was actually configured. flashConfig indicates that the current configuration was obtained via flash. remoteConfig indicates that the configuration was obtained via the protocol determined by configProtocol.')
sonmpTrConfig = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sonmpTrConfig.setStatus('mandatory')
if mibBuilder.loadTexts: sonmpTrConfig.setDescription('The configuration status of the Token Ring auto-topology. If the value of this object is set to enable(1), the Token Ring auto-topology frames will be sent out on every Token Ring port on every 10 seconds interval. The auto- topology frames are received from the Token Ring port and logged in the database. If the value of this object is set to disable(2), no Token ring topology frames are sent and received.')
sonmpTrSpeed = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("topFast", 2), ("topSlow", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sonmpTrSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: sonmpTrSpeed.setDescription('The Token Ring topology message (SONMP frame) transmit speed. The values that are read/write are: topFast(2)...short interval between transmitting topSlow(3)...long interval between transmitting The value that is readonly is: other(1)...speed unknown, or other value In fast mode, the SONMP frame transmit interval is 10 seconds for all SONMP frames. In slow mode, the interval is 60 seconds for master NMM announcement SONMP frames, and 70 seconds for adjacent SONMP frames.')
srUnknownFrameFlood = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 32), EnableIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srUnknownFrameFlood.setStatus('mandatory')
if mibBuilder.loadTexts: srUnknownFrameFlood.setDescription('Unknown Source Route Frame Flood. Enable/Disable flooding of Source Route Frames to the next hop while the route to the remote ring is being learned and circuit is established.')
srbIeeeBpduEnable = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 33), EnableIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srbIeeeBpduEnable.setStatus('mandatory')
if mibBuilder.loadTexts: srbIeeeBpduEnable.setDescription("Send Srb/Ieee BPDU as explorer. Enable/Disable the sending of Srb/IEEE BPDU's as explorers, allowing some routers to receive the BPDU with a rif.")
tbRifProxyEnable = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 34), EnableIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tbRifProxyEnable.setStatus('mandatory')
if mibBuilder.loadTexts: tbRifProxyEnable.setDescription('Process route descriptor LE_ARP requests in token ring transparent bridging LANE. Enable/Disable the processing of LE_ARP requests for route descriptors when received from a source route ATM attached device.')
cpuClkRate = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mhz66", 1), ("mhz85", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuClkRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpuClkRate.setDescription('MCP Clock Rate. Indicates the speed at which the MCP processor functions.')
maxRids = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxRids.setStatus('mandatory')
if mibBuilder.loadTexts: maxRids.setDescription('Maximum number of Reassembly Ids. Indicates the maximum number of RIDs the switch supports. Determined by the XRam installed on the ATM cards in the switch.')
sysAddr = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAddr.setStatus('deprecated')
if mibBuilder.loadTexts: sysAddr.setDescription("The system's IP address. The current operational IP address may be obtained by the ipAdEntAddr entry in the ipAddrTable. This parameter will take effect only after a reset is issued.")
sysNetMask = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysNetMask.setStatus('deprecated')
if mibBuilder.loadTexts: sysNetMask.setDescription("The system's IP subnet mask. The current operational IP subnet mask may be obtained by the ipAdEntNetMask entry in the ipAddrTable. This parameter will take effect only after a reset is issued. The parameter is not saved unless written to flash.")
sysBcastAddr = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBcastAddr.setStatus('deprecated')
if mibBuilder.loadTexts: sysBcastAddr.setDescription("The system's IP broadcast address. The current operational IP broadcast address may be obtained by the ipAdEntBcastAddr in the ipAddrTable. This parameter will take effect only after a reset is issued. This parameter is not saved unless written to flash.")
defaultGatewayAddr = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultGatewayAddr.setStatus('deprecated')
if mibBuilder.loadTexts: defaultGatewayAddr.setDescription("The system's default getway IP address. the current operational default gateway's IP address can be obtained from the ipRoutingTable. This parameter will take effect only after a reset is issued. This parameter is not saved unless written to flash.")
configServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: configServerAddr.setDescription('The IP address to which the requests for configuration files are sent. The protocol used to retrieve the configuration is determined by the configProtocol object. This parameter may be set dynamically as established by the ipConfigProtocol object.')
ipConfigProtocol = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flash", 1), ("bootp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipConfigProtocol.setStatus('deprecated')
if mibBuilder.loadTexts: ipConfigProtocol.setDescription('The protocol used to obtain this IP addressing information.')
ipHostNumber = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipHostNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostNumber.setDescription('The number of IP entities (regardless of their current state) present on this system.')
ipHostTable = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8), )
if mibBuilder.loadTexts: ipHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostTable.setDescription('This table contains all the ip entities this agent manages. The number of entries is given by the value of ipHostNumber.')
ipHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "ipHostIndex"))
if mibBuilder.loadTexts: ipHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostEntry.setDescription('An IP entity entry containing objects regarding this IP entity.')
ipHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostIndex.setDescription('An index to the ipHostTable. Its value ranges between 1 and the value of ipHostNumber.')
ipHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostAddress.setDescription('The IP address of this entity.')
ipHostNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostNetMask.setDescription('The subnet mask associated with the Ip address of this entry.')
ipHostBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostBcastAddr.setDescription('The Broadcast address associated with the IP address of this entry.')
ipHostDefaultGatewayAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostDefaultGatewayAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostDefaultGatewayAddr.setDescription('The gateway address associated with the IP address of this entry.')
ipHostConfigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flash", 1), ("bootp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostConfigProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostConfigProtocol.setDescription("The protocol used to obtain this IP host's addressing information.")
ipHostEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipHostEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostEnable.setDescription('Enable or disable of this ip host entry.')
ipHostType = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 14, 1, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipHostType.setStatus('mandatory')
if mibBuilder.loadTexts: ipHostType.setDescription('A read only object indicating the type of this IP entity. ')
sysTFTPStart = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tftpNoTransfer", 1), ("tftpGet", 2), ("tftpPut", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTFTPStart.setStatus('mandatory')
if mibBuilder.loadTexts: sysTFTPStart.setDescription('Setting sysTFTPStart to tftpGet(2) initiates a file transfer to the agent (download); tftpPut(3) initiates a file transfer to the server (upload).')
sysTFTPIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 18, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTFTPIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysTFTPIpAddress.setDescription('The IP Address of the TFTP server.')
sysTFTPFileName = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 18, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTFTPFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sysTFTPFileName.setDescription('The file name of the file to retrieve (tftpGet), or the name of the file to create (tftpPut). ')
sysTFTPFileType = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 18, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("configuration", 1), ("imageCode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTFTPFileType.setStatus('mandatory')
if mibBuilder.loadTexts: sysTFTPFileType.setDescription('The type of file image to upload/download. The file type indicates to the agent what kind of file it is receiving. configuration(1) indicates an update of the system configuration. imageCode(2) indicates a code upgrade of the operational proms. bootCode(3) indicates a code upgrade of the boot proms.')
sysTFTPResult = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 18, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("clear", 1), ("xferInProgress", 2), ("okay", 3), ("otherTFTPError", 4), ("fileNotFound", 5), ("accessError", 6), ("diskFull", 7), ("illegalTFTPOperation", 8), ("invalidTFTPTransactionID", 9), ("fileExists", 10), ("noSuchUser", 11), ("noResources", 12), ("noResponse", 13), ("flashError", 14), ("configMismatch", 15), ("configChecksumError", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTFTPResult.setStatus('mandatory')
if mibBuilder.loadTexts: sysTFTPResult.setDescription('The result of the last TFTP operation.')
sysSNMPGetCommunity = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSNMPGetCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: sysSNMPGetCommunity.setDescription('The system get community string.')
sysSNMPSetCommunity = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSNMPSetCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: sysSNMPSetCommunity.setDescription('The system set community string.')
sysSNMPEnableTraps = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 3), EnableIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSNMPEnableTraps.setStatus('mandatory')
if mibBuilder.loadTexts: sysSNMPEnableTraps.setDescription('Indicates whether the SNMP agent process is permitted to generate traps. This object provides global trap enable status, as specific traps may be enabled or disabled on an individual basis.')
sysSNMPTrapIPReceiverTable = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 4), )
if mibBuilder.loadTexts: sysSNMPTrapIPReceiverTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysSNMPTrapIPReceiverTable.setDescription('A table containing of network management stations that are to receive traps generated by the system.')
sysSNMPTrapIPReceiverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 4, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "trapIPRcvrAddress"))
if mibBuilder.loadTexts: sysSNMPTrapIPReceiverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysSNMPTrapIPReceiverEntry.setDescription('A destination address and community string to a particular IP trap server. Entries are created by supplying a valid IP address of the trap server.')
trapIPRcvrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 4, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapIPRcvrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: trapIPRcvrAddress.setDescription('The IP network address of the network management entity which will receive traps.')
trapIPRcvrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 4, 1, 2), StatusIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapIPRcvrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapIPRcvrStatus.setDescription('Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the sysSNMPReceiverTrapTable. On a read, the value of valid(2) is returned. Entries are added into the table by specifying a previously unknown trapRcvrNetAddress, along with the corresponding trapRcvrCommunity.')
trapIPRcvrCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 19, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapIPRcvrCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: trapIPRcvrCommunity.setDescription('The community string to use for traps sent to this trap receiver.')
sysMgmtRingNumber = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMgmtRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sysMgmtRingNumber.setDescription("A unique ring number assigned to the system's managment entity. This ring will not appear as a source-route hop as it is seen only in frames destined to or sourced from the system management entity.")
netbiosNameTableAgingTimer = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netbiosNameTableAgingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: netbiosNameTableAgingTimer.setDescription('The non-zero timeout period in seconds for aging out dynamically learned Netbios names. The default value is 300 seconds.')
netbiosNameQueryInterval = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netbiosNameQueryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: netbiosNameQueryInterval.setDescription('The time period in hundreds of milliseconds in which NetBIOS name queries are allowed to be bridged. A value of 0 disables briding NetBIOS name queries. The default value is 5 (a half second).')
netbiosNameTableFlush = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 3), BitField()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netbiosNameTableFlush.setStatus('mandatory')
if mibBuilder.loadTexts: netbiosNameTableFlush.setDescription('If set, indicates that the NetBIOS name table should be flushed. Flushing the table removes all of the dynamically learned entries from the NetBIOS name table. When read, this object always returns a value of clear.')
netbiosNameTableEntry = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4), )
if mibBuilder.loadTexts: netbiosNameTableEntry.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameTableEntry.setDescription('A NetBIOS name table. This table is a list of the NetBIOS names learned or configured on the switch.')
netbiosNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "netbiosNameName"))
if mibBuilder.loadTexts: netbiosNameEntry.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameEntry.setDescription('A NetBIOS name table entry. Entries may be deleted by setting the status object to invalid (2). Entries are added by specifying the name, station and ring or card/port as appropriate.')
netbiosNameName = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameName.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameName.setDescription('The NetBIOS name.')
netbiosNameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 2), StatusIndicator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameStatus.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameStatus.setDescription('The status of the NetBIOS name entry. Setting this object to invalid (2) causes the entry to be deleted from the name table. The value should always be read as valid(1).')
netbiosNameStationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 3), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameStationAddress.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameStationAddress.setDescription('The address of the station from which this name was learned or configured. This object must be specified when adding an entry into the table.')
netbiosNameVirtualRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameVirtualRingNumber.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameVirtualRingNumber.setDescription('The virtual ring number from which the entry was learned or configured. If the switch is operating is a mode where virtual rings are invalid, then this number will be 0. This object must be specified when adding an entry in the table if appropriate.')
netbiosNameCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameCardNumber.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameCardNumber.setDescription('The card number from which the entry was learned or configured. If the switch is operating is a mode where virtual rings are valid, then this number will be 0. This object must be specified when adding an entry in the table if appropriate.')
netbiosNamePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNamePortNumber.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNamePortNumber.setDescription('The port number from which the entry was learned or configured. If the switch is operating is a mode where virtual rings are valid, then this number will be 0. This object must be specified when adding an entry in the table if appropriate.')
netbiosNamePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("token-ring", 2), ("fddi", 3), ("ethernet", 4), ("atm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNamePortType.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNamePortType.setDescription('The type of port from which the entry was learned or configured.')
netbiosNameAge = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameAge.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameAge.setDescription('The amount of time (in hundredths of a second) before this entry is aged, or the elapsed time since the entry was learned or configured.')
netbiosNameProxies = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameProxies.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameProxies.setDescription('The number of times that the switch has proxied for this station.')
netbiosNameSuppressedQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netbiosNameSuppressedQueries.setStatus('deprecated')
if mibBuilder.loadTexts: netbiosNameSuppressedQueries.setDescription('The number of NetBIOS name queries from this station which were suppressed by the switch due to the configured name query interval (netbiosNameQueryInterval)')
cnnetbiosNameTableEntry = MibTable((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5), )
if mibBuilder.loadTexts: cnnetbiosNameTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameTableEntry.setDescription('A NetBIOS name table with VLAN information. This table is a list of the NetBIOS names learned or configured on the switch.')
cnnetbiosNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1), ).setIndexNames((0, "CENTILLION-CONFIG-MIB", "cnnetbiosNameVlanId"), (0, "CENTILLION-CONFIG-MIB", "cnnetbiosNameName"))
if mibBuilder.loadTexts: cnnetbiosNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameEntry.setDescription('A NetBIOS name table entry. Entries may be deleted by setting the status object to invalid (2). Entries are added by specifying the name, station, ring or card/port, vlan id as appropriate.')
cnnetbiosNameName = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameName.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameName.setDescription('The NetBIOS name.')
cnnetbiosNameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 2), StatusIndicator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameStatus.setDescription('The status of the NetBIOS name entry. Setting this object to invalid (2) causes the entry to be deleted from the name table. The value should always be read as valid(1).')
cnnetbiosNameStationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 3), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameStationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameStationAddress.setDescription('The address of the station from which this name was learned or configured. This object must be specified when adding an entry into the table.')
cnnetbiosNameVirtualRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameVirtualRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameVirtualRingNumber.setDescription('The virtual ring number from which the entry was learned or configured. If the switch is operating is a mode where virtual rings are invalid, then this number will be 0. This object must be specified when adding an entry in the table if appropriate.')
cnnetbiosNameCardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameCardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameCardNumber.setDescription('The card number from which the entry was learned or configured. If the switch is operating is a mode where virtual rings are valid, then this number will be 0. This object must be specified when adding an entry in the table if appropriate.')
cnnetbiosNamePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNamePortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNamePortNumber.setDescription('The port number from which the entry was learned or configured. If the switch is operating is a mode where virtual rings are valid, then this number will be 0. This object must be specified when adding an entry in the table if appropriate.')
cnnetbiosNameVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 7), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameVlanId.setDescription('The 802.1q vid for the VLan from which the entry was learned or configured. This object must be specified when adding an entry in the table if appropriate.')
cnnetbiosNamePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("token-ring", 2), ("fddi", 3), ("ethernet", 4), ("atm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNamePortType.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNamePortType.setDescription('The type of port from which the entry was learned or configured.')
cnnetbiosNameAge = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameAge.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameAge.setDescription('The amount of time (in hundredths of a second) before this entry is aged, or the elapsed time since the entry was learned or configured.')
cnnetbiosNameProxies = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameProxies.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameProxies.setDescription('The number of times that the switch has proxied for this station.')
cnnetbiosNameSuppressedQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 21, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnnetbiosNameSuppressedQueries.setStatus('mandatory')
if mibBuilder.loadTexts: cnnetbiosNameSuppressedQueries.setDescription('The number of NetBIOS name queries from this station which were suppressed by the switch due to the configured name query interval (netbiosNameQueryInterval)')
lnmOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 25, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnmOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lnmOperStatus.setDescription(" This object reflects the actual state of LNM which may differ from that of the lnmAdminStatus object. This can occur when the LNM task has failed but the the corresponding lnmAdminStatus is 'up'.")
lnmAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 25, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lnmAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lnmAdminStatus.setDescription('The desired state of the LNM on the switch as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the lnmOperStatus.')
lnmBridgeGroupDisplayMode = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 25, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aggregate", 1), ("separate", 2))).clone('aggregate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lnmBridgeGroupDisplayMode.setStatus('mandatory')
if mibBuilder.loadTexts: lnmBridgeGroupDisplayMode.setDescription('Indicates how LNM should display spanning tree groups. If set to aggregate, LNM displays all spanning tree groups as one internal management ring. If set to separate, LNM displays each spanning tree group as a separate internal management ring.')
lnmLinkPassword = MibScalar((1, 3, 6, 1, 4, 1, 930, 2, 1, 2, 25, 4), EnableIndicator()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lnmLinkPassword.setStatus('mandatory')
if mibBuilder.loadTexts: lnmLinkPassword.setDescription('Indicates the use of the default LNM management password or the first 6 to 8 characters of the system password.')
mibBuilder.exportSymbols("CENTILLION-CONFIG-MIB", ipHostBcastAddr=ipHostBcastAddr, sysAddr=sysAddr, lnmGroup=lnmGroup, sysImgGbl=sysImgGbl, sysImgEntry=sysImgEntry, cpuClkRate=cpuClkRate, cnnetbiosNameAge=cnnetbiosNameAge, sysImgGblLoadDst=sysImgGblLoadDst, cnnetbiosNameProxies=cnnetbiosNameProxies, ipHostNetMask=ipHostNetMask, trapIPRcvrAddress=trapIPRcvrAddress, netbiosNameProxies=netbiosNameProxies, ipHostNumber=ipHostNumber, netbiosNameTableAgingTimer=netbiosNameTableAgingTimer, cnnetbiosNamePortNumber=cnnetbiosNamePortNumber, netbiosNameQueryInterval=netbiosNameQueryInterval, maxRids=maxRids, rifIndex=rifIndex, lnmOperStatus=lnmOperStatus, rifNext=rifNext, sysMgmtRingNumber=sysMgmtRingNumber, cnnetbiosNameStationAddress=cnnetbiosNameStationAddress, netbiosNameName=netbiosNameName, configSave=configSave, sysMcpRedundTable=sysMcpRedundTable, netbiosNameTableEntry=netbiosNameTableEntry, srUnknownFrameFlood=srUnknownFrameFlood, sysMcpRedundOperState=sysMcpRedundOperState, configFilename=configFilename, VlanId=VlanId, netbiosNameVirtualRingNumber=netbiosNameVirtualRingNumber, sysSNMPGroup=sysSNMPGroup, ipHostDefaultGatewayAddr=ipHostDefaultGatewayAddr, trapIPRcvrCommunity=trapIPRcvrCommunity, netbiosNameEntry=netbiosNameEntry, sysTFTPIpAddress=sysTFTPIpAddress, sysMcpRedundCfgStatus=sysMcpRedundCfgStatus, sysMcpRedundIndx=sysMcpRedundIndx, netbiosNamePortType=netbiosNamePortType, srbIeeeBpduEnable=srbIeeeBpduEnable, netbiosNameStatus=netbiosNameStatus, sysMcpRedundEntry=sysMcpRedundEntry, sysImgInfo=sysImgInfo, netbiosNameSuppressedQueries=netbiosNameSuppressedQueries, netbiosNameCardNumber=netbiosNameCardNumber, netbiosGroup=netbiosGroup, cnnetbiosNameCardNumber=cnnetbiosNameCardNumber, ipHostEntry=ipHostEntry, sysTFTPResult=sysTFTPResult, cnnetbiosNameName=cnnetbiosNameName, lnmBridgeGroupDisplayMode=lnmBridgeGroupDisplayMode, rifLength=rifLength, sysNetMask=sysNetMask, trapIPRcvrStatus=trapIPRcvrStatus, sysImgGblInvokeSrc=sysImgGblInvokeSrc, rifPrevious=rifPrevious, ipHostAddress=ipHostAddress, netbiosNamePortNumber=netbiosNamePortNumber, sysTableConfig=sysTableConfig, rifEntry=rifEntry, netbiosNameAge=netbiosNameAge, defaultGatewayAddr=defaultGatewayAddr, maxPerfMode=maxPerfMode, cnnetbiosNamePortType=cnnetbiosNamePortType, sysTFTPGroup=sysTFTPGroup, sysIpProtocol=sysIpProtocol, configProtocol=configProtocol, sysTFTPFileType=sysTFTPFileType, lnmAdminStatus=lnmAdminStatus, sysImgVer=sysImgVer, systemConfigMode=systemConfigMode, sysSNMPEnableTraps=sysSNMPEnableTraps, cnnetbiosNameVlanId=cnnetbiosNameVlanId, sysSNMPTrapIPReceiverEntry=sysSNMPTrapIPReceiverEntry, sysTFTPFileName=sysTFTPFileName, sysMcpRedundGbl=sysMcpRedundGbl, netbiosNameTableFlush=netbiosNameTableFlush, configSource=configSource, cnnetbiosNameVirtualRingNumber=cnnetbiosNameVirtualRingNumber, sysMcpRedundInfo=sysMcpRedundInfo, sysTFTPStart=sysTFTPStart, sysMcpRedundPriority=sysMcpRedundPriority, cnnetbiosNameStatus=cnnetbiosNameStatus, rifPath=rifPath, systemConfigIpOption=systemConfigIpOption, cnnetbiosNameEntry=cnnetbiosNameEntry, rifInUse=rifInUse, ipConfigProtocol=ipConfigProtocol, ipHostType=ipHostType, systemMaxPacketInfoSize=systemMaxPacketInfoSize, ipHostIndex=ipHostIndex, lnmLinkPassword=lnmLinkPassword, tbRifProxyEnable=tbRifProxyEnable, rifCount=rifCount, sonmpTrConfig=sonmpTrConfig, sysSNMPTrapIPReceiverTable=sysSNMPTrapIPReceiverTable, sysMcpRedundType=sysMcpRedundType, sysBcastAddr=sysBcastAddr, configLogin=configLogin, sysMcpRedundNxtGblState=sysMcpRedundNxtGblState, sysSNMPGetCommunity=sysSNMPGetCommunity, localAdminMacAddress=localAdminMacAddress, sysImgStatus=sysImgStatus, ipHostTable=ipHostTable, netbiosNameStationAddress=netbiosNameStationAddress, sonmpTrSpeed=sonmpTrSpeed, sysNetProtocol=sysNetProtocol, cnnetbiosNameTableEntry=cnnetbiosNameTableEntry, sysImgIndx=sysImgIndx, ipHostEnable=ipHostEnable, sysImgTable=sysImgTable, ipHostConfigProtocol=ipHostConfigProtocol, rifTable=rifTable, cnnetbiosNameSuppressedQueries=cnnetbiosNameSuppressedQueries, configServerAddr=configServerAddr, sysSNMPSetCommunity=sysSNMPSetCommunity)

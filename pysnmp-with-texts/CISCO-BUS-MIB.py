#
# PySNMP MIB module CISCO-BUS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-BUS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
AtmLaneAddress, = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "AtmLaneAddress")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ObjectIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Unsigned32, Counter64, Bits, Gauge32, Counter32, NotificationType, MibIdentifier, iso, ModuleIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Unsigned32", "Counter64", "Bits", "Gauge32", "Counter32", "NotificationType", "MibIdentifier", "iso", "ModuleIdentity", "IpAddress")
TextualConvention, RowStatus, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "TimeStamp")
ciscoBusMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 40))
if mibBuilder.loadTexts: ciscoBusMIB.setLastUpdated('9509151702Z')
if mibBuilder.loadTexts: ciscoBusMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoBusMIB.setContactInfo(' Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoBusMIB.setDescription(' The MIB module for the management of LANE broadcast and unknown servers.')
ciscoBusMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 40, 1))
class CiscoVpiInteger(TextualConvention, Integer32):
    description = ' An integer large enough to hold a VPI. In the event that VC does not exist, the value of an object with this syntax shall be -1.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-1, 255)

class CiscoVciInteger(TextualConvention, Integer32):
    description = ' An integer large enough to hold a VCI. In the event that VC does not exist, the value on an object with this syntax shall be -1.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-1, 65535)

busTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1), )
if mibBuilder.loadTexts: busTable.setStatus('current')
if mibBuilder.loadTexts: busTable.setDescription(' A (conceptual) table representing all the instantiations of BUSs on the designated device. This table may or may not allow the creation of rows depending on whether the LANE service elements allow the separate creation of LES and BUS components. In the event that separate components are not allowed then the MINIMUM-ACCESS detailed in the MODULE-COMPLIANCE should be used by those BUS implementations')
busEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1), ).setIndexNames((0, "CISCO-BUS-MIB", "busElanName"), (0, "CISCO-BUS-MIB", "busIndex"))
if mibBuilder.loadTexts: busEntry.setStatus('current')
if mibBuilder.loadTexts: busEntry.setDescription(' An entry (conceptual row) in the busTable.')
busElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: busElanName.setStatus('current')
if mibBuilder.loadTexts: busElanName.setDescription(' The ELAN name of the designated bridge.')
busIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: busIndex.setStatus('current')
if mibBuilder.loadTexts: busIndex.setDescription(' A unique identifier for this particular BUS on this ELAN. This value must remain constant while the entry is in existence and during the operation of the agent (i.e. It is allowed to change after reboot). For implementations that do not support more than one BUS entity per ELAN per device, it is sufficient to always report 1 for this object and only to accept the value 1 for row creation.')
busAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 3), AtmLaneAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busAtmAddrSpec.setStatus('current')
if mibBuilder.loadTexts: busAtmAddrSpec.setDescription(' The specified ATM address of the BUS on the interface of interest. Note that setting this object will have the side effect of reinitializing the BUS and consequently dropping all clients connected to it. If this object is not specified at row creation time then the BUS will choose a value for itself and attempt to register with the switch with that value. If an address is specified which is not acceptable to the switch then the busOperStatus will remain inactive until an acceptable address is set.')
busAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busAtmAddrMask.setStatus('current')
if mibBuilder.loadTexts: busAtmAddrMask.setDescription(" An address mask that when used with the busAtmAddrSpec, specifies the portion of the BUS' ATM address that is desired to be configured. Note that setting this object will result in the reinitialization of the BUS, consequently dropping all clients connected to it. At row creation time this object cannot be set without also supplying a value for the busAtmAddrSpec. If the BUS ATM address is omitted at creation time then this object defaults to the value of all zeros (none of the busAtmAddrSpec value is relevant). If the BUS ATM address is specified at creation time but this object omitted, then this object defaults to the value of all ones (all of the busAtmAddrSpec is relevant).")
busAtmAddrActl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busAtmAddrActl.setStatus('current')
if mibBuilder.loadTexts: busAtmAddrActl.setDescription(' The resultant ATM address in use by the BUS. This object is a product of the specified ATM address, mask and interaction with the switch via the ILMI.')
busIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busIfIndex.setStatus('current')
if mibBuilder.loadTexts: busIfIndex.setDescription(' The interface that a BUS will forward traffic over. The value specified for this object must equate to a value of ifIndex in the ifTable. The interface will be for that particular ATM port (the physical interface, not a logical layer on top of it). This object can only be specified upon row creation and cannot be altered there after.')
busSubIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busSubIfNum.setStatus('current')
if mibBuilder.loadTexts: busSubIfNum.setDescription(' Specifies the sub-interface number that the BUS will reside on. This sub-interface may be shared with a LEC or BUS of the same ELAN but is not required to do so. If no value is specified for this object at row creation time, then a sub-interface will be chosen by the agent. This object may only be specified at row creation time and cannot be altered thereafter.')
busUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busUpTime.setStatus('current')
if mibBuilder.loadTexts: busUpTime.setDescription(' The value of sysUpTime when this BUS became enabled.')
busLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dot3", 1), ("dot5", 2))).clone('dot3')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busLanType.setStatus('current')
if mibBuilder.loadTexts: busLanType.setDescription(' The type of legacy LAN that this LES emulates.')
busMaxFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1516, 4544, 9234, 18190))).clone(namedValues=NamedValues(("dot3", 1516), ("tr4Mb", 4544), ("rfc1626", 9234), ("tr16Mb", 18190))).clone('dot3')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busMaxFrm.setStatus('current')
if mibBuilder.loadTexts: busMaxFrm.setDescription(' The maximum frame size that the emulated LAN may accept.')
busMaxFrmAge = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: busMaxFrmAge.setStatus('current')
if mibBuilder.loadTexts: busMaxFrmAge.setDescription(' The maximum number of seconds a BUS will hold onto a packet for forwarding until it is dropped. Dropping a packet will result in the incrementing of the busFrmTimeOuts counter.')
busOutFwdOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busOutFwdOctets.setStatus('current')
if mibBuilder.loadTexts: busOutFwdOctets.setDescription(' The number of octets that this BUS has forwarded since its initialization.')
busOutFwdUcastFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busOutFwdUcastFrms.setStatus('current')
if mibBuilder.loadTexts: busOutFwdUcastFrms.setDescription(' The number of frames that the BUS has forwarded which were unicast data frames including all control frames (i.e. they were flooded from the client).')
busOutFwdNUcastFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busOutFwdNUcastFrms.setStatus('current')
if mibBuilder.loadTexts: busOutFwdNUcastFrms.setDescription(' The number of frames that the BUS has forwarded which were multicast frames.')
busFrmTimeOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busFrmTimeOuts.setStatus('current')
if mibBuilder.loadTexts: busFrmTimeOuts.setDescription(' The number of frames dropped by the BUS due to time out.')
busMultiFwdVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 16), CiscoVpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busMultiFwdVpi.setStatus('current')
if mibBuilder.loadTexts: busMultiFwdVpi.setDescription(' The virtual path identifier for the multicast forward VCC. ')
busMultiFwdVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 17), CiscoVciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busMultiFwdVci.setStatus('current')
if mibBuilder.loadTexts: busMultiFwdVci.setDescription(' The virtual channel identifier for the multicast forward VCC.')
busOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: busOperStatus.setStatus('current')
if mibBuilder.loadTexts: busOperStatus.setDescription(" This object reflects the actual state of the BUS which may differ from that of the busAdminStatus object. This can occur when the interface ifOperStatus is 'down' but the corresponding busAdminStatus is 'active'.")
busAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busAdminStatus.setStatus('current')
if mibBuilder.loadTexts: busAdminStatus.setDescription(' The desired state of the designated BUS as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the busOperStatus.')
busStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 1, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: busStatus.setStatus('current')
if mibBuilder.loadTexts: busStatus.setDescription(' The status of the BUS entry. This object cannot be set to active until the busIfIndex object has an appropiate value. Note that implementations that do not support separate LES/BUS entities may refuse row creation in this table. Creation of BUS entities for those implementation is facilitated in the LES MIB.')
busClientTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2), )
if mibBuilder.loadTexts: busClientTable.setStatus('current')
if mibBuilder.loadTexts: busClientTable.setDescription(' A (conceptual) table listing the clients associated with a BUS. Note that the local or network management will not create or destroy rows in this table but may only inspect what LECs are currently joined with the BUS.')
busClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2, 1), ).setIndexNames((0, "CISCO-BUS-MIB", "busElanName"), (0, "CISCO-BUS-MIB", "busIndex"), (0, "CISCO-BUS-MIB", "busClientId"))
if mibBuilder.loadTexts: busClientEntry.setStatus('current')
if mibBuilder.loadTexts: busClientEntry.setDescription(' An entry (conceptual) row that denotes a client that is establishing/has established a multicast send VC to the BUS.')
busClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: busClientId.setStatus('current')
if mibBuilder.loadTexts: busClientId.setDescription(' A unique identifier for a LEC which is establishing/ has-established a multicast send VC to the BUS. The identifier only persists for as long as the LEC is associated with this particular BUS. If the LEC is dropped and rejoins the ELAN then a new identifier may be attributed to it.')
busClientIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busClientIfIndex.setStatus('current')
if mibBuilder.loadTexts: busClientIfIndex.setDescription(' The interface of the uni-directional multicast send connection between the LEC and BUS.')
busClientMSendVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2, 1, 3), CiscoVpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busClientMSendVpi.setStatus('current')
if mibBuilder.loadTexts: busClientMSendVpi.setDescription(' The VPI of the uni-directional multicast send connection between the LEC and BUS.')
busClientMSendVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2, 1, 4), CiscoVciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busClientMSendVci.setStatus('current')
if mibBuilder.loadTexts: busClientMSendVci.setDescription(' The VCI of the uni-directional multicast send connection between the LEC and BUS.')
busClientAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 40, 1, 2, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busClientAtmAddress.setStatus('current')
if mibBuilder.loadTexts: busClientAtmAddress.setDescription(' The address associated with the LANE client on the mulicast send VCC.')
ciscoBusMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 40, 2))
ciscoBusMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 40, 2, 1))
ciscoBusMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 40, 2, 2))
ciscoBusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 40, 2, 1, 1)).setObjects(("CISCO-BUS-MIB", "busAtmAddrSpec"), ("CISCO-BUS-MIB", "busAtmAddrMask"), ("CISCO-BUS-MIB", "busAtmAddrActl"), ("CISCO-BUS-MIB", "busIfIndex"), ("CISCO-BUS-MIB", "busUpTime"), ("CISCO-BUS-MIB", "busLanType"), ("CISCO-BUS-MIB", "busMaxFrm"), ("CISCO-BUS-MIB", "busMaxFrmAge"), ("CISCO-BUS-MIB", "busOutFwdOctets"), ("CISCO-BUS-MIB", "busOutFwdUcastFrms"), ("CISCO-BUS-MIB", "busOutFwdNUcastFrms"), ("CISCO-BUS-MIB", "busFrmTimeOuts"), ("CISCO-BUS-MIB", "busMultiFwdVpi"), ("CISCO-BUS-MIB", "busMultiFwdVci"), ("CISCO-BUS-MIB", "busOperStatus"), ("CISCO-BUS-MIB", "busAdminStatus"), ("CISCO-BUS-MIB", "busStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoBusGroup = ciscoBusGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoBusGroup.setDescription(' A collection of objects for the managing of BUS operation.')
ciscoBusSubIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 40, 2, 1, 2)).setObjects(("CISCO-BUS-MIB", "busSubIfNum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoBusSubIfGroup = ciscoBusSubIfGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoBusSubIfGroup.setDescription(' For those implementations that wish to tie their LE service components to an aflane_802x ifIndex.')
ciscoBusClientGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 40, 2, 1, 3)).setObjects(("CISCO-BUS-MIB", "busClientIfIndex"), ("CISCO-BUS-MIB", "busClientMSendVpi"), ("CISCO-BUS-MIB", "busClientMSendVci"), ("CISCO-BUS-MIB", "busClientAtmAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoBusClientGroup = ciscoBusClientGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoBusClientGroup.setDescription(" A collection of objects for the identification of a BUS's multicast send VCs.")
ciscoBusMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 40, 2, 2, 1)).setObjects(("CISCO-BUS-MIB", "ciscoBusGroup"), ("CISCO-BUS-MIB", "ciscoBusSubIfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoBusMIBCompliance = ciscoBusMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoBusMIBCompliance.setDescription(" The compliance statement for SNMP entities that support Cisco's BUS MIB.")
mibBuilder.exportSymbols("CISCO-BUS-MIB", busMaxFrmAge=busMaxFrmAge, busAtmAddrActl=busAtmAddrActl, busAtmAddrMask=busAtmAddrMask, busStatus=busStatus, busTable=busTable, busAtmAddrSpec=busAtmAddrSpec, busSubIfNum=busSubIfNum, CiscoVpiInteger=CiscoVpiInteger, PYSNMP_MODULE_ID=ciscoBusMIB, busLanType=busLanType, busFrmTimeOuts=busFrmTimeOuts, busClientIfIndex=busClientIfIndex, busMultiFwdVpi=busMultiFwdVpi, busOperStatus=busOperStatus, busEntry=busEntry, busOutFwdUcastFrms=busOutFwdUcastFrms, busElanName=busElanName, busIfIndex=busIfIndex, ciscoBusMIBCompliances=ciscoBusMIBCompliances, busClientTable=busClientTable, ciscoBusClientGroup=ciscoBusClientGroup, ciscoBusSubIfGroup=ciscoBusSubIfGroup, ciscoBusMIBCompliance=ciscoBusMIBCompliance, busClientEntry=busClientEntry, busUpTime=busUpTime, CiscoVciInteger=CiscoVciInteger, busClientMSendVpi=busClientMSendVpi, ciscoBusMIB=ciscoBusMIB, busClientId=busClientId, busMultiFwdVci=busMultiFwdVci, ciscoBusMIBObjects=ciscoBusMIBObjects, busOutFwdOctets=busOutFwdOctets, ciscoBusMIBGroups=ciscoBusMIBGroups, busClientAtmAddress=busClientAtmAddress, ciscoBusMIBConformance=ciscoBusMIBConformance, ciscoBusGroup=ciscoBusGroup, busIndex=busIndex, busMaxFrm=busMaxFrm, busAdminStatus=busAdminStatus, busOutFwdNUcastFrms=busOutFwdNUcastFrms, busClientMSendVci=busClientMSendVci)

#
# PySNMP MIB module DOCS-DIAG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DOCS-DIAG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:52:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
clabProjDocsis, = mibBuilder.importSymbols("CLAB-DEF-MIB", "clabProjDocsis")
docsDevEvId, docsDevEvLevel = mibBuilder.importSymbols("DOCS-CABLE-DEVICE-MIB", "docsDevEvId", "docsDevEvLevel")
docsIf3CmtsCmRegStatusId, CmtsCmRegState = mibBuilder.importSymbols("DOCS-IF3-MIB", "docsIf3CmtsCmRegStatusId", "CmtsCmRegState")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
NotificationType, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, iso, MibIdentifier, Unsigned32, Counter64, Gauge32, ObjectIdentity, ModuleIdentity, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "iso", "MibIdentifier", "Unsigned32", "Counter64", "Gauge32", "ObjectIdentity", "ModuleIdentity", "IpAddress", "TimeTicks")
DisplayString, DateAndTime, TextualConvention, TruthValue, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "DateAndTime", "TextualConvention", "TruthValue", "MacAddress")
docsDiagMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9))
docsDiagMib.setRevisions(('2007-12-06 00:00', '2007-05-18 00:00', '2006-12-07 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: docsDiagMib.setRevisionsDescriptions(('Revised version includes ECN OSSIv3.0-N-07.0550-2 and published as I05.', 'Revised Version includes ECN OSSIv3.0-N-07.0410-4 and published as I03.', 'Initial version, published as part of the CableLabs OSSIv3.0 specification CM-SP-OSSIv3.0-I01-061207.',))
if mibBuilder.loadTexts: docsDiagMib.setLastUpdated('200712060000Z')
if mibBuilder.loadTexts: docsDiagMib.setOrganization('Cable Television Laboratories, Inc.')
if mibBuilder.loadTexts: docsDiagMib.setContactInfo('Postal: Cable Television Laboratories 858 Coal Creek Circle Louisville, CO 80027-9750 U.S.A. Phone: +1 303-661-9100 Fax: +1 303-661-9199 E-mail: mibs@cablelabs.com')
if mibBuilder.loadTexts: docsDiagMib.setDescription('This is the MIB Module for the Diagnostic Log for DOCSIS-compliant Cable Modem Termination Systems (CMTS). The purpose of the Diagnostic Log is to prevent service interruptions by early detection of potential problems. It can also be used for fault management and for troubleshooting the cable network. The Diagnostic Log contains Cable Modems that show certain potential problematic behaviors, as determined by the CMTS. These detection criteria are defined as diagnostic triggers. The diagnostic trigger is an information filter to avoid inundating a management agent with data which is less meaningful as a function of size. There are 2 diagnostic triggers defined. Each trigger maintains a counter for each Cable Modem that is caught by that trigger. (1) Registration Trigger (2) Ranging Retry Trigger Copyright 1999-2007 Cable Television Laboratories, Inc. All rights reserved.')
class TriggerFlag(TextualConvention, Bits):
    description = 'This type defines the Diagnostic Log Trigger Type. Bit 0 selects the registration trigger. Bit 1 selects the ranging retry trigger.'
    status = 'current'
    namedValues = NamedValues(("registration", 0), ("rangingRetry", 1))

class RegistrationDetailFlag(TextualConvention, Bits):
    description = 'This data type defines an enumerated union of CM states used for the registration trigger detection. The named bits associated with this type correspond to a subset of the names for the enumerations in CmtsCmRegState data type.'
    status = 'current'
    namedValues = NamedValues(("other", 0), ("initialRanging", 1), ("rangingAutoAdjComplete", 2), ("startEae", 3), ("startDhcpv4", 4), ("startDhcpv6", 5), ("dhcpv4Complete", 6), ("dhcpv6Complete", 7), ("startConfigFileDownload", 8), ("configFileDownloadComplete", 9), ("startRegistration", 10), ("registrationComplete", 11), ("bpiInit", 12), ("operational", 13))

docsDiagLogNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0))
docsDiagLogMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1))
docsDiagLogGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1))
docsDiagLogTriggersCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2))
docsDiagLogMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(100)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogMaxSize.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogMaxSize.setDescription('The maximum number of Cable Modem entries that docsDiagLogTable can report.')
docsDiagLogCurrentSize = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogCurrentSize.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCurrentSize.setDescription('The total number of Cable Modem entries reported in the docsDiagLogTable. The maximum value possible will be docsDiagLogMaxSize.')
docsDiagLogNotifyLogSizeHighThrshld = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(80)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeHighThrshld.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeHighThrshld.setDescription('If the number of entries in docsDiagLogTable exceeds this value, CMTS will trigger the appropriate event.')
docsDiagLogNotifyLogSizeLowThrshld = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(60)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeLowThrshld.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotifyLogSizeLowThrshld.setDescription('If the number of entries in docsDiagLogTable exceeded docsDiagLogNotifyLogSizeHighThrshld earlier and then drops to this value, CMTS will trigger the appropriate event.')
docsDiagLogAging = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400)).clone(10080)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogAging.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogAging.setDescription('Aging threshold for the Diagnostic Log. Periodically, a process scans through the Diagnostic log and removes those Cable Modems from docsDiagLogTable and docsDiagLogDetailTable that have no new detections for a time interval longer than this threshold in minutes.')
docsDiagLogResetAll = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogResetAll.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogResetAll.setDescription("If set to 'true', all counter objects for all entries in docsDiagLogTable and docsDiagLogDetailTable are reset to zero. Reading this object always returns 'false'.")
docsDiagLogLastResetTime = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastResetTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastResetTime.setDescription("The last time that all the counters in the docsDiagLogTable and docsDiagLogDetailTable are reset to 0. The special value of all '00'Hs indicates that the Entries in these tables have never been reset.")
docsDiagLogClearAll = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogClearAll.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogClearAll.setDescription("If set to 'true', all entries from the docsDiagLogTable and docsDiagLogDetailTable are removed. Reading this object always returns 'false'.")
docsDiagLogLastClearTime = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastClearTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastClearTime.setDescription("The last time that all the entries in the docsDiagLogTable and docsDiagLogDetailTable are destroyed. The special value of all '00'Hs indicates that the entries in these tables have never been destroyed.")
docsDiagLogNotifCtrl = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 1, 10), Bits().clone(namedValues=NamedValues(("highThresholdReached", 0), ("lowThresholdReached", 1), ("full", 2))).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogNotifCtrl.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotifCtrl.setDescription('Used to enable diagnostic log related notifications. Setting bit 0 enables notification for reaching log size high threshold, Setting bit 1 enables notification for returning back to log size low threshold after reaching log size high threshold, Setting bit 2 enables notification for diagnostic log size full.')
docsDiagLogIncludeTriggers = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 1), TriggerFlag().clone(hexValue="C0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogIncludeTriggers.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogIncludeTriggers.setDescription("Turns individual diagnostic triggers on and off. Multiple triggers can be turned on or off at a given time. Setting a particular bit to '1' turns on corresponding diagnostic trigger. Setting a particular bit to '0' turns off corresponding diagnostic trigger.")
docsDiagLogEnableAgingTriggers = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 2), TriggerFlag().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogEnableAgingTriggers.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogEnableAgingTriggers.setDescription("Enables and disables the aging of triggers based on the trigger type. Aging out can be enabled or disabled for multiple triggers at a given time. Setting a particular bit to '1' enables the aging out of log entries that are created by corresponding diagnostic trigger. Setting a particular bit to '0' disables the aging out of log entries that are created by corresponding diagnostic trigger.")
docsDiagLogRegTimeInterval = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(90)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRegTimeInterval.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRegTimeInterval.setDescription('Configurable parameter for the Registration trigger. The registration time interval is an empirically derived, worst-case number of seconds which the Cable Modem requires to complete registration. If the Cable Modem has not completed the registration stage within this registration time interval, the Cable Modem will be added to the Diagnostic Log.')
docsDiagLogRegDetail = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 4), RegistrationDetailFlag().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRegDetail.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRegDetail.setDescription('Setting a bit representing a CM registration state will enable counting the number of times the CMTS determines that such CM reaches that state as the last state before failing to proceed further in the registration process and within the time interval considered for the CM registration trigger detection.')
docsDiagLogRangingRetryType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("consecutiveMiss", 1), ("missRatio", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRangingRetryType.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryType.setDescription("Configuration parameter for the Ranging Retry Trigger. When a Cable Modem failed to perform ranging when a ranging opportunity is scheduled by CMTS, it is counted as ranging miss. Ranging retry trigger can be configured to either look at consecutive ranging misses or ranging miss ratio over total number of station maintenance opportunities for a certain time period. If set to '1', this will select consecutive ranging misses as ranging retry trigger criteria. If set to '2', this will select ranging miss ratio as ranging retry trigger criteria.")
docsDiagLogRangingRetryThrhld = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 12)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRangingRetryThrhld.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryThrhld.setDescription('Configurable parameter for the Ranging Retry Trigger. When the number of times a Cable Modem does not acknowledge a MAC-layer station maintenance message from a CMTS exceeds this threshold, the Cable Modem will be add to the Diagnostic Log. The value of docsDiagLogRangingRetryType, decides if consecutive ranging miss or ranging miss ratio is used as trigger.')
docsDiagLogRangingRetryStationMaintNum = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 2, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 65535)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDiagLogRangingRetryStationMaintNum.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryStationMaintNum.setDescription('Number of station maintenance opportunities to monitor for ranging retry trigger. This value implies time intervals in a certain range. DOCSIS requires the CMTS to schedule ranging opportunity to Cable Modem sufficiently smaller than T4. There is no fixed formula to derive at a fixed time interval, how many ranging opportunities would be offered to a Cable Modem by the CMTS, hence using the number of station maintenance opportunities provides ratio with the fixed denominators while also taking time factor into consideration.')
docsDiagLogTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3), )
if mibBuilder.loadTexts: docsDiagLogTable.setReference('DOCSIS 3.0 Operation and Support System Interface Specification CM-SP-OSSIv3.0-I01-061207, Diagnostic Log Annex.')
if mibBuilder.loadTexts: docsDiagLogTable.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogTable.setDescription('This table keeps the Diagnostic Log of the Cable Modems, it is indexed by docsIf3CmtsCmRegStatusId.')
docsDiagLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1), ).setIndexNames((0, "DOCS-IF3-MIB", "docsIf3CmtsCmRegStatusId"))
if mibBuilder.loadTexts: docsDiagLogEntry.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogEntry.setDescription('A conceptual row entry in this table is a per Cable Modem summary of the diagnostic information detected by one or more triggers. There can be only one entry in this for a given Cable Modem.')
docsDiagLogCmMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogCmMacAddr.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCmMacAddr.setDescription('MAC address of the Cable Modem.')
docsDiagLogLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastUpdateTime.setDescription('The time and date value when this entry was last updated. When a Cable Modem is detected by one of the diagnostic trigger, if this table already has an entry for that Cable Modem, the entry will be updated.')
docsDiagLogCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogCreateTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCreateTime.setDescription('The time and date value that this entry was added to this table. When a Cable Modem is detected by one of the diagnostic triggers, if this table has no entry for that cable mode, a new entry will be created. If an entry is removed and then re-added, there can be a discontinuity in the statistical objects associated with this entry. This timestamp can be used to detect those discontinuities.')
docsDiagLogLastRegTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 4), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogLastRegTime.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogLastRegTime.setDescription('The last time this Cable Modem registered.')
docsDiagLogRegCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogRegCount.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRegCount.setDescription('The number of times the registration trigger condition was detected for this Cable Modem.')
docsDiagLogRangingRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogRangingRetryCount.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogRangingRetryCount.setDescription('The number of times the ranging retry trigger condition was detected for this Cable Modem.')
docsDiagLogDetailTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4), )
if mibBuilder.loadTexts: docsDiagLogDetailTable.setReference('DOCSIS 3.0 Operation and Support System Interface Specification CM-SP-OSSIv3.0-I01-061207, Diagnostic Log Annex.')
if mibBuilder.loadTexts: docsDiagLogDetailTable.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailTable.setDescription('This table contains detailed diagnostic information for Cable Modems already in docsDiagLogTable.')
docsDiagLogDetailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1), ).setIndexNames((0, "DOCS-IF3-MIB", "docsIf3CmtsCmRegStatusId"), (0, "DOCS-DIAG-MIB", "docsDiagLogDetailTypeValue"))
if mibBuilder.loadTexts: docsDiagLogDetailEntry.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailEntry.setDescription('A conceptual row in this table contains one single type of detailed diagnostic information for a Cable Modem. This table shall be instantiated only if at least one detail condition is enabled, via docsDiagLogRegDetail. There can be multiple entries in this table for a given cable modem, if more than one detail condition is enabled.')
docsDiagLogDetailTypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 1), CmtsCmRegState())
if mibBuilder.loadTexts: docsDiagLogDetailTypeValue.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailTypeValue.setDescription('The diagnostic detail type this entry represents.')
docsDiagLogDetailCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogDetailCount.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailCount.setDescription('The counter value of this Cable Modem that reached this diagnostic detail state as the last state before it failed to proceed further.')
docsDiagLogDetailLastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogDetailLastUpdate.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailLastUpdate.setDescription('Time and date value when this entry was last updated.')
docsDiagLogDetailLastErrorText = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 1, 4, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDiagLogDetailLastErrorText.setReference('DOCSIS 3.0 Operation and Support System Interface Specification CM-SP-OSSIv3.0-I01-061207, Format and Content for Event, Syslog, and SNMP Notification. Annex.')
if mibBuilder.loadTexts: docsDiagLogDetailLastErrorText.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogDetailLastErrorText.setDescription('Contains the Event ID and Event Text of the event condition that triggers this entry. The format is: <Event ID> Event Text')
docsDiagLogSizeHighThrshldReached = NotificationType((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0, 1)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogMaxSize"))
if mibBuilder.loadTexts: docsDiagLogSizeHighThrshldReached.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogSizeHighThrshldReached.setDescription('This notification indicates that the current size of Diagnostic Log grows beyond docsDiagLogNotifyLogSizeHighThrshld.')
docsDiagLogSizeLowThrshldReached = NotificationType((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0, 2)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogMaxSize"))
if mibBuilder.loadTexts: docsDiagLogSizeLowThrshldReached.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogSizeLowThrshldReached.setDescription('This notification indicates that the current size of Diagnostic Log drops to docsDiagLogNotifyLogSizeLowThrshld after it exceeded docsDiagLogNotifyLogSizeHighThrshld earlier.')
docsDiagLogSizeFull = NotificationType((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 0, 3)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogMaxSize"))
if mibBuilder.loadTexts: docsDiagLogSizeFull.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogSizeFull.setDescription('This notification indicates that the Diagnostic Log is full.')
docsDiagLogConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2))
docsDiagLogCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 1))
docsDiagLogGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 2))
docsDiagLogCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 1, 1)).setObjects(("DOCS-DIAG-MIB", "docsDiagLogBaseGroup"), ("DOCS-DIAG-MIB", "docsDiagLogNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDiagLogCompliance = docsDiagLogCompliance.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogCompliance.setDescription('The compliance statement for the diagnostic log MIB for DOCSIS compliant Cable Modem Termination Systems')
docsDiagLogBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 2, 1)).setObjects(("DOCS-DIAG-MIB", "docsDiagLogMaxSize"), ("DOCS-DIAG-MIB", "docsDiagLogCurrentSize"), ("DOCS-DIAG-MIB", "docsDiagLogNotifyLogSizeHighThrshld"), ("DOCS-DIAG-MIB", "docsDiagLogNotifyLogSizeLowThrshld"), ("DOCS-DIAG-MIB", "docsDiagLogAging"), ("DOCS-DIAG-MIB", "docsDiagLogResetAll"), ("DOCS-DIAG-MIB", "docsDiagLogLastResetTime"), ("DOCS-DIAG-MIB", "docsDiagLogClearAll"), ("DOCS-DIAG-MIB", "docsDiagLogLastClearTime"), ("DOCS-DIAG-MIB", "docsDiagLogNotifCtrl"), ("DOCS-DIAG-MIB", "docsDiagLogIncludeTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogEnableAgingTriggers"), ("DOCS-DIAG-MIB", "docsDiagLogRegTimeInterval"), ("DOCS-DIAG-MIB", "docsDiagLogRegDetail"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryType"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryThrhld"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryStationMaintNum"), ("DOCS-DIAG-MIB", "docsDiagLogCmMacAddr"), ("DOCS-DIAG-MIB", "docsDiagLogLastUpdateTime"), ("DOCS-DIAG-MIB", "docsDiagLogCreateTime"), ("DOCS-DIAG-MIB", "docsDiagLogLastRegTime"), ("DOCS-DIAG-MIB", "docsDiagLogRegCount"), ("DOCS-DIAG-MIB", "docsDiagLogRangingRetryCount"), ("DOCS-DIAG-MIB", "docsDiagLogDetailCount"), ("DOCS-DIAG-MIB", "docsDiagLogDetailLastUpdate"), ("DOCS-DIAG-MIB", "docsDiagLogDetailLastErrorText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDiagLogBaseGroup = docsDiagLogBaseGroup.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogBaseGroup.setDescription('CMTS is required to support objects in this group')
docsDiagLogNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 4491, 2, 1, 9, 2, 2, 2)).setObjects(("DOCS-DIAG-MIB", "docsDiagLogSizeHighThrshldReached"), ("DOCS-DIAG-MIB", "docsDiagLogSizeLowThrshldReached"), ("DOCS-DIAG-MIB", "docsDiagLogSizeFull"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDiagLogNotificationGroup = docsDiagLogNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: docsDiagLogNotificationGroup.setDescription('CMTS is required to support objects in this group')
mibBuilder.exportSymbols("DOCS-DIAG-MIB", docsDiagLogCompliance=docsDiagLogCompliance, docsDiagLogSizeLowThrshldReached=docsDiagLogSizeLowThrshldReached, docsDiagLogClearAll=docsDiagLogClearAll, docsDiagLogNotifications=docsDiagLogNotifications, docsDiagLogCompliances=docsDiagLogCompliances, docsDiagLogNotifyLogSizeLowThrshld=docsDiagLogNotifyLogSizeLowThrshld, docsDiagLogRangingRetryType=docsDiagLogRangingRetryType, docsDiagLogRangingRetryThrhld=docsDiagLogRangingRetryThrhld, docsDiagLogEnableAgingTriggers=docsDiagLogEnableAgingTriggers, docsDiagLogCurrentSize=docsDiagLogCurrentSize, docsDiagLogCmMacAddr=docsDiagLogCmMacAddr, docsDiagLogBaseGroup=docsDiagLogBaseGroup, TriggerFlag=TriggerFlag, docsDiagLogDetailEntry=docsDiagLogDetailEntry, docsDiagLogGlobal=docsDiagLogGlobal, docsDiagLogAging=docsDiagLogAging, docsDiagLogRegDetail=docsDiagLogRegDetail, docsDiagLogIncludeTriggers=docsDiagLogIncludeTriggers, docsDiagLogLastUpdateTime=docsDiagLogLastUpdateTime, docsDiagLogConformance=docsDiagLogConformance, docsDiagLogRangingRetryCount=docsDiagLogRangingRetryCount, docsDiagLogMaxSize=docsDiagLogMaxSize, docsDiagLogCreateTime=docsDiagLogCreateTime, docsDiagLogGroups=docsDiagLogGroups, docsDiagMib=docsDiagMib, docsDiagLogEntry=docsDiagLogEntry, docsDiagLogMibObjects=docsDiagLogMibObjects, RegistrationDetailFlag=RegistrationDetailFlag, docsDiagLogRegCount=docsDiagLogRegCount, docsDiagLogDetailTypeValue=docsDiagLogDetailTypeValue, docsDiagLogSizeFull=docsDiagLogSizeFull, docsDiagLogNotifyLogSizeHighThrshld=docsDiagLogNotifyLogSizeHighThrshld, PYSNMP_MODULE_ID=docsDiagMib, docsDiagLogTable=docsDiagLogTable, docsDiagLogResetAll=docsDiagLogResetAll, docsDiagLogLastResetTime=docsDiagLogLastResetTime, docsDiagLogDetailLastErrorText=docsDiagLogDetailLastErrorText, docsDiagLogLastClearTime=docsDiagLogLastClearTime, docsDiagLogNotificationGroup=docsDiagLogNotificationGroup, docsDiagLogSizeHighThrshldReached=docsDiagLogSizeHighThrshldReached, docsDiagLogTriggersCfg=docsDiagLogTriggersCfg, docsDiagLogDetailCount=docsDiagLogDetailCount, docsDiagLogDetailTable=docsDiagLogDetailTable, docsDiagLogNotifCtrl=docsDiagLogNotifCtrl, docsDiagLogRangingRetryStationMaintNum=docsDiagLogRangingRetryStationMaintNum, docsDiagLogRegTimeInterval=docsDiagLogRegTimeInterval, docsDiagLogLastRegTime=docsDiagLogLastRegTime, docsDiagLogDetailLastUpdate=docsDiagLogDetailLastUpdate)

#
# PySNMP MIB module CISCO-CALL-TRACKER-MODEM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CALL-TRACKER-MODEM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:52:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
cctActiveCallId, cctHistoryIndex = mibBuilder.importSymbols("CISCO-CALL-TRACKER-MIB", "cctActiveCallId", "cctHistoryIndex")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Unsigned32, Counter64, Bits, MibIdentifier, Gauge32, iso, TimeTicks, IpAddress, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Integer32, Counter32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter64", "Bits", "MibIdentifier", "Gauge32", "iso", "TimeTicks", "IpAddress", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Integer32", "Counter32", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ciscoCallTrackerModemMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 165))
ciscoCallTrackerModemMIB.setRevisions(('2005-12-06 00:00', '2001-12-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCallTrackerModemMIB.setRevisionsDescriptions(('Updated the imports such that Unsigned32 is imported from SNMPv2-SMI instead of CISCO-TC. Re-ordered the objects cctmActiveLocalDownRateShifts, cctmActiveRemoteUpRateShifts under CctmActiveEntry, and cctmHistoryLocalDownRateShifts and cctmHistoryRemoteUpRateShifts under CctmHistoryEntry to match the order in which they are defined.', 'Initial version of this mib.',))
if mibBuilder.loadTexts: ciscoCallTrackerModemMIB.setLastUpdated('200512060000Z')
if mibBuilder.loadTexts: ciscoCallTrackerModemMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoCallTrackerModemMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W. Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-dial@cisco.com')
if mibBuilder.loadTexts: ciscoCallTrackerModemMIB.setDescription('This MIB module provides modem call related data for tracking the progress and status of a call. This module extends tables defined in the MIB module ciscoCallTrackerMIB in CISCO-CALL-TRACKER-MIB. ')
class CctmModulation(TextualConvention, Integer32):
    description = 'Represents possible modulation standards other - Modulation other than those identified bell103a - bell212a - v21 - v22 - v22bis - v32 - v32bis - vfc - v34 - v17 - v29 - v33 - k56flex - v23 - v32terbo - v34plus - v90 - v27ter - v110 - '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))
    namedValues = NamedValues(("other", 1), ("bell103a", 2), ("bell212a", 3), ("v21", 4), ("v22", 5), ("v22bis", 6), ("v32", 7), ("v32bis", 8), ("vfc", 9), ("v34", 10), ("v17", 11), ("v29", 12), ("v33", 13), ("k56flex", 14), ("v23", 15), ("v32terbo", 16), ("v34plus", 17), ("v90", 18), ("v27ter", 19), ("v110", 20))

class CctmECProtocol(TextualConvention, Integer32):
    description = 'Represents possible error correction protocols normal - No EC present direct - mnp - lapmV42 - syncMode - asyncMode - No EC present, same as normal(1) ara1 - ARA 1.0 ara2 - ARA 2.0 other - EC protocol other than those identified '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("normal", 1), ("direct", 2), ("mnp", 3), ("lapmV42", 4), ("syncMode", 5), ("asyncMode", 6), ("ara1", 7), ("ara2", 8), ("other", 9))

class CctmDataCompression(TextualConvention, Integer32):
    description = 'Represents possible data compression protocols none - No Data Compression present v42bisTx - V.42bis in transmit direction only v42bisRx - V.42bis in receive direction only v42bisBoth - V.42bis in receive and transmit directions mnp5 - v44Tx - V.44 in transmit direction only v44Rx - V.44 in receive direction only v44Both - V.44 in receive and transmit directions '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("none", 1), ("v42bisTx", 2), ("v42bisRx", 3), ("v42bisBoth", 4), ("mnp5", 5), ("v44Tx", 6), ("v44Rx", 7), ("v44Both", 8))

cctmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 1))
cctmActive = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1))
cctmHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2))
cctmActiveTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1), )
if mibBuilder.loadTexts: cctmActiveTable.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTable.setDescription('This table contains entries for active calls in the system which utilize modem resources. It contains general modem session attributes and statistics at the modem link and modem protocol layers. The table extends the cctActiveTable, using the same index, cctActiveCallId. There are no entries for calls not requiring modem services. ')
cctmActiveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-CALL-TRACKER-MIB", "cctActiveCallId"))
if mibBuilder.loadTexts: cctmActiveEntry.setStatus('current')
if mibBuilder.loadTexts: cctmActiveEntry.setDescription('The information regarding a single call. Entries are created and deleted in sync with the entries in cctActiveTable, if the call utilizes modem service. ')
cctmActiveProjectedMaxRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 1), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveProjectedMaxRxRate.setStatus('current')
if mibBuilder.loadTexts: cctmActiveProjectedMaxRxRate.setDescription('Maximum received rate local modem informs remote modem it will support based on initial negotiations. The remote modem will not attempt to transmit at rates greater than what the local modem will accept. The initial negotiated receive rate is in cctActiveRxRate. ')
cctmActiveProjectedMaxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 2), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveProjectedMaxTxRate.setStatus('current')
if mibBuilder.loadTexts: cctmActiveProjectedMaxTxRate.setDescription('Maximum rate the remote modem indicates it can accept based on initial negotiations. The local modem will not attempt to transmit at rates above what the remote modem will accept. The initial negotiated transmit rate is in cctActiveTxRate. ')
cctmActiveRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 3), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxRate.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxRate.setDescription('Current receive data rate for this call. The value of this object will be the same as reported in cmRXRate from CISCO-MODEM-MGMT-MIB while the call is active. ')
cctmActiveTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 4), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveTxRate.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTxRate.setDescription('Current transmit data rate for this call. The value of this object will be the same as reported in cmTXRate from CISCO-MODEM-MGMT-MIB while the call is active. ')
cctmActiveAttemptedModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 5), CctmModulation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveAttemptedModulation.setStatus('current')
if mibBuilder.loadTexts: cctmActiveAttemptedModulation.setDescription('The initial modulation attempted when the modems began negotiation. ')
cctmActiveInitialModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 6), CctmModulation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveInitialModulation.setStatus('current')
if mibBuilder.loadTexts: cctmActiveInitialModulation.setDescription('The initial negotiated modulation. ')
cctmActiveModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 7), CctmModulation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveModulation.setStatus('current')
if mibBuilder.loadTexts: cctmActiveModulation.setDescription('The current modulation for this call. It is possible for retrains to result in the modulation being renogiated during a call. The value of this object will be the same as reported in cmModulationSchemeUsed from CISCO-MODEM-MGMT-MIB while the call is active. ')
cctmActiveAttemptedECProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 8), CctmECProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveAttemptedECProtocol.setStatus('current')
if mibBuilder.loadTexts: cctmActiveAttemptedECProtocol.setDescription('The initial modem error correction protocol attempted during call negotiation. The actual EC negotiated is in cctmActiveECProtocol. ')
cctmActiveECProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 9), CctmECProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveECProtocol.setStatus('current')
if mibBuilder.loadTexts: cctmActiveECProtocol.setDescription('The modem error correction protocol negotiated for this call. The value of this object will be the same as reported in cmProtocolUsed from CISCO-MODEM-MGMT-MIB while the call is active. ')
cctmActiveSupportedDC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 10), Bits().clone(namedValues=NamedValues(("mnp5", 0), ("v42bisRx", 1), ("v42bisTx", 2), ("v44Rx", 3), ("v44Tx", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveSupportedDC.setStatus('current')
if mibBuilder.loadTexts: cctmActiveSupportedDC.setDescription('The data compression protocols supported by the calling modem. This object is a bit map, with each bit representing a different call type as identified below. A 1-bit indicates the DC protocol is supported. A 0-bit indicates the DC protocol is not supported. Bit 0 - MNP5 Bit 1 - V.42bis in the receive direction Bit 2 - V.42bis in the transmit direction V.42bis may be separately available in Rx or Tx directions. If all bits are zero, no data compression is supported. The particular compression selected by the answering modem is reported in cctmActiveDataCompression. ')
cctmActiveDataCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 11), CctmDataCompression()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveDataCompression.setStatus('current')
if mibBuilder.loadTexts: cctmActiveDataCompression.setDescription('The modem compression protocol selected for this call. ')
cctmActiveRxHighWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 12), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxHighWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxHighWatermark.setDescription('The maximum receive data rate achieved during this call. ')
cctmActiveRxLowWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 13), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxLowWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxLowWatermark.setDescription('The minimum receive data rate during this call. ')
cctmActiveTxHighWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 14), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveTxHighWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTxHighWatermark.setDescription('The maximum transmit data rate achieved during this call. ')
cctmActiveTxLowWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 15), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveTxLowWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTxLowWatermark.setDescription('The minimum transmit data rate during this call. ')
cctmActiveLocalUpRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveLocalUpRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmActiveLocalUpRateShifts.setDescription('The count of locally initiated rate shifts to increase the data rate which were successful. ')
cctmActiveLocalDownRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveLocalDownRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmActiveLocalDownRateShifts.setDescription('The count of locally initiated rate shifts to decrease the data rate which were successful. ')
cctmActiveRemoteUpRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRemoteUpRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRemoteUpRateShifts.setDescription('The count of remotely initiated rate shifts to increase the data rate which were successful. ')
cctmActiveRemoteDownRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRemoteDownRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRemoteDownRateShifts.setDescription('The count of remotely initiated rate shifts to decrease the data rate which were successful. ')
cctmActiveRateShiftFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRateShiftFailures.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRateShiftFailures.setDescription('The count of rate shift attempts which failed to complete. A failure to complete a rate renegotiation results in a retrain attempt. ')
cctmActiveLocalRetrains = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveLocalRetrains.setStatus('current')
if mibBuilder.loadTexts: cctmActiveLocalRetrains.setDescription('The count of locally initiated retrains for the call. Includes successfully completed retrains and those which failed. ')
cctmActiveRemoteRetrains = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRemoteRetrains.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRemoteRetrains.setDescription('The count of remotely initiated retrains for the call. Includes successfully completed retrains and those which failed. ')
cctmActiveRetrainFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRetrainFailures.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRetrainFailures.setDescription('The count of retrains which failed to complete. A failure to retrain results in another retrain attempt. The call will terminate if too many consecutive retrain failures occur. The consecutive retrain failure threshold is system specific. ')
cctmActiveRxLinkOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxLinkOctets.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxLinkOctets.setDescription('The total modem link level octets received during this call. If using Error Correction and Data Compression, this is the compressed data within the EC protocol frames. ')
cctmActiveTxLinkOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveTxLinkOctets.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTxLinkOctets.setDescription('The total modem link level octets transmitted during this call. If using Error Correction and Data Compression, this is the compressed data within the EC protocol frames. ')
cctmActiveRxECFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxECFrames.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxECFrames.setDescription('The total number of error correction data frames received successfully. This does not include damaged frames or control frames. ')
cctmActiveTxECFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveTxECFrames.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTxECFrames.setDescription('The total number of error correction data frames transmitted successfully. This does not include data frame resends or control frames. ')
cctmActiveRxECNAKs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxECNAKs.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxECNAKs.setDescription('The total number of EC protocol negative acknowledgements (NAK) received. ')
cctmActiveTxECNAKs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveTxECNAKs.setStatus('current')
if mibBuilder.loadTexts: cctmActiveTxECNAKs.setDescription('The total number of EC protocol negative acknowledgements (NAK) sent. ')
cctmActiveRxECFramesBad = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxECFramesBad.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxECFramesBad.setDescription('The total error correction frames received during the call which were determined to be bad. ')
cctmActiveECFramesResent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveECFramesResent.setStatus('current')
if mibBuilder.loadTexts: cctmActiveECFramesResent.setDescription('The count of total retransmitted error correction data frames during the call. ')
cctmActiveECLinkTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveECLinkTimeouts.setStatus('current')
if mibBuilder.loadTexts: cctmActiveECLinkTimeouts.setDescription("This counter provides the number of EC link protocol timer expirations which have occurred during the call. This corresponds to the T401 timer for LAPM and MNP. These are distinct from normal 'keep alive' and 'window open' timeouts. ")
cctmActiveRxCharLost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmActiveRxCharLost.setStatus('current')
if mibBuilder.loadTexts: cctmActiveRxCharLost.setDescription('The number of characters received by the modem but were dropped due to host buffer over run. ')
cctmHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1), )
if mibBuilder.loadTexts: cctmHistoryTable.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryTable.setDescription('This table provides information on terminated modem calls. It contains general modem session attributes and statistics at the modem link and modem protocol layers. The table extends the cctHistoryTable, using the same index, cctHistoryIndex. There are no entries for calls not requiring modem services. ')
cctmHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-CALL-TRACKER-MIB", "cctHistoryIndex"))
if mibBuilder.loadTexts: cctmHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryEntry.setDescription('The information regarding a single terminated modem call. Entries are created and deleted in sync with the entries in cctHistoryTable, if the call utilized modem service. ')
cctmHistoryProjectedMaxRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 1), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryProjectedMaxRxRate.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryProjectedMaxRxRate.setDescription('Maximum received rate local modem informs remote modem it will support based on initial negotiations. The remote modem will not attempt to transmit at rates greater than what the local modem will accept. The initial negotiated receive rate is in cctHistoryRxRate. ')
cctmHistoryProjectedMaxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 2), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryProjectedMaxTxRate.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryProjectedMaxTxRate.setDescription('Maximum rate the remote modem indicates it can accept based on initial negotiations. The local modem will not attempt to transmit at rates above what the remote modem will accept. The initial negotiated transmit rate is in cctHistoryTxRate. ')
cctmHistoryFinalRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 3), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryFinalRxRate.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryFinalRxRate.setDescription('Final receive data rate for this call. The initial negotiated receive rate is in cctHistoryRxRate. ')
cctmHistoryFinalTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 4), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryFinalTxRate.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryFinalTxRate.setDescription('Final transmit data rate for this call. The initial negotiated transmit rate is in cctHistoryTxRate. ')
cctmHistoryAttemptedModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 5), CctmModulation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryAttemptedModulation.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryAttemptedModulation.setDescription('The initial modulation attempted when the modems began negotiation. ')
cctmHistoryInitialModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 6), CctmModulation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryInitialModulation.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryInitialModulation.setDescription('The initial negotiated modulation. ')
cctmHistoryFinalModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 7), CctmModulation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryFinalModulation.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryFinalModulation.setDescription('The final modulation for this call. It is possible for retrains to result in the modulation being renogiated during a call. ')
cctmHistoryAttemptedECProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 8), CctmECProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryAttemptedECProtocol.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryAttemptedECProtocol.setDescription('The initial modem error correction protocol attempted during call negotiation. The actual EC negotiated is in cctmHistoryECProtocol. ')
cctmHistoryECProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 9), CctmECProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryECProtocol.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryECProtocol.setDescription('The modem error correction protocol negotiated for this call. ')
cctmHistorySupportedDC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 10), Bits().clone(namedValues=NamedValues(("mnp5", 0), ("v42bisRx", 1), ("v42bisTx", 2), ("v44Rx", 3), ("v44Tx", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistorySupportedDC.setStatus('current')
if mibBuilder.loadTexts: cctmHistorySupportedDC.setDescription('The data compression protocols supported by the calling modem. This object is a bit map, with each bit representing a different call type as identified below. A 1-bit indicates the DC protocol is supported. A 0-bit indicates the DC protocol is not supported. Bit 0 - MNP5 Bit 1 - V.42bis in the receive direction Bit 2 - V.42bis in the transmit direction V.42bis may be separately available in Rx or Tx directions. If all bits are zero, no data compression is supported. The particular compression selected by the answering modem is reported in cctmHistoryDataCompression. ')
cctmHistoryDataCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 11), CctmDataCompression()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryDataCompression.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryDataCompression.setDescription('The modem compression protocol selected for this call. ')
cctmHistoryRxHighWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 12), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxHighWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxHighWatermark.setDescription('The maximum receive data rate achieved during this call. ')
cctmHistoryRxLowWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 13), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxLowWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxLowWatermark.setDescription('The minimum receive data rate during this call. ')
cctmHistoryTxHighWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 14), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryTxHighWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryTxHighWatermark.setDescription('The maximum transmit data rate achieved during this call. ')
cctmHistoryTxLowWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 15), Gauge32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryTxLowWatermark.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryTxLowWatermark.setDescription('The minimum transmit data rate during this call. ')
cctmHistoryLocalUpRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryLocalUpRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryLocalUpRateShifts.setDescription('The count of locally initiated rate shifts to increase the data rate which were successful. ')
cctmHistoryLocalDownRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryLocalDownRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryLocalDownRateShifts.setDescription('The count of locally initiated rate shifts to decrease the data rate which were successful. ')
cctmHistoryRemoteUpRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRemoteUpRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRemoteUpRateShifts.setDescription('The count of remotely initiated rate shifts to increase the data rate which were successful. ')
cctmHistoryRemoteDownRateShifts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRemoteDownRateShifts.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRemoteDownRateShifts.setDescription('The count of remotely initiated rate shifts to decrease the data rate which were successful. ')
cctmHistoryRateShiftFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRateShiftFailures.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRateShiftFailures.setDescription('The count of rate shift attempts which failed to complete. A failure to complete a rate renegotiation results in a retrain attempt. ')
cctmHistoryLocalRetrains = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryLocalRetrains.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryLocalRetrains.setDescription('The count of locally initiated retrains for the call. Includes successfully completed retrains and those which failed. ')
cctmHistoryRemoteRetrains = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRemoteRetrains.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRemoteRetrains.setDescription('The count of remotely initiated retrains for the call. Includes successfully completed retrains and those which failed. ')
cctmHistoryRetrainFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRetrainFailures.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRetrainFailures.setDescription('The count of retrains which failed to complete. A failure to retrain results in another retrain attempt. The call will terminate if too many consecutive retrain failures occur. The consecutive retrain failure threshold is system specific. ')
cctmHistoryRxLinkOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxLinkOctets.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxLinkOctets.setDescription('The total modem link level octets received during this call. If using Error Correction and Data Compression, this is the compressed data within the EC protocol frames. ')
cctmHistoryTxLinkOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryTxLinkOctets.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryTxLinkOctets.setDescription('The total modem link level octets transmitted during this call. If using Error Correction and Data Compression, this is the compressed data within the EC protocol frames. ')
cctmHistoryRxECFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxECFrames.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxECFrames.setDescription('The total number of error correction data frames received successfully. This does not include damaged frames or control frames. ')
cctmHistoryTxECFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryTxECFrames.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryTxECFrames.setDescription('The total number of error correction data frames transmitted successfully. This does not include data frame resends or control frames. ')
cctmHistoryRxECNAKs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxECNAKs.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxECNAKs.setDescription('The total number of EC protocol negative acknowledgements (NAK) received. ')
cctmHistoryTxECNAKs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryTxECNAKs.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryTxECNAKs.setDescription('The total number of EC protocol negative acknowledgements (NAK) sent. ')
cctmHistoryRxECFramesBad = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxECFramesBad.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxECFramesBad.setDescription('The total error correction frames received during the call which were determined to be bad. ')
cctmHistoryECFramesResent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryECFramesResent.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryECFramesResent.setDescription('The count of total retransmitted error correction data frames during the call. ')
cctmHistoryECLinkTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryECLinkTimeouts.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryECLinkTimeouts.setDescription("This counter provides the number of EC link protocol timer expirations which have occurred during the call. This corresponds to the T401 timer for LAPM and MNP. These are distinct from normal 'keep alive' and 'window open' timeouts. ")
cctmHistoryRxCharLost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryRxCharLost.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryRxCharLost.setDescription('The total number of characters received by the modem but were dropped due to host buffer over run. ')
cctmHistoryDisconnectReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 34), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryDisconnectReason.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryDisconnectReason.setDescription('Code indicating the reason this call was terminated. ')
cctmHistoryDisconnectReasonText = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 1, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmHistoryDisconnectReasonText.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryDisconnectReasonText.setDescription('Text description of the disconnect reason indicated by cctHistoryDisconnectReason. Value is zero-length string if no text is available. ')
cctmXHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2), )
if mibBuilder.loadTexts: cctmXHistoryTable.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryTable.setDescription('This table provides additional, detailed information on terminated modem calls. It contains low level modem session attributes and statistics at the modem link and modem protocol layers. The table extends the cctHistoryTable, using the same index, cctHistoryIndex. ')
cctmXHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1), )
cctmHistoryEntry.registerAugmentions(("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryEntry"))
cctmXHistoryEntry.setIndexNames(*cctmHistoryEntry.getIndexNames())
if mibBuilder.loadTexts: cctmXHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryEntry.setDescription('The detailed information for a single terminated modem call. Entries are created and deleted in sync with the entries in cctHistoryTable, if the call utilized modem service. ')
cctmXHistoryRxECInfoFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 1), Unsigned32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryRxECInfoFrameSize.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryRxECInfoFrameSize.setDescription('Negotiated maximum EC frame data payload size in the receive direction. LAPM distinguishes between Rx and Tx. MNP will have the the same information frame size for Rx and Tx, cctmHistoryTxECInfoFrameSize. ')
cctmXHistoryTxECInfoFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 2), Unsigned32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryTxECInfoFrameSize.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryTxECInfoFrameSize.setDescription('Negotiated maximum EC frame data payload size in the transmit direction. LAPM distinguishes between Rx and Tx. MNP will have the the same information frame size for Tx and Rx, cctmHistoryRxECInfoFrameSize. ')
cctmXHistoryRxECWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 3), Unsigned32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryRxECWindowSize.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryRxECWindowSize.setDescription('The EC protocol window size in units of frames in the receive direction. This is the maximum number of information frames sent from remote modem that may be outstanding without receiving any acknowledgement from the local modem. If the EC protocol is LAPM, the Rx and Tx windows are separately negotiated and may have different values. If MNP, both windows are negotiated together and have the same value for this object and cctHistoryTxECWindowSize. ')
cctmXHistoryTxECWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 4), Unsigned32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryTxECWindowSize.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryTxECWindowSize.setDescription('The EC protocol window size in units of frames in the transmit direction. This is the maximum number of information frames sent from local modem that may be outstanding without receiving any acknowledgement from the remote modem. If the EC protocol is LAPM, the Rx and Tx windows are separately negotiated and may have different values. If MNP, both windows are negotiated together and have the same value for this object and cctHistoryRxECWindowSize. ')
cctmXHistoryRxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 0))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryRxLevel.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryRxLevel.setDescription('The final signal level in the receive direction for applicable modulations. ')
cctmXHistoryTxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 0))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryTxLevel.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryTxLevel.setDescription('The final signal level in the transmit direction for applicable modulations. ')
cctmXHistoryConstellation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("points4", 1), ("points16", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryConstellation.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryConstellation.setDescription('Connection constellation size. ')
cctmXHistoryV90Status = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notAttempted", 1), ("failure", 2), ("success", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryV90Status.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryV90Status.setDescription('This object indicates if V.90 modulation was attempted during initial modem negotiation. notAttempted(1) - Client modem did not attempt V.90 failure(2) - Client and server modems attempted V.90, but were not successful success(3) - Client and server modems successfully negotiated V.90 during call setup. ')
cctmXHistoryV90Failure = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noFailure", 1), ("clientNonPCM", 2), ("clientFallback", 3), ("serverV90Disabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryV90Failure.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryV90Failure.setDescription('This object provides an interpretation of why V.90 modulation was not achieved. noFailure(1) - V.90 was not attempted or it was successful. The value of cctmXHistoryV90Status will be notAttempted(1) or success(3) respectively. clientNonPCM(2) - Client selected a non-PCM connection due to PSTN properties. clientFallback(3) - Client was unable to sustain PCM due to PSTN properties and fellback to a non-PCM connection. serverV90Disabled(4) - Client attempted V.90 but server modem was configured to disable V.90. ')
cctmXHistoryV90ClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryV90ClientId.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryV90ClientId.setDescription('Client modem identification inferred from the V.90 DIL training and sign patterns. ')
cctmXHistoryECWindowClosures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 165, 1, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctmXHistoryECWindowClosures.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryECWindowClosures.setDescription('The number of times the EC protocol window closed without receiving an ACK or NAK from the remote modem. A closure occurs when the maximum number of EC information frames have been sent without receiving any acknowledgement. The window size is provided in cctmHistoryRxECWindowSize. ')
cctmMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 2))
cctmMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 2, 0))
cctmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 3))
cctmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 3, 1))
cctmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 165, 3, 2))
cctmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 165, 3, 1, 1)).setObjects(("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveGroup"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryGroup"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctmMIBCompliance = cctmMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cctmMIBCompliance.setDescription('The compliance statement for entities which implement the CISCO CALL TRACKER MODEM MIB')
cctmActiveGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 165, 3, 2, 2)).setObjects(("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveProjectedMaxRxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveProjectedMaxTxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveTxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveAttemptedModulation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveInitialModulation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveModulation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveAttemptedECProtocol"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveECProtocol"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveSupportedDC"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveDataCompression"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxHighWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxLowWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveTxHighWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveTxLowWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveLocalUpRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRemoteUpRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveLocalDownRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRemoteDownRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRateShiftFailures"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveLocalRetrains"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRemoteRetrains"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRetrainFailures"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxLinkOctets"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveTxLinkOctets"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxECFrames"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveTxECFrames"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxECNAKs"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveTxECNAKs"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxECFramesBad"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveECFramesResent"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveECLinkTimeouts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmActiveRxCharLost"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctmActiveGroup = cctmActiveGroup.setStatus('current')
if mibBuilder.loadTexts: cctmActiveGroup.setDescription('A collection of objects providing the active call modem information. ')
cctmHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 165, 3, 2, 3)).setObjects(("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryProjectedMaxRxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryProjectedMaxTxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryFinalRxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryFinalTxRate"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryAttemptedModulation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryInitialModulation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryFinalModulation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryAttemptedECProtocol"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryECProtocol"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistorySupportedDC"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryDataCompression"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxHighWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxLowWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryTxHighWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryTxLowWatermark"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryLocalUpRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRemoteUpRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryLocalDownRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRemoteDownRateShifts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRateShiftFailures"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryLocalRetrains"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRemoteRetrains"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRetrainFailures"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxLinkOctets"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryTxLinkOctets"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxECFrames"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryTxECFrames"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxECNAKs"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryTxECNAKs"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxECFramesBad"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryECFramesResent"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryECLinkTimeouts"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryRxCharLost"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryDisconnectReason"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmHistoryDisconnectReasonText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctmHistoryGroup = cctmHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: cctmHistoryGroup.setDescription('A collection of objects providing the historical call modem information. ')
cctmXHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 165, 3, 2, 4)).setObjects(("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryRxECInfoFrameSize"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryTxECInfoFrameSize"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryRxECWindowSize"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryTxECWindowSize"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryRxLevel"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryTxLevel"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryConstellation"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryV90Status"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryV90Failure"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryV90ClientId"), ("CISCO-CALL-TRACKER-MODEM-MIB", "cctmXHistoryECWindowClosures"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctmXHistoryGroup = cctmXHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: cctmXHistoryGroup.setDescription('A collection of objects providing the historical detailed call modem information. ')
mibBuilder.exportSymbols("CISCO-CALL-TRACKER-MODEM-MIB", cctmMIBObjects=cctmMIBObjects, cctmHistoryTxECNAKs=cctmHistoryTxECNAKs, cctmHistoryRateShiftFailures=cctmHistoryRateShiftFailures, cctmActiveECFramesResent=cctmActiveECFramesResent, cctmActiveECLinkTimeouts=cctmActiveECLinkTimeouts, cctmActiveDataCompression=cctmActiveDataCompression, cctmMIBCompliance=cctmMIBCompliance, cctmActiveGroup=cctmActiveGroup, cctmXHistoryECWindowClosures=cctmXHistoryECWindowClosures, cctmActiveRemoteUpRateShifts=cctmActiveRemoteUpRateShifts, cctmActiveRxECFrames=cctmActiveRxECFrames, cctmActiveRxCharLost=cctmActiveRxCharLost, cctmMIBCompliances=cctmMIBCompliances, cctmActiveRemoteRetrains=cctmActiveRemoteRetrains, cctmXHistoryTable=cctmXHistoryTable, cctmHistoryTxECFrames=cctmHistoryTxECFrames, cctmActiveTxRate=cctmActiveTxRate, cctmHistoryTxLowWatermark=cctmHistoryTxLowWatermark, cctmActiveECProtocol=cctmActiveECProtocol, cctmXHistoryRxECInfoFrameSize=cctmXHistoryRxECInfoFrameSize, cctmHistoryECLinkTimeouts=cctmHistoryECLinkTimeouts, cctmXHistoryV90ClientId=cctmXHistoryV90ClientId, cctmHistoryRxHighWatermark=cctmHistoryRxHighWatermark, cctmHistoryRxECFrames=cctmHistoryRxECFrames, cctmActiveSupportedDC=cctmActiveSupportedDC, cctmHistoryFinalRxRate=cctmHistoryFinalRxRate, cctmActiveAttemptedECProtocol=cctmActiveAttemptedECProtocol, cctmActiveRxECNAKs=cctmActiveRxECNAKs, cctmActiveTxHighWatermark=cctmActiveTxHighWatermark, cctmHistoryLocalRetrains=cctmHistoryLocalRetrains, cctmActiveTxLinkOctets=cctmActiveTxLinkOctets, cctmHistoryEntry=cctmHistoryEntry, cctmXHistoryTxECWindowSize=cctmXHistoryTxECWindowSize, cctmMIBGroups=cctmMIBGroups, cctmActiveProjectedMaxRxRate=cctmActiveProjectedMaxRxRate, ciscoCallTrackerModemMIB=ciscoCallTrackerModemMIB, cctmActiveLocalUpRateShifts=cctmActiveLocalUpRateShifts, cctmActiveRxHighWatermark=cctmActiveRxHighWatermark, cctmActiveRxECFramesBad=cctmActiveRxECFramesBad, cctmActiveProjectedMaxTxRate=cctmActiveProjectedMaxTxRate, cctmActiveLocalRetrains=cctmActiveLocalRetrains, cctmHistoryRetrainFailures=cctmHistoryRetrainFailures, cctmHistoryRxCharLost=cctmHistoryRxCharLost, cctmActiveTxLowWatermark=cctmActiveTxLowWatermark, PYSNMP_MODULE_ID=ciscoCallTrackerModemMIB, cctmMIBConformance=cctmMIBConformance, cctmActiveTxECFrames=cctmActiveTxECFrames, cctmHistory=cctmHistory, cctmActiveTable=cctmActiveTable, cctmHistoryFinalModulation=cctmHistoryFinalModulation, cctmHistoryRxLowWatermark=cctmHistoryRxLowWatermark, cctmXHistoryGroup=cctmXHistoryGroup, cctmHistoryFinalTxRate=cctmHistoryFinalTxRate, cctmHistoryRxECFramesBad=cctmHistoryRxECFramesBad, cctmHistoryLocalDownRateShifts=cctmHistoryLocalDownRateShifts, cctmHistoryRemoteDownRateShifts=cctmHistoryRemoteDownRateShifts, cctmHistoryDisconnectReasonText=cctmHistoryDisconnectReasonText, cctmMIBNotificationPrefix=cctmMIBNotificationPrefix, cctmActiveTxECNAKs=cctmActiveTxECNAKs, cctmXHistoryV90Status=cctmXHistoryV90Status, cctmActiveLocalDownRateShifts=cctmActiveLocalDownRateShifts, cctmHistoryTxHighWatermark=cctmHistoryTxHighWatermark, CctmECProtocol=CctmECProtocol, cctmActiveRemoteDownRateShifts=cctmActiveRemoteDownRateShifts, cctmHistoryLocalUpRateShifts=cctmHistoryLocalUpRateShifts, cctmActiveRxLowWatermark=cctmActiveRxLowWatermark, cctmHistoryRemoteUpRateShifts=cctmHistoryRemoteUpRateShifts, cctmActiveEntry=cctmActiveEntry, cctmXHistoryEntry=cctmXHistoryEntry, cctmHistoryGroup=cctmHistoryGroup, cctmXHistoryConstellation=cctmXHistoryConstellation, cctmActiveAttemptedModulation=cctmActiveAttemptedModulation, cctmHistoryRemoteRetrains=cctmHistoryRemoteRetrains, cctmActiveRxLinkOctets=cctmActiveRxLinkOctets, cctmXHistoryTxECInfoFrameSize=cctmXHistoryTxECInfoFrameSize, cctmXHistoryTxLevel=cctmXHistoryTxLevel, cctmXHistoryRxECWindowSize=cctmXHistoryRxECWindowSize, cctmActiveRxRate=cctmActiveRxRate, cctmXHistoryV90Failure=cctmXHistoryV90Failure, cctmXHistoryRxLevel=cctmXHistoryRxLevel, cctmHistoryDisconnectReason=cctmHistoryDisconnectReason, cctmHistoryDataCompression=cctmHistoryDataCompression, cctmMIBNotifications=cctmMIBNotifications, CctmDataCompression=CctmDataCompression, cctmHistoryECProtocol=cctmHistoryECProtocol, cctmHistorySupportedDC=cctmHistorySupportedDC, cctmHistoryTxLinkOctets=cctmHistoryTxLinkOctets, cctmHistoryRxECNAKs=cctmHistoryRxECNAKs, cctmActiveModulation=cctmActiveModulation, cctmHistoryTable=cctmHistoryTable, cctmActiveInitialModulation=cctmActiveInitialModulation, cctmHistoryECFramesResent=cctmHistoryECFramesResent, cctmActiveRateShiftFailures=cctmActiveRateShiftFailures, cctmHistoryRxLinkOctets=cctmHistoryRxLinkOctets, cctmActive=cctmActive, CctmModulation=CctmModulation, cctmHistoryProjectedMaxRxRate=cctmHistoryProjectedMaxRxRate, cctmHistoryInitialModulation=cctmHistoryInitialModulation, cctmHistoryAttemptedECProtocol=cctmHistoryAttemptedECProtocol, cctmHistoryAttemptedModulation=cctmHistoryAttemptedModulation, cctmActiveRetrainFailures=cctmActiveRetrainFailures, cctmHistoryProjectedMaxTxRate=cctmHistoryProjectedMaxTxRate)

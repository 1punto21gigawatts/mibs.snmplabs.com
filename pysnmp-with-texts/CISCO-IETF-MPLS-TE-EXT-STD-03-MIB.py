#
# PySNMP MIB module CISCO-IETF-MPLS-TE-EXT-STD-03-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IETF-MPLS-TE-EXT-STD-03-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
CMplsLocalId, CMplsGlobalId, CMplsIccId, CMplsNodeId = mibBuilder.importSymbols("CISCO-MPLS-TC-EXT-STD-MIB", "CMplsLocalId", "CMplsGlobalId", "CMplsIccId", "CMplsNodeId")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
MplsTunnelIndex, mplsStdMIB, MplsTunnelInstanceIndex = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsTunnelIndex", "mplsStdMIB", "MplsTunnelInstanceIndex")
mplsTunnelIngressLSRId, mplsTunnelIndex, mplsTunnelEgressLSRId, mplsTunnelInstance = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId", "mplsTunnelIndex", "mplsTunnelEgressLSRId", "mplsTunnelInstance")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, IpAddress, Unsigned32, MibIdentifier, ModuleIdentity, NotificationType, TimeTicks, Counter32, Counter64, zeroDotZero, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "Unsigned32", "MibIdentifier", "ModuleIdentity", "NotificationType", "TimeTicks", "Counter32", "Counter64", "zeroDotZero", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "iso")
DisplayString, RowPointer, StorageType, TextualConvention, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowPointer", "StorageType", "TextualConvention", "TruthValue", "RowStatus")
cmplsTeExtStdMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 146))
cmplsTeExtStdMIB.setRevisions(('2012-04-08 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cmplsTeExtStdMIB.setRevisionsDescriptions(('MPLS TE mib objects extension',))
if mibBuilder.loadTexts: cmplsTeExtStdMIB.setLastUpdated('201206060000Z')
if mibBuilder.loadTexts: cmplsTeExtStdMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: cmplsTeExtStdMIB.setContactInfo('Venkatesan Mahalingam Dell Inc, 350 Holger way, San Jose, CA, USA Email: venkat.mahalingams@gmail.com Kannan KV Sampath Aricent, India Email: Kannan.Sampath@aricent.com Sam Aldrin Huawei Technologies 2330 Central Express Way, Santa Clara, CA 95051, USA Email: aldrin.ietf@gmail.com Thomas D. Nadeau Juniper Networks 10 Technology Park Drive, Westford, MA 01886 Email: tnadeau@juniper.net')
if mibBuilder.loadTexts: cmplsTeExtStdMIB.setDescription('Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved. This MIB module contains generic object definitions for MPLS Traffic Engineering in transport networks.This module is a cisco-ized version of the IETF draft: draft-ietf-mpls-tp-te-mib-03')
cmplsTeExtNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 146, 0))
cmplsTeExtObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 146, 1))
cmplsTeExtConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 146, 2))
cmplsNodeConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1), )
if mibBuilder.loadTexts: cmplsNodeConfigTable.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigTable.setDescription("This table allows the administrator to map a node or LSR Identifier (IP compatible [Global_Node_ID] or ICC) with a local identifier. This table is created to reuse the existing mplsTunnelTable for MPLS based transport network tunnels also. Since the MPLS tunnel's Ingress/Egress LSR identifiers' size (Unsigned32) value is not compatible for MPLS-TP tunnel i.e. Global_Node_Id of size 8 bytes and ICC of size 6 bytes, there exists a need to map the Global_Node_ID or ICC with the local identifier of size 4 bytes (Unsigned32) value in order to index (Ingress/Egress LSR identifier) the existing mplsTunnelTable.")
cmplsNodeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1), ).setIndexNames((0, "CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigLocalId"))
if mibBuilder.loadTexts: cmplsNodeConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigEntry.setDescription('An entry in this table represents a mapping identification for the operator or service provider with node or LSR. As per [RFC6370], this mapping is represented as Global_Node_ID or ICC. Note: Each entry in this table should have a unique Global_ID and Node_ID combination.')
cmplsNodeConfigLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1, 1), CMplsLocalId())
if mibBuilder.loadTexts: cmplsNodeConfigLocalId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigLocalId.setDescription('This object allows the administrator to assign a unique local identifier to map Global_Node_ID or ICC.')
cmplsNodeConfigGlobalId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1, 2), CMplsGlobalId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmplsNodeConfigGlobalId.setReference('MPLS-TP Identifiers [RFC6370].')
if mibBuilder.loadTexts: cmplsNodeConfigGlobalId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigGlobalId.setDescription('This object indicates the Global Operator Identifier. This object value should be zero when mplsNodeConfigIccId is configured with non-null value.')
cmplsNodeConfigNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1, 3), CMplsNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmplsNodeConfigNodeId.setReference('MPLS-TP Identifiers [RFC6370].')
if mibBuilder.loadTexts: cmplsNodeConfigNodeId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigNodeId.setDescription('This object indicates the Node_ID within the operator. This object value should be zero when mplsNodeConfigIccId is configured with non-null value.')
cmplsNodeConfigIccId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1, 4), CMplsIccId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmplsNodeConfigIccId.setReference('MPLS-TP Identifiers [RFC6370].')
if mibBuilder.loadTexts: cmplsNodeConfigIccId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigIccId.setDescription('This object allows the operator or service provider to configure a unique MPLS-TP ITU-T Carrier Code (ICC) either for Ingress ID or Egress ID. This object value should be zero when mplsNodeConfigGlobalId and mplsNodeConfigNodeId are assigned with non-zero value.')
cmplsNodeConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmplsNodeConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigRowStatus.setDescription('This object allows the administrator to create, modify, and/or delete a row in this table.')
cmplsNodeConfigStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 1, 1, 6), StorageType().clone('volatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmplsNodeConfigStorageType.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeConfigStorageType.setDescription("This variable indicates the storage type for this object. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
cmplsNodeIpMapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 2), )
if mibBuilder.loadTexts: cmplsNodeIpMapTable.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIpMapTable.setDescription('This read-only table allows the administrator to retrieve the local identifier for a given Global_Node_ID in an IP compatible operator environment. This table MAY be used in on-demand and/or proactive OAM operations to get the Ingress/Egress LSR identifier (Local Identifier) from Src-Global_Node_ID or Dst-Global_Node_ID and the Ingress and Egress LSR identifiers are used to retrieve the tunnel entry. This table returns nothing when the associated entry is not defined in mplsNodeConfigTable.')
cmplsNodeIpMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 2, 1), ).setIndexNames((0, "CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeIpMapGlobalId"), (0, "CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeIpMapNodeId"))
if mibBuilder.loadTexts: cmplsNodeIpMapEntry.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIpMapEntry.setDescription('An entry in this table represents a mapping of Global_Node_ID with the local identifier. An entry in this table is created automatically when the Local identifier is associated with Global_ID and Node_Id in the mplsNodeConfigTable. Note: Each entry in this table should have a unique Global_ID and Node_ID combination.')
cmplsNodeIpMapGlobalId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 2, 1, 1), CMplsGlobalId())
if mibBuilder.loadTexts: cmplsNodeIpMapGlobalId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIpMapGlobalId.setDescription('This object indicates the Global_ID.')
cmplsNodeIpMapNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 2, 1, 2), CMplsNodeId())
if mibBuilder.loadTexts: cmplsNodeIpMapNodeId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIpMapNodeId.setDescription('This object indicates the Node_ID within the operator.')
cmplsNodeIpMapLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 2, 1, 3), CMplsLocalId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsNodeIpMapLocalId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIpMapLocalId.setDescription('This object contains an IP compatible local identifier which is defined in mplsNodeConfigTable.')
cmplsNodeIccMapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 3), )
if mibBuilder.loadTexts: cmplsNodeIccMapTable.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIccMapTable.setDescription('This read-only table allows the administrator to retrieve the local identifier for a given ICC operator in an ICC operator environment. This table MAY be used in on-demand and/or proactive OAM operations to get the Ingress/Egress LSR identifier (Local Identifier) from Src-ICC or Dst-ICC and the Ingress and Egress LSR identifiers are used to retrieve the tunnel entry. This table returns nothing when the associated entry is not defined in mplsNodeConfigTable.')
cmplsNodeIccMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 3, 1), ).setIndexNames((0, "CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeIccMapIccId"))
if mibBuilder.loadTexts: cmplsNodeIccMapEntry.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIccMapEntry.setDescription('An entry in this table represents a mapping of ICC with the local identifier. An entry in this table is created automatically when the Local identifier is associated with ICC in the mplsNodeConfigTable.')
cmplsNodeIccMapIccId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 3, 1, 1), CMplsIccId())
if mibBuilder.loadTexts: cmplsNodeIccMapIccId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIccMapIccId.setDescription('This object allows the operator or service provider to configure a unique MPLS-TP ITU-T Carrier Code (ICC) either for Ingress or Egress LSR ID. The ICC is a string of one to six characters, each character being either alphabetic (i.e. A-Z) or numeric (i.e. 0-9) characters. Alphabetic characters in the ICC should be represented with upper case letters.')
cmplsNodeIccMapLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 3, 1, 2), CMplsLocalId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsNodeIccMapLocalId.setStatus('current')
if mibBuilder.loadTexts: cmplsNodeIccMapLocalId.setDescription('This object contains an ICC based local identifier which is defined in mplsNodeConfigTable.')
cmplsTunnelExtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4), )
if mibBuilder.loadTexts: cmplsTunnelExtTable.setReference('MPLS-TP Identifiers [RFC6370].')
if mibBuilder.loadTexts: cmplsTunnelExtTable.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtTable.setDescription('This table represents MPLS-TP specific extensions to mplsTunnelTable. As per MPLS-TP Identifiers [RFC6370], LSP_ID for IP based co-routed bidirectional tunnel, A1-{Global_ID::Node_ID::Tunnel_Num}::Z9-{Global_ID:: Node_ID::Tunnel_Num}::LSP_Num LSP_ID for IP based associated bidirectional tunnel, A1-{Global_ID::Node_ID::Tunnel_Num::LSP_Num}:: Z9-{Global_ID::Node_ID::Tunnel_Num::LSP_Num} mplsTunnelTable is reused for forming the LSP_ID as follows, Source Tunnel_Num is mapped with mplsTunnelIndex, Source Node_ID is mapped with mplsTunnelIngressLSRId, Destination Node_ID is mapped with mplsTunnelEgressLSRId LSP_Num is mapped with mplsTunnelInstance. Source Global_Node_ID and/or ICC and Destination Global_Node_ID and/or ICC are maintained in the mplsNodeConfigTable and mplsNodeConfigLocalId is used to create an entry in mplsTunnelTable.')
cmplsTunnelExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: cmplsTunnelExtEntry.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtEntry.setDescription('An entry in this table represents MPLS-TP specific additional tunnel configurations.')
cmplsTunnelOppositeDirPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4, 1, 1), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmplsTunnelOppositeDirPtr.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelOppositeDirPtr.setDescription('This object is applicable only for the bidirectional tunnel that has the forward and reverse LSPs in the same tunnel or in the different tunnels. This object holds the opposite direction tunnel entry if the bidirectional tunnel is setup by configuring two tunnel entries in mplsTunnelTable. The value of zeroDotZero indicates single tunnel entry is used for bidirectional tunnel setup.')
cmplsTunnelExtOppositeDirTnlValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmplsTunnelExtOppositeDirTnlValid.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtOppositeDirTnlValid.setDescription('Denotes whether or not this tunnel uses mplsTunnelOppositeDirPtr for identifying the opposite direction tunnel information. Note that if this variable is set to true then the mplsTunnelOppositeDirPtr should point to the first accessible row of the opposite direction tunnel.')
cmplsTunnelExtDestTnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4, 1, 3), MplsTunnelIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmplsTunnelExtDestTnlIndex.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtDestTnlIndex.setDescription("This object is applicable only for the bidirectional tunnel that has the forward and reverse LSPs in the same tunnel or in the different tunnels. This object holds the same value as that of the mplsTunnelIndex of mplsTunnelEntry if the forward and reverse LSPs are in the same tunnel. Otherwise, this object holds the value of the other direction associated LSP's mplsTunnelIndex from a different tunnel. The values of this object and the mplsTunnelExtDestTnlLspIndex object together can be used to identify an opposite direction LSP i.e. if the mplsTunnelIndex and mplsTunnelInstance hold the value for forward LSP, this object and mplsTunnelExtDestTnlLspIndex can be used to retrieve the reverse direction LSP and vice versa. This object and mplsTunnelExtDestTnlLspIndex values provide the first two indices of tunnel entry and the remaining indices can be derived as follows, if both the forward and reverse LSPs are present in the same tunnel, the opposite direction LSP's Ingress and Egress Identifier will be same for both the LSPs, else the Ingress and Egress Identifiers should be swapped in order to index the other direction tunnel.")
cmplsTunnelExtDestTnlLspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4, 1, 4), MplsTunnelInstanceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmplsTunnelExtDestTnlLspIndex.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtDestTnlLspIndex.setDescription('This object is applicable only for the bidirectional tunnel that has the forward and reverse LSPs in the same tunnel or in the different tunnels. This object should contain different value if both the forward and reverse LSPs present in the same tunnel. This object can contain same value or different values if the forward and reverse LSPs present in the different tunnels.')
cmplsTunnelExtDestTnlValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 4, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmplsTunnelExtDestTnlValid.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtDestTnlValid.setDescription('Denotes whether or not this tunnel uses mplsTunnelExtDestTnlIndex and mplsTunnelExtDestTnlLspIndex for identifying the opposite direction tunnel information. Note that if this variable is set to true then the mplsTunnelExtDestTnlIndex and mplsTunnelExtDestTnlLspIndex objects should have the valid opposite direction tunnel indices.')
cmplsTunnelReversePerfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5), )
if mibBuilder.loadTexts: cmplsTunnelReversePerfTable.setReference('1. Multiprotocol Label Switching (MPLS) Traffic Engineering (TE)Management Information Base (MIB), RFC 3812.')
if mibBuilder.loadTexts: cmplsTunnelReversePerfTable.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfTable.setDescription('This table extends the mplsTunnelTable to provide per-tunnel packet performance information for the reverse direction of a bidirectional tunnel. It can be seen as supplementing the mplsTunnelPerfTable, which augments the mplsTunnelTable. For links that do not transport packets, these packet counters cannot be maintained. For such links, attempts to read the objects in this table will return noSuchInstance.')
cmplsTunnelReversePerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: cmplsTunnelReversePerfEntry.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfEntry.setDescription('An entry in this table is created by the LSR for every bidirectional MPLS tunnel where packets are visible to the LSR.')
cmplsTunnelReversePerfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsTunnelReversePerfPackets.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfPackets.setDescription('Number of packets forwarded on the tunnel in the reverse direction if it is bidirectional. This object represents the 32-bit value of the least significant part of the 64-bit value if both mplsTunnelReversePerfHCPackets and this object are returned. For links that do not transport packets, this packet counter cannot be maintained. For such links, this value will return noSuchInstance.')
cmplsTunnelReversePerfHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsTunnelReversePerfHCPackets.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfHCPackets.setDescription('High-capacity counter for number of packets forwarded on the tunnel in the reverse direction if it is bidirectional. For links that do not transport packets, this packet counter cannot be maintained. For such links, this value will return noSuchInstance.')
cmplsTunnelReversePerfErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsTunnelReversePerfErrors.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfErrors.setDescription('Number of errored packets received on the tunnel in the reverse direction if it is bidirectional. For links that do not transport packets, this packet counter cannot be maintained. For such links, this value will return noSuchInstance.')
cmplsTunnelReversePerfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsTunnelReversePerfBytes.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfBytes.setDescription('Number of bytes forwarded on the tunnel in the reverse direction if it is bidirectional. This object represents the 32-bit value of the least significant part of the 64-bit value if both mplsTunnelReversePerfHCBytes and this object are returned. For links that do not transport packets, this packet counter cannot be maintained. For such links, this value will return noSuchInstance.')
cmplsTunnelReversePerfHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 146, 1, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmplsTunnelReversePerfHCBytes.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelReversePerfHCBytes.setDescription('High-capacity counter for number of bytes forwarded on the tunnel in the reverse direction if it is bidirectional. For links that do not transport packets, this packet counter cannot be maintained. For such links, this value will return noSuchInstance.')
cmplsTeExtGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 1))
cmplsTeExtCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 2))
cmplsTeExtModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 2, 1)).setObjects(("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtGroup"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtIpOperatorGroup"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtIccOperatorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmplsTeExtModuleFullCompliance = cmplsTeExtModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: cmplsTeExtModuleFullCompliance.setDescription('Compliance statement for agents that provide full support the MPLS-TE-EXT-STD-MIB module.')
cmplsTeExtModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 2, 2)).setObjects(("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtGroup"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtIpOperatorGroup"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtIccOperatorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmplsTeExtModuleReadOnlyCompliance = cmplsTeExtModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: cmplsTeExtModuleReadOnlyCompliance.setDescription('Compliance statement for agents that provide full support the MPLS-TE-EXT-STD-MIB module.')
cmplsTunnelExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 1, 1)).setObjects(("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelOppositeDirPtr"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtOppositeDirTnlValid"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtDestTnlIndex"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtDestTnlLspIndex"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelExtDestTnlValid"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelReversePerfPackets"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelReversePerfHCPackets"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelReversePerfErrors"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelReversePerfBytes"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsTunnelReversePerfHCBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmplsTunnelExtGroup = cmplsTunnelExtGroup.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtGroup.setDescription('Necessary, but not sufficient, set of objects to implement tunnels. In addition, depending on the operating environment, the following groups are mandatory.')
cmplsTunnelExtIpOperatorGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 1, 2)).setObjects(("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigGlobalId"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigNodeId"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigRowStatus"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigStorageType"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeIpMapLocalId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmplsTunnelExtIpOperatorGroup = cmplsTunnelExtIpOperatorGroup.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtIpOperatorGroup.setDescription('Object(s) needed to implement IP compatible tunnels.')
cmplsTunnelExtIccOperatorGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 146, 2, 1, 3)).setObjects(("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigIccId"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigRowStatus"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeConfigStorageType"), ("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", "cmplsNodeIccMapLocalId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmplsTunnelExtIccOperatorGroup = cmplsTunnelExtIccOperatorGroup.setStatus('current')
if mibBuilder.loadTexts: cmplsTunnelExtIccOperatorGroup.setDescription('Object(s) needed to implement ICC based tunnels.')
mibBuilder.exportSymbols("CISCO-IETF-MPLS-TE-EXT-STD-03-MIB", cmplsTunnelReversePerfBytes=cmplsTunnelReversePerfBytes, cmplsTunnelExtDestTnlIndex=cmplsTunnelExtDestTnlIndex, cmplsNodeIccMapIccId=cmplsNodeIccMapIccId, cmplsTunnelExtEntry=cmplsTunnelExtEntry, cmplsNodeConfigIccId=cmplsNodeConfigIccId, cmplsTunnelReversePerfTable=cmplsTunnelReversePerfTable, cmplsTeExtModuleReadOnlyCompliance=cmplsTeExtModuleReadOnlyCompliance, cmplsTunnelReversePerfHCPackets=cmplsTunnelReversePerfHCPackets, cmplsTeExtModuleFullCompliance=cmplsTeExtModuleFullCompliance, cmplsTeExtCompliances=cmplsTeExtCompliances, cmplsTeExtNotifications=cmplsTeExtNotifications, cmplsNodeConfigEntry=cmplsNodeConfigEntry, cmplsTunnelExtDestTnlValid=cmplsTunnelExtDestTnlValid, cmplsTunnelReversePerfHCBytes=cmplsTunnelReversePerfHCBytes, cmplsNodeConfigNodeId=cmplsNodeConfigNodeId, cmplsNodeConfigLocalId=cmplsNodeConfigLocalId, cmplsTunnelReversePerfErrors=cmplsTunnelReversePerfErrors, cmplsNodeIpMapNodeId=cmplsNodeIpMapNodeId, cmplsTunnelReversePerfPackets=cmplsTunnelReversePerfPackets, cmplsNodeIpMapEntry=cmplsNodeIpMapEntry, cmplsTunnelOppositeDirPtr=cmplsTunnelOppositeDirPtr, cmplsTunnelReversePerfEntry=cmplsTunnelReversePerfEntry, cmplsTunnelExtTable=cmplsTunnelExtTable, cmplsNodeIccMapTable=cmplsNodeIccMapTable, cmplsNodeIccMapEntry=cmplsNodeIccMapEntry, cmplsTeExtGroups=cmplsTeExtGroups, cmplsTunnelExtDestTnlLspIndex=cmplsTunnelExtDestTnlLspIndex, cmplsNodeIpMapTable=cmplsNodeIpMapTable, cmplsTeExtObjects=cmplsTeExtObjects, cmplsNodeConfigGlobalId=cmplsNodeConfigGlobalId, cmplsTunnelExtOppositeDirTnlValid=cmplsTunnelExtOppositeDirTnlValid, cmplsNodeConfigRowStatus=cmplsNodeConfigRowStatus, cmplsNodeIpMapGlobalId=cmplsNodeIpMapGlobalId, PYSNMP_MODULE_ID=cmplsTeExtStdMIB, cmplsTeExtStdMIB=cmplsTeExtStdMIB, cmplsNodeIccMapLocalId=cmplsNodeIccMapLocalId, cmplsTunnelExtIpOperatorGroup=cmplsTunnelExtIpOperatorGroup, cmplsNodeIpMapLocalId=cmplsNodeIpMapLocalId, cmplsTunnelExtGroup=cmplsTunnelExtGroup, cmplsTunnelExtIccOperatorGroup=cmplsTunnelExtIccOperatorGroup, cmplsNodeConfigTable=cmplsNodeConfigTable, cmplsTeExtConformance=cmplsTeExtConformance, cmplsNodeConfigStorageType=cmplsNodeConfigStorageType)

#
# PySNMP MIB module MPLS-LSR-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-LSR-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndexOrZero, ifGeneralInformationGroup, ifCounterDiscontinuityGroup = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifGeneralInformationGroup", "ifCounterDiscontinuityGroup")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
MplsOwner, mplsStdMIB, MplsBitRate, MplsLabel, MplsLSPID = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsOwner", "mplsStdMIB", "MplsBitRate", "MplsLabel", "MplsLSPID")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter64, Gauge32, IpAddress, Counter32, Integer32, zeroDotZero, Bits, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ObjectIdentity, MibIdentifier, iso, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Gauge32", "IpAddress", "Counter32", "Integer32", "zeroDotZero", "Bits", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ObjectIdentity", "MibIdentifier", "iso", "TimeTicks", "NotificationType")
TextualConvention, TimeStamp, StorageType, TruthValue, DisplayString, RowPointer, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "StorageType", "TruthValue", "DisplayString", "RowPointer", "RowStatus")
mplsLsrStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 2))
mplsLsrStdMIB.setRevisions(('2004-06-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsLsrStdMIB.setRevisionsDescriptions(('Initial revision, published as part of RFC 3813.',))
if mibBuilder.loadTexts: mplsLsrStdMIB.setLastUpdated('200406030000Z')
if mibBuilder.loadTexts: mplsLsrStdMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsLsrStdMIB.setContactInfo(' Cheenu Srinivasan Bloomberg L.P. Email: cheenu@bloomberg.net Arun Viswanathan Force10 Networks, Inc. Email: arunv@force10networks.com Thomas D. Nadeau Cisco Systems, Inc. Email: tnadeau@cisco.com Comments about this document should be emailed directly to the MPLS working group mailing list at mpls@uu.net.')
if mibBuilder.loadTexts: mplsLsrStdMIB.setDescription('This MIB module contains managed object definitions for the Multiprotocol Label Switching (MPLS) Router as defined in: Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, RFC 3031, January 2001. Copyright (C) The Internet Society (2004). The initial version of this MIB module was published in RFC 3812. For full legal notices see the RFC itself or see: http://www.ietf.org/copyrights/ianamib.html')
class MplsIndexType(TextualConvention, OctetString):
    description = 'This is an octet string that can be used as a table index in cases where a large addressable space is required such as on an LSR where many applications may be provisioning labels. Note that the string containing the single octet with the value 0x00 is a reserved value used to represent special cases. When this TEXTUAL-CONVENTION is used as the SYNTAX of an object, the DESCRIPTION clause MUST specify if this special value is valid and if so what the special meaning is. In systems that provide write access to the MPLS-LSR-STD MIB, mplsIndexType SHOULD be used as a simple multi-digit integer encoded as an octet string. No further overloading of the meaning of an index SHOULD be made. In systems that do not offer write access to the MPLS-LSR-STD MIB, the mplsIndexType may contain implicit formatting that is specific to the implementation to convey additional information such as interface index, physical card or device, or application id. The interpretation of this additional formatting is implementation dependent and not covered in this document. Such formatting MUST NOT impact the basic functionality of read-only access to the MPLS-LSR-STD MIB by management applications that are not aware of the formatting rules.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 24)

class MplsIndexNextType(TextualConvention, OctetString):
    description = 'When a MIB module is used for configuration, an object with this SYNTAX always contains a legal value (a non-zero-length string) for an index that is not currently used in the relevant table. The Command Generator (Network Management Application) reads this variable and uses the (non-zero-length string) value read when creating a new row with an SNMP SET. When the SET is performed, the Command Responder (agent) must determine whether the value is indeed still unused; Two Network Management Applications may attempt to create a row (configuration entry) simultaneously and use the same value. If it is currently unused, the SET succeeds and the Command Responder (agent) changes the value of this object, according to an implementation-specific algorithm. If the value is in use, however, the SET fails. The Network Management Application must then re-read this variable to obtain a new usable value. Note that the string containing the single octet with the value 0x00 is a reserved value used to represent the special case where no additional indexes can be provisioned, or in systems that do not offer write access, objects defined using this TEXTUAL-CONVENTION MUST return the string containing the single octet with the value 0x00.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 24)

mplsLsrNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 2, 0))
mplsLsrObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 2, 1))
mplsLsrConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 2, 2))
mplsInterfaceTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1), )
if mibBuilder.loadTexts: mplsInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceTable.setDescription('This table specifies per-interface MPLS capability and associated information.')
mplsInterfaceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsInterfaceIndex"))
if mibBuilder.loadTexts: mplsInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceEntry.setDescription('A conceptual row in this table is created automatically by an LSR for every interface capable of supporting MPLS and which is configured to do so. A conceptual row in this table will exist if and only if a corresponding entry in ifTable exists with ifType = mpls(166). If this associated entry in ifTable is operationally disabled (thus removing MPLS capabilities on that interface), the corresponding entry in this table MUST be deleted shortly thereafter. An conceptual row with index 0 is created if the LSR supports per-platform labels. This conceptual row represents the per-platform label space and contains parameters that apply to all interfaces that participate in the per-platform label space. Other conceptual rows in this table represent MPLS interfaces that may participate in either the per-platform or per- interface label spaces, or both. Implementations that either only support per-platform labels, or have only them configured, may choose to return just the mplsInterfaceEntry of 0 and not return the other rows. This will greatly reduce the number of objects returned. Further information about label space participation of an interface is provided in the DESCRIPTION clause of mplsInterfaceLabelParticipationType.')
mplsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsInterfaceIndex.setReference('RFC 2863 - The Interfaces Group MIB, McCloghrie, K., and F. Kastenholtz, June 2000')
if mibBuilder.loadTexts: mplsInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceIndex.setDescription('This is a unique index for an entry in the MplsInterfaceTable. A non-zero index for an entry indicates the ifIndex for the corresponding interface entry of the MPLS-layer in the ifTable. The entry with index 0 represents the per-platform label space and contains parameters that apply to all interfaces that participate in the per-platform label space. Other entries defined in this table represent additional MPLS interfaces that may participate in either the per-platform or per-interface label spaces, or both.')
mplsInterfaceLabelMinIn = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 2), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMinIn.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMinIn.setDescription('This is the minimum value of an MPLS label that this LSR is willing to receive on this interface.')
mplsInterfaceLabelMaxIn = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 3), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMaxIn.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMaxIn.setDescription('This is the maximum value of an MPLS label that this LSR is willing to receive on this interface.')
mplsInterfaceLabelMinOut = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 4), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMinOut.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMinOut.setDescription('This is the minimum value of an MPLS label that this LSR is willing to send on this interface.')
mplsInterfaceLabelMaxOut = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 5), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMaxOut.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMaxOut.setDescription('This is the maximum value of an MPLS label that this LSR is willing to send on this interface.')
mplsInterfaceTotalBandwidth = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 6), MplsBitRate()).setUnits('kilobits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceTotalBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceTotalBandwidth.setDescription('This value indicates the total amount of usable bandwidth on this interface and is specified in kilobits per second (Kbps). This variable is not applicable when applied to the interface with index 0. When this value cannot be measured, this value should contain the nominal bandwidth.')
mplsInterfaceAvailableBandwidth = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 7), MplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceAvailableBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceAvailableBandwidth.setDescription('This value indicates the total amount of available bandwidth available on this interface and is specified in kilobits per second (Kbps). This value is calculated as the difference between the amount of bandwidth currently in use and that specified in mplsInterfaceTotalBandwidth. This variable is not applicable when applied to the interface with index 0. When this value cannot be measured, this value should contain the nominal bandwidth.')
mplsInterfaceLabelParticipationType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 1, 1, 8), Bits().clone(namedValues=NamedValues(("perPlatform", 0), ("perInterface", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setReference('Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, RFC 3031, January 2001.')
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setDescription('If the value of the mplsInterfaceIndex for this entry is zero, then this entry corresponds to the per-platform label space for all interfaces configured to use that label space. In this case the perPlatform(0) bit MUST be set; the perInterface(1) bit is meaningless and MUST be ignored. The remainder of this description applies to entries with a non-zero value of mplsInterfaceIndex. If the perInterface(1) bit is set then the value of mplsInterfaceLabelMinIn, mplsInterfaceLabelMaxIn, mplsInterfaceLabelMinOut, and mplsInterfaceLabelMaxOut for this entry reflect the label ranges for this interface. If only the perPlatform(0) bit is set, then the value of mplsInterfaceLabelMinIn, mplsInterfaceLabelMaxIn, mplsInterfaceLabelMinOut, and mplsInterfaceLabelMaxOut for this entry MUST be identical to the instance of these objects with index 0. These objects may only vary from the entry with index 0 if both the perPlatform(0) and perInterface(1) bits are set. In all cases, at a minimum one of the perPlatform(0) or perInterface(1) bits MUST be set to indicate that at least one label space is in use by this interface. In all cases, agents MUST ensure that label ranges are specified consistently and MUST return an inconsistentValue error when they do not.')
mplsInterfacePerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 2), )
if mibBuilder.loadTexts: mplsInterfacePerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfTable.setDescription('This table provides MPLS performance information on a per-interface basis.')
mplsInterfacePerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 2, 1), )
mplsInterfaceEntry.registerAugmentions(("MPLS-LSR-STD-MIB", "mplsInterfacePerfEntry"))
mplsInterfacePerfEntry.setIndexNames(*mplsInterfaceEntry.getIndexNames())
if mibBuilder.loadTexts: mplsInterfacePerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfEntry.setDescription("An entry in this table is created by the LSR for every interface capable of supporting MPLS. Its is an extension to the mplsInterfaceEntry table. Note that the discontinuity behavior of entries in this table MUST be based on the corresponding ifEntry's ifDiscontinuityTime.")
mplsInterfacePerfInLabelsInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfacePerfInLabelsInUse.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfInLabelsInUse.setDescription('This object counts the number of labels that are in use at this point in time on this interface in the incoming direction. If the interface participates in only the per-platform label space, then the value of the instance of this object MUST be identical to the value of the instance with index 0. If the interface participates in the per-interface label space, then the instance of this object MUST represent the number of per-interface labels that are in use on this interface.')
mplsInterfacePerfInLabelLookupFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfacePerfInLabelLookupFailures.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfInLabelLookupFailures.setDescription('This object counts the number of labeled packets that have been received on this interface and which were discarded because there was no matching cross- connect entry. This object MUST count on a per- interface basis regardless of which label space the interface participates in.')
mplsInterfacePerfOutLabelsInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfacePerfOutLabelsInUse.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfOutLabelsInUse.setDescription('This object counts the number of top-most labels in the outgoing label stacks that are in use at this point in time on this interface. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
mplsInterfacePerfOutFragmentedPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfacePerfOutFragmentedPkts.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfOutFragmentedPkts.setDescription('This object counts the number of outgoing MPLS packets that required fragmentation before transmission on this interface. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
mplsInSegmentIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 3), MplsIndexNextType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentIndexNext.setDescription('This object contains the next available value to be used for mplsInSegmentIndex when creating entries in the mplsInSegmentTable. The special value of a string containing the single octet 0x00 indicates that no new entries can be created in this table. Agents not allowing managers to create entries in this table MUST set this object to this special value.')
mplsInSegmentTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4), )
if mibBuilder.loadTexts: mplsInSegmentTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTable.setDescription("This table contains a description of the incoming MPLS segments (labels) to an LSR and their associated parameters. The index for this table is mplsInSegmentIndex. The index structure of this table is specifically designed to handle many different MPLS implementations that manage their labels both in a distributed and centralized manner. The table is also designed to handle existing MPLS labels as defined in RFC3031 as well as longer ones that may be necessary in the future. In cases where the label cannot fit into the mplsInSegmentLabel object, the mplsInSegmentLabelPtr will indicate this by being set to the first accessible column in the appropriate extension table's row. In this case an additional table MUST be provided and MUST be indexed by at least the indexes used by this table. In all other cases when the label is represented within the mplsInSegmentLabel object, the mplsInSegmentLabelPtr MUST be set to 0.0. Due to the fact that MPLS labels may not exceed 24 bits, the mplsInSegmentLabelPtr object is only a provision for future-proofing the MIB module. Thus, the definition of any extension tables is beyond the scope of this MIB module.")
mplsInSegmentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsInSegmentIndex"))
if mibBuilder.loadTexts: mplsInSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentEntry.setDescription("An entry in this table represents one incoming segment as is represented in an LSR's LFIB. An entry can be created by a network administrator or an SNMP agent, or an MPLS signaling protocol. The creator of the entry is denoted by mplsInSegmentOwner. The value of mplsInSegmentRowStatus cannot be active(1) unless the ifTable entry corresponding to mplsInSegmentInterface exists. An entry in this table must match any incoming packets, and indicates an instance of mplsXCEntry based on which forwarding and/or switching actions are taken.")
mplsInSegmentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: mplsInSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentIndex.setDescription('The index for this in-segment. The string containing the single octet 0x00 MUST not be used as an index.')
mplsInSegmentInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentInterface.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentInterface.setDescription('This object represents the interface index for the incoming MPLS interface. A value of zero represents all interfaces participating in the per-platform label space. This may only be used in cases where the incoming interface and label are associated with the same mplsXCEntry. Specifically, given a label and any incoming interface pair from the per-platform label space, the outgoing label/interface mapping remains the same. If this is not the case, then individual entries MUST exist that can then be mapped to unique mplsXCEntries.')
mplsInSegmentLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 3), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentLabel.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLabel.setDescription('If the corresponding instance of mplsInSegmentLabelPtr is zeroDotZero then this object MUST contain the incoming label associated with this in-segment. If not this object SHOULD be zero and MUST be ignored.')
mplsInSegmentLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 4), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentLabelPtr.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLabelPtr.setDescription('If the label for this segment cannot be represented fully within the mplsInSegmentLabel object, this object MUST point to the first accessible column of a conceptual row in an external table containing the label. In this case, the mplsInSegmentTopLabel object SHOULD be set to 0 and ignored. This object MUST be set to zeroDotZero otherwise.')
mplsInSegmentNPop = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentNPop.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentNPop.setDescription('The number of labels to pop from the incoming packet. Normally only the top label is popped from the packet and used for all switching decisions for that packet. This is indicated by setting this object to the default value of 1. If an LSR supports popping of more than one label, this object MUST be set to that number. This object cannot be modified if mplsInSegmentRowStatus is active(1).')
mplsInSegmentAddrFamily = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 6), AddressFamilyNumbers().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setReference('Internet Assigned Numbers Authority (IANA), ADDRESS FAMILY NUMBERS, (http://www.iana.org/assignments/ address-family-numbers), for MIB see: http://www.iana.org/assignments/ ianaaddressfamilynumbers-mib ')
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setDescription('The IANA address family [IANAFamily] of packets received on this segment, which is used at an egress LSR to deliver them to the appropriate layer 3 entity. A value of other(0) indicates that the family type is either unknown or undefined; this SHOULD NOT be used at an egress LSR. This object cannot be modified if mplsInSegmentRowStatus is active(1).')
mplsInSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 7), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentXCIndex.setDescription('Index into mplsXCTable which identifies which cross- connect entry this segment is part of. The string containing the single octet 0x00 indicates that this entry is not referred to by any cross-connect entry. When a cross-connect entry is created which this in-segment is a part of, this object is automatically updated to reflect the value of mplsXCIndex of that cross-connect entry.')
mplsInSegmentOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 8), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentOwner.setDescription('Denotes the entity that created and is responsible for managing this segment.')
mplsInSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 9), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic parameter specification for this in-segment. This value may point at an entry in the mplsTunnelResourceTable in the MPLS-TE-STD-MIB (RFC3812) to indicate which traffic parameter settings for this segment if it represents an LSP used for a TE tunnel. This value may optionally point at an externally defined traffic parameter specification table. A value of zeroDotZero indicates best-effort treatment. By having the same value of this object, two or more segments can indicate resource sharing of such things as LSP queue space, etc. This object cannot be modified if mplsInSegmentRowStatus is active(1). For entries in this table that are preserved after a re-boot, the agent MUST ensure that their integrity be preserved, or this object should be set to 0.0 if it cannot.')
mplsInSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table. When a row in this table has a row in the active(1) state, no objects in this row can be modified except the mplsInSegmentRowStatus and mplsInSegmentStorageType.')
mplsInSegmentStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 4, 1, 11), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentStorageType.setReference('See RFC2579.')
if mibBuilder.loadTexts: mplsInSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentStorageType.setDescription("This variable indicates the storage type for this object. The agent MUST ensure that this object's value remains consistent with the associated mplsXCEntry. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
mplsInSegmentPerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5), )
if mibBuilder.loadTexts: mplsInSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfTable.setDescription('This table contains statistical information for incoming MPLS segments to an LSR.')
mplsInSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1), )
mplsInSegmentEntry.registerAugmentions(("MPLS-LSR-STD-MIB", "mplsInSegmentPerfEntry"))
mplsInSegmentPerfEntry.setIndexNames(*mplsInSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: mplsInSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfEntry.setDescription('An entry in this table contains statistical information about one incoming segment which is configured in the mplsInSegmentTable. The counters in this entry should behave in a manner similar to that of the interface. mplsInSegmentPerfDiscontinuityTime indicates the time of the last discontinuity in all of these objects.')
mplsInSegmentPerfOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfOctets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfOctets.setDescription('This value represents the total number of octets received by this segment. It MUST be equal to the least significant 32 bits of mplsInSegmentPerfHCOctets if mplsInSegmentPerfHCOctets is supported according to the rules spelled out in RFC2863.')
mplsInSegmentPerfPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfPackets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfPackets.setDescription('Total number of packets received by this segment.')
mplsInSegmentPerfErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfErrors.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfErrors.setDescription('The number of errored packets received on this segment.')
mplsInSegmentPerfDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfDiscards.setDescription('The number of labeled packets received on this in- segment, which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a labeled packet could be to free up buffer space.')
mplsInSegmentPerfHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfHCOctets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfHCOctets.setDescription('The total number of octets received. This is the 64 bit version of mplsInSegmentPerfOctets, if mplsInSegmentPerfHCOctets is supported according to the rules spelled out in RFC2863.')
mplsInSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 5, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this segment's Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
mplsOutSegmentIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 6), MplsIndexNextType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIndexNext.setDescription('This object contains the next available value to be used for mplsOutSegmentIndex when creating entries in the mplsOutSegmentTable. The special value of a string containing the single octet 0x00 indicates that no new entries can be created in this table. Agents not allowing managers to create entries in this table MUST set this object to this special value.')
mplsOutSegmentTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7), )
if mibBuilder.loadTexts: mplsOutSegmentTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTable.setDescription('This table contains a representation of the outgoing segments from an LSR.')
mplsOutSegmentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsOutSegmentIndex"))
if mibBuilder.loadTexts: mplsOutSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentEntry.setDescription('An entry in this table represents one outgoing segment. An entry can be created by a network administrator, an SNMP agent, or an MPLS signaling protocol. The object mplsOutSegmentOwner indicates the creator of this entry. The value of mplsOutSegmentRowStatus cannot be active(1) unless the ifTable entry corresponding to mplsOutSegmentInterface exists. Note that the indexing of this table uses a single, arbitrary index (mplsOutSegmentIndex) to indicate which out-segment (i.e.: label) is being switched to from which in-segment (i.e: label) or in-segments. This is necessary because it is possible to have an equal-cost multi-path situation where two identical out-going labels are assigned to the same cross-connect (i.e.: they go to two different neighboring LSRs); thus, requiring two out-segments. In order to preserve the uniqueness of the references by the mplsXCEntry, an arbitrary integer must be used as the index for this table.')
mplsOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: mplsOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIndex.setDescription('This value contains a unique index for this row. While a value of a string containing the single octet 0x00 is not valid as an index for entries in this table, it can be supplied as a valid value to index the mplsXCTable to represent entries for which no out-segment has been configured or exists.')
mplsOutSegmentInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentInterface.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentInterface.setDescription('This value must contain the interface index of the outgoing interface. This object cannot be modified if mplsOutSegmentRowStatus is active(1). The mplsOutSegmentRowStatus cannot be set to active(1) until this object is set to a value corresponding to a valid ifEntry.')
mplsOutSegmentPushTopLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 3), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentPushTopLabel.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPushTopLabel.setDescription("This value indicates whether or not a top label should be pushed onto the outgoing packet's label stack. The value of this variable MUST be set to true(1) if the outgoing interface does not support pop-and-go (and no label stack remains). For example, on ATM interface, or if the segment represents a tunnel origination. Note that it is considered an error in the case that mplsOutSegmentPushTopLabel is set to false, but the cross-connect entry which refers to this out-segment has a non-zero mplsLabelStackIndex. The LSR MUST ensure that this situation does not happen. This object cannot be modified if mplsOutSegmentRowStatus is active(1).")
mplsOutSegmentTopLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 4), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTopLabel.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTopLabel.setDescription("If mplsOutSegmentPushTopLabel is true then this represents the label that should be pushed onto the top of the outgoing packet's label stack. Otherwise this value SHOULD be set to 0 by the management station and MUST be ignored by the agent. This object cannot be modified if mplsOutSegmentRowStatus is active(1).")
mplsOutSegmentTopLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 5), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTopLabelPtr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTopLabelPtr.setDescription('If the label for this segment cannot be represented fully within the mplsOutSegmentLabel object, this object MUST point to the first accessible column of a conceptual row in an external table containing the label. In this case, the mplsOutSegmentTopLabel object SHOULD be set to 0 and ignored. This object MUST be set to zeroDotZero otherwise.')
mplsOutSegmentNextHopAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 6), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopAddrType.setReference('See RFC3291.')
if mibBuilder.loadTexts: mplsOutSegmentNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopAddrType.setDescription('Indicates the next hop Internet address type. Only values unknown(0), ipv4(1) or ipv6(2) have to be supported. A value of unknown(0) is allowed only when the outgoing interface is of type point-to-point. If any other unsupported values are attempted in a set operation, the agent MUST return an inconsistentValue error.')
mplsOutSegmentNextHopAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopAddr.setDescription('The internet address of the next hop. The type of this address is determined by the value of the mplslOutSegmentNextHopAddrType object. This object cannot be modified if mplsOutSegmentRowStatus is active(1).')
mplsOutSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 8), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentXCIndex.setDescription('Index into mplsXCTable which identifies which cross- connect entry this segment is part of. A value of the string containing the single octet 0x00 indicates that this entry is not referred to by any cross-connect entry. When a cross-connect entry is created which this out-segment is a part of, this object MUST be updated by the agent to reflect the value of mplsXCIndex of that cross-connect entry.')
mplsOutSegmentOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 9), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentOwner.setDescription('Denotes the entity which created and is responsible for managing this segment.')
mplsOutSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 10), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic parameter specification for this out-segment. This value may point at an entry in the MplsTunnelResourceEntry in the MPLS-TE-STD-MIB (RFC3812) RFC Editor: Please fill in RFC number. to indicate which traffic parameter settings for this segment if it represents an LSP used for a TE tunnel. This value may optionally point at an externally defined traffic parameter specification table. A value of zeroDotZero indicates best-effort treatment. By having the same value of this object, two or more segments can indicate resource sharing of such things as LSP queue space, etc. This object cannot be modified if mplsOutSegmentRowStatus is active(1). For entries in this table that are preserved after a re-boot, the agent MUST ensure that their integrity be preserved, or this object should be set to 0.0 if it cannot.')
mplsOutSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentRowStatus.setDescription('For creating, modifying, and deleting this row. When a row in this table has a row in the active(1) state, no objects in this row can be modified except the mplsOutSegmentRowStatus or mplsOutSegmentStorageType.')
mplsOutSegmentStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 7, 1, 12), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentStorageType.setDescription("This variable indicates the storage type for this object. The agent MUST ensure that this object's value remains consistent with the associated mplsXCEntry. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
mplsOutSegmentPerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8), )
if mibBuilder.loadTexts: mplsOutSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfTable.setDescription('This table contains statistical information about outgoing segments from an LSR. The counters in this entry should behave in a manner similar to that of the interface.')
mplsOutSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1), )
mplsOutSegmentEntry.registerAugmentions(("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfEntry"))
mplsOutSegmentPerfEntry.setIndexNames(*mplsOutSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: mplsOutSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfEntry.setDescription('An entry in this table contains statistical information about one outgoing segment configured in mplsOutSegmentTable. The object mplsOutSegmentPerfDiscontinuityTime indicates the time of the last discontinuity in these objects. ')
mplsOutSegmentPerfOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfOctets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfOctets.setDescription('This value contains the total number of octets sent on this segment. It MUST be equal to the least significant 32 bits of mplsOutSegmentPerfHCOctets if mplsOutSegmentPerfHCOctets is supported according to the rules spelled out in RFC2863.')
mplsOutSegmentPerfPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfPackets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfPackets.setDescription('This value contains the total number of packets sent on this segment.')
mplsOutSegmentPerfErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfErrors.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfErrors.setDescription('Number of packets that could not be sent due to errors on this segment.')
mplsOutSegmentPerfDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscards.setDescription('The number of labeled packets attempted to be transmitted on this out-segment, which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a labeled packet could be to free up buffer space.')
mplsOutSegmentPerfHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfHCOctets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfHCOctets.setDescription('Total number of octets sent. This is the 64 bit version of mplsOutSegmentPerfOctets, if mplsOutSegmentPerfHCOctets is supported according to the rules spelled out in RFC2863.')
mplsOutSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 8, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this segment's Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
mplsXCIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 9), MplsIndexNextType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsXCIndexNext.setDescription('This object contains the next available value to be used for mplsXCIndex when creating entries in the mplsXCTable. A special value of the zero length string indicates that no more new entries can be created in the relevant table. Agents not allowing managers to create entries in this table MUST set this value to the zero length string.')
mplsXCTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10), )
if mibBuilder.loadTexts: mplsXCTable.setStatus('current')
if mibBuilder.loadTexts: mplsXCTable.setDescription('This table specifies information for switching between LSP segments. It supports point-to-point, point-to-multipoint and multipoint-to-point connections. mplsLabelStackTable specifies the label stack information for a cross-connect LSR and is referred to from mplsXCTable.')
mplsXCEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsXCIndex"), (0, "MPLS-LSR-STD-MIB", "mplsXCInSegmentIndex"), (0, "MPLS-LSR-STD-MIB", "mplsXCOutSegmentIndex"))
if mibBuilder.loadTexts: mplsXCEntry.setStatus('current')
if mibBuilder.loadTexts: mplsXCEntry.setDescription('A row in this table represents one cross-connect entry. It is indexed by the following objects: - cross-connect index mplsXCIndex that uniquely identifies a group of cross-connect entries - in-segment index, mplsXCInSegmentIndex - out-segment index, mplsXCOutSegmentIndex LSPs originating at this LSR: These are represented by using the special of value of mplsXCInSegmentIndex set to the string containing a single octet 0x00. In this case the mplsXCOutSegmentIndex MUST not be the string containing a single octet 0x00. LSPs terminating at this LSR: These are represented by using the special value mplsXCOutSegmentIndex set to the string containing a single octet 0x00. Special labels: Entries indexed by the strings containing the reserved MPLS label values as a single octet 0x00 through 0x0f (inclusive) imply LSPs terminating at this LSR. Note that situations where LSPs are terminated with incoming label equal to the string containing a single octet 0x00 can be distinguished from LSPs originating at this LSR because the mplsXCOutSegmentIndex equals the string containing the single octet 0x00. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol.')
mplsXCIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: mplsXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCIndex.setDescription('Primary index for the conceptual row identifying a group of cross-connect segments. The string containing a single octet 0x00 is an invalid index.')
mplsXCInSegmentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 2), MplsIndexType())
if mibBuilder.loadTexts: mplsXCInSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCInSegmentIndex.setDescription("Incoming label index. If this object is set to the string containing a single octet 0x00, this indicates a special case outlined in the table's description above. In this case no corresponding mplsInSegmentEntry shall exist.")
mplsXCOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 3), MplsIndexType())
if mibBuilder.loadTexts: mplsXCOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCOutSegmentIndex.setDescription('Index of out-segment for LSPs not terminating on this LSR if not set to the string containing the single octet 0x00. If the segment identified by this entry is terminating, then this object MUST be set to the string containing a single octet 0x00 to indicate that no corresponding mplsOutSegmentEntry shall exist.')
mplsXCLspId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 4), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCLspId.setStatus('current')
if mibBuilder.loadTexts: mplsXCLspId.setDescription('This value identifies the label switched path that this cross-connect entry belongs to. This object cannot be modified if mplsXCRowStatus is active(1) except for this object.')
mplsXCLabelStackIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 5), MplsIndexType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCLabelStackIndex.setDescription('Primary index into mplsLabelStackTable identifying a stack of labels to be pushed beneath the top label. Note that the top label identified by the out- segment ensures that all the components of a multipoint-to-point connection have the same outgoing label. A value of the string containing the single octet 0x00 indicates that no labels are to be stacked beneath the top label. This object cannot be modified if mplsXCRowStatus is active(1).')
mplsXCOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 6), MplsOwner()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCOwner.setStatus('current')
if mibBuilder.loadTexts: mplsXCOwner.setDescription('Denotes the entity that created and is responsible for managing this cross-connect.')
mplsXCRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCRowStatus.setDescription('For creating, modifying, and deleting this row. When a row in this table has a row in the active(1) state, no objects in this row except this object and the mplsXCStorageType can be modified. ')
mplsXCStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 8), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsXCStorageType.setDescription("This variable indicates the storage type for this object. The agent MUST ensure that the associated in and out segments also have the same StorageType value and are restored consistently upon system restart. This value SHOULD be set to permanent(4) if created as a result of a static LSP configuration. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
mplsXCAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCAdminStatus.setDescription('The desired operational status of this segment.')
mplsXCOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCOperStatus.setDescription('The actual operational status of this cross- connect.')
mplsMaxLabelStackDepth = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsMaxLabelStackDepth.setStatus('current')
if mibBuilder.loadTexts: mplsMaxLabelStackDepth.setDescription('The maximum stack depth supported by this LSR.')
mplsLabelStackIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 12), MplsIndexNextType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLabelStackIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackIndexNext.setDescription('This object contains the next available value to be used for mplsLabelStackIndex when creating entries in the mplsLabelStackTable. The special string containing the single octet 0x00 indicates that no more new entries can be created in the relevant table. Agents not allowing managers to create entries in this table MUST set this value to the string containing the single octet 0x00.')
mplsLabelStackTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13), )
if mibBuilder.loadTexts: mplsLabelStackTable.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackTable.setDescription('This table specifies the label stack to be pushed onto a packet, beneath the top label. Entries into this table are referred to from mplsXCTable.')
mplsLabelStackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsLabelStackIndex"), (0, "MPLS-LSR-STD-MIB", "mplsLabelStackLabelIndex"))
if mibBuilder.loadTexts: mplsLabelStackEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackEntry.setDescription('An entry in this table represents one label which is to be pushed onto an outgoing packet, beneath the top label. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol.')
mplsLabelStackIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1, 1), MplsIndexType())
if mibBuilder.loadTexts: mplsLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackIndex.setDescription('Primary index for this row identifying a stack of labels to be pushed on an outgoing packet, beneath the top label. An index containing the string with a single octet 0x00 MUST not be used.')
mplsLabelStackLabelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLabelStackLabelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabelIndex.setDescription('Secondary index for this row identifying one label of the stack. Note that an entry with a smaller mplsLabelStackLabelIndex would refer to a label higher up the label stack and would be popped at a downstream LSR before a label represented by a higher mplsLabelStackLabelIndex at a downstream LSR.')
mplsLabelStackLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1, 3), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabel.setDescription('The label to pushed.')
mplsLabelStackLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1, 4), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackLabelPtr.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabelPtr.setDescription('If the label for this segment cannot be represented fully within the mplsLabelStackLabel object, this object MUST point to the first accessible column of a conceptual row in an external table containing the label. In this case, the mplsLabelStackLabel object SHOULD be set to 0 and ignored. This object MUST be set to zeroDotZero otherwise.')
mplsLabelStackRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackRowStatus.setDescription('For creating, modifying, and deleting this row. When a row in this table has a row in the active(1) state, no objects in this row except this object and the mplsLabelStackStorageType can be modified.')
mplsLabelStackStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 13, 1, 6), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackStorageType.setDescription("This variable indicates the storage type for this object. This object cannot be modified if mplsLabelStackRowStatus is active(1). No objects are required to be writable for rows in this table with this object set to permanent(4). The agent MUST ensure that all related entries in this table retain the same value for this object. Agents MUST ensure that the storage type for all entries related to a particular mplsXCEntry retain the same value for this object as the mplsXCEntry's StorageType.")
mplsInSegmentMapTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 14), )
if mibBuilder.loadTexts: mplsInSegmentMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentMapTable.setDescription('This table specifies the mapping from the mplsInSegmentIndex to the corresponding mplsInSegmentInterface and mplsInSegmentLabel objects. The purpose of this table is to provide the manager with an alternative means by which to locate in-segments.')
mplsInSegmentMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 14, 1), ).setIndexNames((0, "MPLS-LSR-STD-MIB", "mplsInSegmentMapInterface"), (0, "MPLS-LSR-STD-MIB", "mplsInSegmentMapLabel"), (0, "MPLS-LSR-STD-MIB", "mplsInSegmentMapLabelPtrIndex"))
if mibBuilder.loadTexts: mplsInSegmentMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentMapEntry.setDescription("An entry in this table represents one interface and incoming label pair. In cases where the label cannot fit into the mplsInSegmentLabel object, the mplsInSegmentLabelPtr will indicate this by being set to the first accessible column in the appropriate extension table's row, and the mplsInSegmentLabel SHOULD be set to 0. In all other cases when the label is represented within the mplsInSegmentLabel object, the mplsInSegmentLabelPtr MUST be 0.0. Implementors need to be aware that if the value of the mplsInSegmentMapLabelPtrIndex (an OID) has more that 111 sub-identifiers, then OIDs of column instances in this table will have more than 128 sub-identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.")
mplsInSegmentMapInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 14, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsInSegmentMapInterface.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentMapInterface.setDescription('This index contains the same value as the mplsInSegmentIndex in the mplsInSegmentTable.')
mplsInSegmentMapLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 14, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsInSegmentMapLabel.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentMapLabel.setDescription('This index contains the same value as the mplsInSegmentLabel in the mplsInSegmentTable.')
mplsInSegmentMapLabelPtrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 14, 1, 3), RowPointer())
if mibBuilder.loadTexts: mplsInSegmentMapLabelPtrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentMapLabelPtrIndex.setDescription('This index contains the same value as the mplsInSegmentLabelPtr. If the label for the InSegment cannot be represented fully within the mplsInSegmentLabel object, this index MUST point to the first accessible column of a conceptual row in an external table containing the label. In this case, the mplsInSegmentTopLabel object SHOULD be set to 0 and ignored. This object MUST be set to zeroDotZero otherwise.')
mplsInSegmentMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 14, 1, 4), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentMapIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentMapIndex.setDescription('The mplsInSegmentIndex that corresponds to the mplsInSegmentInterface and mplsInSegmentLabel, or the mplsInSegmentInterface and mplsInSegmentLabelPtr, if applicable. The string containing the single octet 0x00 MUST not be returned.')
mplsXCNotificationsEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 2, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsXCNotificationsEnable.setReference('See also RFC3413 for explanation that notifications are under the ultimate control of the MIB module in this document.')
if mibBuilder.loadTexts: mplsXCNotificationsEnable.setStatus('current')
if mibBuilder.loadTexts: mplsXCNotificationsEnable.setDescription('If this object is set to true(1), then it enables the emission of mplsXCUp and mplsXCDown notifications; otherwise these notifications are not emitted.')
mplsXCUp = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 2, 0, 1)).setObjects(("MPLS-LSR-STD-MIB", "mplsXCOperStatus"), ("MPLS-LSR-STD-MIB", "mplsXCOperStatus"))
if mibBuilder.loadTexts: mplsXCUp.setStatus('current')
if mibBuilder.loadTexts: mplsXCUp.setDescription('This notification is generated when the mplsXCOperStatus object for one or more contiguous entries in mplsXCTable are about to enter the up(1) state from some other state. The included values of mplsXCOperStatus MUST both be set equal to this new state (i.e: up(1)). The two instances of mplsXCOperStatus in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of cross-connects have transitioned into the up(1) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single cross-connect entry, then the instance identifier (and values) of the two mplsXCOperStatus objects MUST be the identical.')
mplsXCDown = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 2, 0, 2)).setObjects(("MPLS-LSR-STD-MIB", "mplsXCOperStatus"), ("MPLS-LSR-STD-MIB", "mplsXCOperStatus"))
if mibBuilder.loadTexts: mplsXCDown.setStatus('current')
if mibBuilder.loadTexts: mplsXCDown.setDescription('This notification is generated when the mplsXCOperStatus object for one or more contiguous entries in mplsXCTable are about to enter the down(2) state from some other state. The included values of mplsXCOperStatus MUST both be set equal to this down(2) state. The two instances of mplsXCOperStatus in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of cross-connects have transitioned into the down(2) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single cross-connect entry, then the instance identifier (and values) of the two mplsXCOperStatus objects MUST be identical.')
mplsLsrGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1))
mplsLsrCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 2))
mplsLsrModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 2, 1)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("MPLS-LSR-STD-MIB", "mplsInterfaceGroup"), ("MPLS-LSR-STD-MIB", "mplsInSegmentGroup"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentGroup"), ("MPLS-LSR-STD-MIB", "mplsXCGroup"), ("MPLS-LSR-STD-MIB", "mplsPerfGroup"), ("MPLS-LSR-STD-MIB", "mplsLabelStackGroup"), ("MPLS-LSR-STD-MIB", "mplsHCInSegmentPerfGroup"), ("MPLS-LSR-STD-MIB", "mplsHCOutSegmentPerfGroup"), ("MPLS-LSR-STD-MIB", "mplsLsrNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrModuleFullCompliance = mplsLsrModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLsrModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for MPLS-LSR-STD-MIB. Such devices can then be monitored and also be configured using this MIB module.')
mplsLsrModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 2, 2)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("MPLS-LSR-STD-MIB", "mplsInterfaceGroup"), ("MPLS-LSR-STD-MIB", "mplsInSegmentGroup"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentGroup"), ("MPLS-LSR-STD-MIB", "mplsXCGroup"), ("MPLS-LSR-STD-MIB", "mplsPerfGroup"), ("MPLS-LSR-STD-MIB", "mplsLabelStackGroup"), ("MPLS-LSR-STD-MIB", "mplsHCInSegmentPerfGroup"), ("MPLS-LSR-STD-MIB", "mplsHCOutSegmentPerfGroup"), ("MPLS-LSR-STD-MIB", "mplsLsrNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrModuleReadOnlyCompliance = mplsLsrModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLsrModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only provide read-only support for MPLS-LSR-STD-MIB. Such devices can then be monitored but cannot be configured using this MIB module. ')
mplsInterfaceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 1)).setObjects(("MPLS-LSR-STD-MIB", "mplsInterfaceLabelMinIn"), ("MPLS-LSR-STD-MIB", "mplsInterfaceLabelMaxIn"), ("MPLS-LSR-STD-MIB", "mplsInterfaceLabelMinOut"), ("MPLS-LSR-STD-MIB", "mplsInterfaceLabelMaxOut"), ("MPLS-LSR-STD-MIB", "mplsInterfaceTotalBandwidth"), ("MPLS-LSR-STD-MIB", "mplsInterfaceAvailableBandwidth"), ("MPLS-LSR-STD-MIB", "mplsInterfaceLabelParticipationType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsInterfaceGroup = mplsInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceGroup.setDescription('Collection of objects needed for MPLS interface and interface performance information.')
mplsInSegmentGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 2)).setObjects(("MPLS-LSR-STD-MIB", "mplsInSegmentIndexNext"), ("MPLS-LSR-STD-MIB", "mplsInSegmentInterface"), ("MPLS-LSR-STD-MIB", "mplsInSegmentLabel"), ("MPLS-LSR-STD-MIB", "mplsInSegmentLabelPtr"), ("MPLS-LSR-STD-MIB", "mplsInSegmentNPop"), ("MPLS-LSR-STD-MIB", "mplsInSegmentAddrFamily"), ("MPLS-LSR-STD-MIB", "mplsInSegmentXCIndex"), ("MPLS-LSR-STD-MIB", "mplsInSegmentOwner"), ("MPLS-LSR-STD-MIB", "mplsInSegmentRowStatus"), ("MPLS-LSR-STD-MIB", "mplsInSegmentStorageType"), ("MPLS-LSR-STD-MIB", "mplsInSegmentTrafficParamPtr"), ("MPLS-LSR-STD-MIB", "mplsInSegmentMapIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsInSegmentGroup = mplsInSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentGroup.setDescription('Collection of objects needed to implement an in- segment.')
mplsOutSegmentGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 3)).setObjects(("MPLS-LSR-STD-MIB", "mplsOutSegmentIndexNext"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentInterface"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPushTopLabel"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentTopLabel"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentTopLabelPtr"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentNextHopAddrType"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentNextHopAddr"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentXCIndex"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentOwner"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfOctets"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfDiscards"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfErrors"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentRowStatus"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentStorageType"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsOutSegmentGroup = mplsOutSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentGroup.setDescription('Collection of objects needed to implement an out- segment.')
mplsXCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 4)).setObjects(("MPLS-LSR-STD-MIB", "mplsXCIndexNext"), ("MPLS-LSR-STD-MIB", "mplsXCLspId"), ("MPLS-LSR-STD-MIB", "mplsXCLabelStackIndex"), ("MPLS-LSR-STD-MIB", "mplsXCOwner"), ("MPLS-LSR-STD-MIB", "mplsXCStorageType"), ("MPLS-LSR-STD-MIB", "mplsXCAdminStatus"), ("MPLS-LSR-STD-MIB", "mplsXCOperStatus"), ("MPLS-LSR-STD-MIB", "mplsXCRowStatus"), ("MPLS-LSR-STD-MIB", "mplsXCNotificationsEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCGroup = mplsXCGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCGroup.setDescription('Collection of objects needed to implement a cross-connect entry.')
mplsPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 5)).setObjects(("MPLS-LSR-STD-MIB", "mplsInSegmentPerfOctets"), ("MPLS-LSR-STD-MIB", "mplsInSegmentPerfPackets"), ("MPLS-LSR-STD-MIB", "mplsInSegmentPerfErrors"), ("MPLS-LSR-STD-MIB", "mplsInSegmentPerfDiscards"), ("MPLS-LSR-STD-MIB", "mplsInSegmentPerfDiscontinuityTime"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfOctets"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfPackets"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfDiscards"), ("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfDiscontinuityTime"), ("MPLS-LSR-STD-MIB", "mplsInterfacePerfInLabelsInUse"), ("MPLS-LSR-STD-MIB", "mplsInterfacePerfInLabelLookupFailures"), ("MPLS-LSR-STD-MIB", "mplsInterfacePerfOutFragmentedPkts"), ("MPLS-LSR-STD-MIB", "mplsInterfacePerfOutLabelsInUse"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsPerfGroup = mplsPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsPerfGroup.setDescription('Collection of objects providing performance information about an LSR.')
mplsHCInSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 6)).setObjects(("MPLS-LSR-STD-MIB", "mplsInSegmentPerfHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsHCInSegmentPerfGroup = mplsHCInSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsHCInSegmentPerfGroup.setDescription('Object(s) providing performance information specific to out-segments for which the object mplsInterfaceInOctets wraps around too quickly.')
mplsHCOutSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 7)).setObjects(("MPLS-LSR-STD-MIB", "mplsOutSegmentPerfHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsHCOutSegmentPerfGroup = mplsHCOutSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsHCOutSegmentPerfGroup.setDescription('Object(s) providing performance information specific to out-segments for which the object mplsInterfaceOutOctets wraps around too quickly.')
mplsLabelStackGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 8)).setObjects(("MPLS-LSR-STD-MIB", "mplsLabelStackLabel"), ("MPLS-LSR-STD-MIB", "mplsLabelStackLabelPtr"), ("MPLS-LSR-STD-MIB", "mplsLabelStackRowStatus"), ("MPLS-LSR-STD-MIB", "mplsLabelStackStorageType"), ("MPLS-LSR-STD-MIB", "mplsMaxLabelStackDepth"), ("MPLS-LSR-STD-MIB", "mplsLabelStackIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLabelStackGroup = mplsLabelStackGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackGroup.setDescription('Objects needed to support label stacking.')
mplsLsrNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 166, 2, 2, 1, 9)).setObjects(("MPLS-LSR-STD-MIB", "mplsXCUp"), ("MPLS-LSR-STD-MIB", "mplsXCDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrNotificationGroup = mplsLsrNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLsrNotificationGroup.setDescription('Set of notifications implemented in this module.')
mibBuilder.exportSymbols("MPLS-LSR-STD-MIB", mplsOutSegmentOwner=mplsOutSegmentOwner, mplsOutSegmentTable=mplsOutSegmentTable, mplsOutSegmentPerfHCOctets=mplsOutSegmentPerfHCOctets, mplsOutSegmentPushTopLabel=mplsOutSegmentPushTopLabel, mplsInSegmentRowStatus=mplsInSegmentRowStatus, mplsOutSegmentPerfDiscontinuityTime=mplsOutSegmentPerfDiscontinuityTime, mplsXCOwner=mplsXCOwner, mplsLabelStackTable=mplsLabelStackTable, mplsXCGroup=mplsXCGroup, mplsOutSegmentRowStatus=mplsOutSegmentRowStatus, mplsOutSegmentTrafficParamPtr=mplsOutSegmentTrafficParamPtr, mplsInterfacePerfTable=mplsInterfacePerfTable, mplsLabelStackLabelIndex=mplsLabelStackLabelIndex, mplsOutSegmentIndexNext=mplsOutSegmentIndexNext, mplsInterfaceAvailableBandwidth=mplsInterfaceAvailableBandwidth, mplsInSegmentMapLabel=mplsInSegmentMapLabel, mplsInSegmentMapInterface=mplsInSegmentMapInterface, mplsOutSegmentTopLabelPtr=mplsOutSegmentTopLabelPtr, mplsInSegmentIndex=mplsInSegmentIndex, mplsOutSegmentNextHopAddrType=mplsOutSegmentNextHopAddrType, mplsLabelStackRowStatus=mplsLabelStackRowStatus, mplsInterfaceIndex=mplsInterfaceIndex, mplsInterfaceGroup=mplsInterfaceGroup, mplsOutSegmentTopLabel=mplsOutSegmentTopLabel, mplsLabelStackIndexNext=mplsLabelStackIndexNext, mplsInterfaceLabelMinOut=mplsInterfaceLabelMinOut, MplsIndexNextType=MplsIndexNextType, mplsOutSegmentPerfErrors=mplsOutSegmentPerfErrors, mplsLabelStackIndex=mplsLabelStackIndex, mplsInterfacePerfOutFragmentedPkts=mplsInterfacePerfOutFragmentedPkts, mplsLsrNotificationGroup=mplsLsrNotificationGroup, mplsInSegmentPerfErrors=mplsInSegmentPerfErrors, mplsInSegmentIndexNext=mplsInSegmentIndexNext, mplsLsrObjects=mplsLsrObjects, mplsLsrModuleReadOnlyCompliance=mplsLsrModuleReadOnlyCompliance, mplsOutSegmentEntry=mplsOutSegmentEntry, mplsOutSegmentGroup=mplsOutSegmentGroup, mplsLabelStackStorageType=mplsLabelStackStorageType, mplsPerfGroup=mplsPerfGroup, mplsInSegmentMapIndex=mplsInSegmentMapIndex, mplsInSegmentPerfDiscards=mplsInSegmentPerfDiscards, mplsOutSegmentPerfDiscards=mplsOutSegmentPerfDiscards, mplsOutSegmentPerfEntry=mplsOutSegmentPerfEntry, mplsInSegmentTrafficParamPtr=mplsInSegmentTrafficParamPtr, mplsXCLabelStackIndex=mplsXCLabelStackIndex, mplsXCTable=mplsXCTable, mplsInSegmentMapTable=mplsInSegmentMapTable, mplsOutSegmentPerfTable=mplsOutSegmentPerfTable, mplsInSegmentPerfEntry=mplsInSegmentPerfEntry, PYSNMP_MODULE_ID=mplsLsrStdMIB, mplsLsrStdMIB=mplsLsrStdMIB, mplsOutSegmentNextHopAddr=mplsOutSegmentNextHopAddr, mplsOutSegmentStorageType=mplsOutSegmentStorageType, mplsXCInSegmentIndex=mplsXCInSegmentIndex, mplsXCUp=mplsXCUp, mplsOutSegmentIndex=mplsOutSegmentIndex, mplsOutSegmentXCIndex=mplsOutSegmentXCIndex, mplsLabelStackGroup=mplsLabelStackGroup, mplsXCIndex=mplsXCIndex, mplsInSegmentEntry=mplsInSegmentEntry, mplsInSegmentNPop=mplsInSegmentNPop, mplsInSegmentInterface=mplsInSegmentInterface, mplsMaxLabelStackDepth=mplsMaxLabelStackDepth, mplsInterfacePerfOutLabelsInUse=mplsInterfacePerfOutLabelsInUse, mplsLabelStackLabel=mplsLabelStackLabel, mplsInSegmentPerfHCOctets=mplsInSegmentPerfHCOctets, mplsXCEntry=mplsXCEntry, mplsInSegmentGroup=mplsInSegmentGroup, mplsInterfacePerfInLabelLookupFailures=mplsInterfacePerfInLabelLookupFailures, mplsLsrGroups=mplsLsrGroups, mplsXCOutSegmentIndex=mplsXCOutSegmentIndex, mplsLsrModuleFullCompliance=mplsLsrModuleFullCompliance, mplsInterfaceLabelMinIn=mplsInterfaceLabelMinIn, mplsInterfaceTotalBandwidth=mplsInterfaceTotalBandwidth, mplsInterfaceLabelMaxIn=mplsInterfaceLabelMaxIn, mplsInSegmentPerfTable=mplsInSegmentPerfTable, mplsInterfaceLabelMaxOut=mplsInterfaceLabelMaxOut, mplsInSegmentPerfPackets=mplsInSegmentPerfPackets, mplsInSegmentMapLabelPtrIndex=mplsInSegmentMapLabelPtrIndex, MplsIndexType=MplsIndexType, mplsInSegmentPerfDiscontinuityTime=mplsInSegmentPerfDiscontinuityTime, mplsXCAdminStatus=mplsXCAdminStatus, mplsLsrNotifications=mplsLsrNotifications, mplsXCDown=mplsXCDown, mplsInSegmentAddrFamily=mplsInSegmentAddrFamily, mplsLsrConformance=mplsLsrConformance, mplsInSegmentPerfOctets=mplsInSegmentPerfOctets, mplsInterfacePerfInLabelsInUse=mplsInterfacePerfInLabelsInUse, mplsOutSegmentPerfPackets=mplsOutSegmentPerfPackets, mplsXCOperStatus=mplsXCOperStatus, mplsInterfaceLabelParticipationType=mplsInterfaceLabelParticipationType, mplsInterfacePerfEntry=mplsInterfacePerfEntry, mplsXCNotificationsEnable=mplsXCNotificationsEnable, mplsLsrCompliances=mplsLsrCompliances, mplsInSegmentMapEntry=mplsInSegmentMapEntry, mplsXCRowStatus=mplsXCRowStatus, mplsInSegmentOwner=mplsInSegmentOwner, mplsInSegmentLabelPtr=mplsInSegmentLabelPtr, mplsOutSegmentPerfOctets=mplsOutSegmentPerfOctets, mplsInSegmentTable=mplsInSegmentTable, mplsHCInSegmentPerfGroup=mplsHCInSegmentPerfGroup, mplsInSegmentLabel=mplsInSegmentLabel, mplsInSegmentXCIndex=mplsInSegmentXCIndex, mplsLabelStackEntry=mplsLabelStackEntry, mplsOutSegmentInterface=mplsOutSegmentInterface, mplsXCIndexNext=mplsXCIndexNext, mplsLabelStackLabelPtr=mplsLabelStackLabelPtr, mplsInSegmentStorageType=mplsInSegmentStorageType, mplsInterfaceEntry=mplsInterfaceEntry, mplsXCStorageType=mplsXCStorageType, mplsHCOutSegmentPerfGroup=mplsHCOutSegmentPerfGroup, mplsXCLspId=mplsXCLspId, mplsInterfaceTable=mplsInterfaceTable)

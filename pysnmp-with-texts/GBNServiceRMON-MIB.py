#
# PySNMP MIB module GBNServiceRMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GBNServiceRMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
rmonMib, = mibBuilder.importSymbols("GREENTECH-MASTER-MIB", "rmonMib")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, ModuleIdentity, iso, Counter64, Unsigned32, NotificationType, Integer32, MibIdentifier, mib_2, Counter32, Gauge32, Bits, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "ModuleIdentity", "iso", "Counter64", "Unsigned32", "NotificationType", "Integer32", "MibIdentifier", "mib-2", "Counter32", "Gauge32", "Bits", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class OwnerString(DisplayString):
    pass

class EntryStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4))

rStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1))
rHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2))
rAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3))
rEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9))
rEtherStatsTable = MibTable((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1), )
if mibBuilder.loadTexts: rEtherStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsTable.setDescription('A list of Ethernet statistics entries.')
rEtherStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1), ).setIndexNames((0, "GBNServiceRMON-MIB", "rEtherStatsIndex"))
if mibBuilder.loadTexts: rEtherStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsEntry.setDescription('A collection of statistics kept for a particular Ethernet interface. As an example, an instance of the etherStatsPkts object might be named etherStatsPkts.1')
rEtherStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsIndex.setDescription('The value of this object uniquely identifies this etherStats entry.')
rEtherStatsDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEtherStatsDataSource.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsDataSource.setDescription('This object identifies the source of the data that this etherStats entry is configured to analyze. This source can be any ethernet interface on this device. In order to identify a particular interface, this object shall identify the instance of the ifIndex object, defined in RFC 1213 and RFC 1573 [4,6], for the desired interface. For example, if an entry were to receive data from interface #1, this object would be set to ifIndex.1. The statistics in this group reflect all packets on the local network segment attached to the identified interface. An agent may or may not be able to tell if fundamental changes to the media of the interface have occurred and necessitate an invalidation of this entry. For example, a hot-pluggable ethernet card could be pulled out and replaced by a token-ring card. In such a case, if the agent has such knowledge of the change, it is recommended that it invalidate this entry. This object may not be modified if the associated etherStatsStatus object is equal to valid(1).')
rEtherStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
rEtherStatsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsOctets.setDescription('The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets). This object can be used as a reasonable estimate of ethernet utilization. If greater precision is desired, the etherStatsPkts and etherStatsOctets objects should be sampled before and after a common interval. The differences in the sampled values are Pkts and Octets, respectively, and the number of seconds in the interval is Interval. These values are used to calculate the Utilization as follows: Pkts * (9.6 + 6.4) + (Octets * .8) Utilization = ------------------------------------- Interval * 10,000 The result of this equation is the value Utilization which is the percent utilization of the ethernet segment on a scale of 0 to 100 percent.')
rEtherStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts.setDescription('The total number of packets (including bad packets, broadcast packets, and multicast packets) received.')
rEtherStatsBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsBroadcastPkts.setDescription('The total number of good packets received that were directed to the broadcast address. Note that this does not include multicast packets.')
rEtherStatsMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address. Note that this number does not include packets directed to the broadcast address.')
rEtherStatsCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsCRCAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsCRCAlignErrors.setDescription('The total number of packets received that had a length (excluding framing bits, but including FCS octets) of between 64 and 1518 octets, inclusive, but but had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
rEtherStatsUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsUndersizePkts.setDescription('The total number of packets received that were less than 64 octets long (excluding framing bits, but including FCS octets) and were otherwise well formed.')
rEtherStatsOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsOversizePkts.setDescription('The total number of packets received that were longer than 1518 octets (excluding framing bits, but including FCS octets) and were otherwise well formed.')
rEtherStatsFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsFragments.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsFragments.setDescription('The total number of packets received that were less than 64 octets in length (excluding framing bits but including FCS octets) and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that it is entirely normal for etherStatsFragments to increment. This is because it counts both runts (which are normal occurrences due to collisions) and noise hits.')
rEtherStatsJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsJabbers.setDescription('The total number of packets received that were longer than 1518 octets (excluding framing bits, but including FCS octets), and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that this definition of jabber is different than the definition in IEEE-802.3 section 8.2.1.5 (10BASE5) and section 10.3.1.4 (10BASE2). These documents define jabber as the condition where any packet exceeds 20 ms. The allowed range to detect jabber is between 20 ms and 150 ms.')
rEtherStatsCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsCollisions.setDescription('The best estimate of the total number of collisions on this Ethernet segment. The value returned will depend on the location of the RMON probe. Section 8.2.1.3 (10BASE-5) and section 10.3.1.3 (10BASE-2) of IEEE standard 802.3 states that a station must detect a collision, in the receive mode, if three or more stations are transmitting simultaneously. A repeater port must detect a collision when two or more stations are transmitting simultaneously. Thus a probe placed on a repeater port could record more collisions than a probe connected to a station on the same segment would. Probe location plays a much smaller role when considering 10BASE-T. 14.2.1.4 (10BASE-T) of IEEE standard 802.3 defines a collision as the simultaneous presence of signals on the DO and RD circuits (transmitting and receiving at the same time). A 10BASE-T station can only detect collisions when it is transmitting. Thus probes placed on a station and a repeater, should report the same number of collisions. Note also that an RMON probe inside a repeater should ideally report collisions between the repeater and one or more other hosts (transmit collisions as defined by IEEE 802.3k) plus receiver collisions observed on any coax segments to which the repeater is connected.')
rEtherStatsPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts64Octets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts64Octets.setDescription('The total number of packets (including bad packets) received that were 64 octets in length (excluding framing bits but including FCS octets).')
rEtherStatsPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts65to127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts65to127Octets.setDescription('The total number of packets (including bad packets) received that were between 65 and 127 octets in length inclusive (excluding framing bits but including FCS octets).')
rEtherStatsPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts128to255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts128to255Octets.setDescription('The total number of packets (including bad packets) received that were between 128 and 255 octets in length inclusive (excluding framing bits but including FCS octets).')
rEtherStatsPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts256to511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts256to511Octets.setDescription('The total number of packets (including bad packets) received that were between 256 and 511 octets in length inclusive (excluding framing bits but including FCS octets).')
rEtherStatsPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts512to1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts512to1023Octets.setDescription('The total number of packets (including bad packets) received that were between 512 and 1023 octets in length inclusive (excluding framing bits but including FCS octets).')
rEtherStatsPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherStatsPkts1024to1518Octets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsPkts1024to1518Octets.setDescription('The total number of packets (including bad packets) received that were between 1024 and 1518 octets in length inclusive (excluding framing bits but including FCS octets).')
rEtherStatsOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 20), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEtherStatsOwner.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rEtherStatsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 1, 1, 1, 21), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEtherStatsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherStatsStatus.setDescription('The status of this etherStats entry.')
rHistoryControlTable = MibTable((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1), )
if mibBuilder.loadTexts: rHistoryControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlTable.setDescription('A list of history control entries.')
rHistoryControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1), ).setIndexNames((0, "GBNServiceRMON-MIB", "rHistoryControlIndex"))
if mibBuilder.loadTexts: rHistoryControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlEntry.setDescription('A list of parameters that set up a periodic sampling of statistics. As an example, an instance of the historyControlInterval object might be named historyControlInterval.2')
rHistoryControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rHistoryControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlIndex.setDescription('An index that uniquely identifies an entry in the historyControl table. Each such entry defines a set of samples at a particular interval for an interface on the device.')
rHistoryControlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rHistoryControlDataSource.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlDataSource.setDescription('This object identifies the source of the data for which historical data was collected and placed in a media-specific table on behalf of this historyControlEntry. This source can be any interface on this device. In order to identify a particular interface, this object shall identify the instance of the ifIndex object, defined in RFC 1213 and RFC 1573 [4,6], for the desired interface. For example, if an entry were to receive data from interface #1, this object would be set to ifIndex.1. The statistics in this group reflect all packets on the local network segment attached to the identified interface. An agent may or may not be able to tell if fundamental changes to the media of the interface have occurred and necessitate an invalidation of this entry. For example, a hot-pluggable ethernet card could be pulled out and replaced by a token-ring card. In such a case, if the agent has such knowledge of the change, it is recommended that it invalidate this entry. This object may not be modified if the associated historyControlStatus object is equal to valid(1).')
rHistoryControlBucketsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rHistoryControlBucketsRequested.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlBucketsRequested.setDescription('The requested number of discrete time intervals over which data is to be saved in the part of the media-specific table associated with this historyControlEntry. When this object is created or modified, the probe should set historyControlBucketsGranted as closely to this object as is possible for the particular probe implementation and available resources.')
rHistoryControlBucketsGranted = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rHistoryControlBucketsGranted.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlBucketsGranted.setDescription('The number of discrete sampling intervals over which data shall be saved in the part of the media-specific table associated with this historyControlEntry. When the associated historyControlBucketsRequested object is created or modified, the probe should set this object as closely to the requested value as is possible for the particular probe implementation and available resources. The probe must not lower this value except as a result of a modification to the associated historyControlBucketsRequested object. There will be times when the actual number of buckets associated with this entry is less than the value of this object. In this case, at the end of each sampling interval, a new bucket will be added to the media-specific table. When the number of buckets reaches the value of this object and a new bucket is to be added to the media-specific table, the oldest bucket associated with this historyControlEntry shall be deleted by the agent so that the new bucket can be added. When the value of this object changes to a value less than the current value, entries are deleted from the media-specific table associated with this historyControlEntry. Enough of the oldest of these entries shall be deleted by the agent so that their number remains less than or equal to the new value of this object. When the value of this object changes to a value greater than the current value, the number of associated media- specific entries may be allowed to grow.')
rHistoryControlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rHistoryControlInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlInterval.setDescription("The interval in seconds over which the data is sampled for each bucket in the part of the media-specific table associated with this historyControlEntry. This interval can be set to any number of seconds between 1 and 3600 (1 hour). Because the counters in a bucket may overflow at their maximum value with no indication, a prudent manager will take into account the possibility of overflow in any of the associated counters. It is important to consider the minimum time in which any counter could overflow on a particular media type and set the historyControlInterval object to a value less than this interval. This is typically most important for the 'octets' counter in any media-specific table. For example, on an Ethernet network, the etherHistoryOctets counter could overflow in about one hour at the Ethernet's maximum utilization. This object may not be modified if the associated historyControlStatus object is equal to valid(1).")
rHistoryControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 6), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rHistoryControlOwner.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rHistoryControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 1, 1, 7), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rHistoryControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rHistoryControlStatus.setDescription('The status of this historyControl entry. Each instance of the media-specific table associated with this historyControlEntry will be deleted by the agent if this historyControlEntry is not equal to valid(1).')
rEtherHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2), )
if mibBuilder.loadTexts: rEtherHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryTable.setDescription('A list of Ethernet history entries.')
rEtherHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1), ).setIndexNames((0, "GBNServiceRMON-MIB", "rEtherHistoryIndex"), (0, "GBNServiceRMON-MIB", "rEtherHistorySampleIndex"))
if mibBuilder.loadTexts: rEtherHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryEntry.setDescription('An historical sample of Ethernet statistics on a particular Ethernet interface. This sample is associated with the historyControlEntry which set up the parameters for a regular collection of these samples. As an example, an instance of the etherHistoryPkts object might be named etherHistoryPkts.2.89')
rEtherHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
rEtherHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same historyControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
rEtherHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryIntervalStart.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
rEtherHistoryDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources during this sampling interval. Note that this number is not necessarily the number of packets dropped, it is just the number of times this condition has been detected.')
rEtherHistoryOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryOctets.setDescription('The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets).')
rEtherHistoryPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryPkts.setDescription('The number of packets (including bad packets) received during this sampling interval.')
rEtherHistoryBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryBroadcastPkts.setDescription('The number of good packets received during this sampling interval that were directed to the broadcast address.')
rEtherHistoryMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryMulticastPkts.setDescription('The number of good packets received during this sampling interval that were directed to a multicast address. Note that this number does not include packets addressed to the broadcast address.')
rEtherHistoryCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryCRCAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryCRCAlignErrors.setDescription('The number of packets received during this sampling interval that had a length (excluding framing bits but including FCS octets) between 64 and 1518 octets, inclusive, but had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error).')
rEtherHistoryUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryUndersizePkts.setDescription('The number of packets received during this sampling interval that were less than 64 octets long (excluding framing bits but including FCS octets) and were otherwise well formed.')
rEtherHistoryOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryOversizePkts.setDescription('The number of packets received during this sampling interval that were longer than 1518 octets (excluding framing bits but including FCS octets) but were otherwise well formed.')
rEtherHistoryFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryFragments.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryFragments.setDescription('The total number of packets received during this sampling interval that were less than 64 octets in length (excluding framing bits but including FCS octets) had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that it is entirely normal for etherHistoryFragments to increment. This is because it counts both runts (which are normal occurrences due to collisions) and noise hits.')
rEtherHistoryJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryJabbers.setDescription('The number of packets received during this sampling interval that were longer than 1518 octets (excluding framing bits but including FCS octets), and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that this definition of jabber is different than the definition in IEEE-802.3 section 8.2.1.5 (10BASE5) and section 10.3.1.4 (10BASE2). These documents define jabber as the condition where any packet exceeds 20 ms. The allowed range to detect jabber is between 20 ms and 150 ms.')
rEtherHistoryCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryCollisions.setDescription('The best estimate of the total number of collisions on this Ethernet segment during this sampling interval. The value returned will depend on the location of the RMON probe. Section 8.2.1.3 (10BASE-5) and section 10.3.1.3 (10BASE-2) of IEEE standard 802.3 states that a station must detect a collision, in the receive mode, if three or more stations are transmitting simultaneously. A repeater port must detect a collision when two or more stations are transmitting simultaneously. Thus a probe placed on a repeater port could record more collisions than a probe connected to a station on the same segment would. Probe location plays a much smaller role when considering 10BASE-T. 14.2.1.4 (10BASE-T) of IEEE standard 802.3 defines a collision as the simultaneous presence of signals on the DO and RD circuits (transmitting and receiving at the same time). A 10BASE-T station can only detect collisions when it is transmitting. Thus probes placed on a station and a repeater, should report the same number of collisions. Note also that an RMON probe inside a repeater should ideally report collisions between the repeater and one or more other hosts (transmit collisions as defined by IEEE 802.3k) plus receiver collisions observed on any coax segments to which the repeater is connected.')
rEtherHistoryUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEtherHistoryUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rEtherHistoryUtilization.setDescription('The best estimate of the mean physical layer network utilization on this interface during this sampling interval, in hundredths of a percent.')
rAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1), )
if mibBuilder.loadTexts: rAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmTable.setDescription('A list of alarm entries.')
rAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1), ).setIndexNames((0, "GBNServiceRMON-MIB", "rAlarmIndex"))
if mibBuilder.loadTexts: rAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmEntry.setDescription('A list of parameters that set up a periodic checking for alarm conditions. For example, an instance of the alarmValue object might be named alarmValue.8')
rAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rAlarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmIndex.setDescription('An index that uniquely identifies an entry in the alarm table. Each such entry defines a diagnostic sample at a particular interval for an object on the device.')
rAlarmInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmInterval.setDescription('The interval in seconds over which the data is sampled and compared with the rising and falling thresholds. When setting this variable, care should be taken in the case of deltaValue sampling - the interval should be set short enough that the sampled variable is very unlikely to increase or decrease by more than 2^31 - 1 during a single sampling interval. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmVariable = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmVariable.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmVariable.setDescription('The object identifier of the particular variable to be sampled. Only variables that resolve to an ASN.1 primitive type of INTEGER (INTEGER, Counter, Gauge, or TimeTicks) may be sampled. Because SNMP access control is articulated entirely in terms of the contents of MIB views, no access control mechanism exists that can restrict the value of this object to identify only those objects that exist in a particular MIB view. Because there is thus no acceptable means of restricting the read access that could be obtained through the alarm mechanism, the probe must only grant write access to this object in those views that have read access to all objects on the probe. During a set operation, if the supplied variable name is not available in the selected MIB view, a badValue error must be returned. If at any time the variable name of an established alarmEntry is no longer available in the selected MIB view, the probe must change the status of this alarmEntry to invalid(4). This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmSampleType = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmSampleType.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmSampleType.setDescription('The method of sampling the selected variable and calculating the value to be compared against the thresholds. If the value of this object is absoluteValue(1), the value of the selected variable will be compared directly with the thresholds at the end of the sampling interval. If the value of this object is deltaValue(2), the value of the selected variable at the last sample will be subtracted from the current value, and the difference compared with the thresholds. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmValue = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rAlarmValue.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmValue.setDescription('The value of the statistic during the last sampling period. For example, if the sample type is deltaValue, this value will be the difference between the samples at the beginning and end of the period. If the sample type is absoluteValue, this value will be the sampled value at the end of the period. This is the value that is compared with the rising and falling thresholds. The value during the current sampling period is not made available until the period is completed and will remain available until the next period completes.')
rAlarmStartupAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("risingAlarm", 1), ("fallingAlarm", 2), ("risingOrFallingAlarm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmStartupAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmStartupAlarm.setDescription('The alarm that may be sent when this entry is first set to valid. If the first sample after this entry becomes valid is greater than or equal to the risingThreshold and alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3), then a single rising alarm will be generated. If the first sample after this entry becomes valid is less than or equal to the fallingThreshold and alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3), then a single falling alarm will be generated. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmRisingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmRisingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is greater than or equal to this threshold, and the value at the last sampling interval was less than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is greater than or equal to this threshold and the associated alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3). After a rising event is generated, another such event will not be generated until the sampled value falls below this threshold and reaches the alarmFallingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmFallingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmFallingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is less than or equal to this threshold, and the value at the last sampling interval was greater than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is less than or equal to this threshold and the associated alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3). After a falling event is generated, another such event will not be generated until the sampled value rises above this threshold and reaches the alarmRisingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmRisingEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmRisingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmRisingEventIndex.setDescription('The index of the eventEntry that is used when a rising threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmFallingEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmFallingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmFallingEventIndex.setDescription('The index of the eventEntry that is used when a falling threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rAlarmOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 11), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmOwner.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 3, 1, 1, 12), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rAlarmStatus.setDescription('The status of this alarm entry.')
rEventTable = MibTable((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1), )
if mibBuilder.loadTexts: rEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: rEventTable.setDescription('A list of events to be generated.')
rEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1), ).setIndexNames((0, "GBNServiceRMON-MIB", "rEventIndex"))
if mibBuilder.loadTexts: rEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rEventEntry.setDescription('A set of parameters that describe an event to be generated when certain conditions are met. As an example, an instance of the eventLastTimeSent object might be named eventLastTimeSent.6')
rEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rEventIndex.setDescription('An index that uniquely identifies an entry in the event table. Each such entry defines one event that is to be generated when the appropriate conditions occur.')
rEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEventDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rEventDescription.setDescription('A comment describing this event entry.')
rEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("log", 2), ("snmp-trap", 3), ("log-and-trap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEventType.setStatus('mandatory')
if mibBuilder.loadTexts: rEventType.setDescription('The type of notification that the probe will make about this event. In the case of log, an entry is made in the log table for each event. In the case of snmp-trap, an SNMP trap is sent to one or more management stations.')
rEventCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEventCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: rEventCommunity.setDescription('If an SNMP trap is to be sent, it will be sent to the SNMP community specified by this octet string. In the future this table will be extended to include the party security mechanism. This object shall be set to a string of length zero if it is intended that that mechanism be used to specify the destination of the trap.')
rEventLastTimeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rEventLastTimeSent.setStatus('mandatory')
if mibBuilder.loadTexts: rEventLastTimeSent.setDescription('The value of sysUpTime at the time this event entry last generated an event. If this entry has not generated any events, this value will be zero.')
rEventOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 6), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEventOwner.setStatus('mandatory')
if mibBuilder.loadTexts: rEventOwner.setDescription("The entity that configured this entry and is therefore using the resources assigned to it. If this object contains a string starting with 'monitor' and has associated entries in the log table, all connected management stations should retrieve those log entries, as they may have significance to all management stations connected to this device")
rEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 1, 1, 7), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rEventStatus.setDescription('The status of this event entry. If this object is not equal to valid(1), all associated log entries shall be deleted by the agent.')
rLogTable = MibTable((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 2), )
if mibBuilder.loadTexts: rLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: rLogTable.setDescription('A list of events that have been logged.')
rLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 2, 1), ).setIndexNames((0, "GBNServiceRMON-MIB", "rLogEventIndex"), (0, "GBNServiceRMON-MIB", "rLogIndex"))
if mibBuilder.loadTexts: rLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rLogEntry.setDescription('A set of data describing an event that has been logged. For example, an instance of the logDescription object might be named logDescription.6.47')
rLogEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rLogEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rLogEventIndex.setDescription('The event entry that generated this log entry. The log identified by a particular value of this index is associated with the same eventEntry as identified by the same value of eventIndex.')
rLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rLogIndex.setDescription('An index that uniquely identifies an entry in the log table amongst those generated by the same eventEntries. These indexes are assigned beginning with 1 and increase by one with each new log entry. The association between values of logIndex and logEntries is fixed for the lifetime of each logEntry. The agent may choose to delete the oldest instances of logEntry as required because of lack of memory. It is an implementation-specific matter as to when this deletion may occur.')
rLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: rLogTime.setDescription('The value of sysUpTime when this log entry was created.')
rLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2, 9, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rLogDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rLogDescription.setDescription('An implementation dependent description of the event that activated this log entry.')
rRisingAlarm = NotificationType((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2) + (0,1)).setObjects(("GBNServiceRMON-MIB", "rAlarmIndex"), ("GBNServiceRMON-MIB", "rAlarmVariable"), ("GBNServiceRMON-MIB", "rAlarmSampleType"), ("GBNServiceRMON-MIB", "rAlarmValue"), ("GBNServiceRMON-MIB", "rAlarmRisingThreshold"))
if mibBuilder.loadTexts: rRisingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its rising threshold and generates an event that is configured for sending SNMP traps.')
rFallingAlarm = NotificationType((1, 3, 6, 1, 4, 1, 13464, 1, 2, 3, 2) + (0,2)).setObjects(("GBNServiceRMON-MIB", "rAlarmIndex"), ("GBNServiceRMON-MIB", "rAlarmVariable"), ("GBNServiceRMON-MIB", "rAlarmSampleType"), ("GBNServiceRMON-MIB", "rAlarmValue"), ("GBNServiceRMON-MIB", "rAlarmFallingThreshold"))
if mibBuilder.loadTexts: rFallingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its falling threshold and generates an event that is configured for sending SNMP traps.')
mibBuilder.exportSymbols("GBNServiceRMON-MIB", rFallingAlarm=rFallingAlarm, rEtherHistoryBroadcastPkts=rEtherHistoryBroadcastPkts, rEtherStatsOversizePkts=rEtherStatsOversizePkts, rRisingAlarm=rRisingAlarm, rEtherHistoryUtilization=rEtherHistoryUtilization, rEtherStatsStatus=rEtherStatsStatus, rLogTable=rLogTable, rHistoryControlIndex=rHistoryControlIndex, rEtherStatsOctets=rEtherStatsOctets, rEtherStatsJabbers=rEtherStatsJabbers, rAlarmOwner=rAlarmOwner, rEtherStatsTable=rEtherStatsTable, rEtherStatsMulticastPkts=rEtherStatsMulticastPkts, rHistoryControlBucketsGranted=rHistoryControlBucketsGranted, rEtherStatsPkts512to1023Octets=rEtherStatsPkts512to1023Octets, rEtherStatsOwner=rEtherStatsOwner, rEtherHistoryFragments=rEtherHistoryFragments, rEtherStatsPkts65to127Octets=rEtherStatsPkts65to127Octets, rEtherHistoryDropEvents=rEtherHistoryDropEvents, rLogTime=rLogTime, rAlarmStartupAlarm=rAlarmStartupAlarm, rEtherHistorySampleIndex=rEtherHistorySampleIndex, rStatistics=rStatistics, rEtherHistoryTable=rEtherHistoryTable, rEtherStatsPkts256to511Octets=rEtherStatsPkts256to511Octets, rHistoryControlInterval=rHistoryControlInterval, rHistoryControlTable=rHistoryControlTable, rHistoryControlBucketsRequested=rHistoryControlBucketsRequested, rEventLastTimeSent=rEventLastTimeSent, rEtherStatsUndersizePkts=rEtherStatsUndersizePkts, rHistoryControlOwner=rHistoryControlOwner, rLogIndex=rLogIndex, rLogEventIndex=rLogEventIndex, rEtherHistoryJabbers=rEtherHistoryJabbers, rEtherHistoryIntervalStart=rEtherHistoryIntervalStart, rHistoryControlEntry=rHistoryControlEntry, rAlarmEntry=rAlarmEntry, rEtherHistoryIndex=rEtherHistoryIndex, rLogDescription=rLogDescription, rEventOwner=rEventOwner, rEtherHistoryOversizePkts=rEtherHistoryOversizePkts, rAlarm=rAlarm, rAlarmStatus=rAlarmStatus, rAlarmIndex=rAlarmIndex, rAlarmRisingEventIndex=rAlarmRisingEventIndex, OwnerString=OwnerString, rEventIndex=rEventIndex, rEtherStatsIndex=rEtherStatsIndex, rEtherStatsDropEvents=rEtherStatsDropEvents, rAlarmValue=rAlarmValue, rHistory=rHistory, rEventStatus=rEventStatus, rEtherStatsPkts64Octets=rEtherStatsPkts64Octets, rEtherHistoryMulticastPkts=rEtherHistoryMulticastPkts, rEventTable=rEventTable, rEtherStatsCollisions=rEtherStatsCollisions, rEtherStatsPkts=rEtherStatsPkts, rEtherHistoryOctets=rEtherHistoryOctets, EntryStatus=EntryStatus, rAlarmVariable=rAlarmVariable, rAlarmSampleType=rAlarmSampleType, rEtherStatsEntry=rEtherStatsEntry, rEventCommunity=rEventCommunity, rEtherStatsPkts1024to1518Octets=rEtherStatsPkts1024to1518Octets, rHistoryControlDataSource=rHistoryControlDataSource, rAlarmFallingEventIndex=rAlarmFallingEventIndex, rEtherStatsCRCAlignErrors=rEtherStatsCRCAlignErrors, rEtherStatsFragments=rEtherStatsFragments, rEventEntry=rEventEntry, rAlarmRisingThreshold=rAlarmRisingThreshold, rEventType=rEventType, rHistoryControlStatus=rHistoryControlStatus, rEtherStatsPkts128to255Octets=rEtherStatsPkts128to255Octets, rEvent=rEvent, rEtherHistoryEntry=rEtherHistoryEntry, rLogEntry=rLogEntry, rEtherHistoryPkts=rEtherHistoryPkts, rAlarmFallingThreshold=rAlarmFallingThreshold, rEtherStatsBroadcastPkts=rEtherStatsBroadcastPkts, rAlarmInterval=rAlarmInterval, rEtherHistoryUndersizePkts=rEtherHistoryUndersizePkts, rEtherHistoryCRCAlignErrors=rEtherHistoryCRCAlignErrors, rAlarmTable=rAlarmTable, rEtherHistoryCollisions=rEtherHistoryCollisions, rEtherStatsDataSource=rEtherStatsDataSource, rEventDescription=rEventDescription)

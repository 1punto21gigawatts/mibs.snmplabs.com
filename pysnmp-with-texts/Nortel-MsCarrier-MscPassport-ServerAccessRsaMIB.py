#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
Counter32, RowPointer, Unsigned32, RowStatus, Integer32, DisplayString, StorageType = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Counter32", "RowPointer", "Unsigned32", "RowStatus", "Integer32", "DisplayString", "StorageType")
EnterpriseDateAndTime, DigitString, NonReplicated, AsciiStringIndex, Link, Hex, AsciiString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "EnterpriseDateAndTime", "DigitString", "NonReplicated", "AsciiStringIndex", "Link", "Hex", "AsciiString")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Bits, IpAddress, TimeTicks, Counter32, ModuleIdentity, Gauge32, Unsigned32, ObjectIdentity, Counter64, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "IpAddress", "TimeTicks", "Counter32", "ModuleIdentity", "Gauge32", "Unsigned32", "ObjectIdentity", "Counter64", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
serverAccessRsaMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116))
mscRsa = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108))
mscRsaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 1), )
if mibBuilder.loadTexts: mscRsaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaRowStatusTable.setDescription('This entry controls the addition and deletion of mscRsa components.')
mscRsaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"))
if mibBuilder.loadTexts: mscRsaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaRowStatusEntry.setDescription('A single entry in the table represents a single mscRsa component.')
mscRsaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRsa components. These components can be added and deleted.')
mscRsaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRsaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaStorageType.setDescription('This variable represents the storage type value for the mscRsa tables.')
mscRsaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: mscRsaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaIndex.setDescription('This variable represents the index for the mscRsa tables.')
mscRsaOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 10), )
if mibBuilder.loadTexts: mscRsaOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaOptionsTable.setDescription('The Options group defines provisionable attributes associated with the Rsa component.')
mscRsaOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"))
if mibBuilder.loadTexts: mscRsaOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaOptionsEntry.setDescription('An entry in the mscRsaOptionsTable.')
mscRsaLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 10, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaLogicalProcessor.setDescription('This attribute specifies the logical processor on which the RSA process will execute.')
mscRsaStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 11), )
if mibBuilder.loadTexts: mscRsaStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscRsaStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"))
if mibBuilder.loadTexts: mscRsaStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaStateEntry.setDescription('An entry in the mscRsaStateTable.')
mscRsaAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscRsaOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscRsaUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscRsaOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 12), )
if mibBuilder.loadTexts: mscRsaOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaOperationalTable.setDescription('The Operational group defines operational attributes associated with the Rsa component.')
mscRsaOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"))
if mibBuilder.loadTexts: mscRsaOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaOperationalEntry.setDescription('An entry in the mscRsaOperationalTable.')
mscRsaMaxRsiConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaMaxRsiConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaMaxRsiConnections.setDescription('This attribute specifies the maximum number of RSI connections which can be supported by this Rsa.')
mscRsaRsiConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaRsiConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaRsiConnections.setDescription('This attribute specifies the number of active RSI connections currently supported by the Rsa component.')
mscRsaDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2))
mscRsaDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 1), )
if mibBuilder.loadTexts: mscRsaDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscRsaDna components.')
mscRsaDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaIndex"))
if mibBuilder.loadTexts: mscRsaDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscRsaDna component.')
mscRsaDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRsaDna components. These components cannot be added nor deleted.')
mscRsaDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRsaDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaStorageType.setDescription('This variable represents the storage type value for the mscRsaDna tables.')
mscRsaDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscRsaDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaIndex.setDescription('This variable represents the index for the mscRsaDna tables.')
mscRsaDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 10), )
if mibBuilder.loadTexts: mscRsaDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaAddressTable.setDescription("The Address group contains attributes common to all Dna's. Every Dna used in the network is defined with this group of 2 attributes. The string of address digits is complemented by the type of address or Npi. These attributes are used to interpret the format of the address digits.")
mscRsaDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaIndex"))
if mibBuilder.loadTexts: mscRsaDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaAddressEntry.setDescription('An entry in the mscRsaDnaAddressTable.')
mscRsaDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. An address may belong to the X.121 or E.164 numbering plans. X.121 is used in packet switched data networks.')
mscRsaDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaDataNetworkAddress.setDescription('The Dna attribute contains digits which form a unique identifier of the customer interface. It can be compared (approximation only) to a telephone number where each phone number identifies a unique telephone set. Dna digits are selected and assigned by network operators.')
mscRsaDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 11), )
if mibBuilder.loadTexts: mscRsaDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaOutgoingOptionsTable.setDescription('The OutgoingOptions group defines call options of a Dna for calls which are made out of the interface represented by the Dna. These options are not used for calls arriving to the interface represented by the Dna.')
mscRsaDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaIndex"))
if mibBuilder.loadTexts: mscRsaDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaOutgoingOptionsEntry.setDescription('An entry in the mscRsaDnaOutgoingOptionsTable.')
mscRsaDnaOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaOutCalls.setDescription("This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed, then outgoing calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Outgoing Calls Barred' feature for Dnas in that outgoing calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this Dna to be usable.")
mscRsaDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 12), )
if mibBuilder.loadTexts: mscRsaDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaIncomingOptionsTable.setDescription('IncomingOptions defines the set of options for incoming calls. These options are used for calls arriving to the interface represented by the Dna. For calls originated from the interface, IncomingOptions attributes are not used.')
mscRsaDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaIndex"))
if mibBuilder.loadTexts: mscRsaDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaIncomingOptionsEntry.setDescription('An entry in the mscRsaDnaIncomingOptionsTable.')
mscRsaDnaIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaIncCalls.setDescription("This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then incoming calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Incoming Calls Barred' feature for Dna's in that incoming calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this Dna to be usable.")
mscRsaDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaIncAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) from the open (non-CUG) part of the network are permitted. It also permits incoming calls from DTEs that have Outgoing Access capabilities. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Closed User Group with Incoming Access' feature for Dnas in that incoming access is granted if this attribute is set to a value of allowed.")
mscRsaDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2))
mscRsaDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 1), )
if mibBuilder.loadTexts: mscRsaDnaCugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of mscRsaDnaCug components.')
mscRsaDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaCugIndex"))
if mibBuilder.loadTexts: mscRsaDnaCugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single mscRsaDnaCug component.')
mscRsaDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaCugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRsaDnaCug components. These components can be added and deleted.')
mscRsaDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaCugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRsaDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaCugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugStorageType.setDescription('This variable represents the storage type value for the mscRsaDnaCug tables.')
mscRsaDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: mscRsaDnaCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugIndex.setDescription('This variable represents the index for the mscRsaDnaCug tables.')
mscRsaDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10), )
if mibBuilder.loadTexts: mscRsaDnaCugCugOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugCugOptionsTable.setDescription("Attributes in this group define ClosedUserGroup options associated with this particular interlockCode. Dna's with the same Cug (interlockCode) can make calls within this group. Various combinations which permit or prevent calls in the same Cug group are defined here.")
mscRsaDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaDnaCugIndex"))
if mibBuilder.loadTexts: mscRsaDnaCugCugOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugCugOptionsEntry.setDescription('An entry in the mscRsaDnaCugCugOptionsTable.')
mscRsaDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaCugType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugType.setDescription('This attribute specifies the Cug type - the Cug is either a national Cug, or an international Cug. International closed user groups are usually established between DTEs for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTEs for which there is no X.75 Gateway between. (National Cugs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the Cug is a national Cug, in which case, the dnic should be left at its default value since it is not part of a national Cug. If this attribute is set to international, then the Cug is an international Cug, in which case, the dnic should be set appropriately as part of the Cug interlockCode.')
mscRsaDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaCugDnic.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugDnic.setDescription('This attribute specifies the dnic (Data Network ID Code) of the Cug by which packet networks are identified. This attribute is not applicable if the Cug is a national Cug, as specified by the Cug type attribute. There are usually 1 or 2 dnics assigned per country, for public networks. The U.S. is an exception where each BOC has a dnic. Also, a group of private networks can have its own dnic. dnic value is not an arbitrary number. It is assigned by international agreement and controlled by ITU-T.')
mscRsaDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaDnaCugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugInterlockCode.setDescription("This attribute specifies the Cug identifier of a national or international Cug call. It is an arbitrary number and it also can be called Cug in some descriptions. Interfaces (Dna's) defined with this number can make calls to Dna's with the same interlockCode.")
mscRsaDnaCugPreferential = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaCugPreferential.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugPreferential.setDescription('This attribute, if set to yes indicates that this Cug is the preferential Cug, in which case it will be used during the call establishment phase if the DTE has not explicitly specified a Cug index in the call request packet. If set to no, then this Cug is not the preferential Cug. Only one of the Cugs associated with a particular Dna can be the preferential Cug - only one Cug can have this attribute set to yes.')
mscRsaDnaCugOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaCugOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugOutCalls.setDescription("This attribute, if set to allowed indicates that outgoing calls (from the DTE into the network) can be made using this particular Cug. If set to a value of disallowed, then outgoing calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Outgoing Calls Barred' feature for Cugs in that outgoing calls are barred if this attribute is set to a value of disallowed.")
mscRsaDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaCugIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugIncCalls.setDescription("This attribute, if set to allowed indicates that incoming calls (from the network to the DTE) can be made using this particular Cug. If set to disallowed, then incoming calls cannot be made using this Cug - such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Incoming Calls Barred' feature for Cugs in that incoming calls are barred if this attribute is set to a value of disallowed.")
mscRsaDnaCugPrivileged = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 2, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaDnaCugPrivileged.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaDnaCugPrivileged.setDescription('This attribute, if set to yes indicates that this Cug is a privileged Cug. In DPN, at least one side of a call setup within a Cug must have the Cug as a privileged Cug. If set to no, then the Cug is not privileged. If both the local DTE and the remote DTE subscribe to the Cug, but it is not privileged, then the call will be cleared. This attribute is typically used for a host DTE which must accept calls from many other DTEs in which case the other DTEs cannot call one another, but can call the host. In this example, the host would have the privileged Cug, and the other DTEs would belong to the same Cug, but it would not be privileged.')
mscRsaVncsAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3))
mscRsaVncsAccessRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 1), )
if mibBuilder.loadTexts: mscRsaVncsAccessRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRowStatusTable.setDescription('This entry controls the addition and deletion of mscRsaVncsAccess components.')
mscRsaVncsAccessRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaVncsAccessIndex"))
if mibBuilder.loadTexts: mscRsaVncsAccessRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRowStatusEntry.setDescription('A single entry in the table represents a single mscRsaVncsAccess component.')
mscRsaVncsAccessRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaVncsAccessRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRsaVncsAccess components. These components can be added and deleted.')
mscRsaVncsAccessComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRsaVncsAccessStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessStorageType.setDescription('This variable represents the storage type value for the mscRsaVncsAccess tables.')
mscRsaVncsAccessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscRsaVncsAccessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessIndex.setDescription('This variable represents the index for the mscRsaVncsAccess tables.')
mscRsaVncsAccessProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 10), )
if mibBuilder.loadTexts: mscRsaVncsAccessProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessProvisionedTable.setDescription('The Provisioned group defines provisioned attributes associated with the VncsAccess component.')
mscRsaVncsAccessProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaVncsAccessIndex"))
if mibBuilder.loadTexts: mscRsaVncsAccessProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessProvisionedEntry.setDescription('An entry in the mscRsaVncsAccessProvisionedTable.')
mscRsaVncsAccessTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRsaVncsAccessTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessTimeToLive.setDescription('This attribute specifies the length of time VNCS requests are allowed to remain queued for transmission before they are considered too old and are discarded. This attribute should be set in considereation with the voice application timeout interval.')
mscRsaVncsAccessStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 11), )
if mibBuilder.loadTexts: mscRsaVncsAccessStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscRsaVncsAccessStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaVncsAccessIndex"))
if mibBuilder.loadTexts: mscRsaVncsAccessStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessStateEntry.setDescription('An entry in the mscRsaVncsAccessStateTable.')
mscRsaVncsAccessAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscRsaVncsAccessOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscRsaVncsAccessUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscRsaVncsAccessOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 12), )
if mibBuilder.loadTexts: mscRsaVncsAccessOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessOperationalTable.setDescription('The Operational group defines operational attributes associated with the VncsAccess component.')
mscRsaVncsAccessOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaVncsAccessIndex"))
if mibBuilder.loadTexts: mscRsaVncsAccessOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessOperationalEntry.setDescription('An entry in the mscRsaVncsAccessOperationalTable.')
mscRsaVncsAccessRequestsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessRequestsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRequestsSent.setDescription('This attribute counts the number of translation requests sent to VNCS. This counter wraps to zero when it reaches its maximum value.')
mscRsaVncsAccessRepliesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessRepliesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRepliesReceived.setDescription('This attribute counts the number of translation replies received from VNCS. This counter wraps to zero when it reaches its maximum value.')
mscRsaVncsAccessRequestsQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessRequestsQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRequestsQueued.setDescription('This attribute indicates the number of translation requests queued for transmission to VNCS.')
mscRsaVncsAccessRequestsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 3, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaVncsAccessRequestsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaVncsAccessRequestsDiscarded.setDescription('This attribute counts the number of translation requests discarded before being sent to VNCS. Requests are discarded if the queue becomes too large or the VNCS server is unavailable. This counter wraps to zero when it reaches its maximum value.')
mscRsaConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4))
mscRsaConnectionRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 1), )
if mibBuilder.loadTexts: mscRsaConnectionRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRsaConnection components.')
mscRsaConnectionRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"))
if mibBuilder.loadTexts: mscRsaConnectionRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionRowStatusEntry.setDescription('A single entry in the table represents a single mscRsaConnection component.')
mscRsaConnectionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRsaConnection components. These components cannot be added nor deleted.')
mscRsaConnectionComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRsaConnectionStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionStorageType.setDescription('This variable represents the storage type value for the mscRsaConnection tables.')
mscRsaConnectionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: mscRsaConnectionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionIndex.setDescription('This variable represents the index for the mscRsaConnection tables.')
mscRsaConnectionOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 10), )
if mibBuilder.loadTexts: mscRsaConnectionOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionOperationalTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** The Operational group defines operational attributes associated with the Connection component.')
mscRsaConnectionOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"))
if mibBuilder.loadTexts: mscRsaConnectionOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionOperationalEntry.setDescription('An entry in the mscRsaConnectionOperationalTable.')
mscRsaConnectionRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionRemoteName.setDescription('This attribute specifies an ASCII string identifier for the remote module which is retrieved from the call request as user data.')
mscRsaConnectionCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("initializing", 0), ("creatingVc", 1), ("calling", 2), ("acceptingCall", 3), ("registeringFmo", 4), ("establishingLapf", 5), ("dataTransfer", 6), ("clearingCall", 7), ("terminating", 8), ("terminatingVc", 9), ("terminated", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionCallState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionCallState.setDescription('This attribute indicates the state of the connection. The normal state for the connection is dataTransfer. The other states are transient states used to setup or clear the connection.')
mscRsaConnectionServerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 11), )
if mibBuilder.loadTexts: mscRsaConnectionServerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionServerStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** The ServerStatistics group provides individual server usage statistics for the connection.')
mscRsaConnectionServerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"))
if mibBuilder.loadTexts: mscRsaConnectionServerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionServerStatsEntry.setDescription('An entry in the mscRsaConnectionServerStatsTable.')
mscRsaConnectionVncsRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVncsRequests.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVncsRequests.setDescription('This attribute counts the number of VNCS translation requests sent or received on this connection.')
mscRsaConnectionVncsReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVncsReplies.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVncsReplies.setDescription('This attribute counts the number of VNCS translation replies sent or received on this connection.')
mscRsaConnectionLapfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 12), )
if mibBuilder.loadTexts: mscRsaConnectionLapfStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the LAPF status.')
mscRsaConnectionLapfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"))
if mibBuilder.loadTexts: mscRsaConnectionLapfStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfStatusEntry.setDescription('An entry in the mscRsaConnectionLapfStatusTable.')
mscRsaConnectionLapfState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7))).clone(namedValues=NamedValues(("disconnected", 1), ("linkSetup", 2), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfState.setDescription('This attribute shows the current state of the LAPF interface. The normal states are informationTransfer and waitingAck. Since the LAPF interface is not over a physical link the other states are transitional.')
mscRsaConnectionLapfQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfQueueSize.setDescription('This attribute indicates the number of frames in the LAPF transmit queue.')
mscRsaConnectionLapfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13), )
if mibBuilder.loadTexts: mscRsaConnectionLapfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the LAPF statistics.')
mscRsaConnectionLapfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"))
if mibBuilder.loadTexts: mscRsaConnectionLapfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfStatsEntry.setDescription('An entry in the mscRsaConnectionLapfStatsTable.')
mscRsaConnectionLapfStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfStateChanges.setDescription('This attribute counts the number of times the LAPF interface has changed state. While the LAPF interface is in informationTransfer state, this counter will increment on each expiry of idleProbeTimer as its state goes from informationTransfer to waitingAck and back. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfRemoteBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfRemoteBusy.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfRemoteBusy.setDescription('This attribute counts the number of times transmission of an I-frame was unsuccessful due to a perceived remote busy condition (window closed or remote busy). When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfAckTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfAckTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfAckTimeouts.setDescription('This attribute counts the number of times the ackTimer has expired. Frequent increments of this counter indicate improper values have been chosen for ackTimer and ackDelayTimer between the local and remote ends. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfRejectFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfRejectFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfRejectFramesRx.setDescription('This attribute counts the number of REJ frames received. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfIFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesTx.setDescription('This attribute counts the number of I-frames transmitted. An I- frame may be counted more than once if there are retransmissions. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfIFramesTxDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesTxDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesTxDiscarded.setDescription('This attribute counts the number of transmit I-frames that have been discarded. Discard reasons may be one of the following: 1. The frame length is beyond allowed limit. 2. The LAPF interface is in disconnected state. 3. The transmit queue has been purged because the queue length has reached the reset threshold. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfIFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesRx.setDescription('This attribute counts the number of I-frames received. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionLapfIFramesRxDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesRxDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionLapfIFramesRxDiscarded.setDescription('This attribute counts the number of received I-frames that have been discarded. The discard reasons are: 1. Incorrect frame size. 2. Frame is out of sequence. 3. Frame received while not in informationTransfer or waitingAck state. When this count reaches maximum, it wraps to zero.')
mscRsaConnectionVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2))
mscRsaConnectionVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 1), )
if mibBuilder.loadTexts: mscRsaConnectionVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRsaConnectionVc components.')
mscRsaConnectionVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionVcIndex"))
if mibBuilder.loadTexts: mscRsaConnectionVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcRowStatusEntry.setDescription('A single entry in the table represents a single mscRsaConnectionVc component.')
mscRsaConnectionVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRsaConnectionVc components. These components cannot be added nor deleted.')
mscRsaConnectionVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRsaConnectionVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcStorageType.setDescription('This variable represents the storage type value for the mscRsaConnectionVc tables.')
mscRsaConnectionVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscRsaConnectionVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcIndex.setDescription('This variable represents the index for the mscRsaConnectionVc tables.')
mscRsaConnectionVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10), )
if mibBuilder.loadTexts: mscRsaConnectionVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCadTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
mscRsaConnectionVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionVcIndex"))
if mibBuilder.loadTexts: mscRsaConnectionVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCadEntry.setDescription('An entry in the mscRsaConnectionVcCadTable.')
mscRsaConnectionVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2), ("frf10spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcType.setDescription('This attribute displays the type of call, pvc,svc,spvc or frf10spvc.')
mscRsaConnectionVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscRsaConnectionVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscRsaConnectionVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscRsaConnectionVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscRsaConnectionVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscRsaConnectionVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscRsaConnectionVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscRsaConnectionVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscRsaConnectionVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscRsaConnectionVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscRsaConnectionVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscRsaConnectionVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscRsaConnectionVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPathReliability.setDescription('This attribute displays the path reliability.')
mscRsaConnectionVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscRsaConnectionVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscRsaConnectionVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscRsaConnectionVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
mscRsaConnectionVcRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
mscRsaConnectionVcRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
mscRsaConnectionVcEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
mscRsaConnectionVcEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
mscRsaConnectionVcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
mscRsaConnectionVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11), )
if mibBuilder.loadTexts: mscRsaConnectionVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcIntdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscRsaConnectionVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionVcIndex"))
if mibBuilder.loadTexts: mscRsaConnectionVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcIntdEntry.setDescription('An entry in the mscRsaConnectionVcIntdTable.')
mscRsaConnectionVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscRsaConnectionVcCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscRsaConnectionVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscRsaConnectionVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscRsaConnectionVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscRsaConnectionVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscRsaConnectionVcCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscRsaConnectionVcFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12), )
if mibBuilder.loadTexts: mscRsaConnectionVcFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcFrdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
mscRsaConnectionVcFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionVcIndex"))
if mibBuilder.loadTexts: mscRsaConnectionVcFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcFrdEntry.setDescription('An entry in the mscRsaConnectionVcFrdTable.')
mscRsaConnectionVcFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
mscRsaConnectionVcCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
mscRsaConnectionVcNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
mscRsaConnectionVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
mscRsaConnectionVcCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
mscRsaConnectionVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
mscRsaConnectionVcNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
mscRsaConnectionVcFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscRsaConnectionVcOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscRsaConnectionVcPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscRsaConnectionVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
mscRsaConnectionVcSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
mscRsaConnectionVcPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscRsaConnectionVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
mscRsaConnectionVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
mscRsaConnectionVcOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscRsaConnectionVcPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscRsaConnectionVcDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 417), )
if mibBuilder.loadTexts: mscRsaConnectionVcDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcDmepTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
mscRsaConnectionVcDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 417, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionVcIndex"), (0, "Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", "mscRsaConnectionVcDmepValue"))
if mibBuilder.loadTexts: mscRsaConnectionVcDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcDmepEntry.setDescription('An entry in the mscRsaConnectionVcDmepTable.')
mscRsaConnectionVcDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 108, 4, 2, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRsaConnectionVcDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRsaConnectionVcDmepValue.setDescription('This variable represents both the value and the index for the mscRsaConnectionVcDmepTable.')
serverAccessRsaGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 1))
serverAccessRsaGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 1, 1))
serverAccessRsaGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 1, 1, 3))
serverAccessRsaGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 1, 1, 3, 2))
serverAccessRsaCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 3))
serverAccessRsaCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 3, 1))
serverAccessRsaCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 3, 1, 3))
serverAccessRsaCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 116, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-ServerAccessRsaMIB", mscRsaConnectionVcIntdTable=mscRsaConnectionVcIntdTable, mscRsaConnectionVcFrmCongestedToSubnet=mscRsaConnectionVcFrmCongestedToSubnet, mscRsaConnectionVcCallReferenceNumber=mscRsaConnectionVcCallReferenceNumber, mscRsaConnectionComponentName=mscRsaConnectionComponentName, mscRsaConnectionLapfStatusEntry=mscRsaConnectionLapfStatusEntry, mscRsaDnaRowStatusTable=mscRsaDnaRowStatusTable, mscRsaConnectionVncsRequests=mscRsaConnectionVncsRequests, mscRsaConnectionVcStartTime=mscRsaConnectionVcStartTime, mscRsaConnectionVcDmepValue=mscRsaConnectionVcDmepValue, mscRsaConnectionVcCallingNpi=mscRsaConnectionVcCallingNpi, mscRsaDnaCugCugOptionsEntry=mscRsaDnaCugCugOptionsEntry, mscRsaConnectionVcPktRetryTimeouts=mscRsaConnectionVcPktRetryTimeouts, serverAccessRsaCapabilitiesCA02A=serverAccessRsaCapabilitiesCA02A, mscRsaDnaOutCalls=mscRsaDnaOutCalls, mscRsaConnectionVcPreviousState=mscRsaConnectionVcPreviousState, mscRsaConnectionServerStatsTable=mscRsaConnectionServerStatsTable, mscRsaConnectionVcRcosFromNetwork=mscRsaConnectionVcRcosFromNetwork, mscRsaDnaAddressTable=mscRsaDnaAddressTable, mscRsaConnectionLapfIFramesTxDiscarded=mscRsaConnectionLapfIFramesTxDiscarded, mscRsaConnectionVcCallReferenceNumberDecimal=mscRsaConnectionVcCallReferenceNumberDecimal, mscRsaConnectionVcDmepEntry=mscRsaConnectionVcDmepEntry, mscRsaConnectionVcType=mscRsaConnectionVcType, mscRsaDnaDataNetworkAddress=mscRsaDnaDataNetworkAddress, serverAccessRsaGroupCA02=serverAccessRsaGroupCA02, mscRsaConnectionVc=mscRsaConnectionVc, mscRsaVncsAccessRepliesReceived=mscRsaVncsAccessRepliesReceived, mscRsaDnaCugPreferential=mscRsaDnaCugPreferential, serverAccessRsaCapabilities=serverAccessRsaCapabilities, mscRsaStateEntry=mscRsaStateEntry, mscRsaConnectionVcRowStatus=mscRsaConnectionVcRowStatus, mscRsaDnaAddressEntry=mscRsaDnaAddressEntry, mscRsaOptionsTable=mscRsaOptionsTable, mscRsaConnectionVcEmissionPriorityToNetwork=mscRsaConnectionVcEmissionPriorityToNetwork, mscRsaVncsAccessStorageType=mscRsaVncsAccessStorageType, mscRsaConnectionVcIntdEntry=mscRsaConnectionVcIntdEntry, mscRsaConnectionVcFrdTable=mscRsaConnectionVcFrdTable, mscRsaConnectionServerStatsEntry=mscRsaConnectionServerStatsEntry, mscRsaOperationalEntry=mscRsaOperationalEntry, mscRsaVncsAccessRowStatusEntry=mscRsaVncsAccessRowStatusEntry, mscRsaConnectionLapfQueueSize=mscRsaConnectionLapfQueueSize, mscRsaDna=mscRsaDna, mscRsaOperationalTable=mscRsaOperationalTable, mscRsaConnectionOperationalTable=mscRsaConnectionOperationalTable, mscRsaMaxRsiConnections=mscRsaMaxRsiConnections, serverAccessRsaGroupCA02A=serverAccessRsaGroupCA02A, mscRsaVncsAccessStateTable=mscRsaVncsAccessStateTable, mscRsaConnectionVcDiagnosticCode=mscRsaConnectionVcDiagnosticCode, mscRsaConnectionVcMaxSubnetPktSize=mscRsaConnectionVcMaxSubnetPktSize, mscRsaDnaCugComponentName=mscRsaDnaCugComponentName, mscRsaConnectionVcDuplicatesFromSubnet=mscRsaConnectionVcDuplicatesFromSubnet, mscRsaVncsAccessIndex=mscRsaVncsAccessIndex, mscRsaConnectionLapfRemoteBusy=mscRsaConnectionLapfRemoteBusy, mscRsaConnectionLapfAckTimeouts=mscRsaConnectionLapfAckTimeouts, mscRsaConnectionVcStorageType=mscRsaConnectionVcStorageType, mscRsaDnaOutgoingOptionsEntry=mscRsaDnaOutgoingOptionsEntry, mscRsaOptionsEntry=mscRsaOptionsEntry, mscRsaDnaIncAccess=mscRsaDnaIncAccess, mscRsaVncsAccessRequestsDiscarded=mscRsaVncsAccessRequestsDiscarded, mscRsaDnaCugOutCalls=mscRsaDnaCugOutCalls, mscRsaVncsAccessOperationalState=mscRsaVncsAccessOperationalState, mscRsaUsageState=mscRsaUsageState, mscRsaVncsAccessRowStatus=mscRsaVncsAccessRowStatus, mscRsaVncsAccess=mscRsaVncsAccess, mscRsaConnectionVcElapsedTimeTillNow=mscRsaConnectionVcElapsedTimeTillNow, mscRsaLogicalProcessor=mscRsaLogicalProcessor, mscRsaVncsAccessProvisionedEntry=mscRsaVncsAccessProvisionedEntry, mscRsaConnectionVcFrmLossTimeouts=mscRsaConnectionVcFrmLossTimeouts, mscRsaConnectionVcOoSeqPktCntExceeded=mscRsaConnectionVcOoSeqPktCntExceeded, mscRsaDnaCugType=mscRsaDnaCugType, mscRsaOperationalState=mscRsaOperationalState, mscRsaRsiConnections=mscRsaRsiConnections, mscRsaDnaCugRowStatus=mscRsaDnaCugRowStatus, mscRsaConnectionLapfRejectFramesRx=mscRsaConnectionLapfRejectFramesRx, mscRsaDnaCugDnic=mscRsaDnaCugDnic, mscRsaConnectionVcCombErrorsFromSubnet=mscRsaConnectionVcCombErrorsFromSubnet, mscRsaDnaIncomingOptionsTable=mscRsaDnaIncomingOptionsTable, mscRsaConnectionCallState=mscRsaConnectionCallState, mscRsaConnectionVcPeakRetryQueueSize=mscRsaConnectionVcPeakRetryQueueSize, mscRsaComponentName=mscRsaComponentName, mscRsaVncsAccessStateEntry=mscRsaVncsAccessStateEntry, mscRsaConnection=mscRsaConnection, mscRsaConnectionVcNotDataXferToSubnet=mscRsaConnectionVcNotDataXferToSubnet, mscRsaVncsAccessAdminState=mscRsaVncsAccessAdminState, mscRsaVncsAccessTimeToLive=mscRsaVncsAccessTimeToLive, mscRsaVncsAccessOperationalTable=mscRsaVncsAccessOperationalTable, mscRsaConnectionVcRowStatusEntry=mscRsaConnectionVcRowStatusEntry, mscRsaConnectionLapfIFramesRx=mscRsaConnectionLapfIFramesRx, mscRsaDnaComponentName=mscRsaDnaComponentName, mscRsaConnectionVcPriority=mscRsaConnectionVcPriority, mscRsaConnectionVcFastSelectCall=mscRsaConnectionVcFastSelectCall, mscRsaDnaRowStatusEntry=mscRsaDnaRowStatusEntry, mscRsaVncsAccessProvisionedTable=mscRsaVncsAccessProvisionedTable, mscRsaConnectionVcAccountingEnabled=mscRsaConnectionVcAccountingEnabled, mscRsaConnectionVcDataPath=mscRsaConnectionVcDataPath, mscRsaVncsAccessUsageState=mscRsaVncsAccessUsageState, mscRsaRowStatusEntry=mscRsaRowStatusEntry, mscRsaDnaOutgoingOptionsTable=mscRsaDnaOutgoingOptionsTable, mscRsaDnaCugCugOptionsTable=mscRsaDnaCugCugOptionsTable, mscRsaConnectionVcCannotForwardToSubnet=mscRsaConnectionVcCannotForwardToSubnet, mscRsaConnectionVcPeakOoSeqFrmForwarded=mscRsaConnectionVcPeakOoSeqFrmForwarded, mscRsaDnaIncomingOptionsEntry=mscRsaDnaIncomingOptionsEntry, mscRsaVncsAccessRequestsQueued=mscRsaVncsAccessRequestsQueued, mscRsaDnaCugRowStatusEntry=mscRsaDnaCugRowStatusEntry, mscRsaVncsAccessComponentName=mscRsaVncsAccessComponentName, mscRsaVncsAccessRequestsSent=mscRsaVncsAccessRequestsSent, mscRsaConnectionRowStatusEntry=mscRsaConnectionRowStatusEntry, mscRsaConnectionVcSegmentsRx=mscRsaConnectionVcSegmentsRx, mscRsaDnaIndex=mscRsaDnaIndex, mscRsaConnectionVncsReplies=mscRsaConnectionVncsReplies, mscRsaConnectionVcPeakOoSeqByteCount=mscRsaConnectionVcPeakOoSeqByteCount, mscRsaDnaCugIncCalls=mscRsaDnaCugIncCalls, mscRsaConnectionVcCalledDna=mscRsaConnectionVcCalledDna, mscRsaConnectionVcRowStatusTable=mscRsaConnectionVcRowStatusTable, mscRsaConnectionLapfIFramesRxDiscarded=mscRsaConnectionLapfIFramesRxDiscarded, mscRsaStateTable=mscRsaStateTable, mscRsaConnectionLapfIFramesTx=mscRsaConnectionLapfIFramesTx, mscRsaStorageType=mscRsaStorageType, mscRsaConnectionVcCalledLcn=mscRsaConnectionVcCalledLcn, mscRsaConnectionVcPathReliability=mscRsaConnectionVcPathReliability, mscRsaDnaRowStatus=mscRsaDnaRowStatus, mscRsaConnectionVcState=mscRsaConnectionVcState, mscRsaConnectionLapfStatusTable=mscRsaConnectionLapfStatusTable, mscRsaVncsAccessRowStatusTable=mscRsaVncsAccessRowStatusTable, mscRsaConnectionVcIndex=mscRsaConnectionVcIndex, mscRsaConnectionRowStatusTable=mscRsaConnectionRowStatusTable, mscRsaDnaCugIndex=mscRsaDnaCugIndex, mscRsaVncsAccessOperationalEntry=mscRsaVncsAccessOperationalEntry, mscRsaDnaCugInterlockCode=mscRsaDnaCugInterlockCode, mscRsa=mscRsa, mscRsaDnaCugStorageType=mscRsaDnaCugStorageType, mscRsaDnaCug=mscRsaDnaCug, mscRsaConnectionRemoteName=mscRsaConnectionRemoteName, mscRsaConnectionLapfStateChanges=mscRsaConnectionLapfStateChanges, mscRsaConnectionVcPeakOoSeqPktCount=mscRsaConnectionVcPeakOoSeqPktCount, mscRsaConnectionVcCalledNpi=mscRsaConnectionVcCalledNpi, mscRsaConnectionVcCadEntry=mscRsaConnectionVcCadEntry, mscRsaConnectionLapfStatsEntry=mscRsaConnectionLapfStatsEntry, serverAccessRsaGroup=serverAccessRsaGroup, mscRsaConnectionVcOutOfRangeFrmFromSubnet=mscRsaConnectionVcOutOfRangeFrmFromSubnet, mscRsaRowStatusTable=mscRsaRowStatusTable, mscRsaConnectionVcPreviousDiagnosticCode=mscRsaConnectionVcPreviousDiagnosticCode, mscRsaConnectionVcCallingLcn=mscRsaConnectionVcCallingLcn, serverAccessRsaGroupCA=serverAccessRsaGroupCA, mscRsaConnectionVcDmepTable=mscRsaConnectionVcDmepTable, mscRsaConnectionVcCallingDna=mscRsaConnectionVcCallingDna, serverAccessRsaCapabilitiesCA02=serverAccessRsaCapabilitiesCA02, mscRsaAdminState=mscRsaAdminState, serverAccessRsaCapabilitiesCA=serverAccessRsaCapabilitiesCA, serverAccessRsaMIB=serverAccessRsaMIB, mscRsaConnectionLapfStatsTable=mscRsaConnectionLapfStatsTable, mscRsaConnectionVcSegmentSize=mscRsaConnectionVcSegmentSize, mscRsaRowStatus=mscRsaRowStatus, mscRsaConnectionRowStatus=mscRsaConnectionRowStatus, mscRsaIndex=mscRsaIndex, mscRsaConnectionVcCadTable=mscRsaConnectionVcCadTable, mscRsaDnaStorageType=mscRsaDnaStorageType, mscRsaConnectionVcAccountingEnd=mscRsaConnectionVcAccountingEnd, mscRsaDnaNumberingPlanIndicator=mscRsaDnaNumberingPlanIndicator, mscRsaDnaCugRowStatusTable=mscRsaDnaCugRowStatusTable, mscRsaDnaCugPrivileged=mscRsaDnaCugPrivileged, mscRsaConnectionIndex=mscRsaConnectionIndex, mscRsaConnectionVcSegmentsSent=mscRsaConnectionVcSegmentsSent, mscRsaConnectionVcOoSeqByteCntExceeded=mscRsaConnectionVcOoSeqByteCntExceeded, mscRsaConnectionVcSendSequenceNumber=mscRsaConnectionVcSendSequenceNumber, mscRsaConnectionVcRcosToNetwork=mscRsaConnectionVcRcosToNetwork, mscRsaConnectionStorageType=mscRsaConnectionStorageType, mscRsaDnaIncCalls=mscRsaDnaIncCalls, mscRsaConnectionOperationalEntry=mscRsaConnectionOperationalEntry, mscRsaConnectionVcFrdEntry=mscRsaConnectionVcFrdEntry, mscRsaConnectionVcEmissionPriorityFromNetwork=mscRsaConnectionVcEmissionPriorityFromNetwork, mscRsaConnectionLapfState=mscRsaConnectionLapfState, mscRsaConnectionVcSubnetRecoveries=mscRsaConnectionVcSubnetRecoveries, mscRsaConnectionVcComponentName=mscRsaConnectionVcComponentName, mscRsaConnectionVcNotDataXferFromSubnet=mscRsaConnectionVcNotDataXferFromSubnet)

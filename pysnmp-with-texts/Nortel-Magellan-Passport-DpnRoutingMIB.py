#
# PySNMP MIB module Nortel-Magellan-Passport-DpnRoutingMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-DpnRoutingMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
rtg, rtgIndex = mibBuilder.importSymbols("Nortel-Magellan-Passport-BaseRoutingMIB", "rtg", "rtgIndex")
RowPointer, Integer32, RowStatus, PassportCounter64, Unsigned32, DisplayString, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowPointer", "Integer32", "RowStatus", "PassportCounter64", "Unsigned32", "DisplayString", "StorageType")
NonReplicated, AsciiStringIndex = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "NonReplicated", "AsciiStringIndex")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, MibIdentifier, Integer32, NotificationType, iso, TimeTicks, ModuleIdentity, IpAddress, Bits, Counter32, Counter64, ObjectIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibIdentifier", "Integer32", "NotificationType", "iso", "TimeTicks", "ModuleIdentity", "IpAddress", "Bits", "Counter32", "Counter64", "ObjectIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dpnRoutingMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21))
rtgDpn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4))
rtgDpnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 1), )
if mibBuilder.loadTexts: rtgDpnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRowStatusTable.setDescription('This entry controls the addition and deletion of rtgDpn components.')
rtgDpnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"))
if mibBuilder.loadTexts: rtgDpnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpn component.')
rtgDpnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpn components. These components cannot be added nor deleted.')
rtgDpnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnStorageType.setDescription('This variable represents the storage type value for the rtgDpn tables.')
rtgDpnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: rtgDpnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnIndex.setDescription('This variable represents the index for the rtgDpn tables.')
rtgDpnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11), )
if mibBuilder.loadTexts: rtgDpnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnProvTable.setDescription('This group contains the provisioning data for the DpnAddressPlan. Attributes in this group must be set to allow the DpnAddressPlan component to function properly.')
rtgDpnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"))
if mibBuilder.loadTexts: rtgDpnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnProvEntry.setDescription('An entry in the rtgDpnProvTable.')
rtgDpnLogicalNetworkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLogicalNetworkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLogicalNetworkNumber.setDescription('This attribute specifies the Logical Network Number for the DpnAddressPlan. Since only one instance of this component can exist, this value is always set to one. It is provided here to be consistent with other address plans and so that it can be queried.')
rtgDpnRoutingId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnRoutingId.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRoutingId.setDescription('This attribute specifies the Routing Identifier (RID) associated with the Passport node. The RID is used to identify a group of one or more interconnected Passport nodes (called a subnet) supporting the transport of DPN traffic. Its value must be the same as that of the other Passport nodes in this subnet and different from that of all RMs and other Passport subnets in the network. The routingId must be set when a DpnAddressPlan component is configured on an Passport node. Changing the value of the routingId will cause the node to restart.')
rtgDpnModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1909))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnModuleId.setDescription('This attribute specifies the Module Identifier (MID) associated with the Passport node. The MID is used to identify an Passport node supporting the transport of DPN traffic. Its value must be different from that of all MIDs assigned to Passport nodes in this RID subnet (interconnected Passport nodes sharing a RID) and AMs in clusters supported by this subnet. If routing zones are used, it must also be unique from all other MIDs in this zone. The moduleId must be set when a DpnAddressPlan component is configured on an Passport node. Changing the value of the moduleId will cause the node to restart.')
rtgDpnDelayMetricCutOff = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 250)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnDelayMetricCutOff.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnDelayMetricCutOff.setDescription('This attribute specifies the delay metric value beyond which a destination RID should be considered unreachable. That is, if a delay metric to a RID is equal to or greater than this value then the RID is considered to be unreachable in the delay class of service. Lowering this value has the effect of speeding up the detection of the loss of reachability to a RID. It also reduces the amount of Routing Table Update (RTU) traffic generated in this scenario. Care must be taken to ensure that the value chosen is big enough for the longest delay path in the network. This attribute is optional; a default of 128 is used when it is not set. It is recommended that all nodes in the network be provisioned with the same cut off value.')
rtgDpnThroughputMetricCutOff = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(128, 245)).clone(245)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnThroughputMetricCutOff.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnThroughputMetricCutOff.setDescription('This attribute specifies the throughput metric value beyond which a destination RID should be considered unreachable. That is, if a throughput metric to a RID is equal to or greater than this value then the RID will be considered to be unreachable in the throughput class of service. Lowering this value has the effect of speeding up the detection of the loss of reachability to a RID. It also reduces the amount of Routing Table Update (RTU) traffic generated in this scenario.Care must be taken to ensure that the value chosen is big enough for the longest throughput path in the network. This attribute is optional; a default of 245 is used when it is not set. It is recommended that all nodes in the network be provisioned with the same cut off value.')
rtgDpnForwardingPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("loadspread", 0), ("loadshare", 1), ("loadspreadFast", 2))).clone('loadspread')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnForwardingPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnForwardingPolicy.setDescription('This attribute specifies the forwarding policy used by packet forwarding to handle DPN traffic on a Passport module. When this attribute is set to loadshare, DPN traffic is shared among preferred links in a link group in proportion to the available bandwidth on each link; the traffic is not forwarded in an order- preserved manner and needs resequencing at the destination, but the available bandwidth in a link group is utilized efficiently. When this attribute is set to loadspread, DPN traffic is forwarded in an order-preserved manner along a randomly selected route; the traffic sticks to a particular link in a link group, and will not spill over to other links in the link group unless there is congestion on the selected link. When this attribute is set to loadspreadFast, DPN traffic is forwarded in an order-preserved manner along a randomly selected route; the traffic sticks to a particular link in a link group, and will not spill over to other links in the link group. Choosing this value may improve throughput but traffic may be discarded in the presence of congestion. It is recommended that all nodes in the network be provisioned with the same forwarding policy.')
rtgDpnDelayMetricRangeBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnDelayMetricRangeBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnDelayMetricRangeBoundary.setDescription('This attribute specifies the total path delay metric below which the variance value specified for delay COS and a low metric range is used, and at or above which the variance value specified for delay COS and a high metric range is used. This attribute defaults to 0, so that the variance value specified for delay COS and a high metric range is used for all delay paths. If this attribute is set to 2147483647, the variance value specified for delay COS and a low metric range is used for all delay paths.')
rtgDpnTputMetricRangeBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnTputMetricRangeBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnTputMetricRangeBoundary.setDescription('This attribute specifies the total path throughput metric below which the variance value specified for throughput COS and a low metric range is used, and at or above which the variance value specified for throughput COS and a high metric range is used. This attribute defaults to 0, so that the variance value specified for throughput COS and a high metric range is used for all delay paths. If this attribute is set to 2147483647, the variance value specified for throughput COS and a low metric range is used for all throughput paths.')
rtgDpnConStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13), )
if mibBuilder.loadTexts: rtgDpnConStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnConStatsTable.setDescription('This group of attributes provides statistics about the behavior of the DpnAddressPlan component. The statistics concern the distribution of routing information, required to support the routing of DPN traffic, to all Passport nodes in the RID subnet.')
rtgDpnConStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"))
if mibBuilder.loadTexts: rtgDpnConStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnConStatsEntry.setDescription('An entry in the rtgDpnConStatsTable.')
rtgDpnControlPktTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnControlPktTx.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnControlPktTx.setDescription('This attribute counts the total number of internal Passport DPN control packets, originating from this node, sent to other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The Packets received from a neighbor node and forwarded to other neighbors are not counted. The counter wraps around to zero when the maximum value is reached.')
rtgDpnControlPktRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnControlPktRx.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnControlPktRx.setDescription('This attribute counts the total number of internal Passport DPN control packets received from other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The counter wraps around to zero when the maximum value is reached.')
rtgDpnControlBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnControlBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnControlBytesTx.setDescription('This attribute counts the total number of internal Passport DPN control packet bytes, originating from the node, sent to other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. Packet bytes received from a neighbor node and forwarded to other neighbors are not counted. The counter wraps around to zero when the maximum value is reached.')
rtgDpnControlBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnControlBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnControlBytesRx.setDescription('This attribute counts the total number of internal Passport DPN control packet bytes received from other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The counter wraps around to zero when the maximum value is reached.')
rtgDpnOutOfSequencePkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnOutOfSequencePkt.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnOutOfSequencePkt.setDescription('This attribute counts the total number of internal Passport DPN control packets received and rejected. These packets contained old sequence numbers. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The counter wraps around to zero when the maximum value is reached.')
rtgDpnFwdStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14), )
if mibBuilder.loadTexts: rtgDpnFwdStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnFwdStatsTable.setDescription('This group of attributes provides statistics for the traffic handled by DPN packet forwarding on this module. The statistics can be used to monitor the connectionless traffic profile on this module.')
rtgDpnFwdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"))
if mibBuilder.loadTexts: rtgDpnFwdStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnFwdStatsEntry.setDescription('An entry in the rtgDpnFwdStatsTable.')
rtgDpnTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnTotalPackets.setDescription('This attribute counts the total number of delay and throughput packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnThroughputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnThroughputPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnThroughputPackets.setDescription('This attribute counts the throughput packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnDelayPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnDelayPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnDelayPackets.setDescription('This attribute counts the delay packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnNormalReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnNormalReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnNormalReliabilityPackets.setDescription('This attribute counts the normal reliability packets handled by DPN packet forwarding on this module when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnHighReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnHighReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnHighReliabilityPackets.setDescription('This attribute counts the high reliability packets handled by DPN packet forwarding on this module when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnDiscardNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnDiscardNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnDiscardNoRoute.setDescription('This attribute counts the packets discarded when DPN packet forwarding has failed to find a route to forward the packets on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnInterruptingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnInterruptingPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnInterruptingPackets.setDescription('This attribute counts the total number of multimedia packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnDiscardLpCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 14, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnDiscardLpCongested.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnDiscardLpCongested.setDescription('This attribute counts the packets that have been discarded by packet forwarding due to LP congestion on this module. A packet encounters LP congestion when there is insufficient shared memory. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnCallServerModuleRidsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 232), )
if mibBuilder.loadTexts: rtgDpnCallServerModuleRidsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCallServerModuleRidsTable.setDescription('This attribute indicates the RIDs of the Call Server Resource Modules (CSRMs) currently in use to support Call Server functions, such as SCR and DCR, for the Passport subnet. Up to two CSRMs can be in use to support such Call Server functions. Note that packets destined to Call Server functions are routed to the closest CSRM supporting the required server functionality.')
rtgDpnCallServerModuleRidsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 232, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCallServerModuleRidsValue"))
if mibBuilder.loadTexts: rtgDpnCallServerModuleRidsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCallServerModuleRidsEntry.setDescription('An entry in the rtgDpnCallServerModuleRidsTable.')
rtgDpnCallServerModuleRidsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 232, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCallServerModuleRidsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCallServerModuleRidsValue.setDescription('This variable represents both the value and the index for the rtgDpnCallServerModuleRidsTable.')
rtgDpnSubnetMidsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 233), )
if mibBuilder.loadTexts: rtgDpnSubnetMidsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnSubnetMidsTable.setDescription('This attribute indicates which of the ReachableMidInfo (Mid) components refer to MIDs which are members of the Passport subnet. This list does not include AMs connected to the subnet.')
rtgDpnSubnetMidsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 233, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnSubnetMidsValue"))
if mibBuilder.loadTexts: rtgDpnSubnetMidsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnSubnetMidsEntry.setDescription('An entry in the rtgDpnSubnetMidsTable.')
rtgDpnSubnetMidsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 233, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnSubnetMidsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnSubnetMidsValue.setDescription('This variable represents both the value and the index for the rtgDpnSubnetMidsTable.')
rtgDpnVarianceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 343), )
if mibBuilder.loadTexts: rtgDpnVarianceTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnVarianceTable.setDescription('This attribute specifies the variance values for high and low metric ranges, for each class of service (COS). A variance value is the maximum allowed difference in metric between the best path and the second path, as a percentage of the best path metric. High and low metric ranges are defined for each COS by the delayMetricRangeBoundary and tputMetricRangeBoundary attributes, and refer to total path metrics. When a variance value for a certain COS and metric range is set to the default value of 0, only equal metric paths can be used under that COS when the best path metric is in that range. When it is set to a value greater than 0, an alternate path which is safe (that is, non-looping) and which has a metric within this percentage of the best path metric can be used as a multipath. The special value of 9999 signifies an infinite variance, so that any safe alternate path may be used in addition to the single best path, regardless of its metric.')
rtgDpnVarianceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 343, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnVarianceCosIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnVarianceMetricRangeIndex"))
if mibBuilder.loadTexts: rtgDpnVarianceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnVarianceEntry.setDescription('An entry in the rtgDpnVarianceTable.')
rtgDpnVarianceCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 343, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("delay", 0), ("throughput", 1))))
if mibBuilder.loadTexts: rtgDpnVarianceCosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnVarianceCosIndex.setDescription('This variable represents the next to last index for the rtgDpnVarianceTable.')
rtgDpnVarianceMetricRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 343, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("low", 0), ("high", 1))))
if mibBuilder.loadTexts: rtgDpnVarianceMetricRangeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnVarianceMetricRangeIndex.setDescription('This variable represents the final index for the rtgDpnVarianceTable.')
rtgDpnVarianceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 343, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 500), ValueRangeConstraint(9999, 9999), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnVarianceValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnVarianceValue.setDescription('This variable represents an individual value for the rtgDpnVarianceTable.')
rtgDpnRid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2))
rtgDpnRidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 1), )
if mibBuilder.loadTexts: rtgDpnRidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of rtgDpnRid components.')
rtgDpnRidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"))
if mibBuilder.loadTexts: rtgDpnRidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnRid component.')
rtgDpnRidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnRid components. These components cannot be added nor deleted.')
rtgDpnRidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnRidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidStorageType.setDescription('This variable represents the storage type value for the rtgDpnRid tables.')
rtgDpnRidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)))
if mibBuilder.loadTexts: rtgDpnRidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidIndex.setDescription('This variable represents the index for the rtgDpnRid tables.')
rtgDpnRidOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 10), )
if mibBuilder.loadTexts: rtgDpnRidOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes is maintained by the DpnAddressPlan component to provide information about the RIDs reachable in the network.')
rtgDpnRidOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"))
if mibBuilder.loadTexts: rtgDpnRidOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidOperEntry.setDescription('An entry in the rtgDpnRidOperTable.')
rtgDpnRidDpnDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidDpnDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDpnDelayMetric.setDescription("This attribute indicates the minimum DPN delay metric to the destination RID. The delay metric associated with a path is computed by the routing system by translating the smallest delayMetric calculated for the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metric displayed is that of the best path to the destination. This metric is advertised to neighbor RMs and Passports in a different RID subnet. A metric value of 255 means the RID is unreachable in the delay class of service. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID. A metric value of 252 indicates that the destination RID is that of a Network Module (NM).")
rtgDpnRidDpnTputMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidDpnTputMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDpnTputMetric.setDescription("This attribute indicates the minimum DPN throughput metric to the destination RID. The throughput metric associated with a path is computed by the routing system by translating the smallest tputMetric calculated for the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metric displayed is that of the best path to the destination. This metric is advertised to neighbor RMs and Passports in a different RID subnet. A metric value of 255 means the RID is unreachable in the throughput class of service. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID.")
rtgDpnRidDelayNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 226), )
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination RID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest delay metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an RM. If no link groups are listed then the destination is not reachable in the delay class of service (except in the case of the local node's RID). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
rtgDpnRidDelayNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 226, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidDelayNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsEntry.setDescription('An entry in the rtgDpnRidDelayNextHopLinkGroupsTable.')
rtgDpnRidDelayNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 226, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsIndex.setDescription('This variable represents the index for the rtgDpnRidDelayNextHopLinkGroupsTable.')
rtgDpnRidDelayNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 226, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the rtgDpnRidDelayNextHopLinkGroupsTable.')
rtgDpnRidTputNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 227), )
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination RID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest throughput metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an RM. If no link groups are listed then the destination is not reachable in the throughput class of service (except in the case of the local node's RID). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
rtgDpnRidTputNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 227, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidTputNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsEntry.setDescription('An entry in the rtgDpnRidTputNextHopLinkGroupsTable.')
rtgDpnRidTputNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 227, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsIndex.setDescription('This variable represents the index for the rtgDpnRidTputNextHopLinkGroupsTable.')
rtgDpnRidTputNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 227, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the rtgDpnRidTputNextHopLinkGroupsTable.')
rtgDpnRidDelayPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 328), )
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total delay traffic flows to the destination which are sent over each delay path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
rtgDpnRidDelayPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 328, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidDelayPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsEntry.setDescription('An entry in the rtgDpnRidDelayPathTrafficProportionsTable.')
rtgDpnRidDelayPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 328, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsIndex.setDescription('This variable represents the index for the rtgDpnRidDelayPathTrafficProportionsTable.')
rtgDpnRidDelayPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 328, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayPathTrafficProportionsValue.setDescription('This variable represents an individual value for the rtgDpnRidDelayPathTrafficProportionsTable.')
rtgDpnRidTputPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 329), )
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total throughput traffic flows to the destination which are sent over each throughput path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
rtgDpnRidTputPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 329, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidTputPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsEntry.setDescription('An entry in the rtgDpnRidTputPathTrafficProportionsTable.')
rtgDpnRidTputPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 329, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsIndex.setDescription('This variable represents the index for the rtgDpnRidTputPathTrafficProportionsTable.')
rtgDpnRidTputPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 329, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputPathTrafficProportionsValue.setDescription('This variable represents an individual value for the rtgDpnRidTputPathTrafficProportionsTable.')
rtgDpnRidDelayMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 339), )
if mibBuilder.loadTexts: rtgDpnRidDelayMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay metrics of up to two paths to the destination RID. The delay metric associated with a path is computed by the routing system based on the sum of the delays associated with the links in the path to the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the RID is unreachable in the delay class of service. A metric value of 2147483647 for the second path only means that there is only one viable delay path to the destination. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID. Metric values of 2147483646 indicate that the destination RID is that of a Network Module (NM).")
rtgDpnRidDelayMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 339, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidDelayMetricIndex"))
if mibBuilder.loadTexts: rtgDpnRidDelayMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayMetricEntry.setDescription('An entry in the rtgDpnRidDelayMetricTable.')
rtgDpnRidDelayMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 339, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnRidDelayMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayMetricIndex.setDescription('This variable represents the index for the rtgDpnRidDelayMetricTable.')
rtgDpnRidDelayMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 339, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidDelayMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidDelayMetricValue.setDescription('This variable represents an individual value for the rtgDpnRidDelayMetricTable.')
rtgDpnRidTputMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 340), )
if mibBuilder.loadTexts: rtgDpnRidTputMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput metrics of up to two paths to the destination RID. The throughput metric associated with a path is computed by the routing system based on the sum of the bandwidth associated with the links in the path to the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the RID is unreachable in the throughput class of service. A metric value of 2147483647 for the second path only means that there is only one viable throughput path to the destination. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID.")
rtgDpnRidTputMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 340, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidTputMetricIndex"))
if mibBuilder.loadTexts: rtgDpnRidTputMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputMetricEntry.setDescription('An entry in the rtgDpnRidTputMetricTable.')
rtgDpnRidTputMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 340, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnRidTputMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputMetricIndex.setDescription('This variable represents the index for the rtgDpnRidTputMetricTable.')
rtgDpnRidTputMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 340, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidTputMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidTputMetricValue.setDescription('This variable represents an individual value for the rtgDpnRidTputMetricTable.')
rtgDpnRidMid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2))
rtgDpnRidMidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2, 1), )
if mibBuilder.loadTexts: rtgDpnRidMidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidMidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of rtgDpnRidMid components.')
rtgDpnRidMidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidMidIndex"))
if mibBuilder.loadTexts: rtgDpnRidMidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidMidRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnRidMid component.')
rtgDpnRidMidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidMidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidMidRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnRidMid components. These components cannot be added nor deleted.')
rtgDpnRidMidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidMidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidMidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnRidMidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidMidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidMidStorageType.setDescription('This variable represents the storage type value for the rtgDpnRidMid tables.')
rtgDpnRidMidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2046)))
if mibBuilder.loadTexts: rtgDpnRidMidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidMidIndex.setDescription('This variable represents the index for the rtgDpnRidMid tables.')
rtgDpnMid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3))
rtgDpnMidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 1), )
if mibBuilder.loadTexts: rtgDpnMidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of rtgDpnMid components.')
rtgDpnMidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"))
if mibBuilder.loadTexts: rtgDpnMidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnMid component.')
rtgDpnMidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnMid components. These components cannot be added nor deleted.')
rtgDpnMidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnMidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidStorageType.setDescription('This variable represents the storage type value for the rtgDpnMid tables.')
rtgDpnMidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2046)))
if mibBuilder.loadTexts: rtgDpnMidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidIndex.setDescription('This variable represents the index for the rtgDpnMid tables.')
rtgDpnMidOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 10), )
if mibBuilder.loadTexts: rtgDpnMidOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes is maintained by DpnAddressPlan component to provide information about the MIDs reachable, or once reachable, through the local RID subnet.')
rtgDpnMidOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"))
if mibBuilder.loadTexts: rtgDpnMidOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidOperEntry.setDescription('An entry in the rtgDpnMidOperTable.')
rtgDpnMidSubstituteRid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidSubstituteRid.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidSubstituteRid.setDescription("This attribute indicates the substitute RID in use for the MID. This RID will be substituted for the RID in DPN packets destined to the local node's RID and the MID in question when the MID is unreachable (when, for example, all links to an AM from the Passport subnet are down). It will also be used in the case where the path through the substitute RID is better than that available through the subnet's connection to the cluster containing the AM MID. Substitute RIDs are learned from AM clusters that are supported by two RIDs (the Passport subnet's RID and another one). The operator can check this value to determine if a possible back up route to an AM exists. When there are no delayNextHopLinkGroups or tputNextHopLinkGroups shown to reach the MID, the substitute RID will be used. A value of 128 indicates that no substitute RID is known.")
rtgDpnMidDelayNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 228), )
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination MID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest delay metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an AM. If no link groups are listed then the destination is not reachable in the delay class of service (except in the case of the local node's MID, or when a substitute RID path is available). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
rtgDpnMidDelayNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 228, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidDelayNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsEntry.setDescription('An entry in the rtgDpnMidDelayNextHopLinkGroupsTable.')
rtgDpnMidDelayNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 228, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsIndex.setDescription('This variable represents the index for the rtgDpnMidDelayNextHopLinkGroupsTable.')
rtgDpnMidDelayNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 228, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the rtgDpnMidDelayNextHopLinkGroupsTable.')
rtgDpnMidTputNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 229), )
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination MID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest throughput metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an AM. If no link groups are listed then the destination is not reachable in the throughput class of service (except in the case of the local node's MID, or when a substitute RID path is available). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
rtgDpnMidTputNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 229, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidTputNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsEntry.setDescription('An entry in the rtgDpnMidTputNextHopLinkGroupsTable.')
rtgDpnMidTputNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 229, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsIndex.setDescription('This variable represents the index for the rtgDpnMidTputNextHopLinkGroupsTable.')
rtgDpnMidTputNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 229, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the rtgDpnMidTputNextHopLinkGroupsTable.')
rtgDpnMidDelayMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 330), )
if mibBuilder.loadTexts: rtgDpnMidDelayMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay metrics of up to two paths to the destination MID. The delay metric associated with a path is computed by the routing system based on the sum of the delays associated with the links (or estimated delays for links to AMs) in the path to the destination. It is computed for every possible path to the destination and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the MID is unreachable in the delay class of service (though it might still be reachable via its substitute RID). A metric value of 2147483647 for the second path only means that there is only one viable delay path to the destination.A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's MID.")
rtgDpnMidDelayMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 330, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidDelayMetricIndex"))
if mibBuilder.loadTexts: rtgDpnMidDelayMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayMetricEntry.setDescription('An entry in the rtgDpnMidDelayMetricTable.')
rtgDpnMidDelayMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 330, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnMidDelayMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayMetricIndex.setDescription('This variable represents the index for the rtgDpnMidDelayMetricTable.')
rtgDpnMidDelayMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 330, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidDelayMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayMetricValue.setDescription('This variable represents an individual value for the rtgDpnMidDelayMetricTable.')
rtgDpnMidTputMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 331), )
if mibBuilder.loadTexts: rtgDpnMidTputMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput metrics to the destination MID. The throughput metric associated with a path is computed by the routing system based on the sum of the bandwidth associated with the links (or estimated bandwidth for links to AMs) in the path to the destination. It is computed for every possible path to the destination and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the MID is unreachable in the throughput class of service (though it might still be reachable via its substitute RID). A metric value of 2147483647 for the second path only means that there is only one viable throughput path to the destination. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID.")
rtgDpnMidTputMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 331, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidTputMetricIndex"))
if mibBuilder.loadTexts: rtgDpnMidTputMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputMetricEntry.setDescription('An entry in the rtgDpnMidTputMetricTable.')
rtgDpnMidTputMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 331, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnMidTputMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputMetricIndex.setDescription('This variable represents the index for the rtgDpnMidTputMetricTable.')
rtgDpnMidTputMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 331, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidTputMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputMetricValue.setDescription('This variable represents an individual value for the rtgDpnMidTputMetricTable.')
rtgDpnMidDelayPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 332), )
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total delay traffic flows to the destination which are sent over each delay path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
rtgDpnMidDelayPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 332, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidDelayPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsEntry.setDescription('An entry in the rtgDpnMidDelayPathTrafficProportionsTable.')
rtgDpnMidDelayPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 332, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsIndex.setDescription('This variable represents the index for the rtgDpnMidDelayPathTrafficProportionsTable.')
rtgDpnMidDelayPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 332, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidDelayPathTrafficProportionsValue.setDescription('This variable represents an individual value for the rtgDpnMidDelayPathTrafficProportionsTable.')
rtgDpnMidTputPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 333), )
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total throughput traffic flows to the destination which are sent over each throughput path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
rtgDpnMidTputPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 333, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnMidTputPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsEntry.setDescription('An entry in the rtgDpnMidTputPathTrafficProportionsTable.')
rtgDpnMidTputPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 333, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsIndex.setDescription('This variable represents the index for the rtgDpnMidTputPathTrafficProportionsTable.')
rtgDpnMidTputPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 3, 333, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnMidTputPathTrafficProportionsValue.setDescription('This variable represents an individual value for the rtgDpnMidTputPathTrafficProportionsTable.')
rtgDpnCs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4))
rtgDpnCsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 1), )
if mibBuilder.loadTexts: rtgDpnCsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of rtgDpnCs components.')
rtgDpnCsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"))
if mibBuilder.loadTexts: rtgDpnCsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnCs component.')
rtgDpnCsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnCs components. These components cannot be added nor deleted.')
rtgDpnCsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnCsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsStorageType.setDescription('This variable represents the storage type value for the rtgDpnCs tables.')
rtgDpnCsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7, 8, 10, 11, 12, 14))).clone(namedValues=NamedValues(("dcr", 1), ("nui", 4), ("crd", 5), ("lnui", 6), ("scr", 7), ("npm", 8), ("grman", 10), ("gscr", 11), ("gdcr", 12), ("lcr", 14))))
if mibBuilder.loadTexts: rtgDpnCsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsIndex.setDescription('This variable represents the index for the rtgDpnCs tables.')
rtgDpnCsDelayNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 230), )
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the Call Server Resource Module (CSRM) supporting the server. DPN server traffic will be load shared across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest delay metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to a CSRM. If no link groups are listed then the server is not reachable in the delay class of service. Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.')
rtgDpnCsDelayNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 230, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsDelayNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsEntry.setDescription('An entry in the rtgDpnCsDelayNextHopLinkGroupsTable.')
rtgDpnCsDelayNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 230, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsIndex.setDescription('This variable represents the index for the rtgDpnCsDelayNextHopLinkGroupsTable.')
rtgDpnCsDelayNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 230, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the rtgDpnCsDelayNextHopLinkGroupsTable.')
rtgDpnCsTputNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 231), )
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput link group, or groups, that are being used to reach a neighbor which is either the next hop in the path to the Call Server Resource Module (CSRM) supporting the server. DPN server traffic will be load shared across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest throughput metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to the CSRM. If no link groups are listed then the server is not reachable in the throughput class of service. Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.')
rtgDpnCsTputNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 231, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsTputNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsEntry.setDescription('An entry in the rtgDpnCsTputNextHopLinkGroupsTable.')
rtgDpnCsTputNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 231, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsIndex.setDescription('This variable represents the index for the rtgDpnCsTputNextHopLinkGroupsTable.')
rtgDpnCsTputNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 231, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the rtgDpnCsTputNextHopLinkGroupsTable.')
rtgDpnCsDelayMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 334), )
if mibBuilder.loadTexts: rtgDpnCsDelayMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayMetricTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay metrics of up to two paths to the server supported on a Call Server Resource Module (CSRM). The delay metric associated with a path is computed by the routing system based on the sum of the delays associated with the links in the path to the CSRM supporting the server. It is computed for every possible path to the server and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the server is unreachable in the delay class of service. A metric value of 2147483647 for the second path only means that there is only one viable delay path to the destination. A value of 0 indicates that no cost is associated with the path to the destination.')
rtgDpnCsDelayMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 334, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsDelayMetricIndex"))
if mibBuilder.loadTexts: rtgDpnCsDelayMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayMetricEntry.setDescription('An entry in the rtgDpnCsDelayMetricTable.')
rtgDpnCsDelayMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 334, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnCsDelayMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayMetricIndex.setDescription('This variable represents the index for the rtgDpnCsDelayMetricTable.')
rtgDpnCsDelayMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 334, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsDelayMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayMetricValue.setDescription('This variable represents an individual value for the rtgDpnCsDelayMetricTable.')
rtgDpnCsTputMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 335), )
if mibBuilder.loadTexts: rtgDpnCsTputMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputMetricTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput metrics of up to two paths to reach the server supported on a Call Server Resource Module (CSRM). The throughput metric associated with a path is computed by the routing system based on the sum of the bandwidth associated with the links in the path to the CSRM supporting the server. It is computed for every possible path to the server and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the server is unreachable in the throughput class of service. A metric value of 2147483647 for the second path only means that there is only one viable throughput path to the destination. A value of 0 indicates that no cost is associated with the path to the destination.')
rtgDpnCsTputMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 335, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsTputMetricIndex"))
if mibBuilder.loadTexts: rtgDpnCsTputMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputMetricEntry.setDescription('An entry in the rtgDpnCsTputMetricTable.')
rtgDpnCsTputMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 335, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnCsTputMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputMetricIndex.setDescription('This variable represents the index for the rtgDpnCsTputMetricTable.')
rtgDpnCsTputMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 335, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsTputMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputMetricValue.setDescription('This variable represents an individual value for the rtgDpnCsTputMetricTable.')
rtgDpnCsDelayPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 336), )
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total delay traffic flows to the destination which are sent over each delay path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
rtgDpnCsDelayPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 336, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsDelayPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsEntry.setDescription('An entry in the rtgDpnCsDelayPathTrafficProportionsTable.')
rtgDpnCsDelayPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 336, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsIndex.setDescription('This variable represents the index for the rtgDpnCsDelayPathTrafficProportionsTable.')
rtgDpnCsDelayPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 336, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsDelayPathTrafficProportionsValue.setDescription('This variable represents an individual value for the rtgDpnCsDelayPathTrafficProportionsTable.')
rtgDpnCsTputPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 337), )
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total throughput traffic flows to the destination which are sent over each throughput path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
rtgDpnCsTputPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 337, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnCsTputPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsEntry.setDescription('An entry in the rtgDpnCsTputPathTrafficProportionsTable.')
rtgDpnCsTputPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 337, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsIndex.setDescription('This variable represents the index for the rtgDpnCsTputPathTrafficProportionsTable.')
rtgDpnCsTputPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 4, 337, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnCsTputPathTrafficProportionsValue.setDescription('This variable represents an individual value for the rtgDpnCsTputPathTrafficProportionsTable.')
rtgDpnLg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5))
rtgDpnLgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 1), )
if mibBuilder.loadTexts: rtgDpnLgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of rtgDpnLg components.')
rtgDpnLgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnLgIndex"))
if mibBuilder.loadTexts: rtgDpnLgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnLg component.')
rtgDpnLgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnLg components. These components cannot be added nor deleted.')
rtgDpnLgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnLgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgStorageType.setDescription('This variable represents the storage type value for the rtgDpnLg tables.')
rtgDpnLgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 12)))
if mibBuilder.loadTexts: rtgDpnLgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgIndex.setDescription('This variable represents the index for the rtgDpnLg tables.')
rtgDpnLgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3), )
if mibBuilder.loadTexts: rtgDpnLgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes provides information about the gateways in use to reach Passports, RMs and AMs connected to this Passport node.')
rtgDpnLgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnLgIndex"))
if mibBuilder.loadTexts: rtgDpnLgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgOperEntry.setDescription('An entry in the rtgDpnLgOperTable.')
rtgDpnLgFarEndType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("em", 0), ("rm", 1), ("am", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgFarEndType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgFarEndType.setDescription('This attribute indicates the type of the far end module (EM, AM or RM).')
rtgDpnLgFarEndRid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgFarEndRid.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgFarEndRid.setDescription('This attribute indicates the far end neighbor RID. If the neighbor is an AM then the RID is that of the Passport node.')
rtgDpnLgFarEndMid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1910))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgFarEndMid.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgFarEndMid.setDescription('This attribute indicates the far end neighbor MID.')
rtgDpnLgDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgDelayMetric.setDescription('This attribute indicates the delay metric calculated for the link group. If the type of the far end switch is AM, the delay metric is calculated for MID routing, ranging from 1 to 2147483647. If the type of the far end switch is EM or RM, the delay metric, ranging from 1 to 255, is based on the measured round trip delay of the delay preferred links in the group. A link group with a low metric value is preferable to one with a higher value as it is associated with lower delay facilities.')
rtgDpnLgTputMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 5, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLgTputMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLgTputMetric.setDescription('This attribute indicates the throughput metric calculated for the link group. If the type of the far end switch is AM, the throughput metric is calculated for MID routing, ranging from 1 to 2147483647. If the type of the far end switch is EM or RM, the throughput metric, ranging from 1 to 255, is based on the sum of the bandwidth available for all links in the group. A link group with a low metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities.')
rtgDpnLpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6))
rtgDpnLpStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 1), )
if mibBuilder.loadTexts: rtgDpnLpStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of rtgDpnLpStats components.')
rtgDpnLpStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnLpStatsIndex"))
if mibBuilder.loadTexts: rtgDpnLpStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnLpStats component.')
rtgDpnLpStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnLpStats components. These components cannot be added nor deleted.')
rtgDpnLpStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnLpStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsStorageType.setDescription('This variable represents the storage type value for the rtgDpnLpStats tables.')
rtgDpnLpStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: rtgDpnLpStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsIndex.setDescription('This variable represents the index for the rtgDpnLpStats tables.')
rtgDpnLpStatsFwdStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10), )
if mibBuilder.loadTexts: rtgDpnLpStatsFwdStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsFwdStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes provides DPN packet forwarding statistics for this LP. The statistics can be used to monitor the connectionless traffic profile on this LP.')
rtgDpnLpStatsFwdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnLpStatsIndex"))
if mibBuilder.loadTexts: rtgDpnLpStatsFwdStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsFwdStatsEntry.setDescription('An entry in the rtgDpnLpStatsFwdStatsTable.')
rtgDpnLpStatsTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsTotalPackets.setDescription('This attribute counts the total number of delay and throughput packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsThroughputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsThroughputPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsThroughputPackets.setDescription('This attribute counts the throughput packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsDelayPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsDelayPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsDelayPackets.setDescription('This attribute counts the delay packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsNormalReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsNormalReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsNormalReliabilityPackets.setDescription('This attribute counts the normal reliability packets handled by DPN packet forwarding on this LP when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsHighReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsHighReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsHighReliabilityPackets.setDescription('This attribute counts the high reliability packets handled by DPN packet forwarding on this LP when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsDiscardNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsDiscardNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsDiscardNoRoute.setDescription('This attribute counts the packets discarded when DPN packet forwarding has failed to find a route to forward the packets on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsInterruptingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsInterruptingPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsInterruptingPackets.setDescription('This attribute counts the total number of multimedia packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnLpStatsDiscardLpCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 6, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnLpStatsDiscardLpCongested.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnLpStatsDiscardLpCongested.setDescription('This attribute counts the packets that have been discarded by DPN packet forwarding, on the entire module, due to congestion on this LP. This value is the sum of the packets discarded by all LPs due to insufficient shared memory on this one. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
rtgDpnRidFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7))
rtgDpnRidFilterRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 1), )
if mibBuilder.loadTexts: rtgDpnRidFilterRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterRowStatusTable.setDescription('This entry controls the addition and deletion of rtgDpnRidFilter components.')
rtgDpnRidFilterRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidFilterIndex"))
if mibBuilder.loadTexts: rtgDpnRidFilterRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterRowStatusEntry.setDescription('A single entry in the table represents a single rtgDpnRidFilter component.')
rtgDpnRidFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnRidFilterRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterRowStatus.setDescription('This variable is used as the basis for SNMP naming of rtgDpnRidFilter components. These components can be added and deleted.')
rtgDpnRidFilterComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidFilterComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
rtgDpnRidFilterStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtgDpnRidFilterStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterStorageType.setDescription('This variable represents the storage type value for the rtgDpnRidFilter tables.')
rtgDpnRidFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 126)))
if mibBuilder.loadTexts: rtgDpnRidFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterIndex.setDescription('This variable represents the index for the rtgDpnRidFilter tables.')
rtgDpnRidFilterImportRidListTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 303), )
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListTable.setDescription('This attribute specifies the list of RIDs whose reachability information will be accepted from the instance RID. Information about RIDs which do not appear in this list will be ignored and this node considers those RIDs to be unreachable from the instance RID. Note that this also applies to the instance RID itself, that is, if the instance RID does not appear in the import list, this node considers the instance RID to be unreachable from the instance RID. By default this list contains all valid RIDs, meaning that information about all RIDs will be accepted from the instance RID. When this list is empty, no RID information is accepted from the instance RID, therefore, no RID traffic will be routed to it. A warning is generated when an empty import list is detected. RID 127 is the Network Services Sharing (NSS) RID, used to identify DPN-100 nodes running call servers which can be used for remote call processing. This RID can be filtered like any other using the import RID list.')
rtgDpnRidFilterImportRidListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 303, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidFilterIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidFilterImportRidListValue"))
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListEntry.setDescription('An entry in the rtgDpnRidFilterImportRidListTable.')
rtgDpnRidFilterImportRidListValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 303, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListValue.setDescription('This variable represents both the value and the index for the rtgDpnRidFilterImportRidListTable.')
rtgDpnRidFilterImportRidListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 303, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterImportRidListRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the rtgDpnRidFilterImportRidListTable.')
rtgDpnRidFilterExportRidListTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 304), )
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListTable.setDescription("This attribute specifies the list of RIDs whose true reachability is advertised to the instance RID. RIDs which do not appear in this list are advertised to the instance RID as being unreachable from this node. By default, this list contains all valid RIDs, meaning that true reachability information for all RIDs is advertised to the instance RID. When this list is empty, all RIDs will be advertised to the instance RID as unreachable, including this node's own RID, therefore the instance RID will not route any RID traffic to this RID. A warning is generated when an empty export list is detected. RID 127 is the Network Services Sharing (NSS) RID, used to identify DPN-100 nodes running call servers which can be used for remote call processing. This RID can be filtered like any other using the import RID list.")
rtgDpnRidFilterExportRidListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 304, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BaseRoutingMIB", "rtgIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidFilterIndex"), (0, "Nortel-Magellan-Passport-DpnRoutingMIB", "rtgDpnRidFilterExportRidListValue"))
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListEntry.setDescription('An entry in the rtgDpnRidFilterExportRidListTable.')
rtgDpnRidFilterExportRidListValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 304, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListValue.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListValue.setDescription('This variable represents both the value and the index for the rtgDpnRidFilterExportRidListTable.')
rtgDpnRidFilterExportRidListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 40, 4, 7, 304, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rtgDpnRidFilterExportRidListRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the rtgDpnRidFilterExportRidListTable.')
dpnRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 1))
dpnRoutingGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 1, 5))
dpnRoutingGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 1, 5, 2))
dpnRoutingGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 1, 5, 2, 2))
dpnRoutingCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 3))
dpnRoutingCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 3, 5))
dpnRoutingCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 3, 5, 2))
dpnRoutingCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 21, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-DpnRoutingMIB", rtgDpnMidDelayNextHopLinkGroupsEntry=rtgDpnMidDelayNextHopLinkGroupsEntry, rtgDpnCsDelayNextHopLinkGroupsTable=rtgDpnCsDelayNextHopLinkGroupsTable, rtgDpnCsComponentName=rtgDpnCsComponentName, rtgDpnMidRowStatusEntry=rtgDpnMidRowStatusEntry, rtgDpnSubnetMidsValue=rtgDpnSubnetMidsValue, rtgDpnVarianceEntry=rtgDpnVarianceEntry, rtgDpnCsStorageType=rtgDpnCsStorageType, rtgDpnLgFarEndType=rtgDpnLgFarEndType, dpnRoutingGroupBE=dpnRoutingGroupBE, rtgDpnRidMidRowStatus=rtgDpnRidMidRowStatus, rtgDpnRidTputPathTrafficProportionsIndex=rtgDpnRidTputPathTrafficProportionsIndex, rtgDpnCsTputNextHopLinkGroupsValue=rtgDpnCsTputNextHopLinkGroupsValue, rtgDpnRidComponentName=rtgDpnRidComponentName, rtgDpnInterruptingPackets=rtgDpnInterruptingPackets, rtgDpnVarianceValue=rtgDpnVarianceValue, rtgDpnCsDelayMetricIndex=rtgDpnCsDelayMetricIndex, rtgDpnRidDelayPathTrafficProportionsValue=rtgDpnRidDelayPathTrafficProportionsValue, rtgDpnMidTputMetricTable=rtgDpnMidTputMetricTable, rtgDpnRidFilterImportRidListEntry=rtgDpnRidFilterImportRidListEntry, rtgDpnVarianceCosIndex=rtgDpnVarianceCosIndex, rtgDpnMidIndex=rtgDpnMidIndex, rtgDpnConStatsTable=rtgDpnConStatsTable, rtgDpnRidMidComponentName=rtgDpnRidMidComponentName, rtgDpnCsTputMetricTable=rtgDpnCsTputMetricTable, rtgDpnLpStatsRowStatus=rtgDpnLpStatsRowStatus, rtgDpnRidDelayNextHopLinkGroupsEntry=rtgDpnRidDelayNextHopLinkGroupsEntry, rtgDpnLg=rtgDpnLg, rtgDpnRidRowStatusTable=rtgDpnRidRowStatusTable, rtgDpnLgComponentName=rtgDpnLgComponentName, rtgDpnLpStatsNormalReliabilityPackets=rtgDpnLpStatsNormalReliabilityPackets, rtgDpnLpStatsDiscardNoRoute=rtgDpnLpStatsDiscardNoRoute, rtgDpnRidFilterImportRidListValue=rtgDpnRidFilterImportRidListValue, rtgDpnLgFarEndMid=rtgDpnLgFarEndMid, rtgDpnLogicalNetworkNumber=rtgDpnLogicalNetworkNumber, dpnRoutingMIB=dpnRoutingMIB, rtgDpnTputMetricRangeBoundary=rtgDpnTputMetricRangeBoundary, rtgDpnLpStatsHighReliabilityPackets=rtgDpnLpStatsHighReliabilityPackets, rtgDpnCsTputPathTrafficProportionsValue=rtgDpnCsTputPathTrafficProportionsValue, rtgDpnForwardingPolicy=rtgDpnForwardingPolicy, rtgDpnMidDelayNextHopLinkGroupsValue=rtgDpnMidDelayNextHopLinkGroupsValue, dpnRoutingGroupBE01A=dpnRoutingGroupBE01A, rtgDpnLpStatsStorageType=rtgDpnLpStatsStorageType, rtgDpnDelayPackets=rtgDpnDelayPackets, rtgDpnFwdStatsEntry=rtgDpnFwdStatsEntry, rtgDpnMidTputPathTrafficProportionsEntry=rtgDpnMidTputPathTrafficProportionsEntry, rtgDpnControlPktTx=rtgDpnControlPktTx, rtgDpnMidTputPathTrafficProportionsValue=rtgDpnMidTputPathTrafficProportionsValue, rtgDpnCsDelayMetricValue=rtgDpnCsDelayMetricValue, rtgDpnLgDelayMetric=rtgDpnLgDelayMetric, rtgDpnMidTputMetricValue=rtgDpnMidTputMetricValue, rtgDpnFwdStatsTable=rtgDpnFwdStatsTable, rtgDpnCsTputMetricEntry=rtgDpnCsTputMetricEntry, rtgDpnVarianceTable=rtgDpnVarianceTable, rtgDpnRidOperTable=rtgDpnRidOperTable, rtgDpnRidTputNextHopLinkGroupsIndex=rtgDpnRidTputNextHopLinkGroupsIndex, dpnRoutingCapabilitiesBE01=dpnRoutingCapabilitiesBE01, rtgDpnLpStatsIndex=rtgDpnLpStatsIndex, rtgDpnMidRowStatusTable=rtgDpnMidRowStatusTable, rtgDpnDiscardNoRoute=rtgDpnDiscardNoRoute, rtgDpnCsTputMetricValue=rtgDpnCsTputMetricValue, rtgDpnMidDelayMetricValue=rtgDpnMidDelayMetricValue, rtgDpnCsDelayPathTrafficProportionsValue=rtgDpnCsDelayPathTrafficProportionsValue, rtgDpnLpStatsFwdStatsEntry=rtgDpnLpStatsFwdStatsEntry, rtgDpnRoutingId=rtgDpnRoutingId, rtgDpnRidDelayNextHopLinkGroupsIndex=rtgDpnRidDelayNextHopLinkGroupsIndex, rtgDpnLpStatsThroughputPackets=rtgDpnLpStatsThroughputPackets, rtgDpnRidFilter=rtgDpnRidFilter, rtgDpnCallServerModuleRidsValue=rtgDpnCallServerModuleRidsValue, rtgDpnCsTputNextHopLinkGroupsEntry=rtgDpnCsTputNextHopLinkGroupsEntry, rtgDpnMid=rtgDpnMid, rtgDpnMidDelayPathTrafficProportionsEntry=rtgDpnMidDelayPathTrafficProportionsEntry, rtgDpnLpStatsFwdStatsTable=rtgDpnLpStatsFwdStatsTable, rtgDpnOutOfSequencePkt=rtgDpnOutOfSequencePkt, rtgDpnCallServerModuleRidsTable=rtgDpnCallServerModuleRidsTable, rtgDpnDiscardLpCongested=rtgDpnDiscardLpCongested, rtgDpnMidTputPathTrafficProportionsTable=rtgDpnMidTputPathTrafficProportionsTable, rtgDpnIndex=rtgDpnIndex, rtgDpnRidFilterStorageType=rtgDpnRidFilterStorageType, rtgDpnMidDelayPathTrafficProportionsIndex=rtgDpnMidDelayPathTrafficProportionsIndex, rtgDpnLgRowStatusEntry=rtgDpnLgRowStatusEntry, rtgDpnLgOperEntry=rtgDpnLgOperEntry, rtgDpnLgTputMetric=rtgDpnLgTputMetric, rtgDpnRidTputMetricValue=rtgDpnRidTputMetricValue, rtgDpnRidRowStatusEntry=rtgDpnRidRowStatusEntry, rtgDpnRidDpnDelayMetric=rtgDpnRidDpnDelayMetric, rtgDpnLgIndex=rtgDpnLgIndex, rtgDpnRowStatusEntry=rtgDpnRowStatusEntry, dpnRoutingCapabilities=dpnRoutingCapabilities, rtgDpnRidRowStatus=rtgDpnRidRowStatus, rtgDpnLpStatsRowStatusEntry=rtgDpnLpStatsRowStatusEntry, rtgDpnRidStorageType=rtgDpnRidStorageType, rtgDpnRidFilterRowStatusEntry=rtgDpnRidFilterRowStatusEntry, rtgDpnSubnetMidsTable=rtgDpnSubnetMidsTable, rtgDpnCsDelayPathTrafficProportionsEntry=rtgDpnCsDelayPathTrafficProportionsEntry, rtgDpnCsRowStatus=rtgDpnCsRowStatus, dpnRoutingCapabilitiesBE=dpnRoutingCapabilitiesBE, rtgDpnCsTputNextHopLinkGroupsTable=rtgDpnCsTputNextHopLinkGroupsTable, rtgDpnMidTputNextHopLinkGroupsTable=rtgDpnMidTputNextHopLinkGroupsTable, rtgDpnRidFilterImportRidListRowStatus=rtgDpnRidFilterImportRidListRowStatus, rtgDpnRidMidIndex=rtgDpnRidMidIndex, rtgDpnCsDelayNextHopLinkGroupsIndex=rtgDpnCsDelayNextHopLinkGroupsIndex, rtgDpnMidSubstituteRid=rtgDpnMidSubstituteRid, rtgDpnMidTputNextHopLinkGroupsIndex=rtgDpnMidTputNextHopLinkGroupsIndex, rtgDpnControlBytesTx=rtgDpnControlBytesTx, rtgDpnLpStatsDiscardLpCongested=rtgDpnLpStatsDiscardLpCongested, rtgDpnCs=rtgDpnCs, rtgDpnRidFilterExportRidListTable=rtgDpnRidFilterExportRidListTable, rtgDpnRidDelayNextHopLinkGroupsTable=rtgDpnRidDelayNextHopLinkGroupsTable, rtgDpnRidDelayMetricEntry=rtgDpnRidDelayMetricEntry, rtgDpnRidDelayMetricTable=rtgDpnRidDelayMetricTable, rtgDpnRidFilterRowStatus=rtgDpnRidFilterRowStatus, rtgDpnRowStatus=rtgDpnRowStatus, rtgDpnRidFilterExportRidListRowStatus=rtgDpnRidFilterExportRidListRowStatus, rtgDpnCsDelayPathTrafficProportionsTable=rtgDpnCsDelayPathTrafficProportionsTable, rtgDpnMidDelayPathTrafficProportionsTable=rtgDpnMidDelayPathTrafficProportionsTable, rtgDpnLgFarEndRid=rtgDpnLgFarEndRid, rtgDpnRidFilterComponentName=rtgDpnRidFilterComponentName, rtgDpnRidDelayPathTrafficProportionsEntry=rtgDpnRidDelayPathTrafficProportionsEntry, rtgDpnLgOperTable=rtgDpnLgOperTable, rtgDpnCsRowStatusTable=rtgDpnCsRowStatusTable, rtgDpnRidDelayPathTrafficProportionsTable=rtgDpnRidDelayPathTrafficProportionsTable, rtgDpnRidTputPathTrafficProportionsValue=rtgDpnRidTputPathTrafficProportionsValue, rtgDpn=rtgDpn, rtgDpnMidDelayNextHopLinkGroupsIndex=rtgDpnMidDelayNextHopLinkGroupsIndex, rtgDpnCsTputNextHopLinkGroupsIndex=rtgDpnCsTputNextHopLinkGroupsIndex, rtgDpnCsTputPathTrafficProportionsIndex=rtgDpnCsTputPathTrafficProportionsIndex, rtgDpnCsTputMetricIndex=rtgDpnCsTputMetricIndex, rtgDpnComponentName=rtgDpnComponentName, rtgDpnRidTputNextHopLinkGroupsTable=rtgDpnRidTputNextHopLinkGroupsTable, rtgDpnRidTputMetricEntry=rtgDpnRidTputMetricEntry, rtgDpnProvTable=rtgDpnProvTable, rtgDpnRidDpnTputMetric=rtgDpnRidDpnTputMetric, rtgDpnConStatsEntry=rtgDpnConStatsEntry, rtgDpnCsIndex=rtgDpnCsIndex, dpnRoutingGroupBE01=dpnRoutingGroupBE01, rtgDpnMidTputPathTrafficProportionsIndex=rtgDpnMidTputPathTrafficProportionsIndex, rtgDpnCsTputPathTrafficProportionsTable=rtgDpnCsTputPathTrafficProportionsTable, rtgDpnRidFilterExportRidListEntry=rtgDpnRidFilterExportRidListEntry, rtgDpnRidFilterRowStatusTable=rtgDpnRidFilterRowStatusTable, rtgDpnRidTputMetricIndex=rtgDpnRidTputMetricIndex, rtgDpnRidTputNextHopLinkGroupsValue=rtgDpnRidTputNextHopLinkGroupsValue, rtgDpnMidDelayMetricTable=rtgDpnMidDelayMetricTable, rtgDpnMidDelayMetricEntry=rtgDpnMidDelayMetricEntry, rtgDpnThroughputMetricCutOff=rtgDpnThroughputMetricCutOff, rtgDpnRidFilterImportRidListTable=rtgDpnRidFilterImportRidListTable, rtgDpnRowStatusTable=rtgDpnRowStatusTable, rtgDpnModuleId=rtgDpnModuleId, rtgDpnCsDelayPathTrafficProportionsIndex=rtgDpnCsDelayPathTrafficProportionsIndex, rtgDpnRidTputPathTrafficProportionsTable=rtgDpnRidTputPathTrafficProportionsTable, rtgDpnRidFilterIndex=rtgDpnRidFilterIndex, rtgDpnMidComponentName=rtgDpnMidComponentName, rtgDpnTotalPackets=rtgDpnTotalPackets, rtgDpnNormalReliabilityPackets=rtgDpnNormalReliabilityPackets, rtgDpnVarianceMetricRangeIndex=rtgDpnVarianceMetricRangeIndex, rtgDpnMidStorageType=rtgDpnMidStorageType, rtgDpnCallServerModuleRidsEntry=rtgDpnCallServerModuleRidsEntry, rtgDpnLgRowStatusTable=rtgDpnLgRowStatusTable, rtgDpnControlBytesRx=rtgDpnControlBytesRx, rtgDpnThroughputPackets=rtgDpnThroughputPackets, rtgDpnCsRowStatusEntry=rtgDpnCsRowStatusEntry, dpnRoutingCapabilitiesBE01A=dpnRoutingCapabilitiesBE01A, rtgDpnStorageType=rtgDpnStorageType, rtgDpnRidDelayPathTrafficProportionsIndex=rtgDpnRidDelayPathTrafficProportionsIndex, rtgDpnMidTputMetricIndex=rtgDpnMidTputMetricIndex, rtgDpnMidOperTable=rtgDpnMidOperTable, rtgDpnRidMidRowStatusTable=rtgDpnRidMidRowStatusTable, rtgDpnSubnetMidsEntry=rtgDpnSubnetMidsEntry, rtgDpnDelayMetricRangeBoundary=rtgDpnDelayMetricRangeBoundary, rtgDpnMidDelayPathTrafficProportionsValue=rtgDpnMidDelayPathTrafficProportionsValue, rtgDpnControlPktRx=rtgDpnControlPktRx, rtgDpnRid=rtgDpnRid, rtgDpnRidDelayNextHopLinkGroupsValue=rtgDpnRidDelayNextHopLinkGroupsValue, rtgDpnRidDelayMetricIndex=rtgDpnRidDelayMetricIndex, rtgDpnMidTputNextHopLinkGroupsEntry=rtgDpnMidTputNextHopLinkGroupsEntry, rtgDpnDelayMetricCutOff=rtgDpnDelayMetricCutOff, rtgDpnLpStats=rtgDpnLpStats, rtgDpnLpStatsInterruptingPackets=rtgDpnLpStatsInterruptingPackets, dpnRoutingGroup=dpnRoutingGroup, rtgDpnMidDelayNextHopLinkGroupsTable=rtgDpnMidDelayNextHopLinkGroupsTable, rtgDpnRidDelayMetricValue=rtgDpnRidDelayMetricValue, rtgDpnRidMid=rtgDpnRidMid, rtgDpnCsTputPathTrafficProportionsEntry=rtgDpnCsTputPathTrafficProportionsEntry, rtgDpnMidTputMetricEntry=rtgDpnMidTputMetricEntry, rtgDpnLpStatsComponentName=rtgDpnLpStatsComponentName, rtgDpnRidTputNextHopLinkGroupsEntry=rtgDpnRidTputNextHopLinkGroupsEntry, rtgDpnMidRowStatus=rtgDpnMidRowStatus, rtgDpnLgStorageType=rtgDpnLgStorageType, rtgDpnHighReliabilityPackets=rtgDpnHighReliabilityPackets, rtgDpnRidIndex=rtgDpnRidIndex, rtgDpnLpStatsRowStatusTable=rtgDpnLpStatsRowStatusTable, rtgDpnCsDelayMetricEntry=rtgDpnCsDelayMetricEntry, rtgDpnRidTputPathTrafficProportionsEntry=rtgDpnRidTputPathTrafficProportionsEntry, rtgDpnRidTputMetricTable=rtgDpnRidTputMetricTable, rtgDpnProvEntry=rtgDpnProvEntry, rtgDpnLpStatsTotalPackets=rtgDpnLpStatsTotalPackets, rtgDpnLpStatsDelayPackets=rtgDpnLpStatsDelayPackets, rtgDpnCsDelayNextHopLinkGroupsEntry=rtgDpnCsDelayNextHopLinkGroupsEntry, rtgDpnLgRowStatus=rtgDpnLgRowStatus, rtgDpnRidMidStorageType=rtgDpnRidMidStorageType, rtgDpnRidMidRowStatusEntry=rtgDpnRidMidRowStatusEntry, rtgDpnRidFilterExportRidListValue=rtgDpnRidFilterExportRidListValue, rtgDpnRidOperEntry=rtgDpnRidOperEntry, rtgDpnMidDelayMetricIndex=rtgDpnMidDelayMetricIndex, rtgDpnCsDelayMetricTable=rtgDpnCsDelayMetricTable, rtgDpnMidOperEntry=rtgDpnMidOperEntry, rtgDpnMidTputNextHopLinkGroupsValue=rtgDpnMidTputNextHopLinkGroupsValue, rtgDpnCsDelayNextHopLinkGroupsValue=rtgDpnCsDelayNextHopLinkGroupsValue)

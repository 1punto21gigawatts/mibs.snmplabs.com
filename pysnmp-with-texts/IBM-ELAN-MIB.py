#
# PySNMP MIB module IBM-ELAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-ELAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:50:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
AtmLaneAddress, = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "AtmLaneAddress")
lecsConfEntry, elanLesEntry, elanConfEntry = mibBuilder.importSymbols("LAN-EMULATION-ELAN-MIB", "lecsConfEntry", "elanLesEntry", "elanConfEntry")
mssServerLanE, AtmSelector, AtmPrivateAddrEsi = mibBuilder.importSymbols("NWAYSMSS-MIB", "mssServerLanE", "AtmSelector", "AtmPrivateAddrEsi")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, IpAddress, iso, TimeTicks, Integer32, Counter64, ModuleIdentity, NotificationType, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, ObjectIdentity, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "IpAddress", "iso", "TimeTicks", "Integer32", "Counter64", "ModuleIdentity", "NotificationType", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "ObjectIdentity", "Bits", "Gauge32")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
ibmElanMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4))
ibmElanAdminGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 1))
ibmElanConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 2))
ibmElanLecsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3))
ibmElanLecsConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1))
ibmElanMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 4))
ibmElanMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 4, 1))
ibmElanMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 4, 2))
ibmElanLesTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 2, 2), )
if mibBuilder.loadTexts: ibmElanLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmElanLesTable.setDescription('This table contains configuration information for the all LESs for each ELAN specified in the elanConfTable. This table is used by the LECS to know if a backup LES is configured.')
ibmElanLesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 2, 2, 1), ).setIndexNames((0, "IBM-ELAN-MIB", "elanConfIndex"), (0, "IBM-ELAN-MIB", "elanLesIndex"))
if mibBuilder.loadTexts: ibmElanLesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmElanLesEntry.setDescription(' Each entry represents a LES/Emulated LAN pair this agent maintains.')
ibmBackupLesAtmAddrValid = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 2, 2, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmBackupLesAtmAddrValid.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBackupLesAtmAddrValid.setDescription(' When True specifies the backup LES is specified by ibmBackupLesAtmAddr. When False specifies no backup LES is configured.')
ibmBackupLesAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 2, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmBackupLesAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ibmBackupLesAtmAddr.setDescription(' The ATM address of the backup LES.')
ibmLecsConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1), )
if mibBuilder.loadTexts: ibmLecsConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLecsConfTable.setDescription('This table contains configuration information the LECSs within the scope of the agent.')
ibmLecsConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1), ).setIndexNames((0, "IBM-ELAN-MIB", "lecsConfIndex"))
if mibBuilder.loadTexts: ibmLecsConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLecsConfEntry.setDescription("Each entry represents a LECS this agent maintains. Objects lecsUseBurnedInEsi, lecsConfiguredEsi, and lecsConfiguredSelector cannot be modified unless the lecsAdminStatus is set to down(2). And the change doesn't take effect until the lecsAdminStatus is set to up(1).")
lecsUseBurnedInEsi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsUseBurnedInEsi.setStatus('mandatory')
if mibBuilder.loadTexts: lecsUseBurnedInEsi.setDescription('Specifies whether a MAC Address burned into the ATM device should be used as the End System Identifier component of the LECS ATM Address.')
lecsConfiguredEsi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 2), AtmPrivateAddrEsi()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsConfiguredEsi.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfiguredEsi.setDescription("Locally Administered End System Identifier that is to be used as the ESI component of the LECS's ATM Address.")
lecsConfiguredSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 3), AtmSelector()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsConfiguredSelector.setStatus('mandatory')
if mibBuilder.loadTexts: lecsConfiguredSelector.setDescription("Specifies value to be used as Selector field component of LECS's ATM address.")
lecsValidateBestEffortPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsValidateBestEffortPcr.setStatus('mandatory')
if mibBuilder.loadTexts: lecsValidateBestEffortPcr.setDescription('When false, Best Effort Configuration Direct VCCs will be accepted without regard to the signalled forward Peak Cell Rate (PCR). When true, Best Effort VCCs will be rejected if the signalled forward PCR exceeds the line speed of the LECS ATM device. Calls will not be rejected due to the backward PCR. The signalled backward PCR will be honored if it does not exceed the line rate; otherwise, transmissions to the caller will be at line rate. ')
configDirectMaxReservedBw = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 155000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDirectMaxReservedBw.setStatus('mandatory')
if mibBuilder.loadTexts: configDirectMaxReservedBw.setDescription('Defines the maximum acceptable Sustained Cell Rate (SCR) for a Configuration Direct VCC; if SCR is not specified on the incoming call, then this parameter defines the maximum acceptable Peak Cell Rate (PCR) for a Configuration Direct VCC with reserved bandwidth. This parameter is applied to both forward and backward directions. Calls received with Traffic Parameters specifying higher rates will be released. If SCR is specified on the incoming call, the call will not be rejected due to the PCR or Maximum Burst Size. The constraint imposed by this parameter is not applicable to BEST EFFORT connections. ')
atmDevLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDevLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: atmDevLineSpeed.setDescription('Line Speed of LECS ATM Device. This should not exposed to the user.')
idleVccTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 43200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: idleVccTime.setStatus('mandatory')
if mibBuilder.loadTexts: idleVccTime.setDescription('When the maximum number of VCCs is exceeded at the LECS, VCCs are released (see lecsMaxVccs). All active VCCs at the LECS are scanned. If a VCC has been inactive for this length of time, then it is released.')
lecsMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: lecsMaxVccs.setDescription('This is the maximum number of simultaneous VCCs supported by the LECS. If this number is exceeded, then VCCs will be released (see idleVccTime).')
lecsDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 3, 1, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lecsDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: lecsDomainName.setDescription('This is the name to associate with the Domain of the LECS')
ibmElanCConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 4, 1, 1))
ibmLecsCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 4, 1, 2))
ibmElanMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 4, 4, 2, 1))
mibBuilder.exportSymbols("IBM-ELAN-MIB", ibmElanLesEntry=ibmElanLesEntry, lecsValidateBestEffortPcr=lecsValidateBestEffortPcr, lecsConfiguredSelector=lecsConfiguredSelector, ibmElanMIB=ibmElanMIB, ibmBackupLesAtmAddrValid=ibmBackupLesAtmAddrValid, ibmLecsConfTable=ibmLecsConfTable, ibmBackupLesAtmAddr=ibmBackupLesAtmAddr, ibmElanConfGroup=ibmElanConfGroup, ibmElanMIBConformance=ibmElanMIBConformance, ibmElanAdminGroup=ibmElanAdminGroup, ibmElanLecsConfGroup=ibmElanLecsConfGroup, lecsMaxVccs=lecsMaxVccs, lecsConfiguredEsi=lecsConfiguredEsi, ibmLecsConfEntry=ibmLecsConfEntry, ibmElanMIBCompliances=ibmElanMIBCompliances, ibmElanLecsGroup=ibmElanLecsGroup, idleVccTime=idleVccTime, atmDevLineSpeed=atmDevLineSpeed, configDirectMaxReservedBw=configDirectMaxReservedBw, ibmElanMIBGroups=ibmElanMIBGroups, ibmElanMIBCompliance=ibmElanMIBCompliance, ibmLecsCGroup=ibmLecsCGroup, lecsDomainName=lecsDomainName, ibmElanCConfGroup=ibmElanCConfGroup, lecsUseBurnedInEsi=lecsUseBurnedInEsi, ibmElanLesTable=ibmElanLesTable)

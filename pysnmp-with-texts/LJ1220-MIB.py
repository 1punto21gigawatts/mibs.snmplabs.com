#
# PySNMP MIB module LJ1220-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LJ1220-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:07:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, MibIdentifier, iso, TimeTicks, Integer32, ObjectIdentity, Counter32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Bits, Unsigned32, NotificationType, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "iso", "TimeTicks", "Integer32", "ObjectIdentity", "Counter32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Bits", "Unsigned32", "NotificationType", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
dm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2))
class DisplayString(OctetString):
    pass

device = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1))
settings_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1)).setLabel("settings-system")
copier = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5))
settings_copier = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1)).setLabel("settings-copier")
status_copier = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 2)).setLabel("status-copier")
hrm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3))
hrStorage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2))
hrStorageTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3))
hrStorageEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1))
hrDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3))
hrDeviceTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2))
hrDeviceEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1))
hrPrinterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5))
hrPrinterEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1))
status_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2)).setLabel("status-system")
id = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4))
simm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1))
simm1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1))
simm2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 2))
mio = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3))
mio1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1))
test = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5))
job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6))
settings_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1)).setLabel("settings-job")
active_print_jobs = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2)).setLabel("active-print-jobs")
job_being_parsed = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1)).setLabel("job-being-parsed")
job_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5)).setLabel("job-info")
job_info_attribute = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23)).setLabel("job-info-attribute")
errorlog = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11))
error1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1))
error2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2))
error3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3))
error4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4))
error5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5))
error6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6))
error7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7))
error8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8))
error9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9))
error10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10))
source_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2)).setLabel("source-subsystem")
io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1))
settings_io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1)).setLabel("settings-io")
processing_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3)).setLabel("processing-subsystem")
pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3))
settings_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1)).setLabel("settings-pdl")
status_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2)).setLabel("status-pdl")
pdl_pcl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3)).setLabel("pdl-pcl")
pdl_postscript = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4)).setLabel("pdl-postscript")
pjl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 5))
destination_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4)).setLabel("destination-subsystem")
print_engine = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1)).setLabel("print-engine")
settings_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1)).setLabel("settings-prt-eng")
status_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2)).setLabel("status-prt-eng")
intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3))
settings_intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1)).setLabel("settings-intray")
intrays = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3))
intray1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1))
imaging = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6))
channel = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6))
tables = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7))
channel_table = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2)).setLabel("channel-table")
channel_entry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1)).setLabel("channel-entry")
scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2))
settings_scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1)).setLabel("settings-scanner")
scan_calibration = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 32)).setLabel("scan-calibration")
status_scanner = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2)).setLabel("status-scanner")
printmib = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2))
prtGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5))
prtGeneralTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1))
prtGeneralEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1))
prtCover = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6))
prtCoverTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1))
prtCoverEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1))
prtLocalization = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7))
prtLocalizationTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1))
prtLocalizationEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1))
prtStorageRefTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2))
prtStorageRefEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2, 1))
prtDeviceRefTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3))
prtDeviceRefEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3, 1))
prtInput = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8))
prtInputTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2))
prtInputEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1))
prtOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9))
prtOutputTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2))
prtOutputEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1))
prtMarker = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10))
prtMarkerTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2))
prtMarkerEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1))
prtMarkerSupplies = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11))
prtMarkerSuppliesTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1))
prtMarkerSuppliesEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1))
prtMediaPath = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13))
prtMediaPathTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4))
prtMediaPathEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1))
prtChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14))
prtChannelTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1))
prtChannelEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1))
prtInterpreter = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15))
prtInterpreterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1))
prtInterpreterEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1))
prtConsoleDisplayBuffer = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16))
prtConsoleDisplayBufferTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5))
prtConsoleDisplayBufferEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5, 1))
prtConsoleLights = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17))
prtConsoleLightTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6))
prtConsoleLightEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1))
prtAlert = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18))
prtAlertTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1))
prtAlertEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1))
copier_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setLabel("copier-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_token.setStatus('optional')
if mibBuilder.loadTexts: copier_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to a copier device. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on COPIER-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing copier objects, and 2) releasing the lock when done changing copier objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on COPY-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing copy objects, and 2) releasing the lock when done changing copy objects.')
copier_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("copier-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_contrast.setStatus('optional')
if mibBuilder.loadTexts: copier_contrast.setDescription("Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the copier contrast level. Range is 0..100. Additional information: Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the copier contrast level. Contrast values can range from -127 to +127, for a total of 255 contrast levels. A positive value results in a larger difference, and a negative value results in a smaller difference. We support the values -125, -100, -75, -50, -25, 0, 25, 50, 75, 100, 125. We will map to the closest device dependent value is some other value is given. ")
copier_reduction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 200))).setLabel("copier-reduction").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_reduction.setStatus('optional')
if mibBuilder.loadTexts: copier_reduction.setDescription('Percentage reduction desired for the copier. A value less than or equal to zero is invalid. A value greater than 100 accomplishes magnification. A device is allowed to support a set of values (documented in its POS), instead of the full range. <noError> will be returned for unsupported values greater than zero. Additional information: Percentage reduction desired for the copier. A value less than or equal to zero is invalid. A value greater than 100 accomplishes magnification. A device is allowed to support a set of values (documented in its POS), instead of the full range. <noError> will be returned for unsupported valuesgreater than zero. Our default of 100 means no scaling')
copier_num_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setLabel("copier-num-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_num_copies.setStatus('optional')
if mibBuilder.loadTexts: copier_num_copies.setDescription('Returns or changes the number of copies to be printed in the next Host requested copy operation. Additional information: Returns or changes the number of copies to be printed in the next Host requested copy operation.')
copier_collation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eCollateDisabled", 1), ("eCollateForward", 2)))).setLabel("copier-collation").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_collation.setStatus('optional')
if mibBuilder.loadTexts: copier_collation.setDescription('Enables the device with local copier capability that also supports outputting multiple copies of a multi- paged source document to print in a collated fashion. eCollateDisabled - The collating feature of the copier device is not to be performed on subsequent copier operation. eCollateForward - Copier device is to print multiple copies of the input document in such a way that the printed output order matches the source document. eCollateReverse - Copier device is to print multiple copies of the input document such that the order of the printed output is in reverse order of the source document. Additional information: Enables the device with local copier capability that also supports outputting multiple copies of a multi- paged source document to print in a collated fashion. eCollateDisabled - The collating feature of the copier device is not to be performed on subsequent copier operation. eCollateForward - Copier device is to print multiple copies of the input document in such a way that the printed output order matches the source document.')
copier_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eCopierQualityFast", 1), ("eCopierQualityNormal", 2), ("eCopierQualityPresentation", 3), ("eCopierQualityDraft", 4)))).setLabel("copier-quality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_quality.setStatus('optional')
if mibBuilder.loadTexts: copier_quality.setDescription('Returns or sets the copier quality. This value is stored in NVRAM, hence the value is saved over power cycles. Additional information: This value is stored in NVRAM, hence the value is saved over power cycles. eCopierQualityFast is mapped to eCopierQualityNormal.')
copier_adf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 19), Integer32()).setLabel("copier-adf-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_adf_page_count.setStatus('optional')
if mibBuilder.loadTexts: copier_adf_page_count.setDescription('This object tracks the page count for the pages scanned for copying through the ADF. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for pages scanned for copying through the ADF. This value is stored in the device NVRAM.')
copier_print_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 20), Integer32()).setLabel("copier-print-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_print_page_count.setStatus('optional')
if mibBuilder.loadTexts: copier_print_page_count.setDescription('This object tracks the page count for the pages sent to the print engine, for copy jobs. In order to write this object SERVICE-PASSWORD must be set correctly. Additional information: This object tracks the page count for pages sent to the print engine, for copy jobs. This value is stored in the device NVRAM.')
copier_job_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eUSLegal", 3), ("eISOandJISA4", 26)))).setLabel("copier-job-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_media_size.setStatus('optional')
if mibBuilder.loadTexts: copier_job_media_size.setDescription('The user can set a copy job setting for paper size using the COPIER-JOB-MEDIA-SIZE object, which is independent of other functions in the device. The device behavior when the scanned media and or print media do not match the value of this object should be documented in the device POS. Additional information: The default size for imaging a copy is determined by reading the common device default paper size object. The default for copy size cannot be changed independently of other functions like fax and print. The device will scan and format the print data based on the value of this object.')
copier_job_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eCopierQualityFast", 1), ("eCopierQualityNormal", 2), ("eCopierQualityPresentation", 3), ("eCopierQualityDraft", 4)))).setLabel("copier-job-quality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_quality.setStatus('optional')
if mibBuilder.loadTexts: copier_job_quality.setDescription('Returns or sets the copier quality. Additional information: Returns or sets the copier quality. eCopierQualityFast is supported but gets mapped to normal.')
copier_job_collation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eCollateDisabled", 1), ("eCollateForward", 2)))).setLabel("copier-job-collation").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_collation.setStatus('optional')
if mibBuilder.loadTexts: copier_job_collation.setDescription('Enables the device with local copier capability that also supports outputting multiple copies of a multi-paged source document to print in a collated fashion. eCollateDisabled - The collating feature of the copier device is not be performed on subsequent copier operation. eCollateForward - Copier device is to print multiple copies of the input document in such a way that the printed output order matches the source document. eCollateReverse - Copier device is to print multiple copies of the input document such that the order of the printed output is in reverse order of the source document. ')
copier_job_num_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setLabel("copier-job-num-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_num_copies.setStatus('optional')
if mibBuilder.loadTexts: copier_job_num_copies.setDescription('Returns or changes the number of copies to be printed in the next Host requested copy operation.')
copier_job_reduction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(25, 200))).setLabel("copier-job-reduction").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_reduction.setStatus('optional')
if mibBuilder.loadTexts: copier_job_reduction.setDescription('Percentage reduction desired for the copier. A device is allowed to support a set of values (documented in its POS), instead of the full range. <OKNearesetLegalValueUsed> will be returned for unsupported values. Additional information: A value less than or equal to zero is invalid. A value greater than 100 accomplishes magnification. <noError> will be returned for unsupported valuesgreater than zero. (default = 100 = no scaling)')
copier_job_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("copier-job-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job_contrast.setStatus('optional')
if mibBuilder.loadTexts: copier_job_contrast.setDescription("Used to set the copier contrast level. Additional information: Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the copier contrast level. Contrast values can range from --127 to +127, for a total of 255 contrast levels. The default contrast level is 0 (normal). A positive value results in a larger difference, and a negative value results in a smaller difference. We support values of -125, -100, -75, -50, -25, 0, 25, 50, 75, 100, 125. The range of values we support is spread over a range such that a software product would support the standard spec, and we would map to the closest device dependent value.")
copier_job = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eCopierIdle", 1), ("eCopierStart", 2), ("eCopierActive", 3), ("eCopierAborting", 4), ("eCopierSetup", 5)))).setLabel("copier-job").setMaxAccess("readwrite")
if mibBuilder.loadTexts: copier_job.setStatus('optional')
if mibBuilder.loadTexts: copier_job.setDescription('Controls initiating and canceling a copy job. Additional information: Controls initiating and canceling a copy job. eCopierIdle - indicates that a copy function is not in progress. Device sets to this state from eCopierActive to signal successful completion of copy operation. Device sets to this state from eCopierAborting to signal successful cancel of copy operation. Host sets to this state to indicate it wants to cancel the job. Device will abort the job. eCopierSetup - indicates the host wants to set up job settings for a copy job. Host sets to this state to then access copier job settings objects. Device does not set to this state. Object can only transition to this state from eCopierIdle. eCopierStart - This state is set by host to request copy function initiation. Object can only transition to this state from eCopierIdle or eCopierSetup. If host transitions directly from Idle to Start, device will use default settings for the job. To specify job settings host has to set to Setup first, send settings, then set to Start. Device should not set to this state. eCopierActive - indicates the copy function is in progress. Device sets this state if the activity was started through front panel or if host request was successfully initiated. Host should not set to this state. eCopierAborting - Set by device to indicate copy function was prematurely terminated, either by an error, or user canceled by pressing cancel button on device. Device stays in this state until abort is complete, then moves to eCopierIdle. Host cannot set to this state, host sets to eCopierIdle to indicate it want to cancel the job. ')
copier_job_status = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 5, 2, 2), OctetString()).setLabel("copier-job-status").setMaxAccess("readonly")
if mibBuilder.loadTexts: copier_job_status.setStatus('optional')
if mibBuilder.loadTexts: copier_job_status.setDescription('Error status of the image copying session.')
hrmemorysize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrmemorysize.setStatus('mandatory')
if mibBuilder.loadTexts: hrmemorysize.setDescription('The amount of physical main memory contained by the host. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The unit of measure for this object is 1024 bytes. The default value assumes the base printer with no additional memory.')
hrstorageindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageindex.setDescription('A unique value for each logical storage area contained by the host. Refer to RFC 1514, Host Resources MIB, for more details.')
hrstoragetype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragetype.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragetype.setDescription('The type of storage represented by this entry. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: For the HP LaserJet 2100 Series this object is constant.')
hrstoragedescr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragedescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragedescr.setDescription('A description of the type and instance of the storage described by this entry. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is not localized. For the HP LaserJet 2100 Series this object is constant.')
hrstorageallocationunits = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageallocationunits.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageallocationunits.setDescription('The size, in bytes, of the data objects allocated from this pool. If this entry is monitoring sectors, blocks, buffers, or packets, for example, this number will commonly be greater than one. Otherwise this number will typically be one. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Unit is one byte. For the HP LaserJet 2100 Series this object is constant.')
hrstoragesize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragesize.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragesize.setDescription('The size of the storage represented by this entry, in units of hrStorageAllocationUnits. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Total formatter RAM. (The value of this object is hrMemorySize times the unit of measure for hrMemorySize. In the case of the HP LaserJet 2100 Series this is 4096*1024 bytes.)')
hrstorageused = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageused.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageused.setDescription('The amount of the storage represented by this entry that is allocated, in units of hrStorageAllocationUnits. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object returns the amount of memory in use by the printer at the current time. This object should not be used when creating a print job for the device because the amount of memory in use will likely be different when the printer processes the print job.')
hrstorageallocationfailures = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageallocationfailures.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageallocationfailures.setDescription('The number of requests for storage represented by this entry that could not be honored due to not enough storage. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is set to zero at power on and when any reset is done via prtGeneralReset. This object is incremented whenever the printer is short on memory (codewise: when PersMemoryCycle is called with a parameter of 2).')
hrdeviceindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceindex.setDescription('A unique value for each device contained by the host. The value for each device must remain constant at least from one re-initialization of the agent to the next re-initialization. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The entry in the Device Table which describes the printer.')
hrdevicetype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicetype.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicetype.setDescription("An indication of the type of device. If this value is `hrDeviceProcessor { hrDeviceTypes 3 }' then an entry exists in the hrProcessorTable which corresponds to this device. If this value is `hrDeviceNetwork { hrDeviceTypes 4 }', then an entry exists in the hrNetworkTable which corresponds to this device. If this value is `hrDevicePrinter { hrDeviceTypes 5 }', then an entry exists in the hrPrinterTable which corresponds to this device. If this value is `hrDeviceDiskStorage { hrDeviceTypes 6 }', then an entry exists in the hrDiskStorageTable which corresponds to this device. Refer to RFC 1514, Host Resources MIB, for more details.")
hrdevicedescr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicedescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicedescr.setDescription("A textual description of this device, including the device's manufacturer and revision, and optionally, its serial number. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The serial number is not returned with this object. This object is not localized.")
hrdeviceid = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceid.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceid.setDescription('The product ID for this device. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The complete OID reported by this object is: .1.3.6.1.4.1.11.2.3.9.1.2.20')
hrdevicestatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5))).clone(namedValues=NamedValues(("eHrunning", 2), ("eHwarning", 3), ("eHdown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicestatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicestatus.setDescription("The current operational state of the device described by this row of the table. A value unknown(1) indicates that the current state of the device is unknown. running(2) indicates that the device is up and running and that no unusual error conditions are known. The warning(3) state indicates that agent has been informed of an unusual error condition by the operational software (e.g., a disk device driver) but that the device is still 'operational'. An example would be high number of soft errors on a disk. A value of testing(4), indicates that the device is not available for use because it is in the testing state. The state of down(5) is used only when the agent has been informed that the device is not available for any use. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The printer's condition is mapped as follows: eHrunning -- Printer ready to print or is printing. May be in power save mode. eHwarning -- A condition exists that needs attention but it is not currently preventing printing. A non-critical alert is active. eHdown -- Printer is not printing because it is offline or a critical alert is active. Human interaction is needed to bring the printer to a ready state.")
hrdeviceerrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceerrors.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceerrors.setDescription('The number of errors detected on this device. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This is the number of critical alerts that have been entered into the alert table since the device was powered on. The maximum value for this object is 2^32-1. At power-on, this object will be set to zero.')
hrprinterstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("eHother", 1), ("eHidle", 3), ("eHprinting", 4), ("eHwarmup", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrprinterstatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrprinterstatus.setDescription("The current status of this printer device. When in the idle(1), printing(2), or warmup(3) state, the corresponding hrDeviceStatus should be running(2) or warning(3). When in the unknown state, the corresponding hrDeviceStatus should be unknown(1). Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The printer's condition is mapped as follows: eHother -- The printer is offline or a critical alert is active. eHidle -- The printer is not doing any of the items listed below for eHprinting status. eHprinting -- A job is currently being processed or printed or a PJL job is being processed. eHwarmup -- If hrDeviceStatus is eHdown, then the printer is currently offline but is resolving the condition that caused it to be offline and it will be online when it is ready to print. If hrDeviceStatus is eHrunning, then the printer was in power save mode and is now becoming ready to print. (In the HP LaserJet 2100 Series this status only occurs very briefly at boot time. At no other time does the printer report 'eHwarmup' status.)")
hrprinterdetectederrorstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrprinterdetectederrorstate.setStatus('mandatory')
if mibBuilder.loadTexts: hrprinterdetectederrorstate.setDescription("This object represents any error conditions detected by the printer. The error conditions are encoded as bits in an octet string, with the following definitions: Condition Bit # hrDeviceStatus lowPaper 0 warning(3) noPaper 1 down(5) lowToner 2 warning(3) noToner 3 down(5) doorOpen 4 down(5) jammed 5 down(5) offline 6 down(5) serviceRequested 7 warning(3) If multiple conditions are currently detected and the hrDeviceStatus would not otherwise be unknown(1) or testing(4), the hrDeviceStatus shall correspond to the worst state of those indicated, where down(5) is worse than warning(3) which is worse than running(2). Bits are numbered starting with the most significant bit of the first byte being bit 0, the least significant bit of the first byte being bit 7, the most significant bit of the second byte being bit 8, and so on. A one bit encodes that the condition was detected, while a zero bit encodes that the condition was not detected. This object is useful for alerting an operator to specific warning or error conditions that may occur, especially those requiring human intervention. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Here is the table from the general description, above, rewritten with formatting to make it more easily readable. The error conditions are encoded as bits in an octet string, with the following definitions: Condition.........Bit #......hrDeviceStatus lowPaper...........0...........warning(3) noPaper............1...........down(5) lowToner...........2...........warning(3) noToner............3...........down(5) doorOpen...........4...........down(5) jammed.............5...........down(5) offline............6...........down(5) serviceRequested...7...........warning(3) The HP LaserJet 2100 Series reports error conditions as follows: noPaper -- A tray is empty and must be filled for printing to continue. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. coverOpen -- A cover or door is open. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. jammed -- A jam condition is preventing printing. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. offline -- Printer is offline and will not accept new print jobs until it is online. This condition is rare in the HP LaserJet 2100 Series and may indicate some other error. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. serviceRequested -- Any status or error condition not listed above. These fall into two categories: (1) If the condition prevents printing, the 'offline' bit is also set and status values are as for offline. i.e.: hrDeviceStatus = eHdown; hrPrinterStatus = eHother; A critical alert is active. (2) If the condition does not prevent printing the status values are: hrDeviceStatus = eHwarning; hrPrinterStatus = eHidle or eHprinting; A non-critical alert is active. lowToner -- The HP LaserJet 2100 Series does not report this condition. noToner -- The HP LaserJet 2100 Series does not report this condition.")
energy_star = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 1), Integer32()).setLabel("energy-star").setMaxAccess("readonly")
if mibBuilder.loadTexts: energy_star.setStatus('optional')
if mibBuilder.loadTexts: energy_star.setDescription('Returns or changes the Energy Star sleep value. If the value is greater than zero, then the device will go into energy saving sleep mode after the print engine has been idle for the number of seconds specified by this object. A value of zero means Energy Star is disabled and the device will not go to sleep based on print engine idle time. The value must be non-negative. Additional information: Laserjet 1220 will always be in sleep mode when not processing data. This object will always return a value of 1.')
sleep_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("sleep-mode").setMaxAccess("readonly")
if mibBuilder.loadTexts: sleep_mode.setStatus('optional')
if mibBuilder.loadTexts: sleep_mode.setDescription('Returns eTrue if the device is in energy saving sleep mode, otherwise returns eFalse. Setting SLEEP-MODE to eFalse causes the device to wake up, if it is in sleep mode. Setting SLEEP-MODE to eTrue causes the device to go into sleep mode. Additional information: Laserjet 1220 will always be in sleep mode except when either processing a print job or in an error state.')
service_password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 9), Integer32()).setLabel("service-password").setMaxAccess("writeonly")
if mibBuilder.loadTexts: service_password.setStatus('optional')
if mibBuilder.loadTexts: service_password.setDescription("When set to the password value, other service related objects become 'visible' (i.e readable) and/or become writable. When written with any other value, the service related objects become 'hidden' (i.e. are no longer readable) and/or are not longer writable. The objects that can be effected by the SERVICE-PASSWORD object include: SERIAL-NUMBER and TOTAL-ENGINE-PAGE- COUNT. The password value, and the list of objects effected by the SERVICE-PASSWORD being set to the correct value, should be documented in the device POS. Additional information: The objects that can be effected by the SERVICE- PASSWORD are: TOTAL-ENGINE-PAGE-COUNT, PRINT-ENGINE- JAM-COUNT, PRINT-ENGINE-MISPICK-COUNT")
device_config_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setLabel("device-config-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_config_token.setStatus('optional')
if mibBuilder.loadTexts: device_config_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to a specific device or subset of device capabilities. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on DEVICE-CONFIG-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing device config objects, and 2) releasing the lock when done changing device config objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on CONFIG-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing CONFIG objects, and 2) releasing the lock when done changing CONFIG objects.')
on_off_line = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOnline", 1), ("eOffline", 2)))).setLabel("on-off-line").setMaxAccess("readonly")
if mibBuilder.loadTexts: on_off_line.setStatus('optional')
if mibBuilder.loadTexts: on_off_line.setDescription('To bring the PDL processing sub-system on or off line. If the device is a printer, then the printer does not process print job data when the printer is off line. PML communication persists. Additional information: The value of this object is eOnline whenever the printer is in the ready state. This object will return eOffline only when an alert is active. For example, the printer will go eOffline if the cover is open, if the toner cartridge is removed, or if the paper trays are all empty. It is not possible to change the state of the printer with this object. ')
pysmi_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eInitiateAction", 1)))).setLabel("continue").setMaxAccess("writeonly")
if mibBuilder.loadTexts: pysmi_continue.setStatus('optional')
if mibBuilder.loadTexts: pysmi_continue.setDescription("A device can support a class of errors called continuable errors. When a continuable error is encountered, the device requires a continue event to occur before the device will continue operation. One continue event is setting the CONTINUE object to eInitiateAction. Devices can support other continue events, like auto-continue. A continue event causes the continuable error to be acknowledged, thus allowing the device to continue. Each device needs to list the continuable errors. If the device doesn't currently have an unacknowledged continuable error, the response will contain <genErr>. Additional information: Consult Laserjet 1220 ERS for a list of continuable errors.")
auto_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("auto-continue").setMaxAccess("readwrite")
if mibBuilder.loadTexts: auto_continue.setStatus('optional')
if mibBuilder.loadTexts: auto_continue.setDescription('Indicates if the device will automatically continue after encountering a continuable error. If AUTO- CONTINUE is set to eOn, the device will automatically generate continue event to acknowledge continuable errors. If AUTO-CONTINUE is set to eOff, then some other continue event will have to acknowledge the continuable error.')
install_date = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setLabel("install-date").setMaxAccess("readonly")
if mibBuilder.loadTexts: install_date.setStatus('optional')
if mibBuilder.loadTexts: install_date.setDescription("Identifies the date that the device was installed. The format of the string is 'YYYYMMDDHHmmZ'. Where: YYYY is the year. MM is the month (1-12). DD is the day (1-31). HH is the hour of the day (0-23). mm are the minutes (0-59). 'Z' designates Greenwich Mean Time; if 'Z' not specified, value is local time. Device POS must specify the conditions for setting this object. Additional information: This value IS AFFECTED BY NVRAM RESETS, it is set to the default value of 199000300000 when an NVRAM init is done.")
job_input_auto_continue_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 35), Integer32()).setLabel("job-input-auto-continue-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: job_input_auto_continue_timeout.setStatus('optional')
if mibBuilder.loadTexts: job_input_auto_continue_timeout.setDescription('The number of seconds the device waits after a job related continuable error occurs before automatically continuing. An example job related continuable error is the job requesting a media size that is not available. After the timeout expires, the device will continue processing the job as if a continue event occurred, such as the front panel continue key being pressed. If the value is -1, the device does not automatically continue after a job related continuable error occurs. If the value is 0, the device immediately continues. If the value is greater than 0, the value represents the timeout value in seconds.')
job_input_auto_continue_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 36), OctetString()).setLabel("job-input-auto-continue-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: job_input_auto_continue_mode.setStatus('optional')
if mibBuilder.loadTexts: job_input_auto_continue_mode.setDescription('Returns or sets the device behavior when the desired media is not currently available. cCancelJob - The device cancels the job. The device POS should explain what happens if this item is not the only item in the collection. cAutoMediaSizeOverride - The device is allowed to substitute a different size media. cAutoMediaNameOverride - The device is allowed to substitute a different media name. cUSMediaSizeOverride - The device is allowed to substitute US media sizes (letter, etc.) for ISO media sizes (A4, etc.). cISOMediaSizeOverride - The device is allowed to substitute ISO media sizes (A4, etc.) for US media sizes (letter, etc.). Additional information: Returns or sets the device behavior when the desired media is not currently available. cCancelJob - The device cancels the job. cAutoMediaSizeOverride - the device is allowed to substitute a different size media.')
error_log_clear = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eClearErrorLog", 1)))).setLabel("error-log-clear").setMaxAccess("writeonly")
if mibBuilder.loadTexts: error_log_clear.setStatus('optional')
if mibBuilder.loadTexts: error_log_clear.setDescription("Setting this object clears all the entries in the error log sub-tree. Additional information: Setting this object removes all errors that have been stored in the printer's non-volatile memory.")
model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 2), DisplayString()).setLabel("model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: model_name.setStatus('optional')
if mibBuilder.loadTexts: model_name.setDescription("Identifies the device model name (e.g. ''DeskJet 1200C''). The string is as specific as possible. Capitalization and spacing should match family naming conventions. Products should note in POS if the model name on the HP corporate price list changes but the device reports the previous device name. If the model name changes based on the installed options, the POS should indicate if only the base model name is returned, or if the device senses the installed options and returns the correct model name. If possible, encode the model name in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: The value of this object does not change based on the installed options. This default of this object is 'HP LaserJet 1220' for all configurations of the printer. Since the value of this object is frequently used in displaying a list of printers, it is kept relatively short in case systems have limited width for their display area.")
serial_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setLabel("serial-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: serial_number.setStatus('optional')
if mibBuilder.loadTexts: serial_number.setDescription('Identifies the serial number for the device. If the SERIAL-NUMBER object is set by the user, then setting the object does not need to be protected. If the SERIAL-NUMBER object is set at the factory, then the SERVICE-PASSWORD object must be set correctly before the SERIAL-NUMBER object is writable. If this is a writable object, the POS should indicate the maximum supported string length. If possible, encode the serial number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: This value IS AFFECTED BY NVRAM RESETS, it is set to the default value of XXXXXXXXXX when an NVRAM init is done.')
fw_rom_datecode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 5), DisplayString()).setLabel("fw-rom-datecode").setMaxAccess("readonly")
if mibBuilder.loadTexts: fw_rom_datecode.setStatus('optional')
if mibBuilder.loadTexts: fw_rom_datecode.setDescription('Identifies the base system firmware date code. The date code will be encoded in the yyyymmdd format. There may be several versions of the base system firmware. The date code associated with the version of the base system firmware that is being used is reported. There may be other date code objects for other specific modules such as fonts, localization modules, etc.; these other datecode objects are device specific.')
device_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 10), DisplayString()).setLabel("device-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_name.setStatus('optional')
if mibBuilder.loadTexts: device_name.setDescription('User defined device name. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 32 characters. If the user entered string is too long, the device will store the first 32 characters and will return the <noError> status.')
device_location = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 11), DisplayString()).setLabel("device-location").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_location.setStatus('optional')
if mibBuilder.loadTexts: device_location.setDescription('User defined device location. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 16 characters. If the user entered string is too long, the device will store the first 16 characters and will return the <noError> status.')
asset_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 12), DisplayString()).setLabel("asset-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: asset_number.setStatus('optional')
if mibBuilder.loadTexts: asset_number.setDescription('User defined asset number. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 8 characters. If the user entered string is too long, the device will store the first 8 characters and will return the <noError> status.')
simm1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 9))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5), ("eRamRom", 9)))).setLabel("simm1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm1_type.setStatus('optional')
if mibBuilder.loadTexts: simm1_type.setDescription("Returns an indication of the type of option installed in SIMM slot 1. eEmpty means the device did not detect any option installed in the interface slot. eUnknown means the device doesn't recognize the installed option. eUnSupported means the device recognizes the installed option, but does not support the option. eReadOnlyMemory means the installed option contains ROM Ics. eVolatileRandomAccessMemory means the installed option contains RAM ICs that loose data when the power is turned off. eNonVolatileRandomAccessMemory means that the installed option contains RAM ICs that do not loose data when the power is turned off. eFlashMemory means that the installed option contains a type of non-volatile RAM that needs to be erased before it can be written. eDiskDrive means the installed option contains a disk drive. eRamRom means the installed option contains both volatile random access memory and read only memory. eInputPHD means the installed option is an input paper handling device. eOutputPHD means the installed option is an output paper handling device. eIOCard means the installed option is an I/O card. Additional information: This object is used to describe DIMMs instead of SIMMs on the Laserjet 1220. eRamRom is used to denote the Laserjet 1220 combo dimm.")
simm1_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1, 5), Integer32()).setLabel("simm1-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm1_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm1_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 1. The capacity is dependent on the type of option, as indicated by the SIMM1-TYPE object. This object has no meaning if the installed option type is eUnknown or eReadOnlyMemory. This object contains the size, in bytes, if the installed option type is eVolatileRandomAccessMemory, eNonVolatileRandomAccessMemory, eFlashMemory, or eDiskDrive. If the type of the installed option is eRamRom, this object contains the size, in bytes, of the random access memory. If the type of the installed option is eInputPHD, the capacity indicates the number of input trays supported by the installed option. If the type of the installed option is eOutputPHD, the capacity indicates the number of output bins supported by the installed option. If the type of the installed option is eIOCard, the capacity indicates the number of logical I/O ports supported by the I/O card. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM1-TYPE type is eVolatileRandomAccessMemory or eRamRom. For eRamRom only the size of the Ram portion of the simm (dimm) is returned.')
simm2_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 9))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5), ("eRamRom", 9)))).setLabel("simm2-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm2_type.setStatus('optional')
if mibBuilder.loadTexts: simm2_type.setDescription('Returns an indication of the type of option installed in SIMM slot 2. See SIMM1-TYPE for a description. Additional information: This object is used to describe DIMMs instead of SIMMs on the Laserjet 1220. eRamRom is used to denote the Laserjet 1220 combo dimm.')
simm2_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 2, 5), Integer32()).setLabel("simm2-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm2_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm2_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 2. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM2-TYPE type is eVolatileRandomAccessMemory or eRamRom. For eRamRom only the size of the Ram portion of the simm (dimm) is returned.')
mio1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 12))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eIOCard", 12)))).setLabel("mio1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_type.setStatus('optional')
if mibBuilder.loadTexts: mio1_type.setDescription('Returns an indication of the type of option installed in MIO/EIO slot 1. See SIMM1-TYPE for an explanation of the enumerations.')
self_test = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("eNotInASelfTest", 1), ("eNonDestructiveSelfTest", 4)))).setLabel("self-test").setMaxAccess("readwrite")
if mibBuilder.loadTexts: self_test.setStatus('optional')
if mibBuilder.loadTexts: self_test.setDescription("Writing this object allows a device self test to be started. Reading this object provides an indication what self-test is currently executing, if any. Actual self-test operation is device specific. A self test may not be allowed at any arbitrary time. If the device supports the requested self test, but can not start the execution of the self test when requested, the device will respond with <genErr>. If a non-destructive self test is being started, the device will generate a response before the self test is completed. RECOMMENDATION: If the device is ready (i.e. the NOT- READY-PRINTER object does not contain any items, except maybe being off-line) and is idle (i.e. the NOT-IDLE object does not contain any items), this request should always succeed. This provides a mechanism for driver writers to always determine if the action will succeed or not. Additional information: The eNonDestructiveSelfTest performs limited testing on the printer and its attached paper handling devices. After the self-test is complete a configuration page is printed. The recommended way to cause a configuration page to be printed is to use the PRINT-INTERNAL-PAGE object. A continuous self test cannot be started or terminated using this OID. When the printer is idle, setting this object to eNonDestructiveSelfTest results in a status of <noError> and a value of eNonDestructiveSelfTest being returned. If the printer is not idle (whether printing an external job, printing an internal page or running self test), a status of <genErr> status will be returned with a value of eNotInASelfTest. When the printer is idle, setting this object to eNonDestructiveSelfTest causes the configuration page to be formatted and put in the printer's print queue. Attempting to set this object before the configuration page has completed being formatted and printed will cause <genErr> status to be returned with a value of eNotInASelfTest. After the configuration page is in the queue, a get on this object will return a value of eNotInASelfTest. Setting the value to eNotInASelfTest is not supported on Laserjet 1220. Once the test has started, it will finish printing. Likewise, if the PRINT-INTERNAL-PAGE object is set to a valid value and that page has not printed when this object is set to eNonDestructiveSelfTest, a status of <genErr> status with a value of eNotInASelfTest will be returned until the internal page has printed.")
print_internal_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 8, 350, 450))).clone(namedValues=NamedValues(("eNotPrintingAnInternalPage", 1), ("ePrintingAnUnknownInternalPage", 2), ("eDeviceDemoPage1ConfigurationPage", 3), ("eDeviceDemoPage2", 4), ("eFileSystemDirectoryListing", 8), ("ePCLFontList1", 350), ("ePostScriptFontList1", 450)))).setLabel("print-internal-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_internal_page.setStatus('optional')
if mibBuilder.loadTexts: print_internal_page.setDescription("Writing this object to a value other than eNotPrintingAnInternalPage causes the device to attempt to print an internally generated page. Reading this object provides an indication what internally generated page is currently being printed, if any. The actual page is device specific. Some devices may support continuously printing an internally generated page. Setting this object to eNotPrintingAnInternalPage terminates continuously printing internally generated pages. An internally generated page may not be allowed to be printed at any arbitrary time; under what conditions it will succeed or fail is device specific. If the device supports the requested page, but can not start printing the page when requested, the device will respond with <genErr>. RECOMMENDATION: If the device is ready (i.e. the NOT- READY-PRINTER object does not contain any items, except maybe being off-line) and is idle (i.e. the NOT-IDLE object does not contain any items), this request should always succeed. This provides a mechanism for driver writers to always determine if the action will succeed or not. Additional information: eDeviceDemoPage2 is the printer demo page. ePCLFontList1 is the PCL typeface list, ePostScriptFontList1 is the PostScript font list, and eDeviceDemoPage1ConfigurationPage is the selftest page. Laserjet 1220 does not support continuously printing a demo page. The printer will queue requests if it is currently busy. When this object is set to a valid value and the printer is idle, the status returned is <noError> and the value returned is ePrintingAnUnknownInternalPage. Setting this object to a valid value causes the desired page to be formatted and put in the printer's print queue. While the page is being formatted, and the printer remains in a testing state, a get on this object will return the value ePrintingAnUnknownInternalPage. The return value will be eNotPrintingAnInternal page if the printer is not in a testing state, and the internal page is done being formatted. The user will not be able to set eNotPrintingAnInternalPage or ePrintingAnUnknownInternalPage, and the return status will be <badValue> with a return value of eNotPrintingAnInternalPage. ePostScriptFontList1 will not be a valid value unless postscript is installed in the printer. If postscript is not installed and the user attempts to set ePostScriptFontList1, the return status will be <badValue> with a return value of eNotPrintingAnInternalPage. Setting through DMCMD will cause a 15 second delay in printing.")
job_info_change_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("job-info-change-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_change_id.setStatus('optional')
if mibBuilder.loadTexts: job_info_change_id.setDescription('Returns the current value of an object in the job-info sub-tree whose value has changed. Define the object identifier for the object whose value has changed as job-info.required-field.optional-field.job-id. job-info represents the OID prefix of all objects in the job-info sub-tree. Required-field represents the OID field value that follows the job-info prefix. Since some objects in the job-info sub-tree have two OID fields between the job-info prefix and the job-id, the optional-field represents the OID field between the required-field and the job-id field, if present. Using this definition, the format for the JOB-INFO-CHANGE-ID binary value can be described as follows: Bytes 0-3 : required-field Bytes 4-7 : optional-field, or all zeros if there is no optional field Bytes 8-11: Job ID. Bytes 12-n : The value of the object job-info. required-field.optional-field.job-id. All multi-byte values stored in Motorola (big-endian) format, where the most significant byte occurs first. Additional information: Laserjet 1220 will use this object to report changes of the job-info-pages-printed and job-info-state objects. The required-field (bytes 0 through 3) will designate whether the change to be reported involves the pages printed (13) or job state (15). The optional-field (bytes 4 through 7) will always be zeroes. The value-field (bytes 12 through 15) will contain the new value for pages printed or job state cast to a 32-bit integer.')
current_job_parsing_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setLabel("current-job-parsing-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: current_job_parsing_id.setStatus('optional')
if mibBuilder.loadTexts: current_job_parsing_id.setDescription("Contains the printer assigned job identification for the job currently being processed by the processing PDL sub- system. The job ID is a monotonically increasing number. The job ID may be reset to zero at power-up and may roll over to zero after reaching some maximum value. Additional information: A value of -1 is returned when the printer is not parsing a job. When data for a new job is detected, this object is updated (the job may or may not turn out to be a Null Job); however, the trap does not occur until the printer determines that it is not a Null Job. (A job is considered to be a 'null job' if it has no name or job attribute, causes no pages to be printed, and consumes MIN_JOB_SIZE (9) or fewer bytes.) A trapped value will differ from the previous value by one or more. See the Job Boundary ERS for details on what constitutes a job boundary. Some job-info- objects are created when the first data bytes are received. If the printer determines that the job is a Null Job, the job-info- objects related to the Null Job are deleted. Laserjet 1220 retains the job-info- objects for the MAX_JOBS_IN_LIST (12) most recent jobs that are not Null Jobs. The first job received after power-up will have job ID 1, and the job ID will increment to 32767 before rolling to zero. To distinguish whether a power cycle or a rollover causes a reduction in the job ID value, the object prtGeneralConfigChanges can be watched and if it increments at the same time as the drop is observed in the value of CURRENT-JOB-PARSING-ID, then a power cycle is the most likely cause.")
job_info_name1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 1), DisplayString()).setLabel("job-info-name1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name1.setStatus('optional')
if mibBuilder.loadTexts: job_info_name1.setDescription("Contains the first part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: The job name is the string specified by the NAME= parameter of the @PJL JOB command which allows a maximum of 80 characters. The first 40 characters are in this object and the second 40 are in job-info-name2. The symbol set is Roman-8. When jobs are nested, the value assigned to this object is the name provided by the most recent @PJL JOB NAME= command. If no name is provided, a null string is returned.")
job_info_name2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 2), DisplayString()).setLabel("job-info-name2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name2.setStatus('optional')
if mibBuilder.loadTexts: job_info_name2.setDescription("Contains the second part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: See job-info-name1-1.")
job_info_stage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 10), OctetString()).setLabel("job-info-stage").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_stage.setStatus('optional')
if mibBuilder.loadTexts: job_info_stage.setDescription("Indicates what printer sub-systems are currently processing this print job. The last OID field for this dynamic object contains the job ID. cSourceSubsystem - some of the job is in the printer I/O subsystem. cProcessingSubsystem - some of the job is in the printer imaging processing subsystem. cDestinationSubsystem - some of the job is being printed. Additional information: For Laserjet 1220,cSourceSubsystem and cProcessingSubsystem will always be set and cleared together. They are set when the beginning of the job is detected, and they are cleared when the end of the job is parsed. A non-printing job will never set cDestinationSubsystem. When a page is ready to be printed (the intermediate has been built and the page is 'closed' by the personality), cDestinationSubsystem will be set even if a page of a previous job is currently being printed. cDestinationSubsystem remains set until the last page of the job has finished printing. If a page requires extensive processing and allows all the previous pages of a job to complete printing cDestinationSubsystem will remain set until the last page of the job has finished printing.")
job_info_io_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 11), Integer32()).setLabel("job-info-io-source").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_io_source.setStatus('optional')
if mibBuilder.loadTexts: job_info_io_source.setDescription('Indicates which I/O source, the print job was received over. The value maps to port numbering scheme supported in the DEVICE/SOURCE-SUBSYSTEM/IO/PORTS sub-tree. Additional information: Laserjet 1220 does not support the DEVICE/SOURCE-SUBSYSTEM/IO/PORTS sub-tree.')
job_info_pages_processed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 12), Integer32()).setLabel("job-info-pages-processed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_processed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_processed.setDescription("Indicates the number of pages processed by the processing subsystem. If neither the cSourceSubsystem or the cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages processed for this job. The last OID field for this dynamic object contains the job ID. Additional information: This object is incremented by one when a page is processed ('closed' by the personality), regardless of the number of pages that are printed as a result of the single page processed. In other words, it does not matter how many identical copies of a page are printed, or no pages may be printed if operating in silent run mode, this count is incremented exactly once per page processed. A page is considered processed when all of the input data has been processed for a page (that is, when the intermediate has been produced and the personality has 'closed' the page). At this time, the image of the page is not necessarily completely formed.")
job_info_pages_printed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 13), Integer32()).setLabel("job-info-pages-printed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_printed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_printed.setDescription('Indicates the number of pages printed by the destination subsystem. If non of the cSourceSubsystem, cProcessingSubsystem or cDestinationSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages printed for this job. This value may increase by two each time for duplex jobs. The last OID field for this dynamic object contains the job ID. Additional information: If multiple copies of a page are printed, each copy is counted individually.')
job_info_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 14), Integer32()).setLabel("job-info-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_size.setStatus('optional')
if mibBuilder.loadTexts: job_info_size.setDescription('Indicates the number of bytes of data processed by the processing subsystem. If neither of the cSourceSubsystem or cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the size of this job, in bytes. The last OID field for this dynamic object contains the job ID. Additional information: This count may be incremented by values other than one as blocks of data are processed; blocks of data (which may be as large as 2K bytes) will be processed in a varying amount of time. During the processing of a job and even when a job completes, an exact count of the number of I/O bytes processed by teh job is not necessarily expected.')
job_info_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 7, 10, 11))).clone(namedValues=NamedValues(("eAborted", 3), ("eWaitingForResources", 4), ("ePrinted", 5), ("eTerminating", 7), ("eCancelled", 10), ("eProcessing", 11)))).setLabel("job-info-state").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_state.setStatus('optional')
if mibBuilder.loadTexts: job_info_state.setDescription('Indicates the state of the job. The last OID field for this dynamic object contains the job ID. eAborted - the print job was aborted. eWaitingForResources - the print job requires resources that are not currently available. Example resources that can cause the job to wait include the print engine or PDL processor being unavailable. The print engine could be unavailable due to paper out, paper jam, staple out, stapler jam, marking agent low, output bin full, etc. The PDL processor could be unavailable due to an off-line condition. Each printer specific object specification should state which conditions cause a job to be waiting for resources and also state which objects can be retrieved by an application to determine the exact cause of a resource being unavailable. ePrinted - the job has printed. The related JOB-INFO- OUTCOME object indicates if any problems were encountered while the job was processed. eRetained - the job can be reprinted. eTerminating - the job was aborted or cancelled and is currently is terminating. eInterrupted - the job has been interrupted. The job can be continued. ePaused - the job has been paused. The job can be continuted. eCancelled - the job has been cancelled. eProcessing - the job is currently being printed normally.')
job_info_outcome = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("eOk", 3)))).setLabel("job-info-outcome").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outcome.setStatus('optional')
if mibBuilder.loadTexts: job_info_outcome.setDescription('Indicates if any warning or error conditions were encountered while processing the assoicated job. The last OID field for this dynamic object contains the job ID. Additional information: In Laserjet 1220, warnings and errors are not recorded in this object. Although no meaningful information can be obtained from this object, it is kept around for the compatibility needs of existing software.')
job_info_outbins_used = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 20), OctetString()).setLabel("job-info-outbins-used").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outbins_used.setStatus('optional')
if mibBuilder.loadTexts: job_info_outbins_used.setDescription('Indicates which output bins this job has delivered printed pages to. The last OID field for this dynamic object contains the job ID. Additional information: Laserjet 1220 has only 1 output bin. cOutbin1 is the top/face-down bin.')
job_info_physical_outbins_used = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 22), OctetString()).setLabel("job-info-physical-outbins-used").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_physical_outbins_used.setStatus('optional')
if mibBuilder.loadTexts: job_info_physical_outbins_used.setDescription('Indicates which physical output bins this job has delivered printed pages to. The last OID field for this dynamic object contains the job ID. Additional information: Laserjet 1220 only has one output bin so this will always be set to cOutbin1. cOutbin1--Face-up bin')
job_info_attr_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_1.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_1.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. Attribute objects are saved sequentially, starting with 1, after the start of a job. If more attributes are set than there are objects to store them, the excess JOBATTR values are ignored. If the corresponding SET JOBATTR= command has not been received when a get is done for this object, a status of <noSuchName> will be returned.')
job_info_attr_2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_2.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_2.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_3 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-3").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_3.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_3.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-4").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_4.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_4.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_5 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-5").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_5.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_5.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_6 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-6").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_6.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_6.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_7 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-7").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_7.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_7.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_8 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-8").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_8.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_8.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_9 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-9").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_9.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_9.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_10 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-10").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_10.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_10.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_11 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-11").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_11.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_11.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_12 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-12").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_12.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_12.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_13 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-13").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_13.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_13.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_14 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-14").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_14.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_14.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_15 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-15").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_15.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_15.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_16 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-16").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_16.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_16.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
error1_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 1), Integer32()).setLabel("error1-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error1_time_stamp.setDescription("Contains some sort of time stamp indicating when error 1 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: This item contains the engine page count when the error occurred. If there is currently no error entry for this object, a '0' will be returned. If ERROR1-CODE object also returns '0', then an error has not yet been logged for this object See ERROR1-CODE for an explanation of the order used for storing errors.")
error1_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 2), Integer32()).setLabel("error1-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_code.setStatus('optional')
if mibBuilder.loadTexts: error1_code.setDescription("Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: Returns a device specific error code. If the error code returned is '0', then the printer has not yet logged an error for this object. When the maximum number of errors is reached (10 on Laserjet 1220), and a new error occurs, the error in ERROR1-CODE will be replaced by the one in ERROR2-CODE, and so on until the last error object will be given the value of the new error. The error category is returned in the upper 16 bits, either 79 (for service) or 0 (for support). The lower 16 bits encodes the specific error. If an error is not a 79 service error, the value of this object is the PJL USTATUS code. If it is a 79 service error, the lower 16 bits contain the PJL USTATUS code. The types of errors reported for Laserjet 1220 are: Page Punt (21 Print Overrun) 49 Service Error 50-67 Service Error 69 Service Error 70-72 Service Error 79 Service Errors Beam Detect Malfunction Laser Malfunction Engine Communication Error Bad Fan Motor Bad Scanner Motor Bad Beam Detect Bad Fuser NVRAM Error NVRAM Service Bad MIO")
error2_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 1), Integer32()).setLabel("error2-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error2_time_stamp.setDescription('Contains some sort of time stamp indicating when error 2 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error2_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 2), Integer32()).setLabel("error2-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_code.setStatus('optional')
if mibBuilder.loadTexts: error2_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error3_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 1), Integer32()).setLabel("error3-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error3_time_stamp.setDescription('Contains some sort of time stamp indicating when error 3 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error3_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 2), Integer32()).setLabel("error3-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_code.setStatus('optional')
if mibBuilder.loadTexts: error3_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error4_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 1), Integer32()).setLabel("error4-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error4_time_stamp.setDescription('Contains some sort of time stamp indicating when error 4 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error4_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 2), Integer32()).setLabel("error4-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_code.setStatus('optional')
if mibBuilder.loadTexts: error4_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error5_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 1), Integer32()).setLabel("error5-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error5_time_stamp.setDescription('Contains some sort of time stamp indicating when error 5 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error5_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 2), Integer32()).setLabel("error5-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_code.setStatus('optional')
if mibBuilder.loadTexts: error5_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error6_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 1), Integer32()).setLabel("error6-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error6_time_stamp.setDescription('Contains some sort of time stamp indicating when error 6 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error6_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 2), Integer32()).setLabel("error6-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_code.setStatus('optional')
if mibBuilder.loadTexts: error6_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error7_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 1), Integer32()).setLabel("error7-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error7_time_stamp.setDescription('Contains some sort of time stamp indicating when error 7 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error7_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 2), Integer32()).setLabel("error7-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_code.setStatus('optional')
if mibBuilder.loadTexts: error7_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error8_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 1), Integer32()).setLabel("error8-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error8_time_stamp.setDescription('Contains some sort of time stamp indicating when error 8 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error8_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 2), Integer32()).setLabel("error8-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_code.setStatus('optional')
if mibBuilder.loadTexts: error8_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error9_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 1), Integer32()).setLabel("error9-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error9_time_stamp.setDescription('Contains some sort of time stamp indicating when error 9 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error9_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 2), Integer32()).setLabel("error9-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_code.setStatus('optional')
if mibBuilder.loadTexts: error9_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error10_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 1), Integer32()).setLabel("error10-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error10_time_stamp.setDescription('Contains some sort of time stamp indicating when error 10 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error10_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 2), Integer32()).setLabel("error10-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_code.setStatus('optional')
if mibBuilder.loadTexts: error10_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
io_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300))).setLabel("io-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: io_timeout.setStatus('optional')
if mibBuilder.loadTexts: io_timeout.setDescription('The amount of time, in seconds, to wait for more print job data to be received before an I/O timeout occurs. The I/O channel being timed is the I/O channel that received the data associated with the current print job. If an I/O timeout occurs, the PDL processing sub-system assumes all the data associated with the current print job has been received, and processes the end of job in an PDL specific manner. The POS specifies the supported values. Additional information: If an I/O timeout occurs,the PDL processing sub-system will consider it an end of job condition only if there is data from another I/O subsystem waiting to be processed. The supported values are 5 to 300 seconds. Setting to a value outside the supported range returns <badValue> status.')
io_switch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eYes", 1)))).setLabel("io-switch").setMaxAccess("readonly")
if mibBuilder.loadTexts: io_switch.setStatus('optional')
if mibBuilder.loadTexts: io_switch.setDescription('Indicates if the device will switch between I/O channels when a job boundary is encountered and print job data is available on another I/O channel.')
default_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setLabel("default-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_copies.setStatus('optional')
if mibBuilder.loadTexts: default_copies.setDescription('Returns or changes default copies. Default copies is the default values used by the PDL to control the number of copies of each page in the print job that are printed. The print job can override this value. The list of supported values should be documented in the device POS. Additional information: The supported values are 1 through 999. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snaps are as follows: <1 snaps to 1 >999 snaps to 999')
form_feed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eInitiateAction", 1)))).setLabel("form-feed").setMaxAccess("writeonly")
if mibBuilder.loadTexts: form_feed.setStatus('optional')
if mibBuilder.loadTexts: form_feed.setDescription('Instructs the PDL processing sub-system to finishing processing the current page of the current job. Form feed is also known as close page or eject page. If the PDL processing sub-system is in a FORM-FEED-NEEDED state, this causes the device to flush or finish processing the current page of the current job. If the device is not in the FORM-FEED-NEEDED state, an <genErr> will occur.')
resource_saving = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2), ("eAuto", 3)))).setLabel("resource-saving").setMaxAccess("readwrite")
if mibBuilder.loadTexts: resource_saving.setStatus('optional')
if mibBuilder.loadTexts: resource_saving.setDescription("Returns or changes PDL resource saving. Resource saving stores a PDL's permanent soft resources, like fonts, even when another PDL is active. Resource saving is also called environment saving. When eOff, resource saving is disabled. When ON, resource saving is enabled and memory is set aside for each PDL based on that PDL's resource saving memory size object, to store that PDL's permanent soft resources. When eAuto, resource saving is enabled and memory space for each installed PDL is determined automatically. The device POS should document what values are legal when only one PDL is installed. Additional information: This object is supported only if PostScript is installed. When PCL (including PCL/XL) is the only PDL installed in Laserjet 1220, eOn is not a legal value. Attempting to set this object to eOn with a PCL-only printer will result in a status of <badValue> being returned. When PostScript is installed and less than 12M RAM is present, resource saving is not available. The only valid value for this object is eOff. Attempting to set this object to eOn or eAuto will cause a status of <badValue> being returned. When PostScript is installed and 12M RAM or more are present, all values are valid")
maximum_resource_saving_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 7), Integer32()).setLabel("maximum-resource-saving-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: maximum_resource_saving_memory.setStatus('optional')
if mibBuilder.loadTexts: maximum_resource_saving_memory.setDescription("This object's name is misleading. This object returns the maximum amount of additional memory, in bytes, that can be dedicated to holding PDL permanent soft resources. Additional information: For a PCL-only printer, the value of this object is zero (all resource saving memory is dedicated to PCL).")
default_vertical_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 8), Integer32()).setLabel("default-vertical-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vertical_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_vertical_black_resolution.setDescription('Returns or changes the value of the default vertical black resolution. The units are dots per inch. Additional information: In Laserjet 1220 changing this OID also causes DEFAULT-HORIZONTAL-BLACK RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported values are 300, 600, and 1200. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <450 will snap to 300 >=450 and <900 will snap to 600 >=900 will snap to 1200')
default_horizontal_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 9), Integer32()).setLabel("default-horizontal-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_horizontal_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_horizontal_black_resolution.setDescription('Returns or changes the value of the default horizontal black resolution. The units are dots per inch. Additional information: In Laserjet 1220 changing this OID also causes DEFAULT-VERTICAL-BLACK RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported values are 300, 600 and 1200. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <450 snaps to 300 >=450 and <900 snaps to 600 >=900 snaps to 1200')
default_page_protect = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("eOn", 2), ("eAuto", 3)))).setLabel("default-page-protect").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_page_protect.setStatus('optional')
if mibBuilder.loadTexts: default_page_protect.setDescription('Returns or changes the default page protection behavior. If eOff, the device does not reserve memory for holding the entire raster form of a processed page. If eOn, then memory is reserved. If eAuto, the device determines the amount of memory to reserve. Additional information: Setting to eOn causes MET to be more conservative, but it will not allocate memory to hold an entire rasterized page.')
default_lines_per_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 11), Integer32()).setLabel("default-lines-per-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_lines_per_page.setStatus('optional')
if mibBuilder.loadTexts: default_lines_per_page.setDescription('Returns or changes the default number of lines per page. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return the <noError>. Additional information: The supported values in Laserjet 1220 are 5 to 128. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <5 snaps to 5 >128 snaps to 128')
default_vmi = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 12), Integer32()).setLabel("default-vmi").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vmi.setStatus('optional')
if mibBuilder.loadTexts: default_vmi.setDescription('Returns or changes the default vertical motion index. The unit of measure for VMI is centipoints per line. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. Additional information: Setting this object may cause DEFAULT-LINES-PER-PAGE to change.')
default_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 17, 26, 25, 45, 71, 72, 80, 81, 90, 91, 100, 101))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eROC16K", 17), ("eISOandJISA4", 26), ("eISOandJISA5", 25), ("eJISB5", 45), ("eJapanesePostcardSingle", 71), ("eJapanesePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101)))).setLabel("default-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_media_size.setStatus('optional')
if mibBuilder.loadTexts: default_media_size.setDescription("This indicates the default media size. A write of an unsupported value causes an <badValue>. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document.")
cold_reset_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eISOandJISA4", 26)))).setLabel("cold-reset-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: cold_reset_media_size.setStatus('optional')
if mibBuilder.loadTexts: cold_reset_media_size.setDescription('Returns or sets the media size that is used as the DEFAULT-MEDIA-SIZE when a cold reset occurs.')
reprint = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2), ("eAuto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reprint.setStatus('optional')
if mibBuilder.loadTexts: reprint.setDescription('Returns or changes the reprint (jam recovery) setting. If eOn, then the device will reprint pages jammed pages. If eOff, the device will not attempt to reprint jammed pages. If eAuto, a device dependent algorithm (which should be documented in the POS) will be used to determine if the page gets reprinted. This object controls all PDLs, unless a specific PDL supports its own reprint control mechanism. To date, only PostScript has a PDL reprint control mechanism. Additional information: Setting this object when the printer is not idle, may cause a status of <noError> to be returned, but the new value will not take effect until a job boundary is reached. If a get is done on object before the job boundary is reached, the value last set will be returned. When the value is set to eOff, pages will not be stored in the printer, and in the event of a paper jam, will have to be reprinted. When the value is set to eOn, pages will be stored until delivery, therefore, in the event of a paper jam, the page will be reprinted. When the value is set to eAuto, the printer will behave as though it is eOff when there is less than seven megabytes of memory installed in the printer. When additional memory is installed, to total at least seven megabytes of RAM, the setting of eAuto will behave as though it was set to eOn.')
wide_a4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("wide-a4").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wide_a4.setStatus('optional')
if mibBuilder.loadTexts: wide_a4.setDescription('Returns or changes the wide A4 logical page size setting. If eOn, then the margins/printable area of A4 paper will be changed to allow 80 10-pitch characters to be printed on a single line. If eOff then the industry standard A4 logical page size is used.')
dark_courier = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("dark-courier").setMaxAccess("readwrite")
if mibBuilder.loadTexts: dark_courier.setStatus('optional')
if mibBuilder.loadTexts: dark_courier.setDescription('Returns or changes the dark Courier setting. If eOn, then the Courier font used will approximate the same darkness as the LaserJet III printer. If eOff, then the Courier font used will approximate the same darkness as the LaserJet 4 printer.')
default_bits_per_pixel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 39), Integer32()).setLabel("default-bits-per-pixel").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_bits_per_pixel.setStatus('optional')
if mibBuilder.loadTexts: default_bits_per_pixel.setDescription('Controls the number of levels used (per pixel) when printing grayscale or color images.')
form_feed_needed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("form-feed-needed").setMaxAccess("readonly")
if mibBuilder.loadTexts: form_feed_needed.setStatus('optional')
if mibBuilder.loadTexts: form_feed_needed.setDescription("Indicates if the PDL processing sub-system has made marks on the current page and the source subsystem has been idle for a device specific amount of time. Additional information: Laserjet 1220 will set this object to eTrue when it has made marks on the current page, the IO-TIMEOUT has expired while PCL was running in 'backward-compatibility mode' (which is caused by jobs consisting purely of PCL data with no prepended PJL commands), and no data is pending on another I/O. Once it is set to eTrue, more data on the same I/O will cause this object to be set to eFalse, until the above conditions are met again.")
pcl_resource_saving_memory_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 2), Integer32()).setLabel("pcl-resource-saving-memory-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_resource_saving_memory_size.setStatus('optional')
if mibBuilder.loadTexts: pcl_resource_saving_memory_size.setDescription('Returns or changes the amount of resource saving memory set aside to hold permanent soft PCL resources. Additional information: The value returned by this object is the amount of Resource Saving memory currently dedicated to PCL, regardless of the value of RESOURCE-SAVING. For a PCL-only printer, the value of this object is zero. All memory is dedicated to PCL, but it is not shown as such. If PostScript is installed, the default value of this object is as follows: 0 if RESOURCE-SAVING=eOff. 0 if <12M memory is installed. 400K if >=12M memory is installed and RESOURCE-SAVING=eOn. 400K if =12M memory is installed and RESOURCE-SAVING=eAuto. plus 100K for each 1M over 12M memory installed. If RESOURCE-SAVING=eOn, this object can be used to set the amount of Resource Saving memory currently dedicated to PCL. The range of values supported by this object are: 0 (disables resource saving for PCL). 400K bytes through (400K bytes + value of MAXIMUM-RESOURCE-SAVING-MEMORY) in increments of 100K bytes. If a value is received that is greater than 0 and less than 400K bytes, it will be snapped to 400K bytes and a status of <noError> will be returned. If an unsupported value greater than 400K bytes is received, it will be snapped down to the nearest 100K value and a status of <noError> will be returned. Attempting to set this object when RESOURCE-SAVING is eAuto or eOff will cause a status of <genErr> to be returned.')
pcl_default_font_height = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 13), Integer32()).setLabel("pcl-default-font-height").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_height.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_height.setDescription("Returns or changes the default PCL height. Height is an approximate measure of the body of the type in centipoints. A centipoint is 1/7200 inch. Height applies only to proportional fonts. Point size, in points, can be converted to font height, in centipoints, by multiplying the point size by 100. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. ''Closest'' means the smallest absolute difference. Additional information: This object refers to the font point size with 400 representing the smallest settable font (4) and 99975 representing the largest settable font (999.75). The default of 1200 is a font point size of 12. Supported values range from 400 to 99975. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follows: <=400 snaps to 400 >=99975 snaps to 99975 Fonts are settable to the nearest quarter point size (i.e. 10, 10.25, 10.50, 10.75). Unsupported values in the range 401 to 99974 snap DOWN to the previous supported value (i.e 25293 snaps to 25275 or 75038 snaps to 75025).")
pcl_default_font_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12))).clone(namedValues=NamedValues(("eInternal", 1), ("ePermanentSoft", 2), ("eRomSimm1", 10), ("eRomSimm2", 11), ("eRomSimm3", 12)))).setLabel("pcl-default-font-source").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_source.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_source.setDescription('Returns or changes the value of the default font source variable in NVRAM.')
pcl_default_font_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setLabel("pcl-default-font-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_number.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_number.setDescription('Returns or changes the value of the default font number variable in NVRAM. Writing an unsupported value causes the printer to generate an <badValue>. Additional information: Valid numbers or 0 - 255, but only font numbers that are included in the PCL FONT LIST are selectable.')
pcl_default_font_width = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 16), Integer32()).setLabel("pcl-default-font-width").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_width.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_width.setDescription("Returns or changes the default PCL font width. Width is expressed as the width of a character in centipoints. A centipoint is 1/7200 inch. Width applies only to fixed space fonts. Pitch, in character per inch, can be converted to font width, in centipoints, by dividing 7200 by the pitch. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. ''Closest'' means the smallest absolute difference. Additional information: Setting to an unsupported value causes the printer to substitue in a snap value (listed below) and return <noError> status. The snap values for pitch are as follow: <=44 snaps to 44 >=9999 snaps to 9999 Unsupported values in the range 44 - 9999 (.44 - 99.99) snap DOWN to the next supported value.")
postscript_resource_saving_memory_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 2), Integer32()).setLabel("postscript-resource-saving-memory-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: postscript_resource_saving_memory_size.setStatus('optional')
if mibBuilder.loadTexts: postscript_resource_saving_memory_size.setDescription('Returns or changes the amount of resource saving memory set aside to hold permanent soft PostScript resources. Additional information: The value returned by this object is the amount of Resource Saving memory currently dedicated to PostScript, regardless of the value of RESOURCE-SAVING. Thee default value of this object is as follows: 0 if RESOURCE-SAVING=eOff. 0 if <12M memory is installed. 400K if >=12M memory is installed and RESOURCE-SAVING=eOn. 400K if =12M memory is installed and RESOURCE-SAVING=eAuto. plus 100K for each 1M over 12M memory installed. If RESOURCE-SAVING=eOn, this object can be used to set the amount of Resource Saving memory currently dedicated to PostScript. The range of values supported by this object are: 0 (disables resource saving for PostScript). 400K bytes through (400K bytes + value of MAXIMUM-RESOURCE-SAVING-MEMORY) in increments of 100K bytes. If a value is received that is greater than 0 and less than 400K bytes, it will be snapped to 400K bytes and a status of <noError> will be returned. If an unsupported value greater than 400K bytes is received, it will be snapped down to the nearest 100K value and a status of <noError> will be returned. Attempting to set this object when RESOURCE-SAVING is eAuto or eOff will cause a status of <genErr> to be returned.')
postscript_print_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("postscript-print-errors").setMaxAccess("readwrite")
if mibBuilder.loadTexts: postscript_print_errors.setStatus('optional')
if mibBuilder.loadTexts: postscript_print_errors.setDescription('Returns or changes the value of the print PostScript errors setting. If eOn, PostScript prints an error page showing the error encountered and the stack at the time of the error.')
pjl_password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 5, 1), Integer32()).setLabel("pjl-password").setMaxAccess("readonly")
if mibBuilder.loadTexts: pjl_password.setStatus('optional')
if mibBuilder.loadTexts: pjl_password.setDescription('Returns PJL password, if the password is not set (zero). If the password is set, then attempting to retrieve the password causes an <genErr> to occur and will return the <NullValue>.')
print_density = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setLabel("print-density").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_density.setStatus('optional')
if mibBuilder.loadTexts: print_density.setDescription('Returns or sets the print density setting. Print density is the instantaneous amount of marking agent applied to the paper while printing. A value of zero has the lowest print density, yielding a lighter page. A value of 10 has the highest print density, yielding a darker page. Each POS should document what values in the 0 to 10 range are supported. Additional information: When this value is written, the page pipeline will be flushed (all pages being printed are completed, no new ones are started), the new density setting is set and printing resumes. The acutal change in print density may be gradual over several pages. The supported values are 1 through 5. Setting to an unsupported value causes the printer to substitue in a a snap value and to return <noError> status. The snap values are as follows: <1 snaps to 1 >5 snaps to 5.')
transfer_setting = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 200))).setLabel("transfer-setting").setMaxAccess("readwrite")
if mibBuilder.loadTexts: transfer_setting.setStatus('optional')
if mibBuilder.loadTexts: transfer_setting.setDescription('When set the object will cause the transfer setting of the device to be changed to the nearest appropriate value. When the object is read it will return the current transfer setting. Each engine will have different supported values. The object should snap to the nearest supported value. Different products could use this value in different ways. Typically, this value would be a voltage on an EP system, but could be a pressure level on an inkjet. Additional information: This setting is a voltage adjustment in the LaserJet 1200. Any value >= 150 snaps to 200.')
total_engine_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 5), Integer32()).setLabel("total-engine-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: total_engine_page_count.setStatus('optional')
if mibBuilder.loadTexts: total_engine_page_count.setDescription('Total number of pages printed by the device. POS indicates if the total engine page count is kept in NVRAM, and the maximum supported value before the page count rolls over to zero. Additional information: This object is stored in NVRAM. The maximum value of this count is 1000000 before it rolls over to zero.')
print_engine_jam_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 34), Integer32()).setLabel("print-engine-jam-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_engine_jam_count.setStatus('optional')
if mibBuilder.loadTexts: print_engine_jam_count.setDescription("Total number of pages jammed in the print engine's life time. The POS indicates if the total jam count is kept in NVRAM and the maximum supported value before the jam count rolls over to zero. Additional information: This object is stored in NVRAM. The maximum value of this count is 65000 before it rolls over to zero.")
print_engine_mispick_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 35), Integer32()).setLabel("print-engine-mispick-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_engine_mispick_count.setStatus('optional')
if mibBuilder.loadTexts: print_engine_mispick_count.setDescription("Total number of pages mispicked in the print engine's life time. The POS indicates if the total mispick count is kept in NVRAM and the maximum supported value before the mispick count rolls over to zero. Additional information: This object is stored in NVRAM. The maximum value of this count is 65000 before it rolls over to zero.")
custom_paper_dim_unit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("eTenThousandthsOfInches", 3), ("eMicrometers", 4)))).setLabel("custom-paper-dim-unit").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_dim_unit.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_dim_unit.setDescription("The units of measure used to specify the width and height of the printer's custom paper. The unit of measure of eTenThousandthsOfInches is 0.0001 inches. Additional information: The only valid values for this object are eTenThousandthsOfInches (3), and eMicrometers (4). The data for this object is stored in NVRAM.")
custom_paper_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 8), Integer32()).setLabel("custom-paper-feed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_feed_dim.setDescription("Sets the printer's custom paper dimension in the feed direction (direction parallel to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: The valid range is 50000 to 140000 if CUSTOM-PAPER_DIM_UNIT is eTenThousandthsOfInches or 127000 to 355600 if CUSTOM-PAPER-DIM-UNIT is ePmicrometers. Attempts to set this object outside the valid range will result in a return value of <badValue>.")
custom_paper_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 9), Integer32()).setLabel("custom-paper-xfeed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setDescription("Sets the printer's custom paper dimension in the cross- feed direction (direction ninety degrees relative to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: The valid range for Brundage is 30000 to 85000 if CUSTOM-PAPER-DIM-UNIT is eTenThousandthsOfInches or 76200 to 216000 if CUSTOM-PAPER-DIM-UNIT is ePmicrometers. Attempts to set this object outside the valid range will result in a return value of <badValue>.")
tray1_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 17, 26, 25, 45, 71, 72, 80, 81, 90, 91, 100, 101, 32767))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eFoolscap", 10), ("eROC16K", 17), ("eISOandJISA4", 26), ("eISOandJISA5", 25), ("eJISB5", 45), ("eJapanesePostcardSingle", 71), ("eJapanesePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101), ("eUnknownMediaSize", 32767)))).setLabel("tray1-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray1_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray1_media_size_loaded.setDescription("Returns the media size that is currently configuredconfigured in tray #1. This object can be set to indicate the media size currently loaded, if the printer supports input trays that can not sense the media size. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document.")
tray1_fuser_temperature = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2))).setLabel("tray1-fuser-temperature").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray1_fuser_temperature.setStatus('optional')
if mibBuilder.loadTexts: tray1_fuser_temperature.setDescription('The fuser temperature to be used when printing media from Tray 1. The value zero is the default temperature. Values less than zero are progressively lower and values greater than zero are progressively higher. The range of values supported is device specific. Additional information: Laserjet 1220 supports 4 fuser temperatures. Zero (0) is the default temperature, one (1) is a higher temperature (for use on media like cardstock), two (2) is an even higher temperature (for use on rough media), negative one (-1) is a lower temperature (for use on media like transparencies). Setting to an unsupported value causes the printer to snap to the nearest supported value and to return <noError> status along with the actual value that was written. The snap values are as follows: <=-1 snaps to -1 >=2 snaps to 2')
default_ret = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eOff", 1), ("eLight", 2), ("eMedium", 3), ("eDark", 4)))).setLabel("default-ret").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_ret.setStatus('optional')
if mibBuilder.loadTexts: default_ret.setDescription('Returns or changes the Resolution Enhancement Technology setting. Devices that only support eOff and on should map all other values to on and always return the same non-eOff value to indicate on. The list of supported values should be documented in the device POS.')
default_print_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setLabel("default-print-quality").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_print_quality.setStatus('optional')
if mibBuilder.loadTexts: default_print_quality.setDescription('Returns or sets the default print quality. A value of zero has the lowest print quality. A value of 100 has the highest print quality. Each POS should document what values in the 0 to 100 range are supported. Additional information: Laserjet 1220 only supports DEFAULT-PRINT-QUALITY in 300 and 600 dpi. A query on this object in the 1200 dpi case will return <noSuchName>. In the Laserjet 1220, the supported values are 0 and 100. A value of zero has the lowest print quality (ECONOMODE=ON), thus minimizes the amount of toner used to print a page. A value of 100 has the highest print quality (ECONOMODE=OFF), thus uses more toner to print a page. Setting to an unsupported value outside of the 0 to 100 range causes the printer to return <badValue> status. Setting to an unsupported value inside of the 0 to 100 range causes the printer to substitute in a snap value (listed below) and to return <noError> status. The snap values are as follow: 0 to 50 snaps to 0 51 to 100 snaps to 100')
channelnumberofchannels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 1), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channelnumberofchannels.setStatus('optional')
if mibBuilder.loadTexts: channelnumberofchannels.setDescription('An indication of how many print data channels the I/O card supports. Additional information: This object is used by the EIO card to tell the peripheral firmware how many logical channels will be used by the card. This object can only be set once per physical channel. If an attempt is made to set it a subsequent time it is ignored and an return code of <genErr> is returned.')
channelprinteralert = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelprinteralert.setStatus('optional')
if mibBuilder.loadTexts: channelprinteralert.setDescription("Identifies the values of prtAlertIndex, prtAlertSeverityLevel, prtAlertGroup, prtAlertGroupIndex, prtAlertLocation, and prtAlertCode for the latest critical evnet in the prtAlertTable. The binary string is defined as following: ------------------------------------------------------ Field | Filed | Description Offset | Length | ------------------------------------------------------ 0 | 4 | the value of prtAlertIndex 4 | 4 | the value of prtAlertSeverityLevel 8 | 4 | the value of prtAlertGroup 12 | 4 | the value of prtAlertGroupIndex 16 | 4 | the value of prtAlertLocation 20 | 4 | the value of prtAlertCode ------------------------------------------------------ Each field is in Big Endian style. Additional information: This object is used to pass alert information from the peripheral to the IIO card. The standard printer MIB contains the following description: printerAlert TRAP-TYPE ENTERPRISE printerV1Alert VARIABLES { prtAlertIndex, prtAlertSeverityLevel, prtAlertGroup, prtAlertGroupIndex, prtAlertLocation, prtAlertCode } DESCRIPTION 'This trap is sent whenever a critical event is added to the prtAlertTable.' In order to provide this information in the trap packet, the IIO card enables traps on channelPrinterAlert. When a critical alert is generated the peripheral fills the appropriate value into this object and sends it to the card. This object is a structure which contains 24 bytes of data. The structure is: struct structAlertInfo { sint32 prtAlertIndex; sint32 prtAlertSeverityLevel; sint32 prtAlertGroup; sint32 prtAlertGroupIndex; sint32 prtAlertLocation; sint32 prtAlertCode; } thisAlertData;")
channel_bytes_sent = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 2), Integer32()).setLabel("channel-bytes-sent").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_bytes_sent.setStatus('optional')
if mibBuilder.loadTexts: channel_bytes_sent.setDescription('The low order 31 bits of the number of bytes sent from the printer to the host on this logical channel.')
channel_bytes_received = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 3), Integer32()).setLabel("channel-bytes-received").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_bytes_received.setStatus('optional')
if mibBuilder.loadTexts: channel_bytes_received.setDescription('The low order 31 bits of the number of bytes received by the printer from the host on this logical channel.')
channel_io_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 4), Integer32()).setLabel("channel-io-errors").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_io_errors.setStatus('optional')
if mibBuilder.loadTexts: channel_io_errors.setDescription('The low order 31 bits of the number of I/O errors which have occured on this logical channel.')
channel_jobs_received = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 5), Integer32()).setLabel("channel-jobs-received").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_jobs_received.setStatus('optional')
if mibBuilder.loadTexts: channel_jobs_received.setDescription('The low order 31 bits of the number of print jobs which have been received on this logical channel.')
scan_token = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setLabel("scan-token").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_token.setStatus('optional')
if mibBuilder.loadTexts: scan_token.setDescription('Provides an advisory locking mechanism for hosts to coordinate exclusive access to a scanner device. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on SCAN-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing scan objects, and 2) releasing the lock when done changing scan objects. Additional information: Provides an advisory locking mechanism for hosts to coordinate exclusive access. Setting the object to a unique id will only succeed if the token is currently set to 0. The token is unlocked when it is set to 0. If the token is set to a any value other than 0, then token is locked. If the token was set to a unique id (locked), then an attempt to set (lock) the token will fail. If the token was set to 0 (unlocked), then an attempt to set (lock) the token will succeed in locking the token. A get operation on SCAN-TOKEN will return its current setting. The device does not prevent access to any objects. It is assumed that hosts will be well behaved; respecting this advisory locking mechanism by: 1) acquiring the lock before changing scan objects, and 2) releasing the lock when done changing scan objects.')
scan_contrast = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 127))).setLabel("scan-contrast").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_contrast.setStatus('optional')
if mibBuilder.loadTexts: scan_contrast.setDescription("Behaves as SCL's 'Set Scanner Contrast Level' command which is used for setting the scanner contrast level. Range is 0..100. Additional information: There are 11 different tonemap that will be used on scan images to change the contrast. Software can set the contrast setting to -125, -100, -75, -50, -25, 0, 50, 75, 100, and 125 to select the different tonemaps. A user can also set the value to -127, which is a special mode used by manufacturing to tell the device to use all linear tonemaps and to perform no gamma correction. The scan pml object does not snap the pml scan-contrast. However, the contrast setting is mapped to the correct tonemap within the device.")
scan_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setLabel("scan-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_resolution.setStatus('optional')
if mibBuilder.loadTexts: scan_resolution.setDescription("struct { unsigned_32bit x_res; /* 1st four bytes; big endian */ unsigned_32bit y_res; /* 2nd four bytes; big endian */ } Sets the scanning resolution. The x and y resolutions in this object are in fixed-point with 16 bits of fraction, and 16 bits of integer, and are in dots per inch. X is horizontal; Y is vertical. Examples of computing x_res and y_res: 300 dots/inch:round(300 * 65536) = 19660800 16 dots/mm: round(16 * 25.4 * 65536) = 26633830. If the device does not support the given combination, then it'll select the nearest supported values in a device-dependent manner (documented in the POS). Additional information: The LaserJet 1220 device will support only: 100, 150, 200, 300 and 600. The Host SW may scale the image to many more resolutions. If an invalid resolution setting is passed to the device or the setting is greater than the max value(600ppi), the device will set the resolution to the default value. If the resolution setting is not 100, 150, 200, 300 or 600, the value is snapped up. For instance, if the value is < 100, the resolution is snapped to 100. If the value is between 101-149, the value is snapped to 150, etc. NOTE: The last 16 bits of the horizontal and vertical settings are ignored. Only the first 16 bits of the horizontal and vertical resolution setting are used.")
scan_pixel_data_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 24))).clone(namedValues=NamedValues(("eBiLevelThesholded", 1), ("eGrey256", 8), ("e24BitColor", 24)))).setLabel("scan-pixel-data-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_pixel_data_type.setStatus('optional')
if mibBuilder.loadTexts: scan_pixel_data_type.setDescription('Sets the method used when scanning. eBiLevelThesholded - One bit per pixel, using simple thresholding of greyscale scan data. eBiLevelHalfToned - One bit per pixel, using some kind of half-toning technique (such as dithering or error- diffusion) to approximate greyscale scan data. eGrey16 - 4 bits per pixel to represent 16 shades of grey. eGrey64 - 6 bits per pixel to represent 64 shades of grey. e3BitColor - 1 bit thresholded per Red, Green, and Blue plane. eGrey128 - 7 bits per pixel to represent 128 shades of grey. eGrey256 - 8 bits per pixel to represent 256 shades of grey. e24BitColor - 24 bits per pixel, 8 bits for Red, 8 bit for Green, and 8 bits for Blue.')
scan_compression = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6))).clone(namedValues=NamedValues(("eCompressNone", 1), ("eCompressDefault", 2), ("eCompressionMMR", 5), ("eCompressionJPEG", 6)))).setLabel("scan-compression").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_compression.setStatus('optional')
if mibBuilder.loadTexts: scan_compression.setDescription('Indicates the type of data compression applied to the image data in the scanning upload session.')
scan_compression_factor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setLabel("scan-compression-factor").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_compression_factor.setStatus('optional')
if mibBuilder.loadTexts: scan_compression_factor.setDescription('Indicates the level of compression to be applied to the scanned image data for upload. Range is normalized to be between 0..100. The device POS determines the mapping of the normalized scale to the actual Q factor for JPEG. Additional information: The LaserJet 1220 will use the SCAN-COMPRESSION-FACTOR for JPEG as described above in the General Description.')
scan_upload_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 6), Integer32()).setLabel("scan-upload-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_upload_error.setStatus('optional')
if mibBuilder.loadTexts: scan_upload_error.setDescription('Error status of the image scanning upload session.')
scan_upload = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eScanUploadIdle", 1), ("eScanUploadStart", 2), ("eScanUploadActive", 3), ("eScanUploadAborted", 4), ("eScanUploadDone", 5), ("eScanUploadNewPage", 6)))).setLabel("scan-upload").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_upload.setStatus('optional')
if mibBuilder.loadTexts: scan_upload.setDescription('Handshake mechanism between host and device to initiate scan operation and coordinate the transfer of scanned image data to the host. This object serves both as an indicator of scan upload activity as well as a trigger for the host to alter scan upload progress. The handshake is on a per page basis to allow greater host control. eScanUploadIdle - indicates the scan upload activity is not occurring. Host setting this object to eScanUploadIdle from eScanUploadActive will cause the scan upload activity to be prematurely terminated. Host may set object to this state at any time. Device sets object to this state only upon initial power up but will otherwise never set to this state of its own accord. eScanUploadStart - indicates host requesting to commence a scan to host operation. Host may set object to this state from eScanUploadIdle or eScanUploadNewPage. Device will not set object to this state of its own accord. eScanUploadActive - indicates scan upload activity is occurring. The device sets object to this state to indicate host may commence receiving scanned image data. During this state, the device will be writing scanned image data to the I/O channel. eScanUploadAborted - indicates the scanning and scan upload activity has terminated in error state. This value is set by the device. This state is not settable by the host. The host should transition this state to eScanUploadIdle. eScanUploadDone - indicates the device is signaling successful completion of scan upload activity and there are no more document pages in the scanner/ADF. The application should set this object to eScanUploadIdle. eScanUploadNewPage - indicates the device is signaling successful completion of scan upload activity for the current page and there remains at least one page in the scanner/ADF available for scanning. Host may choose to begin scan upload cycle by setting object to eScanUploadStart or end the cycle by setting object to eScanUploadIdle. Additional information: eScanUploadNewPage - indicates the device is signaling successful completion of scan upload activity for the current page. There may be a page in the device or not. The device will wait to prefeed another page until the application sets the object to eScanUploadStart. This was to fix a bug on Timberline that a prefed page would cause a jam if the application set the object to eScanUploadIdle. The application could not create another scan job until the prefed page was removed. Host may choose to begin scan upload cycle by setting object to eScanUploadStart or end the cycle by setting object to eScanUploadIdle.')
default_scanner_margin_left = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5088))).setLabel("default-scanner-margin-left").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_scanner_margin_left.setStatus('optional')
if mibBuilder.loadTexts: default_scanner_margin_left.setDescription('Sets the left scanner margin. The unit of measure should be documented in the device POS. Additional information: The margin value must be a multiple of 4 for alignment reasons. If the entered value is not a multiple of 4, the resolution value will be snapped down to the closest value divisible by 4.')
default_scanner_margin_right = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 5120))).setLabel("default-scanner-margin-right").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_scanner_margin_right.setStatus('optional')
if mibBuilder.loadTexts: default_scanner_margin_right.setDescription('Sets the right scanner margin. The unit of measure should be documented in the device POS. Additional information: The margin value must be a multiple of 4 for alignment reasons. If the entered value is not a multiple of 4, the resolution value will be snapped down to the closest value divisible by 4.')
ui_add_option = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 37), DisplayString()).setLabel("ui-add-option").setMaxAccess("writeonly")
if mibBuilder.loadTexts: ui_add_option.setStatus('optional')
if mibBuilder.loadTexts: ui_add_option.setDescription("Lets the host application set up target (eg.scan) destinations. The destinations can be a host network address and/or an application to be launched on that host. The string sent down has a list of 'KEYWORD=value;' items. The data sent down also contains a string to be displayed in the device LCD display. The device POS specifies the number of strings that can be handled (eg. 20) and the replacement/expiration policy as new target destinations are added. Additional information: For push scanning on the LaserJet 1220, there will be a limitation to the number of unique strings sent to the device via UI-ADD-OPTION. A host registers for push scanning by using the UI-ADD-OPTION object. Sockeye will limit the number of hosts registered for push scanning to 20. Sockeye will have a limitation of 1. Another limitation for the LaserJet 1220 is that the DISPLAY value must be at most 18 characters. This limitation is due to the control panel display. ")
ui_select_option = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 38), DisplayString()).setLabel("ui-select-option").setMaxAccess("readonly")
if mibBuilder.loadTexts: ui_select_option.setStatus('optional')
if mibBuilder.loadTexts: ui_select_option.setDescription('Triggers a job from the device based on the option selected.')
ui_delete_option = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 42), DisplayString()).setLabel("ui-delete-option").setMaxAccess("writeonly")
if mibBuilder.loadTexts: ui_delete_option.setStatus('optional')
if mibBuilder.loadTexts: ui_delete_option.setDescription('Lets the host application delete target eg. scan destinations that were setup with UI-ADD-OPTION. The host sends down the entire string that was sent earlier. The firmware looks for an exact match in its lists and deletes the requested option. Additional information: Removes an existing option only if it is uniquely matched by the given object value.')
scanner_jam_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 43), Integer32()).setLabel("scanner-jam-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_jam_page_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_jam_page_count.setDescription("Indicates a count of the total pages jammed in the scanner'slifetime.")
scanner_adf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 44), Integer32()).setLabel("scanner-adf-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_adf_page_count.setStatus('optional')
if mibBuilder.loadTexts: scanner_adf_page_count.setDescription('Indicates a count of the total pages scanned through the ADF on the device. This may include scan to host jobs, copyjobs, and fax jobs. If only the total pages scanned to the host are wanted, use SCAN-ADF-PAGE-COUNT.')
scan_adf_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 45), Integer32()).setLabel("scan-adf-page-count").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_adf_page_count.setStatus('optional')
if mibBuilder.loadTexts: scan_adf_page_count.setDescription('Indicates the total pages scanned through the ADF to the host from the device. If the total pages scanned through the scanner are needed for all features, including copy and fax jobs, use the SCANNER-ADF-PAGE-COUNT object.')
scan_image_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eText", 1), ("ePhoto", 2), ("eMixed", 3)))).setLabel("scan-image-type").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_image_type.setStatus('optional')
if mibBuilder.loadTexts: scan_image_type.setDescription('Indicates the image type of the scan data.')
scan_subsample = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eFourToOneToOne", 1), ("eFourToTwoToTwo", 2), ("eFourToThreeToThree", 3), ("eFourToFourToFour", 4)))).setLabel("scan-subsample").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_subsample.setStatus('optional')
if mibBuilder.loadTexts: scan_subsample.setDescription('Indicates the subsampling used for Scan Data. 4:1:1, 4:2:2, and 4:3:3 subsampling are used to modify the scan image quality and amount of scan data by reducing the number of samples or pixels of the luminous and chrominance data.')
scanner_retrieve_scanline = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 48), OctetString()).setLabel("scanner-retrieve-scanline").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_retrieve_scanline.setStatus('optional')
if mibBuilder.loadTexts: scanner_retrieve_scanline.setDescription('This object facilitates the sending of a scan line of data from the scanner to a host. It grabs either raw or corrected data. SERVICE-PASSWORD must be set correctly to use this object. cScannerRequestRawScanLine - This is set by the host in order to signal to the firmware that it wants an scan line of raw (no PRNU or DSNU correction)data to be sent back up to the host. cScannerRequestCorrectedScanLine - This is set by the host in order to signal to the firmware that it wants a scan line of corrected (PRNU or DSNU correction) data to be sent back up to the host. cScannerSendDataRequest - This is set by firmware to indicate that it has acquired the scan line from scan engine and is ready to send the data to the host. cScannerSendDataOK - This is set by the host to indicate that it is ready to receive the data from the device. cScannerSendDataDone - This is set by the firmware to indicate that the transfer of data is complete. cScannerPickSheet - This is set by the host to tell the device to pick and stage the sheet of paper in the ADF. cScannerFlushSheet - This is set by the host to tell the device to flush the sheet of paper currently in the device. Additional information: This object is meant to be used by Manufacturing in order to facilitate the sending of a scan line of data from the scanner over HDT. It grabs either raw or corrected data.')
scanner_motor_control = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 49), Integer32()).setLabel("scanner-motor-control").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_motor_control.setStatus('optional')
if mibBuilder.loadTexts: scanner_motor_control.setDescription('This objects is set to the number of steps that the scan motor should move. SERVICE-PASSWORD must be setcorrectly to use this object. Additional information: This objects is set to the number of steps that the scan motor should move. It is meant to be used by Manufacturing in order to position the scanner shipping blocks.')
scan_height = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25200))).setLabel("scan-height").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_height.setStatus('optional')
if mibBuilder.loadTexts: scan_height.setDescription('Used to set the height of a scan image in Decapoints. The use of Decapoints as units of measure eliminates the need for the user to understand the scanner mechanics and the device supported resolutions. Additional information: This object will be used to set the height of the scan image. The height will be entered using the measurement of 1/720th of an inch. This will eliminate the host being tied to the scanner mechanics and needing to know what resolutions and number of lines the device supports.')
scanner_scanline_statistics = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 51), DisplayString()).setLabel("scanner-scanline-statistics").setMaxAccess("readonly")
if mibBuilder.loadTexts: scanner_scanline_statistics.setStatus('optional')
if mibBuilder.loadTexts: scanner_scanline_statistics.setDescription('This object is used to obtain statistics about the scan line that was previously obtained using the SCANNER-RETRIEVE-SCANLINE object. Just as SERVICE-PASSWORD must be set correctly for SCANNER-RETRIEVE-SCANLINE, it must be set correctly to use this object as well. Additional information: This object is used to obtain statistics about the scan line that was previously grabbed using the SCANNER_ RETRIEVE_SCANLINE object, max string is 256 bytes. The format is the following: max red value; position; min red value; position; max red pixel to pixel difference; position; red mean; max blue value; position; min blue value; position; max blue pixel to pixel difference; position; blue mean; max green value; position; min green value; position; max green pixel to pixel difference; position; green mean;')
scan_control_descriptor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 52), DisplayString()).setLabel("scan-control-descriptor").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_control_descriptor.setStatus('optional')
if mibBuilder.loadTexts: scan_control_descriptor.setDescription('Describes the control language and formats supported for this scanner.')
scan_gamma_correction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 53), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setLabel("scan-gamma-correction").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_gamma_correction.setStatus('optional')
if mibBuilder.loadTexts: scan_gamma_correction.setDescription('A 32-bit quantity that indicates the gamma correction to use on the scan image. The first 16 bits indicate the integral portion of the gamma correction. The last 16 bits indicate the fraction portion in units of 1/65536. An example is gamma correction value of 2.2 will be representedas 0x00023333 (2 & 13107/65536ths)). The 4-pack products (gecko, sockeye, osprey & steelhead) software will set the gamma correction to be applied on the scan data. IPE SW will request a value of 1.0, which indicates no gamma correction. TWAIN software will request a value of 2.2 for grayscale scans and 2.9 for color scans. The device pos will indicate any deviation from the above description. Additional information: Indicates the gamma correction to use on the scan image. The first 16 bits indicate the integral portion of the gamma correction. The last 16 bits indicate the fraction portion and in units of 1/65536. An example is gamma correction value of 2.2 will be represented as 0x00023333 (2 & 13107/65536ths). ')
scan_pad_image = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("scan-pad-image").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_pad_image.setStatus('optional')
if mibBuilder.loadTexts: scan_pad_image.setDescription('Indicates if the scan image should be padded with white data or not.')
scan_calibration_target = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 1, 32, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eWhiteSheet", 1), ("ePlaten", 2)))).setLabel("scan-calibration-target").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_calibration_target.setStatus('optional')
if mibBuilder.loadTexts: scan_calibration_target.setDescription("This object is used by the host to check which type of calibration this scan device supports. The device pos will describe the meaning and intent of each type of scan calibration supported. Additional information: This object is used by the host to check which type of calibration the firmware supports. This is in anticipation of the fact that the initial release of Sockeye will be calibrated off of a sheet, but the 'Rest of World' release will be calibrated off of the platen.")
not_ready_source_scanner = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 1), OctetString()).setLabel("not-ready-source-scanner").setMaxAccess("readonly")
if mibBuilder.loadTexts: not_ready_source_scanner.setStatus('optional')
if mibBuilder.loadTexts: not_ready_source_scanner.setDescription('Indicates whether and why the scanner is not ready. A set bit indicates a problem. Additional information: ISSUES: Timberline only used cScannerFeederJam. Tahiti does not have an ADF sensor. Can cScannerFeederEmpty still be used (i.e. when the device tries to pull a page, but the ADF is empty or a mispick occurred). cInvalidScannerMediaSize may be used. If a page is longer that 33 inches normally this would be shown to the host as a Jam. However, can the device use cInvalidScannerMediaSize instead?')
scan_resolution_range = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 3), DisplayString()).setLabel("scan-resolution-range").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_resolution_range.setStatus('optional')
if mibBuilder.loadTexts: scan_resolution_range.setDescription('Enumerates the range of selectable scanning resolutions. Format as follows: Each supported resolution is in the format: (m)x(n) where m describes the x dpi resolution along the paper width. n describes the y dpi resolution along the paper length. A scanner that supports several resolutions would enumerate each resolution separated by a comma. A scanner that supports a continuous resolution range would format its range as: (m1-m2)x(n1- n2) where m1 < m2, n1 < n2 ')
scan_calibration_download = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 5), OctetString()).setLabel("scan-calibration-download").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scan_calibration_download.setStatus('optional')
if mibBuilder.loadTexts: scan_calibration_download.setDescription('Returns or changes the state of the calibration operation. cScanCalibrationIdle - indicates that calibration is not in progress. cScanCalibrationStart - This state is set by host to request calibration initiation. Device should not set to this state. cScanCalibrationActive - Indicates device is in calibration mode. Device sets cScanCalibrationActive to signal calibration is in process. cScanCalibrationAborted - Set by device to indicate calibration was prematurely terminated. Set by host when a calibration error occurs. cScanCalibrationSendDataRequest - Set by host when host wants to send data to the device. cScanCalibrationSendDataRequestOK - Set by the device to tell the host that the device is ready to accept data. cScanCalibrationSendDataRequestDone -Set by the device to indicate the data was received by the device. cScanCalibrationRequestScanBuffer - Set by the host to request a buffer from the device. cScanCalibrationDone - Set by the host to inform the device calibration is complete. The sequence of bits being set and the restrictions for setting bits should be documented in the device POS. Additional information: This object was originally defined for use on Timberline. For Tahiti/Sockeye we will not be using values 3-6 and 7. These are no longer applicable since the calibration is completely contained within firmware.')
scan_calibration_error = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("eNoError", 1), ("eUnknownCalibrationError", 2), ("eScannerFeederEmpty", 3), ("eLowMemory", 4), ("eWriteFailed", 5), ("eScannerBusy", 6), ("eADFMispick", 7), ("eADFJam", 8), ("eUncorrectablePixels", 9)))).setLabel("scan-calibration-error").setMaxAccess("readonly")
if mibBuilder.loadTexts: scan_calibration_error.setStatus('optional')
if mibBuilder.loadTexts: scan_calibration_error.setDescription('Error status of the most recent calibration session. eNoError(1) - The calibation was successful. eUnknownCalibrationError(2) - An unknown error occurred. eScannerFeederEmpty(3) - The feeder contained nothing to scan. eLowMemory(4) - Insufficient memory available to complete the calibration. eWriteFailed(5) - Write to NVRAM failure. eScannerBusy(6) - Scanner is busy. Detailed information about the cause and remedy for each error should be documented in the device POS. Additional information: This object was originally defined for use on Timberline. We are proposing the new enums number 7-9. Note: Option 9 would only be set during a factory calibration to indicate that at least one pixel was not correctable by the digital calibration factors.')
scanner_button_status = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("scanner-button-status").setMaxAccess("readwrite")
if mibBuilder.loadTexts: scanner_button_status.setStatus('optional')
if mibBuilder.loadTexts: scanner_button_status.setDescription('Indicates the scanner button has been pressed. The value changes to eOn(2) when the button is pressed. The host acknowledges the button press by setting the value to eOff(1).')
prtgeneralconfigchanges = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtgeneralconfigchanges.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralconfigchanges.setDescription("Counts configuration changes that change the capabilities of a printer, such as the addition/deletion of input/output bins, the addition/deletion of interpreters, or changes in media size. Such changes will often affect the capability of the printer to service certain types of print jobs. Management applications may cache infrequently changed configuration information about sub-units on the printer. This object should be incremented whenever the agent wishes such applications to invalidate that cache and re-download all of this configuration information, thereby signaling a change in the printer's configuration. For example, if an input tray that contained paper of different dimensions was added, this counter would be incremented. As an additional example, this counter would not be incremented when an input tray is removed or the level of an input device changes. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This is a 32 bit counter (unsigned). When it reaches its maximum value, it will roll to zero.")
prtgeneralcurrentlocalization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralcurrentlocalization.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralcurrentlocalization.setDescription('The value of the prtLocalizationIndex corresponding to the current language, country, and character set to be used for localized string values that are identified as being dependent on the value of this object. Note that this object does not apply to localized strings in the prtConsole group or to any object that is not explicitly identified as being localized according to prtGeneralCurrentLocalization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The value of this object is saved in NVRAM.')
prtgeneralreset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5))).clone(namedValues=NamedValues(("ePnotResetting", 3), ("ePresetToNVRAM", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralreset.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralreset.setDescription("Setting this value to `powerCycleReset', `resetToNVRAM', or `resetToFactoryDefaults' will result in the resetting of the printer. When read, this object will always have the value `notResetting(3)', and a SET of the value `notResetting' shall have no effect on the printer. Some of the defined values are optional. However, every implementation must support at least the values `notResetting' and 'resetToNVRAM'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product supports the values 'notResetting' and 'resetToNVRAM'. Setting this object to ePnotResetting causes the printer to do no reset. Setting this object to 'resetToNVRAM' causes the Laserjet 1220 product to perform its power on initialization routines. All I/O buffers are reset and tests normally run at power on time are executed.")
prtgeneralcurrentoperator = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralcurrentoperator.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralcurrentoperator.setDescription("The name of the person who is responsible for operating this printer. It is suggested that this string include information that would enable other humans to reach the operator, such as a phone number. As a convention to facilitate automatic notification of the operator by the agent or the network management station, the phone number, fax number or email address should be placed on a separate line starting with ASCII LF (hex 0x0A) and the ASCII text string (without the quotes): 'phone: ', 'fax: ', and 'email: ', respectively. Phone numbers may contain digits, whitespace and parentheses, which shall be ignored. Phone numbers may also include ASCII comma characters(hex 2C) that are used to indicate a two-second pause during the dialing sequence. If either the phone, fax, or email information is not available, then a line should not be included for this information. NOTE: For interoperability purposes, it is advisable to use email addresses formatted according to RFC 822 requirements. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The maximum supported string length is 32 characters. Length of 32 was chosen so a phone number could be included with the name. If the user entered string is too long, the device will store as much as possible and will return the <noError> status.")
prtgeneralserviceperson = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralserviceperson.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralserviceperson.setDescription("The name of the person responsible for servicing this printer. It is suggested that this string include information that would enable other humans to reach the service person, such as a phone number. As a convention to facilitate automatic notification of the service person by the agent or a network management station, the phone number, fax number or email address should be placed on a separate line starting with ASCII LF (hex 0x0A) and the ASCII text string (without the quotes): 'phone: ', 'fax: ', and 'email: ', respectively. Phone numbers may contain digits, whitespace and parentheses, which shall be ignored. Phone numbers can also include one or more ASCII comma characters(hex 2C) to indicate a two-second pause during the dialing sequence. If either the phone,fax, or email information is not available, then a line should not included for this information. NOTE: For interoperability purposes, it is advisable to use email addresses formatted according to RFC 822 requirements. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The maximum supported string length is 32 characters. Length of 32 was chosen so a phone number could be included with the name. If the user entered string is too long, the device will store as much as possible and will return the <noError> status.")
prtinputdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtinputdefaultindex.setDescription("The value of prtInputIndex corresponding to the default input sub-unit: that is, this object selects the default source of input media. This value shall be -1 if there is no default input subunit specified for the printer as a whole. In this case, the actual default input subunit may be specified by means outside the scope of this MIB, such as by each interpreter in a printer with multiple interpreters. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default input tray is determined by the printer based on DEFAULT-MEDIA-SIZE. See the '4 Pack Paper Handling ERS' for complete details. This object always returns -1, unknown.")
prtoutputdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtoutputdefaultindex.setDescription('The value of prtOutputIndex corresponding to the default output sub-unit; that is, this object selects the default output destination. This value shall be -1 if there is no default output subunit specified for the printer as a whole. In this case, the actual default output subunit may be specified by means outside the scope of this MIB, such as by each interpreter in a printer with multiple interpreters. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has only one output bin, a face-down bin located at the top of the printer.')
prtmarkerdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerdefaultindex.setDescription('The value of prtMarkerIndex corresponding to the default marker sub-unit; that is, this object selects the default marker. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product only has one marker subunit.')
prtmediapathdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathdefaultindex.setDescription('The value of prtMediaPathIndex corresponding to the default media path; that is, the selection of the default media path. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The only valid value for this object is 1 (simplex).')
prtconsolelocalization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtconsolelocalization.setStatus('optional')
if mibBuilder.loadTexts: prtconsolelocalization.setDescription('The value of the prtLocalizationIndex corresponding to the language, country, and character set to be used for the console. This localization applies both to the actual display on the console as well as the encoding of these console objects in management operations. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has no display.')
prtconsolenumberofdisplaylines = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolenumberofdisplaylines.setStatus('optional')
if mibBuilder.loadTexts: prtconsolenumberofdisplaylines.setDescription("The number of lines on the printer's physical display. This value is 0 if there are no lines on the physical display or if there is no physical display Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has no display, however this object can be used to determine the size of the remote control panel display for prtConsoleDisplayBufferText.")
prtconsolenumberofdisplaychars = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolenumberofdisplaychars.setStatus('optional')
if mibBuilder.loadTexts: prtconsolenumberofdisplaychars.setDescription('The number of characters per line displayed on the physical display. This value is 0 if there are no lines on the physical display or if there is no physical display Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has no display, however this object can be used to determine the size of the remote control panel display for prtConsoleDisplayBufferText.')
prtconsoledisable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePoperatorConsoleEnabled", 3), ("ePoperatorConsoleDisabled", 4), ("ePoperatorConsoleEnabledLevel1", 5), ("ePoperatorConsoleEnabledLevel2", 6), ("ePoperatorConsoleEnabledLevel3", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledisable.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledisable.setDescription("If the object prtConsoleDisable has value 'operatorConsoleDisabled' then input is not accepted from the operator console. If the object prtConsoleDisable has the value 'operatorConsoleEnabled' then input is accepted from the operator console. If the object prtConsoleDisable has the value 'operatorConsoleEnabledLevel1','operatorConsoleEnabledLevel2' or 'operatorConsoleEnabledLevel3' then limited input is accepted from the operator console; the limitations are product specific, however, the limitations are generally less restrictive for operatorConsoleEnabledLevel1 than for operatorConsoleEnabledLeve2, which is less restrictive than operatorConsoleEnabledLevel3. The value of the prtConsoleDisable object is a type-2 enumeration. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product have no display.")
prtgeneralprintername = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralprintername.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralprintername.setDescription("An administrator-specified name for this printer. Depending upon implementation of this printer, the value of this object may or may not be same as the value for the MIB-II 'SysName' object. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The maximum supported string length is 32 characters. Length of 32 was chosen so a phone number could be included with the name. If the user-entered string is too long, the device will store as much as possible and will return the <noError> status. The value of this object is saved over a power cycle.")
prtgeneralserialnumber = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtgeneralserialnumber.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralserialnumber.setDescription('A recorded serial number for this device that indexes some type device catalog or inventory. This value is usually set by the device manufacturer but the MIB supports the option of writeability for this object for site-specific administration of device inventory or tracking. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtalertcriticalevents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertcriticalevents.setStatus('optional')
if mibBuilder.loadTexts: prtalertcriticalevents.setDescription('A running counter of the number of critical alert events that have been recorded in the alert table. The value of this object is RESET in the event of a power cycle operation (i.e., the value is not persistent. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This object is set to zero every time the printer is turned on.')
prtalertallevents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertallevents.setStatus('optional')
if mibBuilder.loadTexts: prtalertallevents.setDescription('A running counter of the total number of alert event entries (critical and non-critical) that have been recorded in the alert table Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This object is set to zero every time the printer is turned on. (It is not persistent through a power-cycle.)')
prtcoverdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtcoverdescription.setStatus('optional')
if mibBuilder.loadTexts: prtcoverdescription.setDescription('The manufacturer provided cover sub-mechanism name in the localization specified by prtGeneralCurrentLocalization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtcoverstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePdoorOpen", 3), ("ePdoorClosed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtcoverstatus.setStatus('optional')
if mibBuilder.loadTexts: prtcoverstatus.setDescription('The status of this cover sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtlocalizationlanguage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationlanguage.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationlanguage.setDescription('A two character language code from ISO 639. Examples en, gb, ca, fr, de. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The languages supported by the Laserjet 1220 product English')
prtlocalizationcountry = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationcountry.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationcountry.setDescription('A two character country code from ISO 3166, a blank string (two space characters) shall indicate that the country is not defined. Examples: US, FR, DE, ... Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The languages supported by the Laserjet 1220 product (and corresponding country) are English (US, United States)')
prtlocalizationcharacterset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2004))).clone(namedValues=NamedValues(("ePcsHPRoman8", 2004)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationcharacterset.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationcharacterset.setDescription('The coded character set used for this localization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtstoragerefindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtstoragerefindex.setStatus('optional')
if mibBuilder.loadTexts: prtstoragerefindex.setDescription('The value of the hrDeviceIndex of the printer device that this storageEntry is associated with. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtdevicerefindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtdevicerefindex.setStatus('optional')
if mibBuilder.loadTexts: prtdevicerefindex.setDescription('The value of the hrDeviceIndex of the printer device that this deviceEntry is associated with. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtinputtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePsheetFeedAutoRemovableTray", 3), ("ePsheetFeedAutoNonRemovableTray", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputtype.setStatus('optional')
if mibBuilder.loadTexts: prtinputtype.setDescription('The type of technology (discriminated primarily according to feeder mechanism type) employed by the input sub-unit. Note, the Optional Input Class provides for a descriptor field to further qualify the other choice. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Tray 1 is the multi-purpose tray and is always present. It supports both sheets and envelopes. Its type is ePsheetFeedAutoNonRemovableTray.')
prtinputdimunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdimunit.setStatus('optional')
if mibBuilder.loadTexts: prtinputdimunit.setDescription('The unit of measurement for use calculating and relaying dimensional values for this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Following is a table of paper sizes and dimensions for each paper size supported by the Laserjet 1220 product: Size....................Inches(ten-thousandths)...Micrometers ----------------------------------------------------------------- eUSExecutive............72500 x 105000............184150 x 266700 eUSLetter...............85000 x 110000............215900 x 279400 eUSLegal................85000 x 140000............215900 x 355600 eFoolscap...............85000 x 130000............215900 x 330200 eROC16K.................77500 x 107500............196850 x 273050 eISOandJISA4............82677 x 116929............210000 x 297000 eISOandJISA5............58286 x 82677.............148000 x 210000 eJISB5..................71654 x 101181............182000 x 257000 eJapanesePostcardSingle.39370 x 58267.............100000 x 148000 eJapanesePostcardDouble.58267 x 78740.............148000 x 200000 eMonarch................38750 x 75000.............98425 x 190500 eCommercial10...........41250 x 95000.............104775 x 241300 eInternationalDL........43307 x 86614.............110000 x 120000 eInternationalC5........63780 x 90157.............162000 x 229000 eInternationalB5........69291 x 98425.............176000 x 250000 eCustom.................85000 x 140000(max).......215900 x 355600(max)')
prtinputmediadimfeeddirdeclared = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimfeeddirdeclared.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimfeeddirdeclared.setDescription('This object provides the value of the declared dimension, in the feed direction, of the media that is (or, if empty, was or will be) in this input sub-unit. The feed direction is the direction in which the media is fed on this sub-unit. This dimension is measured in input sub-unit dimensional units (prtInputDimUnit). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests. Otherwise, the value may be changed. The value (-1) means other and specifically means that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default values assume the trays are configured for letter size paper. For tray 1 the value is the dimension for the media size currently declared. Valid values are 63000 to 140000 if prtInputDimUnit is ePtenThousandthsOfInches and 160000 to 356000 if prtInputDimUnit is ePmicrometers.')
prtinputmediadimxfeeddirdeclared = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimxfeeddirdeclared.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimxfeeddirdeclared.setDescription('This object provides the value of the declared dimension, in the cross feed direction, of the media that is (or, if empty, was or will be) in this input sub-unit. The cross feed direction is ninety degrees relative to the feed direction associated with this sub-unit. This dimension is measured in input sub-unit dimensional units (prtInputDimUnit). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests. Otherwise, the value may be changed. The value (-1) means other and specifically means that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default values assume the trays are configured for letter size paper. For tray 1 the value is the dimension for the media size currently declared. Valid values are 35000 to 85000 if prtInputDimUnit is ePtenThousandthsOfInches and 90000 to 216000 if prtInputDimUnit is ePmicrometers.')
prtinputmediadimfeeddirchosen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimfeeddirchosen.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimfeeddirchosen.setDescription('The printer will act as if media of the chosen dimension (in the feed direction) is present in this input source. Note that this value will be used even if the input tray is empty. Feed dimension measurements are taken relative to the feed direction associated with that sub-unit and are in input sub-unit dimensional units (MediaUnit). If the printer supports the declared dimension, the granted dimension is the same as the declared dimension. If not, the granted dimension is set to the closest dimension that the printer supports when the declared dimension is set. The value (-1) means other and specifically indicates that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: When the tray is removed, a value of -2 is returned. The default values assume the trays are configured for letter size paper. The object for tray 1 returns the value of the media size for which the tray is currently configured because they cannot sense what size media it contains.')
prtinputmediadimxfeeddirchosen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimxfeeddirchosen.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimxfeeddirchosen.setDescription('The printer will act as if media of the chosen dimension (in the cross feed direction) is present in this input source. Note that this value will be used even if the input tray is empty. The cross feed direction is ninety degrees relative to the feed direction associated with this sub-unit. This dimension is measured in input sub-unit dimensional units (MediaUnit). If the printer supports the declared dimension, the granted dimension is the same as the declared dimension. If not, the granted dimension is set to the closest dimension that the printer supports when the declared dimension is set. The value (-1) means other and specifically indicates that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default values assume the trays are configured for letter size paper. The objects for tray 1, tray 2 and tray 3 returns the value of the media size for which the tray is currently configured because they cannot sense what size media it contains.')
prtinputcapacityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8))).clone(namedValues=NamedValues(("ePsheets", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputcapacityunit.setStatus('optional')
if mibBuilder.loadTexts: prtinputcapacityunit.setDescription('The unit of measurement for use in calculating and relaying capacity values for this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: A sheet is a single piece of 20 pound paper. ')
prtinputmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtinputmaxcapacity.setDescription('The maximum capacity of the input sub-unit in input sub-unit capacity units (PrtCapacityUnitTC). There is no convention associated with the media itself so this value reflects claimed capacity. If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This is specified assuming 20 pound paper for the paper trays.')
prtinputcurrentlevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputcurrentlevel.setStatus('optional')
if mibBuilder.loadTexts: prtinputcurrentlevel.setDescription('The current capacity of the input sub-unit in input sub-unit capacity units (PrtCapacityUnitTC). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Contol Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. The value (-3) means that the printer knows that at least one unit remains. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 products can only detect empty/not empty in its trays. It returns -3 for not empty and -2 (unknown) for any other condition (e.g. tray is empty or tray is removed).')
prtinputstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputstatus.setStatus('optional')
if mibBuilder.loadTexts: prtinputstatus.setDescription('The current status of this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default value assumes that media is loaded in the tray. When there is not media loaded in the tray it returns 9 instead of 0 (the default). Default - 0 (Available and Idle) paper motion - 6 (Available and Busy) paper out in this tray - 9 (Non-Critical Alert(8) + Unavailable and OnRequest(1)) paper mount in this tray - 48 (Critical Alert (16) + OffLine (32)) manual feed prompt (PaperMount) - 48 (Critical Alert (16) + OffLine (32))')
prtinputmedianame = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmedianame.setStatus('optional')
if mibBuilder.loadTexts: prtinputmedianame.setDescription("A description of the media contained in this input sub-unit; This description is intended for display to a human operator. This description is not processed by the printer. It is used to provide information not expressible in terms of the other media attributes (e.g. prtInputMediaDimFeedDirChosen, prtInputMediaDimXFeedDirChosen, prtInputMediaWeight, prtInputMediaType). An example would be `legal tender bond paper'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product does not support the concept of named media types.")
prtinputname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputname.setStatus('optional')
if mibBuilder.loadTexts: prtinputname.setDescription('The name assigned to this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtinputvendorname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputvendorname.setStatus('optional')
if mibBuilder.loadTexts: prtinputvendorname.setDescription('The vendor name of this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtinputmodel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmodel.setStatus('optional')
if mibBuilder.loadTexts: prtinputmodel.setDescription('The model name of this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product does not specify a model name for Tray1.')
prtinputversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputversion.setStatus('optional')
if mibBuilder.loadTexts: prtinputversion.setDescription('The version of this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product do not specify a version number for the input trays.')
prtinputserialnumber = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputserialnumber.setStatus('optional')
if mibBuilder.loadTexts: prtinputserialnumber.setDescription('The serial number assigned to this input sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product does not specify a serial number for the input trays.')
prtinputdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdescription.setStatus('optional')
if mibBuilder.loadTexts: prtinputdescription.setDescription('A free-form text description of this input sub-unit in the localization specified by prtGeneralCurrentLocalization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtinputsecurity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputsecurity.setStatus('optional')
if mibBuilder.loadTexts: prtinputsecurity.setDescription('Indicates if this input sub-unit has some security associated with it. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: No security mechanism provided.')
prtoutputtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePremovableBin", 3), ("ePunRemovableBin", 4), ("ePcontinuousRollDevice", 5), ("ePmailBox", 6), ("ePcontinousFanFold", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputtype.setStatus('optional')
if mibBuilder.loadTexts: prtoutputtype.setDescription('The type of technology supported by this output sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has only one output bin, a face-down bin located at the top of the printer.')
prtoutputcapacityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 8, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4), ("ePsheets", 8), ("ePfeet", 16), ("ePmeters", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputcapacityunit.setStatus('optional')
if mibBuilder.loadTexts: prtoutputcapacityunit.setDescription('The unit of measurement for use in calculating and relaying capacity values for this output sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: A sheet is a single piece of 20 pound paper.')
prtoutputmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputmaxcapacity.setDescription('The maximum capacity of this output sub-unit in output sub-unit capacity units (PrtCapacityUnitTC). There is no convention associated with the media itself so this value essentially reflects claimed capacity. If this output sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Note: The Laserjet 1220 product cannot sense how much is in the output bin. The output bin can hold 150 sheets. This object refers only to the face-down output bin, not the face-up output tray.')
prtoutputremainingcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputremainingcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputremainingcapacity.setDescription('The remaining capacity of the possible output sub-unit capacity in output sub-unit capacity units (PrtCapacityUnitTC) of this output sub-unit. If this output sub-unit can reliably sense this value, the value is sensed by the printer and may not be modified by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. The value (-3) means that the printer knows that there remains capacity for at least one unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product does not have any sensing on the output bin, so it will always report unknown (-2). Note that for the Laserjet 1220 product this object is read-only (because any values written by a Remote Control Panel or a Management Application would be unreliable).')
prtoutputstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputstatus.setStatus('optional')
if mibBuilder.loadTexts: prtoutputstatus.setDescription('The current status of this output sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product cannot sense the output tray so this object will always return 5 (Unknown Status).')
prtmarkermarktech = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("ePelectrophotographicLaser", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkermarktech.setStatus('optional')
if mibBuilder.loadTexts: prtmarkermarktech.setDescription('The type of marking technology used for this marking sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkercounterunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7))).clone(namedValues=NamedValues(("ePimpressions", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkercounterunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkercounterunit.setDescription("The unit that will be used by the printer when reporting counter values for this marking sub-unit. The time units of measure are provided for a device like a strip recorder that does not or cannot track the physical dimensions of the media and does not use characters, lines or sheets. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Since the Laserjet 1220 product keeps track of pages printed, the counter unit will be defined as ePimpressions which would be like saying pages printed. (The term 'impressions' is used instead of 'pages' to avoid confusion between 'sheets' and 'pages' on a duplexing printer. This confusion isn't a problem with the Laserjet 1220 product because it has no duplexer.)")
prtmarkerlifecount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerlifecount.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerlifecount.setDescription('The count of the number of units of measure counted during the life of printer using units of measure as specified by prtMarkerCounterUnit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: In the Laserjet 1220 product the total engine page count is kept in NVRAM however the NVRAM value is only updated every 10 impressions. NOTE: The value returned by this OID will be incremented every page but if power is lost between NVRAM updates, up to 9 impressions of the page count may be lost. The counter will be reset to zero after 999999 pages. The page count is incremented when a sheet of media is pulled from an input tray.')
prtmarkerpoweroncount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerpoweroncount.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerpoweroncount.setDescription('The count of the number of units of measure counted since the equipment was most recently powered on using units of measure as specified by prtMarkerCounterUnit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkerprocesscolorants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerprocesscolorants.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerprocesscolorants.setDescription('The number of process colors supported by this marker. A process color of 1 implies monochrome. The value of this object and prtMarkerSpotColorants cannot both be 0. The value of prtMarkerProcessColorants must be 0 or greater. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkerspotcolorants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerspotcolorants.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerspotcolorants.setDescription('The number of spot colors supported by this marker. The value of this object and prtMarkerProcessColorants cannot both be 0. Must be 0 or greater. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkeraddressabilityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityunit.setDescription("The unit of measure of distances, as applied to the marker's resolution. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This will always be ePtenThousandthsOfInches, no matter what COLD-RESET-MEDIA-SIZE is because we are talking about resolution and toner addressability, which is always dpi.")
prtmarkeraddressabilityfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityfeeddir.setDescription("The maximum number of addressable marking positions in the feed direction per 10000 units of measure specified by prtMarkerAddressabilityUnit. A value of (-1) implies 'other' or 'infinite' while a value of (-2) implies 'unknown'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Use this object to specify resolution. The Laserjet 1220 product support 300, 600, or 1200 dots per inch with 1200 being the default. If this object changes it causes prtMarkerAddressabilityXFeedDir object to change to the same value.")
prtmarkeraddressabilityxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityxfeeddir.setDescription("The maximum number of addressable marking positions in the cross feed direction in 10000 units of measure specified by prtMarkerAddressabilityUnit. A value of (-1) implies 'other' or 'infinite' while a value of (-2) implies 'unknown'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Use this object to specify resolution. The Laserjet 1220 product support 300, 600, or 1200 dots per inch with 1200 being the default. If this object changes it causes prtMarkerAddressabilityFeedDir object to change to the same value.")
prtmarkernorthmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkernorthmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkernorthmargin.setDescription('The margin, in units identified by prtMarkerAddressabilityUnit, from the leading edge of the medium as the medium flows through the marking engine with the side to be imaged facing the observer. The leading edge is the North edge and the other edges are defined by the normal compass layout of directions with the compass facing the observer. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkersouthmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersouthmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersouthmargin.setDescription('The margin from the South edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkerwestmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerwestmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerwestmargin.setDescription('The margin from the West edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkereastmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkereastmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkereastmargin.setDescription('The margin from the East edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkerstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerstatus.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerstatus.setDescription('The current status of this marker sub-unit. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default value assumes the printer is idle and has no malfunctions. Default - 0 (Available and Idle) no toner cartridge - 51 (UnAvailable because Broken (3) + Critical Alert (16) + OffLine (32))')
prtmarkersuppliesmarkerindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesmarkerindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesmarkerindex.setDescription('The value of prtMarkerIndex corresponding to the marking sub-unit with which this marker supply sub-unit is associated. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has just one marker supply, the toner cartridge, so this value is always 1.')
prtmarkersuppliescolorantindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliescolorantindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliescolorantindex.setDescription('The value of prtMarkerColorantIndex corresponding to the colorant with which this marker supply sub-unit is associated. This value shall be 0 if there is no colorant table. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkersuppliesclass = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("ePother", 1), ("ePsupplyThatIsConsumed", 3), ("ePreceptacleThatIsFilled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesclass.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesclass.setDescription('Indicates whether this supply entity represents a supply that is consumed or a receptacle that is filled. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkersuppliestype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("ePtoner", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliestype.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliestype.setDescription('The type of this supply. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkersuppliesdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesdescription.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesdescription.setDescription('The description of this supply container/receptacle in the localization specified by prtGeneralCurrentLocalization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkersuppliessupplyunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(13))).clone(namedValues=NamedValues(("ePtenthsOfGrams", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliessupplyunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliessupplyunit.setDescription('Unit of measure of this marker supply container/receptacle. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmarkersuppliesmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesmaxcapacity.setDescription('The maximum capacity of this supply container/receptacle expressed in prtMarkerSuppliesSupplyUnit. If this supply container/receptacle can reliably sense this value, the value is reported by the printer and is read-only; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product always return -2 (Unknown).')
prtmarkersupplieslevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersupplieslevel.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersupplieslevel.setDescription('The current level if this supply is a container; the remaining space if this supply is a receptacle. If this supply container/receptacle can reliably sense this value, the value is reported by the printer and is read-only; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. A value of (-3) means that the printer knows that there is some supply/remaining space, respectively. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product cannot sense toner level. The Laserjet 1220 product always return -2 (Unknown).')
prtmediapathmaxspeedprintunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7))).clone(namedValues=NamedValues(("ePimpressionsPerHour", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxspeedprintunit.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxspeedprintunit.setDescription('The unit of measure used in specifying the speed of all media paths in the printer. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: ePimpressionsPerHour is the value that will always be returned for this object. (Print Speed is measured in pages-per-minute (impressions per minute), so ePimpressionsPerHour is a natural extension.)')
prtmediapathmediasizeunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmediasizeunit.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmediasizeunit.setDescription('The units of measure of media size for use in calculating and relaying dimensional values for all media paths in the printer. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtmediapathmaxspeed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxspeed.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxspeed.setDescription("The maximum printing speed of this media path expressed in prtMediaPathMaxSpeedUnit's. A value of (-1) implies 'other'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The page size for this performance is 8.5 x 11.")
prtmediapathmaxmediafeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxmediafeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxmediafeeddir.setDescription("The maximum physical media size in the feed direction of this media path expressed in units of measure specified by PrtMediaPathMediaSizeUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 140000 if prtInputDimUnit is ePtenThousandthsOfInches or 355600 if prtInputDimUnit is ePmicrometers. (14000 is the value arrived at because legal paper is the longest allowable on the Laserjet 1220 products.)")
prtmediapathmaxmediaxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxmediaxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxmediaxfeeddir.setDescription("The maximum physical media size across the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 85000 if prtInputDimUnit is ePtenThousandthsOfInches or 216000 if prtInputDimUnit is ePmicrometers.")
prtmediapathminmediafeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathminmediafeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathminmediafeeddir.setDescription("The minimum physical media size in the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 50000 if prtInputDimUnit is ePtenThousandthsOfInches or 127000 if prtInputDimUnit is ePmicrometers.")
prtmediapathminmediaxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathminmediaxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathminmediaxfeeddir.setDescription("The minimum physical media size across the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 30000 if prtInputDimUnit is ePtenThousandthsOfInches or 76200 if prtInputDimUnit is ePmicrometers. This size corresponds to a Monarch envelope. ")
prtmediapathtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5))).clone(namedValues=NamedValues(("ePsimplex", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathtype.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathtype.setDescription('The type of the media path for this media path. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This object describes how many paths there are through the engine disregarding the paper source (tray 1, 2, or 3). For the Laserjet 1220 product there is exactly one such path, a simplex path.')
prtmediapathdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathdescription.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathdescription.setDescription('The manufacturer-provided description of this media path in the localization specified by prtGeneralCurrentLocalization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product has one paper path, a simplex path.')
prtmediapathstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathstatus.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathstatus.setDescription('The current status of this media path. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The Laserjet 1220 product have one paper path, a simplex path. The default values assume the printer is idle. Default - 0 (Available and Idle) paper motion - 6 (Available and Busy) paper out in all trays - 9 (Non-Critical Alert(8) + Unavailable and OnRequest(1)) paper mount (any tray) - 0 (Available and Idle) manual feed prompt (PaperMount) - 48 (Critical Alert (16) + OffLine (32))')
prtchanneltype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 7, 10, 11, 15, 34, 35, 38))).clone(namedValues=NamedValues(("ePother", 1), ("ePchIEEE1284Port", 5), ("ePchAppleTalkPAP", 7), ("ePchNetwarePServer", 10), ("ePchPort9100", 11), ("ePchDLCLLCPort", 15), ("ePchUSB", 34), ("ePchIrDA", 35), ("ePchBidirPortTCP", 38)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchanneltype.setStatus('optional')
if mibBuilder.loadTexts: prtchanneltype.setDescription('The type of this print data channel. This object provides the linkage to ChannelType-specific groups that may (conceptually) extend the prtChannelTable with additional details about that channel. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: EIO based channels provide their own values.')
prtchannelprotocolversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelprotocolversion.setStatus('optional')
if mibBuilder.loadTexts: prtchannelprotocolversion.setDescription('The version of the protocol used on this channel. The format used for version numbering depends on prtChannelType. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: EIO based channels provide their own values. The channel 1 value includes (separated by semi colons) different aspects of the spec: electrical: logical: and physical connector.')
prtchannelcurrentjobcntllangindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelcurrentjobcntllangindex.setStatus('optional')
if mibBuilder.loadTexts: prtchannelcurrentjobcntllangindex.setDescription("The value of prtInterpreterIndex corresponding to the Control Language Interpreter for this channel. This interpreter defines the syntax used for control functions, such as querying or changing environment variables and identifying job boundaries (e.g. PJL, PostScript, NPAP). Must be 1 or greater. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This object points to the PJL language. It is read-only because PJL is the printer's only job control language.")
prtchanneldefaultpagedesclangindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtchanneldefaultpagedesclangindex.setStatus('optional')
if mibBuilder.loadTexts: prtchanneldefaultpagedesclangindex.setDescription('The value of prtInterpreterIndex corresponding to the Page Description Language Interpreter for this channel. This interpreter defines the default Page Description Language interpreter to be used for the print data unless the Control Language is used to select a specific interpreter (e.g., PCL, PostScript Language, auto-sense). Must be 1 or greater. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The default points to the automatic language switcher. If this object is changed for one channel, all channels will be changed.')
prtchannelstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("ePother", 1), ("ePprintDataAccepted", 3), ("ePnoDataAccepted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelstate.setStatus('optional')
if mibBuilder.loadTexts: prtchannelstate.setDescription("The state of this print data channel. The value determines whether control information and print data is allowed through this channel or not. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: EIO based channels provide their own values for this object. The base-printer's ports always report a value of ePprintDataAccepted. If the printer is offline, that is detected by reading the Host Resources General Printer Status objects, not by reading this object.")
prtchannelifindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelifindex.setStatus('optional')
if mibBuilder.loadTexts: prtchannelifindex.setDescription('The value of ifIndex (in the ifTable; see the interface section of MIB-2/RFC 1213) which corresponds to this channel. When more than one row of the ifTable is relevant, this is the index of the row representing the topmost layer in the interface hierarchy. A value of zero indicates that no interface is associated with this channel. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: EIO based channels provide their own values for this object.')
prtchannelstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelstatus.setStatus('optional')
if mibBuilder.loadTexts: prtchannelstatus.setDescription('The current status of the channel. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: IIO based channels provide their own values for this object.')
prtchannelinformation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelinformation.setStatus('optional')
if mibBuilder.loadTexts: prtchannelinformation.setDescription("Auxiliary information to allow a printing application to use the channel for data submission to the printer. An application capable of using a specific PrtChannelType should be able to use the combined information from the prtChannelInformation and other channel and interface group objects to 'bootstrap' its use of the channel. prtChannelInformation is not intended to provide a general channel description, nor to provide information that is available once the channel is in use. The encoding and interpretation of the prtChannelInformation object is specific to channel type. The description of each PrtChannelType enum value for which prtChannelInformation is defined specifies the appropriate encoding and interpretation, including interaction with other objects. For channel types that do not specify a prtChannelInformation value, its value shall be null (0 length). When a new PrtChannelType enumeration value is registered, its accompanying description must specify the encoding and interpretation of the prtChannelInformation value for the channel type. prtChannelInformation semantics for an existing PrtChannelType may be added or amended in the same manner as described in section 2.4.1 for type 2 enumeration values. The prtChannelInformation specifies values for a collection of channel attributes, represented as text according to the following rules: 1. The prtChannelInformation is coded in the NVT ASCII character set. It is not affected by localization. 2. The prtChannelInformation is a list of entries representing the attribute values. Each entry consists of the following items, in order: a. a keyword, composed of alphabetic characters (A-Z, a-z), that identifies a channel attribute, b. an Equals Sign (=) to delimit the keyword, c. a data value, consisting of NVT ASCII graphics characters (codes 32-126), d. a Line Feed character (code 10) to delimit the data value. No other characters shall be present. Keywords are case-sensitive. Conventionally, keywords are capitalized (including each word of a multi-word keyword), and, since they occupy space in the prtChannelInformation, they are kept short. 3. If a channel attribute has multiple values, it is represented by multiple entries with the same keyword, each specifying one value. Otherwise, there shall be at most one entry for each attribute. 4. By default, entries may appear in any order. If there are ordering constraints for particular entries, these must be specified in their definitions. 5. The prtChannelInformation value may represent information that is not normally coded in textual form, or that is coded in a character set other than NVT ASCII. In these cases, whatever symbolic representation is conventionally used for the information should be used for encoding the prtChannelInformation. (For instance, a binary port value might be represented as a decimal number, Unicode would be represented in UTF-8 format.) 6. For each PrtChannelType for which prtChannelInformation entries are defined, the descriptive text associated with the PrtChannelType enumeration value shall specify the following information for each entry: Title: Brief description phrase, e.g.: 'Port name', 'Service Name', Keyword: The keyword value, eg: 'Port', 'Service' Syntax: The encoding of the entry value, if it cannot be directly represented by NVT ASCII, Status: 'Mandatory', 'Optional', or 'Conditionally Mandatory', Multiplicity: 'Single' or 'Multiple', to indicate whether the entry may be present multiple times, Description: Description of the use of the entry, other information required to complete the definition (e.g.: ordering contstraints, interactions between entries). Applications that interpret prtChannelInformation should ignore unrecognized entries, so they are not affected if new entry types are added. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: EIO-based channels provide their own values for this object.")
prtinterpreterlangfamily = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 37, 47))).clone(namedValues=NamedValues(("ePother", 1), ("ePlangPCL", 3), ("ePlangPJL", 5), ("ePlangPS", 6), ("ePlangAutomatic", 37), ("ePlangPCLXL", 47)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlangfamily.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlangfamily.setDescription("The family name of a Page Description Language (PDL) or control language which this interpreter in the printer can interpret or emulate. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: ePlangAutomatic refers to the 'super-language' made available by implicit language switching.")
prtinterpreterlanglevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlanglevel.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlanglevel.setDescription("The level of the language which this interpreter is interpreting or emulating. This might contain a value like '5e' for an interpreter which is emulating level 5e of the PCL language. It might contain '2' for an interpreter which is emulating level 2 of the PostScript language. Similarly it might contain '2' for an interpreter which is emulating level 2 of the HPGL language. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.")
prtinterpreterlangversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlangversion.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlangversion.setDescription('The date code or version of the language which this interpreter is interpreting or emulating. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: These values are derived from the dateCode field of the personality entities. (ePlangautomatic uses the PJL dateCode.) For PostScript, this is more detailed revision information.')
prtinterpreterdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterdescription.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdescription.setDescription('A string to identify this interpreter in the localization specified by prtGeneralCurrentLocalization as opposed to the language which is being interpreted. It is anticipated that this string will allow manufacturers to unambiguously identify their interpreters. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: None of these strings are localized.')
prtinterpreterversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterversion.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterversion.setDescription('The date code, version number, or other product specific information tied to this interpreter. This value is associated with the interpreter, rather than with the version of the language which is being interpreted or emulated. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Same as prtInterpreterLangVersion.')
prtinterpreterdefaultorientation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePportrait", 3), ("ePlandscape", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinterpreterdefaultorientation.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultorientation.setDescription('The current orientation default for this interpreter. This value may be overridden for a particular job (e.g., by a command in the input data stream). Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: Interpreters 1 and 2 ignore the value of this object. The values for PCL and PostScript are either ePportrait or ePlandscape; attempting to set them to a different value will cause <badValue> to be returned. Setting this object for one interpreter will change it for all installed interpreters.')
prtinterpreterfeedaddressability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterfeedaddressability.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterfeedaddressability.setDescription('The maximum interpreter addressability in the feed direction in 10000 prtMarkerAddressabilityUnits (see prtMarkerAddressabilityFeedDir ) for this interpreter. The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtinterpreterxfeedaddressability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterxfeedaddressability.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterxfeedaddressability.setDescription('The maximum interpreter addressability in the cross feed direction in 10000 prtMarkerAddressabilityUnits (see prtMarkerAddressabilityXFeedDir) for this interpreter. The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtinterpreterdefaultcharsetin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 12, 13, 20, 21, 22, 23, 24, 25, 26, 1004, 2000, 2001, 2002, 2003, 2004, 2005, 2009, 2010, 2011, 2012, 2014, 2017, 2021, 2027))).clone(namedValues=NamedValues(("ePother", 1), ("ePcsASCII", 3), ("ePcsISOLatin1", 4), ("ePcsISOLatin2", 5), ("ePcsISOLatin5", 12), ("ePcsISOLatin6", 13), ("ePcsISO4UnitedKingdom", 20), ("ePcsISO11SwedishforNames", 21), ("ePcsISO15Italian", 22), ("ePcsISO17Spanish", 23), ("ePcsISO21German", 24), ("ePcsISO60DanishNorwegian", 25), ("ePcsISO69French", 26), ("ePcsUnicodeIBM2039", 1004), ("ePcsWindows30Latin1", 2000), ("ePcsWindows31Latin1", 2001), ("ePcsWindows31Latin2", 2002), ("ePcsWindows31Latin5", 2003), ("ePcsHPRoman8", 2004), ("ePcsAdobeStandardEncoding", 2005), ("ePcsPC850Multilingual", 2009), ("ePcsPCp852", 2010), ("ePcsPC8CodePage437", 2011), ("ePcsPC8DNDanishNorwegian", 2012), ("ePcsHPPC8Turkish", 2014), ("ePcsHPLegal", 2017), ("ePcsHPDeskTop", 2021), ("ePcsMacintosh", 2027)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetin.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetin.setDescription('The default coded character set for input octets encountered outside a context in which the Page Description Language established the interpretation of the octets. (Input octets are presented to the interpreter through a path defined in the channel group.) This value shall be (2) if there is no default. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: ePcsAdobeStandardEncoding is the same as PSText(10J). The object corresponding to PCL has read-write acces; all others are read-only. the above list corresponds to the following symbol sets as they appear on the Control Panel: ePother( 1) - used if designated coded char. set not in list ePcsASCII( 3) - ISO-6 ePcsISOLatin1( 4) - ISO L1 ePcsISOLatin2( 5) - IS L2 ePcsISOLatin5( 12) - ISO L5 ePcsISOLatin6( 13) - ISO L6 ePcsISO4UnitedKingdom( 20) - ISO-4 ePcsISO11SwedishforNames( 21) - ISO-11 ePcsISO15Italian( 22) - ISO-15 ePcsISO17Spanish( 23) - ISO-17 ePcsISO21German( 24) - ISO-21 ePcsISO60DanishNorwegian( 25) - ISO-60 ePcsISO69French( 26) - ISO-69 ePcsUnicodeIBM2039(1004) - PC-1004 ePcsWindows30Latin1( 2000) - WIN 3.0 ePcsWindows31Latin1( 2001) - WIN L1 ePcsWindows31Latin2( 2002) - WIN L2 ePcsWindows31Latin5( 2003) - WIN L5 ePcsHPRoman8( 2004) - ROMAN-8 ePcsAdobeStandardEncoding( 2005) - PS TEXT ePcsPC850Multilingual( 2009) - PC-850 ePcsPCp852( 2010) - PC-852 ePcsPC8CodePage437( 2011) - PC-8 ePcsPC8DNDanishNorwegian( 2012) - PC-8DN ePcsHPPC8Turkish( 2014) - PC-8 TK ePcsHPLegal( 2017) - LEGAL ePcsHPDeskTop( 2021) - DESKTOP ePcsMacintosh(2027) - MC TEXT')
prtinterpreterdefaultcharsetout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 2004, 2005))).clone(namedValues=NamedValues(("ePcsNoDefault", 2), ("ePcsASCII", 3), ("ePcsHPRoman8", 2004), ("ePcsAdobeStandardEncoding", 2005)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetout.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetout.setDescription("The default character set for data coming from this interpreter through the printer's output channel (i.e. the 'backchannel'). This value shall be (2) if there is no default. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.")
prtinterpretertwoway = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePyes", 3), ("ePno", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpretertwoway.setStatus('optional')
if mibBuilder.loadTexts: prtinterpretertwoway.setDescription('Indicates whether or not this interpreter returns information back to the host. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtconsoledisplaybuffertext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledisplaybuffertext.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledisplaybuffertext.setDescription("The content of a line in the logical display buffer of the operator's console of the printer. When a write operation occurs, normally a critical message, to one of the LineText strings, the agent should make that line displayable if a physical display is present. Writing a zero length string clears the line. It is an implementation-specific matter as to whether the agent allows a line to be overwritten before it has been cleared. Printer generated strings shall be in the localization specified by prtConsoleLocalization. Management Application generated strings should be localized by the Management Application. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.")
prtconsoleontime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoleontime.setStatus('optional')
if mibBuilder.loadTexts: prtconsoleontime.setDescription('This object, in conjunction with prtConsoleOffTime, defines the current status of the light. If both prtConsoleOnTime and prtConsoleOffTime are non-zero, the lamp is blinking and the values presented define the on time and off time, respectively, in milliseconds. If prtConsoleOnTime is zero and prtConsoleOffTime is non-zero, the lamp is off. If prtConsoleOffTime is zero and prtConsoleOnTime is non-zero, the lamp is on. If both values are zero the status of the lamp is undefined. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: There are three control panel LEDs: Attention, Ready, and Go. When an LED blinks, it is on for one half second and off for one half second. The value used for this object is 500 when the LED is on or blinking, otherwise it is zero. When the LEDs are in a cycling state the value of this object for all LEDs is zero and the value for prtConsoleOffTime for all LEDs is zero.')
prtconsoleofftime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoleofftime.setStatus('optional')
if mibBuilder.loadTexts: prtconsoleofftime.setDescription('This object, in conjunction with prtConsoleOnTime, defines the current status of the light. If both prtConsoleOnTime and prtConsoleOffTime are non-zero, the lamp is blinking and the values presented define the on time and off time, respectively, in milliseconds. If prtConsoleOnTime is zero and prtConsoleOffTime is non-zero, the lamp is off. If prtConsoleOffTime is zero and prtConsoleOnTime is non-zero, the lamp is on. If both values are zero the status of the lamp is undefined. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: There are three control panel LEDs: Attention, Ready, and Go. When an LED blinks, it is on for one half second and off for one half second. The value used for this object is 500 when the LED is off or blinking, otherwise it is zero. When the LEDs are in a cycling state the value of this object for all LEDs is zero and the value for prtConsoleOnTime for all LEDs is zero.')
prtconsolecolor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePwhite", 3), ("ePred", 4), ("ePgreen", 5), ("ePblue", 6), ("ePcyan", 7), ("ePmagenta", 8), ("ePyellow", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolecolor.setStatus('optional')
if mibBuilder.loadTexts: prtconsolecolor.setDescription('The color of this light. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtconsoledescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledescription.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledescription.setDescription('The vendor description or label of this light in the localization specified by prtConsoleLocalization. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtalertseveritylevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePcriticalBinaryChangeEvent", 3), ("ePwarningUnaryChangeEvent", 4), ("ePwarningBinaryChangeEvent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertseveritylevel.setStatus('optional')
if mibBuilder.loadTexts: prtalertseveritylevel.setDescription('The level of severity of this alert table entry. The printer determines the severity level assigned to each entry into the table. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtalerttraininglevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePuntrained", 3), ("ePtrained", 4), ("ePfieldService", 5), ("ePmanagement", 6), ("ePnoInterventionRequired", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalerttraininglevel.setStatus('optional')
if mibBuilder.loadTexts: prtalerttraininglevel.setDescription('See textual convention PrtAlertTrainingLevelTC Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: The value of this object depends on the alert condition as follows: ePuntrained: Paper low/out. ePtrained: Toner low. ePfieldService: Marker failure. ePmanagement: Configuration change.')
prtalertgroup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 8, 9, 10, 14))).clone(namedValues=NamedValues(("ePgeneralPrinter", 5), ("ePcover", 6), ("ePinput", 8), ("ePoutput", 9), ("ePmarker", 10), ("ePchannel", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertgroup.setStatus('optional')
if mibBuilder.loadTexts: prtalertgroup.setDescription('The type of sub-unit within the printer model that this alert is related. Input, output, and markers are examples of printer model groups, i.e., examples of types of sub-units. Wherever possible, these enumerations match the sub-identifier that identifies the relevant table in the printmib. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtalertgroupindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertgroupindex.setStatus('optional')
if mibBuilder.loadTexts: prtalertgroupindex.setDescription('An index of the row within the principle table in the group identified by prtAlertGroup that represents the sub-unit of the printer that caused this alert. The combination of the prtAlertGroup and the prtAlertGroupIndex defines exactly which printer sub-unit caused the alert.; for example, Input #3, Output #2, and Marker #1. Every object in this MIB is indexed with hrDeviceIndex and optionally, another index variable. If this other index variable is present in the table that generated the alert, it will be used as the value for this object. Otherwise, this value shall be -1. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtalertlocation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertlocation.setStatus('optional')
if mibBuilder.loadTexts: prtalertlocation.setDescription('The sub-unit location that is defined by the printer manufacturer to further refine the location of this alert within the designated sub-unit. The location is used in conjunction with the Group and GroupIndex values; for example, there is an alert in Input #2 at location number 7. The value (-2) indicates unknown Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.')
prtalertcode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 8, 801, 808))).clone(namedValues=NamedValues(("ePother", 1), ("ePcoverOpened", 3), ("ePjam", 8), ("ePinputMediaTrayMissing", 801), ("ePinputMediaSupplyEmpty", 808)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertcode.setStatus('optional')
if mibBuilder.loadTexts: prtalertcode.setDescription('See associated textual convention PrtAlertCodeTC Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: ePother is returned for a variety of conditions, including: page punt, io buffer overflow, memory overflow, and warming up. ePcoverOpened is returned for both door open (top) and/or toner cartridge missing. ePinputMediaTrayMissing is returned when paper is out in all trays. And, ePinputMediaSupplyEmpty is returned for a paper prompt.')
prtalertdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertdescription.setStatus('optional')
if mibBuilder.loadTexts: prtalertdescription.setDescription("A description of this alert entry in the localization specified by prtGeneralCurrentLocalization. The description is provided by the printer to further elaborate on the enumerated alert or provide information in the case where the code is classified as `other' or `unknown'. The printer is required to return a description string but the string may be a null string. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details.")
prtalerttime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalerttime.setStatus('optional')
if mibBuilder.loadTexts: prtalerttime.setDescription('The value of sysUpTime at the time that this alert was generated. Refer to Internet Draft Printer MIB, expiring Sept. 1997 for more details. Additional information: This object is always zero.')
mibBuilder.exportSymbols("LJ1220-MIB", prtmediapathminmediafeeddir=prtmediapathminmediafeeddir, error10=error10, prtlocalizationlanguage=prtlocalizationlanguage, job_info_attr_12=job_info_attr_12, prtmarkercounterunit=prtmarkercounterunit, simm1_type=simm1_type, scan_resolution_range=scan_resolution_range, default_page_protect=default_page_protect, print_internal_page=print_internal_page, simm2_type=simm2_type, prtinputsecurity=prtinputsecurity, prtStorageRefEntry=prtStorageRefEntry, hrdevicedescr=hrdevicedescr, prtinputmediadimfeeddirchosen=prtinputmediadimfeeddirchosen, job=job, prtalertcriticalevents=prtalertcriticalevents, prtinputdefaultindex=prtinputdefaultindex, prtMarkerSuppliesEntry=prtMarkerSuppliesEntry, prtInputEntry=prtInputEntry, install_date=install_date, prtmarkersuppliesmarkerindex=prtmarkersuppliesmarkerindex, prtLocalization=prtLocalization, prtinputtype=prtinputtype, prtMarkerEntry=prtMarkerEntry, prtmarkerdefaultindex=prtmarkerdefaultindex, tray1_media_size_loaded=tray1_media_size_loaded, device=device, job_info_outcome=job_info_outcome, tables=tables, hrPrinterTable=hrPrinterTable, error9=error9, pcl_default_font_number=pcl_default_font_number, prtmediapathstatus=prtmediapathstatus, print_engine=print_engine, prtinputversion=prtinputversion, simm2=simm2, test=test, copier_quality=copier_quality, prtoutputcapacityunit=prtoutputcapacityunit, on_off_line=on_off_line, prtmediapathdefaultindex=prtmediapathdefaultindex, not_ready_source_scanner=not_ready_source_scanner, model_name=model_name, scanner_motor_control=scanner_motor_control, prtAlertEntry=prtAlertEntry, prtmarkereastmargin=prtmarkereastmargin, default_print_quality=default_print_quality, scanner=scanner, error5_time_stamp=error5_time_stamp, print_density=print_density, default_scanner_margin_right=default_scanner_margin_right, hp=hp, scan_token=scan_token, hrdevicestatus=hrdevicestatus, error5_code=error5_code, pcl_default_font_source=pcl_default_font_source, simm1_capacity=simm1_capacity, current_job_parsing_id=current_job_parsing_id, prtCover=prtCover, channel_table=channel_table, status_system=status_system, prtoutputmaxcapacity=prtoutputmaxcapacity, prtmarkersuppliesmaxcapacity=prtmarkersuppliesmaxcapacity, prtConsoleLightTable=prtConsoleLightTable, copier_job_quality=copier_job_quality, prtOutputEntry=prtOutputEntry, prtgeneralserviceperson=prtgeneralserviceperson, scanner_button_status=scanner_button_status, error2_code=error2_code, io_switch=io_switch, prtmarkeraddressabilityfeeddir=prtmarkeraddressabilityfeeddir, energy_star=energy_star, prtgeneralserialnumber=prtgeneralserialnumber, mio1=mio1, default_lines_per_page=default_lines_per_page, prtConsoleLights=prtConsoleLights, error4_time_stamp=error4_time_stamp, settings_prt_eng=settings_prt_eng, prtlocalizationcountry=prtlocalizationcountry, errorlog=errorlog, error3_code=error3_code, job_info_attr_1=job_info_attr_1, hrdeviceindex=hrdeviceindex, scan_calibration_target=scan_calibration_target, scan_adf_page_count=scan_adf_page_count, prtmediapathmaxspeed=prtmediapathmaxspeed, prtalerttraininglevel=prtalerttraininglevel, hrDeviceEntry=hrDeviceEntry, serial_number=serial_number, prtstoragerefindex=prtstoragerefindex, error_log_clear=error_log_clear, error7=error7, hrstorageallocationunits=hrstorageallocationunits, channel_jobs_received=channel_jobs_received, prtMarkerSupplies=prtMarkerSupplies, prtchannelcurrentjobcntllangindex=prtchannelcurrentjobcntllangindex, prtInterpreter=prtInterpreter, prtinputmaxcapacity=prtinputmaxcapacity, pjl_password=pjl_password, prtinputcapacityunit=prtinputcapacityunit, prtmediapathtype=prtmediapathtype, error10_time_stamp=error10_time_stamp, prtgeneralreset=prtgeneralreset, scan_resolution=scan_resolution, prtinterpreterlangfamily=prtinterpreterlangfamily, error5=error5, pysmi_continue=pysmi_continue, job_info_attr_13=job_info_attr_13, prtchannelprotocolversion=prtchannelprotocolversion, prtCoverTable=prtCoverTable, prtinterpretertwoway=prtinterpretertwoway, settings_intray=settings_intray, print_engine_jam_count=print_engine_jam_count, postscript_resource_saving_memory_size=postscript_resource_saving_memory_size, default_copies=default_copies, error6_code=error6_code, settings_io=settings_io, hrdevicetype=hrdevicetype, job_info_size=job_info_size, service_password=service_password, prtoutputstatus=prtoutputstatus, copier_job_num_copies=copier_job_num_copies, prtconsoleontime=prtconsoleontime, total_engine_page_count=total_engine_page_count, asset_number=asset_number, prtmarkernorthmargin=prtmarkernorthmargin, scan_contrast=scan_contrast, copier_adf_page_count=copier_adf_page_count, prtinputcurrentlevel=prtinputcurrentlevel, prtchannelinformation=prtchannelinformation, prtmarkersuppliessupplyunit=prtmarkersuppliessupplyunit, pcl_default_font_width=pcl_default_font_width, cold_reset_media_size=cold_reset_media_size, prtmarkersuppliescolorantindex=prtmarkersuppliescolorantindex, active_print_jobs=active_print_jobs, prtinterpreterdefaultorientation=prtinterpreterdefaultorientation, tray1_fuser_temperature=tray1_fuser_temperature, transfer_setting=transfer_setting, sleep_mode=sleep_mode, system=system, channel_bytes_sent=channel_bytes_sent, hrprinterdetectederrorstate=hrprinterdetectederrorstate, channel_bytes_received=channel_bytes_received, prtCoverEntry=prtCoverEntry, job_info_attr_5=job_info_attr_5, print_engine_mispick_count=print_engine_mispick_count, copier_reduction=copier_reduction, scan_upload_error=scan_upload_error, prtinputmedianame=prtinputmedianame, prtchanneldefaultpagedesclangindex=prtchanneldefaultpagedesclangindex, scanner_adf_page_count=scanner_adf_page_count, job_info_attr_15=job_info_attr_15, prtConsoleDisplayBuffer=prtConsoleDisplayBuffer, pdl=pdl, copier_token=copier_token, prtStorageRefTable=prtStorageRefTable, scan_calibration_download=scan_calibration_download, prtalerttime=prtalerttime, prtoutputdefaultindex=prtoutputdefaultindex, imaging=imaging, error4=error4, device_location=device_location, prtInterpreterTable=prtInterpreterTable, default_scanner_margin_left=default_scanner_margin_left, job_info_name2=job_info_name2, pdl_postscript=pdl_postscript, auto_continue=auto_continue, prtlocalizationcharacterset=prtlocalizationcharacterset, channel_io_errors=channel_io_errors, prtconsolenumberofdisplaylines=prtconsolenumberofdisplaylines, job_input_auto_continue_mode=job_input_auto_continue_mode, intray1=intray1, prtDeviceRefTable=prtDeviceRefTable, prtmarkerpoweroncount=prtmarkerpoweroncount, custom_paper_xfeed_dim=custom_paper_xfeed_dim, printmib=printmib, hrDevice=hrDevice, mio1_type=mio1_type, prtChannel=prtChannel, device_name=device_name, prtmediapathminmediaxfeeddir=prtmediapathminmediaxfeeddir, error6_time_stamp=error6_time_stamp, prtOutputTable=prtOutputTable, prtLocalizationTable=prtLocalizationTable, prtGeneral=prtGeneral, hrstoragetype=hrstoragetype, default_bits_per_pixel=default_bits_per_pixel, intrays=intrays, error8_code=error8_code, prtinputdimunit=prtinputdimunit, prtmarkeraddressabilityunit=prtmarkeraddressabilityunit, prtMediaPath=prtMediaPath, prtinputname=prtinputname, prtinterpreterdescription=prtinterpreterdescription, hrDeviceTable=hrDeviceTable, scan_compression=scan_compression, prtinputdescription=prtinputdescription, prtmediapathmediasizeunit=prtmediapathmediasizeunit, prtinputmodel=prtinputmodel, prtGeneralEntry=prtGeneralEntry, job_info_outbins_used=job_info_outbins_used, scan_pixel_data_type=scan_pixel_data_type, prtconsoledescription=prtconsoledescription, simm=simm, ui_select_option=ui_select_option, channelprinteralert=channelprinteralert, default_media_size=default_media_size, prtalertdescription=prtalertdescription, prtgeneralconfigchanges=prtgeneralconfigchanges, error4_code=error4_code, channelnumberofchannels=channelnumberofchannels, job_info_attribute=job_info_attribute, prtmediapathmaxmediaxfeeddir=prtmediapathmaxmediaxfeeddir, prtalertgroupindex=prtalertgroupindex, job_info_attr_2=job_info_attr_2, settings_scanner=settings_scanner, copier_contrast=copier_contrast, prtmediapathdescription=prtmediapathdescription, job_info_state=job_info_state, prtmarkermarktech=prtmarkermarktech, prtconsoleofftime=prtconsoleofftime, prtinterpreterversion=prtinterpreterversion, settings_job=settings_job, default_vertical_black_resolution=default_vertical_black_resolution, error9_code=error9_code, ui_add_option=ui_add_option, prtoutputtype=prtoutputtype, prtalertseveritylevel=prtalertseveritylevel, job_info_attr_16=job_info_attr_16, scan_upload=scan_upload, status_scanner=status_scanner, prtoutputremainingcapacity=prtoutputremainingcapacity, error8_time_stamp=error8_time_stamp, prtDeviceRefEntry=prtDeviceRefEntry, reprint=reprint, io=io, dm=dm, status_pdl=status_pdl, prtinputserialnumber=prtinputserialnumber, copier_collation=copier_collation, scan_calibration_error=scan_calibration_error, prtInterpreterEntry=prtInterpreterEntry, custom_paper_feed_dim=custom_paper_feed_dim, pjl=pjl, prtchannelstatus=prtchannelstatus, processing_subsystem=processing_subsystem, hrstorageindex=hrstorageindex, prtmediapathmaxspeedprintunit=prtmediapathmaxspeedprintunit, pdl_pcl=pdl_pcl, pcl_default_font_height=pcl_default_font_height, prtmarkersuppliestype=prtmarkersuppliestype, hrStorageTable=hrStorageTable, copier_job_reduction=copier_job_reduction, prtLocalizationEntry=prtLocalizationEntry)
mibBuilder.exportSymbols("LJ1220-MIB", prtmediapathmaxmediafeeddir=prtmediapathmaxmediafeeddir, hrstorageallocationfailures=hrstorageallocationfailures, job_info_physical_outbins_used=job_info_physical_outbins_used, prtmarkersuppliesdescription=prtmarkersuppliesdescription, copier_job_media_size=copier_job_media_size, error7_code=error7_code, copier_job=copier_job, prtAlert=prtAlert, prtconsolelocalization=prtconsolelocalization, prtmarkerspotcolorants=prtmarkerspotcolorants, scanner_jam_page_count=scanner_jam_page_count, prtconsoledisable=prtconsoledisable, prtinterpreterxfeedaddressability=prtinterpreterxfeedaddressability, prtConsoleDisplayBufferTable=prtConsoleDisplayBufferTable, self_test=self_test, prtmarkersupplieslevel=prtmarkersupplieslevel, job_info_attr_7=job_info_attr_7, prtmarkerstatus=prtmarkerstatus, dark_courier=dark_courier, scan_calibration=scan_calibration, job_info_attr_3=job_info_attr_3, postscript_print_errors=postscript_print_errors, prtgeneralcurrentoperator=prtgeneralcurrentoperator, job_info_attr_6=job_info_attr_6, job_info_stage=job_info_stage, prtMarker=prtMarker, hrPrinterEntry=hrPrinterEntry, prtChannelTable=prtChannelTable, copier_job_collation=copier_job_collation, error10_code=error10_code, prtMediaPathEntry=prtMediaPathEntry, intray=intray, job_info_change_id=job_info_change_id, status_copier=status_copier, prtConsoleLightEntry=prtConsoleLightEntry, job_info_pages_printed=job_info_pages_printed, scan_subsample=scan_subsample, settings_copier=settings_copier, prtOutput=prtOutput, job_being_parsed=job_being_parsed, prtinterpreterdefaultcharsetin=prtinterpreterdefaultcharsetin, io_timeout=io_timeout, prtdevicerefindex=prtdevicerefindex, prtconsoledisplaybuffertext=prtconsoledisplaybuffertext, maximum_resource_saving_memory=maximum_resource_saving_memory, copier_num_copies=copier_num_copies, channel=channel, job_info_attr_14=job_info_attr_14, mio=mio, job_info_pages_processed=job_info_pages_processed, destination_subsystem=destination_subsystem, error7_time_stamp=error7_time_stamp, prtinterpreterlanglevel=prtinterpreterlanglevel, hrprinterstatus=hrprinterstatus, prtmarkerprocesscolorants=prtmarkerprocesscolorants, prtmarkeraddressabilityxfeeddir=prtmarkeraddressabilityxfeeddir, copier_job_contrast=copier_job_contrast, prtinputmediadimxfeeddirdeclared=prtinputmediadimxfeeddirdeclared, job_info_io_source=job_info_io_source, prtgeneralcurrentlocalization=prtgeneralcurrentlocalization, scan_image_type=scan_image_type, prtAlertTable=prtAlertTable, status_prt_eng=status_prt_eng, hrstorageused=hrstorageused, hrdeviceerrors=hrdeviceerrors, error1_code=error1_code, hrdeviceid=hrdeviceid, default_ret=default_ret, resource_saving=resource_saving, prtchannelifindex=prtchannelifindex, error3_time_stamp=error3_time_stamp, scanner_retrieve_scanline=scanner_retrieve_scanline, form_feed_needed=form_feed_needed, custom_paper_dim_unit=custom_paper_dim_unit, prtinterpreterlangversion=prtinterpreterlangversion, hrStorageEntry=hrStorageEntry, prtcoverstatus=prtcoverstatus, fw_rom_datecode=fw_rom_datecode, prtconsolenumberofdisplaychars=prtconsolenumberofdisplaychars, prtchanneltype=prtchanneltype, source_subsystem=source_subsystem, prtinputmediadimxfeeddirchosen=prtinputmediadimxfeeddirchosen, hrmemorysize=hrmemorysize, prtgeneralprintername=prtgeneralprintername, hrstoragesize=hrstoragesize, device_config_token=device_config_token, hrm=hrm, wide_a4=wide_a4, default_horizontal_black_resolution=default_horizontal_black_resolution, simm2_capacity=simm2_capacity, scan_height=scan_height, scan_control_descriptor=scan_control_descriptor, scan_gamma_correction=scan_gamma_correction, hrStorage=hrStorage, default_vmi=default_vmi, job_info_attr_10=job_info_attr_10, job_info_attr_11=job_info_attr_11, prtConsoleDisplayBufferEntry=prtConsoleDisplayBufferEntry, error6=error6, DisplayString=DisplayString, error1_time_stamp=error1_time_stamp, hrstoragedescr=hrstoragedescr, error9_time_stamp=error9_time_stamp, interface=interface, prtMarkerTable=prtMarkerTable, prtinterpreterdefaultcharsetout=prtinterpreterdefaultcharsetout, ui_delete_option=ui_delete_option, scan_pad_image=scan_pad_image, prtmarkerwestmargin=prtmarkerwestmargin, scanner_scanline_statistics=scanner_scanline_statistics, copier_print_page_count=copier_print_page_count, job_info_name1=job_info_name1, prtinputvendorname=prtinputvendorname, prtalertlocation=prtalertlocation, copier_job_status=copier_job_status, prtchannelstate=prtchannelstate, prtalertgroup=prtalertgroup, prtinterpreterfeedaddressability=prtinterpreterfeedaddressability, prtinputmediadimfeeddirdeclared=prtinputmediadimfeeddirdeclared, prtmarkerlifecount=prtmarkerlifecount, copier=copier, prtInputTable=prtInputTable, job_info_attr_8=job_info_attr_8, prtMediaPathTable=prtMediaPathTable, prtinputstatus=prtinputstatus, form_feed=form_feed, job_info=job_info, error8=error8, job_info_attr_4=job_info_attr_4, scan_compression_factor=scan_compression_factor, settings_system=settings_system, error2_time_stamp=error2_time_stamp, prtconsolecolor=prtconsolecolor, prtInput=prtInput, prtMarkerSuppliesTable=prtMarkerSuppliesTable, error1=error1, id=id, prtmarkersuppliesclass=prtmarkersuppliesclass, channel_entry=channel_entry, error3=error3, job_input_auto_continue_timeout=job_input_auto_continue_timeout, simm1=simm1, prtmarkersouthmargin=prtmarkersouthmargin, prtalertcode=prtalertcode, prtGeneralTable=prtGeneralTable, prtcoverdescription=prtcoverdescription, job_info_attr_9=job_info_attr_9, prtChannelEntry=prtChannelEntry, settings_pdl=settings_pdl, error2=error2, prtalertallevents=prtalertallevents, pcl_resource_saving_memory_size=pcl_resource_saving_memory_size)

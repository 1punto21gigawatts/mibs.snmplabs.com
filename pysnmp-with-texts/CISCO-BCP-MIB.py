#
# PySNMP MIB module CISCO-BCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-BCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:15 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Unsigned32, IpAddress, Counter32, Integer32, Bits, NotificationType, TimeTicks, ObjectIdentity, MibIdentifier, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Gauge32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "IpAddress", "Counter32", "Integer32", "Bits", "NotificationType", "TimeTicks", "ObjectIdentity", "MibIdentifier", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Gauge32", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ciscoBcpMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 275))
ciscoBcpMIB.setRevisions(('2004-08-31 00:00', '2002-08-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoBcpMIB.setRevisionsDescriptions(('Import Unsigned32 from SNMPv2-SMI.', 'Initial Version of this MIB module.',))
if mibBuilder.loadTexts: ciscoBcpMIB.setLastUpdated('200408310000Z')
if mibBuilder.loadTexts: ciscoBcpMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoBcpMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W. Tasman Drive San Jose, CA 95134-1706 USA Tel: +1 800 553-NETS E-mail: osm-wan-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoBcpMIB.setDescription('This MIB module describes the Managed Objects for of Bridge Control Protocol (RFC2878). This MIB is influenced by RFC1474. ')
ciscoBcpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 275, 1))
bcpOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 1), )
if mibBuilder.loadTexts: bcpOperTable.setStatus('current')
if mibBuilder.loadTexts: bcpOperTable.setDescription('Table containing the status of the local BCP entity that is related to the operation of Bridging Control Protocol.')
bcpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bcpOperEntry.setStatus('current')
if mibBuilder.loadTexts: bcpOperEntry.setDescription('Operational status information for a particular BCP link. For all entries in ifTable with ifType ppp(23), there will be an entry in this table.')
bcpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("listening", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcpOperStatus.setStatus('current')
if mibBuilder.loadTexts: bcpOperStatus.setDescription('The operational status of the Bridge Control Protocol. The possible values are : open(1) - the BCP link is up and both ends are configured in the compatible manner. closed(2) - the BCP link is down and neither ends are configured. listening(3) - the local BCP entity is configured and the remote end is not configured compatibly.')
bcpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2), )
if mibBuilder.loadTexts: bcpConfigTable.setStatus('current')
if mibBuilder.loadTexts: bcpConfigTable.setDescription('Table containing the configuration information for the local BCP entity that is related to the operation of Bridging over the PPP link.')
bcpConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: bcpConfigEntry.setStatus('current')
if mibBuilder.loadTexts: bcpConfigEntry.setDescription('Bridging Configuration information for a particular BCP link. For all entries in ifTable with ifType ppp(23), there will be an entry in this table.')
bcpConfigBridgeIdControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigBridgeIdControl.setReference('Section 5.1, Bridge-Identification, of RFC2878')
if mibBuilder.loadTexts: bcpConfigBridgeIdControl.setStatus('current')
if mibBuilder.loadTexts: bcpConfigBridgeIdControl.setDescription('The Bridge-Identification configuration option is designed for use when the line is an interface between half bridges connecting virtual or physical LAN segments. When enabled the local BCP entity initiates a Bridge Identification Option negotiation. ')
bcpConfigBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigBridgeId.setReference('Section 5.1, Bridge-Identification, of RFC2878')
if mibBuilder.loadTexts: bcpConfigBridgeId.setStatus('current')
if mibBuilder.loadTexts: bcpConfigBridgeId.setDescription('The bridge number of the local BCP entity. This value is meaningful only when the local BCP entity has negotiated the BridgeId Configuration option, which means the value of bcpConfigBridgeIdControl is enabled(1). The two half bridges must agree on the bridge number.')
bcpConfigLineIdControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigLineIdControl.setReference('Section 5.2 , Line Identification, of RFC2878')
if mibBuilder.loadTexts: bcpConfigLineIdControl.setStatus('current')
if mibBuilder.loadTexts: bcpConfigLineIdControl.setDescription('The Line-Identification configuration option is designed for use when the line is assigned a LAN segment number. When enabled the local BCP entity initiates a Line Identification Option negotiation.')
bcpConfigLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigLineId.setReference('Section 5.2, Line-Identification, of RFC2878')
if mibBuilder.loadTexts: bcpConfigLineId.setStatus('current')
if mibBuilder.loadTexts: bcpConfigLineId.setDescription('The LAN segment number of the local BCP entity. This value is meaningful only when the local BCP entity negotiated the LineId Configuration option, which means the value of bcpConfigLineIdControl is enabled(1). The two half bridges must agree on the LAN segment number.')
bcpConfigMacSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigMacSupport.setReference('Section 5.3 , MAC-Support, of RFC2878')
if mibBuilder.loadTexts: bcpConfigMacSupport.setStatus('current')
if mibBuilder.loadTexts: bcpConfigMacSupport.setDescription('The Mac-Support configuration option is provided to permit implementations to indicate the sort of traffic they are prepared to receive. When enabled the local BCP entity initiates a Mac-Support Option negotiation. ')
bcpConfigMacType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 11, 12))).clone(namedValues=NamedValues(("ieee802dot3Canonical", 1), ("ieee802dot4Canonical", 2), ("ieee802dot5NonCanonical", 3), ("fddiNonCanonical", 4), ("ieee802dot5Canonical", 11), ("fddiCanonical", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigMacType.setReference('Section 5.3, Mac-Support, of RFC2878')
if mibBuilder.loadTexts: bcpConfigMacType.setStatus('current')
if mibBuilder.loadTexts: bcpConfigMacType.setDescription('The MAC type that this local BCP entity is prepared to receive and service. This value is meaningful only when the local BCP entity has negotiated the MAC-Support Configuration option, which means the value of bcpConfigMacSupport is enabled(1). These values definition are specified in the most recent RFC1700. ')
bcpConfigTinygram = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigTinygram.setReference('Section 5.4 , Tinygram-Compression, of RFC2878')
if mibBuilder.loadTexts: bcpConfigTinygram.setStatus('current')
if mibBuilder.loadTexts: bcpConfigTinygram.setDescription('The Tinygram-Compression configuration option permits implementations to indicate support for Tinygram Compression. When enabled the local BCP Entity initiates a Tinygram-Compression Option negotiation. ')
bcpConfigMacAddressControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigMacAddressControl.setReference('Section 5.5 , Mac-Address , of RFC2878')
if mibBuilder.loadTexts: bcpConfigMacAddressControl.setStatus('current')
if mibBuilder.loadTexts: bcpConfigMacAddressControl.setDescription('The Mac-Address configuration option enables the implementations to announce its MAC address or have one assigned. When enabled the local BCP Entity initiates a Mac-Address Option negotiation. ')
bcpConfigMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigMacAddress.setReference('Section 5.5, MAC-Address, of RFC2878')
if mibBuilder.loadTexts: bcpConfigMacAddress.setStatus('current')
if mibBuilder.loadTexts: bcpConfigMacAddress.setDescription('This value is meaningful only when the local BCP entity has negotiated the MAC-Address configuration option, which means the value of bcpConfigMacAddressControl is enabled(1). If it is non-zero format, the local BCP get its MAC address announced. It is represented in IEEE 802.1 Canonical format. If it is in zero format, i.e. 00-00-00-00-00-00 then the implementation of the system wishes to have a MAC address assigned.')
bcpConfigSpanTreeControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigSpanTreeControl.setReference('Section 5.6, Spanning-Tree-Protocol, of RFC2878')
if mibBuilder.loadTexts: bcpConfigSpanTreeControl.setStatus('current')
if mibBuilder.loadTexts: bcpConfigSpanTreeControl.setDescription('The Spanning-Tree-Protocol configuration option enables a bridge to remain compatible with older implementations of BCP. When enabled the local BCP Entity initiates a Spanning-Tree-Protocol Option negotiation. ')
bcpConfigSpanTree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("null", 0), ("ieee802dot1D", 1), ("ieee802dot1GExtended", 2), ("ibmSourceRoute", 3), ("decLanBridge100", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigSpanTree.setReference('Section 5.6, Spanning-Tree-Protocol, of RFC 2878')
if mibBuilder.loadTexts: bcpConfigSpanTree.setStatus('current')
if mibBuilder.loadTexts: bcpConfigSpanTree.setDescription('The desired spanning tree protocol of the local BCP entity. The listing values of the Spanning- Tree Protocol are specified in the most recent RFC1700. This value is meaningful only when the local BCP entity has negotiated the Spanning-Tree-Protocol configuration option, which means the value of bcpConfigSpanTreeControl is enabled(1). ')
bcpConfigIeee802dot1qTagged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigIeee802dot1qTagged.setReference('Section 5.7, IEEE-802-Tagged-Frame, of RFC2878')
if mibBuilder.loadTexts: bcpConfigIeee802dot1qTagged.setStatus('current')
if mibBuilder.loadTexts: bcpConfigIeee802dot1qTagged.setDescription('The IEEE-802-Tagged-Frame configuration option permits the implementation to support for IEEE 802.1q Tagged Frame. When enabled the local BCP Entity initiates a IEEE-802-Tagged-Frame Option negotiation. ')
bcpConfigMgmtInline = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigMgmtInline.setReference('Section 5.8 , Management-Inline, of RFC2878')
if mibBuilder.loadTexts: bcpConfigMgmtInline.setStatus('current')
if mibBuilder.loadTexts: bcpConfigMgmtInline.setDescription('The Management-Inline configuration option indicates that the system is willing to receive any IEEE-defined inter-bridge protocols. When enabled if the local BCP Entity initiates a Management-Inline Option negotiation. ')
bcpConfigBCPacketIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 275, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcpConfigBCPacketIndicator.setReference('Section 5.9 , Bridge-Control-Packet-Indicator, of RFC2878')
if mibBuilder.loadTexts: bcpConfigBCPacketIndicator.setStatus('current')
if mibBuilder.loadTexts: bcpConfigBCPacketIndicator.setDescription('The Bridge Control Packet Indicator configuration option permits the implementation to indicate support for Bridge Control Packet Indicator. When enabled the local BCP Entity initiates a Bridge Control Packet Indicator Option negotiation. ')
cBcpMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 275, 3))
cBcpMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 275, 3, 1))
cBcpMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 275, 3, 2))
cBcpMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 275, 3, 1, 1)).setObjects(("CISCO-BCP-MIB", "cBcpMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cBcpMIBCompliance = cBcpMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cBcpMIBCompliance.setDescription('The compliance statement for entities which implement this Cisco BCP MIB.')
cBcpMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 275, 3, 2, 1)).setObjects(("CISCO-BCP-MIB", "bcpOperStatus"), ("CISCO-BCP-MIB", "bcpConfigBridgeIdControl"), ("CISCO-BCP-MIB", "bcpConfigBridgeId"), ("CISCO-BCP-MIB", "bcpConfigLineIdControl"), ("CISCO-BCP-MIB", "bcpConfigLineId"), ("CISCO-BCP-MIB", "bcpConfigMacSupport"), ("CISCO-BCP-MIB", "bcpConfigMacType"), ("CISCO-BCP-MIB", "bcpConfigTinygram"), ("CISCO-BCP-MIB", "bcpConfigMacAddressControl"), ("CISCO-BCP-MIB", "bcpConfigMacAddress"), ("CISCO-BCP-MIB", "bcpConfigSpanTreeControl"), ("CISCO-BCP-MIB", "bcpConfigSpanTree"), ("CISCO-BCP-MIB", "bcpConfigIeee802dot1qTagged"), ("CISCO-BCP-MIB", "bcpConfigMgmtInline"), ("CISCO-BCP-MIB", "bcpConfigBCPacketIndicator"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cBcpMIBGroup = cBcpMIBGroup.setStatus('current')
if mibBuilder.loadTexts: cBcpMIBGroup.setDescription('A collection of objects providing the configuration and operating status of the BCP entity.')
mibBuilder.exportSymbols("CISCO-BCP-MIB", PYSNMP_MODULE_ID=ciscoBcpMIB, bcpConfigTable=bcpConfigTable, bcpConfigMgmtInline=bcpConfigMgmtInline, bcpConfigMacAddressControl=bcpConfigMacAddressControl, cBcpMIBCompliance=cBcpMIBCompliance, bcpConfigMacAddress=bcpConfigMacAddress, cBcpMIBConformance=cBcpMIBConformance, bcpConfigSpanTreeControl=bcpConfigSpanTreeControl, bcpConfigBridgeId=bcpConfigBridgeId, bcpConfigIeee802dot1qTagged=bcpConfigIeee802dot1qTagged, bcpConfigLineId=bcpConfigLineId, cBcpMIBGroup=cBcpMIBGroup, ciscoBcpMIB=ciscoBcpMIB, cBcpMIBGroups=cBcpMIBGroups, ciscoBcpMIBObjects=ciscoBcpMIBObjects, bcpConfigLineIdControl=bcpConfigLineIdControl, bcpConfigMacSupport=bcpConfigMacSupport, bcpOperTable=bcpOperTable, bcpOperStatus=bcpOperStatus, bcpConfigBCPacketIndicator=bcpConfigBCPacketIndicator, bcpConfigEntry=bcpConfigEntry, bcpOperEntry=bcpOperEntry, bcpConfigMacType=bcpConfigMacType, cBcpMIBCompliances=cBcpMIBCompliances, bcpConfigTinygram=bcpConfigTinygram, bcpConfigBridgeIdControl=bcpConfigBridgeIdControl, bcpConfigSpanTree=bcpConfigSpanTree)

#
# PySNMP MIB module ATM2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATM2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
atmVclVpi, atmVclVci, atmMIBObjects, atmVpCrossConnectEntry, atmVcCrossConnectEntry, atmInterfaceConfEntry, atmVplVpi, atmVplEntry, atmVclEntry = mibBuilder.importSymbols("ATM-MIB", "atmVclVpi", "atmVclVci", "atmMIBObjects", "atmVpCrossConnectEntry", "atmVcCrossConnectEntry", "atmInterfaceConfEntry", "atmVplVpi", "atmVplEntry", "atmVclEntry")
AtmSigDescrParamIndex, AtmIlmiNetworkPrefix, AtmAddr, AtmTrafficDescrParamIndex, AtmVpIdentifier, AtmInterfaceType, AtmVcIdentifier = mibBuilder.importSymbols("ATM-TC-MIB", "AtmSigDescrParamIndex", "AtmIlmiNetworkPrefix", "AtmAddr", "AtmTrafficDescrParamIndex", "AtmVpIdentifier", "AtmInterfaceType", "AtmVcIdentifier")
InterfaceIndexOrZero, InterfaceIndex, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Integer32, Bits, IpAddress, MibIdentifier, ObjectIdentity, Unsigned32, TimeTicks, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter64, NotificationType, ModuleIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Bits", "IpAddress", "MibIdentifier", "ObjectIdentity", "Unsigned32", "TimeTicks", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter64", "NotificationType", "ModuleIdentity", "Gauge32")
DisplayString, RowStatus, TruthValue, TextualConvention, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TruthValue", "TextualConvention", "TimeStamp")
atm2MIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 37, 1, 14))
atm2MIB.setRevisions(('2003-09-23 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atm2MIB.setRevisionsDescriptions(('Initial version of this MIB, published as RFC 3606.',))
if mibBuilder.loadTexts: atm2MIB.setLastUpdated('200309230000Z')
if mibBuilder.loadTexts: atm2MIB.setOrganization('IETF AToMMIB Working Group')
if mibBuilder.loadTexts: atm2MIB.setContactInfo('AToMMIB WG http://www.ietf.org/html.charters/atommib-charter.html Editors: Faye Ly Postal: Pedestal Networks 6503 Dumbarton Circle Fremont, CA 94555 USA Tel: +1 510 896 2908 E-Mail: faye@pedestalnetworks.com Michael Noto Postal: Cisco Systems 170 W. Tasman Drive San Jose, CA 95134-1706 USA E-mail: mnoto@cisco.com Andrew Smith Postal: Consultant E-Mail: ah_smith@acm.org Ethan Mickey Spiegel Postal: Cisco Systems 170 W. Tasman Drive San Jose, CA 95134-1706 USA Tel: +1 408 526 6408 Fax: +1 408 526 6488 E-Mail: mspiegel@cisco.com Kaj Tesink Postal: Telcordia Technologies 331 Newman Springs Road Red Bank, NJ 07701 USA Tel: +1 732 758 5254 E-mail: kaj@research.telcordia.com')
if mibBuilder.loadTexts: atm2MIB.setDescription('Copyright (C) The Internet Society (2003). This version of this MIB module is part of RFC 3606; see the RFC itself for full legal notices. This MIB Module is a supplement to the ATM-MIB defined in RFC 2515.')
atm2MIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 1))
atm2MIBTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2))
atmSvcVpCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1), )
if mibBuilder.loadTexts: atmSvcVpCrossConnectTable.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectTable.setDescription('The ATM SVPC Cross-Connect table. A bi-directional VP cross-connect between two switched VPLs is modeled as one entry in this table. A Soft PVPC cross-connect, between a soft permanent VPL and a switched VPL, is also modeled as one entry in this table.')
atmSvcVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1), ).setIndexNames((0, "ATM2-MIB", "atmSvcVpCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmSvcVpCrossConnectEntry.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectEntry.setDescription('An entry in the ATM SVPC Cross-Connect table. This entry is used to model a bi-directional ATM VP cross-connect between two VPLs.')
atmSvcVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmSvcVpCrossConnectIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectIndex.setDescription('A unique value to identify this SVPC cross-connect. For each VP associated with this cross-connect, the agent reports this cross-connect index value in the atmVplCrossConnectIdentifer attribute of the corresponding atmVplTable entries.')
atmSvcVpCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowIfIndex.setDescription('The value of this object is equal to the ifIndex value of the ATM interface port for this SVPC cross-connect. The term low implies that this ATM interface has the numerically lower ifIndex value than the other ATM interface identified in the same atmSvcVpCrossConnectEntry.')
atmSvcVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 3), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value associated with the SVPC cross-connect at the ATM interface that is identified by atmSvcVpCrossConnectLowIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceCurrentMaxSvpcVpi at the low ATM interface port.')
atmSvcVpCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighIfIndex.setDescription('The value of this object is equal to the ifIndex value of the ATM interface port for this SVC VP cross-connect. The term high implies that this ATM interface has the numerically higher ifIndex value than the other ATM interface identified in the same atmSvcVpCrossConnectEntry.')
atmSvcVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 5), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value associated with the SVPC cross-connect at the ATM interface that is identified by atmSvcVpCrossConnectHighIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceCurrentMaxSvpcVpi at the high ATM interface port.')
atmSvcVpCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVpCrossConnectCreationTime.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectCreationTime.setDescription('The value of the sysUpTime object at the time this bi-directional SVPC cross-connect was created. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.')
atmSvcVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVpCrossConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSvcVpCrossConnectRowStatus.setDescription('This object is used to delete rows in the atmSvcVpCrossConnectTable.')
atmSvcVcCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2), )
if mibBuilder.loadTexts: atmSvcVcCrossConnectTable.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectTable.setDescription('The ATM SVCC Cross-Connect table. A bi-directional VC cross-connect between two switched VCLs is modeled as one entry in this table. A Soft PVCC cross-connect, between a soft permanent VCL and a switched VCL, is also modeled as one entry in this table.')
atmSvcVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1), ).setIndexNames((0, "ATM2-MIB", "atmSvcVcCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVci"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmSvcVcCrossConnectEntry.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectEntry.setDescription('An entry in the ATM SVCC Cross-Connect table. This entry is used to model a bi-directional ATM VC cross-connect between two VCLs.')
atmSvcVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmSvcVcCrossConnectIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectIndex.setDescription('A unique value to identify this SVCC cross-connect. For each VP associated with this cross-connect, the agent reports this cross-connect index value in the atmVclCrossConnectIdentifier attribute of the corresponding atmVplTable entries.')
atmSvcVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowIfIndex.setDescription('The value of this object is equal to the ifIndex value of the ATM interface port for this SVCC cross-connect. The term low implies that this ATM interface has the numerically lower ifIndex value than the other ATM interface identified in the same atmSvcVcCrossConnectEntry.')
atmSvcVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 3), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value associated with the SVCC cross-connect at the ATM interface that is identified by atmSvcVcCrossConnectLowIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceCurrentMaxSvccVpi at the low ATM interface port.')
atmSvcVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 4), AtmVcIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVci.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI value associated with the SVCC cross-connect at the ATM interface that is identified by atmSvcVcCrossConnectLowIfIndex. The VCI value cannot exceed the number supported by the atmInterfaceCurrentMaxSvccVci at the low ATM interface port.')
atmSvcVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 5), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighIfIndex.setDescription('The value of this object is equal to the ifIndex value for the ATM interface port for this SVCC cross-connect. The term high implies that this ATM interface has the numerically higher ifIndex value than the other ATM interface identified in the same atmSvcVcCrossConnectEntry.')
atmSvcVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 6), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVpi.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value associated with the SVCC cross-connect at the ATM interface that is identified by atmSvcVcCrossConnectHighIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceCurrentMaxSvccVpi at the high ATM interface port.')
atmSvcVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 7), AtmVcIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVci.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI value associated with the SVCC cross-connect at the ATM interface that is identified by atmSvcVcCrossConnectHighIfIndex. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the high ATM interface port.')
atmSvcVcCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVcCrossConnectCreationTime.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectCreationTime.setDescription('The value of the sysUpTime object at the time this bi-directional SVCC cross-connect was created. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.')
atmSvcVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVcCrossConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSvcVcCrossConnectRowStatus.setDescription('This object is used to delete rows in the atmSvcVcCrossConnectTable.')
atmSigStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3), )
if mibBuilder.loadTexts: atmSigStatTable.setStatus('current')
if mibBuilder.loadTexts: atmSigStatTable.setDescription('This table contains ATM interface signalling statistics, one entry per ATM signalling interface.')
atmSigStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmSigStatEntry.setDescription('This list contains signalling statistics variables.')
atmSigSSCOPConEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setReference('ITU-T Recommendation Q.2110, Broadband Integrated Services Digital Network (B-ISDN) - ATM Adaptation Layer - Service Specific Connection Oriented Protocol (SSCOP) Specification, July 1994.')
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setDescription('SSCOP Connection Events Counter. This counter counts the sum of the following errors: 1) SSCOP Connection Disconnect Counter The abnormal occurrence of this event is characterized by the expiry of Timer_NO_RESPONSE. (This event is communicated to the layer management with MAA-ERROR code P. See ITU-T Q.2110.) 2) SSCOP Connection Initiation Failure This condition indicates the inability to establish an SSCOP connection. This event occurs whenever the number of expiries of the connection control timer (Timer_CC) equals or exceeds the MaxCC, or upon receipt of a connection reject message BGREJ PDU. (This event is communicated to layer management with MAA-ERROR code O. See ITU-T Q.2110.) 3) SSCOP Connection Re-Establ/Resynch This event occurs upon receipt of a BGN PDU or RS PDU.')
atmSigSSCOPErrdPdus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setReference('ITU-T Recommendation Q.2110, Broadband Integrated Services Digital Network (B-ISDN) - ATM Adaptation Layer - Service Specific Connection Oriented Protocol (SSCOP) Specification, July 1994.')
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setStatus('current')
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setDescription('SSCOP Errored PDUs Counter. This counter counts the sum of the following errors: 1) Invalid PDUs. These are defined in SSCOP and consist of PDUs with an incorrect length (MAA-ERROR code U), an undefined PDU type code, or that are not 32-bit aligned. 2) PDUs that result in MAA-ERROR codes and are discarded. See MAA-ERROR codes A-D, F-M, and Q-T defined in ITU-T Q.2110.')
atmSigDetectSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectSetupAttempts.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectSetupAttempts.setDescription('Call Setup Attempts Counter. This counter counts the number of call setup attempts (both successful and unsuccessful) detected on this interface.')
atmSigEmitSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitSetupAttempts.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitSetupAttempts.setDescription('Call Setup Attempts Counter. This counter counts the number of call setup attempts (both successful and unsuccessful) transmitted on this interface.')
atmSigDetectUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailRoutes.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectUnavailRoutes.setDescription('Number of Route Unavailability detected on this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 1 unallocated (unassigned) number 2 no route to specified transit network 3 no route to destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
atmSigEmitUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailRoutes.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitUnavailRoutes.setDescription('Number of Route Unavailability transmitted from this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 1 unallocated (unassigned) number 2 no route to specified transit network 3 no route to destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
atmSigDetectUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailResrcs.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectUnavailResrcs.setDescription('Number of Resource Unavailability detected on this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 35 requested VPCI/VCI not available 37 user cell rate not available (UNI3.1 only) 38 network out of order 41 temporary failure 45 no VPCI/VCI available 47 resource unavailable, unspecified 49 Quality of Service unavailable 51 user cell rate not available (UNI3.0 only) 58 bearer capability not presently available 63 Service or option not available, unspecified 92 too many pending add party requests NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
atmSigEmitUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailResrcs.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitUnavailResrcs.setDescription('Number of Resource Unavailability transmitted from this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 35 requested VPCI/VCI not available 37 user cell rate not available (UNI3.1 only) 38 network out of order 41 temporary failure 45 no VPCI/VCI available 47 resource unavailable, unspecified 49 Quality of Service unavailable 51 user cell rate not available (UNI3.0 only) 58 bearer capability not presently available 63 Service or option not available, unspecified 92 too many pending add party requests NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
atmSigDetectCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectCldPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call detected on this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 17 user busy 18 no user responding 21 call rejected 22 number changed 23 user rejects all calls with calling line identification restriction (CLIR) 27 destination out of order 31 normal, unspecified 88 incompatible destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted. Note: Cause Value #30 'response to STATUS ENQUIRY' was not included in this memo since it did not apply to a hard failure.")
atmSigEmitCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitCldPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful Call transmitted from this interface. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 17 user busy 18 no user responding 21 call rejected 22 number changed 23 user rejects all calls with calling line identification restriction (CLIR) 27 destination out of order 31 normal, unspecified 88 incompatible destination NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted. Note: Cause Value #30 'response to STATUS ENQUIRY' was not included in this memo since it did not apply to a hard failure.")
atmSigDetectMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectMsgErrors.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectMsgErrors.setDescription("Number of Incorrect Messages detected on this interface. The Incorrect Messages Counter reflects any sort of incorrect information in a message. This includes: - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT, and STATUS messages transmitted, that contain any of the Cause values listed below. - Ignored messages. These messages are dropped because the message was so damaged that it could not be further processed. A list of dropped messages is compiled below: 1. Message with invalid protocol discriminator 2. Message with errors in the call reference I.E. - Bits 5-8 of the first octet not equal to '0000' - Bits 1-4 of the first octet indicating a length other than 3 octets - RELEASE COMPLETE message received with a call reference that does not relate to a call active or in progress - SETUP message received with call reference flag incorrectly set to 1 - SETUP message received with a call reference for a call that is already active or in progress. 3. Message too short The following cause values are monitored by this counter (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 10 VPCI/VCI unacceptable (UNI3.0 only) 36 VPCI/VCI assignment failure (UNI3.1 only) 81 invalid call reference value 82 identified channel does not exist 89 invalid endpoint reference 96 mandatory information element is missing 97 message type non-existent or not implemented 99 information element non-existent or not implemented 100 invalid information element contents 101 message not compatible with call state 104 incorrect message length 111 protocol error, unspecified NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
atmSigEmitMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitMsgErrors.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitMsgErrors.setDescription("Number of Incorrect Messages transmitted on this interface. The Incorrect Messages Counter reflects any sort of incorrect information in a message. This includes: - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT, and STATUS messages transmitted or received, that contain any of the Cause values listed below. - Ignored messages. These messages are dropped because the message was so damaged that it could not be further processed. A list of dropped messages is compiled below: 1. Message with invalid protocol discriminator 2. Message with errors in the call reference I.E. - Bits 5-8 of the first octet not equal to '0000' - Bits 1-4 of the first octet indicating a length other than 3 octets - RELEASE COMPLETE message received with a call reference that does not relate to a call active or in progress - SETUP message received with call reference flag incorrectly set to 1 - SETUP message received with a call reference for a call that is already active or in progress. 3. Message too short The following cause values are monitored by this counter (Note: These cause values apply to both UNI3.0 and UNI3.1 unless otherwise stated): Cause Value Meaning 10 VPCI/VCI unacceptable (UNI3.0 only) 36 VPCI/VCI assignment failure (UNI3.1 only) 81 invalid call reference value 82 identified channel does not exist 89 invalid endpoint reference 96 mandatory information element is missing 97 message type non-existent or not implemented 99 information element non-existent or not implemented 100 invalid information element contents 101 message not compatible with call state 104 incorrect message length 111 protocol error, unspecified NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
atmSigDetectClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectClgPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectClgPtyEvents.setDescription('Number of Calling Party Events detected on this interface. This counter monitors error events that occur due to the originating user doing something wrong. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is received (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 28 invalid number format (address incomplete) 43 access information discarded 57 bearer capability not authorized 65 bearer capability not implemented 73 unsupported combination of traffic parameters 78 AAL parameters cannot be supported (UNI3.1 only) 91 invalid transit network selection 93 AAL parameters cannot be supported (UNI3.0 only) NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
atmSigEmitClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitClgPtyEvents.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitClgPtyEvents.setDescription('Number of Calling Party Events transmitted from this interface. This counter monitors error events that occur due to the originating user doing something wrong. This counter is incremented when a RELEASE, RELEASE COMPLETE (only when not preceded by a RELEASE message for the same call), ADD PARTY REJECT, or STATUS message that contains one of the following cause code values is transmitted (Note: These cause values apply to both UNI3.0 and UNI3.1): Cause Value Meaning 28 invalid number format (address incomplete) 43 access information discarded 57 bearer capability not authorized 65 bearer capability not implemented 73 unsupported combination of traffic parameters 78 AAL parameters cannot be supported (UNI3.1 only) 91 invalid transit network selection 93 AAL parameters cannot be supported (UNI3.0 only) NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.')
atmSigDetectTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectTimerExpireds.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectTimerExpireds.setDescription("Number of Timer Expiries detected on this interface. The Timer Expiries Counter provides a count of network timer expiries, and to some extent, host or switch timer expiries. The conditions for incrementing this counter are: - Expiry of any network timer - Receipt of a RELEASE or RELEASE COMPLETE message with Cause #102, 'recovery on timer expiry'. NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
atmSigEmitTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitTimerExpireds.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitTimerExpireds.setDescription("Number of Timer Expiries transmitted from this interface. The Timer Expiries Counter provides a count of network timer expiries, and to some extent, host or switch timer expiries. The conditions for incrementing this counter are: - Expiry of any network timer - Receipt of a RELEASE or RELEASE COMPLETE message with Cause #102, 'recovery on timer expiry'. NOTE: For this counter, RELEASE COMPLETE messages that are a reply to a previous RELEASE message and contain the same cause value, are redundant (for counting purposes) and should not be counted.")
atmSigDetectRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectRestarts.setStatus('current')
if mibBuilder.loadTexts: atmSigDetectRestarts.setDescription('Number of Restart Activity errors detected on this interface. The Restart Activity Counter provides a count of host, switch, or network restart activity. This counter is incremented when receiving a RESTART message.')
atmSigEmitRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitRestarts.setStatus('current')
if mibBuilder.loadTexts: atmSigEmitRestarts.setDescription('Number of Restart Activity errors transmitted from this interface. The Restart Activity Counter provides a count of host, switch, or network restart activity. This counter is incremented when transmitting a RESTART message.')
atmSigInEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigInEstabls.setStatus('current')
if mibBuilder.loadTexts: atmSigInEstabls.setDescription('Number of SVCs established at this signalling entity for incoming connections.')
atmSigOutEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigOutEstabls.setStatus('current')
if mibBuilder.loadTexts: atmSigOutEstabls.setDescription('Number of SVCs established at this signalling entity for outgoing connections.')
atmSigSupportTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4), )
if mibBuilder.loadTexts: atmSigSupportTable.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM signalling interface.')
atmSigSupportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigSupportEntry.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportEntry.setDescription('This list contains signalling configuration parameters and state variables.')
atmSigSupportClgPtyNumDel = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtyNumDel.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportClgPtyNumDel.setDescription('This object indicates whether the Calling Party Number Information Element is transferred to the called party address. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
atmSigSupportClgPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtySubAddr.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportClgPtySubAddr.setDescription("This object indicates whether to accept and transfer the Calling Party Subaddress Information Element from the calling party to the called party. Calling party subaddress information shall only be transferred to the called party if calling party number delivery is enabled (i.e., atmSigSupportClgPtyNumDel = 'enabled(1)'. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.")
atmSigSupportCldPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportCldPtySubAddr.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportCldPtySubAddr.setDescription('This object indicates whether to accept, transfer, and deliver the Called Party Subaddress Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
atmSigSupportHiLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportHiLyrInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportHiLyrInfo.setDescription('This object indicates whether to accept, transfer, and deliver the Broadband High Layer Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
atmSigSupportLoLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportLoLyrInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportLoLyrInfo.setDescription('This object indicates whether to accept, transfer, and deliver the Broadband Low Layer Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
atmSigSupportBlliRepeatInd = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportBlliRepeatInd.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportBlliRepeatInd.setDescription("This object indicates whether to accept, transfer, and deliver the Broadband Repeat Indicator with two or three instances of the Broadband Low Layer Information Element for low layer information selection from the calling party to the called party. This object's value should always be disabled(2) if the value of atmSigSupportLolyrInfo is disabled(2). The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.")
atmSigSupportAALInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportAALInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportAALInfo.setDescription('This object indicates whether to accept, transfer, and deliver the ATM Adaptation Layer Parameters Information Element from the calling party to the called party. The value of this object can be: - enabled(1) This Information Element is transferred to the called party - disabled(2) This Information Element is NOT transferred to the called party.')
atmSigSupportPrefCarrier = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 8), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportPrefCarrier.setStatus('current')
if mibBuilder.loadTexts: atmSigSupportPrefCarrier.setDescription("This parameter identifies the carrier to which intercarrier calls originated from this interface are routed when transit network selection information is not provided by the calling party. If a Carrier Identification Code (CIC) is used the parameter shall contain the CIC. For three-digit CICs, the first octet shall be '0' and the CIC is contained in the three following octets. If the preferred carrier feature is not supported the value is a zero-length string.")
atmSigDescrParamTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5), )
if mibBuilder.loadTexts: atmSigDescrParamTable.setReference('ATM User-Network Interface Specification, Version 3.1 (UNI 3.1), September 1994, Section 5.4.5 Variable Length Information Elements.')
if mibBuilder.loadTexts: atmSigDescrParamTable.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamTable.setDescription('A table contains signalling capabilities of VCLs except the Traffic Descriptor. Traffic descriptors are described in the atmTrafficDescrParamTable.')
atmSigDescrParamEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1), ).setIndexNames((0, "ATM2-MIB", "atmSigDescrParamIndex"))
if mibBuilder.loadTexts: atmSigDescrParamEntry.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamEntry.setDescription('Each entry in this table represents a set of signalling capabilities that can be applied to a VCL. There is no requirement for unique entries, except that the index must be unique.')
atmSigDescrParamIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 1), AtmSigDescrParamIndex())
if mibBuilder.loadTexts: atmSigDescrParamIndex.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamIndex.setDescription('The value of this object is used by the atmVclGenSigDescrIndex object in the atmVclGenTable to identify a row in this table.')
atmSigDescrParamAalType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("aal1", 2), ("aal34", 3), ("aal5", 4), ("userDefined", 5), ("aal2", 6))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalType.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamAalType.setDescription('The AAL type. The value of this object is set to other(1) when not defined.')
atmSigDescrParamAalSscsType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("assured", 2), ("nonassured", 3), ("frameRelay", 4), ("null", 5))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalSscsType.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamAalSscsType.setDescription('The SSCS type used by this entry.')
atmSigDescrParamBhliType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("iso", 2), ("user", 3), ("hiProfile", 4), ("vendorSpecific", 5))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliType.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBhliType.setDescription('The Broadband high layer type.')
atmSigDescrParamBhliInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliInfo.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBhliInfo.setDescription('The Broadband high layer information. When atmSigDescrParamBhliType is set to iso(2), the value of this object is a zero length string. When atmSigDescrParamBhliType is set to user(3), the value of this object is an octet string with length ranging from 0 to 8. When atmSigDescrParamBhliType is set to hiProfile(4), the value of this object is a length of 4 octet string containing user to user profile identifier. When atmSigDescrParamBhliType is set to vendorSpecific(5), the value of this object is a length of 7 octet string, where the most significant 3 octets consist of a globally- administered OUI, and the least significant 4 octets are the vender administered application OUI.')
atmSigDescrParamBbcConnConf = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptp", 1), ("ptmp", 2))).clone('ptp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBbcConnConf.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBbcConnConf.setDescription('The Broadband bearer capability user plane connection configuration parameter.')
atmSigDescrParamBlliLayer2 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("iso1745", 2), ("q921", 3), ("x25linklayer", 4), ("x25multilink", 5), ("lapb", 6), ("hdlcArm", 7), ("hdlcNrm", 8), ("hdlcAbm", 9), ("iso88022", 10), ("x75slp", 11), ("q922", 12), ("userDef", 13), ("iso7776", 14))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer2.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer2.setDescription('The Broadband low layer information, protocol type of layer 2. The value of this object is other(1) if layer 2 protocol is not used.')
atmSigDescrParamBlliLayer3 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("x25pkt", 2), ("isoiec8208", 3), ("x223iso8878", 4), ("isoiec8473", 5), ("t70", 6), ("tr9577", 7), ("userDef", 8))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer3.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer3.setDescription('The Broadband low layer information, protocol type of layer 3. The value of this object is other(1) if layer 3 protocol is not used.')
atmSigDescrParamBlliPktSize = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("s16", 2), ("s32", 3), ("s64", 4), ("s128", 5), ("s256", 6), ("s512", 7), ("s1024", 8), ("s2048", 9), ("s4096", 10))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliPktSize.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliPktSize.setDescription('The default packet size defined in B-LLI.')
atmSigDescrParamBlliSnapId = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliSnapId.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliSnapId.setDescription('The SNAP ID used for Broadband low layer protocol layer 3. The value of this object is other(1) if atmSigDescrParamBlliLayer3 is set to other(1).')
atmSigDescrParamBlliOuiPid = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 11), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(5, 5), )).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliOuiPid.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamBlliOuiPid.setDescription('The OUI/PID encoding for Broadband low layer protocol layer 3. The value of this object is a zero length string if atmSigDescrParamBlliLayer3 is set to other(1). When used, it is always 5 octets with the most significant octet as the OUI Octet 1 and the least significant octet as the PID Octet 2.')
atmSigDescrParamRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSigDescrParamRowStatus.setDescription('This object is used to create and delete rows in the atmSigDescrParamTable.')
atmIfRegisteredAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6), )
if mibBuilder.loadTexts: atmIfRegisteredAddrTable.setStatus('current')
if mibBuilder.loadTexts: atmIfRegisteredAddrTable.setDescription('This table contains a list of ATM addresses that can be used for calls to and from a given interface by a switch or service. The ATM addresses are either registered by the endsystem via ILMI or statically configured. This table does not expose PNNI reachability information. ILMI registered addresses cannot be deleted using this table. This table only applies to switches and network services.')
atmIfRegisteredAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIfRegAddrAddress"))
if mibBuilder.loadTexts: atmIfRegisteredAddrEntry.setStatus('current')
if mibBuilder.loadTexts: atmIfRegisteredAddrEntry.setDescription('An entry in the ATM Interface Registered Address table.')
atmIfRegAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmIfRegAddrAddress.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrAddress.setDescription('An address registered for a given switch or service interface.')
atmIfRegAddrAddressSource = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRegAddrAddressSource.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrAddressSource.setDescription('The type of address source for a given ATM Address. The value dynamic(3) is indicated when ILMI is used.')
atmIfRegAddrOrgScope = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("localNetwork", 1), ("localNetworkPlusOne", 2), ("localNetworkPlusTwo", 3), ("siteMinusOne", 4), ("intraSite", 5), ("sitePlusOne", 6), ("organizationMinusOne", 7), ("intraOrganization", 8), ("organizationPlusOne", 9), ("communityMinusOne", 10), ("intraCommunity", 11), ("communityPlusOne", 12), ("regional", 13), ("interRegional", 14), ("global", 15)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrOrgScope.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrOrgScope.setDescription('This object indicates the organizational scope for the referenced address. The information of the referenced address shall not be distributed outside the indicated scope. Refer to Annex 5.3 of ATM Forum UNI Signalling 4.0 for guidelines regarding the use of organizational scopes. This value cannot be configured for ILMI-registered addresses. The default values for organizational scope are localNetwork(1) for ATM group addresses, and global(15) for individual addresses.')
atmIfRegAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmIfRegAddrRowStatus.setDescription('This object is used to create and delete rows in the atmIfRegisteredAddrTable. Rows created dynamically (e.g., ILMI- registered addresses) cannot be deleted using this object.')
atmVclAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7), )
if mibBuilder.loadTexts: atmVclAddrTable.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrTable.setDescription('This table provides a mapping between the atmVclTable and the ATM called party/calling party address. This table can be used to retrieve the calling party and called party ATM address pair for a given VCL. Note that there can be more than one pair of calling party and called party ATM addresses for a VCL in a point to multi-point call.')
atmVclAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM2-MIB", "atmVclAddrAddr"))
if mibBuilder.loadTexts: atmVclAddrEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrEntry.setDescription('Each entry in this table represents a binding between a VCL and an ATM address associated with this call. This ATM address can be either the called party address or the calling party address. There can be more than one pair of calling/called party ATM addresses associated with the VCL entry for point to multi-point calls. Objects atmVclAddrType, and atmVclAddrRowStatus are required during row creation.')
atmVclAddrAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmVclAddrAddr.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrAddr.setDescription('An ATM address on one end of the VCL. For SVCs, the agent supplies the value of this object at creation time. For PVC VCL, the manager can supply the value of this object during or after the PVC VCL creation.')
atmVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrType.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrType.setDescription('The type of ATM Address represented by the object atmVclAddrAddr. Choices are either the calling party ATM address or the called party ATM address.')
atmVclAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVclAddrRowStatus.setDescription('This object is used to create or destroy an entry from this table. Note that the manager entity can only destroy the PVC VCLs.')
atmAddrVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8), )
if mibBuilder.loadTexts: atmAddrVclTable.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclTable.setDescription('This table provides an alternative way to retrieve the atmVclTable. This table can be used to retrieve the indexing to the atmVclTable by an ATM address.')
atmAddrVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1), ).setIndexNames((0, "ATM2-MIB", "atmVclAddrAddr"), (0, "ATM2-MIB", "atmAddrVclAtmIfIndex"), (0, "ATM2-MIB", "atmAddrVclVpi"), (0, "ATM2-MIB", "atmAddrVclVci"))
if mibBuilder.loadTexts: atmAddrVclEntry.setReference('Tesink, K., Editor, Definitions of Managed Objects for ATM Management, RFC 2515, Bell Communications Research, February, 1999.')
if mibBuilder.loadTexts: atmAddrVclEntry.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclEntry.setDescription('Each entry in this table represents an entry in the atmVclTable of the ATM-MIB by its ATM address. The ATM address is either the calling or called party ATM address of the call. Entries in this table are read only. They show up when entries are created in the atmVclAddrTable.')
atmAddrVclAtmIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: atmAddrVclAtmIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclAtmIfIndex.setDescription('The interface index of the ATM interface to which this VCL pertains. This object combined with the atmAddrVclVpi and atmAddrVclVci objects serves as an index to the atmVclTable.')
atmAddrVclVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 2), AtmVpIdentifier())
if mibBuilder.loadTexts: atmAddrVclVpi.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclVpi.setDescription('The VPI value of the VCL. This object combined with the atmAddrVclAtmIfIndex and atmAddrVclVci objects serves as an index to the atmVclTable.')
atmAddrVclVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 3), AtmVcIdentifier())
if mibBuilder.loadTexts: atmAddrVclVci.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclVci.setDescription('The VCI value of the VCL. This object combined with the atmAddrVclAtmIfIndex and atmAddrVclVpi objects serves as an index to the atmVclTable.')
atmAddrVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAddrVclAddrType.setStatus('current')
if mibBuilder.loadTexts: atmAddrVclAddrType.setDescription('The type of ATM Address represented by the object atmVclAddrAddr. Choices are either calling party address or called party address.')
atmVplStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9), )
if mibBuilder.loadTexts: atmVplStatTable.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTable.setDescription('This table contains all statistics counters per VPL. It is used to monitor the usage of the VPL in terms of incoming cells and outgoing cells.')
atmVplStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVplStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmVplStatEntry.setDescription('Each entry in this table represents a VPL.')
atmVplStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellIns.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTotalCellIns.setDescription('The total number of valid ATM cells received by this VPL including both CLP=0 and CLP=1 cells. The cells are counted prior to the application of the traffic policing.')
atmVplStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellIns.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0CellIns.setDescription('The number of valid ATM cells received by this VPL with CLP=0. The cells are counted prior to the application of the traffic policing.')
atmVplStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTotalDiscards.setDescription('The total number of valid ATM cells discarded by the traffic policing entity. This includes cells originally received with CLP=0 and CLP=1.')
atmVplStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 and discarded by the traffic policing entity.')
atmVplStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVplStatTotalCellOuts.setDescription('The total number of valid ATM cells transmitted by this VPL. This includes both CLP=0 and CLP=1 cells.')
atmVplStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0 by this VPL.')
atmVplStatClp0Tagged = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Tagged.setStatus('current')
if mibBuilder.loadTexts: atmVplStatClp0Tagged.setDescription('The total number of valid ATM cells tagged by the traffic policing entity from CLP=0 to CLP=1.')
atmVplLogicalPortTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10), )
if mibBuilder.loadTexts: atmVplLogicalPortTable.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortTable.setDescription('Indicates whether the VPL is an ATM Logical Port interface (ifType=80).')
atmVplLogicalPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1), )
atmVplEntry.registerAugmentions(("ATM2-MIB", "atmVplLogicalPortEntry"))
atmVplLogicalPortEntry.setIndexNames(*atmVplEntry.getIndexNames())
if mibBuilder.loadTexts: atmVplLogicalPortEntry.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortEntry.setDescription('An entry with information about the ATM Logical Port interface.')
atmVplLogicalPortDef = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notLogicalIf", 1), ("isLogicalIf", 2))).clone('notLogicalIf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplLogicalPortDef.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortDef.setDescription('Indicates whether the VPC at this VPL interface is an ATM Logical Port interface.')
atmVplLogicalPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplLogicalPortIndex.setStatus('current')
if mibBuilder.loadTexts: atmVplLogicalPortIndex.setDescription('The ifTable index of the ATM logical port interface associated with this VPL. The distinguished value of zero indicates that the agent has not (yet) assigned such an ifTable Index. The zero value must be assigned by the agent if the value of atmVplLogicalPortDef is set to notLogicalIf, or if the VPL row is not active.')
atmVclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11), )
if mibBuilder.loadTexts: atmVclStatTable.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTable.setDescription('This table contains all statistics counters per VCL. It is used to monitor the usage of the VCL in terms of incoming cells and outgoing cells.')
atmVclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVclStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclStatEntry.setDescription('Each entry in this table represents a VCL.')
atmVclStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellIns.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTotalCellIns.setDescription('The total number of valid ATM cells received by this VCL including both CLP=0 and CLP=1 cells. The cells are counted prior to the application of the traffic policing.')
atmVclStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellIns.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0CellIns.setDescription('The number of valid ATM cells received by this VCL with CLP=0. The cells are counted prior to the application of the traffic policing.')
atmVclStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalDiscards.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTotalDiscards.setDescription('The total number of valid ATM cells discarded by the traffic policing entity. This includes cells originally received with CLP=0 and CLP=1.')
atmVclStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Discards.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0Discards.setDescription('The total number of valid ATM cells received with CLP=0 and discarded by the traffic policing entity.')
atmVclStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVclStatTotalCellOuts.setDescription('The total number of valid ATM cells transmitted by this VCL. This includes both CLP=0 and CLP=1 cells.')
atmVclStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellOuts.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0CellOuts.setDescription('The total number of valid ATM cells transmitted with CLP=0 by this VCL.')
atmVclStatClp0Tagged = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Tagged.setStatus('current')
if mibBuilder.loadTexts: atmVclStatClp0Tagged.setDescription('The total number of valid ATM cells tagged by the traffic policing entity from CLP=0 to CLP=1.')
atmAal5VclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12), )
if mibBuilder.loadTexts: atmAal5VclStatTable.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclStatTable.setDescription('This table provides a collection of objects providing AAL5 configuration and performance statistics of a VCL.')
atmAal5VclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmAal5VclStatEntry.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclStatEntry.setDescription('Each entry in this table represents an AAL5 VCL, and is indexed by ifIndex values of AAL5 interfaces and the associated VPI/VCI values.')
atmAal5VclInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInPkts.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclInPkts.setDescription('The number of AAL5 CPCS PDUs received on the AAL5 VCC at the interface identified by the ifIndex.')
atmAal5VclOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutPkts.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclOutPkts.setDescription('The number of AAL5 CPCS PDUs transmitted on the AAL5 VCC at the interface identified by the ifIndex.')
atmAal5VclInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInOctets.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclInOctets.setDescription('The number of octets contained in AAL5 CPCS PDUs received on the AAL5 VCC at the interface identified by the ifIndex.')
atmAal5VclOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutOctets.setStatus('current')
if mibBuilder.loadTexts: atmAal5VclOutOctets.setDescription('The number of octets contained in AAL5 CPCS PDUs transmitted on the AAL5 VCC at the interface identified by the ifIndex.')
atmVclGenTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13), )
if mibBuilder.loadTexts: atmVclGenTable.setStatus('current')
if mibBuilder.loadTexts: atmVclGenTable.setDescription('General Information for each VC.')
atmVclGenEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1), )
atmVclEntry.registerAugmentions(("ATM2-MIB", "atmVclGenEntry"))
atmVclGenEntry.setIndexNames(*atmVclEntry.getIndexNames())
if mibBuilder.loadTexts: atmVclGenEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclGenEntry.setDescription('An entry with general information about the ATM VC.')
atmVclGenSigDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1, 1), AtmSigDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclGenSigDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmVclGenSigDescrIndex.setDescription('The value of this object identifies the row in the ATM Signalling Descriptor Parameter Table which applies to this VCL.')
atmInterfaceExtTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14), )
if mibBuilder.loadTexts: atmInterfaceExtTable.setReference('Tesink, K., Editor, Definitions of Managed Objects for ATM Management, RFC 2515, Bell Communications Research, February, 1999.')
if mibBuilder.loadTexts: atmInterfaceExtTable.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceExtTable.setDescription('This table contains ATM interface configuration and monitoring information not defined in the atmInterfaceConfTable from the ATM-MIB. This includes the type of connection setup procedures, ILMI information, and information on the VPI/VCI range.')
atmInterfaceExtEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1), )
if mibBuilder.loadTexts: atmInterfaceExtEntry.setReference('Tesink, K., Editor, Definitions of Managed Objects for ATM Management, RFC 2515, Bell Communications Research, February, 1999.')
atmInterfaceConfEntry.registerAugmentions(("ATM2-MIB", "atmInterfaceExtEntry"))
atmInterfaceExtEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: atmInterfaceExtEntry.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceExtEntry.setDescription('An entry extends the atmInterfaceConfEntry defined in the ATM- MIB. Each entry corresponds to an ATM interface.')
atmIntfConfigType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 1), AtmInterfaceType().clone('autoConfig')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigType.setStatus('current')
if mibBuilder.loadTexts: atmIntfConfigType.setDescription("The type of connection setup procedures configured for the ATM interface. Setting this variable to a value of 'other' is not allowed.")
atmIntfActualType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 2), AtmInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualType.setStatus('current')
if mibBuilder.loadTexts: atmIntfActualType.setDescription("The type of connection setup procedures currently being used on the interface. This may reflect a manually configured value for the interface type, or may be determined by other means such as auto-configuration. A value of `autoConfig' indicates that auto-configuration was requested but has not yet been completed.")
atmIntfConfigSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigSide.setStatus('current')
if mibBuilder.loadTexts: atmIntfConfigSide.setDescription("The configured role of the managed entity as one side of the ATM interface. This value does not apply when the object atmIntfConfigType is set to `autoConfig', `atmfPnni1Dot0', or `atmfBici2Dot0'.")
atmIntfActualSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3), ("symmetric", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualSide.setStatus('current')
if mibBuilder.loadTexts: atmIntfActualSide.setDescription('The current role used by the managed entity to represent one side of the ATM interface.')
atmIntfIlmiAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 5), Bits().clone(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiAdminStatus.setDescription("Indicates which components of ILMI are administratively enabled on this interface. If the 'ilmi' bit is not set, then no ILMI components are operational. ILMI components other than auto- configuration that are not represented in the value have their administrative status determined according to the 'ilmi' bit. The ILMI auto-configuration component is enabled/disabled by the atmIntfConfigType object.")
atmIntfIlmiOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 6), Bits().clone(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiOperStatus.setDescription('Indicates which components of ILMI are operational on this interface.')
atmIntfIlmiFsmState = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("stopped", 1), ("linkFailing", 2), ("establishing", 3), ("configuring", 4), ("retrievingNetworkPrefixes", 5), ("registeringNetworkPrefixes", 6), ("retrievingAddresses", 7), ("registeringAddresses", 8), ("verifying", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setReference('ATM Forum, Integrated Local Management Interface (ILMI) Specification, Version 4.0, af-ilmi-0065.000, September 1996, Appendix 1')
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setDescription('Indicates the state of the ILMI Finite State Machine associated with this interface.')
atmIntfIlmiEstablishConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setReference('ATM Forum, Integrated Local Management Interface (ILMI) Specification, Version 4.0, af-ilmi-0065.000, September 1996, Section 8.3.1')
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setDescription('The amount of time S between successive transmissions of ILMI messages on this interface for the purpose of detecting establishment of ILMI connectivity.')
atmIntfIlmiCheckConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setReference('ATM Forum, Integrated Local Management Interface (ILMI) Specification, Version 4.0, af-ilmi-0065.000, September 1996, Section 8.3.1')
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setDescription('The amount of time T between successive transmissions of ILMI messages on this interface for the purpose of detecting loss of ILMI connectivity. The distinguished value zero disables ILMI connectivity procedures on this interface.')
atmIntfIlmiConPollInactFactor = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setReference('ATM Forum, Integrated Local Management Interface (ILMI) Specification, Version 4.0, af-ilmi-0065.000, September 1996, Section 8.3.1')
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setDescription('The number K of consecutive polls on this interface for which no ILMI response message is received before ILMI connectivity is declared lost.')
atmIntfIlmiPublicPrivateIndctr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("public", 2), ("private", 3))).clone('private')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiPublicPrivateIndctr.setStatus('current')
if mibBuilder.loadTexts: atmIntfIlmiPublicPrivateIndctr.setDescription("Specifies whether this end of the interface is advertised in ILMI as a device of the `public' or `private' type.")
atmInterfaceConfMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvpcVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual path connections.')
atmInterfaceCurrentMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvpcVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvpcVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface may currently allocate to switched virtual path connections. This value is the minimum of atmInterfaceConfMaxSvpcVpi, and the atmInterfaceMaxSvpcVpi of the interface's UNI/NNI peer. If the interface does not negotiate with its peer to determine the maximum VPI that can be allocated to SVPCs on the interface, then the value of this object must equal atmInterfaceConfMaxSvpcVpi. ")
atmInterfaceConfMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvccVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual channel connections.')
atmInterfaceCurrentMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvccVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvccVpi.setDescription("The maximum VPI that the signalling stack on the ATM interface may currently allocate to switched virtual channel connections. This value is the minimum of atmInterfaceConfMaxSvccVpi, and the atmInterfaceConfMaxSvccVpi of the interface's UNI/NNI peer. If the interface does not negotiate with its peer to determine the maximum VPI that can be allocated to SVCCs on the interface, then the value of this object must equal atmInterfaceConfMaxSvccVpi.")
atmInterfaceConfMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMinSvccVci.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfMinSvccVci.setDescription('The minimum VCI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual channel connections.')
atmInterfaceCurrentMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMinSvccVci.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceCurrentMinSvccVci.setDescription("The minimum VCI that the signalling stack on the ATM interface may currently allocate to switched virtual channel connections. This value is the maximum of atmInterfaceConfMinSvccVci, and the atmInterfaceConfMinSvccVci of the interface's UNI/NNI peer. If the interface does not negotiate with its peer to determine the minimum VCI that can be allocated to SVCCs on the interface, then the value of this object must equal atmInterfaceConfMinSvccVci.")
atmIntfSigVccRxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 18), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccRxTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmIntfSigVccRxTrafficDescrIndex.setDescription('This object identifies the row in the atmTrafficDescrParamTable used during ILMI auto-configuration to specify the advertised signalling VCC traffic parameters for the receive direction. The traffic descriptor resulting from ILMI auto-configuration of the signalling VCC is indicated in the atmVclTable.')
atmIntfSigVccTxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 19), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccTxTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmIntfSigVccTxTrafficDescrIndex.setDescription('This object identifies the row in the atmTrafficDescrParamTable used during ILMI auto-configuration to specify the advertised signalling VCC traffic parameters for the transmit direction. The traffic descriptor resulting from ILMI auto-configuration of the signalling VCC is indicated in the atmVclTable.')
atmIntfPvcFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfPvcFailures.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcFailures.setDescription('The number of times the operational status of a PVPL or PVCL on this interface has gone down.')
atmIntfCurrentlyFailingPVpls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVpls.setStatus('current')
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVpls.setDescription("The current number of VPLs on this interface for which there is an active row in the atmVplTable having an atmVplConnKind value of `pvc' and an atmVplOperStatus with a value other than `up'.")
atmIntfCurrentlyFailingPVcls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVcls.setStatus('current')
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVcls.setDescription("The current number of VCLs on this interface for which there is an active row in the atmVclTable having an atmVclConnKind value of `pvc' and an atmVclOperStatus with a value other than `up'.")
atmIntfPvcFailuresTrapEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 23), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcFailuresTrapEnable.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcFailuresTrapEnable.setDescription('Allows the generation of traps in response to PVCL or PVPL failures on this interface.')
atmIntfPvcNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcNotificationInterval.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcNotificationInterval.setDescription('The minimum interval between the sending of atmIntfPvcFailuresTrap notifications for this interface.')
atmIntfLeafSetupFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfLeafSetupFailures.setStatus('current')
if mibBuilder.loadTexts: atmIntfLeafSetupFailures.setDescription('Number of setup failures. For root, this is the number of rejected setup requests and for leaf, this is the number of setup failure received.')
atmIntfLeafSetupRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfLeafSetupRequests.setStatus('current')
if mibBuilder.loadTexts: atmIntfLeafSetupRequests.setDescription('Number of setup requests. For root, this includes both incoming setup request and root intiated setup requests.')
atmIlmiSrvcRegTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15), )
if mibBuilder.loadTexts: atmIlmiSrvcRegTable.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegTable.setDescription('This table contains a list of all the ATM network services known by this device. The characteristics of these services are made available through the ILMI, using the ILMI general-purpose service registry MIB. These services may be made available to all ATM interfaces (atmIlmiSrvcRegIndex = 0) or to some specific ATM interfaces only (atmIlmiSrvcRegIndex = ATM interface index).')
atmIlmiSrvcRegEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1), ).setIndexNames((0, "ATM2-MIB", "atmIlmiSrvcRegIndex"), (0, "ATM2-MIB", "atmIlmiSrvcRegServiceID"), (0, "ATM2-MIB", "atmIlmiSrvcRegAddressIndex"))
if mibBuilder.loadTexts: atmIlmiSrvcRegEntry.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegEntry.setDescription('Information about a single service provider that is available to the user-side of an adjacent device through the ILMI. Implementors need to be aware that if the size of the atmIlmiSrvcRegServiceID exceeds 112 sub-identifiers then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2, or SNMPv3.')
atmIlmiSrvcRegIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: atmIlmiSrvcRegIndex.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegIndex.setDescription('The ATM interface where the service defined in this entry can be made available to an ATM device attached to this interface. The value of 0 has a special meaning: when an ATM service is defined in an entry whose atmIlmiSrvcRegIndex is zero, the ATM service is available to ATM devices connected to any ATM interface. (default value(s)). When the user-side of an adjacent device queries the content of the ILMI service registry MIB (using the ILMI protocol), the local network-side responds with the ATM services defined in atmIlmiSrvcRegTable entries, provided that these entries are indexed by: - the corresponding ifIndex value (atmIlmiSrvcRegIndex equal to the ifIndex of the interface to which the adjacent device is connected) - zero (atmIlmiSrvcRegIndex=0).')
atmIlmiSrvcRegServiceID = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 2), ObjectIdentifier())
if mibBuilder.loadTexts: atmIlmiSrvcRegServiceID.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegServiceID.setDescription('This is the service identifier which uniquely identifies the type of service at the address provided in the table. The object identifiers for the LAN Emulation Configuration Server (LECS) and the ATM Name Server (ANS) are defined in the ATM Forum ILMI Service Registry MIB. The object identifiers for the ATMARP Server, the Multicast Address Resolution Server (MARS), and the NHRP Server (NHS) are defined in RFC 2601, RFC 2602, and RFC 2603, respectively.')
atmIlmiSrvcRegAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmIlmiSrvcRegAddressIndex.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegAddressIndex.setDescription('An arbitrary integer to differentiate multiple rows containing different ATM addresses for the same service on the same interface. This number need NOT be the same as the corresponding ILMI atmfSrvcRegAddressIndex MIB object.')
atmIlmiSrvcRegATMAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 4), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegATMAddress.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegATMAddress.setDescription('This is the full address of the service. The user-side of the adjacent device may use this address to establish a connection with the service.')
atmIlmiSrvcRegParm1 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegParm1.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegParm1.setDescription('An octet string used according to the value of atmIlmiSrvcRegServiceID.')
atmIlmiSrvcRegRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmIlmiSrvcRegRowStatus.setDescription('This object is used to create or destroy an entry from this table.')
atmIlmiNetworkPrefixTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16), )
if mibBuilder.loadTexts: atmIlmiNetworkPrefixTable.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetworkPrefixTable.setDescription('A table specifying per-interface network prefix(es) supplied by the network side of the UNI during ILMI address registration. When no network prefixes are specified for a particular interface, one or more network prefixes based on the switch address(es) may be used for ILMI address registration.')
atmIlmiNetworkPrefixEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIlmiNetPrefixPrefix"))
if mibBuilder.loadTexts: atmIlmiNetworkPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetworkPrefixEntry.setDescription('Information about a single network prefix supplied by the network side of the UNI during ILMI address registration. Note that the index variable atmIlmiNetPrefixPrefix is a variable- length string, and as such the rule for variable-length strings in section 7.7 of RFC 2578 applies.')
atmIlmiNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 1), AtmIlmiNetworkPrefix())
if mibBuilder.loadTexts: atmIlmiNetPrefixPrefix.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetPrefixPrefix.setDescription('The network prefix specified for use in ILMI address registration.')
atmIlmiNetPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiNetPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmIlmiNetPrefixRowStatus.setDescription('Used to create, delete, activate and de-activate network prefixes used in ILMI address registration.')
atmSwitchAddressTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17), )
if mibBuilder.loadTexts: atmSwitchAddressTable.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressTable.setDescription('This table contains one or more ATM endsystem addresses on a per-switch basis. These addresses are used to identify the switch. When no ILMI network prefixes are configured for certain interfaces, network prefixes based on the switch address(es) may be used for ILMI address registration.')
atmSwitchAddressEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1), ).setIndexNames((0, "ATM2-MIB", "atmSwitchAddressIndex"))
if mibBuilder.loadTexts: atmSwitchAddressEntry.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressEntry.setDescription('An entry in the ATM Switch Address table.')
atmSwitchAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: atmSwitchAddressIndex.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressIndex.setDescription('An arbitrary index used to enumerate the ATM endsystem addresses for this switch.')
atmSwitchAddressAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(13, 13), ValueSizeConstraint(20, 20), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressAddress.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressAddress.setDescription('An ATM endsystem address or address prefix used to identify this switch. When no ESI or SEL field is specified, the switch may generate the ESI and SEL fields automatically to obtain a complete 20-byte ATM endsystem address.')
atmSwitchAddressRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSwitchAddressRowStatus.setDescription('Used to create, delete, activate, and de-activate addresses used to identify this switch.')
atmVpCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18), )
if mibBuilder.loadTexts: atmVpCrossConnectXTable.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectXTable.setDescription('This table contains one row per VP Cross-Connect represented in the atmVpCrossConnectTable.')
atmVpCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1), )
atmVpCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVpCrossConnectXEntry"))
atmVpCrossConnectXEntry.setIndexNames(*atmVpCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVpCrossConnectXEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectXEntry.setDescription('Information about a particular ATM VP Cross-Connect. Each entry provides an two objects that name the Cross-Connect. One is assigned by the Service User and the other by the Service Provider.')
atmVpCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectUserName.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectUserName.setDescription('This is a service user assigned textual representation of a VPC PVC.')
atmVpCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectProviderName.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectProviderName.setDescription('This is a system supplied textual representation of VPC PVC. It is assigned by the service provider.')
atmVcCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19), )
if mibBuilder.loadTexts: atmVcCrossConnectXTable.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectXTable.setDescription('This table contains one row per VC Cross-Connect represented in the atmVcCrossConnectTable.')
atmVcCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1), )
atmVcCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVcCrossConnectXEntry"))
atmVcCrossConnectXEntry.setIndexNames(*atmVcCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVcCrossConnectXEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectXEntry.setDescription('Information about a particular ATM VC Cross-Connect. Each entry provides an two objects that name the Cross-Connect. One is assigned by the Service User and the other by the Service Provider.')
atmVcCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectUserName.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectUserName.setDescription('This is a service user assigned textual representation of a VCC PVC.')
atmVcCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectProviderName.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectProviderName.setDescription('This is a system supplied textual representation of VCC PVC. It is assigned by the service provider.')
atmCurrentlyFailingPVplTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20), )
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTable.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTable.setDescription("A table indicating all VPLs for which there is an active row in the atmVplTable having an atmVplConnKind value of `pvc' and an atmVplOperStatus with a value other than `up'.")
atmCurrentlyFailingPVplEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVplEntry.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVplEntry.setDescription("Each entry in this table represents a VPL for which the atmVplRowStatus is `active', the atmVplConnKind is `pvc', and the atmVplOperStatus is other than `up'.")
atmCurrentlyFailingPVplTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTimeStamp.setDescription('The time at which this PVPL began to fail.')
atmCurrentlyFailingPVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21), )
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTable.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTable.setDescription("A table indicating all VCLs for which there is an active row in the atmVclTable having an atmVclConnKind value of `pvc' and an atmVclOperStatus with a value other than `up'.")
atmCurrentlyFailingPVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVclEntry.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVclEntry.setDescription("Each entry in this table represents a VCL for which the atmVclRowStatus is `active', the atmVclConnKind is `pvc', and the atmVclOperStatus is other than `up'.")
atmCurrentlyFailingPVclTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTimeStamp.setDescription('The time at which this PVCL began to fail.')
atmPvcTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1))
atmPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0))
atmIntfPvcFailuresTrap = NotificationType((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"))
if mibBuilder.loadTexts: atmIntfPvcFailuresTrap.setStatus('current')
if mibBuilder.loadTexts: atmIntfPvcFailuresTrap.setDescription('A notification indicating that one or more PVPLs or PVCLs on this interface has failed since the last atmPvcFailuresTrap was sent. If this trap has not been sent for the last atmIntfPvcNotificationInterval, then it will be sent on the next increment of atmIntfPvcFailures.')
atm2MIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3))
atm2MIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1))
atm2MIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2))
atm2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2, 1)).setObjects(("ATM2-MIB", "atmCommonGroup"), ("ATM2-MIB", "atmCommonStatsGroup"), ("ATM2-MIB", "atmSwitchServcGroup"), ("ATM2-MIB", "atmSwitchServcSigGroup"), ("ATM2-MIB", "atmSwitchServcNotifGroup"), ("ATM2-MIB", "atmSwitchGroup"), ("ATM2-MIB", "atmServcGroup"), ("ATM2-MIB", "atmHostGroup"), ("ATM2-MIB", "atmHostSigDescrGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atm2MIBCompliance = atm2MIBCompliance.setStatus('current')
if mibBuilder.loadTexts: atm2MIBCompliance.setDescription('The compliance statement for SNMP entities which represent ATM interfaces. The compliance statements are used to determine if a particular group or object applies to hosts, networks/switches, or both. The Common group is defined as applicable to all three.')
atmCommonGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 1)).setObjects(("ATM2-MIB", "atmSigSSCOPConEvents"), ("ATM2-MIB", "atmSigSSCOPErrdPdus"), ("ATM2-MIB", "atmSigDetectSetupAttempts"), ("ATM2-MIB", "atmSigEmitSetupAttempts"), ("ATM2-MIB", "atmSigDetectUnavailRoutes"), ("ATM2-MIB", "atmSigEmitUnavailRoutes"), ("ATM2-MIB", "atmSigDetectUnavailResrcs"), ("ATM2-MIB", "atmSigEmitUnavailResrcs"), ("ATM2-MIB", "atmSigDetectCldPtyEvents"), ("ATM2-MIB", "atmSigEmitCldPtyEvents"), ("ATM2-MIB", "atmSigDetectMsgErrors"), ("ATM2-MIB", "atmSigEmitMsgErrors"), ("ATM2-MIB", "atmSigDetectClgPtyEvents"), ("ATM2-MIB", "atmSigEmitClgPtyEvents"), ("ATM2-MIB", "atmSigDetectTimerExpireds"), ("ATM2-MIB", "atmSigEmitTimerExpireds"), ("ATM2-MIB", "atmSigDetectRestarts"), ("ATM2-MIB", "atmSigEmitRestarts"), ("ATM2-MIB", "atmSigInEstabls"), ("ATM2-MIB", "atmSigOutEstabls"), ("ATM2-MIB", "atmVplLogicalPortDef"), ("ATM2-MIB", "atmVplLogicalPortIndex"), ("ATM2-MIB", "atmInterfaceConfMaxSvpcVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvpcVpi"), ("ATM2-MIB", "atmInterfaceConfMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceConfMinSvccVci"), ("ATM2-MIB", "atmInterfaceCurrentMinSvccVci"), ("ATM2-MIB", "atmIntfSigVccRxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfSigVccTxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"), ("ATM2-MIB", "atmIntfPvcNotificationInterval"), ("ATM2-MIB", "atmIntfPvcFailuresTrapEnable"), ("ATM2-MIB", "atmIntfLeafSetupFailures"), ("ATM2-MIB", "atmIntfLeafSetupRequests"), ("ATM2-MIB", "atmIntfConfigType"), ("ATM2-MIB", "atmIntfActualType"), ("ATM2-MIB", "atmIntfConfigSide"), ("ATM2-MIB", "atmIntfActualSide"), ("ATM2-MIB", "atmIntfIlmiAdminStatus"), ("ATM2-MIB", "atmIntfIlmiOperStatus"), ("ATM2-MIB", "atmIntfIlmiFsmState"), ("ATM2-MIB", "atmIntfIlmiEstablishConPollIntvl"), ("ATM2-MIB", "atmIntfIlmiCheckConPollIntvl"), ("ATM2-MIB", "atmIntfIlmiConPollInactFactor"), ("ATM2-MIB", "atmIntfIlmiPublicPrivateIndctr"), ("ATM2-MIB", "atmCurrentlyFailingPVplTimeStamp"), ("ATM2-MIB", "atmCurrentlyFailingPVclTimeStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmCommonGroup = atmCommonGroup.setStatus('current')
if mibBuilder.loadTexts: atmCommonGroup.setDescription('A collection of objects providing information for a Switch/Service/Host that implements ATM interfaces.')
atmCommonStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 2)).setObjects(("ATM2-MIB", "atmVclStatTotalCellIns"), ("ATM2-MIB", "atmVclStatClp0CellIns"), ("ATM2-MIB", "atmVclStatTotalDiscards"), ("ATM2-MIB", "atmVclStatClp0Discards"), ("ATM2-MIB", "atmVclStatTotalCellOuts"), ("ATM2-MIB", "atmVclStatClp0CellOuts"), ("ATM2-MIB", "atmVclStatClp0Tagged"), ("ATM2-MIB", "atmVplStatTotalCellIns"), ("ATM2-MIB", "atmVplStatClp0CellIns"), ("ATM2-MIB", "atmVplStatTotalDiscards"), ("ATM2-MIB", "atmVplStatClp0Discards"), ("ATM2-MIB", "atmVplStatTotalCellOuts"), ("ATM2-MIB", "atmVplStatClp0CellOuts"), ("ATM2-MIB", "atmVplStatClp0Tagged"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmCommonStatsGroup = atmCommonStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmCommonStatsGroup.setDescription('A collection of objects providing information for a Switch/Service/Host that implements ATM VCL and VPL Statistics')
atmSwitchServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 3)).setObjects(("ATM2-MIB", "atmIlmiSrvcRegATMAddress"), ("ATM2-MIB", "atmIlmiSrvcRegParm1"), ("ATM2-MIB", "atmIlmiSrvcRegRowStatus"), ("ATM2-MIB", "atmIlmiNetPrefixRowStatus"), ("ATM2-MIB", "atmSvcVpCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVpCrossConnectRowStatus"), ("ATM2-MIB", "atmSvcVcCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVcCrossConnectRowStatus"), ("ATM2-MIB", "atmIfRegAddrAddressSource"), ("ATM2-MIB", "atmIfRegAddrOrgScope"), ("ATM2-MIB", "atmIfRegAddrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchServcGroup = atmSwitchServcGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchServcGroup.setDescription('A collection of objects providing information for a Switch/Service that implements ATM interfaces.')
atmSwitchServcSigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 4)).setObjects(("ATM2-MIB", "atmSigSupportClgPtyNumDel"), ("ATM2-MIB", "atmSigSupportClgPtySubAddr"), ("ATM2-MIB", "atmSigSupportCldPtySubAddr"), ("ATM2-MIB", "atmSigSupportHiLyrInfo"), ("ATM2-MIB", "atmSigSupportLoLyrInfo"), ("ATM2-MIB", "atmSigSupportBlliRepeatInd"), ("ATM2-MIB", "atmSigSupportAALInfo"), ("ATM2-MIB", "atmSigSupportPrefCarrier"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchServcSigGroup = atmSwitchServcSigGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchServcSigGroup.setDescription('A collection of objects providing information for a Switch/Service that implements ATM signalling.')
atmSwitchServcNotifGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 5)).setObjects(("ATM2-MIB", "atmIntfPvcFailuresTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchServcNotifGroup = atmSwitchServcNotifGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchServcNotifGroup.setDescription('A collection of notifications providing information for a Switch/Service that implements ATM interfaces.')
atmSwitchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 6)).setObjects(("ATM2-MIB", "atmSwitchAddressAddress"), ("ATM2-MIB", "atmSwitchAddressRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSwitchGroup = atmSwitchGroup.setStatus('current')
if mibBuilder.loadTexts: atmSwitchGroup.setDescription('A collection of objects providing information for an ATM switch.')
atmServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 7)).setObjects(("ATM2-MIB", "atmVpCrossConnectUserName"), ("ATM2-MIB", "atmVpCrossConnectProviderName"), ("ATM2-MIB", "atmVcCrossConnectUserName"), ("ATM2-MIB", "atmVcCrossConnectProviderName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmServcGroup = atmServcGroup.setStatus('current')
if mibBuilder.loadTexts: atmServcGroup.setDescription('A collection of objects providing information for an ATM Network Service.')
atmHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 8)).setObjects(("ATM2-MIB", "atmAal5VclInPkts"), ("ATM2-MIB", "atmAal5VclOutPkts"), ("ATM2-MIB", "atmAal5VclInOctets"), ("ATM2-MIB", "atmAal5VclOutOctets"), ("ATM2-MIB", "atmVclAddrType"), ("ATM2-MIB", "atmVclAddrRowStatus"), ("ATM2-MIB", "atmAddrVclAddrType"), ("ATM2-MIB", "atmVclGenSigDescrIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmHostGroup = atmHostGroup.setStatus('current')
if mibBuilder.loadTexts: atmHostGroup.setDescription('A collection of objects providing information for a Host that implements ATM interfaces.')
atmHostSigDescrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 9)).setObjects(("ATM2-MIB", "atmSigDescrParamAalType"), ("ATM2-MIB", "atmSigDescrParamAalSscsType"), ("ATM2-MIB", "atmSigDescrParamBhliType"), ("ATM2-MIB", "atmSigDescrParamBhliInfo"), ("ATM2-MIB", "atmSigDescrParamBbcConnConf"), ("ATM2-MIB", "atmSigDescrParamBlliLayer2"), ("ATM2-MIB", "atmSigDescrParamBlliLayer3"), ("ATM2-MIB", "atmSigDescrParamBlliPktSize"), ("ATM2-MIB", "atmSigDescrParamBlliSnapId"), ("ATM2-MIB", "atmSigDescrParamBlliOuiPid"), ("ATM2-MIB", "atmSigDescrParamRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmHostSigDescrGroup = atmHostSigDescrGroup.setStatus('current')
if mibBuilder.loadTexts: atmHostSigDescrGroup.setDescription('A collection of objects providing information for a Host that implements ATM interfaces.')
mibBuilder.exportSymbols("ATM2-MIB", atmSigDescrParamTable=atmSigDescrParamTable, atmVplStatTotalCellIns=atmVplStatTotalCellIns, atmSvcVcCrossConnectLowVci=atmSvcVcCrossConnectLowVci, atmVpCrossConnectUserName=atmVpCrossConnectUserName, atmVcCrossConnectXEntry=atmVcCrossConnectXEntry, atmSigSupportPrefCarrier=atmSigSupportPrefCarrier, atmSigStatTable=atmSigStatTable, atmVclGenSigDescrIndex=atmVclGenSigDescrIndex, atmSigDescrParamBbcConnConf=atmSigDescrParamBbcConnConf, atmSvcVcCrossConnectHighIfIndex=atmSvcVcCrossConnectHighIfIndex, atmSwitchGroup=atmSwitchGroup, atmIlmiNetPrefixRowStatus=atmIlmiNetPrefixRowStatus, atmIntfIlmiEstablishConPollIntvl=atmIntfIlmiEstablishConPollIntvl, atmSigEmitTimerExpireds=atmSigEmitTimerExpireds, atmVplLogicalPortTable=atmVplLogicalPortTable, atmVplStatClp0Discards=atmVplStatClp0Discards, atmVplStatTotalCellOuts=atmVplStatTotalCellOuts, atmVplStatClp0Tagged=atmVplStatClp0Tagged, atmAal5VclOutOctets=atmAal5VclOutOctets, atmInterfaceConfMaxSvpcVpi=atmInterfaceConfMaxSvpcVpi, atmVclStatTable=atmVclStatTable, atmVplStatTotalDiscards=atmVplStatTotalDiscards, atmIntfPvcFailuresTrapEnable=atmIntfPvcFailuresTrapEnable, atmVpCrossConnectXEntry=atmVpCrossConnectXEntry, atmSigEmitUnavailResrcs=atmSigEmitUnavailResrcs, atmIlmiSrvcRegATMAddress=atmIlmiSrvcRegATMAddress, atmSigDescrParamAalSscsType=atmSigDescrParamAalSscsType, atm2MIBCompliance=atm2MIBCompliance, atmSigInEstabls=atmSigInEstabls, atmSwitchAddressAddress=atmSwitchAddressAddress, atmIfRegAddrOrgScope=atmIfRegAddrOrgScope, atmIlmiNetPrefixPrefix=atmIlmiNetPrefixPrefix, atmSigDetectClgPtyEvents=atmSigDetectClgPtyEvents, atmSigDescrParamBlliLayer3=atmSigDescrParamBlliLayer3, atmIfRegisteredAddrTable=atmIfRegisteredAddrTable, atmSigDescrParamBlliSnapId=atmSigDescrParamBlliSnapId, atmAal5VclStatTable=atmAal5VclStatTable, atmIntfSigVccTxTrafficDescrIndex=atmIntfSigVccTxTrafficDescrIndex, atm2MIBConformance=atm2MIBConformance, atmSwitchAddressIndex=atmSwitchAddressIndex, atmSvcVcCrossConnectCreationTime=atmSvcVcCrossConnectCreationTime, atmVclStatClp0CellIns=atmVclStatClp0CellIns, atmSigSupportLoLyrInfo=atmSigSupportLoLyrInfo, atmInterfaceCurrentMinSvccVci=atmInterfaceCurrentMinSvccVci, atmVclStatClp0CellOuts=atmVclStatClp0CellOuts, atmSvcVpCrossConnectHighIfIndex=atmSvcVpCrossConnectHighIfIndex, atmSvcVcCrossConnectTable=atmSvcVcCrossConnectTable, atmIntfPvcFailures=atmIntfPvcFailures, atmPvcTrapsPrefix=atmPvcTrapsPrefix, atmAddrVclEntry=atmAddrVclEntry, atmVplStatEntry=atmVplStatEntry, atmSwitchAddressTable=atmSwitchAddressTable, atmHostSigDescrGroup=atmHostSigDescrGroup, atmVplLogicalPortDef=atmVplLogicalPortDef, atmSigSupportEntry=atmSigSupportEntry, atmSigSupportCldPtySubAddr=atmSigSupportCldPtySubAddr, atmIntfPvcNotificationInterval=atmIntfPvcNotificationInterval, atmSigSupportBlliRepeatInd=atmSigSupportBlliRepeatInd, atmSigSupportClgPtyNumDel=atmSigSupportClgPtyNumDel, atmSwitchServcGroup=atmSwitchServcGroup, atmIntfActualSide=atmIntfActualSide, atmInterfaceExtTable=atmInterfaceExtTable, atmAddrVclTable=atmAddrVclTable, atmSigDetectCldPtyEvents=atmSigDetectCldPtyEvents, atmPvcTraps=atmPvcTraps, atmCommonGroup=atmCommonGroup, atmInterfaceExtEntry=atmInterfaceExtEntry, atmSvcVpCrossConnectLowVpi=atmSvcVpCrossConnectLowVpi, atmSvcVcCrossConnectHighVpi=atmSvcVcCrossConnectHighVpi, atmSigSupportAALInfo=atmSigSupportAALInfo, atmSvcVcCrossConnectEntry=atmSvcVcCrossConnectEntry, atmVclAddrType=atmVclAddrType, atmVcCrossConnectXTable=atmVcCrossConnectXTable, atmSigDescrParamBlliOuiPid=atmSigDescrParamBlliOuiPid, atmSigDetectSetupAttempts=atmSigDetectSetupAttempts, atmIntfCurrentlyFailingPVpls=atmIntfCurrentlyFailingPVpls, atmServcGroup=atmServcGroup, atm2MIBObjects=atm2MIBObjects, atmSigDescrParamRowStatus=atmSigDescrParamRowStatus, atmIfRegAddrAddressSource=atmIfRegAddrAddressSource, atmSigOutEstabls=atmSigOutEstabls, atmIlmiSrvcRegTable=atmIlmiSrvcRegTable, atmVclStatTotalCellIns=atmVclStatTotalCellIns, atmSwitchServcNotifGroup=atmSwitchServcNotifGroup, atmCurrentlyFailingPVplEntry=atmCurrentlyFailingPVplEntry, atm2MIBCompliances=atm2MIBCompliances, atmAal5VclStatEntry=atmAal5VclStatEntry, atmVclAddrEntry=atmVclAddrEntry, atmIlmiNetworkPrefixEntry=atmIlmiNetworkPrefixEntry, atmCurrentlyFailingPVclTimeStamp=atmCurrentlyFailingPVclTimeStamp, atmSigEmitMsgErrors=atmSigEmitMsgErrors, atmInterfaceCurrentMaxSvpcVpi=atmInterfaceCurrentMaxSvpcVpi, atmVplStatClp0CellIns=atmVplStatClp0CellIns, atmSvcVpCrossConnectCreationTime=atmSvcVpCrossConnectCreationTime, atmIfRegisteredAddrEntry=atmIfRegisteredAddrEntry, atmSigEmitUnavailRoutes=atmSigEmitUnavailRoutes, atmSvcVcCrossConnectHighVci=atmSvcVcCrossConnectHighVci, atmIlmiSrvcRegEntry=atmIlmiSrvcRegEntry, atmIntfIlmiConPollInactFactor=atmIntfIlmiConPollInactFactor, atmIntfConfigType=atmIntfConfigType, atmAddrVclVci=atmAddrVclVci, atmSigSupportTable=atmSigSupportTable, atmCurrentlyFailingPVplTable=atmCurrentlyFailingPVplTable, atmSvcVpCrossConnectLowIfIndex=atmSvcVpCrossConnectLowIfIndex, atmIlmiSrvcRegRowStatus=atmIlmiSrvcRegRowStatus, atmIlmiSrvcRegAddressIndex=atmIlmiSrvcRegAddressIndex, atmIntfLeafSetupRequests=atmIntfLeafSetupRequests, atmSigDescrParamBlliLayer2=atmSigDescrParamBlliLayer2, atmSvcVcCrossConnectLowVpi=atmSvcVcCrossConnectLowVpi, atmIlmiSrvcRegParm1=atmIlmiSrvcRegParm1, atmAddrVclAddrType=atmAddrVclAddrType, atmIlmiNetworkPrefixTable=atmIlmiNetworkPrefixTable, atmSigDetectMsgErrors=atmSigDetectMsgErrors, atmCommonStatsGroup=atmCommonStatsGroup, atmAddrVclAtmIfIndex=atmAddrVclAtmIfIndex, atmVpCrossConnectProviderName=atmVpCrossConnectProviderName, atm2MIB=atm2MIB, atmSvcVcCrossConnectIndex=atmSvcVcCrossConnectIndex, atmVclStatEntry=atmVclStatEntry, atmInterfaceCurrentMaxSvccVpi=atmInterfaceCurrentMaxSvccVpi, atmSigDescrParamEntry=atmSigDescrParamEntry, atmVclAddrTable=atmVclAddrTable, atmSigDetectRestarts=atmSigDetectRestarts, atmSigSSCOPErrdPdus=atmSigSSCOPErrdPdus, atmSigDescrParamIndex=atmSigDescrParamIndex, atmAal5VclInOctets=atmAal5VclInOctets, atmCurrentlyFailingPVplTimeStamp=atmCurrentlyFailingPVplTimeStamp, atmVpCrossConnectXTable=atmVpCrossConnectXTable, atmIfRegAddrAddress=atmIfRegAddrAddress, atmIntfIlmiOperStatus=atmIntfIlmiOperStatus, atmIntfIlmiCheckConPollIntvl=atmIntfIlmiCheckConPollIntvl, atmSvcVpCrossConnectRowStatus=atmSvcVpCrossConnectRowStatus, atmVclStatClp0Tagged=atmVclStatClp0Tagged, atmVclAddrAddr=atmVclAddrAddr, atmIfRegAddrRowStatus=atmIfRegAddrRowStatus, atmIntfIlmiAdminStatus=atmIntfIlmiAdminStatus, atmIlmiSrvcRegIndex=atmIlmiSrvcRegIndex, atmIntfPvcFailuresTrap=atmIntfPvcFailuresTrap, atmSvcVcCrossConnectRowStatus=atmSvcVcCrossConnectRowStatus, atmSigEmitRestarts=atmSigEmitRestarts, atmSigDescrParamBhliInfo=atmSigDescrParamBhliInfo, atmVplStatTable=atmVplStatTable, atmInterfaceConfMinSvccVci=atmInterfaceConfMinSvccVci, atmIntfCurrentlyFailingPVcls=atmIntfCurrentlyFailingPVcls, atmIntfLeafSetupFailures=atmIntfLeafSetupFailures, atmSigDetectTimerExpireds=atmSigDetectTimerExpireds, atmSigSupportHiLyrInfo=atmSigSupportHiLyrInfo, atmIntfIlmiFsmState=atmIntfIlmiFsmState, atmSigEmitSetupAttempts=atmSigEmitSetupAttempts, atmSigDescrParamBlliPktSize=atmSigDescrParamBlliPktSize, atmIlmiSrvcRegServiceID=atmIlmiSrvcRegServiceID, atmVclStatTotalDiscards=atmVclStatTotalDiscards, atmVclGenEntry=atmVclGenEntry, atmSvcVpCrossConnectTable=atmSvcVpCrossConnectTable, atmVclStatClp0Discards=atmVclStatClp0Discards, atmSigDescrParamBhliType=atmSigDescrParamBhliType, atmSvcVpCrossConnectHighVpi=atmSvcVpCrossConnectHighVpi, atmSigSSCOPConEvents=atmSigSSCOPConEvents, atmVcCrossConnectUserName=atmVcCrossConnectUserName, atmSigDetectUnavailRoutes=atmSigDetectUnavailRoutes, atmVclStatTotalCellOuts=atmVclStatTotalCellOuts, atm2MIBTraps=atm2MIBTraps, atmVplStatClp0CellOuts=atmVplStatClp0CellOuts, atmAal5VclInPkts=atmAal5VclInPkts, atmSigDescrParamAalType=atmSigDescrParamAalType, atmVclAddrRowStatus=atmVclAddrRowStatus, atmIntfActualType=atmIntfActualType, atmSigStatEntry=atmSigStatEntry, atmSigEmitCldPtyEvents=atmSigEmitCldPtyEvents, atmVplLogicalPortIndex=atmVplLogicalPortIndex, atmVclGenTable=atmVclGenTable, atmVcCrossConnectProviderName=atmVcCrossConnectProviderName, atmSvcVpCrossConnectEntry=atmSvcVpCrossConnectEntry, atmCurrentlyFailingPVclTable=atmCurrentlyFailingPVclTable, atmCurrentlyFailingPVclEntry=atmCurrentlyFailingPVclEntry, atmSwitchAddressEntry=atmSwitchAddressEntry, atmSwitchAddressRowStatus=atmSwitchAddressRowStatus, atmHostGroup=atmHostGroup, atmInterfaceConfMaxSvccVpi=atmInterfaceConfMaxSvccVpi, atmSvcVpCrossConnectIndex=atmSvcVpCrossConnectIndex, atmSigSupportClgPtySubAddr=atmSigSupportClgPtySubAddr, atmIntfConfigSide=atmIntfConfigSide, atmSigEmitClgPtyEvents=atmSigEmitClgPtyEvents, atmSwitchServcSigGroup=atmSwitchServcSigGroup, atmIntfIlmiPublicPrivateIndctr=atmIntfIlmiPublicPrivateIndctr, PYSNMP_MODULE_ID=atm2MIB, atmAddrVclVpi=atmAddrVclVpi, atm2MIBGroups=atm2MIBGroups, atmIntfSigVccRxTrafficDescrIndex=atmIntfSigVccRxTrafficDescrIndex, atmAal5VclOutPkts=atmAal5VclOutPkts, atmSigDetectUnavailResrcs=atmSigDetectUnavailResrcs, atmSvcVcCrossConnectLowIfIndex=atmSvcVcCrossConnectLowIfIndex, atmVplLogicalPortEntry=atmVplLogicalPortEntry)

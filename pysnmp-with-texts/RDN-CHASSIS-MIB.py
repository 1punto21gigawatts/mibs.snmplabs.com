#
# PySNMP MIB module RDN-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RDN-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:54:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint")
docsDevEvLevel, = mibBuilder.importSymbols("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel")
ifAdminStatus, ifDescr, ifType, ifIndex, ifOperStatus = mibBuilder.importSymbols("IF-MIB", "ifAdminStatus", "ifDescr", "ifType", "ifIndex", "ifOperStatus")
riverdelta, = mibBuilder.importSymbols("RDN-MIB", "riverdelta")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysDescr, = mibBuilder.importSymbols("SNMPv2-MIB", "sysDescr")
NotificationType, iso, Integer32, Counter64, TimeTicks, IpAddress, ObjectIdentity, MibIdentifier, Gauge32, ModuleIdentity, Unsigned32, Bits, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "iso", "Integer32", "Counter64", "TimeTicks", "IpAddress", "ObjectIdentity", "MibIdentifier", "Gauge32", "ModuleIdentity", "Unsigned32", "Bits", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
rdnChassis = ModuleIdentity((1, 3, 6, 1, 4, 1, 4981, 1))
rdnChassis.setRevisions(('2011-11-09 00:00', '2008-08-08 00:00', '2006-01-06 00:00', '2005-03-01 00:00', '2005-02-22 00:00', '2004-03-18 00:00', '2003-11-04 00:00', '2003-04-30 00:00', '2003-04-29 00:00', '2001-05-08 00:00', '2001-01-15 00:00', '2000-05-23 00:00', '2000-04-04 00:00', '2000-04-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rdnChassis.setRevisionsDescriptions(('add lag(8) type to rdnCardIfPortType', "Added Copyright Statement into MIB modules's description.", '+ adding rdnBsrTestTrap + adding rdnCardIfPortType', 'changing rdnResetSlotStats to a TruthValue', 'clarifying descriptive text related to proprietary linkUp/Down traps', 'Modified the description of rdnSysUpTimeAtLastConfigChange.', "+ Updated CONTACT-INFO. + Added 'hsim(4)' and 'cmts(5)' to rdnSlotType. + Reorder REVISION/DESCRIPTION in required reverse chronological order. + Added rdnLinkUpTrap, rdnLinkDownTrap, rdnCardIfLinkUpDownEnable", "The rdnCardIndex objects MAX-ACCESS was changed to be not-accessible. Also rdnCardIndex object's the SYNTAX was changed to reflect an index of a table.", 'Clean up of CONTACT-INFO.', 'Changed rdnCardSerial to DisplayString; removed rdnCardSlots, rdnConfigReg, rdnConfigRegNext, and rdnChassisPartner; added options bsr1000 and bsr2000 to rdnChassisType; plus other syntax changes.', "Added option 'unknown' to variable chassisPartner.", "Moved 'riverdelta' definition into a separate file; this allows an external module to not include the entire riverdelta chassis mib when needing only the 'riverdelta' definition.", '- Changed the rdnSlotTable to start with a index of 1 rather than 0. SNMP does not allow a table to start with a index of 0. - Change the access of the rdnSlotIndex to be not-accessible; since this object is an index to the rdnSlotTable.', 'Initial creation.',))
if mibBuilder.loadTexts: rdnChassis.setLastUpdated('201111090000Z')
if mibBuilder.loadTexts: rdnChassis.setOrganization('Motorola')
if mibBuilder.loadTexts: rdnChassis.setContactInfo('Motorola Customer Service 101 Tournament Drive Horsham, PA 19044 US Tel: +1 888 944 4357 Int Tel: +1 215 323 0044 Fax: +1 215 323 1502 Email: CPSSupport@Motorola.com')
if mibBuilder.loadTexts: rdnChassis.setDescription('MIB module for Motorola Chassis. Copyright (C) 2001, 2008 by Motorola, Inc. All rights reserved.')
rdnChassisType = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("bsr64000", 2), ("bsr1000", 3), ("osr2000", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnChassisType.setStatus('current')
if mibBuilder.loadTexts: rdnChassisType.setDescription('Chassis type.')
rdnChassisVersion = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnChassisVersion.setStatus('current')
if mibBuilder.loadTexts: rdnChassisVersion.setDescription('Chassis hardware revision level, or an empty string if unavailable.')
rdnChassisId = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnChassisId.setStatus('current')
if mibBuilder.loadTexts: rdnChassisId.setDescription("Unique ID string. Defaults to chassis serial number if available, otherwise empty. Can also be set with 'snmp-server chassis-id'.")
rdnProcessorRam = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnProcessorRam.setStatus('current')
if mibBuilder.loadTexts: rdnProcessorRam.setDescription('Megabytes of RAM available to CPU.')
rdnNvRAMSize = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnNvRAMSize.setStatus('current')
if mibBuilder.loadTexts: rdnNvRAMSize.setDescription('Bytes of non-volatile configuration memory.')
rdnNvRAMUsed = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnNvRAMUsed.setStatus('current')
if mibBuilder.loadTexts: rdnNvRAMUsed.setDescription('Bytes of non-volatile configuration memory in use.')
rdnFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnFlashSize.setStatus('current')
if mibBuilder.loadTexts: rdnFlashSize.setDescription('Bytes flash memory.')
rdnCardTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 1, 8), )
if mibBuilder.loadTexts: rdnCardTable.setStatus('current')
if mibBuilder.loadTexts: rdnCardTable.setDescription('Chassis card table.')
rdnCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1), ).setIndexNames((0, "RDN-CHASSIS-MIB", "rdnCardIndex"))
if mibBuilder.loadTexts: rdnCardEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCardEntry.setDescription('Chassis card table.')
rdnCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: rdnCardIndex.setStatus('current')
if mibBuilder.loadTexts: rdnCardIndex.setDescription('Index into cardTable (not physical chassis slot number).')
rdnCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("srm", 2), ("io", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardType.setStatus('current')
if mibBuilder.loadTexts: rdnCardType.setDescription('Functional type of this card.')
rdnCardDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardDescr.setStatus('current')
if mibBuilder.loadTexts: rdnCardDescr.setDescription('Text description of this card.')
rdnCardSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardSerial.setStatus('current')
if mibBuilder.loadTexts: rdnCardSerial.setDescription('The serial number of this card, or zero if unavailable.')
rdnCardHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardHwVersion.setStatus('current')
if mibBuilder.loadTexts: rdnCardHwVersion.setDescription('Hardware revision level of this card, or an empty string if unavailable.')
rdnCardSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardSwVersion.setStatus('current')
if mibBuilder.loadTexts: rdnCardSwVersion.setDescription('Version of the firmware or microcode installed on this card, or an empty string if unavailable.')
rdnCardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardSlotNumber.setStatus('current')
if mibBuilder.loadTexts: rdnCardSlotNumber.setDescription('Slot number relative to the containing card or chassis, or -1 if neither applicable nor determinable.')
rdnCardContainedByIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardContainedByIndex.setStatus('current')
if mibBuilder.loadTexts: rdnCardContainedByIndex.setDescription('cardIndex of the parent card which directly contains this card, or 0 if contained by the chassis, or -1 if not applicable nor determinable.')
rdnCardOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("not-specified", 1), ("up", 2), ("down", 3), ("standby", 4), ("rom", 5), ("flash", 6), ("diag", 7), ("boot", 8), ("config", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardOperStatus.setStatus('current')
if mibBuilder.loadTexts: rdnCardOperStatus.setDescription('The operational status of the card. cardOperStatus is up when a card is recognized by the device and is enabled for operation. cardOperStatus is down if the card is not recognized by the device, or if it is not enabled for operation. cardOperStatus is standby if the card is enabled and acting as a standby slave. Intermediate stages (rom,flash,diag,boot,config) are also exposed.')
rdnChassisSlots = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnChassisSlots.setStatus('current')
if mibBuilder.loadTexts: rdnChassisSlots.setDescription('Number of slots in this chassis, or -1 if neither applicable nor determinable.')
rdnSlotTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 1, 10), )
if mibBuilder.loadTexts: rdnSlotTable.setStatus('current')
if mibBuilder.loadTexts: rdnSlotTable.setDescription('Chassis slot table.')
rdnSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1), ).setIndexNames((0, "RDN-CHASSIS-MIB", "rdnSlotIndex"))
if mibBuilder.loadTexts: rdnSlotEntry.setStatus('current')
if mibBuilder.loadTexts: rdnSlotEntry.setDescription('Chassis slot table.')
rdnSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: rdnSlotIndex.setStatus('current')
if mibBuilder.loadTexts: rdnSlotIndex.setDescription("The index into rdnSlotTable (not physical slot number). This object's instance is always one number greater than the rdnSlotNumber (physical slot number) instance that it indexes.")
rdnSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("srm", 2), ("io", 3), ("hsim", 4), ("cmts", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSlotType.setStatus('current')
if mibBuilder.loadTexts: rdnSlotType.setDescription("Functional type of this slot. 'io(3)' was used by older agents to report either CMTS, HSIM, or none. Newer agents will no longer report 'io(3)' and instead will use either 'hsim(4)' for HSIM, 'cmts(5)' for CMTS, or 'unkown(1)' for no module present.")
rdnSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSlotNumber.setStatus('current')
if mibBuilder.loadTexts: rdnSlotNumber.setDescription('The physical chasis slot number relative to the containing card or chassis, or -1 if neither applicable nor determinable.')
rdnSlotOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("not-specified", 1), ("up", 2), ("down", 3), ("standby", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSlotOperStatus.setStatus('current')
if mibBuilder.loadTexts: rdnSlotOperStatus.setDescription('The operational status of the chassis physical slot. rdnSlotOperStatus is up when a card is recognized by the system and is enabled for operation. rdnSlotOperStatus is down if a card is not present or recognized by the system, or if it is not enabled for operation. rdnSlotOperStatus is standby if the card is enabled and acting as a standby slave. A not-specified state indicates an unknown error condition')
rdnOfflineModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnOfflineModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnOfflineModemCount.setDescription('Number of offline modems for this slot')
rdnOnlineModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnOnlineModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnOnlineModemCount.setDescription('Number of online modems for this slot')
rdnActiveModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnActiveModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnActiveModemCount.setDescription('Number of active modems for this slot')
rdnRegisteredModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnRegisteredModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnRegisteredModemCount.setDescription('Number of registered modems for this slot')
rdnProvisionedModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnProvisionedModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnProvisionedModemCount.setDescription('Number of provisioned modems for this slot')
rdnUnregisteredModemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnUnregisteredModemCount.setStatus('current')
if mibBuilder.loadTexts: rdnUnregisteredModemCount.setDescription('Number of Unregistered modems for this slot')
rdnResetSlotStats = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnResetSlotStats.setStatus('current')
if mibBuilder.loadTexts: rdnResetSlotStats.setDescription("The byte and packet counters for all the cable modems for the given slot are reset by a 'set' of this object to TRUE(1). This object will always return FALSE(2) when read.")
rdnSlotUnerroreds = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSlotUnerroreds.setStatus('current')
if mibBuilder.loadTexts: rdnSlotUnerroreds.setDescription('Codewords received on this cmts slot without error. This includes all codewords, whether or not they were part of frames destined for this device.')
rdnSlotCorrecteds = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSlotCorrecteds.setStatus('current')
if mibBuilder.loadTexts: rdnSlotCorrecteds.setDescription('Codewords received on this cmts slot with correctable errors. This includes all codewords, whether or not they were part of frames destined for this device.')
rdnSlotUncorrectables = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSlotUncorrectables.setStatus('current')
if mibBuilder.loadTexts: rdnSlotUncorrectables.setDescription('Codewords received on this cmts slot with uncorrectable errors. This includes all codewords, whether or not they were part of frames destined for this device.')
rdnCardIfIndexTable = MibTable((1, 3, 6, 1, 4, 1, 4981, 1, 11), )
if mibBuilder.loadTexts: rdnCardIfIndexTable.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfIndexTable.setDescription('Chassis card table.')
rdnCardIfIndexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1), ).setIndexNames((0, "RDN-CHASSIS-MIB", "rdnCardIfIndex"))
if mibBuilder.loadTexts: rdnCardIfIndexEntry.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfIndexEntry.setDescription('Chassis card table.')
rdnCardIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardIfIndex.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfIndex.setDescription('matches RFC1213 ifTable IfIndex')
rdnCardIfSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardIfSlotNumber.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfSlotNumber.setDescription('Chassis slot number, or -1 if neither applicable nor determinable.')
rdnCardIfPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardIfPortNumber.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfPortNumber.setDescription('Chassis port number, unique per port on a given card if available.')
rdnCardIfCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardIfCardIndex.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfCardIndex.setDescription('cardIndex of the card in the Chassis cardTable which contains this interface.')
rdnCardIfConnectorTypeEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-specified", 1), ("none", 2), ("rj-45", 3), ("db-40", 4), ("db-15", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardIfConnectorTypeEnabled.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfConnectorTypeEnabled.setDescription("Interface connector type currently enabled. Value will be 1 if not known or not used, or 2 if none of this ports' interface connectors are enabled.")
rdnCardIfLinkUpDownEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnCardIfLinkUpDownEnable.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfLinkUpDownEnable.setDescription("This enables and disables the sending of the proprietary notifications 'rdnLinkUpTrap' and 'rdnLinkDownTrap' that provide more information than the standard link up and link down notifications. By default, these traps are disabled.")
rdnCardIfPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 4981, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ethernet", 1), ("gige", 2), ("cmts", 3), ("cmts-dn", 4), ("cmts-up", 5), ("cmts-up-log", 6), ("pos", 7), ("lag", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnCardIfPortType.setStatus('current')
if mibBuilder.loadTexts: rdnCardIfPortType.setDescription('This object is used to identify port types for a given card. This object will report ethernet(1) for SRM ports and HSIM FE ports, gige(2) for GigE ports, cmts(3) for CMTS cards, cmts_dn(4) in case of downstream ports for CMTS cards, cmts_up(5) in case of upstream ports for CMTS cards, cmts_up_log(6) in case of upstream logical channels for CMTS cards, pos(7) for POS cards, lag(8) for Link Aggregation interfaces')
rdnSysUpTimeAtLastChassisChange = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSysUpTimeAtLastChassisChange.setStatus('current')
if mibBuilder.loadTexts: rdnSysUpTimeAtLastChassisChange.setDescription("Time in seconds/100 from the last cold start to the last change in the chassis' configuration. This value will be updated whenever the chassis experiences a change in the count, type, or slot position of a card in cardTable.")
rdnSysUpTimeAtLastConfigChange = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdnSysUpTimeAtLastConfigChange.setStatus('current')
if mibBuilder.loadTexts: rdnSysUpTimeAtLastConfigChange.setDescription('Time in seconds/100 from the last configuration change in the system. This value will be set back to zero whenever the system experiences a change in the configuration.')
rdnChassisPowerTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnChassisPowerTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rdnChassisPowerTrapEnable.setDescription('This object controls SNMP traps for chassis Power Failure. If its value is set to enabled(1), then traps are generated. If the value is disabled(2), then traps are not generated. By default, this object has the value enabled(1). ')
rdnChassisFanTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnChassisFanTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rdnChassisFanTrapEnable.setDescription('This object controls SNMP traps for chassis Fan Failure. If its value is set to enabled(1), then traps are generated. If the value is disabled(2), then traps are not generated. By default, this object has the value enabled(1). ')
rdnChassisBSRSrmSwitchoverTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdnChassisBSRSrmSwitchoverTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rdnChassisBSRSrmSwitchoverTrapEnable.setDescription('This object controls SNMP traps for redundant SRM switchovers. If its value is set to enabled(1), then traps are generated. If the value is disabled(2), then traps are not generated. By default, this object has the value enabled(1). ')
chassisNotificationObject = MibIdentifier((1, 3, 6, 1, 4, 1, 4981, 1, 0))
chassisPowerFailureTrapInfo = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 0, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("powerFailureA", 1), ("powerFailureB", 2), ("powerRestoredA", 3), ("powerRestoredB", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: chassisPowerFailureTrapInfo.setStatus('current')
if mibBuilder.loadTexts: chassisPowerFailureTrapInfo.setDescription('Indicates the location of the Power Failure.')
chassisPowerFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 1, 0, 2)).setObjects(("RDN-CHASSIS-MIB", "chassisPowerFailureTrapInfo"))
if mibBuilder.loadTexts: chassisPowerFailureTrap.setStatus('current')
if mibBuilder.loadTexts: chassisPowerFailureTrap.setDescription('A chassisPowerFailureTrap is generated when a Power Failure is detected in the system')
chassisFanFailureTrapInfo = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 0, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upperFanFailure", 1), ("lowerFanFailure", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: chassisFanFailureTrapInfo.setStatus('current')
if mibBuilder.loadTexts: chassisFanFailureTrapInfo.setDescription('Indicates the location of the Fan Failure.')
chassisFanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 1, 0, 4)).setObjects(("RDN-CHASSIS-MIB", "chassisFanFailureTrapInfo"))
if mibBuilder.loadTexts: chassisFanFailureTrap.setStatus('current')
if mibBuilder.loadTexts: chassisFanFailureTrap.setDescription('A chassisFanFailureTrap is generated when a Fan Failure is detected in the system')
rdnRedundancyFailedSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 0, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rdnRedundancyFailedSlotNumber.setStatus('current')
if mibBuilder.loadTexts: rdnRedundancyFailedSlotNumber.setDescription('Chassis slot number that failed, or -1 if neither applicable nor determinable.')
rdnRedundancyBackupSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 4981, 1, 0, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rdnRedundancyBackupSlotNumber.setStatus('current')
if mibBuilder.loadTexts: rdnRedundancyBackupSlotNumber.setDescription('Slot number of the backup card that took over for the failed card, or -1 if neither applicable nor determinable.')
rdnBSRSrmSwitchoverTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 1, 0, 7)).setObjects(("RDN-CHASSIS-MIB", "rdnRedundancyFailedSlotNumber"), ("RDN-CHASSIS-MIB", "rdnRedundancyBackupSlotNumber"))
if mibBuilder.loadTexts: rdnBSRSrmSwitchoverTrap.setStatus('current')
if mibBuilder.loadTexts: rdnBSRSrmSwitchoverTrap.setDescription('An SRM Card has failed, and a switchover has occurred to a redundant SRM card.')
rdnLinkUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 1, 0, 8)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifDescr"), ("IF-MIB", "ifType"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"))
if mibBuilder.loadTexts: rdnLinkUpTrap.setStatus('current')
if mibBuilder.loadTexts: rdnLinkUpTrap.setDescription("A proprietary Link Up Notification for all interfaces. This notification contains more details than the standard 'linkUp' notification in RFC 2863.")
rdnLinkDownTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 1, 0, 9)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifDescr"), ("IF-MIB", "ifType"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"))
if mibBuilder.loadTexts: rdnLinkDownTrap.setStatus('current')
if mibBuilder.loadTexts: rdnLinkDownTrap.setDescription("A proprietary Link Down Notification for all interfaces. This notification contains more details than the standard 'linkDown' notification in RFC 2863.")
rdnBsrTestTrap = NotificationType((1, 3, 6, 1, 4, 1, 4981, 1, 0, 10)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("SNMPv2-MIB", "sysDescr"))
if mibBuilder.loadTexts: rdnBsrTestTrap.setStatus('current')
if mibBuilder.loadTexts: rdnBsrTestTrap.setDescription("This is convenient test trap that Service personnel can generate manually, in debug mode, from the CLI, for diagnostic purposes ('generate snmp-trap [severity]'). Varbinds are docsDevEvLevel = trap severity level, and sysDescr = system description. ")
mibBuilder.exportSymbols("RDN-CHASSIS-MIB", rdnChassisType=rdnChassisType, rdnSlotUnerroreds=rdnSlotUnerroreds, rdnCardIfPortType=rdnCardIfPortType, rdnCardIfSlotNumber=rdnCardIfSlotNumber, chassisNotificationObject=chassisNotificationObject, rdnSlotCorrecteds=rdnSlotCorrecteds, rdnResetSlotStats=rdnResetSlotStats, rdnUnregisteredModemCount=rdnUnregisteredModemCount, rdnOnlineModemCount=rdnOnlineModemCount, PYSNMP_MODULE_ID=rdnChassis, rdnChassisSlots=rdnChassisSlots, rdnCardIfIndexTable=rdnCardIfIndexTable, rdnChassisVersion=rdnChassisVersion, rdnRedundancyBackupSlotNumber=rdnRedundancyBackupSlotNumber, rdnCardSerial=rdnCardSerial, rdnFlashSize=rdnFlashSize, rdnNvRAMSize=rdnNvRAMSize, rdnSlotNumber=rdnSlotNumber, rdnChassisFanTrapEnable=rdnChassisFanTrapEnable, rdnCardHwVersion=rdnCardHwVersion, rdnSlotTable=rdnSlotTable, rdnCardType=rdnCardType, rdnSlotUncorrectables=rdnSlotUncorrectables, rdnCardContainedByIndex=rdnCardContainedByIndex, rdnSlotEntry=rdnSlotEntry, rdnChassisBSRSrmSwitchoverTrapEnable=rdnChassisBSRSrmSwitchoverTrapEnable, rdnBsrTestTrap=rdnBsrTestTrap, rdnCardIndex=rdnCardIndex, rdnSysUpTimeAtLastChassisChange=rdnSysUpTimeAtLastChassisChange, rdnBSRSrmSwitchoverTrap=rdnBSRSrmSwitchoverTrap, rdnCardOperStatus=rdnCardOperStatus, rdnNvRAMUsed=rdnNvRAMUsed, rdnCardSlotNumber=rdnCardSlotNumber, rdnChassisId=rdnChassisId, rdnCardIfLinkUpDownEnable=rdnCardIfLinkUpDownEnable, rdnCardSwVersion=rdnCardSwVersion, chassisFanFailureTrapInfo=chassisFanFailureTrapInfo, chassisPowerFailureTrapInfo=chassisPowerFailureTrapInfo, rdnCardIfConnectorTypeEnabled=rdnCardIfConnectorTypeEnabled, rdnLinkUpTrap=rdnLinkUpTrap, rdnProvisionedModemCount=rdnProvisionedModemCount, rdnRegisteredModemCount=rdnRegisteredModemCount, rdnCardIfIndex=rdnCardIfIndex, rdnCardIfCardIndex=rdnCardIfCardIndex, rdnChassisPowerTrapEnable=rdnChassisPowerTrapEnable, rdnSlotIndex=rdnSlotIndex, rdnChassis=rdnChassis, chassisPowerFailureTrap=chassisPowerFailureTrap, rdnActiveModemCount=rdnActiveModemCount, rdnSlotType=rdnSlotType, rdnOfflineModemCount=rdnOfflineModemCount, rdnRedundancyFailedSlotNumber=rdnRedundancyFailedSlotNumber, rdnCardIfPortNumber=rdnCardIfPortNumber, chassisFanFailureTrap=chassisFanFailureTrap, rdnSlotOperStatus=rdnSlotOperStatus, rdnCardEntry=rdnCardEntry, rdnProcessorRam=rdnProcessorRam, rdnCardTable=rdnCardTable, rdnSysUpTimeAtLastConfigChange=rdnSysUpTimeAtLastConfigChange, rdnCardIfIndexEntry=rdnCardIfIndexEntry, rdnLinkDownTrap=rdnLinkDownTrap, rdnCardDescr=rdnCardDescr)

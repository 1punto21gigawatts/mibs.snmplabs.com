#
# PySNMP MIB module EXP-DOCS-CABLE-DEVICE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EXP-DOCS-CABLE-DEVICE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:07:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
vacmAccessEntry, = mibBuilder.importSymbols("SNMP-VIEW-BASED-ACM-MIB", "vacmAccessEntry")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter32, ModuleIdentity, Unsigned32, MibIdentifier, iso, Gauge32, mib_2, TimeTicks, ObjectIdentity, NotificationType, Integer32, experimental, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter64, zeroDotZero = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "Unsigned32", "MibIdentifier", "iso", "Gauge32", "mib-2", "TimeTicks", "ObjectIdentity", "NotificationType", "Integer32", "experimental", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter64", "zeroDotZero")
TruthValue, DateAndTime, TextualConvention, DisplayString, RowPointer, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DateAndTime", "TextualConvention", "DisplayString", "RowPointer", "RowStatus")
docsDev = ModuleIdentity((1, 3, 6, 1, 3, 83))
docsDev.setRevisions(('2000-07-07 00:00', '1999-08-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: docsDev.setRevisionsDescriptions(('Modified by Mike StJohns to bring into SNMPv3/IPv6 compliance. Modified to deal with multiple CPE interface devices. Updated compliance statements to current version.', 'Initial version, published as RFC 2669.',))
if mibBuilder.loadTexts: docsDev.setLastUpdated('200007070000Z')
if mibBuilder.loadTexts: docsDev.setOrganization('IETF IPCDN Working Group')
if mibBuilder.loadTexts: docsDev.setContactInfo(' Michael StJohns Postal: Excite@Home 450 Broadway Redwood City, CA 94063 U.S.A. Phone: +1 650 569 5368 E-mail: stjohns@corp.home.net')
if mibBuilder.loadTexts: docsDev.setDescription('This is the MIB Module for MCNS-compliant cable modems and cable-modem termination systems.')
docsDevMIBObjects = MibIdentifier((1, 3, 6, 1, 3, 83, 1))
docsDevBase = MibIdentifier((1, 3, 6, 1, 3, 83, 1, 1))
class InterfaceSet(TextualConvention, Integer32):
    description = "This is a convenience syntax for setting the value of a bit set object which depicts a set of interfaces. Upon read an object of this type always returns other (1). Upon a valid set, this causes the related interface bit set object (as indicated in the object description which uses this syntax) in the same row to be set to a bit set consisting of the interfaces (and ONLY the interfaces) which match the class type represented by this object. allCpe - all interfaces which face the customer. allNetwork - all interfaces which do not face the customer - e.g. for a CM the HFC MAC interface. allCpeEthernet, allCpeUsb, allCpeFirewire - all interfaces which face the customer of a particular type. allExternal - all interfaces which have a external physical instantiation, e.g. CPE Ethernet, HFC MAC, PCI Bus allInternal - all interfaces which point towards either the devices own stack, or towards an application residing on the device self - the interface which points to the device's own stack all - all interfaces. application1-4 - a specific application residing on the CM or CMTS. The specific mapping of which values of this object map to which interfaces is out of scope for this document (and in general is set by the vendor). Certain of these classes of interfaces may not exist on specific agents. In which case, setting this object to those values results in related interface bit set being set to an empty bit set. all, allCpe and allNetwork MUST be valid settings for this object on any compliant agent and MUST result in at least one interface bit being set in the related bit set. If both the object with this syntax and its related object are SET in the same action the result is undefined as the order in which the SETs take place is undefined. Either one or the other object should be SET at any given time, not both."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
    namedValues = NamedValues(("other", 1), ("allCpe", 2), ("allNetwork", 3), ("allCpeEthernet", 4), ("allCpeUsb", 5), ("allCpeFirewire", 6), ("allExternal", 7), ("allInternal", 8), ("all", 9), ("application1", 10), ("application2", 11), ("application3", 12), ("application4", 13))

class IpV4orV6Address(TextualConvention, OctetString):
    description = 'An IP V4 or V6 address expressed as an octet string. The zero length string is equal to both 0.0.0.0 and the IPv6 :0 address.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )
docsDevRole = MibScalar((1, 3, 6, 1, 3, 83, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cm", 1), ("cmtsActive", 2), ("cmtsBackup", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevRole.setStatus('current')
if mibBuilder.loadTexts: docsDevRole.setDescription("Defines the current role of this device. cm (1) is a Cable Modem, cmtsActive(2) is a Cable Modem Termination System which is controlling the system of cable modems, and cmtsBackup(3) is a CMTS which is currently connected, but not controlling the system (not currently used). In general, if this device is a 'cm', its role will not change during operation or between reboots. If the device is a 'cmts' it may change between cmtsActive and cmtsBackup and back again during normal operation. NB: At this time, the DOCSIS standards do not support the concept of a backup CMTS, cmtsBackup is included for completeness.")
docsDevDateTime = MibScalar((1, 3, 6, 1, 3, 83, 1, 1, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevDateTime.setStatus('current')
if mibBuilder.loadTexts: docsDevDateTime.setDescription('The current date and time, with optional timezone information. This is set at boot from the time server. If its impossible to set this from boot, this shall represent elapsed time from boot relative to the standard epoch (e.g. 1 Jan 1970 0000Z). In other words, if this agent has been up for 3 minuntes, and has been unable to set this object from the time server, this object will return 1 Jan 1970 0003Z.')
docsDevResetNow = MibScalar((1, 3, 6, 1, 3, 83, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevResetNow.setStatus('current')
if mibBuilder.loadTexts: docsDevResetNow.setDescription('Setting this object to true(1) causes the device to reset. Reading this object always returns false(2).')
docsDevSerialNumber = MibScalar((1, 3, 6, 1, 3, 83, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSerialNumber.setStatus('current')
if mibBuilder.loadTexts: docsDevSerialNumber.setDescription("The manufacturer's serial number for this device.")
docsDevSTPControl = MibScalar((1, 3, 6, 1, 3, 83, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stEnabled", 1), ("noStFilterBpdu", 2), ("noStPassBpdu", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSTPControl.setStatus('current')
if mibBuilder.loadTexts: docsDevSTPControl.setDescription('This object controls operation of the spanning tree protocol (as distinguished from transparent bridging). If set to stEnabled(1) then the spanning tree protocol is enabled, subject to bridging constraints. If noStFilterBpdu(2), then spanning tree is not active, and Bridge PDUs received are discarded. If noStPassBpdu(3) then spanning tree is not active and Bridge PDUs are transparently forwarded. Note that a device need not implement all of these options, but that noStFilterBpdu(2) is required.')
docsDevNmAccessTable = MibTable((1, 3, 6, 1, 3, 83, 1, 2), )
if mibBuilder.loadTexts: docsDevNmAccessTable.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessTable.setDescription('This table controls access to SNMP objects by network management stations. If the table is empty, access to SNMP objects is unrestricted. This table exists only on SNMPv1 or v2c agents and does not exist on SNMPv3 agents. See the conformance section for details. Specifically, for v3 agents, the appropriate MIBs and security models apply in lieu of this table. This table is deprecated. Instead, use the SNMP coexistence MIBs from RFC2576, the TARGET and NOTIFICATION MIBs from the SNMP Applications RFC, and the VACM MIBs for SNMPv1 and V2C access. If SNMP-COMMUNITY-MIB is implemented AND snmpCommunityTable is populated, then docsDevNmAccessTable and its entries are ignored for the purpose of determining v1 or v2c access. If the SNMP-COMMUNITY-MIB table has no entries, then this table has its normal access control (described above) meaning for v1 and v2c access. (Obviously, if docsDevNmAccessTable is not implemented and snmpCommunityTable is not populated, then there will be no access via SNMPv1 or v2c) To be very specific: IF the count of rows in SNMP-COMMUNITY-MIB|snmpCommunityTable > 0 THEN resolve access using snmpCommunityTable ELSE resolve access using docsDevNmAccessTable')
docsDevNmAccessEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 2, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIndex"))
if mibBuilder.loadTexts: docsDevNmAccessEntry.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessEntry.setDescription('An entry describing access to SNMP objects by a particular network management station. An entry in this table is not readable unless the management station has read-write permission (either implicit if the table is empty, or explicit through an entry in this table. Entries are ordered by docsDevNmAccessIndex. The first matching entry (e.g. matching IP address and community string) is used to derive access.')
docsDevNmAccessIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevNmAccessIndex.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessIndex.setDescription('Index used to order the application of access entries.')
docsDevNmAccessIp = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 2), IpAddress().clone(hexValue="ffffffff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessIp.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessIp.setDescription('The IP address (or subnet) of the network management station. The address 255.255.255.255 is defined to mean any NMS. If traps are enabled for this entry, then the value must be the address of a specific device.')
docsDevNmAccessIpMask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 3), IpAddress().clone(hexValue="ffffffff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessIpMask.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessIpMask.setDescription('The IP subnet mask of the network management stations. If traps are enabled for this entry, then the value must be 255.255.255.255.')
docsDevNmAccessCommunity = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('public')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessCommunity.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessCommunity.setDescription('The community string to be matched for access by this entry. If set to a zero length string then any community string will match. When read, this object SHOULD return a zero length string.')
docsDevNmAccessControl = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("read", 2), ("readWrite", 3), ("roWithTraps", 4), ("rwWithTraps", 5), ("trapsOnly", 6))).clone('read')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessControl.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessControl.setDescription("Specifies the type of access allowed to this NMS. Setting this object to none(1) causes the table entry to be destroyed. Read(2) allows access by 'get' and 'get-next' PDUs. ReadWrite(3) allows access by 'set' as well. RoWithtraps(4), rwWithTraps(5), and trapsOnly(6) control distribution of Trap PDUs transmitted by this device.")
docsDevNmAccessInterfaces = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessInterfaces.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessInterfaces.setDescription("Specifies the set of interfaces from which requests from this NMS will be accepted. Each octet within the value of this object specifies a set of eight interfaces, with the first octet specifying ports 1 through 8, the second octet specifying interfaces 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered interface, and the least significant bit represents the highest numbered interface. Thus, each interface is represented by a single bit within the value of this object. If that bit has a value of '1' then that interface is included in the set. Note that entries in this table apply only to link-layer interfaces (e.g., Ethernet and CATV MAC). Upstream and downstream channel interfaces must not be specified. The size of this object is the minimum required to represent all configured interfaces for this device.")
docsDevNmAccessStatus = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessStatus.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessStatus.setDescription('Controls and reflects the status of rows in this table. Rows in this table may be created by either the create-and-go or create-and-wait paradigms. There is no restriction on changing values in a row of this table while the row is active.')
docsDevSoftware = MibIdentifier((1, 3, 6, 1, 3, 83, 1, 3))
docsDevSwServer = MibScalar((1, 3, 6, 1, 3, 83, 1, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServer.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevSwServer.setDescription('The address of the TFTP server used for software upgrades. If the TFTP server is unknown or is a V6 address, return 0.0.0.0. This entry is deprecated. See docsDevSwServerAddress for its replacement. This object will have its value modified given a valid SET to docsDevSwServerAddress.')
docsDevSwFilename = MibScalar((1, 3, 6, 1, 3, 83, 1, 3, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwFilename.setStatus('current')
if mibBuilder.loadTexts: docsDevSwFilename.setDescription("The file name of the software image to be loaded into this device. Unless set via SNMP, this is the file name specified by the provisioning server that corresponds to the software version that is desired for this device. If unknown, the string '(unknown)' is returned.")
docsDevSwAdminStatus = MibScalar((1, 3, 6, 1, 3, 83, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("upgradeFromMgt", 1), ("allowProvisioningUpgrade", 2), ("ignoreProvisioningUpgrade", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwAdminStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevSwAdminStatus.setDescription('If set to upgradeFromMgt(1), the device will initiate a TFTP software image download using docsDevSwFilename. After successfully receiving an image, the device will set its state to ignoreProvisioningUpgrade(3) and reboot. If the download process is interrupted by a reset or power failure, the device will load the previous image and, after re-initialization, continue to attempt loading the image specified in docsDevSwFilename. If set to allowProvisioningUpgrade(2), the device will use the software version information supplied by the provisioning server when next rebooting (this does not cause a reboot). When set to ignoreProvisioningUpgrade(3), the device will disregard software image upgrade information from the provisioning server. Note that reading this object can return upgradeFromMgt(1). This indicates that a software download is currently in progress, and that the device will reboot after successfully receiving an image. At initial startup, this object has the default value of allowProvisioningUpgrade(2).')
docsDevSwOperStatus = MibScalar((1, 3, 6, 1, 3, 83, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inProgress", 1), ("completeFromProvisioning", 2), ("completeFromMgt", 3), ("failed", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSwOperStatus.setReference('DOCSIS Radio Frequency Interface Specification, Section 8.2, Downloading Cable Modem Operating Software.')
if mibBuilder.loadTexts: docsDevSwOperStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevSwOperStatus.setDescription('InProgress(1) indicates that a TFTP download is underway, either as a result of a version mismatch at provisioning or as a result of a upgradeFromMgt request. CompleteFromProvisioning(2) indicates that the last software upgrade was a result of version mismatch at provisioning. CompleteFromMgt(3) indicates that the last software upgrade was a result of setting docsDevSwAdminStatus to upgradeFromMgt. Failed(4) indicates that the last attempted download failed, ordinarily due to TFTP timeout.')
docsDevSwCurrentVers = MibScalar((1, 3, 6, 1, 3, 83, 1, 3, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSwCurrentVers.setStatus('current')
if mibBuilder.loadTexts: docsDevSwCurrentVers.setDescription('The software version currently operating in this device. This object should be in the syntax used by the individual vendor to identify software versions. Any CM MUST return a string descriptive of the current software load. For a CMTS, this object SHOULD contain either a human readable representation of the vendor specific designation of the software for the chassis, or of the software for the control processor. If neither of these is applicable, this MUST contain an empty string.')
docsDevSwServerAddress = MibScalar((1, 3, 6, 1, 3, 83, 1, 3, 6), IpV4orV6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServerAddress.setStatus('current')
if mibBuilder.loadTexts: docsDevSwServerAddress.setDescription('The address of the TFTP server used for software upgrades. If the TFTP server is unknown, return the zero length address string (See the TextualConvention). If docsDevSwServer is also implemented in this agent, this object is tied to it. A set of this object to an IPv4 address will result in the value of docsDevSwServer also being set to that address. If this object is set to an IPv6 address, docsDevSwServer is set to 0.0.0.0. If docsDevSwServer is set, this object is also set to that value. Note that if both are set in the same action, the order of which one sets the other is undefined - so both should be the same value.')
docsDevServer = MibIdentifier((1, 3, 6, 1, 3, 83, 1, 4))
docsDevServerBootState = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("operational", 1), ("disabled", 2), ("waitingForDhcpOffer", 3), ("waitingForDhcpResponse", 4), ("waitingForTimeServer", 5), ("waitingForTftp", 6), ("refusedByCmts", 7), ("forwardingDenied", 8), ("other", 9), ("unknown", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerBootState.setReference('DOCSIS Radio Frequency Interface Specification, Figure 7-1, CM Initialization Overview.')
if mibBuilder.loadTexts: docsDevServerBootState.setStatus('current')
if mibBuilder.loadTexts: docsDevServerBootState.setDescription('If operational(1), the device has completed loading and processing of configuration parameters and the CMTS has completed the Registration exchange. If disabled(2) then the device was administratively disabled, possibly by being refused network access in the configuration file. If waitingForDhcpOffer(3) then a DHCP Discover has been transmitted and no offer has yet been received. If waitingForDhcpResponse(4) then a DHCP Request has been transmitted and no response has yet been received. If waitingForTimeServer(5) then a Time Request has been transmitted and no response has yet been received. If waitingForTftp(6) then a request to the TFTP parameter server has been made and no response received. If refusedByCmts(7) then the Registration Request/Response exchange with the CMTS failed. If forwardingDenied(8) then the registration process completed, but the network access option in the received configuration file prohibits forwarding. ')
docsDevServerDhcp = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerDhcp.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevServerDhcp.setDescription('The IP address of the DHCP server that assigned an IP address to this device. Returns 0.0.0.0 if DHCP was not used for IP address assignment, or if this agent was assigned an IPv6 address. Deprecated. This object is replaced by docsDevServerDhcpAddress')
docsDevServerTime = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTime.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevServerTime.setDescription('The IP address of the Time server (RFC-868). Returns 0.0.0.0 if the time server IP address is unknown, or if the time server was an IPv6 server. Deprecated. This object is replaced by docsDevServerTimeAddress.')
docsDevServerTftp = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTftp.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevServerTftp.setDescription('The IP address of the TFTP server responsible for downloading provisioning and configuration parameters to this device. Returns 0.0.0.0 if the TFTP server address is unknown or is an IPv6 address. Deprecated. This object is replaced by docsDevServerConfigTftpAddress.')
docsDevServerConfigFile = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerConfigFile.setStatus('current')
if mibBuilder.loadTexts: docsDevServerConfigFile.setDescription('The name of the device configuration file read from the TFTP server. Returns an empty string if the configuration file name is unknown.')
docsDevServerDhcpAddress = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 6), IpV4orV6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerDhcpAddress.setStatus('current')
if mibBuilder.loadTexts: docsDevServerDhcpAddress.setDescription('The IP v4 or v6 address of the DHCP server that assigned an IP address to this device. Returns the zero length octet string if DHCP was not used for IP address assignment.')
docsDevServerTimeAddress = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 7), IpV4orV6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTimeAddress.setStatus('current')
if mibBuilder.loadTexts: docsDevServerTimeAddress.setDescription('The IP V4 or V6 address of the Time server (RFC-868). Returns the zero length octet string if the time server IP address is unknown.')
docsDevServerConfigTftpAddress = MibScalar((1, 3, 6, 1, 3, 83, 1, 4, 8), IpV4orV6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerConfigTftpAddress.setStatus('current')
if mibBuilder.loadTexts: docsDevServerConfigTftpAddress.setDescription('The IP V4 or V6 address of the TFTP server responsible for downloading provisioning and configuration parameters to this device. Returns the zero length octet string if the config server address is unknown.')
docsDevEvent = MibIdentifier((1, 3, 6, 1, 3, 83, 1, 5))
docsDevEvControl = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("resetLog", 1), ("useDefaultReporting", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvControl.setStatus('current')
if mibBuilder.loadTexts: docsDevEvControl.setDescription('Setting this object to resetLog(1) empties the event log. All data is deleted. Setting it to useDefaultReporting(2) returns all event priorities to their factory-default reporting. Reading this object always returns useDefaultReporting(2).')
docsDevEvSyslog = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvSyslog.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevEvSyslog.setDescription('The IP address of the Syslog server. If 0.0.0.0, syslog transmission is either inhibited, or if docsDevEvSyslogAddress exists in this agent - may be an IPv6 device. Deprecated. See docsDevEvSyslogAddress')
docsDevEvThrottleAdminStatus = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unconstrained", 1), ("maintainBelowThreshold", 2), ("stopAtThreshold", 3), ("inhibited", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleAdminStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleAdminStatus.setDescription('Controls the transmission of traps and syslog messages with respect to the trap pacing threshold. unconstrained(1) causes traps and syslog messages to be transmitted without regard to the threshold settings. maintainBelowThreshold(2) causes trap transmission and syslog messages to be suppressed if the number of traps would otherwise exceed the threshold. stopAtThreshold(3) causes trap transmission to cease at the threshold, and not resume until directed to do so. inhibited(4) causes all trap transmission and syslog messages to be suppressed. A single event is always treated as a single event for threshold counting. That is, an event causing both a trap and a syslog message is still treated as a single event. Writing to this object resets the thresholding state. At initial startup, this object has a default value of unconstrained(1).')
docsDevEvThrottleInhibited = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvThrottleInhibited.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleInhibited.setDescription('If true(1), trap and syslog transmission is currently inhibited due to thresholds and/or the current setting of docsDevEvThrottleAdminStatus. In addition, this is set to true(1) if transmission is inhibited due to no syslog (docsDevEvSyslog) or trap (docsDevNmAccessEntry) destinations having been set.')
docsDevEvThrottleThreshold = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleThreshold.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleThreshold.setDescription('Number of trap/syslog events per docsDevEvThrottleInterval to be transmitted before throttling. A single event is always treated as a single event for threshold counting. That is, an event causing both a trap and a syslog message is still treated as a single event. At initial startup, this object returns 0.')
docsDevEvThrottleInterval = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleInterval.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleInterval.setDescription('The interval over which the trap threshold applies. At initial startup, this object has a value of 1.')
docsDevEvControlTable = MibTable((1, 3, 6, 1, 3, 83, 1, 5, 7), )
if mibBuilder.loadTexts: docsDevEvControlTable.setStatus('current')
if mibBuilder.loadTexts: docsDevEvControlTable.setDescription('This table allows control of the reporting of event classes. For each event priority, a combination of logging and reporting mechanisms may be chosen. The mapping of event types to priorities is vendor-dependent. Vendors may also choose to allow the user to control that mapping through proprietary means.')
docsDevEvControlEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 5, 7, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvPriority"))
if mibBuilder.loadTexts: docsDevEvControlEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevEvControlEntry.setDescription('Allows configuration of the reporting mechanisms for a particular event priority.')
docsDevEvPriority = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emergency", 1), ("alert", 2), ("critical", 3), ("error", 4), ("warning", 5), ("notice", 6), ("information", 7), ("debug", 8))))
if mibBuilder.loadTexts: docsDevEvPriority.setStatus('current')
if mibBuilder.loadTexts: docsDevEvPriority.setDescription('The priority level that is controlled by this entry. These are ordered from most (emergency) to least (debug) critical. Each event with a CM or CMTS has a particular priority level associated with it (as defined by the vendor). During normal operation no event more critical than notice(6) should be generated. Events between warning and emergency should be generated at appropriate levels of problems (e.g. emergency when the box is about to crash).')
docsDevEvReporting = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 7, 1, 2), Bits().clone(namedValues=NamedValues(("local", 0), ("traps", 1), ("syslog", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvReporting.setStatus('current')
if mibBuilder.loadTexts: docsDevEvReporting.setDescription('Defines the action to be taken on occurrence of this event class. Implementations may not necessarily support all options for all event classes, but at minimum must allow traps and syslogging to be disabled. If the local(0) bit is set, then log to the internal log, if the traps(1) bit is set, then generate a trap, if the syslog(2) bit is set, then send a syslog message (assuming the syslog address is set).')
docsDevEventTable = MibTable((1, 3, 6, 1, 3, 83, 1, 5, 8), )
if mibBuilder.loadTexts: docsDevEventTable.setStatus('current')
if mibBuilder.loadTexts: docsDevEventTable.setDescription('Contains a log of network and device events that may be of interest in fault isolation and troubleshooting.')
docsDevEventEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 5, 8, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvIndex"))
if mibBuilder.loadTexts: docsDevEventEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevEventEntry.setDescription('Describes a network or device event that may be of interest in fault isolation and troubleshooting. Multiple sequential identical events are represented by incrementing docsDevEvCounts and setting docsDevEvLastTime to the current time rather than creating multiple rows. Entries are created with the first occurrance of an event. docsDevEvControl can be used to clear the table. Individual events can not be deleted.')
docsDevEvIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevEvIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevEvIndex.setDescription('Provides relative ordering of the objects in the event log. This object will always increase except when (a) the log is reset via docsDevEvControl, (b) the device reboots and does not implement non-volatile storage for this log, or (c) it reaches the value 2^31. The next entry for all the above cases is 1.')
docsDevEvFirstTime = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvFirstTime.setStatus('current')
if mibBuilder.loadTexts: docsDevEvFirstTime.setDescription('The value of docsDevDateTime at the time this entry was created.')
docsDevEvLastTime = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvLastTime.setStatus('current')
if mibBuilder.loadTexts: docsDevEvLastTime.setDescription('If multiple events are reported via the same entry, the value of docsDevDateTime that the last event for this entry occurred, otherwise this should have the same value as docsDevEvFirstTime. ')
docsDevEvCounts = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvCounts.setStatus('current')
if mibBuilder.loadTexts: docsDevEvCounts.setDescription('The number of consecutive event instances reported by this entry. This starts at 1 with the creation of this row and increments by 1 for each subsequent duplicate event.')
docsDevEvLevel = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emergency", 1), ("alert", 2), ("critical", 3), ("error", 4), ("warning", 5), ("notice", 6), ("information", 7), ("debug", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvLevel.setStatus('current')
if mibBuilder.loadTexts: docsDevEvLevel.setDescription('The priority level of this event as defined by the vendor. These are ordered from most serious (emergency) to least serious (debug).')
docsDevEvId = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvId.setStatus('current')
if mibBuilder.loadTexts: docsDevEvId.setDescription('For this product, uniquely identifies the type of event that is reported by this entry.')
docsDevEvText = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 5, 8, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvText.setStatus('current')
if mibBuilder.loadTexts: docsDevEvText.setDescription('Provides a human-readable description of the event, including all relevant context (interface numbers, etc.).')
docsDevEvSyslogAddress = MibScalar((1, 3, 6, 1, 3, 83, 1, 5, 9), IpV4orV6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvSyslogAddress.setStatus('current')
if mibBuilder.loadTexts: docsDevEvSyslogAddress.setDescription('The IP V4 or V6 address of the Syslog server. If the address of the server is set to any of the zero length string, the 0.0.0.0 V4 address or the 0: V6 address, syslog transmission is inhibited. By default at agent boot, this object returns the zero length string.')
docsDevFilter = MibIdentifier((1, 3, 6, 1, 3, 83, 1, 6))
docsDevFilterLLCUnmatchedAction = MibScalar((1, 3, 6, 1, 3, 83, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevFilterLLCUnmatchedAction.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCUnmatchedAction.setDescription('LLC (Link Level Control) filters can be defined on an inclusive or exclusive basis: CMs can be configured to forward only packets matching a set of layer three protocols, or to drop packets matching a set of layer three protocols. Typical use of these filters is to filter out possibly harmful (given the context of a large metropolitan LAN) protocols. If set to discard(1), any L2 packet which does not match at least one filter in the docsDevFilterLLCTable will be discarded. If set to accept(2), any L2 packet which does not match at least one filter in the docsDevFilterLLCTable will be accepted for further processing (e.g., bridging). In otherwords, if the packet does not match an entry in the table it takes this action, if it does match an entry in the table it takes the opposite of this action. At initial system startup, this object returns accept(2).')
docsDevFilterLLCTable = MibTable((1, 3, 6, 1, 3, 83, 1, 6, 2), )
if mibBuilder.loadTexts: docsDevFilterLLCTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCTable.setDescription('A list of filters to apply to (bridged) LLC traffic. The filters in this table are applied to incoming traffic on the appropriate interface(s) prior to any further processing (e.g. before handing the packet off for level 3 processing, or for bridging). The specific action taken when no filter is matched is controlled by docsDevFilterLLCUnmatchedAction.')
docsDevFilterLLCEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 6, 2, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIndex"))
if mibBuilder.loadTexts: docsDevFilterLLCEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCEntry.setDescription('Describes a single filter to apply to (bridged) LLC traffic received on a specified interface. ')
docsDevFilterLLCIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterLLCIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCIndex.setDescription('Index used for the identification of filters (note that LLC filter order is irrelevant).')
docsDevFilterLLCStatus = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCStatus.setDescription('Controls and reflects the status of rows in this table. There is no restriction on changing any of the associated columns for this row while this object is set to active.')
docsDevFilterLLCIfIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevFilterLLCIfIndex.setDescription('The entry interface to which this filter applies. The value corresponds to ifIndex for either a CATV MAC or another network interface. If the value is zero, the filter applies to all interfaces. In Cable Modems, the default value is the customer side interface. In Cable Modem Termination Systems, this object has to be specified to create a row in this table. DEPRECATED. If the docsDevFilterLLCInterfaces object exists in this agent and row, then the value of this object is ignored for purposes of filtering.')
docsDevFilterLLCProtocolType = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethertype", 1), ("dsap", 2))).clone('ethertype')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCProtocolType.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCProtocolType.setDescription('The format of the value in docsDevFilterLLCProtocol: either a two-byte Ethernet Ethertype, or a one-byte 802.2 SAP value. EtherType(1) also applies to SNAP- encapsulated frames.')
docsDevFilterLLCProtocol = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCProtocol.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCProtocol.setDescription('The layer three protocol for which this filter applies. The protocol value format depends on docsDevFilterLLCProtocolType. Note that for SNAP frames, etherType filtering is performed rather than DSAP=0xAA.')
docsDevFilterLLCMatches = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevFilterLLCMatches.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCMatches.setDescription('Counts the number of times this filter was matched.')
docsDevFilterLLCInterfaces = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCInterfaces.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCInterfaces.setDescription("Specifies the set of interfaces this filter applies to. Each octet within the value of this object specifies a set of eight interfaces, with the first octet spefifying interfaces 1 through 8, the second octet specifying interfaces 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered interface, and the least significant bit representst the highest numbered interface. Thus, each interface is represented by a single bit within the value of this object. If that bit has a value of '1' then that interface is included in this set. The actual mapping of physical interfaces to interface number is implementation dependent.")
docsDevFilterLLCInterfaceSet = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 2, 1, 8), InterfaceSet().clone('allCpe')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCInterfaceSet.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCInterfaceSet.setDescription("This is a convenience object for setting the value of docsDevFilterLLCInterfaces. Upon a valid set, this causes docsDevFilterLLCInterfaces in the same row to be set to a bit mask set consisting of the interfaces which match the class type represented by this object. Upon read, this returns 'other' by definition.")
docsDevFilterIpDefault = MibScalar((1, 3, 6, 1, 3, 83, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevFilterIpDefault.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDefault.setDescription('The default behavior for (bridged) packets that do not match IP filters is defined by docsDevFilterIpDefault. If set to discard(1), all packets not matching an IP filter will be discarded. If set to accept(2), all packets not matching an IP filter will be accepted for further processing (e.g., bridging). At initial system startup, this object returns accept(2).')
docsDevFilterIpTable = MibTable((1, 3, 6, 1, 3, 83, 1, 6, 4), )
if mibBuilder.loadTexts: docsDevFilterIpTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpTable.setDescription('An ordered list of filters or classifiers to apply to IP traffic. Filter application is ordered by the filter index, rather than by a best match algorithm (Note that this implies that the filter table may have gaps in the index values). Packets which match no filters will have policy 0 in the docsDevFilterPolicyTable applied to them if it exists. Otherwise, Packets which match no filters are discarded or forwarded according to the setting of docsDevFilterIpDefault. Any IP packet can theoretically match multiple rows of this table. When considering a packet, the table is scanned in row index order (e.g. filter 10 is checked before filter 20). If the packet matches that filter (which means that it matches ALL criteria for that row), actions appropriate to docsDevFilterIpControl and docsDevFilterPolicyId are taken. If the packet was discarded processing is complete. If docsDevFilterIpContinue is set to true, the filter comparison continues with the next row in the table looking for additional matches. If the packet matches no filter in the table, the packet is accepted or dropped for further processing based on the setting of docsDevFilterIpDefault. If the packet is accepted, the actions specified by policy group 0 (e.g. the rows in docsDevFilterPolicyTable which have a value of 0 for docsDevFilterPolicyId) are taken if that policy group exists. Logically, this table is consulted twice during the processing of any IP packet - once upon its acceptance from the L2 entity, and once upon its transmission to the L2 entity. In actuality, for cable modems, IP filtering is generally the only IP processing done for transit traffic. This means that inbound and outbound filtering can generally be done at the same time with one pass through the filter table.')
docsDevFilterIpEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 6, 4, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpIndex"))
if mibBuilder.loadTexts: docsDevFilterIpEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpEntry.setDescription('Describes a filter to apply to IP traffic received on a specified interface. All identity objects in this table (e.g. source and destination address/mask, protocol, source/dest port, TOS/mask, interface and direction) must match their respective fields in the packet for any given filter to match. To create an entry in this table, docsDevFilterIpIfIndex must be specified.')
docsDevFilterIpIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterIpIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpIndex.setDescription('Index used to order the application of filters. The filter with the lowest index is always applied first.')
docsDevFilterIpStatus = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpStatus.setDescription('Controls and reflects the status of rows in this table. Specifying only this object (with the appropriate index) on a CM is sufficient to create a filter row which matches all inbound packets on the ethernet interface, and results in the packets being discarded. docsDevFilterIpIfIndex (at least) must be specified on a CMTS to create a row. Creation of the rows may be done via either create-and-wait or create-and-go, but the filter is not applied until this object is set to (or changes to) active. There is no restriction in changing any object in a row while this object is set to active.')
docsDevFilterIpControl = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2), ("policy", 3))).clone('discard')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpControl.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpControl.setDescription('If set to discard(1), all packets matching this filter will be discarded and scanning of the remainder of the filter list will be aborted. If set to accept(2), all packets matching this filter will be accepted for further processing (e.g., bridging). If docsDevFilterIpContinue is set to true, see if there are other matches, otherwise done. If set to policy (3), execute the policy entries matched by docsDevIpFilterPolicyId in docsDevIpFilterPolicyTable. If is docsDevFilterIpContinue is set to true, continue scanning the table for other matches, otherwise done.')
docsDevFilterIpIfIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevFilterIpIfIndex.setDescription('The entry interface to which this filter applies. The value corresponds to ifIndex for either a CATV MAC or another interface. If the value is zero, the filter applies to all interfaces. Default value in Cable Modems is the index of the customer-side (e.g. ethernet) interface. In Cable Modem Termination Systems, this object MUST be specified to create a row in this table. DEPRECATED. If the docsDevFilterIpInterfaces object exists in this agent and row, then the value of this object is ignored for purposes of filtering AND this object need not be specified to create a row in this table.')
docsDevFilterIpDirection = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2), ("both", 3))).clone('inbound')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDirection.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDirection.setDescription('Determines whether the filter is applied to inbound(1) traffic, outbound(2) traffic, or traffic in both(3) directions.')
docsDevFilterIpBroadcast = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpBroadcast.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpBroadcast.setDescription('If set to true(1), the filter only applies to multicast and broadcast traffic. If set to false(2), the filter applies to all traffic.')
docsDevFilterIpSaddr = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSaddr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSaddr.setDescription("The source IP address, or portion thereof, that is to be matched for this filter. The source address is first masked (and'ed) against docsDevFilterIpSmask before being compared to this value. A value of 0 for this object and 0 for the mask matches all IP addresses.")
docsDevFilterIpSmask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSmask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSmask.setDescription("A bit mask that is to be applied to the source address prior to matching. This mask is not necessarily the same as a subnet mask, but 1's bits must be leftmost and contiguous.")
docsDevFilterIpDaddr = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDaddr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDaddr.setDescription("The destination IP address, or portion thereof, that is to be matched for this filter. The destination address is first masked (and'ed) against docsDevFilterIpDmask before being compared to this value. A value of 0 for this object and 0 for the mask matches all IP addresses.")
docsDevFilterIpDmask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDmask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDmask.setDescription("A bit mask that is to be applied to the destination address prior to matching. This mask is not necessarily the same as a subnet mask, but 1's bits must be leftmost and contiguous.")
docsDevFilterIpProtocol = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpProtocol.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpProtocol.setDescription('The IP protocol value that is to be matched. For example: icmp is 1, tcp is 6, udp is 17. A value of 256 matches ANY protocol.')
docsDevFilterIpSourcePortLow = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSourcePortLow.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSourcePortLow.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the inclusive lower bound of the transport-layer source port range that is to be matched, otherwise it is ignored during matching.')
docsDevFilterIpSourcePortHigh = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSourcePortHigh.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSourcePortHigh.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the inclusive upper bound of the transport-layer source port range that is to be matched, otherwise it is ignored during matching.')
docsDevFilterIpDestPortLow = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDestPortLow.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDestPortLow.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the inclusive lower bound of the transport-layer destination port range that is to be matched, otherwise it is ignored during matching.')
docsDevFilterIpDestPortHigh = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDestPortHigh.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDestPortHigh.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the inclusive upper bound of the transport-layer destination port range that is to be matched, otherwise it is ignored during matching.')
docsDevFilterIpMatches = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevFilterIpMatches.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpMatches.setDescription('Counts the number of times this filter was matched. This object is initialized to 0 at boot, or at row creation, and is reset only upon reboot.')
docsDevFilterIpTos = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpTos.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpTos.setDescription("This is the value to be matched to the packet's TOS (Type of Service) value (after the TOS value is AND'd with docsDevFilterIpTosMask). A value for this object of 0 and a mask of 0 matches all TOS values.")
docsDevFilterIpTosMask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpTosMask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpTosMask.setDescription("The mask to be applied to the packet's TOS value before matching.")
docsDevFilterIpContinue = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpContinue.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpContinue.setDescription('If this value is set to true, and docsDevFilterIpControl is anything but discard (1), continue scanning and applying policies.')
docsDevFilterIpPolicyId = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpPolicyId.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpPolicyId.setDescription('This object points to an entry in docsDevFilterPolicyTable. If docsDevFilterIpControl is set to policy (3), execute all matching policies in docsDevFilterPolicyTable. If no matching policy exists, treat as if docsDevFilterIpControl were set to accept (1). If this object is set to the value of 0, there is no matching policy, and docsDevFilterPolicyTable MUST NOT be consulted.')
docsDevFilterIpInterfaces = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpInterfaces.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpInterfaces.setDescription("Specifies the set of interfaces this filter applies to. Each octet within the value of this object specifies a set of eight interfaces, with the first octet spefifying interfaces 1 through 8, the second octet specifying interfaces 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered interface, and the least significant bit represents the highest numbered interface. Thus, each interface is represented by a single bit within the value of this object. If that bit has a value of '1' then that interface is included in this set.")
docsDevFilterIpInterfaceSet = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 4, 1, 22), InterfaceSet().clone('allCpe')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpInterfaceSet.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpInterfaceSet.setDescription('This is a convenience object for setting the value of docsDevFilterIpInterfaces. Upon read this always returns other (1). Upon a valid set, this causes docsDevFilterIpInterfaces in the same row to be set to a bit mask set consisting of the interfaces which match the class type represented by this object.')
docsDevFilterPolicyTable = MibTable((1, 3, 6, 1, 3, 83, 1, 6, 5), )
if mibBuilder.loadTexts: docsDevFilterPolicyTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyTable.setDescription('A Table which maps between a policy group ID and a set of policies to be applied. All rows with the same docsDevFilterPolicyId are part of the same policy group and are applied in the order in which they are in this table. docsDevFilterPolicyTable exists to allow multiple policy actions to be applied to any given classified packet. The policy actions are applied in index order For example: Index ID Type Action 1 1 TOS 1 9 5 TOS 1 12 1 IPSEC 3 This says that a packet which matches a filter with policy id 1, first has TOS policy 1 applied (which might set the TOS bits to enable a higher priority), and next has the IPSEC policy 3 applied (which may result in the packet being dumped into a secure VPN to a remote encryptor). Policy ID 0 is reserved for default actions and is applied only to packets which match no filters in docsDevIpFilterTable.')
docsDevFilterPolicyEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 6, 5, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyIndex"))
if mibBuilder.loadTexts: docsDevFilterPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyEntry.setDescription('An entry in the docsDevFilterPolicyTable. Entries are created by Network Management. To create an entry, docsDevFilterPolicyId and docsDevFilterPolicyAction must be specified.')
docsDevFilterPolicyIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyIndex.setDescription('Index value for the table.')
docsDevFilterPolicyId = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyId.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyId.setDescription('Policy ID for this entry. A policy ID can apply to multiple rows of this table, all relevant policies are executed. Policy 0 (if populated) is applied to all packets which do not match any of the filters. N.B. If docsDevFilterIpPolicyId is set to 0, it DOES NOT match policy 0 of this table. ')
docsDevFilterPolicyStatus = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyStatus.setDescription('Object used to create an entry in this table.')
docsDevFilterPolicyPtr = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 5, 1, 6), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyPtr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyPtr.setDescription('This object points to a row in an applicable filter policy table. Currently, the only standard policy table is docsDevFilterTosTable. Per the textual convention, this object points to the first accessible object in the row. E.g. to point to a row in docsDevFilterTosTable with an index of 21, the value of this object would be the object identifier docsDevTosStatus.21. Vendors must adhere to the same convention when adding vendor specific policy table extensions. The default upon row creation is a null pointer which results in no policy action being taken.')
docsDevFilterTosTable = MibTable((1, 3, 6, 1, 3, 83, 1, 6, 6), )
if mibBuilder.loadTexts: docsDevFilterTosTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosTable.setDescription('Table used to describe Type of Service (TOS) bits processing. This table is an adjunct to the docsDevFilterIpTable, and the docsDevFilterPolicy table. Entries in the latter table can point to specific rows in this (and other) tables and cause specific actions to be taken. This table permits the manipulation of the value of the Type of Service bits in the IP header of the matched packet as follows: Set the tosBits of the packet to (tosBits & docsDevFilterTosAndMask) | docsDevFilterTosOrMask This construct allows you to do a clear and set of all the TOS bits in a flexible manner.')
docsDevFilterTosEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 6, 6, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosIndex"))
if mibBuilder.loadTexts: docsDevFilterTosEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosEntry.setDescription('A TOS policy entry.')
docsDevFilterTosIndex = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterTosIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosIndex.setDescription('The unique index for this row. There are no ordering requirements for this table and any valid index may be specified.')
docsDevFilterTosStatus = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosStatus.setDescription('The object used to create and delete entries in this table. A row created by specifying just this object results in a row which specifies no change to the TOS bits. A row may be created using either the create-and-go or create-and-wait paradigms. There is no restriction on the ability to change values in this row while the row is active.')
docsDevFilterTosAndMask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="ff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosAndMask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosAndMask.setDescription("This value is bitwise AND'd with the matched packet's TOS bits.")
docsDevFilterTosOrMask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosOrMask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosOrMask.setDescription("After bitwise AND'ing with the above bits, the packet's TOS bits are bitwise OR'd with these bits, and the packet's TOS BITS are set to that value.")
docsDevFilterIpV6AuxTable = MibTable((1, 3, 6, 1, 3, 83, 1, 6, 7), )
if mibBuilder.loadTexts: docsDevFilterIpV6AuxTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpV6AuxTable.setDescription('This table augments docsDevIpFilterTable with objects that allow filtering of IPv6 packets. The objects in this table exactly mirror the IPv4 objects in docsDevIpFilterTable, but become active for purposes of filtering if and only if docsDevFilterIpType is set to ipv6.')
docsDevFilterIpV6AuxEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 6, 7, 1), )
docsDevFilterIpEntry.registerAugmentions(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpV6AuxEntry"))
docsDevFilterIpV6AuxEntry.setIndexNames(*docsDevFilterIpEntry.getIndexNames())
if mibBuilder.loadTexts: docsDevFilterIpV6AuxEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpV6AuxEntry.setDescription('This augments the existing objects in docsDevFilterIpEntry, but by default the objects in this entry have no effect on filtering as docsDevFilterIpType defaults to ipv4 upon row creation.')
docsDevFilterIpType = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpType.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpType.setDescription('This object controls whether this filter entry refers to IP v4 or v6 type packets. If this object is ipv4, then the IpAddress objects docsDevFilterEntry apply, otherwise if this object is ipv6 then the remaining objects in this entry apply.')
docsDevFilterIpV6Saddr = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 7, 1, 2), Ipv6Address().clone(hexValue="00000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpV6Saddr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpV6Saddr.setDescription("The source address IPv6 address or portion thereof that is to be matched for this filter. The packet's source address is first masked (and'ed) aginst docsDevFilterIpV6Smask before being compared to this value. A value of of all zeros for this object and for the mask matches all IPv6 addresses.")
docsDevFilterIpV6Smask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 7, 1, 3), Ipv6Address().clone(hexValue="00000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpV6Smask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpV6Smask.setDescription("A bit mask that is to be applied to the packet's source address prior to matching. The mask is not necessarily the same as a subnet mask, the the 1's bits must be leftmost and contiguous.")
docsDevFilterIpV6Daddr = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 7, 1, 4), Ipv6Address().clone(hexValue="00000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpV6Daddr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpV6Daddr.setDescription("The destination address IPv6 address or portion thereof that is to be matched for this filter. The packet's source address is first masked (and'ed) aginst docsDevFilterIpV6Dmask before being compared to this value. A value of of all zeros for this object and for the mask matches all IPv6 addresses.")
docsDevFilterIpV6Dmask = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 6, 7, 1, 5), Ipv6Address().clone(hexValue="00000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpV6Dmask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpV6Dmask.setDescription("A bit mask that is to be applied to the packet's destination address prior to matching. The mask is not necessarily the same as a subnet mask, the the 1's bits must be leftmost and contiguous.")
docsDevCpe = MibIdentifier((1, 3, 6, 1, 3, 83, 1, 7))
docsDevCpeEnroll = MibScalar((1, 3, 6, 1, 3, 83, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("any", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevCpeEnroll.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeEnroll.setDescription('This object controls the population of docsDevFilterCpeTable. If set to none, the filters must be set manually. If set to any, the CM wiretaps the packets originating from the ethernet and enrolls up to docsDevCpeIpMax addresses based on the source IPv4 or v6 addresses of those packets. At initial system startup, default value for this object is any(2).')
docsDevCpeIpMax = MibScalar((1, 3, 6, 1, 3, 83, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevCpeIpMax.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeIpMax.setDescription('This object controls the maximum number of CPEs allowed to be learned behind this device. If set to zero, any number of CPEs may connect up to the maximum permitted for the device. If set to -1, no filtering is done on CPE source addresses, and no entries are made in the docsDevFilterCpeTable via learning. If an attempt is made to set this to a number greater than that permitted for the device, it is set to that maximum. At initial system startup, default value for this object is -1.')
docsDevCpeTable = MibTable((1, 3, 6, 1, 3, 83, 1, 7, 3), )
if mibBuilder.loadTexts: docsDevCpeTable.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeTable.setDescription('This table lists the IP addresses seen (or permitted) as source addresses in packets originating from the customer interface on this device. In addition, this table can be provisioned with the specific addresses permitted for the CPEs via the normal row creation mechanisms. N.B. Management action can add entries in this table and in docsDevCpeIpTable past the value of docsDevCpeIpMax. docsDevCpeIpMax ONLY restricts the ability of the CM to automatically add learned addresses.')
docsDevCpeEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 7, 3, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeIp"))
if mibBuilder.loadTexts: docsDevCpeEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeEntry.setDescription('An entry in the docsDevFilterCpeTable. There is one entry for each IP CPE seen or provisioned. If docsDevCpeIpMax is set to -1, this table is ignored, otherwise: Upon receipt of an IP packet from the customer interface of the CM, the source IP address is checked against this table. If the address is in the table, packet processing continues. If the address is not in the table, but docsDevCpeEnroll is set to any and the sum of the table sizes of docsDevCpeTable and docsDevCpeV6Table is less than docsDevCpeIpMax, the address is added to the table and packet processing continues. Otherwise, the packet is dropped. The filtering actions specified by this table occur after any LLC filtering (docsDevFilterLLCTable), but prior to any IP filtering (docsDevFilterIpTable, docsDevNmAccessTable).')
docsDevCpeIp = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 7, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: docsDevCpeIp.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeIp.setDescription('The IP address to which this entry applies. N.B. Neither the all zeros or all ones addresses may be used as the value of this object.')
docsDevCpeSource = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("manual", 2), ("learned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevCpeSource.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeSource.setDescription('This object describes how this entry was created. If the value is manual(2), this row was created by a network management action (either configuration, or SNMP set). If set to learned(3), then it was found via looking at the source IP address of a received packet.')
docsDevCpeStatus = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 7, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevCpeStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeStatus.setDescription('Standard object to manipulate rows. To create a row in this table, you only need to specify this object. Management stations SHOULD use the create-and-go mechanism for creating rows in this table.')
docsDevCpeV6Table = MibTable((1, 3, 6, 1, 3, 83, 1, 7, 4), )
if mibBuilder.loadTexts: docsDevCpeV6Table.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeV6Table.setDescription('This table lists the IP V6 addresses seen (or permitted) as source addresses in packets originating from the customer interface on this device. In addition, this table can be provisioned with the specific addresses permitted for the CPEs via the normal row creation mechanisms. N.B. Management action can add entries in this table and in docsDevCpeIpTable past the value of docsDevCpeIpMax. docsDevCpeIpMax ONLY restricts the ability of the CM to automatically add learned addresses. This table exactly mirrors docsDevCpeTable and applies only to IPv6 addresses.')
docsDevCpeV6Entry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 7, 4, 1), ).setIndexNames((0, "EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeV6Ip"))
if mibBuilder.loadTexts: docsDevCpeV6Entry.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeV6Entry.setDescription('An entry in the docsDevFilterCpeTable. There is one entry for each IP V6 CPE seen or provisioned. If docsDevCpeIpMax is set to -1, this table is ignored, otherwise: Upon receipt of an IPv6 packet from the customer interface of the CM, the source IP address is checked against this table. If the address is in the table, packet processing continues. If the address is not in the table, but docsDevCpeEnroll is set to any and the sum of the table sizes for docsDevCpeTable and docsDevCpeV6Tble is less than docsDevCpeIpMax, the address is added to the table and packet processing continues. Otherwise, the packet is dropped. The filtering actions specified by this table occur after any LLC filtering (docsDevFilterLLCTable), but prior to any IP filtering (docsDevFilterIpTable, docsDevNmAccessTable).')
docsDevCpeV6Ip = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 7, 4, 1, 1), Ipv6Address())
if mibBuilder.loadTexts: docsDevCpeV6Ip.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeV6Ip.setDescription('The IP address to which this entry applies. N.B. Neither the all zeros or all ones addresses may be used as values for this object.')
docsDevCpeV6Source = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 7, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("manual", 2), ("learned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevCpeV6Source.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeV6Source.setDescription('This object describes how this entry was created. If the value is manual(2), this row was created by a network management action (either configuration, or SNMP set). If set to learned(3), then it was found via looking at the source IP address of a received packet.')
docsDevCpeV6Status = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 7, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevCpeV6Status.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeV6Status.setDescription('Standard object to manipulate rows. To create a row in this table, you only need to specify this object. Management stations SHOULD use the create-and-go mechanism for creating rows in this table.')
docsDevVacmAccessExtTable = MibTable((1, 3, 6, 1, 3, 83, 1, 8), )
if mibBuilder.loadTexts: docsDevVacmAccessExtTable.setStatus('current')
if mibBuilder.loadTexts: docsDevVacmAccessExtTable.setDescription('This table extends the VACM access table by adding a set of objects which represent the interfaces to which the referenced VACM view applies.')
docsDevVacmAccessExtEntry = MibTableRow((1, 3, 6, 1, 3, 83, 1, 8, 1), )
vacmAccessEntry.registerAugmentions(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevVacmAccessExtEntry"))
docsDevVacmAccessExtEntry.setIndexNames(*vacmAccessEntry.getIndexNames())
if mibBuilder.loadTexts: docsDevVacmAccessExtEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevVacmAccessExtEntry.setDescription('This entry logically extends vacmAccessEntry with two objects - an interface bit set and an InterfaceSet convience object which sets the bit set.')
docsDevVacmAccessInterfaces = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevVacmAccessInterfaces.setStatus('current')
if mibBuilder.loadTexts: docsDevVacmAccessInterfaces.setDescription("Specifies the set of interfaces this filter applies to. Each octet within the value of this object specifies a set of eight interfaces, with the first octet spefifying interfaces 1 through 8, the second octet specifying interfaces 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered interface, and the least significant bit represents the highest numbered interface. Thus, each interface is represented by a single bit within the value of this object. If that bit has a value of '1' then that interface is included in this set. If the bit has a value of '0' then the view represented by the related objects in vacmAccessEntry are not accessible from requests received on that inferface.")
docsDevVacmAccessInterfaceSet = MibTableColumn((1, 3, 6, 1, 3, 83, 1, 8, 1, 2), InterfaceSet().clone('all')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevVacmAccessInterfaceSet.setStatus('current')
if mibBuilder.loadTexts: docsDevVacmAccessInterfaceSet.setDescription('This is a convenience object for setting the value of docsDevVacmAccessInterfaces. Upon read this always returns other (1). Upon a valid set, this causes docsDevVacmAccessInterfaces in the same row to be set to a bit mask set consisting of the interfaces which match the class type represented by this object.')
docsDevNotification = MibIdentifier((1, 3, 6, 1, 3, 83, 2))
docsDevConformanceV2 = MibIdentifier((1, 3, 6, 1, 3, 83, 4))
docsDevGroupsV2 = MibIdentifier((1, 3, 6, 1, 3, 83, 4, 1))
docsDevCompliancesV2 = MibIdentifier((1, 3, 6, 1, 3, 83, 4, 2))
docsDevBasicComplianceV2 = ModuleCompliance((1, 3, 6, 1, 3, 83, 4, 2, 1)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevBaseGroupV2"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEventGroupV2"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterGroupV2"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessGroupV2"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerGroupV2"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroupV2"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeGroupV2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevBasicComplianceV2 = docsDevBasicComplianceV2.setStatus('current')
if mibBuilder.loadTexts: docsDevBasicComplianceV2.setDescription('The compliance statement for MCNS Cable Modems and Cable Modem Termination Systems.')
docsDevBaseGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 1)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevRole"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevDateTime"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevResetNow"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSerialNumber"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSTPControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevBaseGroupV2 = docsDevBaseGroupV2.setStatus('current')
if mibBuilder.loadTexts: docsDevBaseGroupV2.setDescription('A collection of objects providing device status and control.')
docsDevNmAccessGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 2)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIp"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIpMask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessCommunity"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessControl"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessInterfaces"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevNmAccessGroupV2 = docsDevNmAccessGroupV2.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevNmAccessGroupV2.setDescription('A collection of objects for controlling access to SNMP objects. Deprecated in favor of SNMPv3 and coexistence MIB.')
docsDevSoftwareGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 3)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSwFilename"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSwAdminStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSwOperStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSwCurrentVers"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSwServerAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevSoftwareGroupV2 = docsDevSoftwareGroupV2.setStatus('current')
if mibBuilder.loadTexts: docsDevSoftwareGroupV2.setDescription('A collection of objects for controlling software downloads.')
docsDevServerGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 4)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerBootState"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerDhcpAddress"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerTimeAddress"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigTftpAddress"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigFile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevServerGroupV2 = docsDevServerGroupV2.setStatus('current')
if mibBuilder.loadTexts: docsDevServerGroupV2.setDescription('A collection of objects providing status about server provisioning.')
docsDevEventGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 5)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvControl"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleAdminStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInhibited"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleThreshold"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInterval"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvReporting"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvFirstTime"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvLastTime"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvCounts"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvText"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvSyslogAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevEventGroupV2 = docsDevEventGroupV2.setStatus('current')
if mibBuilder.loadTexts: docsDevEventGroupV2.setDescription('A collection of objects used to control and monitor events.')
docsDevFilterGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 6)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCUnmatchedAction"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDefault"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocolType"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocol"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCMatches"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCInterfaces"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCInterfaceSet"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpControl"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDirection"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpBroadcast"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSaddr"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSmask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDaddr"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDmask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpProtocol"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSourcePortLow"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSourcePortHigh"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDestPortLow"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDestPortHigh"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpMatches"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpInterfaces"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpInterfaceSet"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpTos"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpTosMask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpContinue"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpPolicyId"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyId"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyPtr"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosStatus"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosAndMask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosOrMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevFilterGroupV2 = docsDevFilterGroupV2.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterGroupV2.setDescription('A collection of objects to specify filters at link layer and IP layer.')
docsDevCpeGroupV2 = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 7)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeEnroll"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeIpMax"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeSource"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevCpeGroupV2 = docsDevCpeGroupV2.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeGroupV2.setDescription('A collection of objects used to control the number and specific values of IP addresses allowed for associated Customer Premises Equipment (CPE).')
docsDevDeprecatedGroup = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 8)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIfIndex"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpIfIndex"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevSwServer"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerDhcp"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerTime"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevServerTftp"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevEvSyslog"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevDeprecatedGroup = docsDevDeprecatedGroup.setStatus('deprecated')
if mibBuilder.loadTexts: docsDevDeprecatedGroup.setDescription('These objects have been deprecated to deal with the IPv6, SNMPv3 and redefinition of the CM as a multiple CPE device. They MAY be implemented, but will be removed in the next iteration of this MIB.')
docsDevIpV6Group = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 9)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpType"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpV6Saddr"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpV6Smask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpV6Daddr"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpV6Dmask"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeV6Source"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevCpeV6Status"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevIpV6Group = docsDevIpV6Group.setStatus('current')
if mibBuilder.loadTexts: docsDevIpV6Group.setDescription('These objects were added to deal with the filtering of IPV6 addresses. They MUST be implemented in any IPv6 aware cable modem.')
docsDevSnmpCoexistGroup = ObjectGroup((1, 3, 6, 1, 3, 83, 4, 1, 10)).setObjects(("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevVacmAccessInterfaces"), ("EXP-DOCS-CABLE-DEVICE-MIB", "docsDevVacmAccessInterfaceSet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevSnmpCoexistGroup = docsDevSnmpCoexistGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevSnmpCoexistGroup.setDescription('These objects were added to retain the capability to restrict SNMP access on a per interface basis.')
mibBuilder.exportSymbols("EXP-DOCS-CABLE-DEVICE-MIB", docsDevDeprecatedGroup=docsDevDeprecatedGroup, docsDevFilterLLCProtocol=docsDevFilterLLCProtocol, docsDevFilterIpV6AuxEntry=docsDevFilterIpV6AuxEntry, docsDevCompliancesV2=docsDevCompliancesV2, docsDevFilterIpDestPortLow=docsDevFilterIpDestPortLow, docsDevFilterIpSourcePortHigh=docsDevFilterIpSourcePortHigh, docsDevIpV6Group=docsDevIpV6Group, docsDevServerConfigTftpAddress=docsDevServerConfigTftpAddress, docsDevFilterLLCProtocolType=docsDevFilterLLCProtocolType, docsDevFilterIpV6Daddr=docsDevFilterIpV6Daddr, docsDevCpeIpMax=docsDevCpeIpMax, docsDevEvControl=docsDevEvControl, docsDevCpeEnroll=docsDevCpeEnroll, docsDevEventEntry=docsDevEventEntry, docsDevSwServer=docsDevSwServer, docsDevSTPControl=docsDevSTPControl, docsDevFilter=docsDevFilter, docsDevVacmAccessInterfaceSet=docsDevVacmAccessInterfaceSet, docsDevMIBObjects=docsDevMIBObjects, docsDevNmAccessStatus=docsDevNmAccessStatus, docsDevServerTftp=docsDevServerTftp, docsDevRole=docsDevRole, docsDevEvIndex=docsDevEvIndex, docsDevEvPriority=docsDevEvPriority, docsDevFilterIpStatus=docsDevFilterIpStatus, docsDevFilterIpInterfaceSet=docsDevFilterIpInterfaceSet, docsDevNmAccessIpMask=docsDevNmAccessIpMask, docsDevFilterPolicyIndex=docsDevFilterPolicyIndex, docsDevFilterIpBroadcast=docsDevFilterIpBroadcast, docsDevCpeV6Status=docsDevCpeV6Status, docsDevFilterIpTosMask=docsDevFilterIpTosMask, docsDevFilterLLCTable=docsDevFilterLLCTable, docsDevFilterLLCInterfaceSet=docsDevFilterLLCInterfaceSet, docsDevEvSyslogAddress=docsDevEvSyslogAddress, docsDevServerBootState=docsDevServerBootState, docsDevSnmpCoexistGroup=docsDevSnmpCoexistGroup, docsDevNmAccessGroupV2=docsDevNmAccessGroupV2, docsDevFilterIpIfIndex=docsDevFilterIpIfIndex, docsDevFilterTosEntry=docsDevFilterTosEntry, docsDevFilterPolicyPtr=docsDevFilterPolicyPtr, docsDevCpeV6Table=docsDevCpeV6Table, docsDevFilterPolicyEntry=docsDevFilterPolicyEntry, docsDevFilterIpControl=docsDevFilterIpControl, docsDevFilterTosAndMask=docsDevFilterTosAndMask, docsDevFilterIpContinue=docsDevFilterIpContinue, docsDevFilterIpPolicyId=docsDevFilterIpPolicyId, docsDevFilterIpV6Dmask=docsDevFilterIpV6Dmask, docsDevFilterIpTos=docsDevFilterIpTos, docsDevFilterLLCIfIndex=docsDevFilterLLCIfIndex, docsDevFilterTosTable=docsDevFilterTosTable, docsDevResetNow=docsDevResetNow, docsDevNmAccessTable=docsDevNmAccessTable, docsDevEvSyslog=docsDevEvSyslog, docsDevFilterTosStatus=docsDevFilterTosStatus, docsDevNmAccessIp=docsDevNmAccessIp, docsDevNmAccessInterfaces=docsDevNmAccessInterfaces, docsDevEvThrottleInhibited=docsDevEvThrottleInhibited, docsDevEvReporting=docsDevEvReporting, docsDevFilterIpDaddr=docsDevFilterIpDaddr, docsDevCpeIp=docsDevCpeIp, PYSNMP_MODULE_ID=docsDev, docsDevNmAccessCommunity=docsDevNmAccessCommunity, docsDevServerDhcp=docsDevServerDhcp, docsDevSwCurrentVers=docsDevSwCurrentVers, docsDevFilterIpIndex=docsDevFilterIpIndex, docsDevServerConfigFile=docsDevServerConfigFile, docsDevSwOperStatus=docsDevSwOperStatus, docsDevFilterIpTable=docsDevFilterIpTable, docsDevFilterTosOrMask=docsDevFilterTosOrMask, docsDevFilterIpV6Saddr=docsDevFilterIpV6Saddr, docsDevCpeSource=docsDevCpeSource, docsDevVacmAccessExtTable=docsDevVacmAccessExtTable, docsDevEvControlEntry=docsDevEvControlEntry, docsDevServer=docsDevServer, docsDevFilterLLCUnmatchedAction=docsDevFilterLLCUnmatchedAction, docsDevEvThrottleInterval=docsDevEvThrottleInterval, docsDevFilterIpDestPortHigh=docsDevFilterIpDestPortHigh, docsDevVacmAccessInterfaces=docsDevVacmAccessInterfaces, docsDevFilterIpDmask=docsDevFilterIpDmask, docsDevServerTimeAddress=docsDevServerTimeAddress, docsDevEvId=docsDevEvId, docsDevServerDhcpAddress=docsDevServerDhcpAddress, docsDevEvText=docsDevEvText, docsDevFilterIpV6AuxTable=docsDevFilterIpV6AuxTable, docsDevBasicComplianceV2=docsDevBasicComplianceV2, docsDevEventTable=docsDevEventTable, docsDevFilterPolicyId=docsDevFilterPolicyId, docsDevFilterPolicyTable=docsDevFilterPolicyTable, docsDev=docsDev, docsDevFilterIpV6Smask=docsDevFilterIpV6Smask, docsDevCpe=docsDevCpe, docsDevVacmAccessExtEntry=docsDevVacmAccessExtEntry, docsDevSoftware=docsDevSoftware, docsDevEvent=docsDevEvent, docsDevCpeV6Ip=docsDevCpeV6Ip, docsDevSerialNumber=docsDevSerialNumber, docsDevNotification=docsDevNotification, docsDevFilterIpEntry=docsDevFilterIpEntry, docsDevFilterIpType=docsDevFilterIpType, docsDevServerGroupV2=docsDevServerGroupV2, docsDevEvCounts=docsDevEvCounts, docsDevNmAccessEntry=docsDevNmAccessEntry, docsDevFilterLLCInterfaces=docsDevFilterLLCInterfaces, docsDevEvLastTime=docsDevEvLastTime, docsDevBase=docsDevBase, docsDevFilterGroupV2=docsDevFilterGroupV2, docsDevFilterLLCEntry=docsDevFilterLLCEntry, docsDevGroupsV2=docsDevGroupsV2, docsDevServerTime=docsDevServerTime, docsDevFilterPolicyStatus=docsDevFilterPolicyStatus, docsDevEventGroupV2=docsDevEventGroupV2, docsDevFilterLLCStatus=docsDevFilterLLCStatus, docsDevSoftwareGroupV2=docsDevSoftwareGroupV2, docsDevSwFilename=docsDevSwFilename, docsDevBaseGroupV2=docsDevBaseGroupV2, docsDevCpeTable=docsDevCpeTable, docsDevSwAdminStatus=docsDevSwAdminStatus, docsDevNmAccessControl=docsDevNmAccessControl, docsDevCpeStatus=docsDevCpeStatus, docsDevFilterIpDefault=docsDevFilterIpDefault, docsDevFilterLLCIndex=docsDevFilterLLCIndex, docsDevEvThrottleThreshold=docsDevEvThrottleThreshold, docsDevEvControlTable=docsDevEvControlTable, docsDevFilterIpSmask=docsDevFilterIpSmask, docsDevEvFirstTime=docsDevEvFirstTime, docsDevDateTime=docsDevDateTime, docsDevFilterLLCMatches=docsDevFilterLLCMatches, docsDevFilterIpInterfaces=docsDevFilterIpInterfaces, docsDevNmAccessIndex=docsDevNmAccessIndex, docsDevConformanceV2=docsDevConformanceV2, docsDevCpeEntry=docsDevCpeEntry, InterfaceSet=InterfaceSet, docsDevFilterIpSaddr=docsDevFilterIpSaddr, IpV4orV6Address=IpV4orV6Address, docsDevSwServerAddress=docsDevSwServerAddress, docsDevFilterIpProtocol=docsDevFilterIpProtocol, docsDevFilterIpDirection=docsDevFilterIpDirection, docsDevEvThrottleAdminStatus=docsDevEvThrottleAdminStatus, docsDevCpeV6Source=docsDevCpeV6Source, docsDevCpeV6Entry=docsDevCpeV6Entry, docsDevFilterTosIndex=docsDevFilterTosIndex, docsDevEvLevel=docsDevEvLevel, docsDevFilterIpMatches=docsDevFilterIpMatches, docsDevFilterIpSourcePortLow=docsDevFilterIpSourcePortLow, docsDevCpeGroupV2=docsDevCpeGroupV2)

#
# PySNMP MIB module CPQHLTH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQHLTH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
cpqHoTrapFlags, compaq = mibBuilder.importSymbols("CPQHOST-MIB", "cpqHoTrapFlags", "compaq")
cpqSiMemModuleSize, cpqSiServerSystemId = mibBuilder.importSymbols("CPQSINFO-MIB", "cpqSiMemModuleSize", "cpqSiServerSystemId")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
IpAddress, TimeTicks, iso, Unsigned32, NotificationType, NotificationType, Gauge32, ModuleIdentity, Bits, ObjectIdentity, Counter64, MibIdentifier, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "TimeTicks", "iso", "Unsigned32", "NotificationType", "NotificationType", "Gauge32", "ModuleIdentity", "Bits", "ObjectIdentity", "Counter64", "MibIdentifier", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "enterprises")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cpqHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6))
cpqHeMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 1))
cpqHeComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2))
cpqHeTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 3))
cpqHeInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 1))
cpqHeCriticalError = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 2))
cpqHeCorrectableMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 3))
cpqHeAsr = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 5))
cpqHeThermal = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 6))
cpqHePostMsg = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 7))
cpqHeSysUtil = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 8))
cpqHeFltTolPwrSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 9))
cpqHeIRC = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 10))
cpqHeEventLog = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 11))
cpqHeMgmtDisplay = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 12))
cpqHePowerConverter = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 13))
cpqHeResilientMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 14))
cpqHePowerMeter = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 15))
cpqHeOsNetWare3x = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 1))
cpqHeOsCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4))
cpqHeMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeMibRevMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeMibRevMajor.setDescription('The Major Revision level of the MIB. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information, correct interpretation of data may require a MIB document with the same major revision level.')
cpqHeMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeMibRevMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeMibRevMinor.setDescription('The minor revision level of the MIB. A change in the minor revision level may represent some minor additional support, no changes to any pre-existing information has occurred.')
cpqHeMibCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeMibCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeMibCondition.setDescription('The overall condition. This object represents the overall status of the server health system represented by this MIB.')
cpqHeNw3xDriverName = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeNw3xDriverName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeNw3xDriverName.setDescription('Driver Name. This value identifies the NetWare Loadable Module providing the operating system access to the Server Health information.')
cpqHeNw3xDriverDate = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeNw3xDriverDate.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeNw3xDriverDate.setDescription('Driver Date. The date of the NetWare Loadable Module providing the operating system access to the Server Health logs. The date is provided in mm/dd/yy format.')
cpqHeNw3xDriverVersion = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeNw3xDriverVersion.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeNw3xDriverVersion.setDescription('Driver Version. This is the version of the NetWare Loadable Module (NLM) providing the operating system access to the Server Health logs.')
cpqHeOsCommonPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeOsCommonPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeOsCommonPollFreq.setDescription("The Insight Agent's polling frequency. The frequency, in seconds, at which the Insight Agent requests information from the device driver. A frequency of zero indicates that the Insight Agent retrieves the information upon request of a management station, it does not poll the device driver at a specific interval. If the poll frequency is 0 all attempts to write to this object will fail. If the poll frequency is non-zero, setting this value will change the polling frequency of the Insight Agent. Setting the poll frequency to zero will always fail, an agent may also choose to fail any request to change the poll frequency to a value that would severely impact system performance.")
cpqHeOsCommonModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2), )
if mibBuilder.loadTexts: cpqHeOsCommonModuleTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModuleTable.setDescription('Supporting software table. This is a table of software modules that provide an interface to the device this server health MIB describes.')
cpqHeOsCommonModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeOsCommonModuleIndex"))
if mibBuilder.loadTexts: cpqHeOsCommonModuleEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModuleEntry.setDescription('A description of a software modules that provide an interface to the device this MIB describes.')
cpqHeOsCommonModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeOsCommonModuleIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModuleIndex.setDescription('A unique index for this module description.')
cpqHeOsCommonModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeOsCommonModuleName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModuleName.setDescription('The module name.')
cpqHeOsCommonModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeOsCommonModuleVersion.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModuleVersion.setDescription('The module version in XX.YY format. Where XX is the major version number and YY is the minor version number. This field will be null (size 0) string if the agent cannot provide the module version.')
cpqHeOsCommonModuleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeOsCommonModuleDate.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModuleDate.setDescription('The module date. field octets contents range ===== ====== ======= ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 6 7 second 0..60 (use 60 for leap-second) This field will be set to year = 0 if the agent cannot provide the module date. The hour, minute, and second field will be set to zero (0) if they are not relevant. The year field is set with the most significant octet first.')
cpqHeOsCommonModulePurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeOsCommonModulePurpose.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeOsCommonModulePurpose.setDescription('The purpose of the module described in this entry.')
cpqHeCritLogSupported = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCritLogSupported.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCritLogSupported.setDescription('This value specifies if this system supports the critical error logging feature.')
cpqHeCritLogCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCritLogCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCritLogCondition.setDescription('This value specifies the overall condition of the critical error log feature.')
cpqHeLastCritErrorAbendMsg = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeLastCritErrorAbendMsg.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeLastCritErrorAbendMsg.setDescription('Last Critical Termination message. The message associated with the last critical error of type criticalException(14) or abend(27).')
cpqHeCriticalErrorTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4), )
if mibBuilder.loadTexts: cpqHeCriticalErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorTable.setDescription('A table of critical error descriptions.')
cpqHeCriticalErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeCriticalErrorIndex"))
if mibBuilder.loadTexts: cpqHeCriticalErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorEntry.setDescription('A critical error description.')
cpqHeCriticalErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCriticalErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorIndex.setDescription('A number that uniquely specifies this critical error description. The entries will be in order of occurrence with the most recent entry first.')
cpqHeCriticalErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uncorrected", 1), ("corrected", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeCriticalErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorStatus.setDescription('This value specifies if the user has marked this error as corrected. Marking errors as corrected may be performed with the Diagnostics or by a set operation on this variable. Attempting to set this variable to uncorrected(1) will fail.')
cpqHeCriticalErrorType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39))).clone(namedValues=NamedValues(("other", 1), ("empty", 2), ("nonCorrectableMemErr", 3), ("busMasterTimeoutNmi", 4), ("commandBusTimeoutNmi", 5), ("ioCheckNmi", 6), ("refreshOverflowNmi", 7), ("cacheParityNmi", 8), ("processorParityNmi", 9), ("eisaHostMemReadHit", 10), ("processorFailure", 11), ("cautionTemperature", 12), ("postCriticalError", 13), ("criticalException", 14), ("serverManagerIfFail", 15), ("pentiumIperr", 16), ("pentiumAperr", 17), ("pentiumIeerr", 18), ("pentiumApcheck", 19), ("cpuLocalError", 20), ("failsafeTimer", 21), ("softwareNmi", 22), ("asrBaseMemoryParity", 23), ("asrExtendedMemParity", 24), ("asrResetLimit", 25), ("asrMemoryParity", 26), ("abend", 27), ("asrTestEvent", 28), ("asrTimeoutNmi", 29), ("fanFailure", 30), ("upsDetectedLineFail", 31), ("asrDetectedAtBoot", 32), ("redunPowerSupplyFailure", 33), ("pciBusParityError", 34), ("diagnosticError", 35), ("rtcChipBatteryFailure", 36), ("pentiumBerr", 37), ("dcConverterFailure", 38), ("cpuInternalThreshPassed", 39)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCriticalErrorType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorType.setDescription('This value specifies the type of error.')
cpqHeCriticalErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCriticalErrorTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorTime.setDescription('The time of the error: hour (first five bits), day of month (next 5 bits), month (next 4 bits), year of the current century (next 7 bits). The last 3 bits are reserved.')
cpqHeCriticalErrorInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCriticalErrorInfo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorInfo.setDescription('Information about the error.')
cpqHeCriticalErrorDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 2, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCriticalErrorDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCriticalErrorDesc.setDescription('A text description of the critical error.')
cpqHeCorrMemLogStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("disabled", 3), ("enabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemLogStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemLogStatus.setDescription('This value specifies whether this system is currently tracking correctable memory errors.')
cpqHeCorrMemLogCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemLogCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemLogCondition.setDescription('This value specifies the overall condition of the correctable memory error log feature.')
cpqHeCorrMemTotalErrs = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemTotalErrs.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeCorrMemTotalErrs.setDescription('The number of correctable memory errors that have occurred.')
cpqHeCorrMemErrTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4), )
if mibBuilder.loadTexts: cpqHeCorrMemErrTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrTable.setDescription('A table of correctable memory error descriptions.')
cpqHeCorrMemErrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeCorrMemErrIndex"))
if mibBuilder.loadTexts: cpqHeCorrMemErrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrEntry.setDescription('A correctable memory error description.')
cpqHeCorrMemErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrIndex.setDescription('A number that uniquely specifies this correctable memory error description. The entries will be in order of occurrence with the most recent new entry first.')
cpqHeCorrMemErrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeCorrMemErrCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrCount.setDescription('The number of times this memory location has had a correctable memory error. The value zero (0) indicates that the user has marked this error as corrected. Marking errors as corrected may be performed with the Diagnostics or with a set operation of 0 on this variable. Any non-zero valued set operation will fail.')
cpqHeCorrMemErrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrTime.setDescription('The time of the error: hour (first five bits), day of month (next 5 bits), month (next 4 bits), year of the current century (next 7 bits). The last 3 bits are reserved.')
cpqHeCorrMemErrDdr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrDdr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrDdr.setDescription('The data destination register value. This contains information about the memory bank in which the error occurred. The interpretation of this value is dependent on the machine type.')
cpqHeCorrMemErrSyndrome = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrSyndrome.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrSyndrome.setDescription('The memory syndrome value. This contains information about the memory module in which the error occurred. The interpretation of this value is dependant on the machine type.')
cpqHeCorrMemErrDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrDesc.setDescription('A text description of the correctable memory error.')
cpqHeCorrMemErrHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeCorrMemErrHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the correctable memory error. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeCorrMemErrorCntThresh = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeCorrMemErrorCntThresh.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeCorrMemErrorCntThresh.setDescription('The error threshold for Correctable memory errors. When cpqHeCorrMemErrCount is greater than or equal to this value user action is required to replace the failing memory module.')
cpqHeAsrStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notAvailable", 2), ("disabled", 3), ("enabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrStatus.setDescription('The Automatic Server Recovery feature status. If this object is currently other(1) or notAvailable(2) all set operations will fail. Any attempt to set this object to other(1) or notAvailable(2) by a management station will fail. Setting this object to disabled(3) or enabled(4) will disable or enable the ASR feature. Setting this object to disabled(3) will disable the following objects: cpqHeAsrPagerStatus cpqHeAsrDialInStatus cpqHeAsrDialOutStatus')
cpqHeAsrMajorVersion = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrMajorVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrMajorVersion.setDescription('The major version number of the Automatic Server Recovery feature hardware.')
cpqHeAsrMinorVersion = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrMinorVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrMinorVersion.setDescription('The minor version number of the Automatic Server Recovery feature hardware.')
cpqHeAsrTimeout = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrTimeout.setDescription('The time-out in minutes for the Automatic Server Recovery feature hardware. If the variable is not supported, a value of -1 will be returned.')
cpqHeAsrBaseIo = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrBaseIo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrBaseIo.setDescription('The Automatic Server Recovery feature Base I/O address.')
cpqHeAsrPost = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("failed", 2), ("ok", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrPost.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeAsrPost.setDescription('Indicates if the Automatic Server Recovery timer passed the server power-on self test.')
cpqHeAsrReset = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("manualReset", 2), ("asrReset", 3), ("viewed-asrReset", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrReset.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrReset.setDescription("Indicates if the previous reset was caused by the ASR timer. An asrReset(3) condition may be changed with a viewed-asrReset(4) set operation. This is only valid if this variable's current value is asrReset(3). Setting this variable to any other value than viewed-asrReset(4) will fail.")
cpqHeAsrReboot = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("bootOs", 2), ("bootUtilities", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrReboot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrReboot.setDescription('Indicates what software should be started when the server is rebooted by the ASR feature. If this object is currently set to other(1), set operations will fail. This object may not be set to other(1) by a management station. Setting this object to bootOs(2) or bootUtilities(3) will select the software to be started after an ASR reboot.')
cpqHeAsrRebootLimit = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrRebootLimit.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrRebootLimit.setDescription('The number of ASR timer reboots that should cause the server to boot the firmware console and override the standard reboot setting (cpqHeAsrReboot). If this value is 0 then no limit is defined and the standard reboot option will always be used. If the variable is not supported, a value of -1 will be returned.')
cpqHeAsrRebootCount = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrRebootCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrRebootCount.setDescription('The number of ASR reboots that have occurred on this server since the last manual reboot. Reboot count may be reset with a zero valued set operation on this variable. Setting this value to a non-zero value will fail. If the variable is not supported, a value of -1 will be returned.')
cpqHeAsrPagerStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrPagerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrPagerStatus.setDescription('The status of the ASR pager feature. If the current value of this object is not other(1), it may be set to disabled(2) or enabled(3). Attempting a set operation while the value is other(1) will fail. Attempting to set the value to other(1) will fail. Setting this object to enabled(3) will enable the cpqHeAsrStatus object.')
cpqHeAsrPagerNumber = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrPagerNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrPagerNumber.setDescription('The pager number to be dialed after an ASR reboot.')
cpqHeAsrCommPort = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrCommPort.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrCommPort.setDescription('The communication port to be used by the firmware pager and console. The value zero (0) indicates this setting is undefined. If the current value of this object is zero (0) any attempt to set this object from a management station will fail. Any attempt to set this object to zero (0) by a management station will fail. If the variable is not supported, a value of -1 will be returned.')
cpqHeAsrBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrBaudRate.setDescription('The baud rate to be used by the firmware pager and console. The value zero (0) indicates this setting is undefined. If the variable is not supported, a value of -1 will be returned.')
cpqHeAsrPagerMessage = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrPagerMessage.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrPagerMessage.setDescription('The 8 character pager message entered by the user.')
cpqHeAsrBootFail = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("interrupt18", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrBootFail.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeAsrBootFail.setDescription('The action to be taken if an ASR reboot failure occurs.')
cpqHeAsrCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeAsrCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrCondition.setDescription('This value specifies the overall condition of the ASR feature.')
cpqHeAsrDialInStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrDialInStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrDialInStatus.setDescription('The status of the ASR dial in feature. If the current value of this object is other(1) any attempt to set this object from a management station will fail. Any attempt to set this object to other(1) by a management station will fail. Setting this object to enabled(3) will enable the cpqHeAsrStatus object.')
cpqHeAsrDialOutStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrDialOutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrDialOutStatus.setDescription('The status of the ASR dial out feature. If the current value of this object is other(1) any attempt to set this object from a management station will fail. Any attempt to set this object to other(1) by a management station will fail. Setting this object to enabled(3) will enable the cpqHeAsrStatus and the cpqHeAsrDialInStatus objects.')
cpqHeAsrDialOutNumber = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrDialOutNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrDialOutNumber.setDescription('The phone number to be dialed for remote diagnostics if an ASR reset occurs.')
cpqHeAsrNetworkAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrNetworkAccessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeAsrNetworkAccessStatus.setDescription('The status of the ASR network access feature. If the current value of this object is other(1) any attempt to set this object from a management station will fail. Any attempt to set this object to other(1) by a management station will fail.')
cpqHeAsrPollTime = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 5, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeAsrPollTime.setStatus('optional')
if mibBuilder.loadTexts: cpqHeAsrPollTime.setDescription('The poll time in seconds the ASR watchdog timer is being refreshed periodically.')
cpqHeThermalCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalCondition.setDescription("This value specifies the overall condition of the system's thermal environment.")
cpqHeThermalDegradedAction = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("continue", 2), ("shutdown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeThermalDegradedAction.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalDegradedAction.setDescription('The action to perform when the thermal condition is degraded. This value will be one of the following: other(1) This feature is not supported by this system or driver. continue(2) The system should be allowed to continue. shutdown(3) The system should be shutdown.')
cpqHeThermalTempStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalTempStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalTempStatus.setDescription("The status of the system's temperature sensors: This value will be one of the following: other(1) Temp sensing is not supported by this system or driver. ok(2) All temp sensors are within normal operating range. degraded(3) A temp sensor is outside of normal operating range. failed(4) A temp sensor detects a condition that could permanently damage the system. The system will automatically shutdown if the failed(4) condition results, so it is unlikely that this value will ever be returned by the agent. If the cpqHeThermalDegradedAction is set to shutdown(3) the system will be shutdown if the degraded(3) condition occurs.")
cpqHeThermalSystemFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalSystemFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalSystemFanStatus.setDescription('The status of the fan(s) in the system. This value will be one of the following: other(1) Fan status detection is not supported by this system or driver. ok(2) All fans are operating properly. degraded(3) A non-required fan is not operating properly. failed(4) A required fan is not operating properly. If the cpqHeThermalDegradedAction is set to shutdown(3) the system will be shutdown if the failed(4) condition occurs.')
cpqHeThermalCpuFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalCpuFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalCpuFanStatus.setDescription('The status of the processor fan(s) in the system. This value will be one of the following: other(1) Fan status detection is not supported by this system or driver. ok(2) All fans are operating properly. failed(4) A fan is not operating properly. The system will be shutdown if the failed(4) condition occurs.')
cpqHeThermalFanTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6), )
if mibBuilder.loadTexts: cpqHeThermalFanTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanTable.setDescription('A table of fan descriptions.')
cpqHeThermalFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeThermalFanIndex"))
if mibBuilder.loadTexts: cpqHeThermalFanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanEntry.setDescription('A fan description.')
cpqHeThermalFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanIndex.setDescription('A number that uniquely specifies this fan description.')
cpqHeThermalFanRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonRequired", 2), ("required", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanRequired.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanRequired.setDescription('This specifies if the fan described is required for proper operation of the system.')
cpqHeThermalFanPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("absent", 2), ("present", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanPresent.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanPresent.setDescription('This specifies if the fan described is present in the system.')
cpqHeThermalFanCpuFan = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("systemFan", 2), ("cpuFan", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanCpuFan.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanCpuFan.setDescription('This specifies if the described fan is intended specifically to cool the CPU(s).')
cpqHeThermalFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeThermalFanStatus.setDescription('This specifies if the fan described is operating properly. This value will be one of the following: other(1) Fan status detection is not supported by this system or driver. ok(2) The fan is operating properly. failed(4) The fan is not operating properly.')
cpqHeThermalFanHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeThermalFanHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the fan. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeThermalFanCurrentSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeThermalFanCurrentSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqHeThermalFanCurrentSpeed.setDescription('The current speed of a fan in rpm - revolutions per minute.')
cpqHeFltTolFanTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7), )
if mibBuilder.loadTexts: cpqHeFltTolFanTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanTable.setDescription('A table of Fault Tolerant Fan Entries.')
cpqHeFltTolFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeFltTolFanChassis"), (0, "CPQHLTH-MIB", "cpqHeFltTolFanIndex"))
if mibBuilder.loadTexts: cpqHeFltTolFanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanEntry.setDescription('A Fault Tolerant Fan Entry.')
cpqHeFltTolFanChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanChassis.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanChassis.setDescription('The System Chassis number.')
cpqHeFltTolFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanIndex.setDescription('A number that uniquely specifies this fan description.')
cpqHeFltTolFanLocale = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("system", 3), ("systemBoard", 4), ("ioBoard", 5), ("cpu", 6), ("memory", 7), ("storage", 8), ("removableMedia", 9), ("powerSupply", 10), ("ambient", 11), ("chassis", 12), ("bridgeCard", 13), ("managementBoard", 14), ("backplane", 15), ("networkSlot", 16), ("bladeSlot", 17), ("virtual", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanLocale.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanLocale.setDescription('This specifies the location of the fan in the system.')
cpqHeFltTolFanPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("absent", 2), ("present", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanPresent.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanPresent.setDescription('This specifies if the fan described is present in the system.')
cpqHeFltTolFanType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("tachOutput", 2), ("spinDetect", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanType.setDescription('This specifies the type of fan. other(1) The type of fan could not be determined. tachOutput(2) The fan can increase speed for greater cooling. Implies spin detect. spinDetect(3) The fan can detect when the fan stops spinning.')
cpqHeFltTolFanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanSpeed.setDescription('This specifies the speed of the fan. This value will be set if the fan type is tachOutput.')
cpqHeFltTolFanRedundant = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("notRedundant", 2), ("redundant", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanRedundant.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanRedundant.setDescription('This specifies if the fan is in a redundant configuration.')
cpqHeFltTolFanRedundantPartner = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanRedundantPartner.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanRedundantPartner.setDescription('This specifies the index of the redundant partner. A value of zero will be used if there is no redundant partner.')
cpqHeFltTolFanCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanCondition.setDescription('The condition of the fan. This value will be one of the following: other(1) Fan status detection is not supported by this system or driver. ok(2) The fan is operating properly. degraded(3) A redundant fan is not operating properly. failed(4) A non-redundant fan is not operating properly.')
cpqHeFltTolFanHotPlug = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonHotPluggable", 2), ("hotPluggable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolFanHotPlug.setDescription('This indicates if the fan is capable of being removed and/or inserted while the system is in an operational state. If the value is hotPluggable(3), the fan can be safely removed if and only if the cpqHeFltTolFanRedundant field is in a redundant(3) state. This value will be one of the following: other(1) The state could not be determined. nonHotPluggable(2) The fan is not hot plug capable. hotPluggable(3) The fan is hot plug capable and can be removed if the system is operating in a redundant state. A fan may be added to an empty fan bay.')
cpqHeFltTolFanHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeFltTolFanHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the fan. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeFltTolFanCurrentSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 7, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolFanCurrentSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqHeFltTolFanCurrentSpeed.setDescription('The current speed of a fan in rpm - revolutions per minute.')
cpqHeTemperatureTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8), )
if mibBuilder.loadTexts: cpqHeTemperatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureTable.setDescription('A table of Temperature Sensor Entries.')
cpqHeTemperatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeTemperatureChassis"), (0, "CPQHLTH-MIB", "cpqHeTemperatureIndex"))
if mibBuilder.loadTexts: cpqHeTemperatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureEntry.setDescription('A Temperature Sensor Entry.')
cpqHeTemperatureChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureChassis.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureChassis.setDescription('The System Chassis number.')
cpqHeTemperatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureIndex.setDescription('A number that uniquely specifies this temperature sensor description.')
cpqHeTemperatureLocale = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("system", 3), ("systemBoard", 4), ("ioBoard", 5), ("cpu", 6), ("memory", 7), ("storage", 8), ("removableMedia", 9), ("powerSupply", 10), ("ambient", 11), ("chassis", 12), ("bridgeCard", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureLocale.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureLocale.setDescription('This specifies the location of the temperature sensor present in the system.')
cpqHeTemperatureCelsius = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureCelsius.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureCelsius.setDescription('This is the current temperature sensor reading in degrees celsius. If this value cannot be determined by software, then a value of -99 will be returned.')
cpqHeTemperatureThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeTemperatureThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureThreshold.setDescription('This is the shutdown threshold temperature sensor setting in degrees celsius. This is the temperature in which the sensor will be considered to be in a failed state thus causing the system to be shutdown. If this value cannot be determined by software, then a value of -99 will be returned. Only the Ambient zone type allows setting of the threshold temperature.')
cpqHeTemperatureCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureCondition.setDescription('The Temperature sensor condition. This value will be one of the following: other(1) Temperature could not be determined. ok(2) The temperature sensor is within normal operating range. degraded(3) The temperature sensor is outside of normal operating range. failed(4) The temperature sensor detects a condition that could permanently damage the system. The system will automatically shutdown if the failed(4) condition results, so it is unlikely that this value will ever be returned by the agent. If the cpqHeThermalDegradedAction is set to shutdown(3) the system will be shutdown if the degraded(3) condition occurs.')
cpqHeTemperatureThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 9, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("blowout", 5), ("caution", 9), ("critical", 15), ("noreaction", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureThresholdType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeTemperatureThresholdType.setDescription('This specifies the type of this instance of temperature sensor. This value will be one of the following: other(1) Temperature threshold type could not be determined. blowout(5) If a blowout(5) temperature sensor reaches its threshold, the fan or fans in the area of the temperature sensor will increase in speed in an attempt to reduce the temperature before a caution or critical threshold is reached. caution(9) If a caution(9) temperature sensor reaches its threshold, the cpqHeTemperatureCondition will be set to degraded(3) and the system will either continue or shutdown depending on the setting of cpqHeThermalDegradedAction. critical(15) If a critical(15) temperature sensor reaches its threshold, the cpqHeTemperatureCondition will be set to failed(4) and the system will shutdown. noreaction(16) this value will be defined when a threshold value is zero and system will not react on those sensor as those threshold sensors are meant for display purpose only.')
cpqHeTemperatureHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 6, 8, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTemperatureHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeTemperatureHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the temperature sensor. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHePostMsgCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePostMsgCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgCondition.setDescription('This value specifies the overall condition of the POST error recording feature.')
cpqHePostMsgTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 2), )
if mibBuilder.loadTexts: cpqHePostMsgTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgTable.setDescription('A table of POST error message numbers.')
cpqHePostMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 2, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHePostMsgIndex"))
if mibBuilder.loadTexts: cpqHePostMsgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgEntry.setDescription('A POST error message number.')
cpqHePostMsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePostMsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgIndex.setDescription('A number that uniquely specifies this POST error description.')
cpqHePostMsgCode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePostMsgCode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgCode.setDescription('This specifies POST message number for this error.')
cpqHePostMsgDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePostMsgDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgDesc.setDescription('This contains a text description of the POST error. A string of length zero (0) will be returned if no description is available.')
cpqHePostMsgEv = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 7, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHePostMsgEv.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePostMsgEv.setDescription('The EV used to store 8 non-critical POST error codes for use with Quicktest, Utilities, and CIM. Setting this variable with a zero length octet string will clear this variable. All other set operations will fail.')
cpqHeSysUtilLifeTime = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilLifeTime.setDescription('The total time (in minutes) the system has been in full operation (while the server health supporting software was running).')
cpqHeSysUtilEisaBusMin = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusMin.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusMin.setDescription('The EISA bus utilization as a percentage of the theoretical maximum during the last minute. A value of -1 indicates that this feature is not supported on this machine or is not available.')
cpqHeSysUtilEisaBusFiveMin = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusFiveMin.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusFiveMin.setDescription('The EISA bus utilization as a percentage of the theoretical maximum during the last five minutes. A value of -1 indicates that this feature is not supported on this machine or is not available.')
cpqHeSysUtilEisaBusThirtyMin = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusThirtyMin.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusThirtyMin.setDescription('The EISA bus utilization as a percentage of the theoretical maximum during the last thirty minutes. A value of -1 indicates that this feature is not supported on this machine or is not available.')
cpqHeSysUtilEisaBusHour = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusHour.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilEisaBusHour.setDescription('The EISA bus utilization as a percentage of the theoretical maximum during the last hour. A value of -1 indicates that this feature is not supported on this machine or is not available.')
cpqHeSysUtilPciTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6), )
if mibBuilder.loadTexts: cpqHeSysUtilPciTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciTable.setDescription('A table of PCI utilization numbers for a whole aggregate PCI bus or a specific device on that bus.')
cpqHeSysUtilPciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeSysUtilPciIndex"))
if mibBuilder.loadTexts: cpqHeSysUtilPciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciEntry.setDescription('PCI utilization entry')
cpqHeSysUtilPciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciIndex.setDescription('A unique index into each PCI utilization table entry. ')
cpqHeSysUtilPciBus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciBus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciBus.setDescription('The PCI bus number for this set of utilization numbers. ')
cpqHeSysUtilPciDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciDevice.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciDevice.setDescription('The PCI device number for this set of utilization numbers. If this value is -1, the utilization reported is for the aggregate of all devices on this PCI bus. ')
cpqHeSysUtilPciMin = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciMin.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciMin.setDescription('The utilization as a percentage of the theoretical maximum during the last minute. A value of -1 indicates that the utilization number is not available.')
cpqHeSysUtilPciFiveMin = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciFiveMin.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciFiveMin.setDescription('The utilization as a percentage of the theoretical maximum during the last five minutes. A value of -1 indicates that the utilization number is not available.')
cpqHeSysUtilPciThirtyMin = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciThirtyMin.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciThirtyMin.setDescription('The utilization as a percentage of the theoretical maximum during the last thirty minutes. A value of -1 indicates that the utilization number is not available.')
cpqHeSysUtilPciHour = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciHour.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeSysUtilPciHour.setDescription('The utilization as a percentage of the theoretical maximum during the last hour. A value of -1 indicates that the utilization number is not available.')
cpqHeSysUtilPciHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 8, 6, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeSysUtilPciHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeSysUtilPciHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the PCI drawer. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeFltTolPwrSupplyCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPwrSupplyCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPwrSupplyCondition.setDescription('This value specifies the overall condition of the fault tolerant power supply sub-system.')
cpqHeFltTolPwrSupplyStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("notInstalled", 3), ("installed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPwrSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPwrSupplyStatus.setDescription('This value specifies the status of the fault tolerant power supply.')
cpqHeFltTolPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3), )
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyTable.setDescription('A table of Power Supply Entries.')
cpqHeFltTolPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), (0, "CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"))
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyEntry.setDescription('A Fault Tolerant Power Supply Entry.')
cpqHeFltTolPowerSupplyChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyChassis.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyChassis.setDescription('The system chassis number.')
cpqHeFltTolPowerSupplyBay = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyBay.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyBay.setDescription('The bay number to index within this chassis.')
cpqHeFltTolPowerSupplyPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("absent", 2), ("present", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyPresent.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyPresent.setDescription('Indicates whether the power supply is present in the chassis.')
cpqHeFltTolPowerSupplyCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyCondition.setDescription('The condition of the power supply. This value will be one of the following: other(1) The status could not be determined or not present. ok(2) The power supply is operating normally. degraded(3) A temperature sensor, fan or other power supply component is outside of normal operating range. failed(4) A power supply component detects a condition that could permanently damage the system.')
cpqHeFltTolPowerSupplyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noError", 1), ("generalFailure", 2), ("bistFailure", 3), ("fanFailure", 4), ("tempFailure", 5), ("interlockOpen", 6), ("epromFailed", 7), ("vrefFailed", 8), ("dacFailed", 9), ("ramTestFailed", 10), ("voltageChannelFailed", 11), ("orringdiodeFailed", 12), ("brownOut", 13), ("giveupOnStartup", 14), ("nvramInvalid", 15), ("calibrationTableInvalid", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyStatus.setDescription('The status of the power supply.')
cpqHeFltTolPowerSupplyMainVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyMainVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyMainVoltage.setDescription('The input main voltage of the power supply in volts.')
cpqHeFltTolPowerSupplyCapacityUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyCapacityUsed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyCapacityUsed.setDescription('The currently used capacity of the power supply in watts.')
cpqHeFltTolPowerSupplyCapacityMaximum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyCapacityMaximum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyCapacityMaximum.setDescription('The maximum capacity of the power supply in watts.')
cpqHeFltTolPowerSupplyRedundant = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("notRedundant", 2), ("redundant", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyRedundant.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyRedundant.setDescription('The redundancy state of the power supply. This value will be one of the following: other(1) The redundancy state could not be determined. notRedundant(2) The power supply is not operating in a redundant state. redundant(3) The power supply is operating in a redundant state.')
cpqHeFltTolPowerSupplyModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyModel.setDescription('The power supply model name.')
cpqHeFltTolPowerSupplySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplySerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplySerialNumber.setDescription('The power supply serial number.')
cpqHeFltTolPowerSupplyAutoRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyAutoRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyAutoRev.setDescription('The power supply auto revision number.')
cpqHeFltTolPowerSupplyHotPlug = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonHotPluggable", 2), ("hotPluggable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyHotPlug.setDescription('This indicates if the power supply is capable of being removed and/or inserted while the system is in an operational state. If the value is hotPluggable(3), the power supply can be safely removed if and only if the cpqHeFltTolPowerSupplyRedundant field is in a redundant(3) state. This value will be one of the following: other(1) The state could not be determined. nonHotPluggable(2) The power supply is not hot plug capable. hotPluggable(3) The power supply is hot plug capable and can be removed if the system is operating in a redundant state. A power supply may be added to an empty power supply bay.')
cpqHeFltTolPowerSupplyFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyFirmwareRev.setDescription('The power supply firmware revision. This field will be left blank if the firmware revision is unknown.')
cpqHeFltTolPowerSupplyHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the power supply. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeFltTolPowerSupplySparePartNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplySparePartNum.setStatus('optional')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplySparePartNum.setDescription('The power supply part number or spare part number.')
cpqHeFltTolPowerSupplyRedundantPartner = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyRedundantPartner.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyRedundantPartner.setDescription('This specifies the index of the redundant partner. A value of zero will be used if there is no redundant partner.')
cpqHeFltTolPowerSupplyErrorCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 9, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("noError", 1), ("generalFailure", 2), ("overvoltage", 3), ("overcurrent", 4), ("overtemperature", 5), ("powerinputloss", 6), ("fanfailure", 7), ("vinhighwarning", 8), ("vinlowwarning", 9), ("vouthighwarning", 10), ("voutlowwarning", 11), ("inlettemphighwarning", 12), ("iinternaltemphighwarning", 13), ("vauxhighwarning", 14), ("vauxlowwarning", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyErrorCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeFltTolPowerSupplyErrorCondition.setDescription('The Error condition of the power supply.')
cpqHeIRCStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("notavailable", 2), ("disabled", 3), ("enabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeIRCStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeIRCStatus.setDescription('The status of the Integrated Remote Console. A value of notavailable will be returned if this system does not contain IRC.')
cpqHeEventLogSupported = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("supported", 3), ("clear", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeEventLogSupported.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogSupported.setDescription('This value specifies if this system supports the Integrated Management Log feature. An SNMP set of the value clear(4) will clear the System Event Log of all entries.')
cpqHeEventLogCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogCondition.setDescription('This value specifies the overall condition of the Integrated Management Log feature.')
cpqHeEventLogTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3), )
if mibBuilder.loadTexts: cpqHeEventLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogTable.setDescription('A table of System Event Log Entries.')
cpqHeEventLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeEventLogEntryNumber"))
if mibBuilder.loadTexts: cpqHeEventLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogEntry.setDescription('A System Event Log Entry.')
cpqHeEventLogEntryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogEntryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogEntryNumber.setDescription('A number that uniquely specifies this system event log entry.')
cpqHeEventLogEntrySeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 6, 9, 15))).clone(namedValues=NamedValues(("informational", 2), ("infoWithAlert", 3), ("repaired", 6), ("caution", 9), ("critical", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeEventLogEntrySeverity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogEntrySeverity.setDescription("This value specifies the severity of the event log entry. A caution or critical entry can have it's severity lowered by setting this variable to the repaired state.")
cpqHeEventLogEntryClass = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogEntryClass.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogEntryClass.setDescription('This value specifies the event log entry class designation.')
cpqHeEventLogEntryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogEntryCode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogEntryCode.setDescription('This value specifies the event log entry code designation. The meaning of this changes depending on the class.')
cpqHeEventLogEntryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogEntryCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogEntryCount.setDescription('This value specifies the event log entry occurrence count. This represents the number of times this event has occurred starting from the initial time until the last modified time.')
cpqHeEventLogInitialTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogInitialTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogInitialTime.setDescription('The time stamp when the event log entry was first created. field octets contents range ===== ====== ======== ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 The year field is set with the most significant octet first. A value of 0 in the year indicates an unknown time stamp.')
cpqHeEventLogUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogUpdateTime.setDescription('The time stamp when the event log entry was last modified. field octets contents range ===== ====== ======== ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 The year field is set with the most significant octet first. A value of 0 in the year indicates an unknown time stamp.')
cpqHeEventLogErrorDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogErrorDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogErrorDesc.setDescription('A text description of the event log entry.')
cpqHeEventLogFreeFormData = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 11, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeEventLogFreeFormData.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeEventLogFreeFormData.setDescription('This is the free form data associated with a particular event.')
cpqHeMgmtDisplayType = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("imd4x16", 3), ("ocp1x16", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeMgmtDisplayType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeMgmtDisplayType.setDescription('This value specifies the type of Management Display device. If a display device is available on the server, the type will be set accordingly. If no device is present, the value will be set to none(2).')
cpqHeMgmtDisplayText = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 12, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeMgmtDisplayText.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeMgmtDisplayText.setDescription('The text to be written to the Management display device. If this item is read, it may not accurately reflect what is currently displayed.')
cpqHeMgmtUID = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("ledOn", 3), ("ledOff", 4), ("ledBlinking", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeMgmtUID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeMgmtUID.setDescription('The Unit Identifier LED. This value will be one of the following: other(1) The state of the LED could not be determined. Setting the LED state is not allowed. none(2) The LED is not present. Setting LED state is not allowed. ledOn(3) The LED is present and ON. The LED can be turned Off or Blinking by setting the cpqHeMgmtUID to ledOff(4) or ledBlinking(5) respectively. ledOff(4) The LED is present and OFF. The LED can be turned On or Blinking by setting the cpqHeMgmtUID to ledOn(3) or ledBlinking(5) respectively. ledBlinking(5) The LED is present and is Blinking. The LED can be turned On or Off by setting the cpqHeMgmtUID to ledOn(3) or ledOff(4) respectively')
cpqHePowerConverterSupported = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("notSupported", 2), ("supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePowerConverterSupported.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerConverterSupported.setDescription('This value specifies if this system supports reporting power converter module information.')
cpqHePowerConverterCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePowerConverterCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerConverterCondition.setDescription('This value specifies the overall condition of the power converters modules in the system.')
cpqHePowerConverterTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3), )
if mibBuilder.loadTexts: cpqHePowerConverterTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerConverterTable.setDescription('A table of Power Converter Module Entries.')
cpqHePowerConverterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHePwrConvChassis"), (0, "CPQHLTH-MIB", "cpqHePwrConvIndex"))
if mibBuilder.loadTexts: cpqHePowerConverterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerConverterEntry.setDescription('A Power Converter Module Entry.')
cpqHePwrConvChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvChassis.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvChassis.setDescription('The system chassis number containing the power converter modules.')
cpqHePwrConvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvIndex.setDescription('The Power Converter Module number to index within the chassis.')
cpqHePwrConvPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("absent", 2), ("present", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvPresent.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvPresent.setDescription('This specifies if the Power Converter Module described is present in the system.')
cpqHePwrConvSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvSlot.setDescription('The Power Converter Module slot number within the chassis.')
cpqHePwrConvSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvSocket.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvSocket.setDescription('The Power Converter Module socket number within the slot.')
cpqHePwrConvRedundant = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonRedundant", 2), ("redundant", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvRedundant.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvRedundant.setDescription('This specifies if the Power Converter Module is redundant.')
cpqHePwrConvRedundantGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvRedundantGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvRedundantGroupId.setDescription('The Power Converter Module group id. A redundant set of power converters will have the same group id.')
cpqHePwrConvCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePwrConvCondition.setDescription('The Power Converter Module condition.')
cpqHePwrConvHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 13, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePwrConvHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHePwrConvHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the power converter. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeResilientMemTypeActive = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("onLineSpare", 3), ("mirrored", 4), ("advancedEcc", 5), ("mirroredSingleBoard", 6), ("mirroredDualBoard", 7), ("xor", 8), ("lockStep", 9), ("onLineSpareChannel", 10), ("onLineSpareRank", 11), ("mirroringIntrasocket", 12), ("mirroringIntersocket", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemTypeActive.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemTypeActive.setDescription('This value specifies the type of Advanced Memory Protection fault tolerance currently active on the system. The following connection states are supported: other(1) The Advanced Memory Protection fault tolerance cannot be determined by the Management Agent. You may need to upgrade your software. none(2) This system is not configured for Advanced Memory Protection fault tolerance or Advanced Memory Protection is not available on this system. onLineSpare(3) This system is configured for Online Spare Advanced Memory Protection. mirrored(4) This system is configured for Mirrored Advanced Memory Protection. advancedECC(5) This system is configured for the Advanced ECC type of Advanced Memory Protection. mirroredSingleBoard(6) This system is configured for Mirrored Advanced Memory Protection within a single memory board. mirroredDualBoard(7) This system is configured for Mirrored Advanced Memory Protection within a dual memory board configuration. The mirrored memory may be swapped with memory on the same memory board or with memory on the second memory board. xor(8) This system is configured for Advanced Memory Protection using the XOR engine. lockStep(9) This system is configured for LockStep type of Advanced Memory Protection. onLineSpareChannel(10) This system is configured for Online Spare Channel Advanced Memory Protection. onLineSpareRank(11) This system is configured for Online Spare Rank Advanced Memory Protection. mirroringIntrasocket(12) This system is configured for Mirrored Intrasocket Advanced Memory Protection between memory of single processor or board. mirroringIntersocket(13) This system is configured for Mirrored Intersocket Advanced Memory Protection between memory of two processors or boards.')
cpqHeResilientMemTypeAvailable = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemTypeAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemTypeAvailable.setDescription('This value specifies the type of Advanced Memory Protection Fault Tolerance available on the system. This is a collection of flags used to indicate the fault Advanced Memory Protection options available. This integer is a bitmap, with each bit indicating the availability of an option. If the bit is set to 1, the option is available; otherwise it is not. Multiple options are allowed. NOTE: bit 31 is the most significant bit, bit 0 is the least significant. Bit 31-11: RESERVED (0) Bit 10: Mirroring Intersocket Bit 9: Mirroring Intrasocket Bit 8: Online Rank Spare Bit 7: Online Channel Spare Bit 6: LockStep Bit 5: XOR Bit 4: Mirrored Memory with dual memory boards Bit 3: Mirrored Memory within a single memory board Bit 2: Advanced ECC Bit 1: Mirrored (deprecated) Bit 0: Online Spare')
cpqHeResilientMemStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("notProtected", 2), ("protected", 3), ("degraded", 4), ("dimmEcc", 5), ("mirrorNoFaults", 6), ("mirrorWithFaults", 7), ("hotSpareNoFaults", 8), ("hotSpareWithFaults", 9), ("xorNoFaults", 10), ("xorWithFaults", 11), ("advancedEcc", 12), ("advancedEccWithFaults", 13), ("lockStep", 14), ("lockStepWithFaults", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemStatus.setDescription('This value specifies the current state of the Advanced Memory Protection subsystem. The following states are supported: other(1) The system does not support Advanced Memory Protection or the status cannot be determined by the Management Agent. notProtected(2) This system supports Advanced Memory Protection but the feature is disabled. protected(3) The system is protected by Advanced Memory Protection. degraded(4) The system was protected, but the Advanced Memory Protection feature has been engaged. dimmEcc(5) The system is protected via DIMM ECC only. mirrorNoFaults(6) The system is protected by Advanced Memory Protection in the mirrored mode. No DIMM faults have been detected. mirrorWithFaults(7) The system is protected by Advanced Memory Protection in the mirrored mode. One or more DIMM faults have been detected. hotSpareNoFaults(8) The system is protected by Advanced Memory Protection in the hot spare mode. No DIMM faults have been detected. hotSpareWithFaults(9) The system is protected by Advanced Memory Protection in the hot spare mode. One or more DIMM faults have been detected. xorNoFaults(10) The system is protected by Advanced Memory Protection in the XOR memory mode. No DIMM faults have been detected. xorWithFaults(11) The system is protected by Advanced Memory Protection in the XOR memory mode. One or more DIMM faults have been detected. advancedEcc(12) The system is protected by Advanced Memory Protection in the Advanced ECC mode. advancedEccWithFaults(13) The system is protected by Advanced Memory Protection in the Advanced ECC mode. One or more DIMM faults have been detected. lockStep(14) The system is protected by Advanced Memory Protection in the Lock Step mode. localStepWithFaults(15) The system is protected by Advanced Memory Protection in the Lock Step mode. One or more DIMM faults have been detected.')
cpqHeResilientMemCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemCondition.setDescription('This value specifies the current condition of the Advanced Memory Protection subsystem. The following states are supported: other(1) The system does not support fault tolerant memory or the state cannot be determined by the Management Agent. ok(2) This system is operating normally. degraded(3) The system is running in a degraded state because the Advanced Memory Protection subsystem has been engaged.')
cpqHeResilientMemHotPlug = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonHotPluggable", 2), ("hotPluggable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemHotPlug.setDescription('This value specifies the current condition of the Advanced Memory Protection subsystem. The following states are supported: other(1) The state could not be determined or the system does not support Advanced Memory Protection. nonHotPluggable(2) The memory board or cartridge is not hot plug capable. hotPluggable(3) The memory board or cartridge is hot plug capable and can be removed if the system is operating in a redundant state. A memory board or cartridge may be added to an empty bay.')
cpqHeResilientMemOperatingSpeed = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemOperatingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemOperatingSpeed.setDescription('This value specifies the current operating speed of the Advanced Memory Protection subsystem in MHz. If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResilientMemOsMemSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemOsMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemOsMemSize.setDescription('This value specifies the size of memory as seen by the Operating System in MB (1 MB = 1048576 bytes). If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResilientMemTotalMemSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemTotalMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemTotalMemSize.setDescription('This value specifies the total size of memory including memory seen by the Operating System and the memory used for spare, mirrored, or RAID configurations in MB (1 MB = 1048576 bytes). If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResilientMemRivState = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("inactive", 2), ("rebuilding", 3), ("initializing", 4), ("verifying", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResilientMemRivState.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResilientMemRivState.setDescription('This value specifies the state of the Rebuild/Initialize/Verify (RIV) engine of the Advanced Memory Protection sub-system. The following states are supported: other(1) The system does not support Advanced Memory Protection or this value cannot be determined, inactive(2) The RIV engine is idle. rebuilding(3) The RIV engine is rebuilding the XOR data. initializing(4) The RIV engine is initializing memory. verifying(5) The RIV engine is verifying memory integrity.')
cpqHeResMemBoardTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10), )
if mibBuilder.loadTexts: cpqHeResMemBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardTable.setDescription('A table of memory board or cartridge descriptions in Advanced Memory Protection systems.')
cpqHeResMemBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeResMemBoardSlotIndex"))
if mibBuilder.loadTexts: cpqHeResMemBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardEntry.setDescription('A memory board or cartridge description.')
cpqHeResMemBoardSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardSlotIndex.setDescription('The slot in which the memory board or cartridge is installed.')
cpqHeResMemBoardOnlineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("present", 2), ("absent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardOnlineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardOnlineStatus.setDescription('The online status of the Advanced Memory Protection board or cartridge. The following status values are supported: other(1) The value is unsupported or could not be determined. present(2) The board or cartridge has memory and is currently online. absent(3) The board or cartridge is missing or offline.')
cpqHeResMemBoardErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("noError", 2), ("dimmEccError", 3), ("unlockError", 4), ("configError", 5), ("busError", 6), ("powerError", 7), ("advancedEcc", 8), ("onlineSpare", 9), ("mirrored", 10), ("mirroredDimmError", 11), ("memoryRaid", 12), ("raidDimmError", 13), ("lockstep", 14), ("lockstepDimmError", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardErrorStatus.setDescription('The error status of the Advanced Memory Protection board or cartridge. The following status values are supported: other(1) The value is unsupported or could not be determined. noError(2) The board or cartridge is configured and operating correctly. dimmEccError(3) The board or cartridge has at least one DIMM ECC error. unlockError(4) The board or cartridge is unlocked when it should not be. Please insure the board of cartridge is locked. configError(5) The board or cartridge has a bad memory configuration. Please insure all memory modules are of the correct type, speed, latency, etc. busError(6) The board or cartridge has a memory bus error. Please insure all memory modules are of the correct type, speed, latency, etc. Also insure the cartridge is inserted properly. powerError(7) The board or cartridge has power error. Please insure all memory modules are of the correct type, speed, latency, etc. Also insure the cartridge is inserted properly. advancedEcc(8), The board or cartridge is configured for advanced Ecc mode. onlineSpare(9), The board or cartridge is configured for Online Spare mode. mirrored(10), The board or cartridge is configured for mirrored mode. mirroredDimmError(11), The board or cartridge has a mirrored Dimm error. memoryRaid(12), The board or cartridge is configured for memory raid mode. raidDimmError(13) The board or cartridge has a raid Dimm error. lockstep(14) The board or cartridge is configured for LockStep. lockstepDimmError(15) The board or cartridge has a lockStep Dimm error.')
cpqHeResMemBoardLocked = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("unlocked", 2), ("locked", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardLocked.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardLocked.setDescription('The locked state of the Advanced Memory Protection board or cartridge. The following status values are supported: other(1) The value is unsupported or could not be determined. If the system does not support hot plugging of the board or cartridge, then this value will be returned. unlocked(2) The board or cartridge is currently unlocked and may be removed. locked(3) The board or cartridge is currently locked and may not be removed.')
cpqHeResMemBoardNumSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardNumSockets.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardNumSockets.setDescription('The total number of memory sockets for this memory board or cartridge. If this value could not be determined, or if the board or cartridge has been removed, this value will be -1.')
cpqHeResMemBoardOsMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardOsMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardOsMemSize.setDescription('This value specifies the size of memory for this board or cartridge as seen by the Operating System in MB (1 MB = 1048576 bytes). If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResMemBoardTotalMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardTotalMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardTotalMemSize.setDescription('This value specifies the size of memory for this board or cartridge including memory seen by the Operating System and the memory used for spare, mirrored, or XOR configurations in MB (1 MB = 1048576 bytes). If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResMemBoardCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardCondition.setDescription('This provides the current status of the Advanced Memory Protection memory board or cartridge. The following status values are supported: other(1): The condition of this memory board or cartridge could not be determined. ok(2): The memory board or cartridge is operating normally. degraded(3): The memory board or cartridge is in an error state. Check for correct memory installation and that the board has been inserted properly.')
cpqHeResMemBoardHotPlug = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonHotPluggable", 2), ("hotPluggable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardHotPlug.setDescription('This indicates if the memory board is capable of being removed and/or inserted while the system is in an operational state. The following states are supported: other(1) The state could not be determined or the system does not support Advanced Memory Protection. nonHotPluggable(2) The memory board or cartridge is not hot plug capable. hotPluggable(3) The memory board or cartridge is hot plug capable and can be removed if the system is operating in a redundant state. A memory board or cartridge may be added to an empty bay.')
cpqHeResMemModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11), )
if mibBuilder.loadTexts: cpqHeResMemModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleTable.setDescription('A table of memory module descriptions.')
cpqHeResMemModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeResMemBoardIndex"), (0, "CPQHLTH-MIB", "cpqHeResMemModuleIndex"))
if mibBuilder.loadTexts: cpqHeResMemModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleEntry.setDescription('A memory module description.')
cpqHeResMemBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemBoardIndex.setDescription('The slot in which the memory board or cartridge is installed. A value of 0 indicates memory installed directly on the system board.')
cpqHeResMemModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleIndex.setDescription('The memory module number.')
cpqHeResMemModuleSparePartNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemModuleSparePartNo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleSparePartNo.setDescription("The memory module's manufacturer part number. This field will be a null (size 0) string if the manufacturer part number is not available.")
cpqHeResMemModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("notPresent", 2), ("present", 3), ("good", 4), ("add", 5), ("upgrade", 6), ("missing", 7), ("doesNotMatch", 8), ("notSupported", 9), ("badConfig", 10), ("degraded", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemModuleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleStatus.setDescription("This provides the current status of the correctable memory errors for this memory module. The following status values are supported: other(1): The status is unknown or could not be determined. notPresent(2): The memory module is not present or is un-initialized. present(3): The memory module is present but not in use. good(4): The memory module is present and in use. The corrected error threshold has not been exceeded. add(5): The memory module has been added, but is not yet in use. upgraded(6): The memory module has been upgraded, but the memory is not yet in use. missing(7): An expected memory module is missing. doesNotMatch(8): The memory module does not match the other memory modules within the bank. notSupported(9): The memory module is not supported. badConfig(10): The memory module violates the add/upgrade configuration rules. degraded(11): The memory module's correctable error count has exceeded threshold.")
cpqHeResMemModuleCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemModuleCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleCondition.setDescription('This provides the current status of the correctable memory errors for this memory module. The following status values are supported: other(1): ECC is not supported on this memory module or the condition could not be determined. ok(2): The memory module is operating normally. degraded(3): The memory module is correctable error count has exceeded threshold or a configuration error has been detected.')
cpqHeResMemModuleSpd = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMemModuleSpd.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMemModuleSpd.setDescription('This is the raw Serial Presence Detect information contained in the memory module. If the SPD information is not available, this item will be empty.')
cpqHeResMem2BoardTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12), )
if mibBuilder.loadTexts: cpqHeResMem2BoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardTable.setDescription('A table of memory board or cartridge descriptions in Advanced Memory Protection systems.')
cpqHeResMem2BoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeResMem2BoardIndex"))
if mibBuilder.loadTexts: cpqHeResMem2BoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardEntry.setDescription('A memory board or cartridge or CPU based Memory Board description.')
cpqHeResMem2BoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardIndex.setDescription('This will represent the unique memory board or cartridge or riser.')
cpqHeResMem2BoardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardSlotNum.setDescription('The slot in which the memory board or cartridge is installed.')
cpqHeResMem2BoardCpuNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardCpuNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardCpuNum.setDescription('The Processor Number to which the memory Riser belongs. Value 0 means memory is not CPU based.')
cpqHeResMem2BoardRiserNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardRiserNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardRiserNum.setDescription('The Riser Number on the Processor.')
cpqHeResMem2BoardOnlineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("present", 2), ("absent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardOnlineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardOnlineStatus.setDescription('The online status of the Advanced Memory Protection board or cartridge or riser. The following status values are supported: other(1) The value is unsupported or could not be determined. present(2) The board or cartridge or riser has memory and is currently online. absent(3) The board or cartridge or riser is missing or offline.')
cpqHeResMem2BoardErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("noError", 2), ("dimmEccError", 3), ("unlockError", 4), ("configError", 5), ("busError", 6), ("powerError", 7), ("advancedEcc", 8), ("onlineSpare", 9), ("mirrored", 10), ("mirroredDimmError", 11), ("memoryRaid", 12), ("raidDimmError", 13), ("lockStep", 14), ("lockStepError", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardErrorStatus.setDescription('The error status of the Advanced Memory Protection board or Cartridge or riser. The following status values are supported: other(1) The value is unsupported or could not be determined. noError(2) The board or cartridge or riser is configured and operating correctly. dimmEccError(3) The board or cartridge or riser has at least one DIMM ECC error. unlockError(4) The board or cartridge or riser is unlocked when it should not be. Please insure the board of cartridge is locked. configError(5) The board or cartridge or riser has a bad memory configuration. Please insure all memory modules are of the correct type, speed, latency, etc. busError(6) The board or cartridge or riser has a memory bus error. Please insure all memory modules are of the correct type, speed, latency, etc. Also insure the cartridge is inserted properly. powerError(7) The board or cartridge or riser has power error. Please insure all memory modules are of the correct type, speed, latency, etc. Also insure the cartridge is inserted properly. advancedEcc(8), The board or cartridge or riser is configured for advanced Ecc mode. onlineSpare(9), The board or cartridge or riser is configured for Online Spare mode. mirrored(10), The board or cartridge or riser is configured for mirrored mode. mirroredDimmError(11), The board or cartridge or riser has a mirrored Dimm error. memoryRaid(12), The board or cartridge or riser is configured for memory raid mode. raidDimmError(13) The board or cartridge or riser has a raid Dimm error. lockStep(14), The board or cartridge or riser is configured for lockStep mode. lockStepError(15) The board or cartridge or riser has a lockStep Dimm error.')
cpqHeResMem2BoardLocked = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("unlocked", 2), ("locked", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardLocked.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardLocked.setDescription('The locked state of the Advanced Memory Protection board or Cartridge or riser. The following status values are supported: other(1) The value is unsupported or could not be determined. If the system does not support hot plugging of the board or cartridge or riser, then this value will be returned. unlocked(2) The board or cartridge or riser is currently unlocked and may be removed. locked(3) The board or cartridge or riser is currently locked and may not be removed.')
cpqHeResMem2BoardNumSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardNumSockets.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardNumSockets.setDescription('The total number of memory sockets for this memory board or Cartridge or riser. If this value could not be determined, or if the board or Cartridge or riser has been removed, this value will be -1.')
cpqHeResMem2BoardOsMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardOsMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardOsMemSize.setDescription('This value specifies the size of memory for this board or cartridge or riser as seen by the Operating System in MB (1 MB = 1048576 bytes). If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResMem2BoardTotalMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardTotalMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardTotalMemSize.setDescription('This value specifies the size of memory for this board or Cartridge or riser including memory seen by the Operating System and the memory used for spare, mirrored, or XOR configurations in MB (1 MB = 1048576 bytes). If this system does not support Advanced Memory Protection or this value cannot be determined, then a value of 0 will be returned.')
cpqHeResMem2BoardCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardCondition.setDescription('This provides the current status of the Advanced Memory Protection memory board or cartridge or riser. The following status values are supported: other(1): The condition of this memory board or cartridge or riser could not be determined. ok(2): The memory board or cartridge or riser is operating normally. degraded(3): The memory board or cartridge or riser is in an error state. Check for correct memory installation and that the board has been inserted properly.')
cpqHeResMem2BoardHotPlug = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("nonHotPluggable", 2), ("hotPluggable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardHotPlug.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardHotPlug.setDescription('This indicates if the memory board is capable of being removed and/or inserted while the system is in an operational state. The following states are supported: other(1) The state could not be determined or the system does not support Advanced Memory Protection. nonHotPluggable(2) The memory board or cartridge or riser is not hot plug capable. hotPluggable(3) The memory board or cartridge or riser is hot plug capable and can be removed if the system is operating in a redundant state. A memory board or cartridge or riser may be added to an empty bay.')
cpqHeResMem2BoardOperatingFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardOperatingFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardOperatingFrequency.setDescription('This value specifies the operational memory frequency for this board or Cartridge or riser in MHz.')
cpqHeResMem2BoardOperatingVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 12, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardOperatingVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardOperatingVoltage.setDescription('This value specifies the operational memory voltage for this board or Cartridge or riser in millivolts.')
cpqHeResMem2ModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13), )
if mibBuilder.loadTexts: cpqHeResMem2ModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleTable.setDescription('A table of memory module descriptions.')
cpqHeResMem2ModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeResMem2Module"))
if mibBuilder.loadTexts: cpqHeResMem2ModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleEntry.setDescription('A memory module description.')
cpqHeResMem2Module = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2Module.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2Module.setDescription('This will represent the unique memory DIMM on memory board or cartridge or riser. ')
cpqHeResMem2BoardNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2BoardNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2BoardNum.setDescription('The slot in which the memory board or cartridge is installed. A value of 0 indicates memory installed directly on the system board.')
cpqHeResMem2CpuNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2CpuNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2CpuNum.setDescription('The memory module CPU number. Value 0 means memory is not Processor based.')
cpqHeResMem2RiserNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2RiserNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2RiserNum.setDescription('The memory module rasier number.')
cpqHeResMem2ModuleNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleNum.setDescription('The memory module number.')
cpqHeResMem2ModuleSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleSize.setDescription('Module memory size in kilobytes. A kilobyte of memory is defined as 1024 bytes. A size of 0 indicates the module is not present.')
cpqHeResMem2ModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("other", 1), ("board", 2), ("cpqSingleWidthModule", 3), ("cpqDoubleWidthModule", 4), ("simm", 5), ("pcmcia", 6), ("compaq-specific", 7), ("dimm", 8), ("smallOutlineDimm", 9), ("rimm", 10), ("srimm", 11), ("fb-dimm", 12), ("dimmddr", 13), ("dimmddr2", 14), ("dimmddr3", 15), ("dimmfbd2", 16), ("fb-dimmddr2", 17), ("fb-dimmddr3", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleType.setDescription('Type of memory module installed. The value other(1) will be given if the type is not known. The value board(2) will be given if the memory module is permanently mounted (not modular) on a system board or memory expansion board.')
cpqHeResMem2ModuleTechnology = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("fastPageMode", 2), ("edoPageMode", 3), ("burstEdoPageMode", 4), ("synchronous", 5), ("rdram", 6), ("rdimm", 7), ("udimm", 8), ("lrdimm", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleTechnology.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleTechnology.setDescription('Technology type of memory module installed. The value other(1) will be given if the technology is not known.')
cpqHeResMem2ModuleManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleManufacturer.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleManufacturer.setDescription("The memory module's manufacturer name. This field will be a null (size 0) string if the manufacturer name is not available.")
cpqHeResMem2ModulePartNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModulePartNo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModulePartNo.setDescription("The memory module's manufacturer part number. This field will be a null (size 0) string if the manufacturer part number is not available.")
cpqHeResMem2ModuleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleDate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleDate.setDescription('The memory module date of manufacture. field octets contents range ===== ====== ====================== ======== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 6 7 second 0..60 (use 60 for leap-second) This field will be set to year = 0 if the date of manufacture is not available. The hour, minute, and second fields will always be set to 0.')
cpqHeResMem2ModuleSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqHeResMem2ModuleSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleSerialNo.setDescription("The memory module's serial number. This field will be a null (size 0) string if the serial number is not available.")
cpqHeResMem2ModuleHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqHeResMem2ModuleHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the memory module. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqHeResMem2ModuleFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleFrequency.setDescription('The memory module maximum frequency in MHz. The value zero (0) will be given if the module frequency cannot be determined.')
cpqHeResMem2ModuleCellTablePtr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleCellTablePtr.setStatus('optional')
if mibBuilder.loadTexts: cpqHeResMem2ModuleCellTablePtr.setDescription('Index for the cell in cpqSeCellTable where the memory board is installed.')
cpqHeResMem2ModuleCellStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("deconfigured", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleCellStatus.setStatus('optional')
if mibBuilder.loadTexts: cpqHeResMem2ModuleCellStatus.setDescription('This provides the current status for this memory module. The following status values are supported: other(1): The memory module status is not available ok(2): The memory module is active deconfigured(3): The memory module is not ready')
cpqHeResMem2ModulePartNoMfgr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModulePartNoMfgr.setStatus('optional')
if mibBuilder.loadTexts: cpqHeResMem2ModulePartNoMfgr.setDescription("The memory module's manufacturer's part number. This field will be a null (size 0) string if the manufacturer part number is not available.")
cpqHeResMem2ModuleSerialNoMfgr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleSerialNoMfgr.setStatus('optional')
if mibBuilder.loadTexts: cpqHeResMem2ModuleSerialNoMfgr.setDescription("The memory module's manufacturer's serial number. This field will be a null (size 0) string if the manufacturer serial number is not available.")
cpqHeResMem2ModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("other", 1), ("notPresent", 2), ("present", 3), ("good", 4), ("add", 5), ("upgrade", 6), ("missing", 7), ("doesNotMatch", 8), ("notSupported", 9), ("badConfig", 10), ("degraded", 11), ("spare", 12), ("partial", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleStatus.setDescription("This provides the current status of the correctable memory errors for this memory module. The following status values are supported: other(1): The status is unknown or could not be determined. notPresent(2): The memory module is not present or is un-initialized. present(3): The memory module is present but not in use. good(4): The memory module is present and in use. The corrected error threshold has not been exceeded. add(5): The memory module has been added, but is not yet in use. upgraded(6): The memory module has been upgraded, but the memory is not yet in use. missing(7): An expected memory module is missing. doesNotMatch(8): The memory module does not match the other memory modules within the bank. notSupported(9): The memory module is not supported. badConfig(10): The memory module violates the add/upgrade configuration rules. degraded(11): The memory module's correctable error count has exceeded threshold. spare(12): The memory module is configured as a spare. partial(13): The memory module is present and is partially in use.")
cpqHeResMem2ModuleCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("degradedModuleIndexUnknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleCondition.setDescription('This provides the current status of the correctable memory errors for this memory module. The following status values are supported: other(1): ECC is not supported on this memory module or the condition could not be determined. ok(2): The memory module is operating normally. degraded(3): The memory module is correctable error count has exceeded threshold or a configuration error has been detected. degradedModuleIndexUnknown(4): The correctable error count has exceeded threshold. The module number not available.')
cpqHeResMem2ModuleSpd = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleSpd.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleSpd.setDescription('This is the raw Serial Presence Detect information contained in the memory module. If the SPD information is not available, this item will be empty.')
cpqHeResMem2ModuleSmartMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("notHPSmartMemory", 2), ("isHPSmartMemory", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleSmartMemory.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleSmartMemory.setDescription('This indicates whether the DIMM slot is populated with an HP Smart Memory DIMM. The following values are supported: other(1): HP SmartMemory not supported in this device. notHPSmartMemory(2): HP SmartMemory is NOT installed in DIMM slot (includes the case where the DIMM slot is not populated). isHPSmartMemory(3): HP SmartMemory is installed in DIMM slot.')
cpqHeResMem2ModuleMinVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleMinVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleMinVoltage.setDescription('This provides the minimum voltage needed for the module to operate, in millivolts.')
cpqHeResMem2ModuleRanks = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 2, 14, 13, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeResMem2ModuleRanks.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHeResMem2ModuleRanks.setDescription('This provides the number of physical ranks on the module.')
cpqHePowerMeterSupport = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("supported", 2), ("unsupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePowerMeterSupport.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerMeterSupport.setDescription('This value specifies whether Power Meter is supported by this Server . The following values are supported: other(1) Could not read the Power Meter status. supported(2) This system support Power Meter. unsupported(3) This system does not support Power Meter.')
cpqHePowerMeterStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("present", 2), ("absent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePowerMeterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerMeterStatus.setDescription('This value specifies whether Power Meter reading is supported by this Server . The following values are supported: other(1) Could not read the Power Meter status. present(2) The Power Meter data is available. absent(3) The Power Meter data is not available at this time.')
cpqHePowerMeterCurrReading = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 15, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePowerMeterCurrReading.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerMeterCurrReading.setDescription(' This is the current Power Meter reading in Watts. This value shows the most recent power reading if available. On systems without Power Meter support, this value will be -1.')
cpqHePowerMeterPrevReading = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 2, 15, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHePowerMeterPrevReading.setStatus('mandatory')
if mibBuilder.loadTexts: cpqHePowerMeterPrevReading.setDescription(' This is the previous Power Meter reading in Watts. This value shows previous power reading if available. On systems without Power Meter support, this value will be -1.')
cpqHeTrapPkts = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTrapPkts.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapPkts.setDescription('The total number of SNMP trap packets issued by the Server Health agent.')
cpqHeTrapLogMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 6, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTrapLogMaxSize.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapLogMaxSize.setDescription('The maximum number of entries that will currently be kept in the trap log. If the maximum size has been reached and a new trap occurs the oldest trap will be removed.')
cpqHeTrapLogTable = MibTable((1, 3, 6, 1, 4, 1, 232, 6, 3, 3), )
if mibBuilder.loadTexts: cpqHeTrapLogTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapLogTable.setDescription('An ordered list of trap log entries (conceptually a queue). The trap log entries will be kept in the order in which they were generated with the most recent trap at index 1 and the oldest trap entry at index trapLogMaxSize. If the maximum number of entries has been reached and a new trap occurs the oldest trap will be removed when the new trap is added so the trapMaxLogSize is not exceeded.')
cpqHeTrapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 6, 3, 3, 1), ).setIndexNames((0, "CPQHLTH-MIB", "cpqHeTrapLogIndex"))
if mibBuilder.loadTexts: cpqHeTrapLogEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapLogEntry.setDescription('A description of a trap event.')
cpqHeTrapLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTrapLogIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapLogIndex.setDescription("The value of this object uniquely identifies this trapLogEntry at this time. The most recent trap will have an index of 1 and the oldest trap will have an index of trapLogMaxSize. Because of the queue-like nature of the trapLog this particular trap event's index will change as new traps are issued.")
cpqHeTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, 6011, 6012, 6013))).clone(namedValues=NamedValues(("cpqHeCorrectableMemoryError", 1), ("cpqHeCorrectableMemoryLogDisabled", 2), ("cpqHe2CorrectableMemoryError", 6001), ("cpqHe2CorrectableMemoryLogDisabled", 6002), ("cpqHeThermalTempFailed", 6003), ("cpqHeThermalTempDegraded", 6004), ("cpqHeThermalTempOk", 6005), ("cpqHeThermalSystemFanFailed", 6006), ("cpqHeThermalSystemFanDegraded", 6007), ("cpqHeThermalSystemFanOk", 6008), ("cpqHeThermalCpuFanFailed", 6009), ("cpqHeThermalCpuFanOk", 6010), ("cpqHeAsrConfirmation", 6011), ("cpqHeThermalConfirmation", 6012), ("cpqHePostError", 6013)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTrapType.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapType.setDescription('The type of the trap event this entry describes. This number refers to an entry in a list of traps enumerating the possible traps the Server Health agent may issue.')
cpqHeTrapTime = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 6, 3, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqHeTrapTime.setStatus('deprecated')
if mibBuilder.loadTexts: cpqHeTrapTime.setDescription('The time of the trap event that this entry describes. The time is given in year (first octet), month, day of month, hour, minute, second (last octet) order. The octets are in Binary Coded Decimal (BCD).')
cpqHeCorrectableMemoryError = NotificationType((1, 3, 6, 1, 4, 1, 232, 6) + (0,1)).setObjects(("CPQHLTH-MIB", "cpqHeCorrMemTotalErrs"))
if mibBuilder.loadTexts: cpqHeCorrectableMemoryError.setDescription('A correctable memory error occurred. The error has been corrected. The current number of correctable memory errors is reported in the variable cpqHeCorrMemTotalErrs.')
cpqHeCorrectableMemoryLogDisabled = NotificationType((1, 3, 6, 1, 4, 1, 232, 6) + (0,2)).setObjects(("CPQHLTH-MIB", "cpqHeCorrMemLogStatus"))
if mibBuilder.loadTexts: cpqHeCorrectableMemoryLogDisabled.setDescription('Correctable memory error tracking disabled. The frequency of errors is so high that the error tracking logic has been temporarily disabled. The cpqHeCorrMemLogStatus variable indicated the current tracking status.')
cpqHe2CorrectableMemoryError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6001)).setObjects(("CPQHLTH-MIB", "cpqHeCorrMemTotalErrs"))
if mibBuilder.loadTexts: cpqHe2CorrectableMemoryError.setDescription('A correctable memory error occurred. The error has been corrected. The current number of correctable memory errors is reported in the variable cpqHeCorrMemTotalErrs.')
cpqHe2CorrectableMemoryLogDisabled = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6002)).setObjects(("CPQHLTH-MIB", "cpqHeCorrMemLogStatus"))
if mibBuilder.loadTexts: cpqHe2CorrectableMemoryLogDisabled.setDescription('Correctable memory error tracking disabled. The frequency of errors is so high that the error tracking logic has been temporarily disabled. The cpqHeCorrMemLogStatus variable indicated the current tracking status.')
cpqHeThermalTempFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6003))
if mibBuilder.loadTexts: cpqHeThermalTempFailed.setDescription('The temperature status has been set to failed. The system will be shutdown due to this thermal condition.')
cpqHeThermalTempDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6004)).setObjects(("CPQHLTH-MIB", "cpqHeThermalDegradedAction"))
if mibBuilder.loadTexts: cpqHeThermalTempDegraded.setDescription("The temperature status has been set to degraded. The server's temperature is outside of the normal operating range. The server will be shutdown if the cpqHeThermalDegradedAction variable is set to shutdown(3).")
cpqHeThermalTempOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6005))
if mibBuilder.loadTexts: cpqHeThermalTempOk.setDescription("The temperature status has been set to ok. The server's temperature has returned to the normal operating range.")
cpqHeThermalSystemFanFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6006)).setObjects(("CPQHLTH-MIB", "cpqHeThermalDegradedAction"))
if mibBuilder.loadTexts: cpqHeThermalSystemFanFailed.setDescription('The system fan status has been set to failed. A required system fan is not operating normally. The system will be shutdown if the cpqHeThermalDegradedAction variable is set to shutdown(3).')
cpqHeThermalSystemFanDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6007))
if mibBuilder.loadTexts: cpqHeThermalSystemFanDegraded.setDescription('The system fan status has been set to degraded. An optional system fan is not operating normally.')
cpqHeThermalSystemFanOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6008))
if mibBuilder.loadTexts: cpqHeThermalSystemFanOk.setDescription('The system fan status has been set to ok. Any previously non-operational system fans have returned to normal operation.')
cpqHeThermalCpuFanFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6009))
if mibBuilder.loadTexts: cpqHeThermalCpuFanFailed.setDescription('The CPU fan status has been set to failed. A processor fan is not operating normally. The server will be shutdown.')
cpqHeThermalCpuFanOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6010))
if mibBuilder.loadTexts: cpqHeThermalCpuFanOk.setDescription('The CPU fan status has been set to ok. Any previously non-operational processor fans have returned to normal operation.')
cpqHeAsrConfirmation = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6011))
if mibBuilder.loadTexts: cpqHeAsrConfirmation.setDescription('The server is operational again. The server has previously been shutdown by the Automatic Server Recovery (ASR) feature and has just become operational again.')
cpqHeThermalConfirmation = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6012))
if mibBuilder.loadTexts: cpqHeThermalConfirmation.setDescription('The server is operational again. The server has previously been shutdown due to a thermal anomaly on the server and has just become operational again.')
cpqHePostError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6013))
if mibBuilder.loadTexts: cpqHePostError.setDescription('One or more POST errors occurred. Power On Self-Test (POST) errors occur during the server restart process. ')
cpqHeFltTolPwrSupplyDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6014))
if mibBuilder.loadTexts: cpqHeFltTolPwrSupplyDegraded.setDescription('The fault tolerant power supply sub-system condition has been set to degraded.')
cpqHe3CorrectableMemoryError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6015)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeCorrMemTotalErrs"))
if mibBuilder.loadTexts: cpqHe3CorrectableMemoryError.setDescription('A correctable memory error occurred. The error has been corrected. The current number of correctable memory errors is reported in the variable cpqHeCorrMemTotalErrs.')
cpqHe3CorrectableMemoryLogDisabled = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6016)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeCorrMemLogStatus"))
if mibBuilder.loadTexts: cpqHe3CorrectableMemoryLogDisabled.setDescription('Correctable memory error tracking disabled. The frequency of errors is so high that the error tracking logic has been temporarily disabled. The cpqHeCorrMemLogStatus variable indicated the current tracking status.')
cpqHe3ThermalTempFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6017)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalTempFailed.setDescription('The temperature status has been set to failed. The system will be shutdown due to this thermal condition.')
cpqHe3ThermalTempDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6018)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeThermalDegradedAction"))
if mibBuilder.loadTexts: cpqHe3ThermalTempDegraded.setDescription("The temperature status has been set to degraded. The server's temperature is outside of the normal operating range. The server will be shutdown if the cpqHeThermalDegradedAction variable is set to shutdown(3).")
cpqHe3ThermalTempOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6019)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalTempOk.setDescription("The temperature status has been set to ok. The server's temperature has returned to the normal operating range.")
cpqHe3ThermalSystemFanFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6020)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeThermalDegradedAction"))
if mibBuilder.loadTexts: cpqHe3ThermalSystemFanFailed.setDescription('The system fan status has been set to failed. A required system fan is not operating normally. The system will be shutdown if the cpqHeThermalDegradedAction variable is set to shutdown(3).')
cpqHe3ThermalSystemFanDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6021)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalSystemFanDegraded.setDescription('The system fan status has been set to degraded. An optional system fan is not operating normally.')
cpqHe3ThermalSystemFanOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6022)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalSystemFanOk.setDescription('The system fan status has been set to ok. Any previously non-operational system fans have returned to normal operation.')
cpqHe3ThermalCpuFanFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6023)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalCpuFanFailed.setDescription('The CPU fan status has been set to failed. A processor fan is not operating normally. The server will be shutdown.')
cpqHe3ThermalCpuFanOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6024)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalCpuFanOk.setDescription('The CPU fan status has been set to ok. Any previously non-operational processor fans have returned to normal operation.')
cpqHe3AsrConfirmation = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6025)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3AsrConfirmation.setDescription('The server is operational again. The server has previously been shutdown by the Automatic Server Recovery (ASR) feature and has just become operational again.')
cpqHe3ThermalConfirmation = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6026)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3ThermalConfirmation.setDescription('The server is operational again. The server has previously been shutdown due to a thermal anomaly on the server and has just become operational again.')
cpqHe3PostError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6027)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3PostError.setDescription('One or more POST errors occurred. Power On Self-Test (POST) errors occur during the server restart process. Details of the POST error messages can be found in Integrated Management Log ')
cpqHe3FltTolPwrSupplyDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6028)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3FltTolPwrSupplyDegraded.setDescription('The fault tolerant power supply sub-system condition has been set to degraded.')
cpqHe3CorrMemReplaceMemModule = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6029)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3CorrMemReplaceMemModule.setDescription('A correctable memory log entry indicates a memory module needs to be replaced. The errors have been corrected, but the memory module should be replaced. The error information is reported in the variable cpqHeCorrMemErrDesc.')
cpqHe3FltTolPowerSupplyDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6030)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"))
if mibBuilder.loadTexts: cpqHe3FltTolPowerSupplyDegraded.setDescription('The fault tolerant power supply condition has been set to degraded for the specified chassis and bay location.')
cpqHe3FltTolPowerSupplyFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6031)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"))
if mibBuilder.loadTexts: cpqHe3FltTolPowerSupplyFailed.setDescription('The fault tolerant power supply condition has been set to failed for the specified chassis and bay location.')
cpqHe3FltTolPowerRedundancyLost = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6032)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"))
if mibBuilder.loadTexts: cpqHe3FltTolPowerRedundancyLost.setDescription('The Fault Tolerant Power Supplies have lost redundancy for the specified chassis.')
cpqHe3FltTolPowerSupplyInserted = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6033)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"))
if mibBuilder.loadTexts: cpqHe3FltTolPowerSupplyInserted.setDescription('A Fault Tolerant Power Supply has been inserted into the specified chassis and bay location.')
cpqHe3FltTolPowerSupplyRemoved = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6034)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"))
if mibBuilder.loadTexts: cpqHe3FltTolPowerSupplyRemoved.setDescription('A Fault Tolerant Power Supply has been removed from the specified chassis and bay location.')
cpqHe3FltTolFanDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6035)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolFanChassis"), ("CPQHLTH-MIB", "cpqHeFltTolFanIndex"))
if mibBuilder.loadTexts: cpqHe3FltTolFanDegraded.setDescription('The Fault Tolerant Fan condition has been set to degraded for the specified chassis and fan.')
cpqHe3FltTolFanFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6036)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolFanChassis"), ("CPQHLTH-MIB", "cpqHeFltTolFanIndex"))
if mibBuilder.loadTexts: cpqHe3FltTolFanFailed.setDescription('The Fault Tolerant Fan condition has been set to failed for the specified chassis and fan.')
cpqHe3FltTolFanRedundancyLost = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6037)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolFanChassis"))
if mibBuilder.loadTexts: cpqHe3FltTolFanRedundancyLost.setDescription('The Fault Tolerant Fans have lost redundancy for the specified chassis.')
cpqHe3FltTolFanInserted = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6038)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolFanChassis"), ("CPQHLTH-MIB", "cpqHeFltTolFanIndex"))
if mibBuilder.loadTexts: cpqHe3FltTolFanInserted.setDescription('A Fault Tolerant Fan has been inserted into the specified chassis and fan location.')
cpqHe3FltTolFanRemoved = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6039)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolFanChassis"), ("CPQHLTH-MIB", "cpqHeFltTolFanIndex"))
if mibBuilder.loadTexts: cpqHe3FltTolFanRemoved.setDescription('A Fault Tolerant Fan has been removed from the specified chassis and fan location.')
cpqHe3TemperatureFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6040)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeTemperatureChassis"), ("CPQHLTH-MIB", "cpqHeTemperatureLocale"))
if mibBuilder.loadTexts: cpqHe3TemperatureFailed.setDescription('The temperature status has been set to failed in the specified chassis and location. The system will be shutdown due to this condition.')
cpqHe3TemperatureDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6041)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeThermalDegradedAction"), ("CPQHLTH-MIB", "cpqHeTemperatureChassis"), ("CPQHLTH-MIB", "cpqHeTemperatureLocale"))
if mibBuilder.loadTexts: cpqHe3TemperatureDegraded.setDescription("The temperature status has been set to degraded in the specified chassis and location. The server's temperature is outside of the normal operating range. The server will be shutdown if the cpqHeThermalDegradedAction variable is set to shutdown(3).")
cpqHe3TemperatureOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6042)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeTemperatureChassis"), ("CPQHLTH-MIB", "cpqHeTemperatureLocale"))
if mibBuilder.loadTexts: cpqHe3TemperatureOk.setDescription("The temperature status has been set to ok in the specified chassis and location. The server's temperature has returned to the normal operating range.")
cpqHe3PowerConverterDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6043)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHePwrConvChassis"), ("CPQHLTH-MIB", "cpqHePwrConvSlot"), ("CPQHLTH-MIB", "cpqHePwrConvSocket"))
if mibBuilder.loadTexts: cpqHe3PowerConverterDegraded.setDescription('The DC-DC Power Converter condition has been set to degraded for the specified chassis, slot and socket.')
cpqHe3PowerConverterFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6044)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHePwrConvChassis"), ("CPQHLTH-MIB", "cpqHePwrConvSlot"), ("CPQHLTH-MIB", "cpqHePwrConvSocket"))
if mibBuilder.loadTexts: cpqHe3PowerConverterFailed.setDescription('The DC-DC Power Converter condition has been set to failed for the specified chassis, slot and socket.')
cpqHe3PowerConverterRedundancyLost = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6045)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHePwrConvChassis"))
if mibBuilder.loadTexts: cpqHe3PowerConverterRedundancyLost.setDescription('The DC-DC Power Converters have lost redundancy for the specified chassis.')
cpqHe3CacheAccelParityError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6046)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHe3CacheAccelParityError.setDescription('A cache accelerator parity error indicates a cache module needs to be replaced. The error information is reported in the variable cpqHeEventLogErrorDesc.')
cpqHeResilientMemOnlineSpareEngaged = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6047)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeResilientMemOnlineSpareEngaged.setDescription('Advanced Memory Protection Online Spare Engaged. The Advanced Memory Protection subsystem has detected a memory fault. The Online Spare Memory has been activated. User Action: Schedule server down-time to replace the faulty memory.')
cpqHe4FltTolPowerSupplyOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6048)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyStatus"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyModel"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySerialNumber"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyAutoRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyFirmwareRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySparePartNum"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqHe4FltTolPowerSupplyOk.setDescription('The fault tolerant power supply condition has been set back to the OK state for the specified chassis and bay location.')
cpqHe4FltTolPowerSupplyDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6049)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyStatus"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyModel"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySerialNumber"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyAutoRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyFirmwareRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySparePartNum"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqHe4FltTolPowerSupplyDegraded.setDescription('The fault tolerant power supply condition has been set to degraded for the specified chassis and bay location.')
cpqHe4FltTolPowerSupplyFailed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6050)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyStatus"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyModel"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySerialNumber"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyAutoRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyFirmwareRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySparePartNum"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqHe4FltTolPowerSupplyFailed.setDescription('The fault tolerant power supply condition has been set to failed for the specified chassis and bay location.')
cpqHeResilientMemMirroredMemoryEngaged = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6051)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeResilientMemMirroredMemoryEngaged.setDescription('Advanced Memory Protection Mirrored Memory Engaged. The Advanced Memory Protection subsystem has detected a memory fault. Mirrored Memory has been activated. User Action: Replace the faulty memory.')
cpqHeResilientAdvancedECCMemoryEngaged = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6052)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeResilientAdvancedECCMemoryEngaged.setDescription('Advanced Memory Protection Advanced ECC Memory Engaged. The Advanced Memory Protection subsystem has detected a memory fault. Advanced ECC has been activated. User Action: Replace the faulty memory.')
cpqHeResilientMemXorMemoryEngaged = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6053)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeResilientMemXorMemoryEngaged.setDescription('Advanced Memory Protection XOR Engine Memory Engaged. The Advanced Memory Protection subsystem has detected a memory fault. The XOR engine has been activated. User Action: Replace the faulty memory.')
cpqHe3FltTolPowerRedundancyRestored = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6054)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"))
if mibBuilder.loadTexts: cpqHe3FltTolPowerRedundancyRestored.setDescription('The Fault Tolerant Power Supplies have returned to a redundant state for the specified chassis.')
cpqHe3FltTolFanRedundancyRestored = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6055)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolFanChassis"))
if mibBuilder.loadTexts: cpqHe3FltTolFanRedundancyRestored.setDescription('The Fault Tolerant Fans have returned to a redundant state for the specified chassis.')
cpqHe4CorrMemReplaceMemModule = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6056)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMemBoardIndex"), ("CPQHLTH-MIB", "cpqHeResMemModuleIndex"), ("CPQHLTH-MIB", "cpqHeResMemModuleSparePartNo"), ("CPQSINFO-MIB", "cpqSiMemModuleSize"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqHe4CorrMemReplaceMemModule.setDescription('Corrected Memory Errors Detected The errors have been corrected, but the memory module should be replaced.')
cpqHeResMemBoardRemoved = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6057)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMemBoardSlotIndex"))
if mibBuilder.loadTexts: cpqHeResMemBoardRemoved.setDescription('Memory board or cartridge removed. An Advanced Memory Protection sub-system board or cartridge has been removed from the system. User Action: Insure the board or cartridge has memory correctly installed and re-insert the memory board or cartridge back into the system.')
cpqHeResMemBoardInserted = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6058)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMemBoardSlotIndex"))
if mibBuilder.loadTexts: cpqHeResMemBoardInserted.setDescription('Memory board or cartridge inserted. An Advanced Memory Protection sub-system board or cartridge has been inserted into the system. User Action: None.')
cpqHeResMemBoardBusError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6059)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMemBoardSlotIndex"))
if mibBuilder.loadTexts: cpqHeResMemBoardBusError.setDescription('Memory board or cartridge bus error detected. An Advanced Memory Protection sub-system board or cartridge bus error has been detected. User Action: Replace the indicated board or cartridge.')
cpqHeEventOccurred = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6060)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeEventLogEntryNumber"), ("CPQHLTH-MIB", "cpqHeEventLogEntrySeverity"), ("CPQHLTH-MIB", "cpqHeEventLogUpdateTime"), ("CPQHLTH-MIB", "cpqHeEventLogErrorDesc"))
if mibBuilder.loadTexts: cpqHeEventOccurred.setDescription('An event has occurred. User Action: None.')
cpqHeManagementProcInReset = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6061)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeManagementProcInReset.setDescription('The Management processor is currently in reset The management processor is currently in the process of being reset because of a firmware update or some other event. User action: None')
cpqHeManagementProcReady = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6062)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeManagementProcReady.setDescription('The Management processor is ready The management processor has successfully reset and is now available again. User action: None')
cpqHeManagementProcFailedReset = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6063)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeManagementProcFailedReset.setDescription('The Management processor failed reset The management processor was not successfully reset and is not operational. User action: Reset the management procesessor again or re-flash the management processor firmware.')
cpqHe5CorrMemReplaceMemModule = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6064)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMem2BoardNum"), ("CPQHLTH-MIB", "cpqHeResMem2CpuNum"), ("CPQHLTH-MIB", "cpqHeResMem2RiserNum"), ("CPQHLTH-MIB", "cpqHeResMem2ModuleNum"), ("CPQHLTH-MIB", "cpqHeResMem2ModulePartNo"), ("CPQHLTH-MIB", "cpqHeResMem2ModuleSize"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqHe5CorrMemReplaceMemModule.setDescription('Corrected \\ uncorrected Memory Errors Detected The errors have been corrected, but the memory module should be replaced. Value 0 for CPU means memory is not Processor based')
cpqHe5ResMemBoardRemoved = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6065)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMem2BoardSlotNum"), ("CPQHLTH-MIB", "cpqHeResMem2BoardCpuNum"), ("CPQHLTH-MIB", "cpqHeResMem2BoardRiserNum"))
if mibBuilder.loadTexts: cpqHe5ResMemBoardRemoved.setDescription('Memory board or cartridge or riser removed. An Advanced Memory Protection sub-system board or cartridge or riser has been removed from the system. Value 0 for CPU means memory is not processor based. User Action: Insure the board or cartridge or riser has memory correctly installed and re-insert the memory board or cartridge or CPU back into the system.')
cpqHe5ResMemBoardInserted = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6066)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMem2BoardSlotNum"), ("CPQHLTH-MIB", "cpqHeResMem2BoardCpuNum"), ("CPQHLTH-MIB", "cpqHeResMem2BoardRiserNum"))
if mibBuilder.loadTexts: cpqHe5ResMemBoardInserted.setDescription('Memory board or cartridge or riser inserted. An Advanced Memory Protection sub-system board or cartridge or riser Has been inserted into the system. Value 0 for CPU means memory is not processor based. User Action: None.')
cpqHe5ResMemBoardBusError = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6067)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeResMem2BoardSlotNum"), ("CPQHLTH-MIB", "cpqHeResMem2BoardCpuNum"), ("CPQHLTH-MIB", "cpqHeResMem2BoardRiserNum"))
if mibBuilder.loadTexts: cpqHe5ResMemBoardBusError.setDescription('Memory board or cartridge or Riser bus error detected. An Advanced Memory Protection sub-system board or cartridge or Riser bus error has been detected. Value 0 for CPU means memory is not processor based. User Action: Replace the indicated board or cartridge or Riser.')
cpqHeResilientMemLockStepMemoryEngaged = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6068)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"))
if mibBuilder.loadTexts: cpqHeResilientMemLockStepMemoryEngaged.setDescription('Advanced Memory Protection LockStep Engine Memory Engaged. The Advanced Memory Protection subsystem has detected a memory fault. The LockStep engine has been activated. User Action: Replace the faulty memory.')
cpqHe4FltTolPowerSupplyACpowerloss = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,6069)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyChassis"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyBay"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyStatus"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyModel"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySerialNumber"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyAutoRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplyFirmwareRev"), ("CPQHLTH-MIB", "cpqHeFltTolPowerSupplySparePartNum"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqHe4FltTolPowerSupplyACpowerloss.setDescription('The fault tolerant power supply AC power loss for the specified chassis and bay location.')
mibBuilder.exportSymbols("CPQHLTH-MIB", cpqHeAsrRebootCount=cpqHeAsrRebootCount, cpqHeThermalSystemFanDegraded=cpqHeThermalSystemFanDegraded, cpqHeResMemBoardInserted=cpqHeResMemBoardInserted, cpqHeEventLogEntryCode=cpqHeEventLogEntryCode, cpqHeEventLogEntry=cpqHeEventLogEntry, cpqHe3ThermalCpuFanOk=cpqHe3ThermalCpuFanOk, cpqHeCorrectableMemoryError=cpqHeCorrectableMemoryError, cpqHeThermalFanPresent=cpqHeThermalFanPresent, cpqHeFltTolPowerSupplyBay=cpqHeFltTolPowerSupplyBay, cpqHeFltTolPowerSupplyStatus=cpqHeFltTolPowerSupplyStatus, cpqHeResMem2BoardRiserNum=cpqHeResMem2BoardRiserNum, cpqHeResilientMemTotalMemSize=cpqHeResilientMemTotalMemSize, cpqHeCriticalErrorTime=cpqHeCriticalErrorTime, cpqHeResMem2BoardTable=cpqHeResMem2BoardTable, cpqHeFltTolPowerSupplyFirmwareRev=cpqHeFltTolPowerSupplyFirmwareRev, cpqHeNw3xDriverName=cpqHeNw3xDriverName, cpqHeComponent=cpqHeComponent, cpqHeResMem2ModuleTable=cpqHeResMem2ModuleTable, cpqHeAsrReset=cpqHeAsrReset, cpqHeTrapLogMaxSize=cpqHeTrapLogMaxSize, cpqHeResMemModuleTable=cpqHeResMemModuleTable, cpqHeFltTolFanEntry=cpqHeFltTolFanEntry, cpqHeCriticalErrorEntry=cpqHeCriticalErrorEntry, cpqHeFltTolPowerSupplyMainVoltage=cpqHeFltTolPowerSupplyMainVoltage, cpqHe3ThermalCpuFanFailed=cpqHe3ThermalCpuFanFailed, cpqHe3FltTolFanInserted=cpqHe3FltTolFanInserted, cpqHe3FltTolFanRedundancyRestored=cpqHe3FltTolFanRedundancyRestored, cpqHeSysUtilPciEntry=cpqHeSysUtilPciEntry, cpqHeEventLogEntryCount=cpqHeEventLogEntryCount, cpqHeTemperatureThreshold=cpqHeTemperatureThreshold, cpqHealth=cpqHealth, cpqHe3FltTolFanRedundancyLost=cpqHe3FltTolFanRedundancyLost, cpqHePowerMeter=cpqHePowerMeter, cpqHeThermalFanStatus=cpqHeThermalFanStatus, cpqHeSysUtilPciFiveMin=cpqHeSysUtilPciFiveMin, cpqHePowerConverterEntry=cpqHePowerConverterEntry, cpqHeOsCommonModuleEntry=cpqHeOsCommonModuleEntry, cpqHeResMem2ModuleEntry=cpqHeResMem2ModuleEntry, cpqHeResMem2ModuleCellStatus=cpqHeResMem2ModuleCellStatus, cpqHeCritLogCondition=cpqHeCritLogCondition, cpqHeNw3xDriverVersion=cpqHeNw3xDriverVersion, cpqHeMgmtDisplayType=cpqHeMgmtDisplayType, cpqHePwrConvRedundantGroupId=cpqHePwrConvRedundantGroupId, cpqHe3PowerConverterRedundancyLost=cpqHe3PowerConverterRedundancyLost, cpqHeThermalSystemFanStatus=cpqHeThermalSystemFanStatus, cpqHe3ThermalSystemFanFailed=cpqHe3ThermalSystemFanFailed, cpqHePostMsgIndex=cpqHePostMsgIndex, cpqHeOsCommonModuleDate=cpqHeOsCommonModuleDate, cpqHeSysUtilPciHwLocation=cpqHeSysUtilPciHwLocation, cpqHePwrConvPresent=cpqHePwrConvPresent, cpqHe2CorrectableMemoryLogDisabled=cpqHe2CorrectableMemoryLogDisabled, cpqHePostMsgDesc=cpqHePostMsgDesc, cpqHe3CorrMemReplaceMemModule=cpqHe3CorrMemReplaceMemModule, cpqHeResilientMemOsMemSize=cpqHeResilientMemOsMemSize, cpqHeManagementProcFailedReset=cpqHeManagementProcFailedReset, cpqHeFltTolPowerSupplyModel=cpqHeFltTolPowerSupplyModel, cpqHeCorrectableMemoryLogDisabled=cpqHeCorrectableMemoryLogDisabled, cpqHe4FltTolPowerSupplyACpowerloss=cpqHe4FltTolPowerSupplyACpowerloss, cpqHePwrConvSocket=cpqHePwrConvSocket, cpqHe3FltTolPowerRedundancyLost=cpqHe3FltTolPowerRedundancyLost, cpqHeResMem2BoardCpuNum=cpqHeResMem2BoardCpuNum, cpqHeTrapLogIndex=cpqHeTrapLogIndex, cpqHeFltTolPowerSupplyCapacityUsed=cpqHeFltTolPowerSupplyCapacityUsed, cpqHeAsrPagerStatus=cpqHeAsrPagerStatus, cpqHeResilientMemCondition=cpqHeResilientMemCondition, cpqHePowerConverterSupported=cpqHePowerConverterSupported, cpqHeFltTolPowerSupplyHwLocation=cpqHeFltTolPowerSupplyHwLocation, cpqHeFltTolFanCondition=cpqHeFltTolFanCondition, cpqHeTemperatureThresholdType=cpqHeTemperatureThresholdType, cpqHeManagementProcReady=cpqHeManagementProcReady, cpqHeResMem2BoardTotalMemSize=cpqHeResMem2BoardTotalMemSize, cpqHeResMem2ModuleManufacturer=cpqHeResMem2ModuleManufacturer, cpqHeTemperatureIndex=cpqHeTemperatureIndex, cpqHeResMemBoardHotPlug=cpqHeResMemBoardHotPlug, cpqHeResMem2ModuleRanks=cpqHeResMem2ModuleRanks, cpqHeEventLogInitialTime=cpqHeEventLogInitialTime, cpqHeCorrMemErrCount=cpqHeCorrMemErrCount, cpqHeFltTolPowerSupplyErrorCondition=cpqHeFltTolPowerSupplyErrorCondition, cpqHe2CorrectableMemoryError=cpqHe2CorrectableMemoryError, cpqHeResMemBoardBusError=cpqHeResMemBoardBusError, cpqHePostMsgEv=cpqHePostMsgEv, cpqHeResMemModuleSpd=cpqHeResMemModuleSpd, cpqHe3AsrConfirmation=cpqHe3AsrConfirmation, cpqHeResMem2ModuleType=cpqHeResMem2ModuleType, cpqHeSysUtilPciDevice=cpqHeSysUtilPciDevice, cpqHeResMem2ModuleSize=cpqHeResMem2ModuleSize, cpqHeResilientAdvancedECCMemoryEngaged=cpqHeResilientAdvancedECCMemoryEngaged, cpqHeFltTolFanLocale=cpqHeFltTolFanLocale, cpqHeEventLogEntryClass=cpqHeEventLogEntryClass, cpqHeMibRevMinor=cpqHeMibRevMinor, cpqHePwrConvChassis=cpqHePwrConvChassis, cpqHe3PostError=cpqHe3PostError, cpqHe3FltTolFanDegraded=cpqHe3FltTolFanDegraded, cpqHeCriticalError=cpqHeCriticalError, cpqHeResMemBoardRemoved=cpqHeResMemBoardRemoved, cpqHePwrConvSlot=cpqHePwrConvSlot, cpqHeResilientMemTypeAvailable=cpqHeResilientMemTypeAvailable, cpqHeAsrBaudRate=cpqHeAsrBaudRate, cpqHeAsrStatus=cpqHeAsrStatus, cpqHeFltTolFanSpeed=cpqHeFltTolFanSpeed, cpqHeThermalCpuFanOk=cpqHeThermalCpuFanOk, cpqHeThermalSystemFanFailed=cpqHeThermalSystemFanFailed, cpqHeAsrBaseIo=cpqHeAsrBaseIo, cpqHe3ThermalTempFailed=cpqHe3ThermalTempFailed, cpqHePostMsgEntry=cpqHePostMsgEntry, cpqHeTrap=cpqHeTrap, cpqHeResMemBoardLocked=cpqHeResMemBoardLocked, cpqHeMibRevMajor=cpqHeMibRevMajor, cpqHeResilientMemRivState=cpqHeResilientMemRivState, cpqHeThermalCpuFanStatus=cpqHeThermalCpuFanStatus, cpqHe3FltTolPowerRedundancyRestored=cpqHe3FltTolPowerRedundancyRestored, cpqHeCriticalErrorInfo=cpqHeCriticalErrorInfo, cpqHePowerMeterSupport=cpqHePowerMeterSupport, cpqHePwrConvIndex=cpqHePwrConvIndex, cpqHePowerMeterStatus=cpqHePowerMeterStatus, cpqHeResMemModuleIndex=cpqHeResMemModuleIndex, cpqHeCorrMemErrTable=cpqHeCorrMemErrTable, cpqHeManagementProcInReset=cpqHeManagementProcInReset, cpqHeResilientMemLockStepMemoryEngaged=cpqHeResilientMemLockStepMemoryEngaged, cpqHeOsCommonModuleName=cpqHeOsCommonModuleName, cpqHeResMem2ModuleCondition=cpqHeResMem2ModuleCondition, cpqHeResMemBoardTotalMemSize=cpqHeResMemBoardTotalMemSize, cpqHeResilientMemory=cpqHeResilientMemory, cpqHePwrConvCondition=cpqHePwrConvCondition, cpqHeTrapType=cpqHeTrapType, cpqHeMibRev=cpqHeMibRev, cpqHePowerMeterPrevReading=cpqHePowerMeterPrevReading, cpqHeResMem2RiserNum=cpqHeResMem2RiserNum, cpqHeAsrRebootLimit=cpqHeAsrRebootLimit, cpqHe5ResMemBoardRemoved=cpqHe5ResMemBoardRemoved, cpqHe3FltTolPowerSupplyInserted=cpqHe3FltTolPowerSupplyInserted, cpqHeCorrMemErrDesc=cpqHeCorrMemErrDesc, cpqHeResMem2ModuleSpd=cpqHeResMem2ModuleSpd, cpqHeResMem2BoardNum=cpqHeResMem2BoardNum, cpqHeAsrPagerMessage=cpqHeAsrPagerMessage, cpqHeResMem2ModuleNum=cpqHeResMem2ModuleNum, cpqHeThermal=cpqHeThermal, cpqHeCorrectableMemory=cpqHeCorrectableMemory, cpqHeThermalTempFailed=cpqHeThermalTempFailed, cpqHeResMemBoardOnlineStatus=cpqHeResMemBoardOnlineStatus, cpqHeResMem2ModuleHwLocation=cpqHeResMem2ModuleHwLocation, cpqHeSysUtilPciTable=cpqHeSysUtilPciTable, cpqHeResMem2BoardCondition=cpqHeResMem2BoardCondition, cpqHeAsrTimeout=cpqHeAsrTimeout, cpqHeAsrBootFail=cpqHeAsrBootFail, cpqHeResMem2ModuleSerialNoMfgr=cpqHeResMem2ModuleSerialNoMfgr, cpqHeCorrMemErrSyndrome=cpqHeCorrMemErrSyndrome, cpqHeEventLogEntryNumber=cpqHeEventLogEntryNumber, cpqHe3TemperatureOk=cpqHe3TemperatureOk, cpqHeThermalFanRequired=cpqHeThermalFanRequired, cpqHeTemperatureCelsius=cpqHeTemperatureCelsius, cpqHe3FltTolPowerSupplyFailed=cpqHe3FltTolPowerSupplyFailed, cpqHeResMemModuleEntry=cpqHeResMemModuleEntry, cpqHePostMsgCode=cpqHePostMsgCode, cpqHeResMemBoardEntry=cpqHeResMemBoardEntry, cpqHeEventLogTable=cpqHeEventLogTable, cpqHe3FltTolPowerSupplyRemoved=cpqHe3FltTolPowerSupplyRemoved, cpqHePwrConvRedundant=cpqHePwrConvRedundant, cpqHeThermalTempOk=cpqHeThermalTempOk, cpqHeResilientMemOnlineSpareEngaged=cpqHeResilientMemOnlineSpareEngaged, cpqHeIRCStatus=cpqHeIRCStatus, cpqHeOsCommonModuleTable=cpqHeOsCommonModuleTable, cpqHeSysUtilEisaBusThirtyMin=cpqHeSysUtilEisaBusThirtyMin, cpqHeMgmtDisplayText=cpqHeMgmtDisplayText, cpqHe3PowerConverterDegraded=cpqHe3PowerConverterDegraded, cpqHeThermalConfirmation=cpqHeThermalConfirmation, cpqHe3CacheAccelParityError=cpqHe3CacheAccelParityError, cpqHeResMem2BoardOnlineStatus=cpqHeResMem2BoardOnlineStatus, cpqHeCorrMemTotalErrs=cpqHeCorrMemTotalErrs, cpqHeTemperatureTable=cpqHeTemperatureTable, cpqHeFltTolPowerSupplyEntry=cpqHeFltTolPowerSupplyEntry, cpqHeResMem2CpuNum=cpqHeResMem2CpuNum, cpqHeCorrMemLogStatus=cpqHeCorrMemLogStatus, cpqHeFltTolPowerSupplySparePartNum=cpqHeFltTolPowerSupplySparePartNum, cpqHeAsrConfirmation=cpqHeAsrConfirmation, cpqHe3ThermalSystemFanDegraded=cpqHe3ThermalSystemFanDegraded, cpqHeTrapPkts=cpqHeTrapPkts, cpqHeFltTolPowerSupplyCapacityMaximum=cpqHeFltTolPowerSupplyCapacityMaximum, cpqHeAsrReboot=cpqHeAsrReboot, cpqHeResMemBoardNumSockets=cpqHeResMemBoardNumSockets, cpqHeResMem2ModuleTechnology=cpqHeResMem2ModuleTechnology, cpqHeSysUtilPciIndex=cpqHeSysUtilPciIndex, cpqHeOsCommonModuleIndex=cpqHeOsCommonModuleIndex, cpqHe3FltTolFanRemoved=cpqHe3FltTolFanRemoved, cpqHeResMem2Module=cpqHeResMem2Module, cpqHeAsrPost=cpqHeAsrPost, cpqHeResilientMemTypeActive=cpqHeResilientMemTypeActive, cpqHeSysUtilPciHour=cpqHeSysUtilPciHour, cpqHeResilientMemMirroredMemoryEngaged=cpqHeResilientMemMirroredMemoryEngaged, cpqHeEventLogUpdateTime=cpqHeEventLogUpdateTime, cpqHeFltTolPowerSupplyAutoRev=cpqHeFltTolPowerSupplyAutoRev, cpqHeResMem2ModuleSmartMemory=cpqHeResMem2ModuleSmartMemory, cpqHeResMemBoardSlotIndex=cpqHeResMemBoardSlotIndex, cpqHeResMem2BoardLocked=cpqHeResMem2BoardLocked, cpqHeAsrCommPort=cpqHeAsrCommPort, cpqHeFltTolPowerSupplySerialNumber=cpqHeFltTolPowerSupplySerialNumber, cpqHePowerConverterCondition=cpqHePowerConverterCondition, cpqHe3CorrectableMemoryError=cpqHe3CorrectableMemoryError, cpqHeSysUtilEisaBusFiveMin=cpqHeSysUtilEisaBusFiveMin, cpqHeThermalTempDegraded=cpqHeThermalTempDegraded, cpqHeResMemBoardTable=cpqHeResMemBoardTable, cpqHeTrapLogEntry=cpqHeTrapLogEntry, cpqHeResMem2BoardOsMemSize=cpqHeResMem2BoardOsMemSize, cpqHeThermalFanCurrentSpeed=cpqHeThermalFanCurrentSpeed, cpqHeFltTolFanChassis=cpqHeFltTolFanChassis, cpqHeAsrMajorVersion=cpqHeAsrMajorVersion, cpqHeResilientMemHotPlug=cpqHeResilientMemHotPlug, cpqHeTemperatureLocale=cpqHeTemperatureLocale, cpqHeCorrMemErrEntry=cpqHeCorrMemErrEntry, cpqHeAsr=cpqHeAsr, cpqHeTemperatureChassis=cpqHeTemperatureChassis, cpqHeResMem2ModulePartNoMfgr=cpqHeResMem2ModulePartNoMfgr, cpqHeAsrDialOutNumber=cpqHeAsrDialOutNumber, cpqHeThermalFanEntry=cpqHeThermalFanEntry, cpqHeTemperatureCondition=cpqHeTemperatureCondition, cpqHeResMemBoardErrorStatus=cpqHeResMemBoardErrorStatus, cpqHeResMem2BoardErrorStatus=cpqHeResMem2BoardErrorStatus, cpqHePwrConvHwLocation=cpqHePwrConvHwLocation, cpqHeEventLogCondition=cpqHeEventLogCondition, cpqHeTemperatureEntry=cpqHeTemperatureEntry, cpqHe3TemperatureFailed=cpqHe3TemperatureFailed, cpqHePostError=cpqHePostError, cpqHeEventLogErrorDesc=cpqHeEventLogErrorDesc, cpqHe3TemperatureDegraded=cpqHe3TemperatureDegraded, cpqHeOsNetWare3x=cpqHeOsNetWare3x, cpqHeThermalDegradedAction=cpqHeThermalDegradedAction, cpqHeResMemModuleCondition=cpqHeResMemModuleCondition, cpqHeFltTolFanType=cpqHeFltTolFanType, cpqHeSysUtil=cpqHeSysUtil, cpqHeThermalCondition=cpqHeThermalCondition, cpqHePostMsgTable=cpqHePostMsgTable, cpqHeFltTolFanPresent=cpqHeFltTolFanPresent, cpqHeAsrMinorVersion=cpqHeAsrMinorVersion, cpqHeResMemModuleStatus=cpqHeResMemModuleStatus, cpqHeSysUtilPciThirtyMin=cpqHeSysUtilPciThirtyMin, cpqHeLastCritErrorAbendMsg=cpqHeLastCritErrorAbendMsg, cpqHeCorrMemErrTime=cpqHeCorrMemErrTime, cpqHeNw3xDriverDate=cpqHeNw3xDriverDate, cpqHeResMem2BoardNumSockets=cpqHeResMem2BoardNumSockets, cpqHeTemperatureHwLocation=cpqHeTemperatureHwLocation, cpqHeResMem2BoardOperatingFrequency=cpqHeResMem2BoardOperatingFrequency, cpqHeCriticalErrorTable=cpqHeCriticalErrorTable, cpqHeResMem2ModuleStatus=cpqHeResMem2ModuleStatus, cpqHeResilientMemOperatingSpeed=cpqHeResilientMemOperatingSpeed, cpqHeResMem2BoardEntry=cpqHeResMem2BoardEntry, cpqHeMgmtUID=cpqHeMgmtUID, cpqHe5ResMemBoardInserted=cpqHe5ResMemBoardInserted, cpqHeOsCommonPollFreq=cpqHeOsCommonPollFreq, cpqHeAsrDialOutStatus=cpqHeAsrDialOutStatus, cpqHeFltTolFanCurrentSpeed=cpqHeFltTolFanCurrentSpeed, cpqHeCorrMemErrHwLocation=cpqHeCorrMemErrHwLocation, cpqHeFltTolPwrSupplyDegraded=cpqHeFltTolPwrSupplyDegraded, cpqHeResMemBoardIndex=cpqHeResMemBoardIndex, cpqHeCriticalErrorStatus=cpqHeCriticalErrorStatus)
mibBuilder.exportSymbols("CPQHLTH-MIB", cpqHeEventOccurred=cpqHeEventOccurred, cpqHeSysUtilEisaBusHour=cpqHeSysUtilEisaBusHour, cpqHeResMem2BoardOperatingVoltage=cpqHeResMem2BoardOperatingVoltage, cpqHeThermalTempStatus=cpqHeThermalTempStatus, cpqHeMgmtDisplay=cpqHeMgmtDisplay, cpqHeOsCommonModuleVersion=cpqHeOsCommonModuleVersion, cpqHeThermalFanTable=cpqHeThermalFanTable, cpqHeResMem2ModuleCellTablePtr=cpqHeResMem2ModuleCellTablePtr, cpqHeResMem2BoardSlotNum=cpqHeResMem2BoardSlotNum, cpqHeMibCondition=cpqHeMibCondition, cpqHePowerConverterTable=cpqHePowerConverterTable, cpqHeThermalCpuFanFailed=cpqHeThermalCpuFanFailed, cpqHe3ThermalSystemFanOk=cpqHe3ThermalSystemFanOk, cpqHeCriticalErrorDesc=cpqHeCriticalErrorDesc, cpqHeOsCommon=cpqHeOsCommon, cpqHeAsrPagerNumber=cpqHeAsrPagerNumber, cpqHeFltTolFanIndex=cpqHeFltTolFanIndex, cpqHeResMemBoardOsMemSize=cpqHeResMemBoardOsMemSize, cpqHeSysUtilPciBus=cpqHeSysUtilPciBus, cpqHeFltTolFanHotPlug=cpqHeFltTolFanHotPlug, cpqHePowerConverter=cpqHePowerConverter, cpqHeResilientMemStatus=cpqHeResilientMemStatus, cpqHeInterface=cpqHeInterface, cpqHeIRC=cpqHeIRC, cpqHe3PowerConverterFailed=cpqHe3PowerConverterFailed, cpqHePostMsg=cpqHePostMsg, cpqHeEventLogEntrySeverity=cpqHeEventLogEntrySeverity, cpqHeCorrMemErrDdr=cpqHeCorrMemErrDdr, cpqHeSysUtilLifeTime=cpqHeSysUtilLifeTime, cpqHe4FltTolPowerSupplyDegraded=cpqHe4FltTolPowerSupplyDegraded, cpqHeFltTolFanTable=cpqHeFltTolFanTable, cpqHe3ThermalTempDegraded=cpqHe3ThermalTempDegraded, cpqHeCorrMemErrIndex=cpqHeCorrMemErrIndex, cpqHeThermalFanIndex=cpqHeThermalFanIndex, cpqHeTrapTime=cpqHeTrapTime, cpqHe3CorrectableMemoryLogDisabled=cpqHe3CorrectableMemoryLogDisabled, cpqHe5ResMemBoardBusError=cpqHe5ResMemBoardBusError, cpqHeOsCommonModulePurpose=cpqHeOsCommonModulePurpose, cpqHeFltTolPowerSupplyRedundantPartner=cpqHeFltTolPowerSupplyRedundantPartner, cpqHeCritLogSupported=cpqHeCritLogSupported, cpqHeResMem2ModuleMinVoltage=cpqHeResMem2ModuleMinVoltage, cpqHeFltTolPowerSupplyPresent=cpqHeFltTolPowerSupplyPresent, cpqHeResMem2ModulePartNo=cpqHeResMem2ModulePartNo, cpqHeResMemBoardCondition=cpqHeResMemBoardCondition, cpqHeResilientMemXorMemoryEngaged=cpqHeResilientMemXorMemoryEngaged, cpqHePostMsgCondition=cpqHePostMsgCondition, cpqHeResMem2ModuleSerialNo=cpqHeResMem2ModuleSerialNo, cpqHeFltTolPwrSupply=cpqHeFltTolPwrSupply, cpqHeCorrMemErrorCntThresh=cpqHeCorrMemErrorCntThresh, cpqHeEventLog=cpqHeEventLog, cpqHeThermalFanCpuFan=cpqHeThermalFanCpuFan, cpqHe4FltTolPowerSupplyOk=cpqHe4FltTolPowerSupplyOk, cpqHe3ThermalConfirmation=cpqHe3ThermalConfirmation, cpqHeSysUtilEisaBusMin=cpqHeSysUtilEisaBusMin, cpqHeAsrNetworkAccessStatus=cpqHeAsrNetworkAccessStatus, cpqHeFltTolFanRedundant=cpqHeFltTolFanRedundant, cpqHeCriticalErrorIndex=cpqHeCriticalErrorIndex, cpqHeFltTolPwrSupplyCondition=cpqHeFltTolPwrSupplyCondition, cpqHeFltTolPowerSupplyRedundant=cpqHeFltTolPowerSupplyRedundant, cpqHeResMem2ModuleFrequency=cpqHeResMem2ModuleFrequency, cpqHePowerMeterCurrReading=cpqHePowerMeterCurrReading, cpqHeEventLogFreeFormData=cpqHeEventLogFreeFormData, cpqHeFltTolPowerSupplyHotPlug=cpqHeFltTolPowerSupplyHotPlug, cpqHeFltTolPowerSupplyTable=cpqHeFltTolPowerSupplyTable, cpqHeCriticalErrorType=cpqHeCriticalErrorType, cpqHeAsrCondition=cpqHeAsrCondition, cpqHeResMem2BoardIndex=cpqHeResMem2BoardIndex, cpqHe4FltTolPowerSupplyFailed=cpqHe4FltTolPowerSupplyFailed, cpqHe3ThermalTempOk=cpqHe3ThermalTempOk, cpqHe3FltTolPowerSupplyDegraded=cpqHe3FltTolPowerSupplyDegraded, cpqHeResMem2ModuleDate=cpqHeResMem2ModuleDate, cpqHeResMem2BoardHotPlug=cpqHeResMem2BoardHotPlug, cpqHeSysUtilPciMin=cpqHeSysUtilPciMin, cpqHe5CorrMemReplaceMemModule=cpqHe5CorrMemReplaceMemModule, cpqHeFltTolPwrSupplyStatus=cpqHeFltTolPwrSupplyStatus, cpqHeAsrPollTime=cpqHeAsrPollTime, cpqHeThermalSystemFanOk=cpqHeThermalSystemFanOk, cpqHeFltTolPowerSupplyCondition=cpqHeFltTolPowerSupplyCondition, cpqHeCorrMemLogCondition=cpqHeCorrMemLogCondition, cpqHe3FltTolFanFailed=cpqHe3FltTolFanFailed, cpqHe3FltTolPwrSupplyDegraded=cpqHe3FltTolPwrSupplyDegraded, cpqHe4CorrMemReplaceMemModule=cpqHe4CorrMemReplaceMemModule, cpqHeAsrDialInStatus=cpqHeAsrDialInStatus, cpqHeThermalFanHwLocation=cpqHeThermalFanHwLocation, cpqHeFltTolFanHwLocation=cpqHeFltTolFanHwLocation, cpqHeEventLogSupported=cpqHeEventLogSupported, cpqHeFltTolFanRedundantPartner=cpqHeFltTolFanRedundantPartner, cpqHeResMemModuleSparePartNo=cpqHeResMemModuleSparePartNo, cpqHeFltTolPowerSupplyChassis=cpqHeFltTolPowerSupplyChassis, cpqHeTrapLogTable=cpqHeTrapLogTable)

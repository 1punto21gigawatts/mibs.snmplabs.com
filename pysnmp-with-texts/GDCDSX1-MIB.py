#
# PySNMP MIB module GDCDSX1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCDSX1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, iso, ModuleIdentity, enterprises, Gauge32, TimeTicks, Integer32, ObjectIdentity, Unsigned32, Counter64, NotificationType, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "iso", "ModuleIdentity", "enterprises", "Gauge32", "TimeTicks", "Integer32", "ObjectIdentity", "Unsigned32", "Counter64", "NotificationType", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
dsx1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6))
gdcDsx1System = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1))
sc5001 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2))
gdcDsx1Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 1))
gdcDsx1Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 2))
gdcDsx1Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 3))
gdcDsx1Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 4))
gdcDsx1Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 5))
gdcDsx1Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 6))
gdcDsx1NetMaintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 1, 7))
gdcDsx1SystemMIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1SystemMIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1SystemMIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
gdcDsx1VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2), )
if mibBuilder.loadTexts: gdcDsx1VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1VersionTable.setDescription(' ')
gdcDsx1VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1VersionIndex"))
if mibBuilder.loadTexts: gdcDsx1VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1VersionEntry.setDescription('An entry in the GDC gdcDsx1 Version Table.')
gdcDsx1VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1VersionIndex.setDescription('Identifies Version parameters associated with the managed object.')
gdcDsx1FirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1FirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1FirmwareRev.setDescription('The version number of the bootstrap firmware. The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. ')
gdcDsx1ModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ModelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ModelNumber.setDescription('This variable is used to determine the type of card family installed ex. SC5001, SC5002.')
gdcDsx1ActiveFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ActiveFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ActiveFirmwareRev.setDescription('The version number of the firmware currently executing. The format is MM.NN.BB where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
gdcDsx1StoredFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1StoredFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1StoredFirmwareRev.setDescription('The version number of the firmware stored (in a compressed format) but not currently executing. MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
gdcDsx1BootRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1BootRev.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1BootRev.setDescription('The version number of the bootstrap firmware. The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. ')
gdcDsx1StoredFirmwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("statBlank", 1), ("statDownLoading", 2), ("statOK", 3), ("statCheckSumBad", 4), ("statUnZipping", 5), ("statBadUnZip", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1StoredFirmwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1StoredFirmwareStatus.setDescription('This object represents the state of the Non-Active or Stored firmware: statBlank(1) Factory Default statDownLoading(2) In process of downloading firmware statOK(3) Zipped version checksum succesful (OK to switch) (can set gdcDsx1SwitchActive to switchActive(2)) statCheckSumBad(4) Failed checksum after download statUnZipping(5) In process of uncompressing into active area statBadUnZip(6) Failed last uncompress The object is read only. ')
gdcDsx1SwitchActiveFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNorm", 1), ("switchActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1SwitchActiveFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1SwitchActiveFirmware.setDescription('This object is used to switch the active executing firmware from the version in gdcDsx1ActiveRev to the version in gdcDsx1StoredRev. When a switchActive(2) is set (write only) the element will: 1) reboot 2) uncompress stored code into active area 3) perform checksum on active area 4) Set gdcDsx1StoredStatus object to indicate results 5) If succesfull: update gdcDsx1ActiveFirmwareRev and gdcDsx1StoredFirmwareRev and begin executing If failed: replace active area with previous revision The switchNorm(1) enumeration will always be read. Setting switchActive(2) when the gdcDsx1StoredStatus is not statOK(3) will result in an error. ')
gdcDsx1DownloadingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableAll", 1), ("enableAndWait", 2), ("enableAndSwitch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1DownloadingMode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1DownloadingMode.setDescription('This object is used to configure the download mode: disableAll(1) Prevents any firmware downloading to gdcDsx1 enableAndWait(2) Allows downloading zipped code to be stored only! enableAndSwitch(3) Allows downloading and then unzips and begins executing the new code ')
gdcDsx1MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1), )
if mibBuilder.loadTexts: gdcDsx1MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1MaintenanceTable.setDescription('The table describes the maintenance objects for the unit and references the unit interface (cc = 00).')
gdcDsx1MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1MaintenanceLineIndex"))
if mibBuilder.loadTexts: gdcDsx1MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1MaintenanceEntry.setDescription('An entry in the GDC ltu Maintenance Configuration Table.')
gdcDsx1MaintenanceLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1MaintenanceLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1MaintenanceLineIndex.setDescription('This object identifies Maintenance parameters associated with the managed object.')
gdcDsx1SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(1), then the unit performs a soft reset, whose meaning is specific to the type of unit being managed. The value of norm(2) will be returned when the reset is complete. The value of norm(2) can not be set by management.')
gdcDsx1ConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hardware", 1), ("software", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ConfigMode.setDescription('The hardware configuration mode of the unit. A unit may be configured through hardware switches, jumper, straps, etc. The value software(2) indicates that the unit is software configurable. The value of hardware(1) indicates that some options are hard configured and that software configuration is not permitted of these options. The value of hardware(1) can not be set by management.')
gdcDsx1FrontPanel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1FrontPanel.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1FrontPanel.setDescription("This variable is used to indicate whether the front panel switches are operational or not. 'inhibit' refers to when the front panel switches are not operational. 'enable' refers to when the front panel switches are operational.")
gdcDsx1SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count.')
gdcDsx1DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("factoryDefault", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault(1) the unit will perform a reset to make the default configuration take affect. The value of normal(2) will be returned when the initialization is complete. The value of normal(2) can not be set by management.')
gdcDsx1ResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9))).clone(namedValues=NamedValues(("norm", 1), ("reset", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1ResetStats.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ResetStats.setDescription('Supports the action of soft resetting the dsx1ValidIntervals object. When this object is set to reset(9), then the unit will reset the dsx1ValidIntervals object to zero. The value of norm(1) can not be set by management.')
gdcDsx1LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1LedStatus.setDescription("Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - ON bit 5 - INSV bit 4 - RSP bit 3 - TMG bit 2 - EQ LAD bit 1 - EQ 0'S bit 0 - EQ NS Octet 2 bit 7 - not used bit 6 - EQ OOF bit 5 - NTWK AIS bit 4 - NTWK BPV bit 3 - NTWK NS bit 2 - NTWK OOF bit 1 - ALM bit 0 - TM Octet 3 bit 7 - not used bit 6 - ST bit 5 - LT bit 4 - RL bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - future use")
gdcDsx1SetTransmitClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("txClkSrc", 1), ("fallBackClkSrc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1SetTransmitClkSrc.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1SetTransmitClkSrc.setDescription(" 'txClkSrc' indicates the unit is using the optioned clock source as indicated by the dsx1TransmitClockSource variable in the RFC1406 mib or the gdcDsx1TransmitClockSource variable in the gdcdsx1 mib. 'fallBackClkSrc' indicates the unit is using the optioned clock source as indicated by the gdcDsx1FallbackClockSource variable in the gdcdsx1 mib. ")
gdcDsx1CsuMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("csuMode", 1), ("concentratorMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1CsuMode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CsuMode.setDescription(" 'csuMode' indicates the unit is operating as a T1 channel service unit with the payload from the network interface connected to the payload of the cascade interface. 'concentratorMode' indicates the unit is operating as a T1 channel service unit with the T1 payloads groomed to cross connect within the shelf and the network and cascade interfaces. ")
gdcDsx1CircuitIdentifier1 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1CircuitIdentifier1.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CircuitIdentifier1.setDescription('Private data storage area of sixteen bytes.')
gdcDsx1CircuitIdentifier2 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 2, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1CircuitIdentifier2.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CircuitIdentifier2.setDescription('Private data storage area of sixteen bytes.')
gdcDsx1NetMaintTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 7, 1), )
if mibBuilder.loadTexts: gdcDsx1NetMaintTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1NetMaintTable.setDescription('The table describes the maintenance objects for the network and references the network interface (cc = 01).')
gdcDsx1NetMaintEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 7, 1, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1NetMaintLineIndex"))
if mibBuilder.loadTexts: gdcDsx1NetMaintEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1NetMaintEntry.setDescription('An entry in the GDC ltu Network Maintenance Configuration Table.')
gdcDsx1NetMaintLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 7, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1NetMaintLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1NetMaintLineIndex.setDescription('This object identifies Maintenance parameters associated with the managed object.')
gdcDsx1NetMaintReceiveLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 43))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1NetMaintReceiveLevel.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1NetMaintReceiveLevel.setDescription("This variable reports the absolute value of the network relative receive level of -40dB to +3dB when the gdcDsx1InterfaceType is set for ds1(1). This object interacts with the gdcDsx1NetMaintAttenSense object in determining the unit's actual Receive Level.")
gdcDsx1NetMaintAttenSense = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("positive", 1), ("negative", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1NetMaintAttenSense.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1NetMaintAttenSense.setDescription('This variable identifies ths sense of the gdcdsx1NetReceiveLevel variable.')
gdcDsx1ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1), )
if mibBuilder.loadTexts: gdcDsx1ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ConfigTable.setDescription('The GDC DS1 Configuration table. Information in the entries of this table augment the entries in the DS1 Configuration table of the DS1 MIB defined in RFC 1406.')
gdcDsx1ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1ConfigIndex"))
if mibBuilder.loadTexts: gdcDsx1ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ConfigEntry.setDescription('The GDC DS1 Configuration table entry. The information in this entry augments the information for the corresponding entry in the dsx1ConfigEntry of the DS1 MIB defined in RFC 1406.')
gdcDsx1ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier.')
gdcDsx1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 1), ("manEsf", 2), ("manD4", 3), ("unframed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1LineType.setDescription("This variable indicates the variety of DS-X Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. The values, in sequence, describe: 'auto' indicates the unit is still determining framing when gdcDsx1LineType is set for auto (1) dsx1LineType reads other(1). 'manEsf' indicates manual selection of extended superframe format 'manD4'indicates manual selection of D4 framing format 'unframed' indicates manual selection of unframed format Reference rfc1406 dsx1LineType gdcDsx1LineType dsx1ESF (2) ============> manESF (2) dsx1D4 (3) ============> manD4 (3) All other values in dsx1LineType are not supported at this time. Default value: manESF (2)")
gdcDsx1InterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ds1", 2), ("dsx1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1InterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1InterfaceType.setDescription('The operating mode of the interface. Setting the value of this object to ds1(2) configures the interface as standard DS1. Setting the value of this object to dsx1(3) configures the interface to operate as a standard cross-connect DSX-1. The value other(1) identifies another interface mode defined elsewhere. This value can never be set by management operation. This object interoperates with the gdcDsx1Preequalization object. When this object is set to ds1(2), then the value of gdcDsx1Preequalization does not apply. This object interoperates with the gdcDsx1AdminLineBuildout object. When this object is set to dsx1(3), then the value of gdcDsx1LineBuildout does not apply. This object interoperates with the gdcDsx1AdminLineBuildout object. When this object is set to dsx1(3), then the value of gdcDsx1AutoLineBuildout does not apply. This object interoperates with the gdcDsx1AdminReceiveRange object. When this object is set to dsx1(3), then the value of gdcDsx1ReceiveRange does not apply. This object interoperates with the gdcDsx1AdminReceiveRange object. When this object is set to dsx1(3), then the value of gdcDsx1AutoReceiveRange is set to disabled(2).')
gdcDsx1Preequalization = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("preeq130", 2), ("preeq260", 3), ("preeq390", 4), ("preeq530", 5), ("preeq655", 6), ("none", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1Preequalization.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1Preequalization.setDescription('Is the preequalization of the transmitter of the interface. The value other(1) identifies an other preequalization value which is defined elsewhere. This value can never be set by management operation. This object interoperates with the object gdcDsx1InterfaceType. When the value of gdcDsx1InterfaceType is ds1(2) then this value is not applicable.')
gdcDsx1AdminLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 1), ("man00dB", 2), ("man75dB", 3), ("man150dB", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1AdminLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AdminLineBuildout.setDescription("This variable is used to set the Transmit Ntwk Build-Out value on the network side and is only valid if the gdcDsx1InterfaceType is set for ds1(1). The values, in sequence, describe: 'auto' indicates auto detection of receive level to determine the appropriate Ntwk build out without controller intervention 'man00dB' indicates manual selection of 0.0 dB transmit Ntwk build out 'man75dB' indicates manual selection of -7.5 dB transmit Ntwk build out 'man150dB' indicates manual selection of -15.0 dB transmit Ntwk build out Set/get of auto requires a reading of gdcDsx1OperLineBuildOut to determine the selection of the Ntwk buildout. Caution must be used when setting auto since only one unit on a link can be in auto at a given time. Default value: man00dB (2)")
gdcDsx1OperLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inProcess", 1), ("tx00dB", 2), ("tx75dB", 3), ("tx150dB", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1OperLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1OperLineBuildout.setDescription("This variable is used to report the current Ntwk build-out setting if the gdcDsx1InterfaceType is set for ds1(1). 'inProcess' indicates the unit is still determining the Ntwk build out required when the gdcDsx1AdminLineBuildout is set for auto (1) 'tx00dB' indicates the unit is set for 0.0 dB of attenuation when the gdcDsx1AdminLineBuildout is set for auto (1) or man00dB (2) 'tx75dB' indicates the unit is set for -7.5 dB of attenuation when the gdcDsx1AdminLineBuildout is set for auto (1) or man75dB (3) 'tx150dB' indicates the unit is set for -15.0 dB of attenuation when the gdcDsx1AdminLineBuildout is set for auto (1) or man150dB (4)")
gdcDsx1AdminRcvRange = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("manNorm", 2), ("manExt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1AdminRcvRange.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AdminRcvRange.setDescription("This variable is used to set the receiver circuitry for signal recovery ranges when gdcDsx1InterfaceType is set for ds1 (1). This function is not supported for gdcDsx1InterfaceType set for dsx1 (2). Normal range is considered 0 to -28 dB and extended range is from -20 to -40 dB relative to a DS-1 launch pulse. The values,in sequence, describe: 'auto' indicates auto selection of receiver range 'manNorm' indicates manual selection of normal range 'manExt' indicates manual selection of extended range Set/get of auto requires a reading of gdcDsx1OperRcvRange to determine the selection of the receiver range. Caution must be used when setting auto since only one unit on a link can be in auto at a given time. Default value: auto(1)")
gdcDsx1OperRcvRange = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inProcess", 1), ("norm", 2), ("ext", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1OperRcvRange.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1OperRcvRange.setDescription("This variable is used to report the current receiver range setting when gdcDsx1InterfaceType is set for ds1 (1). 'inProcess' indicates the unit is still determining the required receiver range when the gdcDsx1AdminRcvRange is set for auto (1) 'norm' indicates the receiver is set for normal range when the gdcDsx1AdminRcvRange is set for auto (1) or manNorm (2) 'ext' indicates the receiver is set for extended range when the gdcDsx1AdminRcvRange is set for auto (1) or manExt (3)")
gdcDsx1OnesDensity = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inhibit", 1), ("max15zeros", 2), ("max39zeros", 3), ("restrict8XNplus1", 4), ("min1in8", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1OnesDensity.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1OnesDensity.setDescription('The ones density restriction for the interface. The values of this object define the ones density restriction that is enforced on the interface. The value inhibit(1) indicates that no ones density restriction is enforced. The value max15zeros(2) indicates that a maximum of 15 zeros are transmitted to the network before a one is inserted. The value max39zeros(3) indicates that a maximum of 39 zeros are transmitted to the network before a one is inserted. The value restrict8nX1(4) indicates a minimum of N ones per 8(N+1) bits, where N is in the range 1 to 24. The value min1in8(5) indicates a minimum of 1 one per 8 bits. With this value, pulse density violations are enforced but not recorded.')
gdcDsx1TransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("station", 2), ("cascade", 3), ("channel", 4), ("composite", 5), ("shelf", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1TransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TransmitClockSource.setDescription('Augments the dsx1TransmitClockSource of the DS1 MIB of RFC 1406. This object defines transmit clock sources that are not defined by RFC 1406, but are supported by GDC DS1 interfaces. The value other(1) indicates that the DS1 transmit clock source is defined elsewhere. The other values identify other timing sources as indicated. The value other(1) can never be set by management operation. This object interoperates with the dsx1TransmitClockSource object. When the dsx1TransmitClockSource is set to loopTiming(1) or localTiming(2), the value of this object reflects other(1). When the value of this object has a value other than other(1), then the value of the dsx1TransmitClockSource object reflects throughTiming(3). The value channel(4) interoperates with the gdcDsuChannelTransmitClockSource object. When this value is selected, gdcDsuChannelTransmitClockSource is set to the appropriate channel of the clock source for multi-channel products.')
gdcDsx1FallbackClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("composite", 3), ("loopTiming", 4), ("channel", 5), ("cascade", 6), ("localTiming", 7), ("station", 8), ("shelf", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1FallbackClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1FallbackClockSource.setDescription('Identifies the fallback transmit clock source. The value of other(1) identifies another fallback transmit clock source that is defined elsewhere. The value of none(2) indicates no fallback transmit clock source. The value other(1) can never be set by management operation. The value channel(4) interoperates with the gdcDsuChannelTransmitClockSource object. When this value is selected, gdcDsuChannelTransmitClockSource is set to the appropriate channel of the clock source for multi-channel products.')
gdcDsx1AISLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1AISLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AISLoopdown.setDescription('The time in seconds when receiving a continuous AIS signal before a remotely initiated loopback is terminated. When this object has the value 4, then there is no time limit and the loop must be terminated by remotely issued in-band loopdown codes. When the object has a value between 5 and 60, then this is time in seconds of continuous AIS signal before the loopback is terminated.')
gdcDsx1InbandLoopCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inhibit", 1), ("payload", 2), ("lineloop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1InbandLoopCfg.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1InbandLoopCfg.setDescription("This variable is used to set the In-Band DS1 Loopback Code Detection. 'inhibit' refers to when the in-band loopback codes are ignored. 'payload' designates a payload loopback is done upon recognition of the inband loopback code. 'lineloop' designates a line loopback is done upon recognition of the inband loopback code.")
gdcDsx1Redundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("onLine", 1), ("backUp", 2), ("keepAlive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1Redundancy.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1Redundancy.setDescription('This variable identifies which unit is the Primary unit and which unit is the Secondary unit. When the value is onLine(1), then the unit is identified as the Primary unit. When the value is backUp(2), then the unit is identified as the Secondary unit. The value keepAlive(3) indicates that a physical strap is enabled on the unit and that the values of onLine(1) and backUp(2) are ignored. The value keepAlive(3) can never be set by network management.')
gdcDsx1DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1), )
if mibBuilder.loadTexts: gdcDsx1DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1DiagTable.setDescription('The GDC DS1 Diagnostics table. Information in the entries of this table support diagnostics testing, both active testing via patterns, and passive testing via loopbacks. The information of this table augments the entries in the DS1 Configuration table of the DS1 MIB defined in RFC 1406.')
gdcDsx1DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1DiagIndex"))
if mibBuilder.loadTexts: gdcDsx1DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1DiagEntry.setDescription('The GDC DS1 Diagnostics table entry. The information in this entry augments the information for the corresponding entry in the DS1 Configuration table of the DS1 MIB defined in RFC 1406.')
gdcDsx1DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1DiagIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier, which in this case is a network interface.')
gdcDsx1SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("other", 1), ("sendProgPattern", 2), ("send2047pattern", 3), ("sendInbandCode", 6), ("sendInbandCodeReset", 7), ("sendNetworkInterfaceCode", 8), ("sendNtworkInterfaceResetcode", 9), ("sendDS0DelayPattern", 10), ("send511PatternWithLT", 11), ("send511PatternWithRT", 12), ("send2047PatternWithLT", 13), ("send2047PatternWithRT", 14), ("sendQRSPatternWithLT", 15), ("sendQRSPatternWithRT", 16), ("sendProgPatternWithLT", 17), ("sendProgPatternWithRT", 18), ("send3in24PatternWithRT", 19)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1SendCode.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1SendCode.setDescription('Augments the dsx1SendCode object from the DS1 MIB of RFC 1406. This object defines other codes that are not defined by dsx1SendCode. The value of other(1) can never be set by management operation. This object and the dsx1SendCode object interoperate. When the value of dsx1SendCode is set to something other than dsx1SendOtherTestPattern(8), then the value of this object is set to other(1). When the value of this object is set to something other than other(1), the the value of dsx1SendCode is set to dsx1SendOtherTestPattern(8). This object and the gdcDsx1ProgPattern object interrelate. When this object is set to the value sendProgPattern(4), the value of the gdcDsx1ProgPattern object is used as the 16 bit user programmable pattern. The values send511PatternWithLT(11), send511PatternWithRT(12), send2047PatternWithLT(13), send2047PatternWithRT(14), sendQRSPatternWithLT(15), sendQRSPatternWithRT(16), sendProgPatternWithLT(17), sendProgPatternWithRT(18), send3in24PatternWithRT(19) indicate that the given pattern test is running in conjunction with a local test (LT) or remote test (RT). gdcDsx1LoopbackConfig is updated to indicate this as well. When one of these tests are running, and dsx1SendCode is set to dsx1SendNoCode(1), both the pattern and the loopback are terminated. However, if dsx1LoopbackConfig is set to dsx1NoLoop(1), and a pattern with LT is in progres, only the loopback portion is terminated.')
gdcDsx1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("localtest", 2), ("ds0", 3), ("cascade", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1LoopbackConfig.setDescription('Augments the dsx1LoopbackConfig object from the DS1 MIB of RFC 1406. This object defines other loopback configurations that are not defined by dsx1LoopbackConfig. The value of other(1) can never be set by management operation.')
gdcDsx1DS0Diag = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1DS0Diag.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1DS0Diag.setDescription('Defines a DS0 level diagnostic. Setting this object value to 0 disables a DS0 level diagnostic. Setting this object to a value from 1 to 32 enables a DS0 level diagnostic on the DS0 indicated. Enabling a DS0 level diagnostic bysetting this object to a value from 1 to 32 alters the meaning of the diagnostic test to be specific to the DS0 specified instead of the whole DS1. Note that a DS0 level diagnostic and a DS1 level diagnostic cannot be performed simultaneously.')
gdcDsx1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noLimit", 1), ("testTime1Min", 2), ("testTime2Mins", 3), ("testTime3Mins", 4), ("testTime4Mins", 5), ("testTime5Mins", 6), ("testTime6Mins", 7), ("testTime7Mins", 8), ("testTime8Mins", 9), ("testTime9Mins", 10), ("testTime10Mins", 11), ("testTime15Mins", 12), ("testTime20Mins", 13), ("testTime25Mins", 14), ("testTime30Mins", 15), ("testTime30Secs", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TestDuration.setDescription('Selects the duration to run a diagnostic test. The value(1) noLimit signifies that the test should run indefinitely until explicitly terminated. Default value: noLimit (1)')
gdcDsx1TestExecutionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("notInTest", 1), ("testInProgress", 2), ("testCompleted", 4), ("testCompletedNotInTest", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1TestExecutionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TestExecutionStatus.setDescription('This variable reports the status of a test. notInTest(1) indicates a test is not running. testInProgress(2) indicates that a test is currently running. testCompleted(4) indicates that a test has run and is completed. testCompletedNotInTest(5) indicates that a test has completed and it is no longer in test.')
gdcDsx1TestExceptions = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1TestExceptions.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TestExceptions.setDescription('Indicates exceptions that have occurred that may affect interpretation of the test results. The value of this object is a sum. This sum initially take the value zero. Then, for each exception, the value associated with the exception is added to the sum. The exception values are: value exception 1 a timed test was preempted so the result cannot be viewed in relation to the test duration 2 the results overflowed so the result cannot be viewed as an absolute value 4 the test was performed while synchronization could not be performed so the result may not be accurate.')
gdcDsx1TestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048576))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1TestResults.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TestResults.setDescription('The results of the last diagnostic test. This can be the current test running or the last completed test. Note that the interpretation of these results may be affected by the value of the gdcDsx1TestExceptions object. The units of the value of this object depend on the type of diagnostic test run. For all cases except a DS0 delay measurement, the units of the value of this object is the number of errors that occurred. For a DS0 delay measurement, the units of the value of this test are milliseconds.')
gdcDsx1ANSIperfTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1), )
if mibBuilder.loadTexts: gdcDsx1ANSIperfTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIperfTable.setDescription('The GDC ANSI Performance table. Information in the entries of this table support the ANSI Scheduled Performance Reports. Entries supply information for both inbound and outbound reports for the last 4 seconds.')
gdcDsx1ANSIperfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1ANSIperfIndex"), (0, "GDCDSX1-MIB", "gdcDsx1ANSIdirection"), (0, "GDCDSX1-MIB", "gdcDsx1ANSIseconds"))
if mibBuilder.loadTexts: gdcDsx1ANSIperfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIperfEntry.setDescription('The GDC ANSI Performance table entry. The information in this entry presents one of the 4 second periods performance data in either the inbound or outbound direction.')
gdcDsx1ANSIperfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIperfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIperfIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
gdcDsx1ANSIdirection = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("outbound", 1), ("inbound", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIdirection.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIdirection.setDescription('Identifies the direction of the report entry. This is either an outbound(1) report or an inbound(2) report.')
gdcDsx1ANSIseconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIseconds.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIseconds.setDescription('Identifies the reporting interval. This has the value 1 to 4 supporting up to the last 4 seconds of performance data.')
gdcDsx1ANSICRCerrorEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))).clone(namedValues=NamedValues(("noErrors", 1), ("errors1", 2), ("errors2to5", 4), ("errors6to10", 8), ("errors11to100", 16), ("errors101to320", 32), ("errors321orMore", 64)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSICRCerrorEvents.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSICRCerrorEvents.setDescription('Identifies the magnitude of the error events in the interval which this entry represents.')
gdcDsx1ANSIsevereErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIsevereErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIsevereErrors.setDescription('Identifies whether or not any severe errors were detected in the interval which this entry represents.')
gdcDsx1ANSIframeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIframeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIframeErrors.setDescription('Identifies whether or not any framing errors were detected in the interval which this entry represents.')
gdcDsx1ANSIcodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIcodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIcodeViolations.setDescription('Identifies whether or not any code violations were detected in the interval which this entry represents.')
gdcDsx1ANSIcontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIcontrolledSlips.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIcontrolledSlips.setDescription('Identifies whether or not any controlled slips were detected in the interval which this entry represents.')
gdcDsx1ANSIactivePayloadLoops = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noEventsDetected", 1), ("eventsDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1ANSIactivePayloadLoops.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1ANSIactivePayloadLoops.setDescription('Identifies whether or not any active payload loops were detected in the interval which this entry represents.')
gdcDsx1CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 2), )
if mibBuilder.loadTexts: gdcDsx1CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CurrentTable.setDescription('The gdcDsx1 Current table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
gdcDsx1CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 2, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1CurrentIndex"))
if mibBuilder.loadTexts: gdcDsx1CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CurrentEntry.setDescription('An entry in the gdcDsx1 Current table.')
gdcDsx1CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CurrentIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
gdcDsx1CurrentLOFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1CurrentLOFCs.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CurrentLOFCs.setDescription('The number of Loss of Frame Counts (LOFCs) encountered by a DS1 interface in the current 15 minute interval.')
gdcDsx1CurrenUserStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1CurrenUserStat.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1CurrenUserStat.setDescription('Returns a bitwise snapshot of the statistics. Octet 1 bit 7 - parity bit 6 - 2^15 Errored Seconds bit 5 - 2^14 bit 4 - 2^15 Severely Errored Seconds bit 3 - 2^14 bit 2 - 2^15 Bursty Errored Seconds bit 1 - 2^14 bit 0 - 1: New Interval Octet 2 bit 7 - parity bit 6 - 2^13 Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - parity bit 6 - 2^6 Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 4 bit 7 - parity bit 6 - 2^13 Severely Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - parity bit 6 - 2^6 Severely Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 6 bit 7 - parity bit 6 - 2^13 Bursty Errored Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - parity bit 6 - 2^6 Bursty Errored Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 8 bit 7 - parity bit 6 - f/u bit 5 - f/u bit 4 - 2^15 Unavailable Seconds bit 3 - 2^14 bit 2 - f/u bit 1 - 2^7 Loss of Frame Count bit 0 - 2^7 Controlled Slip Seconds Octet 9 bit 7 - parity bit 6 - 2^13 Unavailable Seconds bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - parity bit 6 - 2^6 Unavailable Seconds bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 11 bit 7 - parity bit 6 - 2^6 Controlled Slip Second bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 12 bit 7 - parity bit 6 - 2^6 Loss of Frame Count bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Octet 13 bit 7 - parity bit 6 - 2^6 Percent Complete bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 ')
gdcDsx1IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 3), )
if mibBuilder.loadTexts: gdcDsx1IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1IntervalTable.setDescription('The gdcDsx1 Interval table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
gdcDsx1IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 3, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1IntervalIndex"), (0, "GDCDSX1-MIB", "gdcDsx1IntervalNumber"))
if mibBuilder.loadTexts: gdcDsx1IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1IntervalEntry.setDescription('An entry in the DS1 Interval table.')
gdcDsx1IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1IntervalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
gdcDsx1IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1IntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
gdcDsx1IntervalLOFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1IntervalLOFCs.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1IntervalLOFCs.setDescription('The number of Loss of Frame Counts (LOFCs) encountered by a DS1 interface in the current 15 minute interval.')
gdcDsx1TotalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 4), )
if mibBuilder.loadTexts: gdcDsx1TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TotalTable.setDescription('The DS1 Total table. 24 hour interval. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
gdcDsx1TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 4, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1TotalIndex"))
if mibBuilder.loadTexts: gdcDsx1TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TotalEntry.setDescription('An entry in the DS1 Total table.')
gdcDsx1TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TotalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
gdcDsx1TotalLOFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 5, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1TotalLOFCs.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1TotalLOFCs.setDescription('The number of Loss of Frame Counts (LOFCs) encountered by a DS1interface in the current 15 minute interval.')
dsx1AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1))
dsx1NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 1))
dsx1DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 2))
dsx1PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 3))
dsx1NvRamCorrupt = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 4))
dsx1UnitFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 5))
dsx1MbiLock = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 6))
dsx1LocalPwrFail = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 7))
dsx1TimingLoss = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 8))
dsx1StatusChange = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 9))
dsx1UnsoTest = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 10))
dsx1LossOfSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 11))
dsx1LossOfFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 12))
dsx1Ais = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 13))
dsx1ReceivedYellow = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 14))
dsx1UnavailSignalState = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 15))
dsx1ExcessiveZeros = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 16))
dsx1LowAverageDensity = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 17))
dsx1ControlledSlips = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 18))
dsx1BipolarViolations = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 19))
dsx1CrcErrors = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 20))
dsx1FallbackTimingActive = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 2, 1, 21))
gdcDsx1AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 1), )
if mibBuilder.loadTexts: gdcDsx1AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmConfigTable.setDescription('The gdcAlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface. For simplicity sake alarms, be they unit or interface related, are represented in one table.')
gdcDsx1AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 1, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1AlarmConfigIndex"), (0, "GDCDSX1-MIB", "gdcDsx1AlarmConfigIdentifier"))
if mibBuilder.loadTexts: gdcDsx1AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmConfigEntry.setDescription('An entry in the GDC Alarm Configuration table.')
gdcDsx1AlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
gdcDsx1AlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
gdcDsx1AlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("last1sec", 2), ("last1min", 3), ("last1hr", 4), ("infinite", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1AlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmCountWindow.setDescription('This variable sets/reads the BPV alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting. Default: disabled(1)')
gdcDsx1AlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("thresGT10", 1), ("thresGT100", 2), ("thresGT1000", 3), ("thresGT10000", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gdcDsx1AlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmCountThreshold.setDescription('This function sets/reads the BPV alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active. Default: thresGT10(1)')
gdcDsx1AlarmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2), )
if mibBuilder.loadTexts: gdcDsx1AlarmStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmStatusTable.setDescription('The gdcDsx1AlarmStatusTable contains entries that report the status of alarms. The status of an alarm consists of the current alarm status, indicating whether or not the alarm condition is in effect, the number of times the alarm has occurred, the time of the first alarm occurrence, and the time of the last alarm occurrence. The structure of the table is such that alarm status is supported on a unit or interface basis, and then on an alarm type basis within the interface. For simplicity sake and to support the reporting of status of all alarms, a unit is treated as an interface in this table.')
gdcDsx1AlarmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2, 1), ).setIndexNames((0, "GDCDSX1-MIB", "gdcDsx1AlarmStatusIndex"), (0, "GDCDSX1-MIB", "gdcDsx1AlarmStatusIdentifier"))
if mibBuilder.loadTexts: gdcDsx1AlarmStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmStatusEntry.setDescription('An entry in the GDC Alarm Status table.')
gdcDsx1AlarmStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmStatusIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
gdcDsx1AlarmStatusIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmStatusIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmStatusIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
gdcDsx1AlarmCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmCount.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmCount.setDescription('The number of occurrences of this alarm. This objects value is incremented once for each time that the alarm occurs. This count is incremented regardless of whether or not the alarm is masked or is not reporteded because of the threshold configuration. If the network element type does not support this variable, a noSuch will be returned.')
gdcDsx1AlarmFirstOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmFirstOccurrence.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmFirstOccurrence.setDescription('The time at which the alarm first occurred. This is reported as the number of TimeTicks after the interface was initialized. This object along with its companion object, gdcDsx1AlarmLastOccurrence, can be used to provide greater meaning to the value of gdcDsx1AlarmOccurrenceCount by weighing the count over the period of time. If the network element type does not support this variable, a noSuch will be returned.')
gdcDsx1AlarmLastOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 1, 6, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gdcDsx1AlarmLastOccurrence.setStatus('mandatory')
if mibBuilder.loadTexts: gdcDsx1AlarmLastOccurrence.setDescription('The time at which the alarm last occurred. This is reported as the number of TimeTicks after the interface was initialized. This object along with its companion object, gdcDsx1AlarmFirstOccurrence, can be used to provide greater meaning to the value of gdcDsx1AlarmOccurrenceCount by weighing the count over the period of time. If the network element type does not support this variable, a noSuch will be returned.')
mibBuilder.exportSymbols("GDCDSX1-MIB", dsx1=dsx1, gdcDsx1ConfigTable=gdcDsx1ConfigTable, gdcDsx1SetTransmitClkSrc=gdcDsx1SetTransmitClkSrc, dsx1ReceivedYellow=dsx1ReceivedYellow, dsx1StatusChange=dsx1StatusChange, gdcDsx1Version=gdcDsx1Version, gdcDsx1Preequalization=gdcDsx1Preequalization, gdcDsx1MaintenanceEntry=gdcDsx1MaintenanceEntry, gdcDsx1CurrentLOFCs=gdcDsx1CurrentLOFCs, gdcDsx1ConfigMode=gdcDsx1ConfigMode, gdcDsx1AdminRcvRange=gdcDsx1AdminRcvRange, gdcDsx1LoopbackConfig=gdcDsx1LoopbackConfig, dsx1LocalPwrFail=dsx1LocalPwrFail, gdcDsx1System=gdcDsx1System, dsx1ExcessiveZeros=dsx1ExcessiveZeros, gdcDsx1CsuMode=gdcDsx1CsuMode, gdcDsx1InterfaceType=gdcDsx1InterfaceType, gdcDsx1TotalEntry=gdcDsx1TotalEntry, gdcDsx1Redundancy=gdcDsx1Redundancy, gdcDsx1TransmitClockSource=gdcDsx1TransmitClockSource, gdcDsx1OperLineBuildout=gdcDsx1OperLineBuildout, gdcDsx1ANSIframeErrors=gdcDsx1ANSIframeErrors, dsx1AlarmData=dsx1AlarmData, gdcDsx1NetMaintAttenSense=gdcDsx1NetMaintAttenSense, gdcDsx1TotalIndex=gdcDsx1TotalIndex, dsx1NvRamCorrupt=dsx1NvRamCorrupt, gdcDsx1ModelNumber=gdcDsx1ModelNumber, dsx1LossOfSignal=dsx1LossOfSignal, gdc=gdc, gdcDsx1NetMaintenance=gdcDsx1NetMaintenance, gdcDsx1VersionEntry=gdcDsx1VersionEntry, gdcDsx1TotalTable=gdcDsx1TotalTable, gdcDsx1CurrentTable=gdcDsx1CurrentTable, gdcDsx1FirmwareRev=gdcDsx1FirmwareRev, gdcDsx1CircuitIdentifier2=gdcDsx1CircuitIdentifier2, dsx1PowerUpAlm=dsx1PowerUpAlm, dsx1DiagRxErrAlm=dsx1DiagRxErrAlm, dsx1CrcErrors=dsx1CrcErrors, gdcDsx1MaintenanceLineIndex=gdcDsx1MaintenanceLineIndex, gdcDsx1SoftReset=gdcDsx1SoftReset, gdcDsx1DS0Diag=gdcDsx1DS0Diag, dsx1UnsoTest=dsx1UnsoTest, gdcDsx1ActiveFirmwareRev=gdcDsx1ActiveFirmwareRev, gdcDsx1AlarmConfigTable=gdcDsx1AlarmConfigTable, gdcDsx1DiagIndex=gdcDsx1DiagIndex, gdcDsx1IntervalEntry=gdcDsx1IntervalEntry, dsx1LowAverageDensity=dsx1LowAverageDensity, gdcDsx1Alarms=gdcDsx1Alarms, dsx1ControlledSlips=dsx1ControlledSlips, gdcDsx1ANSIperfEntry=gdcDsx1ANSIperfEntry, gdcDsx1ANSIperfIndex=gdcDsx1ANSIperfIndex, gdcDsx1DiagEntry=gdcDsx1DiagEntry, gdcDsx1NetMaintTable=gdcDsx1NetMaintTable, gdcDsx1NetMaintLineIndex=gdcDsx1NetMaintLineIndex, gdcDsx1CurrenUserStat=gdcDsx1CurrenUserStat, gdcDsx1LedStatus=gdcDsx1LedStatus, gdcDsx1ANSIcodeViolations=gdcDsx1ANSIcodeViolations, gdcDsx1IntervalTable=gdcDsx1IntervalTable, gdcDsx1ANSIperfTable=gdcDsx1ANSIperfTable, gdcDsx1TestExceptions=gdcDsx1TestExceptions, dsx1MbiLock=dsx1MbiLock, gdcDsx1AlarmFirstOccurrence=gdcDsx1AlarmFirstOccurrence, gdcDsx1ANSIcontrolledSlips=gdcDsx1ANSIcontrolledSlips, gdcDsx1AdminLineBuildout=gdcDsx1AdminLineBuildout, gdcDsx1NetMaintEntry=gdcDsx1NetMaintEntry, gdcDsx1SysUpTime=gdcDsx1SysUpTime, dsx1TimingLoss=dsx1TimingLoss, gdcDsx1TestResults=gdcDsx1TestResults, gdcDsx1VersionIndex=gdcDsx1VersionIndex, gdcDsx1ANSIseconds=gdcDsx1ANSIseconds, gdcDsx1Configuration=gdcDsx1Configuration, dsx1FallbackTimingActive=dsx1FallbackTimingActive, dsx1Ais=dsx1Ais, gdcDsx1IntervalLOFCs=gdcDsx1IntervalLOFCs, gdcDsx1Diagnostics=gdcDsx1Diagnostics, gdcDsx1IntervalNumber=gdcDsx1IntervalNumber, gdcDsx1AlarmConfigIndex=gdcDsx1AlarmConfigIndex, sc5001=sc5001, gdcDsx1VersionTable=gdcDsx1VersionTable, dsx1UnitFailure=dsx1UnitFailure, dsx1BipolarViolations=dsx1BipolarViolations, gdcDsx1AlarmConfigEntry=gdcDsx1AlarmConfigEntry, gdcDsx1FallbackClockSource=gdcDsx1FallbackClockSource, gdcDsx1ANSIactivePayloadLoops=gdcDsx1ANSIactivePayloadLoops, gdcDsx1TestDuration=gdcDsx1TestDuration, dsx1UnavailSignalState=dsx1UnavailSignalState, gdcDsx1Performance=gdcDsx1Performance, gdcDsx1FrontPanel=gdcDsx1FrontPanel, gdcDsx1CircuitIdentifier1=gdcDsx1CircuitIdentifier1, gdcDsx1InbandLoopCfg=gdcDsx1InbandLoopCfg, gdcDsx1ANSIsevereErrors=gdcDsx1ANSIsevereErrors, gdcDsx1AlarmLastOccurrence=gdcDsx1AlarmLastOccurrence, gdcDsx1AlarmConfigIdentifier=gdcDsx1AlarmConfigIdentifier, gdcDsx1ConfigIndex=gdcDsx1ConfigIndex, gdcDsx1AlarmStatusTable=gdcDsx1AlarmStatusTable, gdcDsx1Maintenance=gdcDsx1Maintenance, gdcDsx1ConfigEntry=gdcDsx1ConfigEntry, dsx1LossOfFrame=dsx1LossOfFrame, gdcDsx1AlarmCount=gdcDsx1AlarmCount, dsx1NoResponseAlm=dsx1NoResponseAlm, gdcDsx1BootRev=gdcDsx1BootRev, gdcDsx1OnesDensity=gdcDsx1OnesDensity, gdcDsx1AISLoopdown=gdcDsx1AISLoopdown, gdcDsx1IntervalIndex=gdcDsx1IntervalIndex, gdcDsx1TestExecutionStatus=gdcDsx1TestExecutionStatus, gdcDsx1DefaultInit=gdcDsx1DefaultInit, gdcDsx1AlarmStatusIdentifier=gdcDsx1AlarmStatusIdentifier, gdcDsx1TotalLOFCs=gdcDsx1TotalLOFCs, gdcDsx1CurrentIndex=gdcDsx1CurrentIndex, gdcDsx1AlarmStatusEntry=gdcDsx1AlarmStatusEntry, gdcDsx1AlarmCountWindow=gdcDsx1AlarmCountWindow, gdcDsx1ANSICRCerrorEvents=gdcDsx1ANSICRCerrorEvents, gdcDsx1AlarmCountThreshold=gdcDsx1AlarmCountThreshold, gdcDsx1LineType=gdcDsx1LineType, gdcDsx1OperRcvRange=gdcDsx1OperRcvRange, gdcDsx1CurrentEntry=gdcDsx1CurrentEntry, gdcDsx1StoredFirmwareStatus=gdcDsx1StoredFirmwareStatus, gdcDsx1DiagTable=gdcDsx1DiagTable, gdcDsx1NetMaintReceiveLevel=gdcDsx1NetMaintReceiveLevel, gdcDsx1AlarmStatusIndex=gdcDsx1AlarmStatusIndex, gdcDsx1SwitchActiveFirmware=gdcDsx1SwitchActiveFirmware, gdcDsx1ResetStats=gdcDsx1ResetStats, gdcDsx1DownloadingMode=gdcDsx1DownloadingMode, gdcDsx1SendCode=gdcDsx1SendCode, gdcDsx1SystemMIBversion=gdcDsx1SystemMIBversion, gdcDsx1MaintenanceTable=gdcDsx1MaintenanceTable, gdcDsx1ANSIdirection=gdcDsx1ANSIdirection, gdcDsx1StoredFirmwareRev=gdcDsx1StoredFirmwareRev)

#
# PySNMP MIB module TRIP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TRIP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:27:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
InetPortNumber, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddress", "InetAddressType")
applRFC2788Group, applIndex = mibBuilder.importSymbols("NETWORK-SERVICES-MIB", "applRFC2788Group", "applIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
TimeTicks, Integer32, Unsigned32, Counter32, IpAddress, Counter64, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, mib_2, iso, ObjectIdentity, ModuleIdentity, Gauge32, Bits, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Integer32", "Unsigned32", "Counter32", "IpAddress", "Counter64", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mib-2", "iso", "ObjectIdentity", "ModuleIdentity", "Gauge32", "Bits", "MibIdentifier")
DateAndTime, TimeInterval, StorageType, RowStatus, TimeStamp, DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TimeInterval", "StorageType", "RowStatus", "TimeStamp", "DisplayString", "TruthValue", "TextualConvention")
TripProtocolVersion, TripSendReceiveMode, TripAddressFamily, TripAppProtocol, TripItad, TripId, TripCommunityId = mibBuilder.importSymbols("TRIP-TC-MIB", "TripProtocolVersion", "TripSendReceiveMode", "TripAddressFamily", "TripAppProtocol", "TripItad", "TripId", "TripCommunityId")
tripMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 116))
tripMIB.setRevisions(('2004-09-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: tripMIB.setRevisionsDescriptions(('The initial version, Published as RFC 3872.',))
if mibBuilder.loadTexts: tripMIB.setLastUpdated('200409020000Z')
if mibBuilder.loadTexts: tripMIB.setOrganization('IETF IPTel Working Group. Mailing list: iptel@lists.bell-labs.com')
if mibBuilder.loadTexts: tripMIB.setContactInfo('Co-editor David Zinman postal: 265 Ridley Blvd. Toronto ON, M5M 4N8 Canada email: dzinman@rogers.com phone: +1 416 433 4298 Co-editor: David Walker Sedna Wireless Inc. postal: 495 March Road, Suite 500 Ottawa, ON K2K 3G1 Canada email: david.walker@sedna-wireless.com phone: +1 613 878 8142 Co-editor Jianping Jiang Syndesis Limited postal: 30 Fulton Way Richmond Hill, ON L4B 1J5 Canada email: jjiang@syndesis.com phone: +1 905 886-7818 x2515 ')
if mibBuilder.loadTexts: tripMIB.setDescription('The MIB module describing Telephony Routing over IP (TRIP). TRIP is a policy driven inter-administrative domain protocol for advertising the reachability of telephony destinations between location servers (LS), and for advertising attributes of the routes to those destinations. Copyright (C) The Internet Society (2004). This version of this MIB module is part of RFC 3872, see the RFC itself for full legal notices.')
tripMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 116, 0))
tripMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 116, 1))
tripMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 116, 2))
tripMIBNotifObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 116, 3))
tripMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 116, 2, 1))
tripMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 116, 2, 2))
tripCfgTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 1), )
if mibBuilder.loadTexts: tripCfgTable.setStatus('current')
if mibBuilder.loadTexts: tripCfgTable.setDescription("This table contains the common configuration objects applicable to all TRIP applications referenced by the applIndex. Each row represents those objects for a particular TRIP LS present in this system. The instances of TRIP LS's are uniquely identified by the applIndex. The objects in this table SHOULD be nonVolatile and survive a reboot.")
tripCfgEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 1, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"))
if mibBuilder.loadTexts: tripCfgEntry.setStatus('current')
if mibBuilder.loadTexts: tripCfgEntry.setDescription('A row of common configuration.')
tripCfgProtocolVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 1), TripProtocolVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripCfgProtocolVersion.setReference('RFC 3219, section 4.2.')
if mibBuilder.loadTexts: tripCfgProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: tripCfgProtocolVersion.setDescription('This object will reflect the version of TRIP supported by this system. It follows the same format as TRIP version information contained in the TRIP messages generated by this TRIP entity.')
tripCfgItad = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 2), TripItad()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgItad.setStatus('current')
if mibBuilder.loadTexts: tripCfgItad.setDescription('The Internet Telephony Administrative domain (ITAD) of this LS.')
tripCfgIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 3), TripId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripCfgIdentifier.setStatus('current')
if mibBuilder.loadTexts: tripCfgIdentifier.setDescription('The object that identifies this TRIP Client.')
tripCfgAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tripCfgAdminStatus.setDescription('The desired TRIP state. up(1) : Set the application to normal operation. down(2): Set the application to a state where it will not process TRIP messages. Setting this object should be reflected in tripCfgOperStatus. If an unknown error occurs tripCfgOperStatus will return unknown(0).')
tripCfgOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("up", 1), ("down", 2), ("faulty", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripCfgOperStatus.setStatus('current')
if mibBuilder.loadTexts: tripCfgOperStatus.setDescription('The current operational state of the TRIP protocol. unknown(0): The operating status of the application is unknown. up(1): The application is operating normally, and is ready to process (receive and issue) TRIP requests and responses. down(2): The application is currently not processing TRIP messages. This occurs if the TRIP application is in an initialization state or if tripCfgAdminStatus is set to down(2). faulty(3): The application is not operating normally due to a fault in the system. If tripCfgAdminStatus is down(2) then tripOperStatus SHOULD be down(2). If tripAdminStatus is changed to up(1) then tripOperStatus SHOULD change to up(1) if there is no fault that prevents the TRIP protocol from moving to the up(1) state.')
tripCfgAddrIAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripCfgAddrIAddrType.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripCfgAddrIAddrType.setStatus('current')
if mibBuilder.loadTexts: tripCfgAddrIAddrType.setDescription('The type of Inet Address of the tripAddr.')
tripCfgAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripCfgAddr.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripCfgAddr.setStatus('current')
if mibBuilder.loadTexts: tripCfgAddr.setDescription('The network address of the local LS that the peer connects to. The type of address depends on the object tripCfgAddrIAddrType. The type of this address is determined by the value of the tripCfgAddrIAddrType object.')
tripCfgPort = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 8), InetPortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgPort.setStatus('current')
if mibBuilder.loadTexts: tripCfgPort.setDescription('The local tcp/udp port on the local LS that the peer connects to.')
tripCfgMinItadOriginationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(30)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgMinItadOriginationInterval.setStatus('current')
if mibBuilder.loadTexts: tripCfgMinItadOriginationInterval.setDescription("The minimum amount of time that MUST elapse between advertisement of the update message that reports changes within the LS's own ITAD.")
tripCfgMinRouteAdvertisementInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(30)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgMinRouteAdvertisementInterval.setStatus('current')
if mibBuilder.loadTexts: tripCfgMinRouteAdvertisementInterval.setDescription('Specifies minimal interval between successive advertisements to a particular destination from an LS.')
tripCfgMaxPurgeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(10)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgMaxPurgeTime.setStatus('current')
if mibBuilder.loadTexts: tripCfgMaxPurgeTime.setDescription('Indicates the interval that the LS MUST maintain routes marked as withdrawn in its database.')
tripCfgDisableTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(180)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgDisableTime.setStatus('current')
if mibBuilder.loadTexts: tripCfgDisableTime.setDescription('Indicates the interval that the TRIP module of the LS MUST be disabled while routes originated by this LS with high sequence numbers can be removed.')
tripCfgSendReceiveMode = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 13), TripSendReceiveMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripCfgSendReceiveMode.setStatus('current')
if mibBuilder.loadTexts: tripCfgSendReceiveMode.setDescription('The operational mode of the TRIP entity running on this system.')
tripCfgStorage = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 1, 1, 14), StorageType().clone('nonVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tripCfgStorage.setStatus('current')
if mibBuilder.loadTexts: tripCfgStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
tripRouteTypeTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 2), )
if mibBuilder.loadTexts: tripRouteTypeTable.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypeTable.setDescription('The TRIP peer Route Type table contains one entry per supported protocol - address family pair. The objects in this table are volatile and are refreshed after a reboot.')
tripRouteTypeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 2, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripRouteTypeAddrInetType"), (0, "TRIP-MIB", "tripRouteTypeAddr"), (0, "TRIP-MIB", "tripRouteTypePort"), (0, "TRIP-MIB", "tripRouteTypeProtocolId"), (0, "TRIP-MIB", "tripRouteTypeAddrFamilyId"))
if mibBuilder.loadTexts: tripRouteTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypeEntry.setDescription('An entry containing information about the route type that a particular TRIP entity supports. Each entry represents information about either the local or a remote LS peer. The object tripRouteTypePeer is used to distinguish this. In the case of a local LS, the address/port information will reflect the values configured in tripCfgTable. In the case of a remote peer, the address/port information will reflect the values of an entry in the tripPeerTable. Implementation need to be aware that if the size of tripRouteTypeAddr exceeds 111 sub-IDs, then OIDs of column instances in this table will have more than 128 sub-IDs and cannot be accessed using SNMPv1, SNMPv2c, or snmpv3.')
tripRouteTypeAddrInetType = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: tripRouteTypeAddrInetType.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripRouteTypeAddrInetType.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypeAddrInetType.setDescription('The type of Inet Address of the tripRouteTypeAddr.')
tripRouteTypeAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 2, 1, 2), InetAddress())
if mibBuilder.loadTexts: tripRouteTypeAddr.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripRouteTypeAddr.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypeAddr.setDescription("The network address of this entry's TRIP peer LS. The type of this address is determined by the value of the tripRouteTypeAddrInetType object.")
tripRouteTypePort = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 2, 1, 3), InetPortNumber())
if mibBuilder.loadTexts: tripRouteTypePort.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypePort.setDescription('The port for the TCP connection between this and an associated TRIP peer.')
tripRouteTypeProtocolId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 2, 1, 4), TripAppProtocol())
if mibBuilder.loadTexts: tripRouteTypeProtocolId.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypeProtocolId.setDescription('The object identifier of a protocol that the associated peer is using.')
tripRouteTypeAddrFamilyId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 2, 1, 5), TripAddressFamily())
if mibBuilder.loadTexts: tripRouteTypeAddrFamilyId.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypeAddrFamilyId.setDescription('The object identifier of an address family that the associated peer belongs to.')
tripRouteTypePeer = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteTypePeer.setStatus('current')
if mibBuilder.loadTexts: tripRouteTypePeer.setDescription("This object identifies whether this entry is associated with a 'local' or 'remote' LS peer.")
tripSupportedCommunityTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 3), )
if mibBuilder.loadTexts: tripSupportedCommunityTable.setReference('RFC 3219, section 5.9')
if mibBuilder.loadTexts: tripSupportedCommunityTable.setStatus('current')
if mibBuilder.loadTexts: tripSupportedCommunityTable.setDescription('The list of TRIP communities that this LS supports. A TRIP community is a group of destinations that share common properties. The TRIP Supported Communities entry is used to group destinations so that the routing decision can be based on the identity of the group.')
tripSupportedCommunityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 3, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripSupportedCommunityId"))
if mibBuilder.loadTexts: tripSupportedCommunityEntry.setStatus('current')
if mibBuilder.loadTexts: tripSupportedCommunityEntry.setDescription('Entry containing information about a community. A TRIP community is a group of destinations that share some common property. This attribute is used so that routing decisions can be based on the identity of the group.')
tripSupportedCommunityId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 3, 1, 1), TripCommunityId())
if mibBuilder.loadTexts: tripSupportedCommunityId.setStatus('current')
if mibBuilder.loadTexts: tripSupportedCommunityId.setDescription('The identifier of the supported Community.')
tripSupportedCommunityItad = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 3, 1, 2), TripItad()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripSupportedCommunityItad.setStatus('current')
if mibBuilder.loadTexts: tripSupportedCommunityItad.setDescription('The ITAD of the community.')
tripSupportedCommunityStorage = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 3, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripSupportedCommunityStorage.setStatus('current')
if mibBuilder.loadTexts: tripSupportedCommunityStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write- access to any columnar objects in the row. It is not a requirement that this storage be non volatile.")
tripSupportedCommunityRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripSupportedCommunityRowStatus.setStatus('current')
if mibBuilder.loadTexts: tripSupportedCommunityRowStatus.setDescription('The row status of the entry. This object is REQUIRED to create or delete rows by a manager. A value for tripSupportedCommunityItad MUST be set for row creation to be successful. If the instance already exists for a particular applIndex, the row create operation will fail. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
tripPeerTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 4), )
if mibBuilder.loadTexts: tripPeerTable.setStatus('current')
if mibBuilder.loadTexts: tripPeerTable.setDescription('The TRIP peer table. This table contains one entry per TRIP peer, and information about the connection with the peer.')
tripPeerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 4, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripPeerRemoteAddrInetType"), (0, "TRIP-MIB", "tripPeerRemoteAddr"), (0, "TRIP-MIB", "tripPeerRemotePort"))
if mibBuilder.loadTexts: tripPeerEntry.setStatus('current')
if mibBuilder.loadTexts: tripPeerEntry.setDescription('Entry containing information about the connection with a TRIP peer. Implementation need to be aware that if the size of tripPeerRemoteAddr exceeds 113 sub-IDs, then OIDs of column instances in this table will have more than 128 sub-IDs and cannot be accessed using SNMPv1, SNMPv2c, or snmpv3.')
tripPeerRemoteAddrInetType = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: tripPeerRemoteAddrInetType.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripPeerRemoteAddrInetType.setStatus('current')
if mibBuilder.loadTexts: tripPeerRemoteAddrInetType.setDescription('The type of Inet Address of the tripPeerRemoteAddr.')
tripPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: tripPeerRemoteAddr.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: tripPeerRemoteAddr.setDescription("The IP address of this entry's TRIP peer LS. The type of this address is determined by the value of the tripPeerRemoteAddrInetType object.")
tripPeerRemotePort = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 3), InetPortNumber())
if mibBuilder.loadTexts: tripPeerRemotePort.setStatus('current')
if mibBuilder.loadTexts: tripPeerRemotePort.setDescription('The remote port for the TCP connection between the TRIP peers.')
tripPeerIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 4), TripId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerIdentifier.setStatus('current')
if mibBuilder.loadTexts: tripPeerIdentifier.setDescription('TRIP identifier of the peer.')
tripPeerState = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("openSent", 4), ("openConfirm", 5), ("established", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerState.setStatus('current')
if mibBuilder.loadTexts: tripPeerState.setDescription('TRIP Peer Finite State Machine state. idle(1) : The initial state. Local LS refuses all incoming connections. No application resources are allocated to processing information about the remote peer. connect(2) : Local LS waiting for a transport protocol connection to be completed to the peer, and is listening for inbound transport connections from the peer. active(3) : Local LS is listening for an inbound connection from the peer, but is not in the process of initiating a connection to the remote peer. openSent(4) : Local LS has sent an OPEN message to its peer and is waiting for an OPEN message from the remote peer. openConfirm(5): Local LS has sent an OPEN message to the remote peer, received an OPEN message from the remote peer, and sent a KEEPALIVE message in response to the OPEN. The local LS is now waiting for a KEEPALIVE message or a NOTIFICATION message in response to its OPEN message. established(6): LS can exchange UPDATE, NOTIFICATION, and KEEPALIVE messages with its peer.')
tripPeerAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tripPeerAdminStatus.setDescription('This object is used to affect the TRIP connection state. up(1) : Allow a connection with the peer LS. down(2) : disconnect the connection from the peer LS and do not allow any further connections to this peer. If this value is set to down(2) then tripPeerState will have the value of idle(1).')
tripPeerNegotiatedVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 7), TripProtocolVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerNegotiatedVersion.setStatus('current')
if mibBuilder.loadTexts: tripPeerNegotiatedVersion.setDescription('The negotiated version of TRIP running between this local entity and this peer.')
tripPeerSendReceiveMode = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 8), TripSendReceiveMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerSendReceiveMode.setStatus('current')
if mibBuilder.loadTexts: tripPeerSendReceiveMode.setDescription('The operational mode of this peer.')
tripPeerRemoteItad = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 9), TripItad()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerRemoteItad.setStatus('current')
if mibBuilder.loadTexts: tripPeerRemoteItad.setDescription('The Internet Telephony Administrative domain of this peer.')
tripPeerConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(120)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerConnectRetryInterval.setStatus('current')
if mibBuilder.loadTexts: tripPeerConnectRetryInterval.setDescription('Specifies the initial amount of time that will elapse between connection retry. This value SHOULD double after each attempt up to the value of tripPeerMaxRetryInterval. This value MUST always be less than or equal to the value of tripPeerMaxRetryInterval. Attempts to set this value higher than the max retry will not be allowed.')
tripPeerMaxRetryInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(360)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerMaxRetryInterval.setStatus('current')
if mibBuilder.loadTexts: tripPeerMaxRetryInterval.setDescription('Specifies the maximum amount of time that will elapse between connection retries. Once the value of tripPeerConnectRetryInterval has reached this value, no more retries will be attempted. Attempts to set this value lower than the retry interval SHOULD not be allowed.')
tripPeerHoldTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerHoldTime.setStatus('current')
if mibBuilder.loadTexts: tripPeerHoldTime.setDescription('The time interval in seconds for the hold timer that is established with the peer. The value of this object is the smaller of the values in tripPeerHoldTimeConfigured and the hold time received in the open message.')
tripPeerKeepAlive = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerKeepAlive.setStatus('current')
if mibBuilder.loadTexts: tripPeerKeepAlive.setDescription('Specifies the amount of time that MUST elapse between keep alive messages. This value is negotiated with the remote when a connection is established.')
tripPeerHoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 65535), )).clone(240)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerHoldTimeConfigured.setStatus('current')
if mibBuilder.loadTexts: tripPeerHoldTimeConfigured.setDescription('Specifies the maximum time that MAY elapse between the receipt of successive keepalive or update message. A value of 0 means that keepalive or update messages will not be sent.')
tripPeerKeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(30)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerKeepAliveConfigured.setStatus('current')
if mibBuilder.loadTexts: tripPeerKeepAliveConfigured.setDescription('Specifies the amount of time that MUST elapse between keep alive messages.')
tripPeerMaxPurgeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerMaxPurgeTime.setStatus('current')
if mibBuilder.loadTexts: tripPeerMaxPurgeTime.setDescription('Indicates the interval that the LS MUST maintain routes marked as withdrawn in its database.')
tripPeerDisableTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(180)).setUnits('Seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerDisableTime.setStatus('current')
if mibBuilder.loadTexts: tripPeerDisableTime.setDescription('Indicate the interval that the TRIP module of the remote peer LS MUST be disabled while routes originated by the local LS with high sequence numbers can be removed.')
tripPeerLearned = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 18), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerLearned.setStatus('current')
if mibBuilder.loadTexts: tripPeerLearned.setDescription('Indicates whether this entry was learned or configured.')
tripPeerStorage = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 19), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerStorage.setStatus('current')
if mibBuilder.loadTexts: tripPeerStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write- access to any columnar objects in the row. It is not a requirement that this storage be non volatile.")
tripPeerRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 4, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tripPeerRowStatus.setStatus('current')
if mibBuilder.loadTexts: tripPeerRowStatus.setDescription('The row status of the entry. This object is REQUIRED to create or delete rows remotely by a manager. If the instance already exists for a particular applIndex, the row create operation will fail. The value of this object has no effect on whether other objects in this conceptual row can be modified. Entries in this table can be learned by the TRIP application, or provisioned through this table.')
tripPeerStatisticsTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 5), )
if mibBuilder.loadTexts: tripPeerStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: tripPeerStatisticsTable.setDescription('The TRIP peer stats table. This table contains one entry per remote TRIP peer, and statistics related to the connection with the remote peer. The objects in this table are volatile.')
tripPeerStatisticsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 5, 1), )
tripPeerEntry.registerAugmentions(("TRIP-MIB", "tripPeerStatisticsEntry"))
tripPeerStatisticsEntry.setIndexNames(*tripPeerEntry.getIndexNames())
if mibBuilder.loadTexts: tripPeerStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: tripPeerStatisticsEntry.setDescription('Entry containing information about the connection with a TRIP peer.')
tripPeerInUpdates = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerInUpdates.setStatus('current')
if mibBuilder.loadTexts: tripPeerInUpdates.setDescription('The number of TRIP update messages received from this remote peer since the last restart of this location server.')
tripPeerOutUpdates = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerOutUpdates.setStatus('current')
if mibBuilder.loadTexts: tripPeerOutUpdates.setDescription('The number of TRIP update messages sent to this remote peer since the last restart of this LS.')
tripPeerInTotalMessages = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerInTotalMessages.setStatus('current')
if mibBuilder.loadTexts: tripPeerInTotalMessages.setDescription('The total number of TRIP messages received from the remote peer on this connection since the last restart of this LS.')
tripPeerOutTotalMessages = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerOutTotalMessages.setStatus('current')
if mibBuilder.loadTexts: tripPeerOutTotalMessages.setDescription('The total number of outgoing TRIP messages sent to the remote peer since the last restart of this LS.')
tripPeerFsmEstablishedTransitions = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerFsmEstablishedTransitions.setStatus('current')
if mibBuilder.loadTexts: tripPeerFsmEstablishedTransitions.setDescription('The number of times the remote peer has transitioned into the established state since the last restart of this LS.')
tripPeerFsmEstablishedTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerFsmEstablishedTime.setStatus('current')
if mibBuilder.loadTexts: tripPeerFsmEstablishedTime.setDescription("Indicates the time and date that this remote peer entered the 'established' state.")
tripPeerInUpdateElapsedTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 7), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerInUpdateElapsedTime.setStatus('current')
if mibBuilder.loadTexts: tripPeerInUpdateElapsedTime.setDescription('Elapsed time in hundredths of seconds since the last TRIP update message was received from this remote peer.')
tripPeerStateChangeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 5, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripPeerStateChangeTime.setStatus('current')
if mibBuilder.loadTexts: tripPeerStateChangeTime.setDescription('The value of sysUpTime when the last state change of tripPeerState took place.')
tripRouteTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 6), )
if mibBuilder.loadTexts: tripRouteTable.setStatus('current')
if mibBuilder.loadTexts: tripRouteTable.setDescription('The TRIP route table containing information about reachable routes that are to be added to service by the receiving LS. The objects in this table are volatile and are refreshed when this LS rediscovers its route table.')
tripRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 6, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripRouteAppProtocol"), (0, "TRIP-MIB", "tripRouteAddressFamily"), (0, "TRIP-MIB", "tripRouteAddress"), (0, "TRIP-MIB", "tripRoutePeer"))
if mibBuilder.loadTexts: tripRouteEntry.setStatus('current')
if mibBuilder.loadTexts: tripRouteEntry.setDescription('Information about a route to a called destination.')
tripRouteAppProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 1), TripAppProtocol())
if mibBuilder.loadTexts: tripRouteAppProtocol.setStatus('current')
if mibBuilder.loadTexts: tripRouteAppProtocol.setDescription('The protocol for which this entry of the routing table is maintained.')
tripRouteAddressFamily = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 2), TripAddressFamily())
if mibBuilder.loadTexts: tripRouteAddressFamily.setStatus('current')
if mibBuilder.loadTexts: tripRouteAddressFamily.setDescription('Specifies the type of address for the destination route.')
tripRouteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 105)))
if mibBuilder.loadTexts: tripRouteAddress.setReference('RFC 3219, section 5.1.1.1.')
if mibBuilder.loadTexts: tripRouteAddress.setStatus('current')
if mibBuilder.loadTexts: tripRouteAddress.setDescription('This is the address (prefix) of the family type given by Address Family of the destination. It is the prefix of addresses reachable from this gateway via the next hop server. The SIZE value of 105 has been assigned due to the sub identifier of object types length limitation as defined in SMIv2.')
tripRoutePeer = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 4), TripId())
if mibBuilder.loadTexts: tripRoutePeer.setStatus('current')
if mibBuilder.loadTexts: tripRoutePeer.setDescription('The identifier of the peer where the route information was learned.')
tripRouteTRIBMask = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 5), Bits().clone(namedValues=NamedValues(("adjTribIns", 0), ("extTrib", 1), ("locTrib", 2), ("adjTribOut", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteTRIBMask.setReference('RFC 3291, section 3.5.')
if mibBuilder.loadTexts: tripRouteTRIBMask.setStatus('current')
if mibBuilder.loadTexts: tripRouteTRIBMask.setDescription('Indicates which Telephony Routing Information Base (TRIB) this entry belongs to. This is a bit-map of possible types. If the bit has a value of 1, then the entry is a member of the corresponding TRIB type. If the bit has a value of 0 then the entry is not a member of the TRIP type. The various bit positions are: 0 adjTribIns The entry is of type adj-TRIBs-ins, stores routing information that has been learned from inbound UPDATE messages. 1 extTrib The entry is of type ext-TRIB, the best route for a given destination. 2 locTrib The entry is of type loc-TRIB contains the local TRIP routing information that the LS has selected. 3 adjTribOut The entry is of type adj-TRIBs-out, stores the information that the local LS has selected for advertisement to its external peers.')
tripRouteAddressSequenceNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteAddressSequenceNumber.setStatus('current')
if mibBuilder.loadTexts: tripRouteAddressSequenceNumber.setDescription('Indicates the version of the destination route originated by the LS identified by tripRouteAddressOriginatorId intra-domain attribute.')
tripRouteAddressOriginatorId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 7), TripId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteAddressOriginatorId.setStatus('current')
if mibBuilder.loadTexts: tripRouteAddressOriginatorId.setDescription('This is an intra-domain attribute indicating the internal LS that originated the route into the ITAD.')
tripRouteNextHopServerIAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteNextHopServerIAddrType.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripRouteNextHopServerIAddrType.setStatus('current')
if mibBuilder.loadTexts: tripRouteNextHopServerIAddrType.setDescription('The type of Inet Address of the tripRouteNextHopServer.')
tripRouteNextHopServer = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteNextHopServer.setStatus('current')
if mibBuilder.loadTexts: tripRouteNextHopServer.setDescription('Indicates the next hop that messages of a given protocol destined for tripRouteAddress SHOULD be sent to. The type of this address is determined by the value of the tripRouteNextHopServerIAddrType object.')
tripRouteNextHopServerPort = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 10), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteNextHopServerPort.setStatus('current')
if mibBuilder.loadTexts: tripRouteNextHopServerPort.setDescription('The port of the next hop server that this route will use.')
tripRouteNextHopServerItad = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 11), TripItad()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteNextHopServerItad.setStatus('current')
if mibBuilder.loadTexts: tripRouteNextHopServerItad.setDescription('Indicates the domain of the next hop.')
tripRouteMultiExitDisc = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteMultiExitDisc.setReference('RFC 3219, section 5.8')
if mibBuilder.loadTexts: tripRouteMultiExitDisc.setStatus('current')
if mibBuilder.loadTexts: tripRouteMultiExitDisc.setDescription('The Multiple Exit Discriminator allows an LS to discriminate between, and indicate preference for, otherwise similar routes to a neighbouring domain. A higher value represents a more preferred routing object.')
tripRouteLocalPref = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteLocalPref.setReference('RFC 3219, section 4.3.4.7')
if mibBuilder.loadTexts: tripRouteLocalPref.setStatus('current')
if mibBuilder.loadTexts: tripRouteLocalPref.setDescription("Indicated the local LS's degree of preference for an advertised route destination.")
tripRouteAdvertisementPath = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteAdvertisementPath.setReference('RFC 3219, section 4.3.4.4')
if mibBuilder.loadTexts: tripRouteAdvertisementPath.setStatus('current')
if mibBuilder.loadTexts: tripRouteAdvertisementPath.setDescription('Identifies the sequence of domains through which this advertisement has passed. This object is probably best represented as sequence of TripItads. For SMI compatibility, though, it is represented as an OCTET STRING. This object is a sequence of ITADs where each set of 4 octets corresponds to a TRIP ITAD in network byte order.')
tripRouteRoutedPath = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteRoutedPath.setReference('RFC 3219, section 4.3.4.5')
if mibBuilder.loadTexts: tripRouteRoutedPath.setStatus('current')
if mibBuilder.loadTexts: tripRouteRoutedPath.setDescription('Identifies the ITADs through which messages sent using this route would pass. These are a subset of tripRouteAdvertisementPath. This object is probably best represented as sequence of TripItads. For SMI compatibility, though, it is represented as OCTET STRING. This object is a sequence of ITADs where each set of 4 octets corresponds to a TRIP ITAD in network byte order.')
tripRouteAtomicAggregate = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteAtomicAggregate.setReference('RFC 3219, section 4.3.4.6')
if mibBuilder.loadTexts: tripRouteAtomicAggregate.setStatus('current')
if mibBuilder.loadTexts: tripRouteAtomicAggregate.setDescription('Indicates that a route MAY traverse domains not listed in tripRouteRoutedPath. If an LS selects the less specific route from a set of overlapping routes, then this value returns TRUE.')
tripRouteUnknown = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteUnknown.setReference('RFC 3219, sections 4.3.1, 4.3.2.3')
if mibBuilder.loadTexts: tripRouteUnknown.setStatus('current')
if mibBuilder.loadTexts: tripRouteUnknown.setDescription('This object contains one or more attributes that were not understood, and because they were transitive, were dropped during aggregation. They take the format of a triple <attribute type, attribute length, attribute value>, of variable length. If no attributes were dropped, this returns an OCTET STRING of size 0.')
tripRouteWithdrawn = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteWithdrawn.setStatus('current')
if mibBuilder.loadTexts: tripRouteWithdrawn.setDescription('Indicates if this route is to be removed from service by the receiving LS.')
tripRouteConverted = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteConverted.setStatus('current')
if mibBuilder.loadTexts: tripRouteConverted.setDescription('Indicates if this route has been converted to a different application protocol than it had originally.')
tripRouteReceivedTime = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 6, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteReceivedTime.setStatus('current')
if mibBuilder.loadTexts: tripRouteReceivedTime.setDescription('The value of sysUpTime when this route was received.')
tripRouteCommunityTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 7), )
if mibBuilder.loadTexts: tripRouteCommunityTable.setReference('RFC 3219, section 5.9.')
if mibBuilder.loadTexts: tripRouteCommunityTable.setStatus('current')
if mibBuilder.loadTexts: tripRouteCommunityTable.setDescription('A table containing a list of TRIP communities associated with a route. Each instance of tripRouteTypeEntry that has the tripRouteTypePeer object set to remote(2) has an instance in the tripRouteTable as a parent. The objects in this table are volatile and are refreshed after a reboot.')
tripRouteCommunityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 7, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripRouteAppProtocol"), (0, "TRIP-MIB", "tripRouteAddressFamily"), (0, "TRIP-MIB", "tripRouteAddress"), (0, "TRIP-MIB", "tripRoutePeer"), (0, "TRIP-MIB", "tripRouteCommunityId"))
if mibBuilder.loadTexts: tripRouteCommunityEntry.setStatus('current')
if mibBuilder.loadTexts: tripRouteCommunityEntry.setDescription('Information about communities associated with a route. An entry with a tripRouteAddress of 00 and a tripRoutePeer of 0 refers to the local LS.')
tripRouteCommunityId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 7, 1, 1), TripCommunityId())
if mibBuilder.loadTexts: tripRouteCommunityId.setStatus('current')
if mibBuilder.loadTexts: tripRouteCommunityId.setDescription('The community identifier.')
tripRouteCommunityItad = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 7, 1, 2), TripItad()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripRouteCommunityItad.setStatus('current')
if mibBuilder.loadTexts: tripRouteCommunityItad.setDescription('The ITAD associated with this community.')
tripItadTopologyTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 8), )
if mibBuilder.loadTexts: tripItadTopologyTable.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyTable.setDescription('The sequence of link connections between peers within an ITAD. The objects in this table are volatile and are refreshed after a reboot.')
tripItadTopologyEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 8, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripItadTopologyOrigId"))
if mibBuilder.loadTexts: tripItadTopologyEntry.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyEntry.setDescription('Information about a peer of the LS identified by tripItadTopologyOrigId.')
tripItadTopologyOrigId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 8, 1, 1), TripId())
if mibBuilder.loadTexts: tripItadTopologyOrigId.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyOrigId.setDescription('Indicates the internal LS that originated the ITAD topology information into the ITAD.')
tripItadTopologySeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripItadTopologySeqNum.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologySeqNum.setDescription('Indicates the version of the ITAD topology originated by the LS identified by tripItadTopologyOrigId.')
tripItadTopologyIdTable = MibTable((1, 3, 6, 1, 2, 1, 116, 1, 9), )
if mibBuilder.loadTexts: tripItadTopologyIdTable.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyIdTable.setDescription("The list of other LS's within the ITAD domain that the LS identified by tripItadTopologyOrigId is currently peering. Each instance of tripItadTopologyIdEntry has an instance in the tripItadTopologyTable as a parent. The objects in this table are volatile and are refreshed after a reboot.")
tripItadTopologyIdEntry = MibTableRow((1, 3, 6, 1, 2, 1, 116, 1, 9, 1), ).setIndexNames((0, "NETWORK-SERVICES-MIB", "applIndex"), (0, "TRIP-MIB", "tripItadTopologyOrigId"), (0, "TRIP-MIB", "tripItadTopologyId"))
if mibBuilder.loadTexts: tripItadTopologyIdEntry.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyIdEntry.setDescription('Information about a peer to the LS identified by tripItadTopologyOrigId.')
tripItadTopologyId = MibTableColumn((1, 3, 6, 1, 2, 1, 116, 1, 9, 1, 1), TripId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tripItadTopologyId.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyId.setDescription('The index into this entry. Indicates the other location servers within the ITAD domain that this LS identified by tripItadTopologyOrigId is currently peering.')
tripNotifApplIndex = MibScalar((1, 3, 6, 1, 2, 1, 116, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tripNotifApplIndex.setReference('RFC 2788, section 3.')
if mibBuilder.loadTexts: tripNotifApplIndex.setStatus('current')
if mibBuilder.loadTexts: tripNotifApplIndex.setDescription('This object contains the application Index. It is used to bind this notification with a specific instance of TRIP entity.')
tripNotifPeerAddrInetType = MibScalar((1, 3, 6, 1, 2, 1, 116, 3, 2), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tripNotifPeerAddrInetType.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripNotifPeerAddrInetType.setStatus('current')
if mibBuilder.loadTexts: tripNotifPeerAddrInetType.setDescription('The type of Inet Address of the tripNotifPeerAddr.')
tripNotifPeerAddr = MibScalar((1, 3, 6, 1, 2, 1, 116, 3, 3), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tripNotifPeerAddr.setReference('RFC 3291, section 3.')
if mibBuilder.loadTexts: tripNotifPeerAddr.setStatus('current')
if mibBuilder.loadTexts: tripNotifPeerAddr.setDescription("The IP address of this entry's TRIP peer LS. This object contains the value of tripPeerRemoteAddr. The type of this address is determined by the value of the tripNotifPeerAddrInetType object.")
tripNotifPeerErrCode = MibScalar((1, 3, 6, 1, 2, 1, 116, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("messageHeader", 1), ("openMessage", 2), ("updateMessage", 3), ("holdTimerExpired", 4), ("finiteStateMachine", 5), ("cease", 6), ("tripNotification", 7)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tripNotifPeerErrCode.setStatus('current')
if mibBuilder.loadTexts: tripNotifPeerErrCode.setDescription('Notification message of TRIP error. The meaning of this value is applicable to the following functions: messageHeader(1) - All errors detected while processing the TRIP message header. openMessage(2) - All errors detected while processing the OPEN message. updateMessage(3) - All errors detected while processing the UPDATE message. holdTimerExpired(4) - A notification generated when the hold timer expires. finiteStateMachine(5) - All errors detected by the TRIP Finite State Machine. cease(6) - Any fatal error condition that the rest of the values do not cover. tripNotification(7) - Any error encountered while sending a notification message.')
tripNotifPeerErrSubcode = MibScalar((1, 3, 6, 1, 2, 1, 116, 3, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tripNotifPeerErrSubcode.setStatus('current')
if mibBuilder.loadTexts: tripNotifPeerErrSubcode.setDescription('The sub error code associated with error code. The meaning of this value is dependent on the value of tripNotifPeerErrCode. Message Header (1) Error Subcodes: 1 - Bad Message Length. 2 - Bad Message Type. OPEN Message (2) Error Subcodes: 1 - Unsupported Version Number. 2 - Bad Peer ITAD. 3 - Bad TRIP Identifier. 4 - Unsupported Optional Parameter. 5 - Unacceptable Hold Time. 6 - Unsupported Capability. 7 - Capability Mismatch. UPDATE Message (3) Error Subcodes: 1 - Malformed Attribute List. 2 - Unrecognized Well-known Attribute. 3 - Missing Well-known Mandatory Attribute. 4 - Attribute Flags Error. 5 - Attribute Length Error. 6 - Invalid Attribute.')
tripConnectionEstablished = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 1)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"))
if mibBuilder.loadTexts: tripConnectionEstablished.setStatus('current')
if mibBuilder.loadTexts: tripConnectionEstablished.setDescription('The TRIP Connection Established event is generated when the TRIP finite state machine enters the ESTABLISHED state.')
tripConnectionDropped = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 2)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"))
if mibBuilder.loadTexts: tripConnectionDropped.setStatus('current')
if mibBuilder.loadTexts: tripConnectionDropped.setDescription('The TRIP Connection Dropped event is generated when the TRIP finite state machine leaves the ESTABLISHED state.')
tripFSM = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 3)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"), ("TRIP-MIB", "tripNotifPeerErrCode"), ("TRIP-MIB", "tripNotifPeerErrSubcode"), ("TRIP-MIB", "tripPeerState"))
if mibBuilder.loadTexts: tripFSM.setStatus('current')
if mibBuilder.loadTexts: tripFSM.setDescription('The trip FSM Event is generated when any error is detected by the TRIP Finite State Machine.')
tripOpenMessageError = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 4)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"), ("TRIP-MIB", "tripNotifPeerErrCode"), ("TRIP-MIB", "tripNotifPeerErrSubcode"), ("TRIP-MIB", "tripPeerState"))
if mibBuilder.loadTexts: tripOpenMessageError.setStatus('current')
if mibBuilder.loadTexts: tripOpenMessageError.setDescription('Errors detected while processing the OPEN message.')
tripUpdateMessageError = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 5)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"), ("TRIP-MIB", "tripNotifPeerErrCode"), ("TRIP-MIB", "tripNotifPeerErrSubcode"), ("TRIP-MIB", "tripPeerState"))
if mibBuilder.loadTexts: tripUpdateMessageError.setStatus('current')
if mibBuilder.loadTexts: tripUpdateMessageError.setDescription('Errors detected while processing the UPDATE message.')
tripHoldTimerExpired = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 6)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"), ("TRIP-MIB", "tripNotifPeerErrCode"), ("TRIP-MIB", "tripNotifPeerErrSubcode"), ("TRIP-MIB", "tripPeerState"))
if mibBuilder.loadTexts: tripHoldTimerExpired.setStatus('current')
if mibBuilder.loadTexts: tripHoldTimerExpired.setDescription('The system does not receive successive messages within the period specified by the negotiated Hold Time.')
tripConnectionCollision = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 7)).setObjects(("TRIP-MIB", "tripNotifApplIndex"))
if mibBuilder.loadTexts: tripConnectionCollision.setStatus('current')
if mibBuilder.loadTexts: tripConnectionCollision.setDescription('A pair of LSs tried to simultaneously to establish a transport connection to each other.')
tripCease = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 8)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"), ("TRIP-MIB", "tripNotifPeerErrCode"), ("TRIP-MIB", "tripNotifPeerErrSubcode"), ("TRIP-MIB", "tripPeerState"))
if mibBuilder.loadTexts: tripCease.setStatus('current')
if mibBuilder.loadTexts: tripCease.setDescription('A TRIP peer MAY choose at any given time to close its TRIP connection by sending this notification message. However, the Cease notification message MUST NOT be used when a fatal error occurs.')
tripNotificationErr = NotificationType((1, 3, 6, 1, 2, 1, 116, 0, 9)).setObjects(("TRIP-MIB", "tripNotifApplIndex"))
if mibBuilder.loadTexts: tripNotificationErr.setStatus('current')
if mibBuilder.loadTexts: tripNotificationErr.setDescription('Generated if there is an error detected in a TRIP notification message sent with another cause. Note that the TRIP notification referred to in this object is not an SNMP notification, it is a specific message described in the TRIP specification.')
if mibBuilder.loadTexts: tripNotificationErr.setReference('RFC 3219, section 6.4.')
tripMIBFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 116, 2, 1, 1)).setObjects(("TRIP-MIB", "tripConfigGroup"), ("TRIP-MIB", "tripPeerTableConfigGroup"), ("TRIP-MIB", "tripRouteGroup"), ("TRIP-MIB", "tripItadTopologyGroup"), ("TRIP-MIB", "tripPeerTableStatsGroup"), ("TRIP-MIB", "tripNotificationGroup"), ("TRIP-MIB", "tripNotifObjectGroup"), ("NETWORK-SERVICES-MIB", "applRFC2788Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripMIBFullCompliance = tripMIBFullCompliance.setStatus('current')
if mibBuilder.loadTexts: tripMIBFullCompliance.setDescription('The compliance statement for TRIP entities that implement this MIB module in read-write mode, such that it can be used for both monitoring and configuring the TRIP entity. There is one INDEX object that cannot be represented in the form of OBJECT clauses in SMIv2, but for which there is a compliance requirement, expressed in OBJECT clause form in this description: -- OBJECT tripRouteTypeAddrInetType -- SYNTAX InetAddressType (ipv4(1), ipv6(2), -- ipv4z(3), ipv6z(4)) -- DESCRIPTION -- This MIB requires support for global and -- non-global ipv4 and ipv6 addresses. -- -- OBJECT tripRouteTypeAddr -- SYNTAX InetAddress (SIZE (4 | 8 | 16 | 20)) -- DESCRIPTION -- This MIB requires support for global and -- non-global IPv4 and IPv6 addresses. -- ')
tripMIBReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 116, 2, 1, 2)).setObjects(("TRIP-MIB", "tripConfigGroup"), ("TRIP-MIB", "tripPeerTableConfigGroup"), ("TRIP-MIB", "tripRouteGroup"), ("TRIP-MIB", "tripItadTopologyGroup"), ("TRIP-MIB", "tripPeerTableStatsGroup"), ("TRIP-MIB", "tripNotificationGroup"), ("TRIP-MIB", "tripNotifObjectGroup"), ("NETWORK-SERVICES-MIB", "applRFC2788Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripMIBReadOnlyCompliance = tripMIBReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: tripMIBReadOnlyCompliance.setDescription('The compliance statement for TRIP entities that implement this MIB module in read only mode. Such TRIP entities can then only be monitored, but not be configured via this MIB module. In read-only mode, the manager will not be able to add, remove or modify rows to any table, however the TRIP application may modify, remove or add rows to a table. There is one INDEX object that cannot be represented in the form of OBJECT clauses in SMIv2, but for which there is a compliance requirement, expressed in OBJECT clause form in this description: -- OBJECT tripRouteTypeAddrInetType -- SYNTAX InetAddressType (ipv4(1), ipv6(2), -- ipv4z(3), ipv6z(4)) -- DESCRIPTION -- This MIB requires support for global and -- non-global ipv4 and ipv6 addresses. -- -- OBJECT tripRouteTypeAddr -- SYNTAX InetAddress (SIZE (4 | 8 | 16 | 20)) -- DESCRIPTION -- This MIB requires support for global and -- non-global IPv4 and IPv6 addresses. -- ')
tripConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 1)).setObjects(("TRIP-MIB", "tripCfgProtocolVersion"), ("TRIP-MIB", "tripCfgItad"), ("TRIP-MIB", "tripCfgIdentifier"), ("TRIP-MIB", "tripCfgOperStatus"), ("TRIP-MIB", "tripCfgAdminStatus"), ("TRIP-MIB", "tripCfgAddrIAddrType"), ("TRIP-MIB", "tripCfgAddr"), ("TRIP-MIB", "tripCfgPort"), ("TRIP-MIB", "tripCfgMinItadOriginationInterval"), ("TRIP-MIB", "tripCfgMinRouteAdvertisementInterval"), ("TRIP-MIB", "tripCfgMaxPurgeTime"), ("TRIP-MIB", "tripCfgDisableTime"), ("TRIP-MIB", "tripCfgSendReceiveMode"), ("TRIP-MIB", "tripCfgStorage"), ("TRIP-MIB", "tripSupportedCommunityItad"), ("TRIP-MIB", "tripSupportedCommunityStorage"), ("TRIP-MIB", "tripRouteTypePeer"), ("TRIP-MIB", "tripSupportedCommunityRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripConfigGroup = tripConfigGroup.setStatus('current')
if mibBuilder.loadTexts: tripConfigGroup.setDescription('The global objects for configuring trip.')
tripPeerTableConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 2)).setObjects(("TRIP-MIB", "tripPeerIdentifier"), ("TRIP-MIB", "tripPeerState"), ("TRIP-MIB", "tripPeerAdminStatus"), ("TRIP-MIB", "tripPeerNegotiatedVersion"), ("TRIP-MIB", "tripPeerSendReceiveMode"), ("TRIP-MIB", "tripPeerRemoteItad"), ("TRIP-MIB", "tripPeerConnectRetryInterval"), ("TRIP-MIB", "tripPeerMaxRetryInterval"), ("TRIP-MIB", "tripPeerHoldTime"), ("TRIP-MIB", "tripPeerKeepAlive"), ("TRIP-MIB", "tripPeerHoldTimeConfigured"), ("TRIP-MIB", "tripPeerKeepAliveConfigured"), ("TRIP-MIB", "tripPeerMaxPurgeTime"), ("TRIP-MIB", "tripPeerDisableTime"), ("TRIP-MIB", "tripPeerLearned"), ("TRIP-MIB", "tripPeerStorage"), ("TRIP-MIB", "tripPeerRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripPeerTableConfigGroup = tripPeerTableConfigGroup.setStatus('current')
if mibBuilder.loadTexts: tripPeerTableConfigGroup.setDescription('The global objects for configuring the TRIP peer table.')
tripPeerTableStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 3)).setObjects(("TRIP-MIB", "tripPeerInUpdates"), ("TRIP-MIB", "tripPeerOutUpdates"), ("TRIP-MIB", "tripPeerInTotalMessages"), ("TRIP-MIB", "tripPeerOutTotalMessages"), ("TRIP-MIB", "tripPeerFsmEstablishedTransitions"), ("TRIP-MIB", "tripPeerFsmEstablishedTime"), ("TRIP-MIB", "tripPeerInUpdateElapsedTime"), ("TRIP-MIB", "tripPeerStateChangeTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripPeerTableStatsGroup = tripPeerTableStatsGroup.setStatus('current')
if mibBuilder.loadTexts: tripPeerTableStatsGroup.setDescription('The global statistics the TRIP peer table.')
tripRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 4)).setObjects(("TRIP-MIB", "tripRouteTRIBMask"), ("TRIP-MIB", "tripRouteAddressSequenceNumber"), ("TRIP-MIB", "tripRouteAddressOriginatorId"), ("TRIP-MIB", "tripRouteNextHopServerIAddrType"), ("TRIP-MIB", "tripRouteNextHopServer"), ("TRIP-MIB", "tripRouteNextHopServerPort"), ("TRIP-MIB", "tripRouteNextHopServerItad"), ("TRIP-MIB", "tripRouteMultiExitDisc"), ("TRIP-MIB", "tripRouteLocalPref"), ("TRIP-MIB", "tripRouteAdvertisementPath"), ("TRIP-MIB", "tripRouteRoutedPath"), ("TRIP-MIB", "tripRouteAtomicAggregate"), ("TRIP-MIB", "tripRouteUnknown"), ("TRIP-MIB", "tripRouteWithdrawn"), ("TRIP-MIB", "tripRouteConverted"), ("TRIP-MIB", "tripRouteReceivedTime"), ("TRIP-MIB", "tripRouteCommunityItad"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripRouteGroup = tripRouteGroup.setStatus('current')
if mibBuilder.loadTexts: tripRouteGroup.setDescription('The global objects for configuring route attribute.')
tripItadTopologyGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 5)).setObjects(("TRIP-MIB", "tripItadTopologySeqNum"), ("TRIP-MIB", "tripItadTopologyId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripItadTopologyGroup = tripItadTopologyGroup.setStatus('current')
if mibBuilder.loadTexts: tripItadTopologyGroup.setDescription('The objects that define the TRIP ITAD topology.')
tripNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 6)).setObjects(("TRIP-MIB", "tripConnectionEstablished"), ("TRIP-MIB", "tripConnectionDropped"), ("TRIP-MIB", "tripFSM"), ("TRIP-MIB", "tripOpenMessageError"), ("TRIP-MIB", "tripUpdateMessageError"), ("TRIP-MIB", "tripHoldTimerExpired"), ("TRIP-MIB", "tripConnectionCollision"), ("TRIP-MIB", "tripCease"), ("TRIP-MIB", "tripNotificationErr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripNotificationGroup = tripNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: tripNotificationGroup.setDescription('A collection of notifications defined for TRIP.')
tripNotifObjectGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 116, 2, 2, 7)).setObjects(("TRIP-MIB", "tripNotifApplIndex"), ("TRIP-MIB", "tripNotifPeerAddrInetType"), ("TRIP-MIB", "tripNotifPeerAddr"), ("TRIP-MIB", "tripNotifPeerErrCode"), ("TRIP-MIB", "tripNotifPeerErrSubcode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tripNotifObjectGroup = tripNotifObjectGroup.setStatus('current')
if mibBuilder.loadTexts: tripNotifObjectGroup.setDescription('The collection of objects that specify information for TRIP notifications.')
mibBuilder.exportSymbols("TRIP-MIB", tripFSM=tripFSM, tripRouteAddressSequenceNumber=tripRouteAddressSequenceNumber, tripNotificationErr=tripNotificationErr, tripPeerHoldTimeConfigured=tripPeerHoldTimeConfigured, tripCfgDisableTime=tripCfgDisableTime, tripRouteRoutedPath=tripRouteRoutedPath, tripRouteConverted=tripRouteConverted, tripPeerStateChangeTime=tripPeerStateChangeTime, tripPeerAdminStatus=tripPeerAdminStatus, tripPeerDisableTime=tripPeerDisableTime, tripItadTopologyIdTable=tripItadTopologyIdTable, tripRouteLocalPref=tripRouteLocalPref, tripPeerStatisticsEntry=tripPeerStatisticsEntry, tripPeerMaxRetryInterval=tripPeerMaxRetryInterval, tripNotifPeerErrSubcode=tripNotifPeerErrSubcode, tripCfgAddrIAddrType=tripCfgAddrIAddrType, tripCfgStorage=tripCfgStorage, tripRouteAddressOriginatorId=tripRouteAddressOriginatorId, tripRouteTypeAddr=tripRouteTypeAddr, tripCfgTable=tripCfgTable, tripCfgEntry=tripCfgEntry, PYSNMP_MODULE_ID=tripMIB, tripRouteAppProtocol=tripRouteAppProtocol, tripMIB=tripMIB, tripMIBObjects=tripMIBObjects, tripPeerOutUpdates=tripPeerOutUpdates, tripSupportedCommunityItad=tripSupportedCommunityItad, tripPeerHoldTime=tripPeerHoldTime, tripPeerLearned=tripPeerLearned, tripConnectionCollision=tripConnectionCollision, tripItadTopologyId=tripItadTopologyId, tripCfgProtocolVersion=tripCfgProtocolVersion, tripCfgIdentifier=tripCfgIdentifier, tripRouteTypeAddrInetType=tripRouteTypeAddrInetType, tripPeerNegotiatedVersion=tripPeerNegotiatedVersion, tripRouteAddressFamily=tripRouteAddressFamily, tripSupportedCommunityTable=tripSupportedCommunityTable, tripSupportedCommunityId=tripSupportedCommunityId, tripRouteNextHopServerPort=tripRouteNextHopServerPort, tripRouteTypePort=tripRouteTypePort, tripConnectionDropped=tripConnectionDropped, tripRouteTRIBMask=tripRouteTRIBMask, tripPeerKeepAliveConfigured=tripPeerKeepAliveConfigured, tripRouteTypeEntry=tripRouteTypeEntry, tripRouteTable=tripRouteTable, tripRouteNextHopServerItad=tripRouteNextHopServerItad, tripRouteAdvertisementPath=tripRouteAdvertisementPath, tripMIBConformance=tripMIBConformance, tripPeerMaxPurgeTime=tripPeerMaxPurgeTime, tripRouteNextHopServer=tripRouteNextHopServer, tripRouteGroup=tripRouteGroup, tripCfgItad=tripCfgItad, tripNotificationGroup=tripNotificationGroup, tripPeerRemoteAddrInetType=tripPeerRemoteAddrInetType, tripMIBNotifObjects=tripMIBNotifObjects, tripCfgSendReceiveMode=tripCfgSendReceiveMode, tripNotifPeerErrCode=tripNotifPeerErrCode, tripPeerInUpdateElapsedTime=tripPeerInUpdateElapsedTime, tripMIBFullCompliance=tripMIBFullCompliance, tripPeerRemoteItad=tripPeerRemoteItad, tripCfgAddr=tripCfgAddr, tripSupportedCommunityRowStatus=tripSupportedCommunityRowStatus, tripPeerInUpdates=tripPeerInUpdates, tripPeerRemotePort=tripPeerRemotePort, tripPeerConnectRetryInterval=tripPeerConnectRetryInterval, tripItadTopologyIdEntry=tripItadTopologyIdEntry, tripPeerOutTotalMessages=tripPeerOutTotalMessages, tripOpenMessageError=tripOpenMessageError, tripCease=tripCease, tripRouteAddress=tripRouteAddress, tripCfgMinItadOriginationInterval=tripCfgMinItadOriginationInterval, tripNotifPeerAddrInetType=tripNotifPeerAddrInetType, tripMIBCompliances=tripMIBCompliances, tripNotifObjectGroup=tripNotifObjectGroup, tripCfgMinRouteAdvertisementInterval=tripCfgMinRouteAdvertisementInterval, tripMIBGroups=tripMIBGroups, tripRouteAtomicAggregate=tripRouteAtomicAggregate, tripPeerInTotalMessages=tripPeerInTotalMessages, tripPeerTableStatsGroup=tripPeerTableStatsGroup, tripItadTopologyOrigId=tripItadTopologyOrigId, tripRouteCommunityTable=tripRouteCommunityTable, tripRouteUnknown=tripRouteUnknown, tripPeerKeepAlive=tripPeerKeepAlive, tripCfgPort=tripCfgPort, tripRouteTypePeer=tripRouteTypePeer, tripPeerRowStatus=tripPeerRowStatus, tripMIBReadOnlyCompliance=tripMIBReadOnlyCompliance, tripPeerFsmEstablishedTransitions=tripPeerFsmEstablishedTransitions, tripRoutePeer=tripRoutePeer, tripNotifApplIndex=tripNotifApplIndex, tripRouteTypeAddrFamilyId=tripRouteTypeAddrFamilyId, tripPeerRemoteAddr=tripPeerRemoteAddr, tripPeerStorage=tripPeerStorage, tripRouteCommunityItad=tripRouteCommunityItad, tripRouteCommunityId=tripRouteCommunityId, tripPeerSendReceiveMode=tripPeerSendReceiveMode, tripRouteEntry=tripRouteEntry, tripConfigGroup=tripConfigGroup, tripPeerFsmEstablishedTime=tripPeerFsmEstablishedTime, tripRouteMultiExitDisc=tripRouteMultiExitDisc, tripPeerState=tripPeerState, tripCfgMaxPurgeTime=tripCfgMaxPurgeTime, tripItadTopologyTable=tripItadTopologyTable, tripItadTopologyGroup=tripItadTopologyGroup, tripCfgOperStatus=tripCfgOperStatus, tripPeerIdentifier=tripPeerIdentifier, tripItadTopologySeqNum=tripItadTopologySeqNum, tripRouteCommunityEntry=tripRouteCommunityEntry, tripNotifPeerAddr=tripNotifPeerAddr, tripConnectionEstablished=tripConnectionEstablished, tripRouteTypeTable=tripRouteTypeTable, tripRouteReceivedTime=tripRouteReceivedTime, tripCfgAdminStatus=tripCfgAdminStatus, tripItadTopologyEntry=tripItadTopologyEntry, tripPeerEntry=tripPeerEntry, tripSupportedCommunityEntry=tripSupportedCommunityEntry, tripPeerTableConfigGroup=tripPeerTableConfigGroup, tripPeerStatisticsTable=tripPeerStatisticsTable, tripMIBNotifications=tripMIBNotifications, tripHoldTimerExpired=tripHoldTimerExpired, tripRouteTypeProtocolId=tripRouteTypeProtocolId, tripPeerTable=tripPeerTable, tripSupportedCommunityStorage=tripSupportedCommunityStorage, tripRouteNextHopServerIAddrType=tripRouteNextHopServerIAddrType, tripUpdateMessageError=tripUpdateMessageError, tripRouteWithdrawn=tripRouteWithdrawn)

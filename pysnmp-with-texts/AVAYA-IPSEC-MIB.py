#
# PySNMP MIB module AVAYA-IPSEC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AVAYA-IPSEC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:32:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
avGatewayMibs, = mibBuilder.importSymbols("AVAYAGEN-MIB", "avGatewayMibs")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
TimeTicks, Unsigned32, Integer32, MibIdentifier, Bits, Counter32, ObjectIdentity, IpAddress, ModuleIdentity, Counter64, NotificationType, iso, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Unsigned32", "Integer32", "MibIdentifier", "Bits", "Counter32", "ObjectIdentity", "IpAddress", "ModuleIdentity", "Counter64", "NotificationType", "iso", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, RowStatus, TruthValue, TextualConvention, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TruthValue", "TextualConvention", "TimeStamp")
avayaIpsecMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1))
avayaIpsecMib.setRevisions(('2007-01-08 16:43',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: avayaIpsecMib.setRevisionsDescriptions(('Add time to failback to primary peer (seconds) - avipsIsakmpPeerGroupFailbacktoPrimaryInterval under the avipsIsakmpPeerTable.',))
if mibBuilder.loadTexts: avayaIpsecMib.setLastUpdated('200701081643Z')
if mibBuilder.loadTexts: avayaIpsecMib.setOrganization('Avaya, Inc.')
if mibBuilder.loadTexts: avayaIpsecMib.setContactInfo(' Avaya Customer Services Postal: Avaya, Inc. 211 Mt Airy Rd. Basking Ridge, NJ 07920 USA Tel: +1 908 953 6000 E-mail: executiveoffic@avaya.com WWW: http://www.avaya.com ')
if mibBuilder.loadTexts: avayaIpsecMib.setDescription('The MIB module for configuring IPSec functionality in Avaya converged Gateways.')
class DiffHellmanGrp(TextualConvention, Integer32):
    description = 'The Diffie Hellman Group used in negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 5, 14, 15, 16, 17, 18, 255))
    namedValues = NamedValues(("dhGroup1", 1), ("dhGroup2", 2), ("dhGroup5", 5), ("dhGroup14", 14), ("dhGroup15", 15), ("dhGroup16", 16), ("dhGroup17", 17), ("dhGroup18", 18), ("none", 255))

class IkeEncryptAlgo(TextualConvention, Integer32):
    description = 'Values for encryption algorithms negotiated for the ISAKMP SA by IKE in Phase I. These are values for SA Attribute type Encryption Algorithm (1).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 255))
    namedValues = NamedValues(("des", 2), ("des3", 3), ("aes", 4), ("aes192", 5), ("aes256", 6), ("none", 255))

class IkeHashAlgo(TextualConvention, Integer32):
    description = 'Values for hash algorithms negotiated for the ISAKMP SA by IKE in Phase I. These are values for SA Attribute type Hash Algorithm (2).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("md5", 2), ("sha", 3))

class EspHashTransform(TextualConvention, Integer32):
    description = 'The ESP Authentication Algorithm used in the IPsec DOI as a SA Attributes definition in the Transform Payload of Phase II of an IKE negotiation. This set of values defines the AH authentication algorithm, when the associated Proposal Payload has a Protocol-ID of 2 (AH). This set of values defines the ESP authentication algorithm, when the associated Proposal Payload has a Protocol-ID of 3 (ESP).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("md5", 2), ("sha", 3))

class EspEncrTransform(TextualConvention, Integer32):
    description = 'The values of the IPsec DOI ESP Transform Identifier which identify a particular algorithm to be used to provide secrecy protection for ESP. It is used in the Transform-ID field of a ISAKMP Transform Payload for the IPsec DOI, when the Protocol-Id of the associated Proposal Payload is 2 (AH), 3 (ESP), and 4 (IPCOMP).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))
    namedValues = NamedValues(("null", 1), ("des", 2), ("des3", 3), ("aes", 4), ("aes192", 5), ("aes256", 6), ("none", 255))

class IsakmpIdentityType(TextualConvention, Integer32):
    description = "This TC provides the semantics for a column with IsakmpIdentityValue TC. Wherever this TC is used, there should be an accompanying column which uses the IsakmpIdentityValue TC to specify the data for which the semantics apply. Values in the range [1..255] is the IPsec DOI Identification Type that is an 8-bit value which is used in the ID Type field as a discriminant for interpretation of the variable-length Identification Payload. Values in the range [256..260] are reserved for the following semantics, which can be used for local and remote peers: none(256) - this object is empty. peerGroup(257) - IsakmpIdentityValue is a peer-group name. Values in the range [261..Max] are reserved for the following semantics, which can be used for local peers only: ifName(270) - an interface name, which IP address is used as the local-peer's ID. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 256, 257, 270))
    namedValues = NamedValues(("ipv4Address", 1), ("fqdn", 2), ("userFqdn", 3), ("none", 256), ("peerGroup", 257), ("ifName", 270))

class IsakmpIdentityValue(TextualConvention, OctetString):
    description = 'IsakmpIdentityValue contains a string encoded Identity Type value to be used in comparisons against an IKE Identity payload. Wherever this TC is used, there should be an accompanying column which uses the IsakmpIdentityType TC to specify the type of data in this object. See the IsakmpIdentityType TC for the supported identity types available. Note that the IsakmpIdentityType TC specifies how to encode binary values, while this object will contain human readable string versions.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 110)

class IsakmpDpdKeepaliveMetric(TextualConvention, Integer32):
    description = 'Specifies the type of worry-metric to be used for DPD.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("disabled", 1), ("onDemand", 2), ("periodic", 3))

class IpsecEncapMode(TextualConvention, Integer32):
    description = 'IPSec encapsulation mode.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("tunnel", 1), ("transport", 2))

avipsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1))
avipsGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 1))
avipsGlobalsInvalidSpiRecovery = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsGlobalsInvalidSpiRecovery.setStatus('current')
if mibBuilder.loadTexts: avipsGlobalsInvalidSpiRecovery.setDescription('This object determines whether invalid-spi-recovery is enabled (true) or disabled (false). When enabled, the device shall open an IKE SA, if it does not already exist, in order to send DELETE message to the remote peer when receiving an invalid spi or invalid cookie with SIP of that remote peer. This causes faster recovery times in case of SADB inconsistency, but may cause D/DoS attack on the remote peer.')
avipsNatTEnabled = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsNatTEnabled.setStatus('current')
if mibBuilder.loadTexts: avipsNatTEnabled.setDescription('This object specifies whether IPSec NAT-T is invoked in the device. If this object is True then NAT-T is enabled.')
avipsNatTKeepaliveInterval = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 1, 3), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsNatTKeepaliveInterval.setStatus('current')
if mibBuilder.loadTexts: avipsNatTKeepaliveInterval.setDescription('This object determines the NAT-T keepalive interval in seconds. If this object is set to 0 then NAT-T keepalives are disabled.')
avipsCryptoEngineAccelEnabled = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoEngineAccelEnabled.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoEngineAccelEnabled.setDescription('The value of this object determines whether IPSec HW acceleration is enabled or disabled. In case the HW does not support acceleration the value of this object shall be false. ')
avipsIsakmpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2))
avipsIsakmpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1), )
if mibBuilder.loadTexts: avipsIsakmpPeerTable.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerTable.setDescription("This table contains a list of all the remote peers and peer-groups we are willing to establish an IPSec VPN connection with. Each entry represents a peer or a peer-group, and is indexed by the peer's IKE identification (type and value), or the peer-group name. Each peer entry points to the ISAKMP policy that will be used for IKE negotiations (as an initiator or a responder). Note that in case this entry represents a peer-group the value of IsakmpIdentityType shall be set to peerGroup. In that case certain columns in this row are N/A.")
avipsIsakmpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1), ).setIndexNames((0, "AVAYA-IPSEC-MIB", "avipsIsakmpPeerIdType"), (1, "AVAYA-IPSEC-MIB", "avipsIsakmpPeerId"))
if mibBuilder.loadTexts: avipsIsakmpPeerEntry.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerEntry.setDescription('A specific entry.')
avipsIsakmpPeerIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 1), IsakmpIdentityType().subtype(subtypeSpec=ValueRangeConstraint(1, 260)))
if mibBuilder.loadTexts: avipsIsakmpPeerIdType.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerIdType.setDescription("This object is an enumeration identifying the type of the Identity value. Note that value can also be peerGroup, in that case avipsIsakmpPeerId contains the peer-group's name. Also note that certain columns in this row are N/A for peer-group (refer to specific objects' descriptions for details). This is also the first index component of this table.")
avipsIsakmpPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 2), IsakmpIdentityValue())
if mibBuilder.loadTexts: avipsIsakmpPeerId.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerId.setDescription('This object contains an Identity filter to be used to match against the identity payload in an IKE request. This is also the second index component of this table.')
avipsIsakmpPeerDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerDescription.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerDescription.setDescription('Free text describing this row.')
avipsIsakmpPeerIsaPlcyId1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerIsaPlcyId1.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerIsaPlcyId1.setDescription('This object contains the ID of the ISAKMP policy to be used in IKE Phase I negotiation with this peer. A value of 0 indicates that this object is empty. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerInitiateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("main", 2), ("aggressive", 3))).clone('main')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerInitiateMode.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerInitiateMode.setDescription('This object specifies how to initiate IKE when communicating with this peer: none(1) - Never initiate IKE with this peer (i.e. respond only) main(2) - Initiate Main Mode (MM) aggressive(3) - Initiate Aggressive Mode (AM) This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerSelfIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 6), IsakmpIdentityType().clone('ipv4Address')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerSelfIdType.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerSelfIdType.setDescription('This object is an enumeration identifying the type of the Identity value which the local peer shall use in the its identity payload during Phase-1 negotiation. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerSelfId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 7), IsakmpIdentityValue().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerSelfId.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerSelfId.setDescription('If not empty, this object specifies the identity value which the local peer will send in the identification payload during IKE Phase-1 negotiation. If this object is empty, the default local identity shall be sent, according to the value of avipsIsakmpPeerSelfIdType. This object is N/A if avipsIsakmpPeerIdType is peerGroup. ')
avipsIsakmpPeerKeepaliveMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 8), IsakmpDpdKeepaliveMetric().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveMetric.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveMetric.setDescription('The worry-metric to be used for deciding when to send R-U-THERE message to the remote peer. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerKeepaliveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 9), Integer32().clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveInterval.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveInterval.setDescription('The minimal interval, in seconds, between two consecutive R-U-THERE sent by the local peer, when the previous R-U-THERE message has been answered. The actual interval is based on this value and other parameters, such as the worry-metric. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerKeepaliveRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 10), Integer32().clone(2)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveRetryInterval.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveRetryInterval.setDescription('The actual interval, in seconds, between R-U-THERE retries sent by the local peer, when the previous R-U-THERE message has not been answered. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerKeepaliveTrackId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveTrackId.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerKeepaliveTrackId.setDescription('Bind the status of this peer to an object-tracker by specifying the ID of the object-tracker (avstrTrackerId in AVAYA-SAA-TRACK-MIB). A value of 0 means that peer is not bound to any object-tracker. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerContChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerContChannel.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerContChannel.setDescription('This object determines whether continuous channel IKE mode is used for contacting the peer. Continuous channel IKE means that local peer tries to establish an IKE SA with the remote peer as soon as possible, also when there is no outbound traffic that requires it. This object is N/A if avipsIsakmpPeerIdType is peerGroup.')
avipsIsakmpPeerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerRowStatus.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table. Use createAndGo (not createAndWait) to create this row.')
avipsIsakmpPeerGroupFailbacktoPrimaryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 1, 1, 14), Integer32().clone(86400)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPeerGroupFailbacktoPrimaryInterval.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPeerGroupFailbacktoPrimaryInterval.setDescription('The amount of time in seconds that secondary peer shall be up (after primary peer went down) before there will be failback to primary peer (in case it is up again). The default value is 24 hours. Relevant for peer-group only (values 1 and up). For peer return value of 0. ')
avipsPeerGroupPeersTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2), )
if mibBuilder.loadTexts: avipsPeerGroupPeersTable.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersTable.setDescription('This table contains all the associations between peer-groups and isakmp peers. The relation between peer-group and isakmp peer is many-to-many. A valid peer-group (i.e. a peer-group that can be associated with an active crypto-list) contains one or more isakmp peers. An isakmp peer may be contained in zero or more peer-groups.')
avipsPeerGroupPeersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2, 1), ).setIndexNames((0, "AVAYA-IPSEC-MIB", "avipsPeerGroupPeersPGrpName"), (0, "AVAYA-IPSEC-MIB", "avipsPeerGroupPeersPeerIndex"))
if mibBuilder.loadTexts: avipsPeerGroupPeersEntry.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersEntry.setDescription('A specific entry.')
avipsPeerGroupPeersPGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2, 1, 1), DisplayString())
if mibBuilder.loadTexts: avipsPeerGroupPeersPGrpName.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersPGrpName.setDescription("The name of the peer-group associated with this isakmp peer. Note that there must exist a matching active entry in avipsIsakmpPeerTable which avipsIsakmpPeerIdType is peerGroup, otherwise a 'set' operation shall fail.")
avipsPeerGroupPeersPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: avipsPeerGroupPeersPeerIndex.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersPeerIndex.setDescription('The ordered index of the peer within the peer-group.')
avipsPeerGroupPeersPIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2, 1, 3), IsakmpIdentityType().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsPeerGroupPeersPIdType.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersPIdType.setDescription('This object is an enumeration identifying the type of the Identity value of the peer associated with this IPSec connection. Note that value cannot be peerGroup. The contents of this object object is interpreted along with avipsPeerGroupPeersPIdValue.')
avipsPeerGroupPeersPIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2, 1, 4), IsakmpIdentityValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsPeerGroupPeersPIdValue.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersPIdValue.setDescription('This object contains value of the peer ID. The contents of this object object is interpreted along with avipsPeerGroupPeersPIdType.')
avipsPeerGroupPeersRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsPeerGroupPeersRowStatus.setStatus('current')
if mibBuilder.loadTexts: avipsPeerGroupPeersRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table. Use createAndWait (not createAndGo) to create this row. This object is active(1) after avipsPeerGroupPeersPIdType and avipsPeerGroupPeersPIdValue are set.')
avipsIsakmpPlcyTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3), )
if mibBuilder.loadTexts: avipsIsakmpPlcyTable.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyTable.setDescription('The table containing the list of all ISAKMP policy entries configured by the operator.')
avipsIsakmpPlcyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1), ).setIndexNames((0, "AVAYA-IPSEC-MIB", "avipsIsakmpPlcyId"))
if mibBuilder.loadTexts: avipsIsakmpPlcyEntry.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyEntry.setDescription('Each entry contains the attributes associated with a single ISAKMP Policy entry.')
avipsIsakmpPlcyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)))
if mibBuilder.loadTexts: avipsIsakmpPlcyId.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyId.setDescription('The ID of this ISAKMP Policy entry. This is also the index of this table.')
avipsIsakmpPlcyDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyDescription.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyDescription.setDescription('Free text describing this object.')
avipsIsakmpPlcyDhGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 3), DiffHellmanGrp().clone('dhGroup1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyDhGroup.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyDhGroup.setDescription('This object specifies the Oakley group used for Diffie Hellman exchange in the Main Mode. If this policy item is selected to negotiate Main Mode with an IKE peer, the local entity chooses the group specified by this object to perform Diffie Hellman exchange with the peer.')
avipsIsakmpPlcyEncrAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 4), IkeEncryptAlgo().clone('des')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyEncrAlgo.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyEncrAlgo.setDescription('The encryption transform specified by this ISAKMP policy specification. The Internet Key Exchange (IKE) tunnels setup using this policy item would use the specified encryption transform to protect the ISAKMP PDUs.')
avipsIsakmpPlcyHashAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 5), IkeHashAlgo().clone('sha')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyHashAlgo.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyHashAlgo.setDescription('The hash transform specified by this ISAKMP policy specification. The IKE tunnels setup using this policy item would use the specified hash transform to protect the ISAKMP PDUs.')
avipsIsakmpPlcyLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(86400)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyLifetime.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyLifetime.setDescription('This object specifies the lifetime, in seconds, of the IKE tunnels generated using this policy specification.')
avipsIsakmpPlcyAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("preSharedKey", 2))).clone('preSharedKey')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyAuth.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyAuth.setDescription('The peer authentication method specified by this ISAKMP policy specification. If this policy entity is selected for negotiation with a peer, the local entity would authenticate the peer using the method specified by this object.')
avipsIsakmpPlcyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 2, 3, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsIsakmpPlcyRowStatus.setStatus('current')
if mibBuilder.loadTexts: avipsIsakmpPlcyRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
avipsIpsecGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3))
avipsCryptoMapTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1), )
if mibBuilder.loadTexts: avipsCryptoMapTable.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapTable.setDescription('This table contains all the crypto maps configured by the user. A crypto map essentially concentrates all the IPSec protection policy required for establishing IKE Phase-1 and Phase-2 connections.')
avipsCryptoMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1), ).setIndexNames((0, "AVAYA-IPSEC-MIB", "avipsCryptoMapId"))
if mibBuilder.loadTexts: avipsCryptoMapEntry.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapEntry.setDescription('A specific crypto map entry.')
avipsCryptoMapId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)))
if mibBuilder.loadTexts: avipsCryptoMapId.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapId.setDescription('The ID of the crypto map entry. This is also the index of this table.')
avipsCryptoMapDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapDescription.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapDescription.setDescription('Free text describing this object.')
avipsCryptoMapPeerIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 3), IsakmpIdentityType().subtype(subtypeSpec=ValueRangeConstraint(1, 260))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapPeerIdType.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapPeerIdType.setDescription('This object is an enumeration identifying the type of the Identity value of the peer associated with this IPSec connection. The contents of this object object is interpreted along with avipsCryptoMapPeerIdValue.')
avipsCryptoMapPeerIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 4), IsakmpIdentityValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapPeerIdValue.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapPeerIdValue.setDescription('This object contains an Identity filter to be used to select the remote peer or peer-group when initiating IKE, and to match against the identity payload in an IKE request when responding to IKE. The contents of this object object is interpreted along with avipsCryptoMapPeerIdType.')
avipsCryptoMapTranSetName1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapTranSetName1.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapTranSetName1.setDescription('The name of the transforms-set for this crypto map. This object is the index into the avipsTranSetTable.')
avipsCryptoMapIsReady = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsCryptoMapIsReady.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapIsReady.setDescription('This field is true if and only if this crypto map entry and all the descendent configuration objects pointed by it are in the ready state. Note that crypto list activation requires that all the crypto maps it points to be ready. ')
avipsCryptoMapTunnelDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 63), )).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapTunnelDscp.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapTunnelDscp.setDescription("The method used to set the high 6 bits of the TOS in the outer IP header. A value of -1 indicates that the bits are copied from the payload's header. A value between 0 and 63 inclusive indicates that the bit field is set to the indicated value.")
avipsCryptoMapContChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapContChannel.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapContChannel.setDescription('This object determines whether continuous channel IPSec mode is used for the rule pointing to this crypto map. Continuous channel IPSec means that local peer tries to establish an IPSec SA with the remote peer as soon as possible, also when there is no outbound traffic that requires it.')
avipsCryptoMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsCryptoMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: avipsCryptoMapRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by an active crypto list.')
avipsTranSetTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2), )
if mibBuilder.loadTexts: avipsTranSetTable.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetTable.setDescription('This table lists all the transform-sets which can be used to build or accept IPsec proposals.')
avipsTranSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1), ).setIndexNames((1, "AVAYA-IPSEC-MIB", "avipsTranSetName"))
if mibBuilder.loadTexts: avipsTranSetEntry.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetEntry.setDescription('An entry containing the information on an IPsec transform-set.')
avipsTranSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: avipsTranSetName.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetName.setDescription('The name of this particular transform-set be referred to by an avipsCryptoMapEntry. This is the index of this table.')
avipsTranSetEspEncrTran = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 2), EspEncrTransform().clone('des')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetEspEncrTran.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetEspEncrTran.setDescription('This object specifies the transform ID of the ESP encryption algorithm.')
avipsTranSetEspHashTran = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 3), EspHashTransform().clone('sha')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetEspHashTran.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetEspHashTran.setDescription('This object specifies the ESP hash algorithm ID.')
avipsTranSetLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(120, 86400), )).clone(3600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetLifetime.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetLifetime.setDescription('This object specifies how long, in seconds, the security association (SA) derived from this transform should be used. The value 0 is reserved for future use.')
avipsTranSetLifesize = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 0), ValueRangeConstraint(2560, 536870912), )).clone(4608000)).setUnits('KBytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetLifesize.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetLifesize.setDescription('This object specifies how long, in Kilobytes, the security association (SA) derived from this transform should be used. The value -1 means that no size based lifetime will be offered to the other side. The value 0 is reserved for future use.')
avipsTranSetPfsGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 6), DiffHellmanGrp().clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetPfsGroup.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetPfsGroup.setDescription("This object specifies the DH group that shall be used for PFS in quick mode exchange, when creating the security association (SA) derived from this transform. The reserved value 'none' means that PFS shall not be used.")
avipsTranSetEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 7), IpsecEncapMode().clone('tunnel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetEncapMode.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetEncapMode.setDescription("This object determines the ESP encapsulation mode that will be used. Possible values are 'tunnel' and 'transport'. In case transport mode is configured, it shall be used only if possible, i.e. the SIP and DIP of the relevant rule are equivalent to the LTEP and RTEP. Otherwise tunnel mode is used. ")
avipsTranSetEspCompTran = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("ippcpLzs", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranSetEspCompTran.setStatus('current')
if mibBuilder.loadTexts: avipsTranSetEspCompTran.setDescription('This object specifies the ESP compression algorithm: none(1) - no compression algorithm. ippcpLzs(2) - IPPCP with LZS compression. ')
avipsTranRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 3, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsTranRowStatus.setStatus('current')
if mibBuilder.loadTexts: avipsTranRowStatus.setDescription('This object indicates the conceptual status of this row. The value of this object has no effect on whether other objects in this conceptual row can be modified. If active, this object must remain active if it is referenced by a row in another table.')
avipsMonitoringGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4))
avipsMonitoringTables = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1))
avipsMonitoringTablesGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 1))
avipsMonitorRstCntrs = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("running", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avipsMonitorRstCntrs.setStatus('current')
if mibBuilder.loadTexts: avipsMonitorRstCntrs.setDescription("Use this object to reset all the IPSec counters. Set this object to reset(2) in order to do that. This operation is equivalent to issuing the 'clear crypto sa counters' command in the CLI.")
avipsMonitorRstCntrsLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsMonitorRstCntrsLastChange.setStatus('current')
if mibBuilder.loadTexts: avipsMonitorRstCntrsLastChange.setDescription("sysUpTime when last IPSec counters reset by avipsMonitorRstCntrs or 'clear crypto sa counters' in CLI, in hundredths of a second.")
avipsPeerTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2), )
if mibBuilder.loadTexts: avipsPeerTable.setStatus('current')
if mibBuilder.loadTexts: avipsPeerTable.setDescription("This table contains entries for every active isakmp peer in the system. The word 'active' suggests that in case the peer is part of a redundant list of peers within a crypto map, only the peer that is currently active will be included. ")
avipsPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1), ).setIndexNames((0, "AVAYA-IPSEC-MIB", "avipsPeerLocalId"), (0, "AVAYA-IPSEC-MIB", "avipsPeerRemoteId"))
if mibBuilder.loadTexts: avipsPeerEntry.setStatus('current')
if mibBuilder.loadTexts: avipsPeerEntry.setDescription('A specific peer entry.')
avipsPeerLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: avipsPeerLocalId.setStatus('current')
if mibBuilder.loadTexts: avipsPeerLocalId.setDescription('A synthetic ID that uniquely identifies the local peer for monitoring purpose. Note that this ID is persistent for this peer. This is also the first index component of this table. ')
avipsPeerRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 2), Unsigned32())
if mibBuilder.loadTexts: avipsPeerRemoteId.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemoteId.setDescription('A synthetic ID that uniquely identifies the remote peer for monitoring purpose. Note that this ID is persistent for this peer. This is also the second index component of this table.')
avipsPeerLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 3), IsakmpIdentityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerLocalType.setStatus('current')
if mibBuilder.loadTexts: avipsPeerLocalType.setDescription('The type of the local peer identity, as it was configured. If the local peer ID was configured as an interface name, the value of this object shall be ifName.')
avipsPeerLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 4), IsakmpIdentityValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerLocalValue.setStatus('current')
if mibBuilder.loadTexts: avipsPeerLocalValue.setDescription('The value of the local peer identity. If the local peer type is an IP Address, then this is the IP Address used to identify the local peer. If the local peer type is an interface name, then this is the name of the interface which IP is used to identify the local peer. If the local peer type is a fqdn, then this is the fqdn used to identify the local peer.')
avipsPeerRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 5), IsakmpIdentityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemoteType.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemoteType.setDescription('The type of the remote peer identity. ')
avipsPeerRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 6), IsakmpIdentityValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemoteValue.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemoteValue.setDescription('The value of the remote peer identity. If the remote peer type is an IP Address, then this is the IP Address used to identify the remote peer. If the remote peer type is a fqdn, then this is the fqdn used to identify the remote peer.')
avipsPeerRemoteDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemoteDescription.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemoteDescription.setDescription('Free text describing the remote peer or peer-group. The value of this field is taken from avipsIsakmpPeerDescription.')
avipsPeerLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerLocalAddress.setStatus('current')
if mibBuilder.loadTexts: avipsPeerLocalAddress.setDescription('The IP address of the local peer. This is derived from the local-address specified in the crypto-list that creates this connection. If the local peer type is an IP Address, then this is identical to avipsPeerLocalValue.')
avipsPeerRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemoteAddress.setDescription('The IP address of the remote peer. If the remote peer type is an IP Address, then this is identical to avipsPeerRemoteValue. If the remote peer type is a fqdn, then this is the IP address that was received by DNS resolution of the fqdn specified in IsakmpIdentityValue.')
avipsPeerRemotePeerGrpActiveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemotePeerGrpActiveIndex.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemotePeerGrpActiveIndex.setDescription('In case the remote is a peer-group, i.e. avipsPeerRemoteType is peerGroup, this object specifies the index within the peer-group of the currently active peer. This value is taken from avipsPeerGroupPeersPeerIndex of the active peer in this peer-group.')
avipsPeerRemotePeerGrpActiveIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 11), IsakmpIdentityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemotePeerGrpActiveIdType.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemotePeerGrpActiveIdType.setDescription('In case the remote is a peer-group, i.e. avipsPeerRemoteType is peerGroup, this object specifies the id-type of the currently active peer. This value is taken from avipsIsakmpPeerIdType of the active peer in this peer-group.')
avipsPeerRemotePeerGrpActiveIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 12), IsakmpIdentityValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerRemotePeerGrpActiveIdValue.setStatus('current')
if mibBuilder.loadTexts: avipsPeerRemotePeerGrpActiveIdValue.setDescription('In case the remote is a peer-group, i.e. avipsPeerRemoteType is peerGroup, this object specifies the id-value of the currently active peer. This value is taken from avipsIsakmpPeerId of the active peer in this peer-group.')
avipsPeerIsakmpState = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("closed", 1), ("inProgress", 2), ("established", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerIsakmpState.setStatus('current')
if mibBuilder.loadTexts: avipsPeerIsakmpState.setDescription("This object specifies the state of the IKE connection between the peers. 1. closed - No IKE SA exists between peers because it was not negotiated yet, or because last IKE closed normally due to hard timeout, clear by admin, or DELETE received from the remote peer. This is also the initial state of the row when it is created. 2. inProgress - No IKE SA exists between peers, but it is currently being negotiated in Phase-1. 3. established - IKE SA exists between peers. 4. failed - No IKE SA exists between peers because of a failure. Possible reasons are: 1. Last time we tried to establish IKE the negotiation failed. 2. Last time we tried to establish IKE the remote peer DNS resolution failed. 3. During last connection DPD signaled a connection failure. 4. During last connection a track object signaled a connection failure. 5. The interface used for local-address does not have an IP address asigned to it 1 minute or more after this row was created. 6. Last time we negotiated Phase-2 the negotiation timed-out, and the current IKE was subsequently deleted. NOTE: When continuous-channel IKE is used, the state shall remain 'established' during the normal transition time between one IKE SA and the next. However, if the IKE SA was deleted due to a suspected problem then the state will change normally during the transition (i.e. 'closed' and then 'inProgress'). [Suspected problem: if the last IKE SA was DELETEd by the remote peer after less then 5 minutes,or if it was deleted by local admin] ")
avipsPeerIsakmpStateLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerIsakmpStateLastChange.setStatus('current')
if mibBuilder.loadTexts: avipsPeerIsakmpStateLastChange.setDescription('sysUpTime when the last change in avipsPeerIsakmpState occured, in hundredths of a second.')
avipsPeerTunnelsClosed = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerTunnelsClosed.setStatus('current')
if mibBuilder.loadTexts: avipsPeerTunnelsClosed.setDescription("The number of IPSec tunnels associated with these peers, which are in the 'closed' state.")
avipsPeerTunnelsInProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerTunnelsInProgress.setStatus('current')
if mibBuilder.loadTexts: avipsPeerTunnelsInProgress.setDescription("The number of IPSec tunnels associated with these peers, which are in the 'inProgress' state.")
avipsPeerTunnelsEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerTunnelsEstablished.setStatus('current')
if mibBuilder.loadTexts: avipsPeerTunnelsEstablished.setDescription("The number of IPSec tunnels associated with these peers, which are in the 'established' state.")
avipsPeerTunnelsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerTunnelsFailed.setStatus('current')
if mibBuilder.loadTexts: avipsPeerTunnelsFailed.setDescription("The number of IPSec tunnels associated with these peers, which are in the 'failed' state.")
avipsPeerInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInOctets.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInOctets.setDescription('The aggregate number of octets (bytes) successfully received through all the tunnels between the peers. This value is accumulated BEFORE determining whether or not the packet should be decompressed. This number is the sum of avipsTunnelInOctets together with avipsTunnelInOctetsWraps as a single 64-bit integer, for all the IPSec tunnels pertaining to the peers. See also avipsPeerInOctetsWraps for the number of times this counter has wrapped.')
avipsPeerInOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInOctetsWraps.setDescription('The number of times avipsPeerInOctets has wrapped.')
avipsPeerInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInDecompOctets.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInDecompOctets.setDescription('The aggregate number of decompressed octets (bytes) successfully received through all the tunnels between the peers. This value is accumulated AFTER the packet is decompressed. If compression is not being used in any of the tunnels, this value will match the value of avipsPeerInOctets. This number is the sum of avipsTunnelInDecompOctets together with avipsTunnelInDecompOctetsWraps as a single 64-bit integer, for all the tunnels pertaining to the peers. See also avipsPeerInDecompOctetsWraps for the number of times this counter has wrapped.')
avipsPeerInDecompOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInDecompOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInDecompOctetsWraps.setDescription('The number of times avipsPeerInDecompOctets has wrapped.')
avipsPeerInDecompRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 23), Gauge32()).setUnits('Ratio * 100').setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInDecompRatio.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInDecompRatio.setDescription('The overall decompression ratio * 100. This is the ratio between the number of octets received after decompression and the number of octets received before decompression. It is calculated as the integer of {[(avipsPeerInDecompOctetsWraps*2^32 + avipsPeerInDecompOctets) / (avipsPeerInOctetsWraps*2^32 + avipsPeerInOctets)] * 100}')
avipsPeerInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInPkts.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInPkts.setDescription('The aggregate number of packets successfully received through all the tunnels between the peers. This number is the sum of avipsTunnelInPkts for all the tunnels pertaining to the peers.')
avipsPeerInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerInDropPkts.setStatus('current')
if mibBuilder.loadTexts: avipsPeerInDropPkts.setDescription('The aggregate number of packets dropped after being received through any of the tunnels between the peers. This number is the sum of avipsTunnelInDropTotalPkts for all the tunnels pertaining to the peers.')
avipsPeerOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutOctets.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutOctets.setDescription('The aggregate number of octets (bytes) successfully transmitted through all the tunnels between the peers. This value is accumulated AFTER determining whether or not the packet should be compressed. This number is the sum of avipsTunnelOutOctets together with vipsTunnelOutOctetsWraps as a single 64-bit integer, for all the tunnels pertaining to the peers. See also avipsPeerOutOctetsWraps for the number of times this counter has wrapped.')
avipsPeerOutOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutOctetsWraps.setDescription('The number of times avipsPeerOutOctets has wrapped.')
avipsPeerOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutUncompOctets.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutUncompOctets.setDescription('The aggregate number of uncompressed octets (bytes) successfully transmitted through this IPsec Tunnel. This value is accumulated BEFORE the packet is compressed. If compression is not being used in any of the tunnels, this value will match the value of avipsPeerOutOctets. This number is the sum of avipsTunnelOutUncompOctets together with avipsTunnelOutUncompOctetsWraps as a single 64-bit integer, for all the tunnels pertaining to the peers. See also avipsPeerOutUncompOctetsWraps for the number of times this counter has wrapped.')
avipsPeerOutUncompOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutUncompOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutUncompOctetsWraps.setDescription('The number of times avipsPeerInDecompOctets has wrapped.')
avipsPeerOutCompRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 30), Gauge32()).setUnits('Ratio * 100').setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutCompRatio.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutCompRatio.setDescription('The overall compression ratio * 100. This is the ratio between the number of outbound octets before compression and the number of outbound octets after compression. It is calculated as the integer of {[(avipsPeerOutUncompOctetsWraps*2^32 + avipsPeerOutUncompOctets) / (avipsPeerOutOctetsWraps*2^32 + avipsPeerOutOctets)]* 100}')
avipsPeerOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutPkts.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutPkts.setDescription('The aggregate number of packets successfully transmitted through all the tunnels between the peers. This number is the sum of avipsTunnelOutPkts for all the tunnels pertaining to the peers.')
avipsPeerOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsPeerOutDropPkts.setStatus('current')
if mibBuilder.loadTexts: avipsPeerOutDropPkts.setDescription('The aggregate number of packets dropped before being transmitted through any of the tunnels between the peers. This number is the sum of avipsTunnelOutDropTotalPkts for all the tunnels pertaining to the peers.')
avipsTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3), )
if mibBuilder.loadTexts: avipsTunnelTable.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelTable.setDescription("This table contains a entries for all the tunnels in the system. A 'tunnel' is a rule within an active crypto-list.")
avipsTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1), ).setIndexNames((0, "AVAYA-IPSEC-MIB", "avipsTunnelIndex"), (0, "AVAYA-IPSEC-MIB", "avipsTunnelSubIndex"), (0, "AVAYA-IPSEC-MIB", "avipsTunnelPeerLocalId"), (0, "AVAYA-IPSEC-MIB", "avipsTunnelPeerRemoteId"))
if mibBuilder.loadTexts: avipsTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelEntry.setDescription('A specific tunnel entry.')
avipsTunnelPeerLocalId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: avipsTunnelPeerLocalId.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelPeerLocalId.setDescription('A synthetic ID that uniquely identifies the local peer for monitoring purpose. Note that this ID is persistent for this peer. ')
avipsTunnelPeerRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: avipsTunnelPeerRemoteId.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelPeerRemoteId.setDescription('A synthetic ID that uniquely identifies the remote peer for monitoring purpose. Note that this ID is persistent for this peer.')
avipsTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: avipsTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelIndex.setDescription('The ID of the crypto-list containing the rule that creates this tunnel. This is also the fifth index component of this table.')
avipsTunnelSubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: avipsTunnelSubIndex.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelSubIndex.setDescription('The index of the crypto-list rule that creates this tunnel. This is also the sixth index component of this table.')
avipsTunnelPeerLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 5), IsakmpIdentityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelPeerLocalType.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelPeerLocalType.setDescription('The type of the local peer identity, as it was configured. If the local peer ID was configured as an interface name, the value of this object shall be ifName. This is also the first index component of this table.')
avipsTunnelPeerLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 6), IsakmpIdentityValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelPeerLocalValue.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelPeerLocalValue.setDescription('The value of the local peer identity. If the local peer type is an IP Address, then this is the IP Address used to identify the local peer. If the local peer type is an interface name, then this is the name of the interface which IP is used to identify the local peer. If the local peer type is a fqdn, then this is the fqdn used to identify the local peer. This is also the second index component of this table.')
avipsTunnelPeerRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 7), IsakmpIdentityType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelPeerRemoteType.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelPeerRemoteType.setDescription('The type of the remote peer identity. This is also the third index component of this table.')
avipsTunnelPeerRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 8), IsakmpIdentityValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelPeerRemoteValue.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelPeerRemoteValue.setDescription('The value of the remote peer identity. If the remote peer type is an IP Address, then this is the IP Address used to identify the remote peer. If the remote peer type is a fqdn, then this is the fqdn used to identify the remote peer. This is also the fourth index component of this table.')
avipsTunnelDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelDescription.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelDescription.setDescription('Free text describing this tunnel. The value of this field is taken from the description specified for the crypto-list rule that creates this tunnel.')
avipsTunnelLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelLocalAddress.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelLocalAddress.setDescription('The IP address of the local peer.')
avipsTunnelRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelRemoteAddress.setDescription('The IP address of the remote peer.')
avipsTunnelProxyLocalSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelProxyLocalSubnet.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelProxyLocalSubnet.setDescription('The local subnet address this tunnel protects.')
avipsTunnelProxyLocalMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelProxyLocalMask.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelProxyLocalMask.setDescription('The local subnet mask this tunnel protects.')
avipsTunnelProxyRemoteSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelProxyRemoteSubnet.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelProxyRemoteSubnet.setDescription('The remote subnet address this tunnel protects.')
avipsTunnelProxyRemoteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelProxyRemoteMask.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelProxyRemoteMask.setDescription('The remote subnet mask this tunnel protects.')
avipsTunnelState = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("closed", 1), ("inProgress", 2), ("established", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelState.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelState.setDescription("This object specifies the state of this tunnel. 1. closed - The tunnel does not exist between the peers because it was not negotiated yet, or because last tunnel closed normally due to hard timeout, clear by admin or DELETE received from the remote peer. This is also the initial state of the row when it is created. 2. inProgress - The tunnel does not exist between peers, but it is currently being negotiated in IKE Quick Mode. 3. established - The tunnel exists between peers. 4. failed - The tunnel does not exist between peers because of a failure: 1. Last time we tried to establish this tunnel the negotiation failed. 2. The connection with the remote peer has failed due to one of the following, and hence all the corresponding ipsec tunnels were closed: a. Last time we tried to establish IKE the negotiation failed. b. During last connection a track object signaled a connection failure. c. The interface used for local-address does not have an IP address asigned to it 1 minute or more after this row was created. NOTE: The word 'tunnel' in this context refers to 1 or more IPSec SAs (ESP or AH) between the peers, pertaining to the proxy addresses specified in this entry. As long as there is at least 1 SA established, the tunnel state shall remain 'established'. ")
avipsTunnelStateLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelStateLastChange.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelStateLastChange.setDescription('sysUpTime when the last change in avipsTunnelState occured, in hundredths of a second.')
avipsTunnelLastCntrsReset = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelLastCntrsReset.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelLastCntrsReset.setDescription("sysUpTime when last counter reset for this tunnel occured, in hundredths of a second. Counters are zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInOctets.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInOctets.setDescription("The total number of octets (bytes) successfully received through this IPSec tunnel. This value is accumulated BEFORE determining whether or not the packet should be decompressed. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config). See also avipsTunnelInOctetsWraps for the number of times this counter has wrapped.")
avipsTunnelInOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInOctetsWraps.setDescription("The number of times avipsTunnelInOctets has wrapped. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDecompOctets.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDecompOctets.setDescription("The total number of decompressed octets (bytes) successfully received through this IPsec Tunnel. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of avipsTunnelInOctets. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config). See also avipsTunnelInDecompOctetsWraps for the number of times this counter has wrapped.")
avipsTunnelInDecompOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDecompOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDecompOctetsWraps.setDescription("The number of times avipsTunnelInDecompOctets has wrapped. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDecompRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 23), Gauge32()).setUnits('Ratio * 100').setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDecompRatio.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDecompRatio.setDescription('The overall decompression ratio * 100. This is the ratio between the number of octets received after decompression and the number of octets received before decompression. It is calculated as the integer of {[(avipsTunnelInDecompOctetsWraps*2^32 + avipsTunnelInDecompOctets) / (avipsTunnelInOctetsWraps*2^32 + avipsTunnelInOctets)] * 100}')
avipsTunnelInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInPkts.setDescription("The number of packets succesfully received through this tunnel. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropTotalPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropTotalPkts.setDescription("The total number of packets discarded after being received through this tunnel. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropAntiReplayPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropAntiReplayPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropAntiReplayPkts.setDescription("The number of packets discarded after being received through this tunnel due to anti-replay verification failure. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropHmacFailPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropHmacFailPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropHmacFailPkts.setDescription("The number of packets discarded after being received through this tunnel due to HMAC verification failure. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropBadTrailerPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropBadTrailerPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropBadTrailerPkts.setDescription("The number of packets discarded after being received through this tunnel due to bad ESP trailer format received failure. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropInvalidIdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropInvalidIdPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropInvalidIdPkts.setDescription("The number of packets discarded after being received through this tunnel due to invalid identity: inner (original) IP header address doesn't match the configured tunnel proxy IPs. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropUnprotectPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropUnprotectPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropUnprotectPkts.setDescription("The number of packets discarded after being received in the clear (unprotected) although they were expected to arrive protected by this tunnel (i.e. unprotected packets with source and destination IP matching the proxy IPs of this tunnel). This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropInvalidLenPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropInvalidLenPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropInvalidLenPkts.setDescription("The number of packets discarded after being received through this tunnel due to length being not aligned to cipher block. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelInDropSaExpiredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelInDropSaExpiredPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelInDropSaExpiredPkts.setDescription("The number of packets discarded after being received through this tunnel due to SA KB lifetime being smaller then the external IP packet total length. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutOctets.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutOctets.setDescription("The total number of octets (bytes) successfully transmitted through this IPSec tunnel. This value is accumulated AFTER determining whether or not the packet should be compressed. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config). See also avipsTunnelOutOctetsWraps for the number of times this counter has wrapped.")
avipsTunnelOutOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutOctetsWraps.setDescription("The number of times avipsTunnelOutOctets has wrapped. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutUncompOctets.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutUncompOctets.setDescription("The total number of uncompressed octets (bytes) successfully transmitted through this IPsec Tunnel. This value is accumulated BEFORE the packet is compressed. If compression is not being used, this value will match the value of avipsTunnelOutOctets. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config). See also avipsTunnelOutUncompOctetsWraps for the number of times this counter has wrapped.")
avipsTunnelOutUncompOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutUncompOctetsWraps.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutUncompOctetsWraps.setDescription("The number of times avipsTunnelInDecompOctets has wrapped. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutCompRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 37), Gauge32()).setUnits('Ratio * 100').setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutCompRatio.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutCompRatio.setDescription('The overall compression ratio * 100. This is the ratio between the number of outbound octets before compression and the number of outbound octets after compression. It is calculated as the integer of {[(avipsTunnelOutUncompOctetsWraps*2^32 + avipsTunnelOutUncompOctets) / (avipsTunnelOutOctetsWraps*2^32 + avipsTunnelOutOctets)]* 100}')
avipsTunnelOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutPkts.setDescription("The number of packets succesfully transmitted through this tunnel. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutDropTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutDropTotalPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutDropTotalPkts.setDescription("The total number of packets dropped before being transmitted through this tunnel. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutDropNoSaPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutDropNoSaPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutDropNoSaPkts.setDescription("The number of packets dropped before being transmitted through this tunnel due to no IPSec SA existed when the packet arrived. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutDropSeqRolPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutDropSeqRolPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutDropSeqRolPkts.setDescription("The number of packets dropped before being transmitted through this tunnel due to sequence number rollover: the sequence number of the IPSec SA reached its capacity. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsTunnelOutDropSaExpiredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 1, 4, 1, 3, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avipsTunnelOutDropSaExpiredPkts.setStatus('current')
if mibBuilder.loadTexts: avipsTunnelOutDropSaExpiredPkts.setDescription("The number of packets dropped before being transmitted through this tunnel due to SA expired: SA KB lifetime is smaller then the external IP packet total length. This counter is zeroized when: o Issuing 'clear crypto sa counters' in CLI. o Setting avipsMonitorRstCntrs in MIB (equivalent to above). o Issuing 'clear crypto sa all' in CLI. o Activating the crypto-list on an interface for the first time. o Failing-over to a different peer. o Learning a new local-address (DHCP, PPPoE, user config).")
avipsMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2))
avipsMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0))
avipsIskampEstablished = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0, 1)).setObjects(("AVAYA-IPSEC-MIB", "avipsPeerLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerIsakmpStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteDescription"))
if mibBuilder.loadTexts: avipsIskampEstablished.setStatus('current')
if mibBuilder.loadTexts: avipsIskampEstablished.setDescription("This notification is sent whenever avipsPeerIsakmpState moves into the 'established' state.")
avipsIskampClosed = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0, 2)).setObjects(("AVAYA-IPSEC-MIB", "avipsPeerLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerIsakmpStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteDescription"))
if mibBuilder.loadTexts: avipsIskampClosed.setStatus('current')
if mibBuilder.loadTexts: avipsIskampClosed.setDescription("This notification is sent whenever avipsPeerIsakmpState moves into the 'closed' state, excluding during row creation.")
avipsIskampFailed = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0, 3)).setObjects(("AVAYA-IPSEC-MIB", "avipsPeerLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerIsakmpStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteDescription"))
if mibBuilder.loadTexts: avipsIskampFailed.setStatus('current')
if mibBuilder.loadTexts: avipsIskampFailed.setDescription("This notification is sent whenever avipsPeerIsakmpState moves into the 'failed' state.")
avipsIpsecTunnelEstablished = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0, 4)).setObjects(("AVAYA-IPSEC-MIB", "avipsTunnelLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsTunnelDescription"))
if mibBuilder.loadTexts: avipsIpsecTunnelEstablished.setStatus('current')
if mibBuilder.loadTexts: avipsIpsecTunnelEstablished.setDescription("This notification is sent whenever avipsTunnelState moves into the 'established' state.")
avipsIpsecTunnelClosed = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0, 5)).setObjects(("AVAYA-IPSEC-MIB", "avipsTunnelLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsTunnelDescription"))
if mibBuilder.loadTexts: avipsIpsecTunnelClosed.setStatus('current')
if mibBuilder.loadTexts: avipsIpsecTunnelClosed.setDescription("This notification is sent whenever avipsTunnelState moves into the 'closed' state, excluding during row creation.")
avipsIpsecTunnelFailed = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 2, 0, 6)).setObjects(("AVAYA-IPSEC-MIB", "avipsTunnelLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsTunnelDescription"))
if mibBuilder.loadTexts: avipsIpsecTunnelFailed.setStatus('current')
if mibBuilder.loadTexts: avipsIpsecTunnelFailed.setDescription("This notification is sent whenever avipsTunnelState moves into the 'failed' state.")
avipsMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 3))
avipsMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 3, 1))
avipsConfigurationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 3, 1, 1)).setObjects(("AVAYA-IPSEC-MIB", "avipsGlobalsInvalidSpiRecovery"), ("AVAYA-IPSEC-MIB", "avipsNatTEnabled"), ("AVAYA-IPSEC-MIB", "avipsNatTKeepaliveInterval"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerDescription"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerIsaPlcyId1"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerSelfIdType"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerSelfId"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerKeepaliveMetric"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerKeepaliveInterval"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerKeepaliveRetryInterval"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerKeepaliveTrackId"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerContChannel"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerRowStatus"), ("AVAYA-IPSEC-MIB", "avipsPeerGroupPeersPIdType"), ("AVAYA-IPSEC-MIB", "avipsPeerGroupPeersPIdValue"), ("AVAYA-IPSEC-MIB", "avipsPeerGroupPeersRowStatus"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyDescription"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyDhGroup"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyEncrAlgo"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyHashAlgo"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyLifetime"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyAuth"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPlcyRowStatus"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapDescription"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapPeerIdType"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapPeerIdValue"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapTranSetName1"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapIsReady"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapTunnelDscp"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapContChannel"), ("AVAYA-IPSEC-MIB", "avipsCryptoMapRowStatus"), ("AVAYA-IPSEC-MIB", "avipsTranSetEspEncrTran"), ("AVAYA-IPSEC-MIB", "avipsTranSetEspHashTran"), ("AVAYA-IPSEC-MIB", "avipsTranSetLifetime"), ("AVAYA-IPSEC-MIB", "avipsTranSetLifesize"), ("AVAYA-IPSEC-MIB", "avipsTranSetPfsGroup"), ("AVAYA-IPSEC-MIB", "avipsTranSetEncapMode"), ("AVAYA-IPSEC-MIB", "avipsTranSetEspCompTran"), ("AVAYA-IPSEC-MIB", "avipsTranRowStatus"), ("AVAYA-IPSEC-MIB", "avipsCryptoEngineAccelEnabled"), ("AVAYA-IPSEC-MIB", "avipsIsakmpPeerInitiateMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    avipsConfigurationGroup = avipsConfigurationGroup.setStatus('current')
if mibBuilder.loadTexts: avipsConfigurationGroup.setDescription('This group consists of: 1) Global configuration objects. 2) Isakmp configuration objects. 3) IPsec configuration objects.')
avipsMonitorGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 3, 1, 2)).setObjects(("AVAYA-IPSEC-MIB", "avipsMonitorRstCntrs"), ("AVAYA-IPSEC-MIB", "avipsMonitorRstCntrsLastChange"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteDescription"), ("AVAYA-IPSEC-MIB", "avipsPeerLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsPeerIsakmpState"), ("AVAYA-IPSEC-MIB", "avipsPeerIsakmpStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsPeerInOctets"), ("AVAYA-IPSEC-MIB", "avipsPeerInOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsPeerInPkts"), ("AVAYA-IPSEC-MIB", "avipsPeerInDropPkts"), ("AVAYA-IPSEC-MIB", "avipsPeerOutOctets"), ("AVAYA-IPSEC-MIB", "avipsPeerOutOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsPeerOutPkts"), ("AVAYA-IPSEC-MIB", "avipsPeerOutDropPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelDescription"), ("AVAYA-IPSEC-MIB", "avipsTunnelLocalAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelRemoteAddress"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyLocalMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteSubnet"), ("AVAYA-IPSEC-MIB", "avipsTunnelProxyRemoteMask"), ("AVAYA-IPSEC-MIB", "avipsTunnelState"), ("AVAYA-IPSEC-MIB", "avipsTunnelStateLastChange"), ("AVAYA-IPSEC-MIB", "avipsTunnelInOctets"), ("AVAYA-IPSEC-MIB", "avipsTunnelInOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsTunnelInPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropAntiReplayPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropHmacFailPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropBadTrailerPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropInvalidIdPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropUnprotectPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropInvalidLenPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropSaExpiredPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutOctets"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutDropNoSaPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutDropSeqRolPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutDropSaExpiredPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelLastCntrsReset"), ("AVAYA-IPSEC-MIB", "avipsPeerRemotePeerGrpActiveIdValue"), ("AVAYA-IPSEC-MIB", "avipsPeerTunnelsClosed"), ("AVAYA-IPSEC-MIB", "avipsPeerTunnelsInProgress"), ("AVAYA-IPSEC-MIB", "avipsPeerTunnelsEstablished"), ("AVAYA-IPSEC-MIB", "avipsPeerTunnelsFailed"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDecompOctets"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDecompOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutUncompOctets"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutUncompOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsPeerInDecompOctets"), ("AVAYA-IPSEC-MIB", "avipsPeerInDecompOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsPeerOutUncompOctetsWraps"), ("AVAYA-IPSEC-MIB", "avipsPeerOutUncompOctets"), ("AVAYA-IPSEC-MIB", "avipsPeerInDecompRatio"), ("AVAYA-IPSEC-MIB", "avipsPeerOutCompRatio"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDecompRatio"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutCompRatio"), ("AVAYA-IPSEC-MIB", "avipsPeerLocalType"), ("AVAYA-IPSEC-MIB", "avipsPeerLocalValue"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteType"), ("AVAYA-IPSEC-MIB", "avipsPeerRemoteValue"), ("AVAYA-IPSEC-MIB", "avipsTunnelPeerLocalType"), ("AVAYA-IPSEC-MIB", "avipsTunnelPeerLocalValue"), ("AVAYA-IPSEC-MIB", "avipsTunnelPeerRemoteType"), ("AVAYA-IPSEC-MIB", "avipsTunnelPeerRemoteValue"), ("AVAYA-IPSEC-MIB", "avipsPeerRemotePeerGrpActiveIdType"), ("AVAYA-IPSEC-MIB", "avipsPeerRemotePeerGrpActiveIndex"), ("AVAYA-IPSEC-MIB", "avipsTunnelInDropTotalPkts"), ("AVAYA-IPSEC-MIB", "avipsTunnelOutDropTotalPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    avipsMonitorGroup = avipsMonitorGroup.setStatus('current')
if mibBuilder.loadTexts: avipsMonitorGroup.setDescription('This group consists of: 1) Global monitoring objects. 2) Peer monitoring objects. 3) IPSec tunnels monitoring objects.')
avipsMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 3, 2))
avipsMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6889, 2, 6, 1, 3, 2, 1)).setObjects(("AVAYA-IPSEC-MIB", "avipsConfigurationGroup"), ("AVAYA-IPSEC-MIB", "avipsMonitorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    avipsMIBCompliance = avipsMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: avipsMIBCompliance.setDescription('The compliance statement for SNMP entities the IP Security Protocol.')
mibBuilder.exportSymbols("AVAYA-IPSEC-MIB", avipsMIBGroups=avipsMIBGroups, avipsIsakmpPeerKeepaliveMetric=avipsIsakmpPeerKeepaliveMetric, avipsIsakmpPeerIdType=avipsIsakmpPeerIdType, avipsTranSetLifesize=avipsTranSetLifesize, avipsCryptoEngineAccelEnabled=avipsCryptoEngineAccelEnabled, avipsIsakmpPlcyAuth=avipsIsakmpPlcyAuth, avipsMonitorGroup=avipsMonitorGroup, avipsTunnelInDecompOctets=avipsTunnelInDecompOctets, avipsPeerRemoteAddress=avipsPeerRemoteAddress, avipsIsakmpPlcyEncrAlgo=avipsIsakmpPlcyEncrAlgo, avipsPeerIsakmpStateLastChange=avipsPeerIsakmpStateLastChange, avipsPeerOutPkts=avipsPeerOutPkts, avipsIsakmpGroup=avipsIsakmpGroup, avipsCryptoMapTunnelDscp=avipsCryptoMapTunnelDscp, avipsIsakmpPeerContChannel=avipsIsakmpPeerContChannel, avipsCryptoMapRowStatus=avipsCryptoMapRowStatus, avipsTunnelOutOctetsWraps=avipsTunnelOutOctetsWraps, avipsTunnelInDropAntiReplayPkts=avipsTunnelInDropAntiReplayPkts, avipsPeerRemotePeerGrpActiveIdType=avipsPeerRemotePeerGrpActiveIdType, avipsPeerRemoteId=avipsPeerRemoteId, avipsPeerLocalType=avipsPeerLocalType, avipsIsakmpPeerDescription=avipsIsakmpPeerDescription, avipsPeerEntry=avipsPeerEntry, avipsPeerOutDropPkts=avipsPeerOutDropPkts, avipsTunnelInPkts=avipsTunnelInPkts, avipsTunnelOutUncompOctetsWraps=avipsTunnelOutUncompOctetsWraps, avipsTunnelPeerLocalValue=avipsTunnelPeerLocalValue, avipsTunnelTable=avipsTunnelTable, EspHashTransform=EspHashTransform, IsakmpIdentityType=IsakmpIdentityType, avipsIsakmpPeerRowStatus=avipsIsakmpPeerRowStatus, avipsCryptoMapTable=avipsCryptoMapTable, avipsTunnelInOctets=avipsTunnelInOctets, avipsPeerInDecompOctets=avipsPeerInDecompOctets, avayaIpsecMib=avayaIpsecMib, avipsPeerOutOctets=avipsPeerOutOctets, avipsTunnelProxyRemoteMask=avipsTunnelProxyRemoteMask, avipsTunnelInDropTotalPkts=avipsTunnelInDropTotalPkts, avipsPeerOutUncompOctetsWraps=avipsPeerOutUncompOctetsWraps, avipsGlobals=avipsGlobals, avipsTunnelInDropInvalidLenPkts=avipsTunnelInDropInvalidLenPkts, avipsPeerOutOctetsWraps=avipsPeerOutOctetsWraps, avipsTunnelPeerRemoteValue=avipsTunnelPeerRemoteValue, avipsTunnelOutOctets=avipsTunnelOutOctets, avipsPeerRemotePeerGrpActiveIdValue=avipsPeerRemotePeerGrpActiveIdValue, avipsMIBConformance=avipsMIBConformance, avipsIsakmpPlcyDhGroup=avipsIsakmpPlcyDhGroup, avipsPeerTunnelsEstablished=avipsPeerTunnelsEstablished, avipsTunnelProxyLocalSubnet=avipsTunnelProxyLocalSubnet, avipsTunnelOutDropSaExpiredPkts=avipsTunnelOutDropSaExpiredPkts, avipsTunnelProxyRemoteSubnet=avipsTunnelProxyRemoteSubnet, avipsIsakmpPlcyRowStatus=avipsIsakmpPlcyRowStatus, avipsPeerTunnelsFailed=avipsPeerTunnelsFailed, avipsIsakmpPlcyHashAlgo=avipsIsakmpPlcyHashAlgo, avipsTunnelOutDropSeqRolPkts=avipsTunnelOutDropSeqRolPkts, PYSNMP_MODULE_ID=avayaIpsecMib, avipsPeerInDecompRatio=avipsPeerInDecompRatio, avipsTunnelInDecompOctetsWraps=avipsTunnelInDecompOctetsWraps, avipsMonitorRstCntrsLastChange=avipsMonitorRstCntrsLastChange, avipsMIBCompliance=avipsMIBCompliance, avipsTranSetLifetime=avipsTranSetLifetime, avipsCryptoMapId=avipsCryptoMapId, avipsCryptoMapPeerIdValue=avipsCryptoMapPeerIdValue, IsakmpDpdKeepaliveMetric=IsakmpDpdKeepaliveMetric, avipsConfigurationGroup=avipsConfigurationGroup, EspEncrTransform=EspEncrTransform, avipsTranSetTable=avipsTranSetTable, avipsMIBCompliances=avipsMIBCompliances, avipsIpsecTunnelFailed=avipsIpsecTunnelFailed, avipsPeerGroupPeersPeerIndex=avipsPeerGroupPeersPeerIndex, avipsTunnelPeerRemoteId=avipsTunnelPeerRemoteId, avipsGlobalsInvalidSpiRecovery=avipsGlobalsInvalidSpiRecovery, avipsIsakmpPeerKeepaliveInterval=avipsIsakmpPeerKeepaliveInterval, avipsIskampEstablished=avipsIskampEstablished, avipsPeerGroupPeersTable=avipsPeerGroupPeersTable, avipsTranSetEspEncrTran=avipsTranSetEspEncrTran, avipsIsakmpPeerKeepaliveRetryInterval=avipsIsakmpPeerKeepaliveRetryInterval, avipsCryptoMapPeerIdType=avipsCryptoMapPeerIdType, avipsTunnelInDropHmacFailPkts=avipsTunnelInDropHmacFailPkts, avipsTunnelPeerRemoteType=avipsTunnelPeerRemoteType, IkeHashAlgo=IkeHashAlgo, avipsPeerGroupPeersRowStatus=avipsPeerGroupPeersRowStatus, avipsTunnelDescription=avipsTunnelDescription, avipsPeerRemoteDescription=avipsPeerRemoteDescription, avipsPeerRemotePeerGrpActiveIndex=avipsPeerRemotePeerGrpActiveIndex, avipsPeerInDecompOctetsWraps=avipsPeerInDecompOctetsWraps, avipsIsakmpPeerTable=avipsIsakmpPeerTable, avipsMonitoringTablesGlobals=avipsMonitoringTablesGlobals, avipsIsakmpPeerEntry=avipsIsakmpPeerEntry, IsakmpIdentityValue=IsakmpIdentityValue, avipsIsakmpPeerSelfIdType=avipsIsakmpPeerSelfIdType, avipsNatTEnabled=avipsNatTEnabled, avipsTunnelEntry=avipsTunnelEntry, avipsTranSetEspHashTran=avipsTranSetEspHashTran, avipsNatTKeepaliveInterval=avipsNatTKeepaliveInterval, avipsTranSetEntry=avipsTranSetEntry, avipsIsakmpPeerIsaPlcyId1=avipsIsakmpPeerIsaPlcyId1, avipsPeerIsakmpState=avipsPeerIsakmpState, avipsTunnelInDropBadTrailerPkts=avipsTunnelInDropBadTrailerPkts, avipsIskampClosed=avipsIskampClosed, avipsIpsecGroup=avipsIpsecGroup, avipsTunnelSubIndex=avipsTunnelSubIndex, avipsPeerTunnelsInProgress=avipsPeerTunnelsInProgress, avipsPeerLocalAddress=avipsPeerLocalAddress, avipsIpsecTunnelEstablished=avipsIpsecTunnelEstablished, avipsPeerRemoteType=avipsPeerRemoteType, avipsIsakmpPeerKeepaliveTrackId=avipsIsakmpPeerKeepaliveTrackId, avipsTunnelInDropSaExpiredPkts=avipsTunnelInDropSaExpiredPkts, avipsPeerGroupPeersPGrpName=avipsPeerGroupPeersPGrpName, avipsTunnelOutCompRatio=avipsTunnelOutCompRatio, IpsecEncapMode=IpsecEncapMode, avipsPeerGroupPeersEntry=avipsPeerGroupPeersEntry, avipsIsakmpPlcyId=avipsIsakmpPlcyId, avipsTranSetEncapMode=avipsTranSetEncapMode, avipsPeerLocalValue=avipsPeerLocalValue, avipsIsakmpPlcyDescription=avipsIsakmpPlcyDescription, avipsPeerGroupPeersPIdType=avipsPeerGroupPeersPIdType, avipsPeerInOctetsWraps=avipsPeerInOctetsWraps, avipsTunnelStateLastChange=avipsTunnelStateLastChange, avipsTunnelLastCntrsReset=avipsTunnelLastCntrsReset, avipsTunnelInDecompRatio=avipsTunnelInDecompRatio, avipsCryptoMapDescription=avipsCryptoMapDescription, avipsIsakmpPlcyEntry=avipsIsakmpPlcyEntry, IkeEncryptAlgo=IkeEncryptAlgo, avipsTunnelPeerLocalId=avipsTunnelPeerLocalId, avipsTunnelProxyLocalMask=avipsTunnelProxyLocalMask, avipsPeerGroupPeersPIdValue=avipsPeerGroupPeersPIdValue, avipsTranRowStatus=avipsTranRowStatus, avipsIsakmpPlcyTable=avipsIsakmpPlcyTable, avipsMonitorRstCntrs=avipsMonitorRstCntrs, avipsMIBObjects=avipsMIBObjects, avipsTranSetName=avipsTranSetName, avipsIsakmpPeerInitiateMode=avipsIsakmpPeerInitiateMode, avipsPeerInDropPkts=avipsPeerInDropPkts, avipsPeerOutUncompOctets=avipsPeerOutUncompOctets, avipsMonitoringTables=avipsMonitoringTables, avipsPeerRemoteValue=avipsPeerRemoteValue, avipsPeerInOctets=avipsPeerInOctets, avipsIsakmpPeerSelfId=avipsIsakmpPeerSelfId, avipsTunnelOutDropNoSaPkts=avipsTunnelOutDropNoSaPkts, avipsPeerTable=avipsPeerTable, avipsIsakmpPlcyLifetime=avipsIsakmpPlcyLifetime, avipsTunnelInDropInvalidIdPkts=avipsTunnelInDropInvalidIdPkts, avipsPeerTunnelsClosed=avipsPeerTunnelsClosed, avipsTranSetPfsGroup=avipsTranSetPfsGroup, avipsCryptoMapContChannel=avipsCryptoMapContChannel, avipsIskampFailed=avipsIskampFailed, avipsPeerOutCompRatio=avipsPeerOutCompRatio, avipsCryptoMapTranSetName1=avipsCryptoMapTranSetName1, avipsTunnelState=avipsTunnelState, avipsPeerInPkts=avipsPeerInPkts, DiffHellmanGrp=DiffHellmanGrp, avipsTunnelOutUncompOctets=avipsTunnelOutUncompOctets, avipsTunnelIndex=avipsTunnelIndex, avipsTunnelRemoteAddress=avipsTunnelRemoteAddress, avipsCryptoMapIsReady=avipsCryptoMapIsReady, avipsPeerLocalId=avipsPeerLocalId, avipsTranSetEspCompTran=avipsTranSetEspCompTran, avipsIpsecTunnelClosed=avipsIpsecTunnelClosed, avipsTunnelOutPkts=avipsTunnelOutPkts, avipsTunnelLocalAddress=avipsTunnelLocalAddress, avipsIsakmpPeerId=avipsIsakmpPeerId, avipsCryptoMapEntry=avipsCryptoMapEntry, avipsMIBNotificationPrefix=avipsMIBNotificationPrefix, avipsTunnelOutDropTotalPkts=avipsTunnelOutDropTotalPkts, avipsMonitoringGroup=avipsMonitoringGroup, avipsMIBNotifications=avipsMIBNotifications, avipsIsakmpPeerGroupFailbacktoPrimaryInterval=avipsIsakmpPeerGroupFailbacktoPrimaryInterval, avipsTunnelPeerLocalType=avipsTunnelPeerLocalType, avipsTunnelInOctetsWraps=avipsTunnelInOctetsWraps, avipsTunnelInDropUnprotectPkts=avipsTunnelInDropUnprotectPkts)

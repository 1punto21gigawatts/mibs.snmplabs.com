#
# PySNMP MIB module SOURCE-ROUTING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SOURCE-ROUTING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:10:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
dot1dSr, dot1dBridge = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dSr", "dot1dBridge")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Gauge32, Counter64, Counter32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, ObjectIdentity, TimeTicks, iso, IpAddress, MibIdentifier, Unsigned32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Gauge32", "Counter64", "Counter32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "ObjectIdentity", "TimeTicks", "iso", "IpAddress", "MibIdentifier", "Unsigned32", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dot1dPortPair = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 10))
dot1dSrPortTable = MibTable((1, 3, 6, 1, 2, 1, 17, 3, 1), )
if mibBuilder.loadTexts: dot1dSrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortTable.setDescription('A table that contains information about every port that is associated with this source route bridge.')
dot1dSrPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 3, 1, 1), ).setIndexNames((0, "SOURCE-ROUTING-MIB", "dot1dSrPort"))
if mibBuilder.loadTexts: dot1dSrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortEntry.setDescription('A list of information for each port of a source route bridge.')
dot1dSrPort = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPort.setDescription('The port number of the port for which this entry contains Source Route management information.')
dot1dSrPortHopCount = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrPortHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortHopCount.setDescription('The maximum number of routing descriptors allowed in an All Paths or Spanning Tree Explorer frames.')
dot1dSrPortLocalSegment = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrPortLocalSegment.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortLocalSegment.setDescription('The segment number that uniquely identifies the segment to which this port is connected. Current source routing protocols limit this value to the range: 0 through 4095. (The value 0 is used by some management applications for special test cases.) A value of 65535 signifies that no segment number is assigned to this port.')
dot1dSrPortBridgeNum = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrPortBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortBridgeNum.setDescription('A bridge number uniquely identifies a bridge when more than one bridge is used to span the same two segments. Current source routing protocols limit this value to the range: 0 through 15. A value of 65535 signifies that no bridge number is assigned to this bridge.')
dot1dSrPortTargetSegment = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrPortTargetSegment.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortTargetSegment.setDescription('The segment number that corresponds to the target segment this port is considered to be connected to by the bridge. Current source routing protocols limit this value to the range: 0 through 4095. (The value 0 is used by some management applications for special test cases.) A value of 65535 signifies that no target segment is assigned to this port.')
dot1dSrPortLargestFrame = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrPortLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortLargestFrame.setDescription('The maximum size of the INFO field (LLC and above) that this port can send/receive. It does not include any MAC level (framing) octets. The value of this object is used by this bridge to determine whether a modification of the LargestFrame (LF, see [14]) field of the Routing Control field of the Routing Information Field is necessary. 64 valid values are defined by the IEEE 802.5M SRT Addendum: 516, 635, 754, 873, 993, 1112, 1231, 1350, 1470, 1542, 1615, 1688, 1761, 1833, 1906, 1979, 2052, 2345, 2638, 2932, 3225, 3518, 3812, 4105, 4399, 4865, 5331, 5798, 6264, 6730, 7197, 7663, 8130, 8539, 8949, 9358, 9768, 10178, 10587, 10997, 11407, 12199, 12992, 13785, 14578, 15370, 16163, 16956, 17749, 20730, 23711, 26693, 29674, 32655, 35637, 38618, 41600, 44591, 47583, 50575, 53567, 56559, 59551, and 65535. An illegal value will not be accepted by the bridge.')
dot1dSrPortSTESpanMode = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto-span", 1), ("disabled", 2), ("forced", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrPortSTESpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortSTESpanMode.setDescription("Determines how this port behaves when presented with a Spanning Tree Explorer frame. The value 'disabled(2)' indicates that the port will not accept or send Spanning Tree Explorer packets; any STE packets received will be silently discarded. The value 'forced(3)' indicates the port will always accept and propagate Spanning Tree Explorer frames. This allows a manually configured Spanning Tree for this class of packet to be configured. Note that unlike transparent bridging, this is not catastrophic to the network if there are loops. The value 'auto-span(1)' can only be returned by a bridge that both implements the Spanning Tree Protocol and has use of the protocol enabled on this port. The behavior of the port for Spanning Tree Explorer frames is determined by the state of dot1dStpPortState. If the port is in the 'forwarding' state, the frame will be accepted or propagated. Otherwise, it will be silently discarded.")
dot1dSrPortSpecInFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortSpecInFrames.setDescription("The number of Specifically Routed frames, also referred to as Source Routed Frames, that have been received from this port's segment.")
dot1dSrPortSpecOutFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortSpecOutFrames.setDescription('The number of Specifically Routed frames, also referred to as Source Routed Frames, that this port has transmitted on its segment.')
dot1dSrPortApeInFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortApeInFrames.setDescription('The number of All Paths Explorer frames, also referred to as All Routes Explorer frames, that have been received by this port from its segment.')
dot1dSrPortApeOutFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortApeOutFrames.setDescription('The number of all Paths Explorer Frames, also referred to as All Routes Explorer frames, that have been transmitted by this port on its segment.')
dot1dSrPortSteInFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortSteInFrames.setDescription('The number of spanning tree explorer frames that have been received by this port from its segment.')
dot1dSrPortSteOutFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortSteOutFrames.setDescription('The number of spanning tree explorer frames that have been transmitted by this port on its segment.')
dot1dSrPortSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortSegmentMismatchDiscards.setDescription('The number of explorer frames that have been discarded by this port because the routing descriptor field contained an invalid adjacent segment value.')
dot1dSrPortDuplicateSegmentDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortDuplicateSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortDuplicateSegmentDiscards.setDescription('The number of frames that have been discarded by this port because the routing descriptor field contained a duplicate segment identifier.')
dot1dSrPortHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortHopCountExceededDiscards.setDescription('The number of explorer frames that have been discarded by this port because the Routing Information Field has exceeded the maximum route descriptor length.')
dot1dSrPortDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortDupLanIdOrTreeErrors.setDescription('The number of duplicate LAN IDs or Tree errors. This helps in detection of problems in networks containing older IBM Source Routing Bridges.')
dot1dSrPortLanIdMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dSrPortLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrPortLanIdMismatches.setDescription('The number of ARE and STE frames that were discarded because the last LAN ID in the routing information field did not equal the LAN-in ID. This error can occur in implementations which do only a LAN-in ID and Bridge Number check instead of a LAN-in ID, Bridge Number, and LAN-out ID check before they forward broadcast frames.')
dot1dSrBridgeLfMode = MibScalar((1, 3, 6, 1, 2, 1, 17, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mode3", 1), ("mode6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dSrBridgeLfMode.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dSrBridgeLfMode.setDescription('Indicates whether the bridge operates using older 3 bit length negotiation fields or the newer 6 bit length field in its RIF.')
dot1dPortPairTableSize = MibScalar((1, 3, 6, 1, 2, 1, 17, 10, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dPortPairTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairTableSize.setDescription('The total number of entries in the Bridge Port Pair Database.')
dot1dPortPairTable = MibTable((1, 3, 6, 1, 2, 1, 17, 10, 2), )
if mibBuilder.loadTexts: dot1dPortPairTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairTable.setDescription('A table that contains information about every port pair database entity associated with this source routing bridge.')
dot1dPortPairEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 10, 2, 1), ).setIndexNames((0, "SOURCE-ROUTING-MIB", "dot1dPortPairLowPort"), (0, "SOURCE-ROUTING-MIB", "dot1dPortPairHighPort"))
if mibBuilder.loadTexts: dot1dPortPairEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairEntry.setDescription('A list of information for each port pair entity of a bridge.')
dot1dPortPairLowPort = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortPairLowPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairLowPort.setDescription('The port number of the lower numbered port for which this entry contains port pair database information.')
dot1dPortPairHighPort = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortPairHighPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairHighPort.setDescription('The port number of the higher numbered port for which this entry contains port pair database information.')
dot1dPortPairBridgeNum = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 10, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortPairBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairBridgeNum.setDescription('A bridge number that uniquely identifies the path provided by this source routing bridge between the segments connected to dot1dPortPairLowPort and dot1dPortPairHighPort. The purpose of bridge number is to disambiguate between multiple paths connecting the same two LANs.')
dot1dPortPairBridgeState = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dPortPairBridgeState.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dPortPairBridgeState.setDescription("The state of dot1dPortPairBridgeNum. Writing 'invalid(3)' to this object removes the corresponding entry.")
mibBuilder.exportSymbols("SOURCE-ROUTING-MIB", dot1dSrPort=dot1dSrPort, dot1dSrPortDupLanIdOrTreeErrors=dot1dSrPortDupLanIdOrTreeErrors, dot1dSrPortTable=dot1dSrPortTable, dot1dSrPortLanIdMismatches=dot1dSrPortLanIdMismatches, dot1dSrPortHopCount=dot1dSrPortHopCount, dot1dPortPairHighPort=dot1dPortPairHighPort, dot1dPortPairTableSize=dot1dPortPairTableSize, dot1dPortPairTable=dot1dPortPairTable, dot1dSrPortTargetSegment=dot1dSrPortTargetSegment, dot1dSrBridgeLfMode=dot1dSrBridgeLfMode, dot1dPortPairLowPort=dot1dPortPairLowPort, dot1dPortPairBridgeState=dot1dPortPairBridgeState, dot1dSrPortSteOutFrames=dot1dSrPortSteOutFrames, dot1dPortPairEntry=dot1dPortPairEntry, dot1dSrPortBridgeNum=dot1dSrPortBridgeNum, dot1dSrPortSteInFrames=dot1dSrPortSteInFrames, dot1dSrPortEntry=dot1dSrPortEntry, dot1dPortPairBridgeNum=dot1dPortPairBridgeNum, dot1dSrPortSpecInFrames=dot1dSrPortSpecInFrames, dot1dSrPortLargestFrame=dot1dSrPortLargestFrame, dot1dPortPair=dot1dPortPair, dot1dSrPortApeInFrames=dot1dSrPortApeInFrames, dot1dSrPortDuplicateSegmentDiscards=dot1dSrPortDuplicateSegmentDiscards, dot1dSrPortApeOutFrames=dot1dSrPortApeOutFrames, dot1dSrPortLocalSegment=dot1dSrPortLocalSegment, dot1dSrPortSpecOutFrames=dot1dSrPortSpecOutFrames, dot1dSrPortSTESpanMode=dot1dSrPortSTESpanMode, dot1dSrPortHopCountExceededDiscards=dot1dSrPortHopCountExceededDiscards, dot1dSrPortSegmentMismatchDiscards=dot1dSrPortSegmentMismatchDiscards)

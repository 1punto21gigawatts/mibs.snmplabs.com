#
# PySNMP MIB module TUBS-IBR-LINUX-NETFILTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TUBS-IBR-LINUX-NETFILTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:27:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InetAddress, InetAddressPrefixLength, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter32, Integer32, IpAddress, NotificationType, Unsigned32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, MibIdentifier, iso, ModuleIdentity, TimeTicks, Bits, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Integer32", "IpAddress", "NotificationType", "Unsigned32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "MibIdentifier", "iso", "ModuleIdentity", "TimeTicks", "Bits", "ObjectIdentity")
TimeStamp, DisplayString, RowStatus, TruthValue, StorageType, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "RowStatus", "TruthValue", "StorageType", "TextualConvention")
ibr, = mibBuilder.importSymbols("TUBS-SMI", "ibr")
lnfMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 1575, 1, 13))
lnfMIB.setRevisions(('2002-07-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: lnfMIB.setRevisionsDescriptions(('The initial revision of this module. This revision does not cover any match extensions and target extensions.',))
if mibBuilder.loadTexts: lnfMIB.setLastUpdated('200207230000Z')
if mibBuilder.loadTexts: lnfMIB.setOrganization('TU Braunschweig')
if mibBuilder.loadTexts: lnfMIB.setContactInfo('Frank Strauss, Oliver Wellnitz TU Braunschweig Muehlenpfordtstrasse 23 38106 Braunschweig Germany Tel: +49 531 391 3283 Fax: +49 531 391 5936 E-mail: {strauss,wellnitz}@ibr.cs.tu-bs.de')
if mibBuilder.loadTexts: lnfMIB.setDescription('Experimental MIB module for the Linux 2.4 netfilter subsystem.')
lnfObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1))
lnfTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1575, 1, 13, 2))
lnfConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 1575, 1, 13, 3))
class LnfTarget(TextualConvention, Integer32):
    description = 'This data type represents an action that is about to be applied to a packet. none(1): No action, except increasing counters. other(2): An unknown extension action which cannot be described by the values specified below. drop(3): Drop the packet on the floor. accept(4): Let the packet through. queue(5): Pass the packet to userspace. return(6): Stop traversing this chain and resume at the next rule in the previous (calling) chain. chain(7): Jump to the user chain specified by a related object. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("none", 1), ("other", 2), ("drop", 3), ("accept", 4), ("queue", 5), ("return", 6), ("chain", 7))

lnfLastChange = MibScalar((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfLastChange.setStatus('current')
if mibBuilder.loadTexts: lnfLastChange.setDescription('The time of the last netfilter configuration change of any kind, including any creation, deletion or modification of any table of this MIB.')
lnfTableTable = MibTable((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 2), )
if mibBuilder.loadTexts: lnfTableTable.setStatus('current')
if mibBuilder.loadTexts: lnfTableTable.setDescription('A list of all tables installed on the netfilter subsystem.')
lnfTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 2, 1), ).setIndexNames((0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableAddressType"), (0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableName"))
if mibBuilder.loadTexts: lnfTableEntry.setStatus('current')
if mibBuilder.loadTexts: lnfTableEntry.setDescription('An entry describing a particular netfilter table.')
lnfTableAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 2, 1, 1), InetAddressType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))))
if mibBuilder.loadTexts: lnfTableAddressType.setStatus('current')
if mibBuilder.loadTexts: lnfTableAddressType.setDescription('The address type for which the netfilter table works.')
lnfTableName = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: lnfTableName.setStatus('current')
if mibBuilder.loadTexts: lnfTableName.setDescription('The name of the netfilter table.')
lnfTableLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 2, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfTableLastChange.setStatus('current')
if mibBuilder.loadTexts: lnfTableLastChange.setDescription('The time of the last modification of this netfilter table, including the creation or deletion of a netfilter chain that belongs to this table.')
lnfChainTable = MibTable((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3), )
if mibBuilder.loadTexts: lnfChainTable.setStatus('current')
if mibBuilder.loadTexts: lnfChainTable.setDescription('A list of all chains installed on the netfilter subsystem.')
lnfChainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1), ).setIndexNames((0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableAddressType"), (0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableName"), (0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainName"))
if mibBuilder.loadTexts: lnfChainEntry.setStatus('current')
if mibBuilder.loadTexts: lnfChainEntry.setDescription('An entry describing a particular netfilter chain.')
lnfChainName = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: lnfChainName.setStatus('current')
if mibBuilder.loadTexts: lnfChainName.setDescription('The netfilter chain to which the rule belongs.')
lnfChainPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfChainPackets.setStatus('current')
if mibBuilder.loadTexts: lnfChainPackets.setDescription('The number of packets that passed this chain since the rule was installed or reset.')
lnfChainOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfChainOctets.setStatus('current')
if mibBuilder.loadTexts: lnfChainOctets.setDescription('The number of octets that passed this chain since the chain was installed or reset.')
lnfChainTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 4), LnfTarget().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 6))).clone(namedValues=NamedValues(("drop", 3), ("accept", 4), ("return", 6))).clone('return')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfChainTarget.setStatus('current')
if mibBuilder.loadTexts: lnfChainTarget.setDescription('The action that shall be applied to a packet if no rule within the chain matches. Note that user-defined chains only allow return(6).')
lnfChainLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfChainLastChange.setStatus('current')
if mibBuilder.loadTexts: lnfChainLastChange.setDescription('The time of the last modification of this netfilter chain, including the creation or deletion of a netfilter rule that belongs to this chain.')
lnfChainStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfChainStorage.setStatus('current')
if mibBuilder.loadTexts: lnfChainStorage.setDescription('This object defines whether this row is kept in volatile storage and lost upon reboot or whether it is backed up by stable storage or builtin.')
lnfChainStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfChainStatus.setStatus('current')
if mibBuilder.loadTexts: lnfChainStatus.setDescription('This object is used to create and delete rows in the lnfChainTable.')
lnfRuleTable = MibTable((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4), )
if mibBuilder.loadTexts: lnfRuleTable.setStatus('current')
if mibBuilder.loadTexts: lnfRuleTable.setDescription('A list of all rules installed on the netfilter subsystem.')
lnfRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1), ).setIndexNames((0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableAddressType"), (0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableName"), (0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainName"), (0, "TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleIndex"))
if mibBuilder.loadTexts: lnfRuleEntry.setStatus('current')
if mibBuilder.loadTexts: lnfRuleEntry.setDescription('An entry describing a particular netfilter rule. Rules of different netfilter tables and chains are distinguished by the corresponding index objects.')
lnfRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lnfRuleIndex.setStatus('current')
if mibBuilder.loadTexts: lnfRuleIndex.setDescription('A unique number identifying the rule within a netfilter chain.')
lnfRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: lnfRuleProtocol.setDescription('The protocol of the rule. The number zero matches all protocols.')
lnfRuleProtocolInv = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleProtocolInv.setStatus('current')
if mibBuilder.loadTexts: lnfRuleProtocolInv.setDescription('This flag specifies whether the lnfRuleProtocol test has to be inverted.')
lnfRuleSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleSourceAddress.setStatus('current')
if mibBuilder.loadTexts: lnfRuleSourceAddress.setDescription('The source address of a packet. The exact format depends on the address type specified by lnfRuleAddressType. This test is applied for an address prefix whose length is specified by lnfRuleSourceAddressPrefixLength. If a new row is created this object should default to an all-zeros value with a length approrpiate for the corresponding lnfRuleAddressType object value.')
lnfRuleSourceAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 5), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleSourceAddressPrefixLength.setStatus('current')
if mibBuilder.loadTexts: lnfRuleSourceAddressPrefixLength.setDescription('The network prefix length associated with lnfRuleSourceAddress.')
lnfRuleSourceAddressInv = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleSourceAddressInv.setStatus('current')
if mibBuilder.loadTexts: lnfRuleSourceAddressInv.setDescription('This flag specifies whether the lnfRuleSourceAddress and lnfRuleSourceAddressPrefixLength test has to be inverted.')
lnfRuleDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleDestinationAddress.setStatus('current')
if mibBuilder.loadTexts: lnfRuleDestinationAddress.setDescription('The destination address of a packet. The exact format depends on the address type specified by lnfRuleAddressType. This test is applied for an address prefix whose length is specified by lnfRuleDestinationAddressPrefixLength. If a new row is created this object should default to an all-zeros value with a length approrpiate for the corresponding lnfRuleAddressType object value.')
lnfRuleDestinationAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 8), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleDestinationAddressPrefixLength.setStatus('current')
if mibBuilder.loadTexts: lnfRuleDestinationAddressPrefixLength.setDescription('The network prefix length associated with lnfRuleDestinationAddress.')
lnfRuleDestinationAddressInv = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleDestinationAddressInv.setStatus('current')
if mibBuilder.loadTexts: lnfRuleDestinationAddressInv.setDescription('This flag specifies whether the lnfRuleDestinationAddress and lnfRuleDestinationAddressPrefixLength test has to be inverted.')
lnfRuleInInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleInInterface.setStatus('current')
if mibBuilder.loadTexts: lnfRuleInInterface.setDescription("Name of an interface via which a packet is going to be received (only for packets entering the INPUT, FORWARD and PREROUTING chains). If the interface name ends in a '+', then any interface which begins with this name will match. If this is an empty string, any interface name will match.")
lnfRuleInInterfaceInv = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleInInterfaceInv.setStatus('current')
if mibBuilder.loadTexts: lnfRuleInInterfaceInv.setDescription('This flag specifies whether the lnfRuleInInterface test has to be inverted.')
lnfRuleOutInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleOutInterface.setStatus('current')
if mibBuilder.loadTexts: lnfRuleOutInterface.setDescription("Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). If the interface name ends in a '+', then any interface which begins with this name will match. If this is an empty string, any interface name will match.")
lnfRuleOutInterfaceInv = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleOutInterfaceInv.setStatus('current')
if mibBuilder.loadTexts: lnfRuleOutInterfaceInv.setDescription('This flag specifies whether the lnfRuleOutInterface test has to be inverted.')
lnfRuleFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleFragment.setStatus('current')
if mibBuilder.loadTexts: lnfRuleFragment.setDescription('If this flag is true, the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them.')
lnfRuleFragmentInv = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleFragmentInv.setStatus('current')
if mibBuilder.loadTexts: lnfRuleFragmentInv.setDescription('This flag specifies whether the lnfRuleFragmentInv test, if true, has to be inverted. An inverted rule will only match head fragments, or unfragmented packets.')
lnfRulePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfRulePackets.setStatus('current')
if mibBuilder.loadTexts: lnfRulePackets.setDescription('The number of packets that matched this rule since the rule was installed or reset.')
lnfRuleOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfRuleOctets.setStatus('current')
if mibBuilder.loadTexts: lnfRuleOctets.setDescription('The number of octets that matched this rule since the rule was installed or reset.')
lnfRuleTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 18), LnfTarget().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleTarget.setStatus('current')
if mibBuilder.loadTexts: lnfRuleTarget.setDescription('The action that shall be applied to a packet if the rule matches. If the value is chain(7), then jump to the user chain specified by lnfRuleTargetChain.')
lnfRuleTargetChain = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 19), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleTargetChain.setStatus('current')
if mibBuilder.loadTexts: lnfRuleTargetChain.setDescription('The name of the target chain if the value of lnfRuleTarget is chain(7).')
lnfRuleTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lnfRuleTrapEnable.setStatus('current')
if mibBuilder.loadTexts: lnfRuleTrapEnable.setDescription("Indicates whether lnfRuleMatch traps should be generated for packets matching this rule. Note that it's up to the implementation to delay and accumulate mutliple traps in order to reduce the number of emitted traps.")
lnfRuleLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 21), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lnfRuleLastChange.setStatus('current')
if mibBuilder.loadTexts: lnfRuleLastChange.setDescription('The time of the last modification of this netfilter rule. If it has been unchanged since the last re-initialization of the local network management subsystem, then this object contains a zero value.')
lnfRuleStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 22), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleStorage.setStatus('current')
if mibBuilder.loadTexts: lnfRuleStorage.setDescription('This object defines whether this row is kept in volatile storage and lost upon reboot or whether it is backed up by stable storage or builtin.')
lnfRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1575, 1, 13, 1, 4, 1, 23), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lnfRuleStatus.setStatus('current')
if mibBuilder.loadTexts: lnfRuleStatus.setDescription('This object is used to create and delete rows in the lnfRuleTable.')
lnfNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 1575, 1, 13, 2, 0))
lnfRuleMatch = NotificationType((1, 3, 6, 1, 4, 1, 1575, 1, 13, 2, 0, 1)).setObjects(("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRulePackets"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleOctets"))
if mibBuilder.loadTexts: lnfRuleMatch.setStatus('current')
if mibBuilder.loadTexts: lnfRuleMatch.setDescription("A lnfRuleMatch trap signifies that the rule to which the lnfRulePackets and lnfRuleOctets objects belong was matched by at least one packets since the last trap for the same rule was emitted. The agent may delay and accumulate mutliple traps in order to reduce the number of emitted traps, but the time for accumulation should be no more than 60 seconds. Note that detailed information on the packet(s) that triggered a trap is not available from the trap's objects. This would cause problems with the accumulation of matches and/or increased trap traffic.")
lnfCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 1575, 1, 13, 3, 1))
lnfGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 1575, 1, 13, 3, 2))
lnfCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 1575, 1, 13, 3, 1, 1)).setObjects(("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfGeneralGroup"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lnfCompliance = lnfCompliance.setStatus('current')
if mibBuilder.loadTexts: lnfCompliance.setDescription('The compliance statement for an SNMP entity which implements the Linux Netfilter MIB.')
lnfGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 1575, 1, 13, 3, 2, 1)).setObjects(("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfLastChange"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfTableLastChange"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainPackets"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainOctets"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainTarget"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainLastChange"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainStorage"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfChainStatus"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleProtocol"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleProtocolInv"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleSourceAddress"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleSourceAddressPrefixLength"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleSourceAddressInv"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleDestinationAddress"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleDestinationAddressPrefixLength"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleDestinationAddressInv"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleInInterface"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleInInterfaceInv"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleOutInterface"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleOutInterfaceInv"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleFragment"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleFragmentInv"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRulePackets"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleOctets"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleTarget"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleTargetChain"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleTrapEnable"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleLastChange"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleStorage"), ("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lnfGeneralGroup = lnfGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: lnfGeneralGroup.setDescription('A collection of all Linux Netfilter objects of the core table.')
lnfNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 1575, 1, 13, 3, 2, 2)).setObjects(("TUBS-IBR-LINUX-NETFILTER-MIB", "lnfRuleMatch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lnfNotificationGroup = lnfNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: lnfNotificationGroup.setDescription('A collection of all Linux Netfilter notifications.')
mibBuilder.exportSymbols("TUBS-IBR-LINUX-NETFILTER-MIB", lnfRuleDestinationAddress=lnfRuleDestinationAddress, lnfRuleFragment=lnfRuleFragment, lnfChainTarget=lnfChainTarget, lnfCompliances=lnfCompliances, lnfChainStorage=lnfChainStorage, lnfRuleProtocol=lnfRuleProtocol, lnfRuleProtocolInv=lnfRuleProtocolInv, lnfRuleDestinationAddressInv=lnfRuleDestinationAddressInv, lnfRuleTarget=lnfRuleTarget, lnfChainTable=lnfChainTable, LnfTarget=LnfTarget, lnfRulePackets=lnfRulePackets, lnfTableLastChange=lnfTableLastChange, lnfRuleInInterfaceInv=lnfRuleInInterfaceInv, lnfTableEntry=lnfTableEntry, lnfChainEntry=lnfChainEntry, lnfTraps=lnfTraps, lnfChainName=lnfChainName, lnfChainLastChange=lnfChainLastChange, lnfConformance=lnfConformance, lnfNotificationGroup=lnfNotificationGroup, lnfRuleIndex=lnfRuleIndex, lnfRuleOutInterfaceInv=lnfRuleOutInterfaceInv, lnfChainStatus=lnfChainStatus, lnfRuleInInterface=lnfRuleInInterface, lnfRuleFragmentInv=lnfRuleFragmentInv, lnfRuleEntry=lnfRuleEntry, lnfRuleSourceAddressInv=lnfRuleSourceAddressInv, lnfRuleDestinationAddressPrefixLength=lnfRuleDestinationAddressPrefixLength, lnfRuleOctets=lnfRuleOctets, lnfGroups=lnfGroups, lnfCompliance=lnfCompliance, lnfTableTable=lnfTableTable, lnfRuleLastChange=lnfRuleLastChange, lnfTableName=lnfTableName, lnfRuleTable=lnfRuleTable, lnfRuleSourceAddressPrefixLength=lnfRuleSourceAddressPrefixLength, lnfRuleOutInterface=lnfRuleOutInterface, lnfRuleTrapEnable=lnfRuleTrapEnable, lnfRuleSourceAddress=lnfRuleSourceAddress, lnfTableAddressType=lnfTableAddressType, lnfRuleStorage=lnfRuleStorage, lnfLastChange=lnfLastChange, lnfRuleTargetChain=lnfRuleTargetChain, lnfRuleStatus=lnfRuleStatus, lnfNotifications=lnfNotifications, lnfGeneralGroup=lnfGeneralGroup, lnfRuleMatch=lnfRuleMatch, lnfChainOctets=lnfChainOctets, lnfChainPackets=lnfChainPackets, PYSNMP_MODULE_ID=lnfMIB, lnfMIB=lnfMIB, lnfObjects=lnfObjects)

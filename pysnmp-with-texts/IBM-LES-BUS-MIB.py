#
# PySNMP MIB module IBM-LES-BUS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-LES-BUS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
AtmLaneAddress, = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "AtmLaneAddress")
lesConfIndex, lesConfEntry = mibBuilder.importSymbols("LAN-EMULATION-LES-MIB", "lesConfIndex", "lesConfEntry")
AtmPrivateAddrEsi, AtmSelector, AtmVccTrafficType, Bandwidth, mssServerLanE = mibBuilder.importSymbols("NWAYSMSS-MIB", "AtmPrivateAddrEsi", "AtmSelector", "AtmVccTrafficType", "Bandwidth", "mssServerLanE")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, Counter32, Integer32, ModuleIdentity, Unsigned32, TimeTicks, Gauge32, MibIdentifier, iso, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, IpAddress, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Counter32", "Integer32", "ModuleIdentity", "Unsigned32", "TimeTicks", "Gauge32", "MibIdentifier", "iso", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "IpAddress", "Bits")
TextualConvention, TruthValue, TimeStamp, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "TimeStamp", "DisplayString", "MacAddress")
ibmLesBusMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1))
ibmLesBusConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1))
ibmLesBusStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 2))
ibmBusMonStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3))
ibmLesBusMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4))
ibmLesBusMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4, 1))
ibmLesBusMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4, 2))
ibmLesBusConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1), )
if mibBuilder.loadTexts: ibmLesBusConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLesBusConfTable.setDescription('This table contains configuration information for the LESs within the scope of the agent.')
ibmLesBusConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: ibmLesBusConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLesBusConfEntry.setDescription('Each entry in this table represents a LES. The parameters in each entry apply to one emulated LAN served by one LES. Objects lesLanType and lesMaxFrameSize are also required besides lesRowStatus during row creation.')
atmDevNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDevNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmDevNum.setDescription('Identifies ATM device to be used by LES/BUS. ')
useBurnedInEsi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: useBurnedInEsi.setStatus('mandatory')
if mibBuilder.loadTexts: useBurnedInEsi.setDescription('Specifies whether a MAC Address burned into the ATM device should be used as the End System Identifier component of the LES/BUS ATM Address.')
configuredEsi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 3), AtmPrivateAddrEsi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configuredEsi.setStatus('mandatory')
if mibBuilder.loadTexts: configuredEsi.setDescription('Locally Administered End System Identifier that is to be used as the ESI component of the LES/BUS ATM Address. If this object is used do not use the ATM Forum elanLecAtmMask. If both are used the last object set will take affect.')
configuredSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 4), AtmSelector()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configuredSelector.setStatus('mandatory')
if mibBuilder.loadTexts: configuredSelector.setDescription('Specifies value to be used as Selector field component of LES/BUS ATM Address. If this object is used do not use the ATM Forum elanLecAtmMask. If both are used the last object set will take affect.')
leArpResponseDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("oneClient", 0), ("allClients", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: leArpResponseDest.setStatus('mandatory')
if mibBuilder.loadTexts: leArpResponseDest.setDescription("When the value is ALL_CLIENTS, LE_ARP_RESPONSE frames initiated or forwarded by the LES are sent to all clients on the Point-to-Multipoint Control Distribute VCC(s). When the value is ONE_CLIENT, LE_ARP_RESPONSE frames are sent solely to the client that originated the associated LE_ARP_REQUEST over the Control Direct VCC to that client. The primary advantage of sending LE_ARP_RESPONSE frames to all clients is that the clients are provided an opportunity to learn new {LAN Destination, ATM Address} mappings by 'eavesdropping' (secondary effects include lower LES processing requirements and less latency introduced by the LES). The potential disadvantage is that the benefits of eavesdropping, if it is even performed, may not compensate for the additional client overhead. ")
use2ControlDistributeVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: use2ControlDistributeVccs.setStatus('mandatory')
if mibBuilder.loadTexts: use2ControlDistributeVccs.setDescription('When TRUE, proxy clients are placed on one Point-to-Multipoint Control Distribute VCC and all other clients are placed on another Point-to-Multipoint Control Distribute VCC. When FALSE, all clients are placed on a single Point-to-Multipoint Control Distribute VCC. The advantage of using two Control Distribute VCCs is that non-proxy clients are not perturbed by LE_ARP_REQUESTs for unregistered LAN Destinations (the LES answers LE_ARP_REQUESTs for registered LAN Destinations). The disadvantage is that Control Frames destined for all clients (LE_TOPOLOGY_REQUEST, LE_NARP_REQUEST, and possibly LE_ARP_RESPONSE depending upon LES-BUS-12) must be transmitted on 2 VCCs (as a related aside, note that LE_FLUSH_RESPONSEs are sent solely to the originator of the corresponding LE_FLUSH_REQUEST over the Control Direct VCC to that client).')
use2MulticastForwardVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: use2MulticastForwardVccs.setStatus('mandatory')
if mibBuilder.loadTexts: use2MulticastForwardVccs.setDescription("When TRUE: - proxy clients are placed on one Point-to-Multipoint Multicast Forward VCC and all other clients are placed on another Point-to-Multipoint Multicast Forward VCC, - all 'unknown' unicast frames and all unicast frames for LAN Destinations registered by proxy clients are forwarded on the Proxy Multicast Forward VCC ('unknown' unicast frames are not forwarded to non-proxy clients), - all unicast frames for LAN Destinations registered by non-proxy clients are forwarded on the Multicast Send VCC to that client, and - multicast and broadcast frames are transmitted on both Multicast Forward VCCs. When FALSE: - all clients are placed on a single Point-to-Multipoint Multicast Forward VCC, and - the BUS functions as a simple forwarding device (efficient, but 'dumb') with respect to unicast frames. One advantage of enabling this option is a reduction in client pertubation due to 'nuisance' unicast frames (i.e., unicast frames not destined for the client); proxy clients do not receive unicast frames destined for non-proxy clients, and non-proxy clients never receive nuisance unicast frames. Another advantage is the reduction in network bandwidth devoted to nuisance frames. The potential disadvantage is that the increased processing requirements result in a degradation of overall system performance.")
validateBestEffortPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: validateBestEffortPcr.setStatus('mandatory')
if mibBuilder.loadTexts: validateBestEffortPcr.setDescription('When false, Best Effort Control Direct or Multicast Send VCCs will be accepted without regard to the signalled forward Peak Cell Rate (PCR). When true, Best Effort VCCs will be rejected if the signalled forward PCR exceeds the line rate of the LES/BUS ATM device. Calls will not be rejected due to the backward PCR. The signalled backward PCR will be honored if it does not exceed the line rate; otherwise, transmissions to the caller will be at line rate.')
controlDirectMaxReservedBw = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 9), Bandwidth()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlDirectMaxReservedBw.setStatus('mandatory')
if mibBuilder.loadTexts: controlDirectMaxReservedBw.setDescription('Defines the maximum acceptable Sustained Cell Rate (SCR) for a Control Direct VCC; if SCR is not specified on the incoming call, then this parameter defines the maximum acceptable Peak Cell Rate (PCR) for a Control Direct VCC with reserved bandwidth. This parameter is applied to both forward and backward directions. Calls received with Traffic Parameters specifying higher rates will be released. If SCR is specified on the incoming call, the call will not be rejected due to the PCR or Maximum Burst Size. The constraint imposed by this parameter is not applicable to BEST EFFORT connections. ')
multicastSendMaxReservedBw = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 10), Bandwidth()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multicastSendMaxReservedBw.setStatus('mandatory')
if mibBuilder.loadTexts: multicastSendMaxReservedBw.setDescription('Defines the maximum acceptable Sustained Cell Rate (SCR) for a Multicast Send VCC; if SCR is not specified on the incoming call, then this parameter defines the maximum acceptable Peak Cell Rate (PCR) for a Multicast Send VCC with reserved bandwidth. This parameter is applied to both forward and backward directions. Calls received with Traffic Parameters specifying higher rates will be released. If SCR is specified on the incoming call, the call will not be rejected due to the PCR or Maximum Burst Size. The constraint imposed by this parameter is not applicable to BEST EFFORT connections. ')
controlDistributeVccType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 11), AtmVccTrafficType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlDistributeVccType.setStatus('mandatory')
if mibBuilder.loadTexts: controlDistributeVccType.setDescription('Specifies type of traffic characteristics to be associated with Control Distribute VCC(s). Bandwidth is not reserved for best effort traffic.')
controlDistributePcr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 12), Bandwidth()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlDistributePcr.setStatus('mandatory')
if mibBuilder.loadTexts: controlDistributePcr.setDescription('Specifies the Peak Cell Rate (PCR) Traffic Parameter for the Control Distribute VCC(s). Since the Control Distribute is a point-to-multipoint VCC, the specified rate applies to the forward direction only.')
controlDistributeScr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 13), Bandwidth()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlDistributeScr.setStatus('mandatory')
if mibBuilder.loadTexts: controlDistributeScr.setDescription('Specifies the Sustained Cell Rate (SCR) Traffic Parameter for the Control Distribute VCC(s). Since the Control Distribute is a point-to-multipoint VCC, the specified rate applies to the forward direction only. If the SCR equals the PCR specified in LES-BUS-19, the call is signalled with PCR only. If SCR is signalled, the Maximum Burst Size traffic parameter is set to accomodate the maximum control frame size of 1516 bytes. ')
multicastForwardVccType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 14), AtmVccTrafficType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multicastForwardVccType.setStatus('mandatory')
if mibBuilder.loadTexts: multicastForwardVccType.setDescription('Specifies type of traffic characteristics to be associated with Multicast Forward VCC(s). Bandwidth is not reserved for best effort traffic.')
multicastForwardPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 15), Bandwidth()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multicastForwardPcr.setStatus('mandatory')
if mibBuilder.loadTexts: multicastForwardPcr.setDescription('Specifies the Peak Cell Rate (PCR) Traffic Parameter for the Multicast Forward VCC(s). Since the Multicast Multicast Forward is a point-to-multipoint VCC, the specified rate applies to the forward direction only.')
multicastForwardScr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 16), Bandwidth()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multicastForwardScr.setStatus('mandatory')
if mibBuilder.loadTexts: multicastForwardScr.setDescription('Specifies the Sustained Cell Rate (SCR) Traffic Parameter for the Multicast Forward VCC(s). Since the Multicast Forward is a point-to-multipoint VCC, the specified rate applies to the forward direction only. If the SCR equals the PCR specified in LES-BUS-22, the call is signalled with PCR only. If SCR is signalled, the Maximum Burst Size traffic parameter is set to accomodate the maximum data frame size specified in maxDataFrameSize.')
validateJoinsWithLecs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 17), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: validateJoinsWithLecs.setStatus('mandatory')
if mibBuilder.loadTexts: validateJoinsWithLecs.setDescription('Specifies whether clients that attempt to join the ELAN must be validated by the LECS. The default value is taken from the corresponding object in the ELAN MIB, and it overrides the ELAN value.')
redundancyEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 18), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyEnabled.setDescription('Redundancy support allows clients to be assigned to a backup LES/BUS in the event that the primary LES/BUS for the ELAN fails.')
redundancyRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("neverSet", 0), ("primaryLesBus", 1), ("backupLesBus", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyRole.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyRole.setDescription('Redundancy Protocol Role. Specifies whether this LES/BUS instance is to serve as the primary or backup LES/BUS for the ELAN. This object is only valid when redundancyEnabled is true. If this object is never set and redundancyEnabled has never been set to true redundancyRole will have a value of 0.')
redundancyAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 20), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyAtmAddr.setDescription('ATM Address of Backup LES/BUS. Specifies the ATM address of the backup LES/BUS for the ELAN. Currently, only the private address formats defined by the ATM Forum are supported, there are three private ATM address formats (Data Country Code (DCC) Format, International Code Designator (ICD) Format, and E.164 Format) and all are modeled after the format of an OSI Network Service Access Point (NSAP), all three private address formats are 20 octets (ATM_PRIVATE_ADDR_OCTETS) in length, and the most significant octet contains an Authority and Format Identifier (AFI) field that identifies the address format (see constants ATM_ADDR_DCC_AFI, ATM_ADDR_ICD_AFI, and ATM_ADDR_E164_AFI), the remaining octets of the address are divided into an Initial Domain Identifier (IDI) and a Domain Specific Part (DSP), the IDI has specific encoding rules that may be enforced by the configurator (see Section 5.1.3 of the ATM Forum UNI Specification).')
bmonEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bmonEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: bmonEnabled.setDescription('Enable BUS Monitor for ELAN. When TRUE, host usage of the Broadcast and Unknown Server is monitored. Periodic sampling is performed to provide information on the top N heaviest users of the BUS. Here, a user is defined as any MAC address originating data frames to the BUS. Information is available on the last sample interval. When FALSE, BUS Monitoring is not performed.')
numTopMacs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numTopMacs.setStatus('mandatory')
if mibBuilder.loadTexts: numTopMacs.setDescription('Number of Top MAC Addresses to Record. Specifies the number of MACs to be recorded with the highest quantity of sampled frames sent to the BUS in a sample interval.')
sampleDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sampleDuration.setStatus('mandatory')
if mibBuilder.loadTexts: sampleDuration.setDescription('Number of seconds in each Sample Interval. Specifies the number of seconds in each BUS Monitor sample interval.')
interSampleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: interSampleTime.setStatus('mandatory')
if mibBuilder.loadTexts: interSampleTime.setDescription('Minutes between start of one sample and the next sample. Specifies the number of minutes between the start of one BUS Monitor sample interval and the start of the next sample interval.')
sampleRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sampleRate.setStatus('mandatory')
if mibBuilder.loadTexts: sampleRate.setDescription('Specifies the rate at which the BUS Monitor samples frames sent to the BUS during a sample interval. A value of 1 indicates that every frame sent to the BUS is sampled. A value of 100 indicates that 1 out of every 100 frames sent to the BUS is sampled.')
busMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("systemBusMode", 1), ("adapterBusMode", 2), ("vccSpliceBusMode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: busMode.setStatus('mandatory')
if mibBuilder.loadTexts: busMode.setDescription(' With the Fast Bus Feature the BUS can run now run in one of three modes: systemBusMode(1) - Frames from BUS are buffered into system memory. All intelligent BUS mode are available in this mode. adapterBusMode(2) - Frames received for the BUS are kept in adapter memory. BCM is not available in this mode. On Token-Ring all data frames are counted as multicast frames. vccSpliceBusMode(3) - The BUS ties all Multicast Send VCCs into the Multicast Forward VCC. Frames received for the BUS are immediately forwarded onto the Multicast Foward VCC without notifying the BUS. Statistics related to frame rec/transmit are not maintained when the Bus mode is VCC Splice.')
ibmLesBusStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 2, 1), )
if mibBuilder.loadTexts: ibmLesBusStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLesBusStatTable.setDescription('This table contains all counters ???.')
ibmLesBusStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 2, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: ibmLesBusStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ibmLesBusStatEntry.setDescription('Each entry in this table contains a LES and its counters.')
redundancyVccRefused = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyVccRefused.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyVccRefused.setDescription('Number of Redundancy VCC call setup requests rejected by the LES for any reason.')
redundancyVccReleased = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyVccReleased.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyVccReleased.setDescription('Number of times a Redundancy VCC has been released by LEC/network for any reason.')
redundancyVccFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyVccFailure.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyVccFailure.setDescription('Number of Redundancy VCC requests made by LES that failed.')
bmonSampleInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1), )
if mibBuilder.loadTexts: bmonSampleInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: bmonSampleInfoTable.setDescription('This table contains the BUS Monitor (BMON) information for the last complete sample processed. The following information is maintained for each BUS instance using BMON: - Time that the last complete sample interval started. - Duration of the sample interval. - Number of top hosts actually recorded in the sample. - Number of frames received during the sample interval. - Number of frames sampled in the sample interval. - Frame sampling rate (i.e., 1 out of N frames sampled). Each BUS instance may have a BMON. This table is indexed by lesConfIndex.')
bmonSampleInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: bmonSampleInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bmonSampleInfoEntry.setDescription('Each entry in this table contains BMON information for the last complete sample processed for a specific BUS instance.')
bmonSampleStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonSampleStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: bmonSampleStartTime.setDescription('Timestamp for the start of the last complete BUS Monitor sample interval.')
bmonSampleDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonSampleDuration.setStatus('mandatory')
if mibBuilder.loadTexts: bmonSampleDuration.setDescription('Duration of the last complete sample interval.')
bmonNumTopMacs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonNumTopMacs.setStatus('mandatory')
if mibBuilder.loadTexts: bmonNumTopMacs.setDescription('The number of top hosts actually recorded during the last complete sample interval.')
bmonReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonReceivedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: bmonReceivedFrames.setDescription('The total number of frames received during the last complete sample interval.')
bmonSampledFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonSampledFrames.setStatus('mandatory')
if mibBuilder.loadTexts: bmonSampledFrames.setDescription('The number of frames actually sampled during the last complete sample interval.')
bmonSamplingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonSamplingRate.setStatus('mandatory')
if mibBuilder.loadTexts: bmonSamplingRate.setDescription('The frame sampling rate given as N where the rate is 1 out of every N frames will be sampled.')
bmonStatTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 2), )
if mibBuilder.loadTexts: bmonStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: bmonStatTable.setDescription('This table contains the BUS Monitor (BMON) counters for the top N heaviest users of a BUS (i.e., the N MAC addresses that originate the most data frames. Each BUS instance may have a BMON. This table augments the bmonConfTable.')
bmonStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 2, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "IBM-LES-BUS-MIB", "bmonTopNRank"))
if mibBuilder.loadTexts: bmonStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bmonStatEntry.setDescription('Each entry in this table contains BMON statistics for the top users of the indicated BUS instance.')
bmonTopNRank = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonTopNRank.setStatus('mandatory')
if mibBuilder.loadTexts: bmonTopNRank.setDescription('Rank for the indicated host (i.e., MAC address) given as N where 1 is the host originating the most frames.')
bmonTopNSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonTopNSrcMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bmonTopNSrcMacAddr.setDescription('Source MAC Address for this host.')
bmonTopNLecAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 2, 1, 3), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonTopNLecAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bmonTopNLecAtmAddr.setDescription('Associated LEC ATM Address for this host.')
bmonTopNFramesSampled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bmonTopNFramesSampled.setStatus('mandatory')
if mibBuilder.loadTexts: bmonTopNFramesSampled.setDescription('Number of frames sampled from this host during last complete sample interval.')
ibmLesBusCConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4, 1, 1))
ibmLesBusCStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4, 1, 2))
ibmBusMonCStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4, 1, 3))
ibmLesBusMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 118, 1, 2, 1, 1, 4, 2, 1))
mibBuilder.exportSymbols("IBM-LES-BUS-MIB", bmonReceivedFrames=bmonReceivedFrames, bmonSampledFrames=bmonSampledFrames, ibmLesBusMIBCompliances=ibmLesBusMIBCompliances, bmonSampleInfoEntry=bmonSampleInfoEntry, controlDirectMaxReservedBw=controlDirectMaxReservedBw, ibmLesBusStatGroup=ibmLesBusStatGroup, configuredEsi=configuredEsi, redundancyAtmAddr=redundancyAtmAddr, redundancyEnabled=redundancyEnabled, ibmLesBusMIBGroups=ibmLesBusMIBGroups, leArpResponseDest=leArpResponseDest, bmonTopNFramesSampled=bmonTopNFramesSampled, bmonNumTopMacs=bmonNumTopMacs, multicastSendMaxReservedBw=multicastSendMaxReservedBw, sampleRate=sampleRate, ibmLesBusMIB=ibmLesBusMIB, bmonSampleInfoTable=bmonSampleInfoTable, ibmBusMonStatGroup=ibmBusMonStatGroup, validateJoinsWithLecs=validateJoinsWithLecs, numTopMacs=numTopMacs, useBurnedInEsi=useBurnedInEsi, redundancyRole=redundancyRole, bmonSampleStartTime=bmonSampleStartTime, redundancyVccRefused=redundancyVccRefused, bmonSampleDuration=bmonSampleDuration, bmonTopNSrcMacAddr=bmonTopNSrcMacAddr, ibmLesBusCConfGroup=ibmLesBusCConfGroup, redundancyVccReleased=redundancyVccReleased, bmonSamplingRate=bmonSamplingRate, ibmLesBusStatTable=ibmLesBusStatTable, bmonTopNLecAtmAddr=bmonTopNLecAtmAddr, validateBestEffortPcr=validateBestEffortPcr, multicastForwardPcr=multicastForwardPcr, ibmLesBusStatEntry=ibmLesBusStatEntry, configuredSelector=configuredSelector, multicastForwardVccType=multicastForwardVccType, ibmBusMonCStatGroup=ibmBusMonCStatGroup, redundancyVccFailure=redundancyVccFailure, sampleDuration=sampleDuration, ibmLesBusConfTable=ibmLesBusConfTable, ibmLesBusConfEntry=ibmLesBusConfEntry, controlDistributeVccType=controlDistributeVccType, bmonStatEntry=bmonStatEntry, use2ControlDistributeVccs=use2ControlDistributeVccs, ibmLesBusMIBCompliance=ibmLesBusMIBCompliance, ibmLesBusConfGroup=ibmLesBusConfGroup, controlDistributeScr=controlDistributeScr, atmDevNum=atmDevNum, ibmLesBusCStatGroup=ibmLesBusCStatGroup, busMode=busMode, interSampleTime=interSampleTime, bmonStatTable=bmonStatTable, use2MulticastForwardVccs=use2MulticastForwardVccs, multicastForwardScr=multicastForwardScr, controlDistributePcr=controlDistributePcr, bmonTopNRank=bmonTopNRank, ibmLesBusMIBConformance=ibmLesBusMIBConformance, bmonEnabled=bmonEnabled)

#
# PySNMP MIB module MRV-IN-REACH-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MRV-IN-REACH-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:15:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
MacAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "MacAddress")
IOType, HardwareType, AddressType, mrvInReachProductDivision = mibBuilder.importSymbols("MRV-IN-REACH-PRODUCT-DIVISION-MIB", "IOType", "HardwareType", "AddressType", "mrvInReachProductDivision")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Bits, Gauge32, TimeTicks, Integer32, ObjectIdentity, iso, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter64, IpAddress, NotificationType, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Bits", "Gauge32", "TimeTicks", "Integer32", "ObjectIdentity", "iso", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter64", "IpAddress", "NotificationType", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xChassis = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16))
xChassisBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 1))
xSegment = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 2))
xPort = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 3))
xController = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 4))
xInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 5))
xSlotBootControl = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 6))
xSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 7))
xPowerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 8))
xFirmwareUpdate = MibIdentifier((1, 3, 6, 1, 4, 1, 33, 16, 9))
class NetworkType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
    namedValues = NamedValues(("unknown", 1), ("other", 2), ("ethernet", 3), ("tokenRing", 4), ("fddi", 5), ("wan", 6), ("ethernetRepeater", 7), ("tokenRingConcentrator", 8), ("fddiConcentrator", 9), ("atm", 10), ("isdn", 11), ("switchplane", 12), ("switchedEthernet", 13))

class SerialNumber(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 6)

class Letter(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26))
    namedValues = NamedValues(("a", 1), ("b", 2), ("c", 3), ("d", 4), ("e", 5), ("f", 6), ("g", 7), ("h", 8), ("i", 9), ("j", 10), ("k", 11), ("l", 12), ("m", 13), ("n", 14), ("o", 15), ("p", 16), ("q", 17), ("r", 18), ("s", 19), ("t", 20), ("u", 21), ("v", 22), ("w", 23), ("x", 24), ("y", 25), ("z", 26))

basicBase802Address = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basicBase802Address.setStatus('mandatory')
if mibBuilder.loadTexts: basicBase802Address.setDescription('Base IEEE 802 global address for the chassis.')
basicSlot = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basicSlot.setStatus('mandatory')
if mibBuilder.loadTexts: basicSlot.setDescription('Chassis slot number (slotIndex) of the system whose agent is supplying this MIB.')
basicSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basicSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: basicSlotNumber.setDescription('Number of slots in the chassis.')
basicNewBase802Address = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: basicNewBase802Address.setStatus('mandatory')
if mibBuilder.loadTexts: basicNewBase802Address.setDescription("New base IEEE 802 global address for the chassis. Must be set in conjunction with featType 'changeEthernetAddress' and featKey from the MRV In-Reach System MIB.")
segmentTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 2, 1), )
if mibBuilder.loadTexts: segmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: segmentTable.setDescription('A list of segment entries, one for each segment of each type on the chassis.')
segmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 2, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "segmentType"), (0, "MRV-IN-REACH-CHASSIS-MIB", "segmentIndex"))
if mibBuilder.loadTexts: segmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: segmentEntry.setDescription('Values for a chassis segment.')
segmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 2, 1, 1, 1), NetworkType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentType.setStatus('mandatory')
if mibBuilder.loadTexts: segmentType.setDescription('The segment type.')
segmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 2, 1, 1, 2), Letter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: segmentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: segmentIndex.setDescription('An index value that uniquely identifies a segment.')
portIOCardType = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 3, 1), IOType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIOCardType.setStatus('mandatory')
if mibBuilder.loadTexts: portIOCardType.setDescription('The hardware type of the I/O card in this slot.')
portIOCardSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 3, 2), SerialNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIOCardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portIOCardSerialNumber.setDescription('The MRV In-Reach serial number of the I/O card in this slot.')
portIOCardOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 33, 16, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("mismatch", 2), ("good", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIOCardOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portIOCardOperStatus.setDescription('Status of the I/O card relative to the function card in this slot.')
portTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 3, 4), )
if mibBuilder.loadTexts: portTable.setStatus('mandatory')
if mibBuilder.loadTexts: portTable.setDescription('A list of port entries, one for each port of each type on the slots I/O card.')
portEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 3, 4, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "portType"), (0, "MRV-IN-REACH-CHASSIS-MIB", "portIndex"))
if mibBuilder.loadTexts: portEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portEntry.setDescription('Values for an I/O card port.')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 3, 4, 1, 1), NetworkType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setStatus('mandatory')
if mibBuilder.loadTexts: portType.setDescription('The port type.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('An index value that uniquely identifies a port.')
controllerTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 4, 1), )
if mibBuilder.loadTexts: controllerTable.setStatus('mandatory')
if mibBuilder.loadTexts: controllerTable.setDescription('A list of controller entries, one for each controller of each type on the local system.')
controllerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 4, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "controllerType"), (0, "MRV-IN-REACH-CHASSIS-MIB", "controllerIndex"))
if mibBuilder.loadTexts: controllerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: controllerEntry.setDescription('Values for a controller.')
controllerType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 4, 1, 1, 1), NetworkType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: controllerType.setStatus('mandatory')
if mibBuilder.loadTexts: controllerType.setDescription('The controller type.')
controllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: controllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: controllerIndex.setDescription('An index value that uniquely identifies a controller.')
controllerNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 4, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controllerNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: controllerNetwork.setDescription('The instance identifier of the first object in the conceptual row entry for the segment, port, or controller this controller is to use, that is, segmentType, portType or controllerType.')
interfaceTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 5, 1), )
if mibBuilder.loadTexts: interfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTable.setDescription('A list of interface entries, corresponding to the MIB II Interface group. These are directly equivalent to hardware network controllers, and must be the lowest numbered interfaces on the system.')
interfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 5, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "interfaceIndex"))
if mibBuilder.loadTexts: interfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceEntry.setDescription('Values for an interface.')
interfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceIndex.setDescription('An index value that uniquely identifies an interface. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
interfaceNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 5, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: interfaceNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNetwork.setDescription('The instance identifier of the first object in the conceptual row entry for the segment, port, or controller this interface is to use, that is, segmentType, portType, or controllerType.')
slotBootControlTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 6, 1), )
if mibBuilder.loadTexts: slotBootControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlTable.setDescription('A list of slot boot control entries.')
slotBootControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootControlSlot"), (0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootControlIndex"))
if mibBuilder.loadTexts: slotBootControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlEntry.setDescription('Values for a chassis slot.')
slotBootControlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootControlSlot.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlSlot.setDescription('An index value that uniquely identifies a slot, defined the same as slotIndex.')
slotBootControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlIndex.setDescription('An index value that uniquely identifies a boot control entry, from 1 to the number of entries for the slot.')
slotBootControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStatus.setDescription("The status of the entry. Set to 'disabled' to disable the entry.")
slotBootControlController = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlController.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlController.setDescription('The instance identifier of the first object in the conceptual row entry for the controller this entry selects for bootstrap operation, that is, controllerType. This entry must be compatible with slotBootControlNetwork, including being of the same network type. The value 0.0 indicates default action.')
slotBootControlNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlNetwork.setDescription('The instance identifier of the first object in the conceptual row entry for the segment or port this entry selects for bootstrap operation, that is, segmentType or portType. This entry must be compatible with slotBootControlController, including being of the same network type. The value 0.0 indicates default action.')
slotBootControlMopFile = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15)).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlMopFile.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlMopFile.setDescription('The software file name to request for down-line load of the server via MOP or XMOP.')
slotBootControlInternetFile = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlInternetFile.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlInternetFile.setDescription('The filename to request when loading an image via TFTP.')
slotBootControlInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlInternetAddress.setDescription('The internet address of the system is to use for itself when loading via TFTP. The value 0.0.0.0 indicates default action.')
slotBootControlInternetServer = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlInternetServer.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlInternetServer.setDescription('The internet address of the server to use when loading an image via TFTP. The value 0.0.0.0 indicates default action.')
slotBootControlInternetGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlInternetGateway.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlInternetGateway.setDescription('The internet address of the gateway to use when loading an image via TFTP. The value 0.0.0.0 indicates default action.')
slotBootControlInternetDelimiter = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1)).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlInternetDelimiter.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlInternetDelimiter.setDescription('The character separating the load file directory name from the file name.')
slotBootControlFlagTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 6, 2), )
if mibBuilder.loadTexts: slotBootControlFlagTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagTable.setDescription('A list of slot boot control source flag entries.')
slotBootControlFlagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootControlSlot"), (0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootControlIndex"))
if mibBuilder.loadTexts: slotBootControlFlagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagEntry.setDescription('Values for a boot control flag.')
slotBootControlFlagLoadBootpTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagLoadBootpTftp.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagLoadBootpTftp.setDescription('Control for performing load over BOOTP/TFTP.')
slotBootControlFlagParamBootpTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagParamBootpTftp.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagParamBootpTftp.setDescription('Control for performing parameter load over BOOTP/TFTP.')
slotBootControlFlagDumpBootpTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagDumpBootpTftp.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagDumpBootpTftp.setDescription('Control for performing dump over BOOTP/TFTP.')
slotBootControlFlagLoadTftpDirect = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagLoadTftpDirect.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagLoadTftpDirect.setDescription('Control for performing load over direct TFTP.')
slotBootControlFlagParamTftpDirect = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagParamTftpDirect.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagParamTftpDirect.setDescription('Control for performing parameter load over direct TFTP.')
slotBootControlFlagDumpTftpDirect = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagDumpTftpDirect.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagDumpTftpDirect.setDescription('Control for performing dump over direct TFTP.')
slotBootControlFlagLoadLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagLoadLocal.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagLoadLocal.setDescription('Control for performing load from a local device.')
slotBootControlFlagParamLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagParamLocal.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagParamLocal.setDescription('Control for performing parameter load from a local device.')
slotBootControlFlagDumpLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagDumpLocal.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagDumpLocal.setDescription('Control for performing dump from a local device.')
slotBootControlFlagLoadMop = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagLoadMop.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagLoadMop.setDescription("Control for performing load over Digital's MOP.")
slotBootControlFlagParamMop = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagParamMop.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagParamMop.setDescription("Control for performing parameter load over Digital's MOP.")
slotBootControlFlagDumpMop = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagDumpMop.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagDumpMop.setDescription("Control for performing dump over Digital's MOP.")
slotBootControlFlagLoadXmop = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagLoadXmop.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagLoadXmop.setDescription('Control for performing load over MRV In-Reach extended MOP.')
slotBootControlFlagParamXmop = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagParamXmop.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagParamXmop.setDescription('Control for performing parameter load over MRV In-Reach extended MOP.')
slotBootControlFlagDumpXmop = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagDumpXmop.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagDumpXmop.setDescription('Control for performing dump over MRV In-Reach extended MOP.')
slotBootControlFlagLoadRarpTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagLoadRarpTftp.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagLoadRarpTftp.setDescription('Control for performing load over RARP/TFTP.')
slotBootControlFlagParamRarpTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagParamRarpTftp.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagParamRarpTftp.setDescription('Control for performing parameter load over RARP/TFTP.')
slotBootControlFlagDumpRarpTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotBootControlFlagDumpRarpTftp.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlFlagDumpRarpTftp.setDescription('Control for performing dump over RARP/TFTP.')
slotBootControlStorageTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 6, 3), )
if mibBuilder.loadTexts: slotBootControlStorageTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStorageTable.setDescription('A list of slot boot control Storage entries.')
slotBootControlStorageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 6, 3, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootControlStorageClientSlot"), (0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootControlStorageServerSlot"))
if mibBuilder.loadTexts: slotBootControlStorageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStorageEntry.setDescription('Values for a chassis slot.')
slotBootControlStorageClientSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootControlStorageClientSlot.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStorageClientSlot.setDescription('An index value that uniquely identifies a slot, defined the same as slotIndex.')
slotBootControlStorageServerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootControlStorageServerSlot.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStorageServerSlot.setDescription('An index value that uniquely identifies the slot in which the Storage record resides, with the same values as slotIndex.')
slotBootControlStorageStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("present", 1), ("failed", 2), ("ok", 3), ("notpresent", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootControlStorageStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStorageStatus.setDescription('The status of the entry.')
slotBootControlStorageFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 6, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootControlStorageFailures.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootControlStorageFailures.setDescription('The number of times a read from or write to a given Storage location failed')
slotTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 7, 1), )
if mibBuilder.loadTexts: slotTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotTable.setDescription('A list of slot entries.')
slotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "slotIndex"))
if mibBuilder.loadTexts: slotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotEntry.setDescription('Values for a chassis slot.')
slotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotIndex.setDescription('An index value that uniquely identifies a slot, in the range 0 to basicSlotNumber, where the value 0 indicates the same slot as basicSlot. As the objects found at instance zero are duplicates, that instance does not appear in responses a get-next, that is, the lowest numbered slotIndex returned by get-next is 1.')
slotAdminAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ready", 1), ("reset", 2), ("resetHold", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotAdminAction.setStatus('mandatory')
if mibBuilder.loadTexts: slotAdminAction.setDescription("Control to cause reset of the system in a slot. When read, the value is always 'ready'. Setting to 'reset' or 'resetHold' causes a single attempt to take that action, but does not ensure transition to any particular value of slotOperStatus.")
slotOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 64, 65, 66, 67, 68, 69))).clone(namedValues=NamedValues(("loadRequested", 1), ("loading", 2), ("dumpRequested", 3), ("dumping", 4), ("paramRequested", 5), ("paramLoading", 6), ("running", 7), ("initializing", 8), ("attended", 9), ("internal10", 10), ("internal11", 11), ("inhibited", 12), ("maxserverCard", 13), ("invalidConfigStorage", 14), ("securityLockdown", 15), ("resetHold", 64), ("selfTest", 65), ("notResponding", 66), ("broken", 67), ("unknown", 68), ("notApplicable", 69)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slotOperStatus.setDescription('Relative to the chassis, the current operating status of the system in the slot.')
slotSecondsSinceReset = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotSecondsSinceReset.setStatus('mandatory')
if mibBuilder.loadTexts: slotSecondsSinceReset.setDescription('The number of seconds since the system in the slot was last reset by hardware or software.')
slotHardwareType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 5), HardwareType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotHardwareType.setStatus('mandatory')
if mibBuilder.loadTexts: slotHardwareType.setDescription('The type of hardware in the slot.')
slotHardwareSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 6), SerialNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotHardwareSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: slotHardwareSerialNumber.setDescription('The MRV In-Reach serial number of the function card hardware in this slot.')
slotHardwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotHardwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: slotHardwareRevision.setDescription('This revision level of the function card hardware in the slot.')
slotIOCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 8), IOType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIOCardType.setStatus('mandatory')
if mibBuilder.loadTexts: slotIOCardType.setDescription('The hardware type of the I/O card in this slot.')
slotIOCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 9), SerialNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIOCardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: slotIOCardSerialNumber.setDescription('The MRV In-Reach serial number of the I/O card in this slot.')
slotIOCardOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("mismatch", 2), ("good", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIOCardOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slotIOCardOperStatus.setDescription('Status of the I/O card relative to the function card in this slot.')
slotBootstrapFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootstrapFirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootstrapFirmwareRevision.setDescription('The firmware revision level of the bootstrap ROM installed in the system in the slot.')
slotElementalFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotElementalFirmwareRevision.setStatus('mandatory')
if mibBuilder.loadTexts: slotElementalFirmwareRevision.setDescription('The firmware revision level of the minimal function ROM (management bus microprocessor) installed in the system in the slot.')
slotMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: slotMemorySize.setDescription('The number of bytes of memory installed in the system in the slot.')
slotLedNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotLedNumber.setStatus('mandatory')
if mibBuilder.loadTexts: slotLedNumber.setDescription('The number of LEDs on the system in the slot. A value of 0 indicates none, unknown, or status not readable.')
slotLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slotLedStatus.setDescription('The status of the LEDs displayed on the front and back of the system in the slot. The first bit is the high-order bit of the first byte of the value, proceeding to the low-order bit, then to then next byte. On the system hardware, the first LED is at the top, left, front, proceeding left to right, top to bottom, and front to back.')
slotBase802Address = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 16), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBase802Address.setStatus('mandatory')
if mibBuilder.loadTexts: slotBase802Address.setDescription('Base IEEE 802 global address for the slot.')
slotIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slotIpAddress.setDescription('An internet address to which the system in this slot might respond. May be one of many.')
slotPlus5Status = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("broken", 2), ("good", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotPlus5Status.setStatus('mandatory')
if mibBuilder.loadTexts: slotPlus5Status.setDescription('Status of the +5 volt power to the slot.')
slotPlus12Status = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("broken", 2), ("good", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotPlus12Status.setStatus('mandatory')
if mibBuilder.loadTexts: slotPlus12Status.setDescription('Status of the +12 volt power to the slot.')
slotMinus12Status = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("broken", 2), ("good", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotMinus12Status.setStatus('mandatory')
if mibBuilder.loadTexts: slotMinus12Status.setDescription('Status of the -12 volt power to the slot.')
slotPlus5Watts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotPlus5Watts.setStatus('mandatory')
if mibBuilder.loadTexts: slotPlus5Watts.setDescription('Tenths of watts of +5 volt power currently drawn by the slot.')
slotPlus12Watts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotPlus12Watts.setStatus('mandatory')
if mibBuilder.loadTexts: slotPlus12Watts.setDescription('Tenths of watts of +12 volt power currently drawn by the slot.')
slotMinus12Watts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotMinus12Watts.setStatus('mandatory')
if mibBuilder.loadTexts: slotMinus12Watts.setDescription('Tenths of watts of -12 volt power currently drawn by the slot.')
slotIOCardHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIOCardHardwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: slotIOCardHardwareVersion.setDescription('Version number of I/O card in the slot.')
slotRestoreNVS = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotRestoreNVS.setStatus('mandatory')
if mibBuilder.loadTexts: slotRestoreNVS.setDescription("Setting to 'execute' causes the non-volatile parameter storage to be restored from an installed memory card. Setting to 'ready' has no effect.")
slotDefaultNVS = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotDefaultNVS.setStatus('mandatory')
if mibBuilder.loadTexts: slotDefaultNVS.setDescription("Setting to 'execute' causes non-volatile stored parameters to be reset to factory defaults. Setting to 'ready' has no effect.")
slotBootTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 7, 2), )
if mibBuilder.loadTexts: slotBootTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootTable.setDescription('A list of slot bootstrap status entries. A given slot has an entry in this table only when slotOperStatus is one of: loadRequested, loading, dumpRequested, dumping, paramRequested, paramLoading')
slotBootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "slotBootIndex"))
if mibBuilder.loadTexts: slotBootEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootEntry.setDescription('Bootstrap status values for a chassis slot.')
slotBootIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootIndex.setDescription('An index value that uniquely identifies a slot, defined the same as slotIndex.')
slotBootIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootIfIndex.setDescription('An index value that uniquely identifies the interface in use for bootstrap functions. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
slotBootNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootNetwork.setDescription('The instance identifier of the first object in the conceptual row entry for the segment or port this interface is using, that is, segmentType or portType.')
slotBootProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("mop", 3), ("xmop", 4), ("rarpTftp", 5), ("bootpTftp", 6), ("tftp", 7), ("local", 8), ("managementBus", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootProtocol.setDescription('The protocol in use for bootstrap operation.')
slotBoot802Address = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBoot802Address.setStatus('mandatory')
if mibBuilder.loadTexts: slotBoot802Address.setDescription('IEEE 802 global address in use for bootstrap operation.')
slotBootAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 6), AddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootAddressType.setDescription('The type of network address contained in slotBootAddress.')
slotBootAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootAddress.setDescription('The network address the system in the slot is using to identify itself for bootstrap operation.')
slotBootServerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 8), AddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootServerAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootServerAddressType.setDescription('The type of network address contained in slotBootServerAddress.')
slotBootServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootServerAddress.setDescription('The network address of the system supplying bootstrap services to the system in the slot.')
slotBootGatewayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootGatewayAddress.setDescription('The internet address of the router in use for bootstrap operation.')
slotBootFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootFileName.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootFileName.setDescription('The full name of the file in use for bootstrap operation.')
slotBootBlockNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootBlockNumber.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootBlockNumber.setDescription('The current block number being transferred for bootstrap operation, zero if unknown or not applicable.')
slotBootCrashCode = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotBootCrashCode.setStatus('mandatory')
if mibBuilder.loadTexts: slotBootCrashCode.setDescription('If slotOperStatus is dumpRequested or dumping, a code number to identify the crash reason; otherwise zero length.')
slotControllerTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 7, 3), )
if mibBuilder.loadTexts: slotControllerTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotControllerTable.setDescription('A list of controller entries, one for each controller of each type in each slot.')
slotControllerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 7, 3, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "slotControllerType"), (0, "MRV-IN-REACH-CHASSIS-MIB", "slotControllerIndex"))
if mibBuilder.loadTexts: slotControllerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotControllerEntry.setDescription('Values for a controller.')
slotControllerType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 3, 1, 1), NetworkType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotControllerType.setStatus('mandatory')
if mibBuilder.loadTexts: slotControllerType.setDescription('The controller type.')
slotControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotControllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotControllerIndex.setDescription('An index value that uniquely identifies a controller.')
slotControllerNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 7, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotControllerNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: slotControllerNetwork.setDescription('The instance identifier of the first object in the conceptual row entry for the segment or port this controller is to use, that is, segmentType or portType.')
powerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 8, 1), )
if mibBuilder.loadTexts: powerSupplyTable.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyTable.setDescription('A list of power supply entries.')
powerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "powerSupplyIndex"))
if mibBuilder.loadTexts: powerSupplyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyEntry.setDescription('Values for a chassis power supply.')
powerSupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyIndex.setDescription('An index value that uniquely identifies a power supply, in the range 1 to the number of power supply slots in the chassis.')
powerSupplyAdminAction = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ready", 1), ("reset", 2), ("resetHold", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: powerSupplyAdminAction.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyAdminAction.setDescription("Control to cause reset of the power supply. When read, the value is always 'ready'. Setting to 'reset' or 'resetHold' causes a single attempt to take that action, but does not ensure transition to any particular value of powerSupplyRedundancyStatus.")
powerSupplyFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyFirmwareVersion.setDescription('Version number of power supply firmware.')
powerSupplyRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("disabled", 2), ("redundant", 3), ("engaged", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyRedundancyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyRedundancyStatus.setDescription('The current redundancy status of the power supply.')
powerSupplyPlus5Status = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyPlus5Status.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyPlus5Status.setDescription('Status of the +5 volt power from the power supply.')
powerSupplyPlus12Status = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyPlus12Status.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyPlus12Status.setDescription('Status of the +12 volt power from the power supply.')
powerSupplyMinus12Status = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyMinus12Status.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyMinus12Status.setDescription('Status of the -12 volt power from the power supply.')
powerSupplyThermalWarningStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyThermalWarningStatus.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyThermalWarningStatus.setDescription('The current thermal warning status of the power supply.')
powerSupplyThermalShutdownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyThermalShutdownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyThermalShutdownStatus.setDescription('The current thermal shutdown status of the power supply.')
powerSupplyFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyFanStatus.setDescription("The current status of the power supply's fan.")
powerSupplyHardwareInhibitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyHardwareInhibitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyHardwareInhibitStatus.setDescription("The current status of the power supply's hardware inhibit.")
powerSupplyPlus5History = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyPlus5History.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyPlus5History.setDescription('History of the +5 volt power from the power supply.')
powerSupplyPlus12History = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyPlus12History.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyPlus12History.setDescription('History of the +12 volt power from the power supply.')
powerSupplyMinus12History = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyMinus12History.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyMinus12History.setDescription('History of the -12 volt power from the power supply.')
powerSupplyThermalWarningHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyThermalWarningHistory.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyThermalWarningHistory.setDescription('The thermal warning history of the power supply.')
powerSupplyThermalShutdownHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyThermalShutdownHistory.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyThermalShutdownHistory.setDescription('The thermal shutdown history of the power supply.')
powerSupplyFanHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyFanHistory.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyFanHistory.setDescription("The status history of the power supply's fan.")
powerSupplyHardwareInhibitHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("good", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyHardwareInhibitHistory.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyHardwareInhibitHistory.setDescription("The status history of the power supply's hardware inhibit.")
powerSupplyPlus5Volts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyPlus5Volts.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyPlus5Volts.setDescription('In hundredths, volts of +5 volt power currently provided by the power supply. A value of 0 indicates unknown.')
powerSupplyPlus12Volts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyPlus12Volts.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyPlus12Volts.setDescription('In hundredths, volts of +12 volt power currently provided by the power supply. A value of 0 indicates unknown.')
powerSupplyMinus12Volts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyMinus12Volts.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyMinus12Volts.setDescription('In hundredths, volts of -12 volt power currently provided by the power supply. A value of 0 indicates unknown.')
powerSupplyWatts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyWatts.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyWatts.setDescription('Watts of power currently drawn from this power supply. A value of 0 indicates unknown.')
powerSupplyWattsMax = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyWattsMax.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyWattsMax.setDescription('Maximum watts of power available from this power supply. A value of 0 indicates unknown.')
powerSupplyChassisWatts = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyChassisWatts.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyChassisWatts.setDescription('Total watts of power currently drawn by the entire chassis. A value of 0 indicates unknown.')
powerSupplyChassisWattsMax = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyChassisWattsMax.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyChassisWattsMax.setDescription('Total maximum watts of power available from all the power supplies in the chassis. A value of 0 indicates unknown.')
powerSupplyHardwareType = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 8, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ps130", 2), ("bb190", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyHardwareType.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyHardwareType.setDescription('The type of power supply.')
firmwareUpdateTable = MibTable((1, 3, 6, 1, 4, 1, 33, 16, 9, 1), )
if mibBuilder.loadTexts: firmwareUpdateTable.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateTable.setDescription('Table of descriptive and status information concerning the writing of firmware to a target I/O card.')
firmwareUpdateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1), ).setIndexNames((0, "MRV-IN-REACH-CHASSIS-MIB", "firmwareUpdateSlotIndex"))
if mibBuilder.loadTexts: firmwareUpdateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateEntry.setDescription('An entry in the table concerning the writing of firmware to a target I/O card.')
firmwareUpdateSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: firmwareUpdateSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateSlotIndex.setDescription('This variable identifies the slot to which is to be the target of the firmware update.')
firmwareUpdateDefaultFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: firmwareUpdateDefaultFileName.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateDefaultFileName.setDescription('This variable when read will obtain the default file name from the target.')
firmwareUpdateFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: firmwareUpdateFileName.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateFileName.setDescription('This variable contains the name of the file to be read from the flash memory card and written to the target.')
firmwareUpdateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: firmwareUpdateStatus.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateStatus.setDescription("This variable is used to start the update process. The agent always 'ready' for this value. Setting this value to 'execute' causes the agent to write the file specified by firmwareUpdateFileName to be written to the taget. Setting this value to 'execute' when firmwareUpdateFileName has not been written or when firmwareUpdateState is 'writing' causes bad value to be returned.")
firmwareUpdateState = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("writing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: firmwareUpdateState.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateState.setDescription("This variable indicates the current state of firmware update, 'idle' indicates that firmware update may be initiated, and 'writing' indicates that an update is in process.")
firmwareUpdateCompletionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("noTarget", 3), ("busError", 4), ("badFileName", 5), ("targetError", 6), ("timeout", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: firmwareUpdateCompletionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateCompletionStatus.setDescription("This variable indicates the completion status of the the last firmware update attempt. 'none' indicates that no firmware update has yet been attempted.")
firmwareUpdateMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 33, 16, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("card", 1), ("local", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: firmwareUpdateMethod.setStatus('mandatory')
if mibBuilder.loadTexts: firmwareUpdateMethod.setDescription('This variable indicates the method of update of the firmware update attempt. ')
mibBuilder.exportSymbols("MRV-IN-REACH-CHASSIS-MIB", controllerType=controllerType, slotBootControlIndex=slotBootControlIndex, slotRestoreNVS=slotRestoreNVS, slotBootCrashCode=slotBootCrashCode, powerSupplyFanStatus=powerSupplyFanStatus, NetworkType=NetworkType, slotControllerEntry=slotControllerEntry, slotBootBlockNumber=slotBootBlockNumber, xSlotBootControl=xSlotBootControl, slotAdminAction=slotAdminAction, slotElementalFirmwareRevision=slotElementalFirmwareRevision, powerSupplyIndex=powerSupplyIndex, slotHardwareSerialNumber=slotHardwareSerialNumber, slotBootAddressType=slotBootAddressType, xPort=xPort, powerSupplyThermalShutdownHistory=powerSupplyThermalShutdownHistory, slotBootControlController=slotBootControlController, slotIpAddress=slotIpAddress, slotBootControlInternetAddress=slotBootControlInternetAddress, xChassisBasic=xChassisBasic, slotBootControlFlagLoadRarpTftp=slotBootControlFlagLoadRarpTftp, powerSupplyPlus5Volts=powerSupplyPlus5Volts, powerSupplyHardwareInhibitStatus=powerSupplyHardwareInhibitStatus, portIOCardSerialNumber=portIOCardSerialNumber, slotIOCardHardwareVersion=slotIOCardHardwareVersion, Letter=Letter, slotBootTable=slotBootTable, slotDefaultNVS=slotDefaultNVS, controllerNetwork=controllerNetwork, slotControllerTable=slotControllerTable, powerSupplyMinus12Volts=powerSupplyMinus12Volts, slotBootControlTable=slotBootControlTable, slotPlus5Watts=slotPlus5Watts, slotIOCardType=slotIOCardType, slotBootControlFlagLoadBootpTftp=slotBootControlFlagLoadBootpTftp, slotBootControlMopFile=slotBootControlMopFile, slotBootControlInternetServer=slotBootControlInternetServer, portTable=portTable, slotBootControlFlagEntry=slotBootControlFlagEntry, powerSupplyThermalShutdownStatus=powerSupplyThermalShutdownStatus, slotBootControlStorageClientSlot=slotBootControlStorageClientSlot, powerSupplyTable=powerSupplyTable, firmwareUpdateMethod=firmwareUpdateMethod, powerSupplyFanHistory=powerSupplyFanHistory, xFirmwareUpdate=xFirmwareUpdate, slotBootControlInternetFile=slotBootControlInternetFile, slotBootControlStorageTable=slotBootControlStorageTable, slotPlus12Watts=slotPlus12Watts, slotBootControlFlagLoadLocal=slotBootControlFlagLoadLocal, slotBoot802Address=slotBoot802Address, firmwareUpdateState=firmwareUpdateState, slotBootNetwork=slotBootNetwork, SerialNumber=SerialNumber, firmwareUpdateFileName=firmwareUpdateFileName, slotBootControlStorageEntry=slotBootControlStorageEntry, slotControllerNetwork=slotControllerNetwork, segmentTable=segmentTable, interfaceIndex=interfaceIndex, slotBootControlFlagTable=slotBootControlFlagTable, firmwareUpdateDefaultFileName=firmwareUpdateDefaultFileName, xInterface=xInterface, segmentType=segmentType, slotBootProtocol=slotBootProtocol, slotBootControlStorageFailures=slotBootControlStorageFailures, portType=portType, powerSupplyPlus12Volts=powerSupplyPlus12Volts, firmwareUpdateCompletionStatus=firmwareUpdateCompletionStatus, slotMemorySize=slotMemorySize, powerSupplyPlus5History=powerSupplyPlus5History, slotControllerType=slotControllerType, powerSupplyPlus12Status=powerSupplyPlus12Status, interfaceEntry=interfaceEntry, slotBootControlStorageStatus=slotBootControlStorageStatus, slotOperStatus=slotOperStatus, slotEntry=slotEntry, slotSecondsSinceReset=slotSecondsSinceReset, powerSupplyThermalWarningStatus=powerSupplyThermalWarningStatus, basicSlotNumber=basicSlotNumber, slotBootControlFlagDumpTftpDirect=slotBootControlFlagDumpTftpDirect, slotBootControlStorageServerSlot=slotBootControlStorageServerSlot, powerSupplyThermalWarningHistory=powerSupplyThermalWarningHistory, powerSupplyMinus12Status=powerSupplyMinus12Status, powerSupplyHardwareInhibitHistory=powerSupplyHardwareInhibitHistory, xSlot=xSlot, slotControllerIndex=slotControllerIndex, slotBootControlEntry=slotBootControlEntry, portEntry=portEntry, xController=xController, slotBootstrapFirmwareRevision=slotBootstrapFirmwareRevision, slotBootEntry=slotBootEntry, powerSupplyPlus12History=powerSupplyPlus12History, slotBootControlFlagLoadXmop=slotBootControlFlagLoadXmop, slotBootControlInternetDelimiter=slotBootControlInternetDelimiter, slotBootControlFlagParamXmop=slotBootControlFlagParamXmop, slotBootControlFlagParamBootpTftp=slotBootControlFlagParamBootpTftp, firmwareUpdateEntry=firmwareUpdateEntry, slotBootControlFlagLoadTftpDirect=slotBootControlFlagLoadTftpDirect, slotBootServerAddress=slotBootServerAddress, slotBootControlFlagParamRarpTftp=slotBootControlFlagParamRarpTftp, slotBootControlSlot=slotBootControlSlot, slotIOCardSerialNumber=slotIOCardSerialNumber, slotBootControlFlagDumpXmop=slotBootControlFlagDumpXmop, slotBootIndex=slotBootIndex, powerSupplyChassisWatts=powerSupplyChassisWatts, portIOCardOperStatus=portIOCardOperStatus, powerSupplyRedundancyStatus=powerSupplyRedundancyStatus, segmentIndex=segmentIndex, controllerTable=controllerTable, slotIndex=slotIndex, slotLedNumber=slotLedNumber, slotBootAddress=slotBootAddress, slotBootControlFlagParamMop=slotBootControlFlagParamMop, firmwareUpdateSlotIndex=firmwareUpdateSlotIndex, slotBootServerAddressType=slotBootServerAddressType, portIndex=portIndex, powerSupplyWatts=powerSupplyWatts, slotBootControlFlagDumpRarpTftp=slotBootControlFlagDumpRarpTftp, slotLedStatus=slotLedStatus, slotIOCardOperStatus=slotIOCardOperStatus, slotPlus12Status=slotPlus12Status, slotBootIfIndex=slotBootIfIndex, powerSupplyPlus5Status=powerSupplyPlus5Status, slotBootControlFlagDumpMop=slotBootControlFlagDumpMop, slotPlus5Status=slotPlus5Status, powerSupplyEntry=powerSupplyEntry, firmwareUpdateTable=firmwareUpdateTable, powerSupplyMinus12History=powerSupplyMinus12History, controllerIndex=controllerIndex, slotBootControlNetwork=slotBootControlNetwork, powerSupplyFirmwareVersion=powerSupplyFirmwareVersion, powerSupplyChassisWattsMax=powerSupplyChassisWattsMax, basicBase802Address=basicBase802Address, basicSlot=basicSlot, slotBootControlFlagLoadMop=slotBootControlFlagLoadMop, slotMinus12Status=slotMinus12Status, slotBootControlFlagDumpBootpTftp=slotBootControlFlagDumpBootpTftp, slotMinus12Watts=slotMinus12Watts, interfaceNetwork=interfaceNetwork, slotHardwareRevision=slotHardwareRevision, firmwareUpdateStatus=firmwareUpdateStatus, interfaceTable=interfaceTable, slotBootControlFlagDumpLocal=slotBootControlFlagDumpLocal, xChassis=xChassis, segmentEntry=segmentEntry, slotBase802Address=slotBase802Address, slotBootFileName=slotBootFileName, powerSupplyWattsMax=powerSupplyWattsMax, xPowerSupply=xPowerSupply, slotBootControlFlagParamLocal=slotBootControlFlagParamLocal, slotTable=slotTable, portIOCardType=portIOCardType, powerSupplyHardwareType=powerSupplyHardwareType, powerSupplyAdminAction=powerSupplyAdminAction, slotBootControlFlagParamTftpDirect=slotBootControlFlagParamTftpDirect, slotHardwareType=slotHardwareType, basicNewBase802Address=basicNewBase802Address, xSegment=xSegment, slotBootGatewayAddress=slotBootGatewayAddress, slotBootControlStatus=slotBootControlStatus, slotBootControlInternetGateway=slotBootControlInternetGateway, controllerEntry=controllerEntry)

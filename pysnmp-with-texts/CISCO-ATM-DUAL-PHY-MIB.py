#
# PySNMP MIB module CISCO-ATM-DUAL-PHY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ATM-DUAL-PHY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:50:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndexOrZero, = mibBuilder.importSymbols("CISCO-TC", "InterfaceIndexOrZero")
InterfaceIndex, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, Integer32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, ObjectIdentity, IpAddress, iso, TimeTicks, NotificationType, MibIdentifier, Bits, NotificationType, Gauge32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Integer32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "ObjectIdentity", "IpAddress", "iso", "TimeTicks", "NotificationType", "MibIdentifier", "Bits", "NotificationType", "Gauge32", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
TruthValue, = mibBuilder.importSymbols("SNMPv2-TC-v1", "TruthValue")
ciscoAtmDualPhyMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60))
ciscoAtmDualPhyMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 1))
cadpStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1))
ciscoAtmDualPhyMIBTrapPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 2))
ciscoAtmDualPhyMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 2, 0))
ciscoAtmDualPhyMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 3))
ciscoAtmDualPhyMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 3, 1))
ciscoAtmDualPhyMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 3, 2))
cadpStatTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1), )
if mibBuilder.loadTexts: cadpStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatTable.setDescription('A table of status information about ATM phy.')
cadpStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cadpStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatEntry.setDescription('An Atm Phy table entry, containing information about a phy on this ATM module.')
cadpStatLossOfSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatLossOfSignal.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatLossOfSignal.setDescription('Set to true if the phy is currently experiencing a loss of signal (LOS) from its connected port. Set to false if the phy is not experiencing a loss of signal.')
cadpStatFarEndReceiveFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatFarEndReceiveFailure.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatFarEndReceiveFailure.setDescription('Set to true if the phy is currently experiencing a far end receive failure (FERF) with its connected port. Set to false if the phy is not experiencing a far end receive failure.')
cadpStatActive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatActive.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatActive.setDescription('Set to true when this phy is currently the active phy. Set to false when this phy is not the currently active phy.')
cadpStatSectionBIP8Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatSectionBIP8Errors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatSectionBIP8Errors.setDescription('The Bit Interleaved Parity 8 is an error checking code applied for quick isolation of faults. Each bit in the B octets is set to 1 or 0 as necessary to obtain even parity over the previous frame. The calculated BIP-8 code for frame N is compared with the BIP-8 code extracted from the B1 byte of frame N+1. Differences indicate that a section level bit error has occurred. Count of Section BIP-8 (Bit Interleaved Parity) errors that have been detected on this phy. ')
cadpStatLineBIP824Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatLineBIP824Errors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatLineBIP824Errors.setDescription('The Bit Interleaved Parity 8/24 is an error checking code based on even parity. The calculated BIP code for frame N is compared with the BIP-8/24 code extracted from the B2 byte(s) of frame N+1. Any differences indicate that a line layer bit error has occurred. Count of line bit interleaved partiy (BIP-8/24) errors on this phy. ')
cadpStatLineFEBErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatLineFEBErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatLineFEBErrors.setDescription("The number of bits (binary 000 to 1000) in the previous BIP-8 that didn't match the even parity check are inserted by the transmitter. The receiver checks for this in the M0/M1 byte of the frame. A non-zero value (legal range is binary 0000 - 1000) indicates a line layer error in the remote end. Any other value is treated as no error. Count of Line Far End Bit Errors (FEBE) on this phy.")
cadpStatPathBIP8Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatPathBIP8Errors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatPathBIP8Errors.setDescription('The Bit Interleaved Parity 8 is an error checking code applied for quick isolation of faults. Each bit in the B octets is set to 1 or 0 as necessary to obtain even parity over the previous frame. The calculated BIP-8 code for frame N is compared with the BIP-8 code extracted from the B3 byte of frame N+1. Differences indicate that a Path level bit error has occurred. Count of Path BIP-8 (Bit Interleaved Parity) errors that have been detected on this phy.')
cadpStatPathFEBErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatPathFEBErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatPathFEBErrors.setDescription('The number of B3 errors in the previous frame inserted by the transmitter. The receiver checks for this in the G1 byte of the frame. A non-zero value (legal range is binary 0000 - 1000) indicates a line layer error in the remote end. Any other value is treated as no error. Count of Path Far End Bit Errors (FEBE) on this phy.')
cadpStatCorrectableHCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatCorrectableHCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatCorrectableHCSErrors.setDescription('The Header Checksum (HCS) is a CRC-8 calculation over the first 4 octets of the ATM cell header. The received HCS is verified using the polynomial x^8 + x^2 + x + 1. The coset polynomial x^6 + x^4 + x^2 + 1, is added (modulo 2) to the received HCS octet before comparison with the calculated result. Cells with single bit error in the HCS byte are corrected. Cells with more than one bit error in the HCS byte are uncorrectable. Count of incoming cells on this phy with single bit error in the Header Checksum (HCS) byte')
cadpStatUncorrectableHCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatUncorrectableHCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatUncorrectableHCSErrors.setDescription('The Header Checksum (HCS) is a CRC-8 calculation over the first 4 octets of the ATM cell header. The received HCS is verified using the polynomial x^8 + x^2 + x + 1. The coset polynomial x^6 + x^4 + x^2 + 1, is added (modulo 2) to the received HCS octet before comparison with the calculated result. Cells with single bit error in the HCS byte are corrected. Cells with more than one bit error in the HCS byte are uncorrectable. Count of uncorrectable Header Checksum (HCS) errors on this phy.')
cadpStatOperActivePhy = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cadpStatOperActivePhy.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatOperActivePhy.setDescription('Returns the ifIndex of the phy which is currently the active phy. A value of 0 indicates that no phy is currently active.')
cadpStatAdminActivePhy = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 60, 1, 1, 3), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cadpStatAdminActivePhy.setStatus('mandatory')
if mibBuilder.loadTexts: cadpStatAdminActivePhy.setDescription('Returns the ifIndex of the phy which is the preferred active phy. A value of 0 indicates that no phy is currently active. Setting this object to a value different from its current value causes the ATM module to make the indicated phy active, and the active phy inactive. Setting this object to its current value has no effect. After performing the phy change, the agent will update all phy information (including cadpStatOperActivePhy) and send a ciscoAtmDualPhyChange trap.')
ciscoAtmDualPhyChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 60, 2) + (0,1)).setObjects(("CISCO-ATM-DUAL-PHY-MIB", "cadpStatOperActivePhy"))
if mibBuilder.loadTexts: ciscoAtmDualPhyChange.setDescription('A ciscoAtmDualPhyChange trap is sent when the active phy changes either because of a failure or because of user intervention (setting cadpStatAdminActivePhy, for example).')
ciscoAtmDualPhyMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 3, 2, 1))
ciscoAtmDualPhyMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 60, 3, 1, 1))
mibBuilder.exportSymbols("CISCO-ATM-DUAL-PHY-MIB", cadpStatistics=cadpStatistics, cadpStatOperActivePhy=cadpStatOperActivePhy, ciscoAtmDualPhyMIBGroups=ciscoAtmDualPhyMIBGroups, cadpStatEntry=cadpStatEntry, cadpStatAdminActivePhy=cadpStatAdminActivePhy, ciscoAtmDualPhyMIBObjects=ciscoAtmDualPhyMIBObjects, ciscoAtmDualPhyMIB=ciscoAtmDualPhyMIB, cadpStatPathBIP8Errors=cadpStatPathBIP8Errors, cadpStatFarEndReceiveFailure=cadpStatFarEndReceiveFailure, cadpStatLineFEBErrors=cadpStatLineFEBErrors, ciscoAtmDualPhyMIBCompliance=ciscoAtmDualPhyMIBCompliance, cadpStatUncorrectableHCSErrors=cadpStatUncorrectableHCSErrors, cadpStatPathFEBErrors=cadpStatPathFEBErrors, cadpStatLossOfSignal=cadpStatLossOfSignal, ciscoAtmDualPhyMIBCompliances=ciscoAtmDualPhyMIBCompliances, cadpStatActive=cadpStatActive, cadpStatCorrectableHCSErrors=cadpStatCorrectableHCSErrors, ciscoAtmDualPhyMIBTrapPrefix=ciscoAtmDualPhyMIBTrapPrefix, cadpStatLineBIP824Errors=cadpStatLineBIP824Errors, ciscoAtmDualPhyMIBGroup=ciscoAtmDualPhyMIBGroup, cadpStatTable=cadpStatTable, ciscoAtmDualPhyMIBTraps=ciscoAtmDualPhyMIBTraps, ciscoAtmDualPhyMIBConformance=ciscoAtmDualPhyMIBConformance, ciscoAtmDualPhyChange=ciscoAtmDualPhyChange, cadpStatSectionBIP8Errors=cadpStatSectionBIP8Errors)

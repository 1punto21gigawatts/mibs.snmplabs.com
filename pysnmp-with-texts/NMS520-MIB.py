#
# PySNMP MIB module NMS520-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NMS520-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:22:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
dsu, = mibBuilder.importSymbols("DDS-MIB", "dsu")
gdc, = mibBuilder.importSymbols("GDCCMN-MIB", "gdc")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Gauge32, IpAddress, Counter32, ModuleIdentity, ObjectIdentity, iso, Unsigned32, NotificationType, Integer32, MibIdentifier, Counter64, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Gauge32", "IpAddress", "Counter32", "ModuleIdentity", "ObjectIdentity", "iso", "Unsigned32", "NotificationType", "Integer32", "MibIdentifier", "Counter64", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
nms520 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2))
nms520MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 8, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: nms520MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
nms520UnitCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 2, 2), )
if mibBuilder.loadTexts: nms520UnitCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms520UnitCfgTable.setDescription('The NMS520 Unit Configuration table. This table augments the GDC SC5520 Unit Configuration table, providing unit level configuration for each NMS520 device installed. For each entry in the GDC SC Unit Configuration table that represents an NMS520, there is a corresponding entry here whereby the value of the gdcSCunitCfgIndex object is equivalent to the value of the nms520unitCfgIndex object.')
nms520UnitCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1), ).setIndexNames((0, "NMS520-MIB", "nms520UnitCfgIndex"))
if mibBuilder.loadTexts: nms520UnitCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms520UnitCfgEntry.setDescription('The NMS520 Unit Configuration table entry. The information in this entry augments the information in the corresponding entry in the GDC SC Unit Configuration table and provides unit level configuration for the installed NMS520.')
nms520UnitCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520UnitCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms520UnitCfgIndex.setDescription('The index value which uniquely identifies the NMS520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the NMS520 with no sub-identifier value.')
nms520Nms510CompatibilityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520Nms510CompatibilityMode.setStatus('mandatory')
if mibBuilder.loadTexts: nms520Nms510CompatibilityMode.setDescription('The NMS510 compatibility mode. This mode allows the NMS520 to behave in a manner compatible with that of the NMS510 in a DDSI multipoint circuit. If this object has the value enabled(2), then the device can be used in conjunction with an NMS510. A value of disabled(1) implies that the device is not backwardly compatible with the NMS510.')
nms520PtToPtSentryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520PtToPtSentryTime.setStatus('mandatory')
if mibBuilder.loadTexts: nms520PtToPtSentryTime.setDescription('The Point to point sentry time nms520PtToPtSentryTime, is used to control the amount of time between unsolicited alarm responses from a remote unit in a point to point application when there are no alarm conditions to report. This unsolicited response maintains the management link between the two units. These alarm responses are intrusive to data. The range is from 1 minute to 127 minutes, with 60 minutes being the default value. The value of 0(zero) minutes will disable remote alarm sentry reporting.')
nms520AlarmHystTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520AlarmHystTime.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmHystTime.setDescription('The Alarm hysterysis time nms520AlarmHystTime, is used to control the amount of time a remote must wait between reporting unsolicited alarm conditions. A remote will send an unsolicited alarm response at the time of the first alarm. If second alarm occurs the remote will wait for the time specified by this object before it will send another alarm response. This time applies for both point to point and multipoint applications. The range is from 1 second to 127 seconds, with 10 seconds being the default value.')
nms520MtpointRmRspIntrvl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520MtpointRmRspIntrvl.setStatus('mandatory')
if mibBuilder.loadTexts: nms520MtpointRmRspIntrvl.setDescription('The multipoint remote response interval nms520MtpointRmRspIntrvl, is used to control the amount of time between unsolicited alarm responses from a remote unit in a multipoint applications when there are no alarm conditions to report. This unsolicited response maintains the management link between the two units. The range is from 1 second to 127 seconds with 10 seconds being the default value. The value of 0(zero) seconds is disable remote alarm sentry reporting. All remotes in a multipoint application must be set the same. These alarm responses are non-intrusive to data.')
nms520DtePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rs232", 1), ("v35", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DtePortType.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DtePortType.setDescription('The value auto(3), indicates that the DTE port is automatically being detected, and set. The rs232(1), will force the DTE port to EIA/TIA-232-E, and v35(2), will force the DTE port to V.35.')
nms520DteCtsDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ctsOn", 1), ("cts0mSec", 2), ("ctsFixed3Char", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DteCtsDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DteCtsDelay.setDescription('RTS/CTS Delay options ctsOn(1) Forces both RTS and CTS On regardless of the state of the attached business equipment (the transmitter is On regardless of the status of the RTS interface lead). MIB object nms520DteCtsDelayExt is ignored. cts0mSec(2) Provides zero bits of delay between active RTS and CTS being set to active. MIB object nms520DteCtsDelayExt must be set to ext0mSec(1). ctsFix3Char(3) Provides three character bits of delay between active RTS and CTS being set to active. MIB object nms520DteCtsDelayExt must be set to ext0mSec(1).')
nms520DteCtsDelayExt = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ext0mSec", 1), ("ext30mSec", 2), ("ext60mSec", 3), ("ext90mSec", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DteCtsDelayExt.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DteCtsDelayExt.setDescription('RTS/CTS Delay options extension ext0mSec(1) Used to enable options cts0mSec(2) or ctsFix3Char(3) from MIB object nms520DteCtsDelay. ext30mSec(2) Provides 30 msec of delay between active RTS and CTS being set to active. MIB object nms520DteCtsDelay must be set for either cts0mSec(2) or ctsFix3Char(3). ext60mSec(3) Provides 60 msec of delay between active RTS and CTS being set to active. MIB object nms520DteCtsDelay must be set for either cts0mSec(2) or ctsFix3Char(3). ext90mSec(4) Provides 90 msec of delay between active RTS and CTS being set to active. MIB object nms520DteCtsDelay must be set for either cts0mSec(2) or ctsFix3Char(3).')
nms520FirmwareLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520FirmwareLevel.setStatus('mandatory')
if mibBuilder.loadTexts: nms520FirmwareLevel.setDescription('The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. Test versions are numerical from 01 to 99.')
nms520DaisyChainBps = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bps75", 1), ("bps9600", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DaisyChainBps.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DaisyChainBps.setDescription('Indicates the data rate at which the management data is sent/received when the gdcNmsManagementSource is daisyChain(4).')
nms520AlarmCfgCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520AlarmCfgCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmCfgCountWindow.setDescription('The DDS Alarm Threshold Alarm Interval. It specifies the amount of time in minutes, 1 to 15 minutes, in which the threshold setting is to be exceeded for the alarm to occur. There is one Alarm Interval for all five alarms that require thresholds: nms520JitterAlm, nms520BpvAlm, nms520FrameLossAlm, nms520SignalToNoiseAlm and nms520RxSignalLowAlm. ')
nms520SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: nms520SoftReset.setDescription('This object will cause software reset in dataset.')
nms520FrontPanelInhibit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fpInhibited", 1), ("fpEnabled", 2), ("execute", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520FrontPanelInhibit.setStatus('mandatory')
if mibBuilder.loadTexts: nms520FrontPanelInhibit.setDescription('Inhibits all front panel test switches. If a test switch is activated while inhibited it will simply be ignored. If enabled via the nms520FrontPanelEnable object the test switch will function as normal.')
nms520FrontPanelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fpInhibited", 1), ("fpEnabled", 2), ("execute", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520FrontPanelEnable.setStatus('mandatory')
if mibBuilder.loadTexts: nms520FrontPanelEnable.setDescription('Enables all front panel test switches. If a test switch is activated while inhibited, via the nms520FrontPanelInhibit object, it will simply be ignored. If enabled the test switch will function as normal.')
nms520HdlcInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("invert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520HdlcInvert.setStatus('mandatory')
if mibBuilder.loadTexts: nms520HdlcInvert.setDescription('Primary data invert option. Will enhance the quality of data when network does not provide B8Z5. Primarily used with DDS II 56k')
nms520PiggyBackDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-installed", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520PiggyBackDetect.setStatus('mandatory')
if mibBuilder.loadTexts: nms520PiggyBackDetect.setDescription('If set to 2 then either a Data Rate Adadaptor or 530 card is installed.')
nms520UnitType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("singleHeight", 1), ("withIFP", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520UnitType.setStatus('mandatory')
if mibBuilder.loadTexts: nms520UnitType.setDescription('with IFP(2) means that the unit has a LCD configurable display. single-height(1) means that the unit does NOT have a LCD configurable display.')
nms520ExtPortCtrlOut1 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520ExtPortCtrlOut1.setStatus('mandatory')
if mibBuilder.loadTexts: nms520ExtPortCtrlOut1.setDescription('This option sets the external output state (on/off) of the current network element and displays the external output.')
nms520ExtPortCtrlOut2 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520ExtPortCtrlOut2.setStatus('mandatory')
if mibBuilder.loadTexts: nms520ExtPortCtrlOut2.setDescription('This option sets the external output state (on/off) of the current network element and displays the external output.')
nms520AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4))
nms520NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 1))
nms520DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 2))
nms520PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 3))
nms520EEChkSumErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 4))
nms520StcLoopbackAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 5))
nms520NoNtwkLoopCurrentAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 6))
nms520LinePairsReversedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 7))
nms520NoSignalAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 8))
nms520FpTestAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 9))
nms520StreamingAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 10))
nms520DSRLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 11))
nms520DTRLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 12))
nms520DTPLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 13))
nms520DCDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 14))
nms520RXDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 15))
nms520TXDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 16))
nms520TmShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 17))
nms520DcdShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 18))
nms520DsrShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 19))
nms520CtsShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 20))
nms520RxdShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 21))
nms520RxcShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 22))
nms520TxcShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 23))
nms520DBURequestForScanAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 24))
nms520DBUOnalm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 25))
nms520DBUFailedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 26))
nms520NoDSUResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 27))
nms520NoDTEPollingAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 28))
nms520JitterAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 29))
nms520BpvAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 30))
nms520FrameLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 31))
nms520SignalToNoiseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 32))
nms520RxSignalLowAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 33))
nms520ExtInputChangeAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 34))
nms520ExtInputLowAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 2, 4, 35))
nms520AlarmCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 2, 8), )
if mibBuilder.loadTexts: nms520AlarmCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmCfgTable.setDescription('The GDC NMS520 Alarm Configuration Table.')
nms520AlarmCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 2, 8, 1), ).setIndexNames((0, "NMS520-MIB", "nms520AlarmCfgIndex"), (0, "NMS520-MIB", "nms520AlarmCfgIdentifier"))
if mibBuilder.loadTexts: nms520AlarmCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmCfgEntry.setDescription('An entry in the GDC NMS520 alarm Configuration table.')
nms520AlarmCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520AlarmCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmCfgIndex.setDescription('This object is the index of the NMS520 Alarm Threshold Configuration table.')
nms520AlarmCfgIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 8, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520AlarmCfgIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmCfgIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
nms520AlarmCfgThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-50, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520AlarmCfgThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: nms520AlarmCfgThreshold.setDescription('This function sets/reads the alarm threashold settings criteria. This threshold is used along with the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active. Alarm Table Entry Threshold Range Defaults ------------------ -------------------- -------------- -------- Jitter nms520JitterAlm 0 to 99 % 9 % Bipolar Violations nms520BpvAlm 0 to 99 Count 10 Frame Loss nms520FrameLossAlm 0 to 99 Count 10 Signal to Noise Ratio nms520SignalToNoiseAlm 0 to 50 0 Receive Level Low nms520RxSignalLowAlm -50 to 6 dB -33 dB')
nms520LineStatsTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 2, 5), )
if mibBuilder.loadTexts: nms520LineStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsTable.setDescription('The DDS Line Statistics table.')
nms520LineStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1), ).setIndexNames((0, "NMS520-MIB", "nms520LineStatsIndex"), (0, "NMS520-MIB", "nms520LineStatsInterval"))
if mibBuilder.loadTexts: nms520LineStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsEntry.setDescription('An entry in the DDS Line Statistics Table.')
nms520LineStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsIndex.setDescription('')
nms520LineStatsInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsInterval.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsInterval.setDescription('The DDS Line Statistics Interval. It specifies the amount of time in minutes (1 to 15 minutes) the unit will use to report statistical information. The unit will record statictics every minute and hold that information for 15 minutes. Past statistics can read from 1 to 15 minutes ago. A time must be specified to read any object in the ms520LineStatsTable. ')
nms520LineStatsTxInterpretation = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("noSignal", 2), ("notAvailable", 3), ("overRange", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsTxInterpretation.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsTxInterpretation.setDescription('This object will report the status of the line measurements, for the selected period. If noSignal(2), it will indicate that there is no receive signal availible. If notAvailable(3), it will indicate that the measurements have not completed. And if overRange(4), will indicate that the measurements taken are over measument the range. ')
nms520LineStatsTxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("txLevel0dB", 1), ("txLevel6dB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsTxLevel.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsTxLevel.setDescription('Will report the transmit Level of the line to be 0dB txLevel0dB(1), or 6dB txLevel6dB(2) as measured by the unit X minutes ago (1 to 15 miniutes) as specified by nms520LineStatsInterval. ')
nms520LineStatsRxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-50, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsRxLevel.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsRxLevel.setDescription('This object will report the receive level measured at X minutes ago (1 to 15 miniutes) as specified by nms520LineStatsInterval. The range is between the -50dB to +6dB.')
nms520LineStatsSignalToNoiseRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsSignalToNoiseRatio.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsSignalToNoiseRatio.setDescription('This object will the report the signal to noise ratio measured X minutes ago(1 to 15 miniutes) as specified by nms520LineStatsInterval. The range is from 0 to 50, for the selected period. The value is absolute. ')
nms520LineStatsSignalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("good", 1), ("fair", 2), ("bad", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsSignalQuality.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsSignalQuality.setDescription('This object will the report the signal quality of the line measured X minutes ago (1 to 15 miniutes) as specified by nms520LineStatsInterval.')
nms520LineStatsJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsJitter.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsJitter.setDescription('This object will the report the percent jitter of the line measured X minutes ago (1 to 15 miniutes) as specified by nms520LineStatsInterval. The range is 0% to 99% Jitter.')
nms520LineStatsBpvCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsBpvCount.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsBpvCount.setDescription('This object will the report the number of bipolar violation that have occured over the last X minutes (1 to 15 minutes). The range is from 0 to 99 violations. ')
nms520LineStatsFrameLossCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520LineStatsFrameLossCount.setStatus('mandatory')
if mibBuilder.loadTexts: nms520LineStatsFrameLossCount.setDescription('This object will the report the numbrt of frame losses that have occured over the last X minutes (1 to 15 minutes). The range is from 0 to 99 frame losses. ')
nms520DiagCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 2, 6), )
if mibBuilder.loadTexts: nms520DiagCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagCfgTable.setDescription('The NMS520 Unit Diagonostic table. ')
nms520DiagCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1), ).setIndexNames((0, "NMS520-MIB", "nms520DiagCfgIndex"))
if mibBuilder.loadTexts: nms520DiagCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagCfgEntry.setDescription('The NMS520 Unit Diagonostic table entry. ')
nms520DiagCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagCfgIndex.setDescription('The index value which uniquely identifies the NMS520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the NMS520 with no sub-identifier value.')
nms520DiagSendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sendOtherPattern", 1), ("send511Pattern", 2), ("send2047Pattern", 3), ("send15BitPattern", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagSendCode.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagSendCode.setDescription('Configures the selftest pattern to be run during any diagonostic test involving selftest. If option SendOtherPattern is selected, then pattern will default to 15 bit if unit is set for 56k-DDS/sc-multi point else pattern will default to 511 bit for all other conditions')
nms520DiagTestExceptions = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noExceptions", 1), ("blocksOutOfRange", 2), ("bitsOutOfRange", 3), ("blocksAndBitsOutOfRange", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagTestExceptions.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagTestExceptions.setDescription('Indicates exceptions that have occurred that may affect interpretation of the test results. The value of this object is a sum. This sum initially take the value zero. Then, for each exception, the value associated with the exception is added to the sum. The exception values are: value exception 0 No errors 1 bit over range 2 block over range 4 bit and block over range')
nms520DiagBitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagBitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagBitErrors.setDescription('The bit errors of the last diagnostic test that involved a Selftest pattern. Reading bit errors while a diagnostic test in running will cause the unit to drop out of test and invalidate the bit errors. Bit errors should be read only after the test is completed. The valid range for bit errors is 0 to 1,023, 65535 will be returned if for any reason the test was terminated early.')
nms520DiagBlockErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagBlockErrors.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagBlockErrors.setDescription('The block errors of the last diagnostic test that involved a Selftest pattern. Reading block errors while a diagnostic test in running will cause the unit to drop out of test and invalidate the block errors. Block errors should be read only after the test is completed. The valid range for block errors is 0 to 1,023, 65535 will be returned if for any reason the test was terminated early.')
nms520DiagTestReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("diagnostic", 2), ("resetTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagTestReset.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagTestReset.setDescription('This object will halt the execution of any and all diagnostic test that may be running with the exception of the Network Delay Test.')
nms520DiagTimeDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagTimeDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagTimeDelay.setDescription('This object reads the results of a Network Delay Test. The results are valid only after the test is completed which takes about 10 seconds. The unit for time delay is in miliseconds. The valid range for delay is 0 to 4096, 16383 will be returned if for any reason the test was terminated early. Reading this object while a test is in progress will terminate the test.')
nms520DiagExcTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 2, 7), )
if mibBuilder.loadTexts: nms520DiagExcTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagExcTable.setDescription('The NMS520 Unit Diagonostic table. ')
nms520DiagExcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1), ).setIndexNames((0, "NMS520-MIB", "nms520DiagExcIndex"))
if mibBuilder.loadTexts: nms520DiagExcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagExcEntry.setDescription('The NMS520 Unit Diagonostic table entry. ')
nms520DiagExcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagExcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagExcIndex.setDescription('The index value which uniquely identifies the NMS520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the NMS520 with no sub-identifier value.')
nms520DiagExtLineloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lineloopOff", 1), ("lineloopOn", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagExtLineloop.setStatus('obsolete')
if mibBuilder.loadTexts: nms520DiagExtLineloop.setDescription('Lineloop (or Analoop) can be either a Bilaterial or Unilaterial loopback depending on option ddsDteTermaloop. To initiate a Lineloop with no Selftest SET this object and specifiy external, this will allow the data from the DTE to looped back to itself. Emun external(3) is write only. The only valid response to a READ is lineloopOn(2) or lineloopOff(1). To halt this test you must SET the nms520DiagTestReset object. Reading test results via the sc5520DiagBitErrors or nms520DiagBlockErrors objects while the test is running will also cause the test to terminate. There are no test results associated with this test. ')
nms520DiagIntLineloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("lineloopOff", 1), ("lineloopOn", 2), ("blocks1", 3), ("blocks10", 4), ("blocks100", 5), ("blocks500", 6), ("blocks1000", 7), ("blocks5000", 8), ("blocks10000", 9), ("blocks50000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagIntLineloop.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagIntLineloop.setDescription('Lineloop (or Analoop) can be either a Bilaterial or Unilaterial loopback depending on option ddsDteTermaloop. To initiate a Lineloop with Selftest SET this object and specifiy a blocksize. The blocksize indicates the number of blocks the Selftest pattern generator will run. There are 1000 bits/block. Emuns 3 through 10 are write only. The only valid responses to a READ are lineloopOn(2) or lineloopOff(1). This test will terminate after the specified number of blocks have been run. Reading test results via the nms520DiagBitErrors or nms520DiagBlockErrors objects while the test is running will cause the test to terminate prematurely and render the results invalid. Test results should be only read after the test is completed. The current Test Status can be obtained by reading this object or the nms520DiagTestStatus object on the unit under test. This test can also be terminated by seting the nms520DiagTestReset object. ')
nms520DiagIntDataloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("dataloopOff", 1), ("dataloopOn", 2), ("blocks1", 3), ("blocks10", 4), ("blocks100", 5), ("blocks500", 6), ("blocks1000", 7), ("blocks5000", 8), ("blocks10000", 9), ("blocks50000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagIntDataloop.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagIntDataloop.setDescription('To initiate a Dataloop with Selftest SET this object and specifiy a blocksize. The nms520 (the remote) unit will go into Dataloop and the master (the sc5520) unit will go into Selftest. The blocksize indicates the number of blocks the Selftest pattern generator will run. There are 1000 bits/block. Emuns 3 through 10 are write only. The only valid responses to a READ are dataloopOn(2) or dataloopOff(1). This test will terminate after the specified number of blocks have been run. Reading test results via the nms520DiagBitErrors or nms520DiagBlockErrors objects while the test is running will cause the test to terminate prematurely and render the results invalid. Test results should be read only after the test is completed and are available from the master (sc5520) unit. The current Test Status can be obtained by reading the sc5520DiagTestStatus object on the master unit, reading test status on the remote unit may interfere with the diagonostic test pattern and cause errors. This test can also be terminated by seting the nms520DiagTestReset object. ')
nms520DiagEndToEndSelftest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("endToEndOff", 1), ("endToEndOn", 2), ("blocks1", 3), ("blocks10", 4), ("blocks100", 5), ("blocks500", 6), ("blocks1000", 7), ("blocks5000", 8), ("blocks10000", 9), ("blocks50000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagEndToEndSelftest.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagEndToEndSelftest.setDescription('To initiate an End to End Selftest(Error Rate Test) SET this object and specifiy a blocksize. Both the remote (nms520) amd master (sc5520) units will go into Selftest. The blocksize indicates the number of blocks the Selftest pattern generator will run. There are 1000 bits/block. Emuns 3 through 10 are write only. The only valid responses to a READ are selftestOn(2) or selftestOff(1). This test will terminate after the specified number of blocks have been run. Reading test results via the nms520DiagBitErrors or nms520DiagBlockErrors objects while the test is running will cause the test to terminate prematurely and render the results invalid. Test results should be read only after the test is completed and are available from both the remote (nms520) and master (sc5520) units. The current Test Status can be obtained by reading the sc5520DiagTestStatus object on the master unit, reading test status on the remote unit may interfere with the diagonostic test patternand cause errors. This test can also be terminated by seting the nms520DiagTestReset object. ')
nms520DiagNetworkDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delayTestOff", 1), ("delayTestOn", 2), ("runDelayTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagNetworkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagNetworkDelay.setDescription('To initiate a Network Delay test SET this object and specifiy runDelayTest. Both the remote (nms520) and master (sc5520) units will go into a test to measure network delay. Emun 3 is write only. The only valid responses to a READ are delayTestOn(2) or delatTestOff(1). This test will terminate after 10 seconds. Reading test results via the nms520DelayTime object while the test is running will cause the test to terminate prematurely and render the results invalid. Test results should be read only after the test is completed and are available from the master (sc5520) unit. The current Test Status can be obtained by reading the sc5520DiagTestStatus object on the master unit, reading test status on the remote unit may interfere with the test and cause errors. This test can not be terminated early once it is started.')
nms520DiagTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noTest", 1), ("internalLineloop", 2), ("externalDataloop", 3), ("internalDataloop", 4), ("serviceTestCenterLoop", 5), ("endToend", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms520DiagTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagTestStatus.setDescription('This object gives the current diagonostic test status. noTest indicates that no diagonostic test is currently active. Reading this object while in a diagonostic test involing two units may interfere with a selftest pattern and invalidate the test results. Reading the sc5520DiagTestStatus (master unit) object during dagonostic tests involing two unit will not disrupt the test results. ')
nms520DiagExtDataloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 2, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dataloopOff", 1), ("dataloopOn", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms520DiagExtDataloop.setStatus('mandatory')
if mibBuilder.loadTexts: nms520DiagExtDataloop.setDescription('To initiate a Dataloop test with no Selftest SET this object and specifiy external, this will allow the data from the DTE attached to the far end unit (sc5520) to looped back to itself. Emun external(3) is write only. The only valid response to a READ is dataloopOn(2) or dataloopOff(1). To halt this test you must SET the nms520DiagTestReset object. Reading test results via the nms520DiagBitErrors or nms520DiagBlockErrors objects while the test is running will also cause the test to terminate. There are no test results associated with this test. Reading test status on the remote unit via nms520DiagTestStatus may interfere with the diagonostic test pattern generated from the terminal equiptment. ')
mibBuilder.exportSymbols("NMS520-MIB", nms520NoNtwkLoopCurrentAlm=nms520NoNtwkLoopCurrentAlm, nms520DBUFailedAlm=nms520DBUFailedAlm, nms520NoSignalAlm=nms520NoSignalAlm, nms520RxdShortedAlm=nms520RxdShortedAlm, nms520NoDTEPollingAlm=nms520NoDTEPollingAlm, nms520DiagBitErrors=nms520DiagBitErrors, nms520FpTestAlm=nms520FpTestAlm, nms520FrontPanelInhibit=nms520FrontPanelInhibit, nms520DTPLossAlm=nms520DTPLossAlm, nms520DiagCfgIndex=nms520DiagCfgIndex, nms520TxcShortedAlm=nms520TxcShortedAlm, nms520FirmwareLevel=nms520FirmwareLevel, nms520DBURequestForScanAlm=nms520DBURequestForScanAlm, nms520LineStatsFrameLossCount=nms520LineStatsFrameLossCount, nms520UnitCfgTable=nms520UnitCfgTable, nms520ExtInputLowAlm=nms520ExtInputLowAlm, nms520DiagEndToEndSelftest=nms520DiagEndToEndSelftest, nms520AlarmData=nms520AlarmData, nms520DiagRxErrAlm=nms520DiagRxErrAlm, nms520DiagCfgEntry=nms520DiagCfgEntry, nms520DBUOnalm=nms520DBUOnalm, nms520=nms520, nms520AlarmHystTime=nms520AlarmHystTime, nms520DiagBlockErrors=nms520DiagBlockErrors, nms520LineStatsTxLevel=nms520LineStatsTxLevel, nms520DiagTestExceptions=nms520DiagTestExceptions, nms520DiagNetworkDelay=nms520DiagNetworkDelay, nms520DiagTestReset=nms520DiagTestReset, nms520LinePairsReversedAlm=nms520LinePairsReversedAlm, nms520DiagCfgTable=nms520DiagCfgTable, nms520AlarmCfgTable=nms520AlarmCfgTable, nms520FrontPanelEnable=nms520FrontPanelEnable, nms520TXDLossAlm=nms520TXDLossAlm, nms520NoDSUResponseAlm=nms520NoDSUResponseAlm, nms520AlarmCfgCountWindow=nms520AlarmCfgCountWindow, nms520LineStatsTxInterpretation=nms520LineStatsTxInterpretation, nms520DiagTimeDelay=nms520DiagTimeDelay, nms520StreamingAlm=nms520StreamingAlm, nms520RxcShortedAlm=nms520RxcShortedAlm, nms520AlarmCfgIdentifier=nms520AlarmCfgIdentifier, nms520RxSignalLowAlm=nms520RxSignalLowAlm, nms520AlarmCfgThreshold=nms520AlarmCfgThreshold, nms520AlarmCfgEntry=nms520AlarmCfgEntry, nms520LineStatsJitter=nms520LineStatsJitter, nms520UnitType=nms520UnitType, nms520SoftReset=nms520SoftReset, nms520EEChkSumErrAlm=nms520EEChkSumErrAlm, nms520DcdShortedAlm=nms520DcdShortedAlm, nms520LineStatsInterval=nms520LineStatsInterval, nms520DteCtsDelay=nms520DteCtsDelay, nms520FrameLossAlm=nms520FrameLossAlm, nms520LineStatsBpvCount=nms520LineStatsBpvCount, nms520DiagExcTable=nms520DiagExcTable, nms520PtToPtSentryTime=nms520PtToPtSentryTime, nms520RXDLossAlm=nms520RXDLossAlm, nms520LineStatsEntry=nms520LineStatsEntry, nms520Nms510CompatibilityMode=nms520Nms510CompatibilityMode, nms520HdlcInvert=nms520HdlcInvert, nms520DteCtsDelayExt=nms520DteCtsDelayExt, nms520LineStatsRxLevel=nms520LineStatsRxLevel, nms520NoResponseAlm=nms520NoResponseAlm, nms520StcLoopbackAlm=nms520StcLoopbackAlm, nms520MtpointRmRspIntrvl=nms520MtpointRmRspIntrvl, nms520BpvAlm=nms520BpvAlm, nms520DtePortType=nms520DtePortType, nms520DiagIntLineloop=nms520DiagIntLineloop, nms520DiagExcIndex=nms520DiagExcIndex, nms520ExtPortCtrlOut2=nms520ExtPortCtrlOut2, nms520DCDLossAlm=nms520DCDLossAlm, nms520MIBversion=nms520MIBversion, nms520JitterAlm=nms520JitterAlm, nms520LineStatsSignalToNoiseRatio=nms520LineStatsSignalToNoiseRatio, nms520CtsShortedAlm=nms520CtsShortedAlm, nms520UnitCfgIndex=nms520UnitCfgIndex, nms520DTRLossAlm=nms520DTRLossAlm, nms520PowerUpAlm=nms520PowerUpAlm, nms520DiagExtLineloop=nms520DiagExtLineloop, nms520DSRLossAlm=nms520DSRLossAlm, nms520ExtPortCtrlOut1=nms520ExtPortCtrlOut1, nms520DsrShortedAlm=nms520DsrShortedAlm, nms520LineStatsSignalQuality=nms520LineStatsSignalQuality, nms520DaisyChainBps=nms520DaisyChainBps, nms520DiagExcEntry=nms520DiagExcEntry, nms520LineStatsTable=nms520LineStatsTable, nms520TmShortedAlm=nms520TmShortedAlm, nms520SignalToNoiseAlm=nms520SignalToNoiseAlm, nms520DiagTestStatus=nms520DiagTestStatus, nms520LineStatsIndex=nms520LineStatsIndex, nms520PiggyBackDetect=nms520PiggyBackDetect, nms520DiagSendCode=nms520DiagSendCode, nms520DiagIntDataloop=nms520DiagIntDataloop, nms520UnitCfgEntry=nms520UnitCfgEntry, nms520DiagExtDataloop=nms520DiagExtDataloop, nms520ExtInputChangeAlm=nms520ExtInputChangeAlm, nms520AlarmCfgIndex=nms520AlarmCfgIndex)

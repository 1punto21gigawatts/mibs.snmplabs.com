#
# PySNMP MIB module CISCO-DOCS-REMOTE-QUERY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-DOCS-REMOTE-QUERY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:55:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
cdxCmCpeMacAddress, = mibBuilder.importSymbols("CISCO-DOCS-EXT-MIB", "cdxCmCpeMacAddress")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
TenthdB, TenthdBmV = mibBuilder.importSymbols("DOCS-IF-MIB", "TenthdB", "TenthdBmV")
SnmpEngineID, SnmpAdminString = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpEngineID", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ObjectIdentity, IpAddress, MibIdentifier, ModuleIdentity, TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, Gauge32, Counter64, Unsigned32, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "MibIdentifier", "ModuleIdentity", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "Gauge32", "Counter64", "Unsigned32", "iso", "Bits")
TimeInterval, DisplayString, TimeStamp, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "DisplayString", "TimeStamp", "TruthValue", "TextualConvention")
ciscoDocsRemoteQueryMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 59))
ciscoDocsRemoteQueryMIB.setRevisions(('2004-08-06 00:00', '2000-12-21 00:00', '2000-03-08 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoDocsRemoteQueryMIB.setRevisionsDescriptions(('Change of range for cdrqCmtsCmPollerInterval. Change of description for cdrqCmtsCmPollerEnable and cdrqCmtsCmPollerInterval', 'Change the range of cdrqCmtsCmPollerInterval', 'Initial version of this MIB. ',))
if mibBuilder.loadTexts: ciscoDocsRemoteQueryMIB.setLastUpdated('200408060000Z')
if mibBuilder.loadTexts: ciscoDocsRemoteQueryMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoDocsRemoteQueryMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 U.S.A Tel: +1 800 553-NETS E-mail: cs-ubr@cisco.com')
if mibBuilder.loadTexts: ciscoDocsRemoteQueryMIB.setDescription('This MIB module provides the management of the Cisco Cable Modem Termination Systems (CMTS) Remote Query feature. This feature, implemented on a CMTS, facilitates SNMP polling of remote cable modems (CMs). This MIB includes the configuration and status objects of the CMTS CM Poller and remote CMs that polled by the CMTS CM Poller')
ciscoDocsRemQueryMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 1))
cdrqPoller = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1))
cdrqCM = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2))
cdrqCmtsCmPollerEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdrqCmtsCmPollerEnable.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerEnable.setDescription('An indication of whether the CMTS CM Poller is running. When the poller is enabled, it polls the remote CMs periodically specified in the cdrqCmtsCmPollerInterval mib object. cdrqCmtsCmPollerInterval and cdrqCmtsCmPollerCommunity need to have valid values in order to be able to set cdrqCmtsCmPollerEnable to TRUE. The operation can be expensive depending on how many CMs that the poller would be polling. It is suggested to have it disabled when not needed.')
cdrqCmtsCmPollerInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 2), TimeInterval().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8640000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdrqCmtsCmPollerInterval.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerInterval.setDescription("An interval between two polling cycles of the CMTS CM Poller. The poller will not start the next cycle until it finished polling for the last CM , even though the time has expired. If the cdrqCmtsCmPollerInterval is too small with a large number of CMs, the poller would tie up the CPU and resources and possibly degrade the system's performance. Any change in the cdrqCmtsCmPollerInterval will not be reflected if the poller has already been enabled. User cannot set cdrqCmtsCmPollerInterval to 0 but will read 0 when CMTS is first restarted and remote-query is not configured. Once poller is configured, cdrqCmtsCmPollerInterval will retain the value even if poller is later disabled")
cdrqCmtsCmPollerCommunity = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdrqCmtsCmPollerCommunity.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerCommunity.setDescription('The read community string is used for polling the CMs. Any change in the cdrqCmtsCmPollerCommunity will not be reflected if the poller has already been enabled. For SNMPv3, this object will contain a user name instead of a community string.')
cdrqCmtsCmPollerContextEngineID = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 4), SnmpEngineID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdrqCmtsCmPollerContextEngineID.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerContextEngineID.setDescription('The contextEngineID indicating the location of the context in which management information is accessed when using the user name specified by the corresponding instance of cdrqCmtsCmPollerCommunity. This object is implemented to support SNMPv3')
cdrqCmtsCmPollerContextName = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdrqCmtsCmPollerContextName.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerContextName.setDescription('The context in which management information is accessed when using the user name specified by the corresponding instance of cdrqCmtsCmPollerCommunity. This object is implemented to support SNMPv3')
cdrqCmtsCmPollerStartTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmPollerStartTime.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerStartTime.setDescription("The value of sysUpTime when the last polling cycle started. cdrqCmtsCmPollerStartTime is set to 0 when the CMTS is first restarted and doesn't get reset after the poller is disabled.")
cdrqCmtsCmPollerStopTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmPollerStopTime.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollerStopTime.setDescription("The value of sysUpTime when the last polling cycle finished. cdrqCmtsCmPollerStopTime is set to 0 when the CMTS is first restarted and doesn't get reset after the poller is disabled.")
cdrqCmtsCmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1), )
if mibBuilder.loadTexts: cdrqCmtsCmStatusTable.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmStatusTable.setDescription("This table contains the status of the cable modems that are polled by the CMTS CM Poller. The information will be overwritten when a new polling cycle starts. The removal of CM from the list or adding a new CM to the list won't be reflected until the next polling cycle. Depending on how many CMs that the poller is polling, polling this table constantly can be quite expensive; Therefore, it is best to poll upon receipt of the cdrqCmtsCmRQDoneNotification. As a hedge against lost notifications, periodic background polling should be performed. Howerver, excessive polling could degrade performance.")
cdrqCmtsCmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-DOCS-EXT-MIB", "cdxCmCpeMacAddress"))
if mibBuilder.loadTexts: cdrqCmtsCmStatusEntry.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmStatusEntry.setDescription("A list of the cable modem's attributes that are polled by a CMTS. ")
cdrqCmtsCmDownChannelPower = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1, 1), TenthdBmV()).setUnits('dBmV').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmDownChannelPower.setReference('DOCSIS Radio Frequency Interface Specification, Table 4-12 and Table 4-13.')
if mibBuilder.loadTexts: cdrqCmtsCmDownChannelPower.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmDownChannelPower.setDescription("The CM's received power level. This object may be set to zero if the CM does not support power level measurement. If the CM downstream interface is down, this object either returns the most current value or the value of 0.")
cdrqCmtsCmStatusTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1, 2), TenthdBmV()).setUnits('dBmV').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmStatusTxPower.setReference('DOCSIS Radio Frequency Interface specification, Section 4.2.8.')
if mibBuilder.loadTexts: cdrqCmtsCmStatusTxPower.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmStatusTxPower.setDescription('The operational transmit power for the CM upstream channel.')
cdrqCmtsCmUpChnlTxTimingOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmUpChnlTxTimingOffset.setReference('DOCSIS Radio Frequency Interface Specification, Section 6.5.')
if mibBuilder.loadTexts: cdrqCmtsCmUpChnlTxTimingOffset.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmUpChnlTxTimingOffset.setDescription('A measure of the current round trip time. Used for timing of CM upstream transmissions to ensure synchronized arrivals at the CMTS.')
cdrqCmtsCmSigQSignalNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1, 4), TenthdB()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmSigQSignalNoise.setReference('DOCSIS Radio Frequency Interface specification, Table 2-1 and 2-2')
if mibBuilder.loadTexts: cdrqCmtsCmSigQSignalNoise.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmSigQSignalNoise.setDescription('Signal/Noise ratio as perceived for the CM downstream channel.')
cdrqCmtsCmSigQMicroreflections = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('dBc').setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmSigQMicroreflections.setReference('DOCSIS Radio Frequency Interface specification, Table 2-1 and 2-2')
if mibBuilder.loadTexts: cdrqCmtsCmSigQMicroreflections.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmSigQMicroreflections.setDescription('Total microreflections including in-channel response as perceived on the CM downstream, measured in dBc below the signal level. This object is not assumed to return an absolutely accurate value, but is meant to give a rough indication of microreflections received on this interface. It is up to the implementor to provide information as accurate as possible.')
cdrqCmtsCmPollTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 59, 1, 2, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdrqCmtsCmPollTime.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmPollTime.setDescription('The value of sysUpTime when this CM entry was polled. If this value is larger than the cdrqCmtsCmPollerStopTime, either by receiving it from the cdrqCmtsCmRQDoneNotification or by polling the object itself, it indicates that the status has already been overwritten by a new polling cycle. To avoid this to happen, the NMS can increase the cdrqCmtsCmPollInterval so that the cdrqCmtsCmPollTime would fall in between the cdrqCmtsCmPollerStartTime and the cdrqCmtsCmPollerStopTime.')
ciscoDocsRQNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 2))
ciscoDocsRQNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 2, 0))
cdrqCmtsCmRQDoneNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 59, 2, 0, 1)).setObjects(("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerStartTime"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerStopTime"))
if mibBuilder.loadTexts: cdrqCmtsCmRQDoneNotification.setStatus('current')
if mibBuilder.loadTexts: cdrqCmtsCmRQDoneNotification.setDescription('This notification is sent when CMTS CM Poller finished polling for the current cycle. The cdrqCmtsCmPollerStartTime is the time when the polling cycle started. The cdrqCmtsCmPollerStopTime is the time when the polling cycle finished.')
ciscoDocsRemoteQueryConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 3))
cdrqDocsRemoteQueryCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 3, 1))
cdrqDocsRemoteQueryGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 59, 3, 2))
cdrqDocsRemoteQueryCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 59, 3, 1, 1)).setObjects(("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqPollerGroup"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCMGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdrqDocsRemoteQueryCompliance = cdrqDocsRemoteQueryCompliance.setStatus('current')
if mibBuilder.loadTexts: cdrqDocsRemoteQueryCompliance.setDescription('The compliance statement for entities which implement the Cisco Remote Query MIB')
cdrqPollerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 59, 3, 2, 1)).setObjects(("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerInterval"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerCommunity"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerContextEngineID"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerContextName"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerEnable"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerStartTime"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollerStopTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdrqPollerGroup = cdrqPollerGroup.setStatus('current')
if mibBuilder.loadTexts: cdrqPollerGroup.setDescription('Group of objects implemented in Cable Modem Termination Systems (CMTS) for configuring and monitoring the CMTS CM Poller.')
cdrqCMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 59, 3, 2, 2)).setObjects(("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmDownChannelPower"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmStatusTxPower"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmUpChnlTxTimingOffset"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmSigQSignalNoise"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmSigQMicroreflections"), ("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmPollTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdrqCMGroup = cdrqCMGroup.setStatus('current')
if mibBuilder.loadTexts: cdrqCMGroup.setDescription('Group of objects implemented in Cable Modem Termination Systems (CMTS) for monitoring cable modems via CMTS CM Poller.')
cdrqNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 10, 59, 3, 2, 3)).setObjects(("CISCO-DOCS-REMOTE-QUERY-MIB", "cdrqCmtsCmRQDoneNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdrqNotificationGroup = cdrqNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: cdrqNotificationGroup.setDescription('The notification which a CISCO-DOCS-REMOTE-QUERY-MIB entity may implement.')
mibBuilder.exportSymbols("CISCO-DOCS-REMOTE-QUERY-MIB", cdrqDocsRemoteQueryCompliances=cdrqDocsRemoteQueryCompliances, cdrqCmtsCmDownChannelPower=cdrqCmtsCmDownChannelPower, ciscoDocsRemQueryMIBObjects=ciscoDocsRemQueryMIBObjects, cdrqCmtsCmStatusTxPower=cdrqCmtsCmStatusTxPower, cdrqCmtsCmUpChnlTxTimingOffset=cdrqCmtsCmUpChnlTxTimingOffset, cdrqCmtsCmSigQSignalNoise=cdrqCmtsCmSigQSignalNoise, cdrqCmtsCmPollerEnable=cdrqCmtsCmPollerEnable, cdrqCmtsCmPollerContextEngineID=cdrqCmtsCmPollerContextEngineID, ciscoDocsRemoteQueryMIB=ciscoDocsRemoteQueryMIB, cdrqCmtsCmSigQMicroreflections=cdrqCmtsCmSigQMicroreflections, cdrqCmtsCmPollerCommunity=cdrqCmtsCmPollerCommunity, cdrqDocsRemoteQueryCompliance=cdrqDocsRemoteQueryCompliance, cdrqCmtsCmPollerStopTime=cdrqCmtsCmPollerStopTime, cdrqCmtsCmPollerStartTime=cdrqCmtsCmPollerStartTime, ciscoDocsRQNotifications=ciscoDocsRQNotifications, cdrqPoller=cdrqPoller, PYSNMP_MODULE_ID=ciscoDocsRemoteQueryMIB, cdrqCM=cdrqCM, cdrqCmtsCmPollTime=cdrqCmtsCmPollTime, ciscoDocsRQNotificationsPrefix=ciscoDocsRQNotificationsPrefix, cdrqDocsRemoteQueryGroups=cdrqDocsRemoteQueryGroups, cdrqCmtsCmStatusEntry=cdrqCmtsCmStatusEntry, cdrqPollerGroup=cdrqPollerGroup, cdrqCmtsCmPollerContextName=cdrqCmtsCmPollerContextName, cdrqCmtsCmStatusTable=cdrqCmtsCmStatusTable, cdrqCmtsCmPollerInterval=cdrqCmtsCmPollerInterval, cdrqNotificationGroup=cdrqNotificationGroup, ciscoDocsRemoteQueryConformance=ciscoDocsRemoteQueryConformance, cdrqCmtsCmRQDoneNotification=cdrqCmtsCmRQDoneNotification, cdrqCMGroup=cdrqCMGroup)

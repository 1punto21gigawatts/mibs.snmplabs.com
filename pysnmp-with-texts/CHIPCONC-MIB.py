#
# PySNMP MIB module CHIPCONC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CHIPCONC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:48:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
DisplayString, = mibBuilder.importSymbols("RFC1155-SMI", "DisplayString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Unsigned32, enterprises, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, MibIdentifier, ObjectIdentity, TimeTicks, IpAddress, Integer32, iso, Bits, ModuleIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Unsigned32", "enterprises", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "MibIdentifier", "ObjectIdentity", "TimeTicks", "IpAddress", "Integer32", "iso", "Bits", "ModuleIdentity", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

chipcom = MibIdentifier((1, 3, 6, 1, 4, 1, 49))
chipmib02 = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2))
chipGen = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 1))
chipEcho = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 2))
chipProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3))
chipExperiment = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4))
chipTTY = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 5))
chipTFTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 6))
chipDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 7))
online = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1))
oebm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 2))
midnight = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 3))
workGroupHub = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4))
emm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 5))
chipBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 6))
trmm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 7))
fmm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 8))
focus1 = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 9))
oeim = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 10))
chipExpTokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 1))
dot1dBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 14))
dot5 = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 1, 1))
olAgents = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1))
olConc = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 2))
olEnv = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3))
olModules = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4))
olNets = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5))
olGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6))
olAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7))
olSpecMods = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4))
ol50nnMCTL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 3))
ol51nnMMGT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 4))
ol51nnMFIB = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 5))
ol51nnMUTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 6))
ol51nnMTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 7))
ol51nnMBNC = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 8))
ol51nnBEE = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 9))
ol51nnRES = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 10))
ol51nnREE = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 11))
ol51nnMAUIF = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 12))
ol51nnMAUIM = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 13))
ol5208MTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 14))
ol51nnMFP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 15))
ol51nnMFBP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 16))
ol51nnMTPL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 17))
ol51nnMTPPL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 18))
ol52nnMTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 19))
ol52nnMFR = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 20))
ol51nnMTS = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 21))
ol51nnMFL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 22))
ol50nnMRCTL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 23))
ol51nnMFB = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 24))
ol53nnMMGT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 25))
ol53nnMFBMIC = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 26))
ol53nnMFIBST = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 27))
ol53nnMSTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 28))
ol51nnMTPCL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 29))
ol52nnBTT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 30))
ol51nnIx = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 31))
ol52nnMMGT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 32))
ol50nnMHCTL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 33))
olNet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 1))
olEnet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 2))
olTRnet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 3))
olFDDInet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 4))
hubSysGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 1))
hardwareGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 2))
softwareGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 3))
hubGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 4))
boardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 5))
portGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 6))
alarmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 7))
olThresh = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1))
olThreshControl = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 1))
olAgentsMySlot = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olAgentsMySlot.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsMySlot.setDescription('The slot id of this agent.')
olAgentsMasterReset = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olAgentsMasterReset.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsMasterReset.setDescription('Resetting mastership causes a new mastership election to occur. The agent with the highest mastership priority will become the new master. If there is more than one agent with the highest priority, the selection between those agents will be arbritrary.')
olAgentsTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3), )
if mibBuilder.loadTexts: olAgentsTable.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsTable.setDescription('A table of agents in the concentrator as seen by this agent. A master will see all the agents; a slave will only see itself.')
olAgentsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olAgentsSlotIndex"))
if mibBuilder.loadTexts: olAgentsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsEntry.setDescription('A profile of an agent within the concentrator.')
olAgentsSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olAgentsSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsSlotIndex.setDescription('The slot number that identifies the referenced agent.')
olAgentsStationAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: olAgentsStationAddr.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsStationAddr.setDescription('The unique identifier for this agent. Often this is the value of ifPhysAddress for the first interface.')
olAgentsIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olAgentsIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsIpAddress.setDescription("An IP Address that can be used to communicate to this agent. Note, this object's value may change as the agent switches to different sub-networks.")
olAgentsMasterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("non-master", 2), ("electing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olAgentsMasterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsMasterStatus.setDescription('The mastership status of this agent.')
olAgentsMasterPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4), ("five", 5), ("six", 6), ("seven", 7), ("eight", 8), ("nine", 9), ("ten", 10), ("never", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olAgentsMasterPriority.setStatus('mandatory')
if mibBuilder.loadTexts: olAgentsMasterPriority.setDescription('The mastership priority of this agent. Ten is the highest and one is the lowest. Never means will not be able become master. Some agents do not have the capability to become master (the etherent to ethernet bridge, e.g.) and setting those agents to a value other than never(11) will generate an invalid value error. Priority is only used when an election occurs. Mastership is not pre-emptive; use the reset mastership command (olAgentsMasterReset).')
olConcType = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("online-seventeen-slot", 1), ("online-six-slot", 2), ("online-six-slot-ft", 3), ("online-six-slot-hc", 4), ("online-six-slot-ft-hc", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olConcType.setStatus('mandatory')
if mibBuilder.loadTexts: olConcType.setDescription('This object identifies the type of concentrator represented by this agent.')
olConcReset = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olConcReset.setStatus('mandatory')
if mibBuilder.loadTexts: olConcReset.setDescription('Setting this value to reset(2) causes this concentrator to reset. ')
olConcNumSlots = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olConcNumSlots.setStatus('mandatory')
if mibBuilder.loadTexts: olConcNumSlots.setDescription('The number of slots in this concentrator. Note, that if a hidden controller is present, the number of slots is one more than the number of payload slots (six-slot-hc will report 7 slots, for example). The hidden controller does not actually occupy a main slot in the 6-slot concentrator, but it will report itself as slot 7.')
olConcProfile = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olConcProfile.setStatus('mandatory')
if mibBuilder.loadTexts: olConcProfile.setDescription("A bit string where the least significant bit corresponds to slot 1. A '1' in the bit indicates that a module is present in that slot. The number of octets provided is based on the olConcNumSlots value divided by 8. Any extra bits (for example, bits 18-24 for 17 slots) are meaningless. For example, the string 0x01 0xFF 0xFF would represent a full 17 slot concentrator.")
olEnvTempStatus = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("okay", 1), ("extremeTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olEnvTempStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvTempStatus.setDescription("The overall temperature status for this concentrator. This object's value is an aggregate of all the temperature probes in the concentrator, such that, when at least one probe reports extreme temperature, this object will have the value extremeTemp(2).")
olEnvPSCapacity = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olEnvPSCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvPSCapacity.setDescription('The total capacity of power supplies for this concentrator.')
olEnvPSTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 3), )
if mibBuilder.loadTexts: olEnvPSTable.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvPSTable.setDescription('A table that contains information about each potential power supply in the concentrator.')
olEnvPSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 3, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olEnvPSIndex"))
if mibBuilder.loadTexts: olEnvPSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvPSEntry.setDescription('A list of of information for each power supply in the concentrator.')
olEnvPSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olEnvPSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvPSIndex.setDescription('Identifies the power supply for which this entry contains power supply information. For systems with the primary and backup power supply (as opposed to the N+1 design), index 1 refers to the primary, and index 2 refers to the backup. ')
olEnvPSAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activate", 1), ("standby", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olEnvPSAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvPSAdminState.setDescription('The current desired state of the power supply. A power supply in standby does not provide power to the concentrator.')
olEnvPSOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("faulty", 3), ("not-installed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olEnvPSOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvPSOperStatus.setDescription('The current operational state of the power supply. A power supply in standby does not provide power to the concentrator.')
olEnvFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("okay", 1), ("faulty", 3), ("not-installed", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olEnvFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olEnvFanStatus.setDescription('The overall status of the fan(s).')
olModTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1), )
if mibBuilder.loadTexts: olModTable.setStatus('mandatory')
if mibBuilder.loadTexts: olModTable.setDescription('A table that contains generic information about every module that is present within the concentrator. ')
olModEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olModSlotIndex"))
if mibBuilder.loadTexts: olModEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olModEntry.setDescription('A list of information for each module in the concentrator. ')
olModSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olModSlotIndex.setDescription("The unique slot number of this module. Its value ranges between 1 and olConcNumSlots and remains constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
olModType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33))).clone(namedValues=NamedValues(("module-unmanageable", 1), ("module-unknown", 2), ("module-50nnM-CTL", 3), ("module-51nnM-MGT", 4), ("module-51nnM-FIB", 5), ("module-51nnM-UTP", 6), ("module-51nnM-TP", 7), ("module-51nnM-BNC", 8), ("module-51nnB-EE", 9), ("module-51nnR-ES", 10), ("module-51nnR-EE", 11), ("module-51nnM-AUIF", 12), ("module-51nnM-AUIM", 13), ("module-5208M-TP", 14), ("module-51nnM-FP", 15), ("module-51nnM-FBP", 16), ("module-51nnM-TPL", 17), ("module-51nnM-TPPL", 18), ("module-52nnM-TP", 19), ("module-52nnM-FR", 20), ("module-51nnM-TS", 21), ("module-51nnM-FL", 22), ("module-50nnM-RCTL", 23), ("module-51nnM-FB", 24), ("module-53nnM-MGT", 25), ("module-53nnM-FBMIC", 26), ("module-53nnM-FIBST", 27), ("module-53nnM-STP", 28), ("module-51nnM-TPCL", 29), ("module-52nnB-TT", 30), ("module-51nnI-x", 31), ("module-52nnM-MGT", 32), ("module-50nnM-HCTL", 33)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModType.setStatus('mandatory')
if mibBuilder.loadTexts: olModType.setDescription('The unique type identifier for this module. This type is used to identify the branch in olSpecMods (see below). module-unmanageable(1) means that only the following objects are valid for this module: olModSlotIndex olModClass olModVersion olModVendor olModReset olModConfigToDips olModConfigured module-unknown(2) means that all the generic attributes are manageable, but there is no olSpecMods branch for this module as viewed by this agent.')
olModClass = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("controller", 1), ("ethernet-mgmt", 2), ("ethernet-media", 3), ("ethernet-interconnect", 4), ("ethernet-portswitching-media", 5), ("token-ring-media", 6), ("terminal-server", 7), ("fddi-media", 8), ("token-ring-mgmt", 9), ("ethernet-connswitching-media", 10), ("token-ring-interconnect", 11), ("fddi-mgmt", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModClass.setStatus('mandatory')
if mibBuilder.loadTexts: olModClass.setDescription("The class of this module. Generally speaking, this object indicates the kind of module. Specifically, the class identifier specifies the internal representation of the module's managed information base.")
olModDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModDescr.setStatus('mandatory')
if mibBuilder.loadTexts: olModDescr.setDescription('A textual string containing information about the module.')
olModVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModVersion.setStatus('mandatory')
if mibBuilder.loadTexts: olModVersion.setDescription('The software version number of this module. ')
olModVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("chipcom", 1), ("cisco", 2), ("pilkington", 3), ("datability", 5), ("ibm", 6), ("raycom", 7), ("retix", 8), ("intellicom", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModVendor.setStatus('mandatory')
if mibBuilder.loadTexts: olModVendor.setDescription('The actual manufacturer of this board.')
olModResetModule = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olModResetModule.setStatus('mandatory')
if mibBuilder.loadTexts: olModResetModule.setDescription('Setting this object to reset(2) causes this module to reset.')
olModConfigToDips = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noConfigure", 1), ("configure", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olModConfigToDips.setStatus('mandatory')
if mibBuilder.loadTexts: olModConfigToDips.setDescription('Setting this object to configure(2) causes this module to configure based on the dip switch settings.')
olModConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notConfigured", 1), ("configured", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModConfigured.setStatus('mandatory')
if mibBuilder.loadTexts: olModConfigured.setDescription('This object indicates whether this module has already been configured. An unconfigured module is configured to a safe state where the network is isolated and the ports are disabled.')
olModNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("other", 1), ("isolated", 2), ("port-switching", 3), ("front-panel", 5), ("ethernet-1", 6), ("ethernet-2", 7), ("ethernet-3", 8), ("token-ring-1", 9), ("token-ring-2", 10), ("token-ring-3", 11), ("token-ring-4", 12), ("token-ring-5", 13), ("token-ring-6", 14), ("token-ring-7", 15), ("fddi-1", 16), ("fddi-2", 17), ("fddi-3", 18), ("fddi-4", 19), ("per-connector", 20), ("isolated-1", 21), ("isolated-2", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olModNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: olModNetwork.setDescription('The network that this module is attached to. If the value is other(1) or port-switching(3), setting this object to a different value will generate the invalidData error. If the value is port-switching(3), manage the networks via the olPortNetwork object. The value per-connector(20) is returned if the managed module is a per-connector switchable and the connectors are on different networks. The connector networks are managed by the objects defined in the olSpecMods branch specified for this module. Modules and ports on the same network intercommunicate. Setting the module to isolated(2) (or other isolated values), removes this module from the backplane. Setting this module to a value that is not the same protocol type will return an invalidData error. Setting this module to a value that it does not support will return an invalidData error.')
olModNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("port-switching", 3), ("ethernet", 5), ("token-ring", 6), ("fddi", 7), ("serial", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: olModNetworkType.setDescription('The network type of this module. port-switching(3) means that the network type differs depending on the port (like the router module). The network type reflects the valid values for olModNetwork.')
olModStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 20, 21))).clone(namedValues=NamedValues(("okay", 1), ("fatalError", 10), ("booting", 20), ("partial-failure", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olModStatus.setDescription("The module's status.")
olModNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: olModNumPorts.setDescription('The number of ports on this module. Note, ports may be physical ports like 10BASE-T ports, or logical, like the bridge module ports.')
olModNumTrunks = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModNumTrunks.setStatus('mandatory')
if mibBuilder.loadTexts: olModNumTrunks.setDescription('The number of trunks on this module. Note, trunks are links that are, by definition, backbone connections. Examples of trunks are ring in and ring out ports for token ring, and the connections for rings to the backplane.')
olPortTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2), )
if mibBuilder.loadTexts: olPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: olPortTable.setDescription('A table that contains generic information about each port on each module present within the concentrator.')
olPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olPortSlotIndex"), (0, "CHIPCONC-MIB", "olPortIndex"))
if mibBuilder.loadTexts: olPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olPortEntry.setDescription('A list of information about each port in the concentrator.')
olPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olPortSlotIndex.setDescription("The slot number of this port's module.")
olPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olPortIndex.setDescription('The port number of this port within this module.')
olPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5))).clone(namedValues=NamedValues(("logical", 1), ("media", 2), ("virtual", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olPortType.setStatus('mandatory')
if mibBuilder.loadTexts: olPortType.setDescription('The type of port. logical(1) is used to manage port resources that may not map directly to physical connections. The OEBM, for example, has two logical ports, although those two ports can be assigned to different combinations of four physical connections. media(2) refers to ports such as those on the 10BASE-T module. ')
olPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("backPlane", 1), ("bnc", 2), ("faui", 3), ("maui", 4), ("fiber", 5), ("db-50", 6), ("telco", 7), ("rj45", 8), ("rj45S", 9), ("db-9", 10), ("virtual", 11), ("fddi-lc", 12), ("fddi-st", 13), ("fddi-mic", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: olPortConnector.setDescription('The connector type of this port.')
olPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 19, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))).clone(namedValues=NamedValues(("okay", 1), ("linkFailure", 2), ("jabber", 3), ("remoteLinkFailure", 4), ("remoteJabber", 5), ("invalidData", 6), ("lowLight", 7), ("fifoOverrun", 8), ("fifoUnderrun", 9), ("fatalError", 10), ("partition", 11), ("mjlp", 12), ("noCable", 13), ("noSquelch", 14), ("noPhantom", 15), ("okay-standby", 19), ("off", 22), ("connecting", 23), ("backup-link", 24), ("security-breach", 25), ("unknownStatus", 26), ("beacon", 27), ("wireFault", 28), ("macRemoved", 29), ("notInserted", 30), ("speedMismatch", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olPortStatus.setDescription('The status of this port.')
olPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("redundant-primary", 3), ("redundant-backup", 4), ("redundant-rfs", 5), ("local", 6), ("remote", 7), ("remote-diagnostics", 8), ("unknown", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olPortAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: olPortAdminState.setDescription('The desired state of this port. Setting a port to be redundant-primary(3) or redundant-backup requires that the buddy slot and buddy port also be set to valid values (see appropriate olSpecMods objects). If the values associated with the redundant buddys are not valid, a genError will be returned. If the port is already redundant, an invalid set may result in both ports being disabled.')
olPortNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("other", 1), ("isolated", 2), ("per-module", 4), ("front-panel", 5), ("ethernet-1", 6), ("ethernet-2", 7), ("ethernet-3", 8), ("token-ring-1", 9), ("token-ring-2", 10), ("token-ring-3", 11), ("token-ring-4", 12), ("token-ring-5", 13), ("token-ring-6", 14), ("token-ring-7", 15), ("fddi-1", 16), ("fddi-2", 17), ("fddi-3", 18), ("fddi-4", 19), ("per-connector", 20), ("isolated-1", 21), ("isolated-2", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olPortNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: olPortNetwork.setDescription('The network that this port is attached to. If the value of olPortNetwork is per-module(4), then use the olModNetwork to manage this port. Setting olPortNetwork to a different value in this case will generate the invalidData error. Setting this port to a value that is not the same protocol type will return invalidData error. front-panel(5) is used for modules that have a logical port and a physical front connection. An example of this is the Eth2Eth Bridge module. Setting this port to a value that it does not support will generate an invalidData error.')
olPortNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 5), ("token-ring", 6), ("fddi", 7), ("serial", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olPortNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: olPortNetworkType.setDescription('The network type of this port. The type reflects the valid values for olPortNetwork. ')
olTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3), )
if mibBuilder.loadTexts: olTrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkTable.setDescription('A table that contains generic information about each trunk on each module present within the concentrator.')
olTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olTrunkSlotIndex"), (0, "CHIPCONC-MIB", "olTrunkIndex"))
if mibBuilder.loadTexts: olTrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkEntry.setDescription('A list of information about each trunk in the concentrator.')
olTrunkSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkSlotIndex.setDescription("The slot number of this trunk's module.")
olTrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkIndex.setDescription('The trunk number of this trunk.')
olTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("ringIn", 3), ("ringOut", 4), ("backplaneIn", 6), ("backplaneOut", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkType.setDescription('The type of trunk. ringIn(3) and ringOut(4) refer to special trunks on the token ring protocol type modules.')
olTrunkConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 9))).clone(namedValues=NamedValues(("backplane", 1), ("fiber", 5), ("rj45S", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkConnector.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkConnector.setDescription('The connector type of this trunk.')
olTrunkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 13, 14, 16, 17, 18, 27, 28))).clone(namedValues=NamedValues(("okay", 1), ("linkFailure", 2), ("fatalError", 10), ("noCable", 13), ("noSquelch", 14), ("lostLock", 16), ("upstreamNeighborLost", 17), ("invalidConfig", 18), ("beacon", 27), ("wireFault", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkStatus.setDescription('The status of this trunk.')
olTrunkAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olTrunkAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkAdminState.setDescription('The desired state of this trunk. Enabling a trunk allows the trunk to pass network traffic.')
olTrunkWrapState = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wrapped", 1), ("unwrapped", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkWrapState.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkWrapState.setDescription('The wrap state of this trunk. A trunk can wrap in response to a network event such as a break in the cable.')
olTrunkNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 255))).clone(namedValues=NamedValues(("slot-1", 1), ("slot-2", 2), ("slot-3", 3), ("slot-4", 4), ("slot-5", 5), ("slot-6", 6), ("slot-7", 7), ("slot-8", 8), ("slot-9", 9), ("slot-10", 10), ("slot-11", 11), ("slot-12", 12), ("slot-13", 13), ("slot-14", 14), ("slot-15", 15), ("slot-16", 16), ("slot-17", 17), ("external", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olTrunkNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: olTrunkNeighbor.setDescription('The upstream or downstream neighbor of the trunk.')
olModSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 5), )
if mibBuilder.loadTexts: olModSummaryTable.setStatus('mandatory')
if mibBuilder.loadTexts: olModSummaryTable.setDescription('A table of condensed module information.')
olModSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 5, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olModSummarySlotIndex"))
if mibBuilder.loadTexts: olModSummaryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olModSummaryEntry.setDescription('A summary of all the generic and value added information associated with this module.')
olModSummarySlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModSummarySlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olModSummarySlotIndex.setDescription('The slot number of this module that this summary pertains to.')
olModSummaryInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olModSummaryInfo.setStatus('mandatory')
if mibBuilder.loadTexts: olModSummaryInfo.setDescription("A summary of all information relating to this module in condensed format. The condensed format is only as large as needed to hence the largest value which usually is one octet. The TCP port for the terminal server, however, uses 4 octets. The summary consists of a header, a module portion, a port portion, and a trunk portion. Each portion consists of generic information and module specific information. For example, the module information consists of the olModTable entry for this slot and the olSpecMods module table information for this module type for this slot. --------------------------------------------------- The header consists of the following octets: Version of structure : 1 Number of octets in generic module Number of octets in specific module Number of octets in generic port Number of octets in specific port Number of octets in generic trunk Number of octets in specific trunk The format of the data portion is as follows: Some of the olModTable: olModType olModClass olModDescr olModVersion olModNetwork olModNetworkType olModStatus olModNumPorts olModNumTrunks olSpecMods module table (for this module) Not including slot number. For each port: Some of the olPortTable: olPortType olPortConnector olPortStatus olPortAdminState olPortNetwork olPortNetworkType olSpecMods port table (for this port's module) Not including slot and port number. For each trunk: Some of the olTrunkTable: olTrunkType olTrunkConnector olTrunkStatus olTrunkAdminState olTrunkWrapState olTrunkNeighbor olSpecMods trunk table (for this trunk's module) Not including slot and trunk number. In all of the above, the index for all of these tables is condensed out of the summary. ")
olGroupPortTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 1), )
if mibBuilder.loadTexts: olGroupPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupPortTable.setDescription('A list of groups that each port is in. Each port can can be in 0, 1, or many groups.')
olGroupPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 1, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olGroupPortSlotIndex"), (0, "CHIPCONC-MIB", "olGroupPortIndex"))
if mibBuilder.loadTexts: olGroupPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupPortEntry.setDescription('The groups corresponding to a particular port.')
olGroupPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olGroupPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupPortSlotIndex.setDescription('The slot number that contains this port.')
olGroupPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olGroupPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupPortIndex.setDescription('The port number within this slot. Logical ports can not be put into groups.')
olGroupPortGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olGroupPortGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupPortGroupID.setDescription('The group(s) to which the port has been assigned.')
olGroupSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 2), )
if mibBuilder.loadTexts: olGroupSummaryTable.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSummaryTable.setDescription('A table of condensed group information listing all the ports in each group.')
olGroupSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 2, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olGroupSummaryGroupID"), (0, "CHIPCONC-MIB", "olGroupSummaryIndex"))
if mibBuilder.loadTexts: olGroupSummaryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSummaryEntry.setDescription('The summary of all the ports in a particular group.')
olGroupSummaryGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("group-1", 1), ("group-2", 2), ("group-3", 3), ("group-4", 4), ("group-5", 5), ("group-6", 6), ("group-7", 7), ("group-8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olGroupSummaryGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSummaryGroupID.setDescription('The group to which the ports have been assigned. A port can be in one or more groups.')
olGroupSummaryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olGroupSummaryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSummaryIndex.setDescription('The index into the summary array. Up to 256 ports will be shown in olGroupSummaryPorts for each value in this entry.')
olGroupSummaryPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olGroupSummaryPorts.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSummaryPorts.setDescription('A condensed list of all the ports in this group. The summary is in the format: Slotx PortX SlotY PortY ...')
olGroupSet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 3))
olGroupSetAction = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add-ports", 1), ("clear-ports", 2), ("set-admin-state", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olGroupSetAction.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSetAction.setDescription('This object specifies the action that we apply on a group. add-ports(1) adds port(s) to a group, clear-ports(2) clears (delete) port(s) from a group, and set-admin-state sets the Admin State of the group.')
olGroupSetGroupID = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("group-1", 1), ("group-2", 2), ("group-3", 3), ("group-4", 4), ("group-5", 5), ("group-6", 6), ("group-7", 7), ("group-8", 8), ("all-groups", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olGroupSetGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSetGroupID.setDescription('A group index that uniquely identifies this group. A port can be in zero, one, or more groups.')
olGroupSetSlotIndex = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olGroupSetSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSetSlotIndex.setDescription('This object specifies the slot number of the port(s) that are to be added/cleared to/from the group. This object should be set whenever add-ports(1) or clear-ports(2) are selected for olGroupSetAction. Value 254 refers to all non-existing ports, and value 255 refers to all slots which are only valid when olGroupSetAction is clear-ports(2).')
olGroupSetPortIndex = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olGroupSetPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSetPortIndex.setDescription('This object specifies the port number of the port(s) that are to be added/cleared to/from the group. This object should be set whenever add-ports(1) or clear-ports(2) are selected for olGroupSetAction. Value 255 refers to all ports.')
olGroupSetAdminState = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olGroupSetAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: olGroupSetAdminState.setDescription('This object specifies the Admin State that all the ports in the group defined by olGroupSetGroupID should be set to. This object should be set whenever set-admin-state(3) is selected for olGroupSetAction.')
olThreshTotalEntries = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshTotalEntries.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshTotalEntries.setDescription('The number of entries currently in olThreshTable.')
olThreshMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshMaxEntries.setDescription('The maximum number of entries in olThreshTable supported by this agent.')
olThreshLastCreatedIndex = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshLastCreatedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshLastCreatedIndex.setDescription('The index of the last entry in olThreshTable created via index 255 (see olThreshMode). If none, this value will be zero.')
olThreshAllMode = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshAllMode.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshAllMode.setDescription('Provides the management station with a convenient way to set olThreshMode for all of the entries in ThreshTable. Setting olThreshAllMode to enable(1) or disable(2) will not cause new entries to be created; this will only affect entries that have presiously been created. Getting olThreshAllMode will always yield clear(3).')
olThreshTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2), )
if mibBuilder.loadTexts: olThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshTable.setDescription('A list of thresholding entries.')
olThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1), ).setIndexNames((0, "CHIPCONC-MIB", "olThreshIndex"))
if mibBuilder.loadTexts: olThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshEntry.setDescription('A collection of variables for controlling and monitoring a specific threshold.')
olThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshIndex.setDescription("An index that uniquely identifies an entry in the olThresh table. The number of entries in olTRThreshTable is olThreshTotalEntries. A new entry is created when a value is written to any object within the entry. An entry is removed when olThreshMode is set to clear(3). Index 255 references a 'pseudo entry' that allows the management station to create a new entry without having to search for a clear entry. When olThreshMode for entry 255 is set to disable or enable, if there is no available (clear) entry, then the SNMP set-response will indicate a bad value error, otherwise the agent does the following: - set the value of olThreshLastCreatedIndex to the index of the available entry - copy the values currently in entry 255 to the available entry - clear out entry 255.")
olThreshMode = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshMode.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshMode.setDescription('The mode for this threshold. enable(1) indicates that this entry is in use and thresholding will be done. disable(2) indicates that this entry is in use but will no thresholding will be done. Setting olThreshMode to clear(3) will cause this entry to be removed from the table.')
olThreshDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshDescription.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshDescription.setDescription('Description of the threshold to be sent with the chipAboveThreshold trap.')
olThreshObjectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshObjectIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshObjectIdentifier.setDescription('The object identifier that specifies the statistic to be thresholded. The statistic to be thresholded can be specified either by setting olThreshObjectIdentifier or by setting values of the olThreshStat group of variables. When olThreshObjectIdentifier is set, the agent changes the values of the olThreshStat group of variables to refer to the new statistic to be thresholded. Similarly, when a olThreshStat variable is set, the agent changes olThreshObjectIdentifier to refer to the new statistic to be thresholded. A null object identifier (0.0) is used when no statistic is specified.')
olThreshStatCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("network", 2), ("port", 3), ("station", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshStatCategory.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatCategory.setDescription('Specifies the category of statistic to be thresholded. When olThreshStatCategory is network(2) or station(4), olThreshStatNetID may also be specified. When olThreshStatCategory is station(4), olThreshStatStation must be specified. When olThreshStatCategory is port(3), olThreshStatSlotIndex and olThreshStatPortIndex must be specified.')
olThreshStatType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("frames", 2), ("octets", 3), ("broadcast-frames", 4), ("multicast-frames", 5), ("error-frames", 6), ("tr-net-soft-errors", 7), ("tr-net-hard-errors", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshStatType.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatType.setDescription('Specifies the type of statistic to be thresholded. error-frames(6) is valid only when olThreshStatCategory is port(3) or station(4). tr-net-soft-errors(7) or tr-net-hard-errors(8) is valid only when olThreshStatCategory is network(2). Note that tr-net-soft-errors(7) and tr-net-hard-errors(8) refer to dot5StatsSoftErrors and dot5StatsHardErrors, respectively. The other choices refer for items in the olTRTraf tables.')
olThreshStatNetID = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("other", 1), ("isolated", 2), ("token-ring-1", 9), ("token-ring-2", 10), ("token-ring-3", 11), ("token-ring-4", 12), ("token-ring-5", 13), ("token-ring-6", 14), ("token-ring-7", 15), ("agent-network", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshStatNetID.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatNetID.setDescription('When olThreshStatCategory is network(2) or station(4), specifies the network of statistic to be thresholded. If the agent is capable of collecting statistics only for the network that it is attached to, olThreshStatNetID can be set to agent-network(255); the agent will change olThreshStatNetID to reflect the network that the agent is currently attached to. If olThreshStatType is tr-net-soft-errors(7) or tr-net-hard-errors(8) the agent will change olThreshStatNetID to other(1).')
olThreshStatSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshStatSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatSlotIndex.setDescription('When olThreshStatCategory is port(3), specifies the slot index of the port of statistic to be thresholded.')
olThreshStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatPortIndex.setDescription('When olThreshStatCategory is port(3), specifies the port index of the port of statistic to be thresholded.')
olThreshStatStationAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 10), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshStatStationAddr.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatStationAddr.setDescription('When olThreshStatCategory is station(4), specifies the MAC address of the station of statistic to be thresholded.')
olThreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshInterval.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshInterval.setDescription('Specifies the length of the thresholding period in seconds. Minimum length is 5 seconds; maximum is 86400 seconds (24 hours).')
olThreshCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delta-above", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshCondition.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshCondition.setDescription('Specifies the type of conditional comparison for the threshold.')
olThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshValue.setDescription('At the end of each thresholding interval (olThreshInterval seconds), olThreshCurrentValue is compared against olThreshValue (unsigned). When olThreshType is delta-above(1): If olThreshStatus is valid(4), and olThreshCurrentValue is above olThreshValue, and olThreshMode is enabled, then a chipAboveThreshold trap will be sent. Another chipAboveThreshold trap will not be sent until olThreshCurrentValue drops to less than or equal to olThreshValue and then again exceeds it.')
olThreshCurrentValue = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshCurrentValue.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshCurrentValue.setDescription('When olThreshType is delta-exceed(1): The most recent delta value of olThreshStatObjectIdentifier (i.e. value of olThreshStatObjectIdentifier at the end of the interval minus the value of olThreshStatObjectIdentifier at the beginning of the interval). If olThreshStatus is not valid(4), olThreshCurrentValue will be 0.')
olThreshStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-statistic-specified", 1), ("statistic-not-accessible", 2), ("not-yet-available", 3), ("valid", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshStatus.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshStatus.setDescription('When olThreshType is delta-exceed(1): If olThreshStatObjectIdentifier has not yet been specified, olThreshStatus will be no-statistic-specified(1). If the first interval has not yet completed, olThreshStatus will be not-yet-available(2). If object referenced by olThreshStatObjectIdentifier is not accessible, olThreshStatus will be not-accessible(3). Otherwise olThreshStatus will be valid(4).')
olThreshTimeSinceLastTriggered = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: olThreshTimeSinceLastTriggered.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshTimeSinceLastTriggered.setDescription('Time in TimeTicks that has elapsed since a chipAboveThreshold trap associated with this ThreshEntry was last sent. If never sent, this value shall be zero.')
olThreshActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("trap-only", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshActionType.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshActionType.setDescription('The action to be performed when the threshold is triggered.')
olThreshActionData = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshActionData.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshActionData.setDescription('Additional information to be sent with the chipAboveThreshold trap. Provided for use by the network management station (NMS) - not interpreted by the agent. A network management station (NMS) could use olThreshActionData to specify an action to be performed by the NMS when the chipAboveThreshold trap is received.')
olThreshActionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: olThreshActionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: olThreshActionPriority.setDescription('The priority for this entry. Provided for use by the network management station (NMS) - not interpreted by the agent.')
mibBuilder.exportSymbols("CHIPCONC-MIB", chipProducts=chipProducts, olEnvFanStatus=olEnvFanStatus, olModVendor=olModVendor, olNets=olNets, olModType=olModType, olEnvPSIndex=olEnvPSIndex, olModConfigured=olModConfigured, olAgentsIpAddress=olAgentsIpAddress, olSpecMods=olSpecMods, hubGroup=hubGroup, olThreshMaxEntries=olThreshMaxEntries, ol51nnBEE=ol51nnBEE, olThreshControl=olThreshControl, olPortEntry=olPortEntry, olPortStatus=olPortStatus, olConc=olConc, ol51nnMFIB=ol51nnMFIB, olModules=olModules, olAgentsStationAddr=olAgentsStationAddr, softwareGroup=softwareGroup, chipGen=chipGen, olAgentsMasterPriority=olAgentsMasterPriority, olModNumPorts=olModNumPorts, oebm=oebm, olGroupSummaryIndex=olGroupSummaryIndex, chipcom=chipcom, olTrunkIndex=olTrunkIndex, olThreshCondition=olThreshCondition, olTrunkConnector=olTrunkConnector, ol51nnREE=ol51nnREE, olAgentsEntry=olAgentsEntry, ol50nnMCTL=ol50nnMCTL, olModSummarySlotIndex=olModSummarySlotIndex, olGroupPortIndex=olGroupPortIndex, olGroups=olGroups, chipDownload=chipDownload, ol51nnMTS=ol51nnMTS, olEnvPSCapacity=olEnvPSCapacity, ol51nnIx=ol51nnIx, olGroupSummaryPorts=olGroupSummaryPorts, olThreshActionType=olThreshActionType, olGroupSetGroupID=olGroupSetGroupID, olTrunkNeighbor=olTrunkNeighbor, ol53nnMFBMIC=ol53nnMFBMIC, olTrunkType=olTrunkType, olModEntry=olModEntry, olPortType=olPortType, boardGroup=boardGroup, ol50nnMRCTL=ol50nnMRCTL, alarmGroup=alarmGroup, olModStatus=olModStatus, ol51nnMFBP=ol51nnMFBP, olEnvPSAdminState=olEnvPSAdminState, olModTable=olModTable, midnight=midnight, olThreshStatPortIndex=olThreshStatPortIndex, olAgentsMySlot=olAgentsMySlot, olConcNumSlots=olConcNumSlots, ol51nnRES=ol51nnRES, olModSummaryTable=olModSummaryTable, chipTFTP=chipTFTP, ol5208MTP=ol5208MTP, focus1=focus1, olThreshTimeSinceLastTriggered=olThreshTimeSinceLastTriggered, olModResetModule=olModResetModule, ol51nnMAUIF=ol51nnMAUIF, ol51nnMUTP=ol51nnMUTP, olTrunkTable=olTrunkTable, olPortSlotIndex=olPortSlotIndex, emm=emm, olThreshEntry=olThreshEntry, dot5=dot5, olThreshIndex=olThreshIndex, olModSummaryInfo=olModSummaryInfo, olModSummaryEntry=olModSummaryEntry, olThreshLastCreatedIndex=olThreshLastCreatedIndex, olGroupSetAdminState=olGroupSetAdminState, olGroupPortTable=olGroupPortTable, olModNetworkType=olModNetworkType, ol51nnMBNC=ol51nnMBNC, ol53nnMFIBST=ol53nnMFIBST, olGroupSummaryTable=olGroupSummaryTable, chipExpTokenRing=chipExpTokenRing, hardwareGroup=hardwareGroup, olModVersion=olModVersion, olThreshInterval=olThreshInterval, olGroupSummaryEntry=olGroupSummaryEntry, olEnvPSOperStatus=olEnvPSOperStatus, olEnet=olEnet, online=online, olGroupSet=olGroupSet, olThreshStatCategory=olThreshStatCategory, ol53nnMMGT=ol53nnMMGT, ol50nnMHCTL=ol50nnMHCTL, chipTTY=chipTTY, olTrunkEntry=olTrunkEntry, olThreshCurrentValue=olThreshCurrentValue, olPortConnector=olPortConnector, olGroupPortGroupID=olGroupPortGroupID, olThresh=olThresh, olConcProfile=olConcProfile, olGroupSetSlotIndex=olGroupSetSlotIndex, olPortIndex=olPortIndex, olEnvPSEntry=olEnvPSEntry, olThreshActionData=olThreshActionData, chipmib02=chipmib02, workGroupHub=workGroupHub, olAgents=olAgents, olTrunkWrapState=olTrunkWrapState, olThreshStatSlotIndex=olThreshStatSlotIndex, hubSysGroup=hubSysGroup, ol51nnMTPPL=ol51nnMTPPL, olNet=olNet, olGroupSetPortIndex=olGroupSetPortIndex, olThreshStatType=olThreshStatType, ol51nnMTP=ol51nnMTP, olThreshStatStationAddr=olThreshStatStationAddr, olAlarm=olAlarm, olEnv=olEnv, olModClass=olModClass, olTrunkStatus=olTrunkStatus, olPortTable=olPortTable, olAgentsSlotIndex=olAgentsSlotIndex, ol53nnMSTP=ol53nnMSTP, trmm=trmm, olModConfigToDips=olModConfigToDips, olGroupSummaryGroupID=olGroupSummaryGroupID, ol51nnMFP=ol51nnMFP, fmm=fmm, dot1dBridge=dot1dBridge, olThreshStatNetID=olThreshStatNetID, ol52nnMMGT=ol52nnMMGT, olTRnet=olTRnet, olTrunkSlotIndex=olTrunkSlotIndex, olThreshAllMode=olThreshAllMode, chipEcho=chipEcho, chipBridge=chipBridge, olAgentsTable=olAgentsTable, olModSlotIndex=olModSlotIndex, olThreshTable=olThreshTable, olEnvPSTable=olEnvPSTable, ol52nnMFR=ol52nnMFR, ol51nnMFB=ol51nnMFB, olTrunkAdminState=olTrunkAdminState, ol51nnMTPL=ol51nnMTPL, olConcReset=olConcReset, olGroupPortSlotIndex=olGroupPortSlotIndex, ol51nnMMGT=ol51nnMMGT, olPortAdminState=olPortAdminState, olAgentsMasterReset=olAgentsMasterReset, olModNumTrunks=olModNumTrunks, ol51nnMFL=ol51nnMFL, MacAddress=MacAddress, portGroup=portGroup, ol51nnMAUIM=ol51nnMAUIM, olThreshValue=olThreshValue, olFDDInet=olFDDInet, ol52nnBTT=ol52nnBTT, olThreshMode=olThreshMode, olPortNetworkType=olPortNetworkType, ol51nnMTPCL=ol51nnMTPCL, olThreshDescription=olThreshDescription, olModDescr=olModDescr, ol52nnMTP=ol52nnMTP, olThreshStatus=olThreshStatus, olModNetwork=olModNetwork, olThreshTotalEntries=olThreshTotalEntries, olAgentsMasterStatus=olAgentsMasterStatus, oeim=oeim, olThreshObjectIdentifier=olThreshObjectIdentifier, olPortNetwork=olPortNetwork, olConcType=olConcType, olGroupSetAction=olGroupSetAction, olThreshActionPriority=olThreshActionPriority, olEnvTempStatus=olEnvTempStatus, olGroupPortEntry=olGroupPortEntry, chipExperiment=chipExperiment)

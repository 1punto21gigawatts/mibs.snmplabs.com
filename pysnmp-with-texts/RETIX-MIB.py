#
# PySNMP MIB module RETIX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RETIX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:56:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("RFC1212", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter64, NotificationType, TimeTicks, ModuleIdentity, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, Bits, IpAddress, Unsigned32, Gauge32, MibIdentifier, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter64", "NotificationType", "TimeTicks", "ModuleIdentity", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "Bits", "IpAddress", "Unsigned32", "Gauge32", "MibIdentifier", "iso", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
retix = MibIdentifier((1, 3, 6, 1, 4, 1, 72))
station = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 1))
lapb = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 2))
ieee8023 = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 3))
phySerIf = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 4))
mlink = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 5))
lan = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 6))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 7))
product = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 8))
router = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 10))
boot = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 11))
boothelper = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 12))
remote = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 13))
ipx = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 13, 1))
decnet = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 13, 2))
rmtLapb = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 13, 3))
x25 = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 13, 4))
stationTime = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stationTime.setStatus('mandatory')
if mibBuilder.loadTexts: stationTime.setDescription('The station time is the ime as perceived by the station. The string returned is a subset of UTC Time as specified in the Draft Recommendation X.409 Message Handling Systems : Presentation Transfer Syntax and Notation (ASN 1).')
stationCountResets = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationCountResets.setStatus('mandatory')
if mibBuilder.loadTexts: stationCountResets.setDescription('This parameter is a count of the number of times the station has been reset since the last station intialisation.')
freeBufferCount = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: freeBufferCount.setStatus('mandatory')
if mibBuilder.loadTexts: freeBufferCount.setDescription('This parameter represents the number of free buffers remaining in this station.')
freeHeaderCount = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: freeHeaderCount.setStatus('mandatory')
if mibBuilder.loadTexts: freeHeaderCount.setDescription('This parameter represents the number of free headers remaining in this station.')
physBlkSize = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 1600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: physBlkSize.setStatus('mandatory')
if mibBuilder.loadTexts: physBlkSize.setDescription("This parameter represents the current size in bytes of the physical block used by the station's buffer manager.")
newPhysBlkSize = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 1600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: newPhysBlkSize.setStatus('mandatory')
if mibBuilder.loadTexts: newPhysBlkSize.setDescription("This parameter represents the size in bytes of the physical block, that will be used by the station's buffer manager, after the next station reset.")
resetStation = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetStation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetStation.setStatus('mandatory')
if mibBuilder.loadTexts: resetStation.setDescription('This object is used to reset the station. This action does not clear any configured data, so that after the reset, the box does not return to the factory defaults. Only two values are valid to use with this object. A value of 1 is always returned when a GET is performed upon the object. To force a reset, a value of 2 must be used in the SET. A SET with a value of 1 has no effect.')
initStation = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("initialize", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: initStation.setStatus('mandatory')
if mibBuilder.loadTexts: initStation.setDescription('This object is used to initialise the station. Any configured data is lost, and all data values are returned to factory default values. Only two values are valid to use with this object. A value of 1 is always returned when a GET is performed upon the object. To force the initialisation, a value of 2 must be used in the SET. A SET with a value of 1 has no effect.')
resetStats = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetStats", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetStats.setStatus('mandatory')
if mibBuilder.loadTexts: resetStats.setDescription('The statistics counters are reset to zero by performing a set on this object. This reset occurs immediately. See the Statistics Objects section for a list of these counters. Only two values are valid to use with this object. A value of 1 is always returned when a GET is performed upon the object. To force a reset, a value of 2 must be used in the SET. A SET with a value of 1 has no effect.')
processorLoading = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processorLoading.setStatus('mandatory')
if mibBuilder.loadTexts: processorLoading.setDescription("Each instance of this object gives the percentage loading on a particular processor. Currently the first instance gives the percentage loading on the station's main processor and the second instance gives the loading on the station's sub-processor.")
trapDestinationTable = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 1, 11))
trapDestTable = MibTable((1, 3, 6, 1, 4, 1, 72, 1, 11, 1), )
if mibBuilder.loadTexts: trapDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestTable.setDescription('A list of destinations to which Traps will be sent.')
trapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 1, 11, 1, 1), ).setIndexNames((0, "RETIX-MIB", "trapDestEntryIpAddr"))
if mibBuilder.loadTexts: trapDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestEntry.setDescription("This table contains the internet addresses of, and the community names allocated to the managers to which the station's agent software will send traps (event information).")
trapDestEntryIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 11, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestEntryIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestEntryIpAddr.setDescription('This object defines the IP addresses of the managers to which the station will send Trap information.')
trapDestEntryCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 11, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestEntryCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestEntryCommunityName.setDescription('This object is a string, which is inserted into the community field of a Trap PDU.')
trapDestEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestEntryType.setDescription('Setting this object to invalid(2) has the effect of removing the corresponding entry in the trapDestTable. Setting this object to valid(1) has the effect of adding the corresponding entry in the trapDestTable. If the corresponding entry already existed, no error is returned.')
trapDestAction = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clearTable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestAction.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestAction.setDescription('This object is used to clear the complete table. Only two values are valid to use with this object. A value of 1 is always returned when a GET is performed upon the object. To clear the table, a value of 2 must be used in the SET. A SET with a value of 1 has no effect.')
trapDestPage = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 11, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(240, 240)).setFixedLength(240)).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDestPage.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestPage.setDescription("This OCTET STRING contains all the entries in the table. Each entry is in a 14 byte unit within the string. This unit is formatted as follows: Bytes 0-3 contain the IP Address, Bytes 4-13 contain the community name and Byte 14 contains the entry's type.")
passWord = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: passWord.setStatus('mandatory')
if mibBuilder.loadTexts: passWord.setDescription('This string is the password for the local configurator on the station. A GET on this object returns to a NULL string, a SET will reset the password to the new string value as a specified in the SET request.')
snmpAccessPolicyObject = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 1, 13))
snmpAccessPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 72, 1, 13, 1), )
if mibBuilder.loadTexts: snmpAccessPolicyTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpAccessPolicyTable.setDescription('This table is a list of entries which are used to authenticate PDUs received by the station. This table contains a maximum of 16 entries.')
snmpAccessPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 1, 13, 1, 1), ).setIndexNames((0, "RETIX-MIB", "accessPolicyIndex"))
if mibBuilder.loadTexts: snmpAccessPolicyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpAccessPolicyEntry.setDescription('This is an entry in the snmpAccesssPolicyTable.')
accessPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 13, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessPolicyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: accessPolicyIndex.setDescription('This index is used as the instance for a Get or Set operation on the table.')
communityName = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 13, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityName.setStatus('mandatory')
if mibBuilder.loadTexts: communityName.setDescription('This object is a string, against which the community field in a received PDU is compared. If there exists no community name in the table, with which the received community field forms a match, authentication of the PDU fails.')
accessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessMode.setStatus('mandatory')
if mibBuilder.loadTexts: accessMode.setDescription('This object is a bit field, where setting the bit to a value of 1 enabled the ACCESS option. Bit 0 represents read access, bit 1 represents write access. Thus to configure an entry to have read-write ACCESS this object must be set to a value of 3.')
snmpAccessPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 1, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpAccessPolicyType.setStatus('mandatory')
if mibBuilder.loadTexts: snmpAccessPolicyType.setDescription('This entry in the table tells you if the entire entry is valid or invalid, that is, if the community name specified by this entry is currently being used during the SNMP authentication process. If it is invalid, then it is not being used, and may be overwritten with a valid entry. Setting an entry to invalid effectively deletes the entry from the table, it will, however, appear in the table if you GET the complete contents of the table.')
snmpAccessPolicyAction = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 13, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clearTable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpAccessPolicyAction.setStatus('mandatory')
if mibBuilder.loadTexts: snmpAccessPolicyAction.setDescription('This object is used to invalidate all the entries in the snmpAccessPolicy Table.')
snmpAccessPolicyPage = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 13, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpAccessPolicyPage.setStatus('mandatory')
if mibBuilder.loadTexts: snmpAccessPolicyPage.setDescription("This OCTET STRING contains all the entries in the table. Each entry is in an 11 byte unit within the string. This unit is formatted as follows: Bytes 0-9 contain the community name, Byte 10 contains the ACCESS mode and Byte 11 contains the entry's type.")
authenticationTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authenticationTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: authenticationTrapStatus.setDescription('This object determines if the station will send a Trap upon detection of an authentication failure error. Set to a value of enabled(1) enables authentication checking and transmission of authenticationFailure Trap is an authentication problem occurs.')
serialTxQueueSize = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialTxQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: serialTxQueueSize.setDescription('This parameter indicates the maximum number of LAPB frames that can be enqueued, waiting for transmission over the serial interface.')
internalQueueCurrentLength = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalQueueCurrentLength.setStatus('mandatory')
if mibBuilder.loadTexts: internalQueueCurrentLength.setDescription('This is the length of the enqueued information specific to the internal operation of the bridge.')
queueUpperLimit = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: queueUpperLimit.setStatus('mandatory')
if mibBuilder.loadTexts: queueUpperLimit.setDescription('This is the upper limit of the enqueued information, for all the queues, specific to the operation of the bridge.')
lanQueueSize = MibScalar((1, 3, 6, 1, 4, 1, 72, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: lanQueueSize.setDescription('This variable reports tohe maximum number of frames that are enqueued waiting for transmission over the LAN interface.')
lapbNumber = MibScalar((1, 3, 6, 1, 4, 1, 72, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lapbNumber.setDescription('This is the number of LAPB interfaces (regardless of their current state) present on this system.')
lapbTable = MibTable((1, 3, 6, 1, 4, 1, 72, 2, 2), )
if mibBuilder.loadTexts: lapbTable.setStatus('mandatory')
if mibBuilder.loadTexts: lapbTable.setDescription('A list of LAPB interface entries.')
lapbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 2, 2, 1), ).setIndexNames((0, "RETIX-MIB", "lapbIndex"))
if mibBuilder.loadTexts: lapbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lapbEntry.setDescription('The LAPB table. An entry in this table is uniquely identified by the value of the lapbIndex variable associated with the interface to which the statistics refer.')
lapbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lapbIndex.setDescription("The interface on which this entry's equivalence is effective.")
lapbModeT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lapbModeT1.setStatus('mandatory')
if mibBuilder.loadTexts: lapbModeT1.setDescription("If the value of modeT1 is 0 then T1 timer is determined automatically by the software. If the value of this object is 1 then the timer is settable by the manager. The value of T1 won't change until the next reset of the station or the next link reset.")
lapbAutoT1value = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbAutoT1value.setStatus('mandatory')
if mibBuilder.loadTexts: lapbAutoT1value.setDescription('This parameter is the value of the T1 timer as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCICLE VIII.3 and is determined empirically by the software. It is the actual value of the timer in milliseconds.')
lapbManualT1value = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lapbManualT1value.setStatus('mandatory')
if mibBuilder.loadTexts: lapbManualT1value.setDescription('This object allows the manager to set the value of the T1 timer as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCICLE VIII.3. The settable range is 10 - 5000 which represents the timer value in milliseconds. This object maybe set at any time, but it is only used if the value of modeT1 is 1. This value will not become active until the next link or station reset.')
lapbWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbWindow.setStatus('mandatory')
if mibBuilder.loadTexts: lapbWindow.setDescription('This parameter represents the maximum number of I-frames which can be transmitted before an acknowledgement is received. Its value is determined automatically at link reset to be the optimum for the link in question. It can have any value between 7 and 127. This is the value of k as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCILE VIII.3')
lapbPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: lapbPolarity.setDescription("This parameter represents the logical 'polarity' of the port. LAPB polarity can take on one of two values, if it is 0 then the port is a logical DTE, if its value is 1 then the port is a logical DCE.")
lapbCountResets = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountResets.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountResets.setDescription('This parameter represents the number of link resets performed since the last warm or cold restart of the station or the last statistics reset.')
lapbCountSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountSentFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountSentFrames.setDescription('This parameter represents the number of I-frames sent since the last station restart or the last statistics reset.')
lapbCountRcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountRcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountRcvFrames.setDescription('This parameter represents the number of I-frames received since the last station restart or the last statistics reset.')
lapbCountSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountSentOctets.setDescription('This parameter represents the number of bytes sent since the last station restart or the last statistics reset.')
lapbCountRcvOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountRcvOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountRcvOctets.setDescription('This parameter represents the number of bytes received since the last station restart or the last statistics reset.')
lapbCountAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountAborts.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountAborts.setDescription('This parameter represents the number of aborths received since last station restart or the last statistics reset.')
lapbCountCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbCountCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lapbCountCrcErrors.setDescription('This parameter represents the number of CRC errors received since the last station restart or the last statistics reset.')
lapbState = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbState.setStatus('mandatory')
if mibBuilder.loadTexts: lapbState.setDescription('This parameter indicates the state of the LAPB link. This parameter can take on the following values: inactive (0), active (1), unused (2), tooFast (3).')
lapbLastResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbLastResetTime.setStatus('mandatory')
if mibBuilder.loadTexts: lapbLastResetTime.setDescription("Time and date when the last link reset occurred. The format of this string is the same as that defined for 'stationTime'.")
lapbLastResetReason = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lapbLastResetReason.setStatus('mandatory')
if mibBuilder.loadTexts: lapbLastResetReason.setDescription('This parameter indicates the reason for the last link reset. This parameter can take on the following: noReason (0), xpcError (1), ctsLost (2), retryLimitExceeded (3), receivedIdle (4), personalityModule (5), softwareWatchdog (6), nmcInitiated (7).')
lapbLinkReset = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lapbLinkReset.setStatus('mandatory')
if mibBuilder.loadTexts: lapbLinkReset.setDescription('This parameter causes a link reset. The link reset occurs after a pre-determined period of time which is implementation specific. A value of 1 is always returned when a GET is performed upon the object. To force the reset, a value of 2 must be used in the SET. A SET with a value of 1 has no effect.')
lapbRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 72, 2, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lapbRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: lapbRetryCount.setDescription('This is the value of N2 as defined inthe 1984 CCITT Recommendation X.25 VOLUME VIII - FASCICLE VIII.3.')
ieee8023Number = MibScalar((1, 3, 6, 1, 4, 1, 72, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023Number.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023Number.setDescription('This is the number of ethernet like interfaces supported by this station.')
ieee8023Table = MibTable((1, 3, 6, 1, 4, 1, 72, 3, 2), )
if mibBuilder.loadTexts: ieee8023Table.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023Table.setDescription('A list of IEEE 802.3 Interface entries.')
ieee8023Entry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 3, 2, 1), ).setIndexNames((0, "RETIX-MIB", "ieee8023Index"))
if mibBuilder.loadTexts: ieee8023Entry.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023Entry.setDescription('The statistics table. An entry in this table is uniquely identified by the value of the ieee8023Index variable associated with the interface to which the statistics refer.')
ieee8023Index = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023Index.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023Index.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
ieee8023FramesTransmittedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023FramesTransmittedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023FramesTransmittedOks.setDescription('This contains a count of frames that are successfully transmitted. This counter is incremented when a frame is successfully transmitted, even if one of the collision Counters (following two objects) are also counted. In other words, this count includes transmissions that succeeded after some number of collisions. This count includes multicast and broadcast frames.')
ieee8023SingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023SingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023SingleCollisionFrames.setDescription('This contains a count of frames that are involved in a single collision, and are subsequently transmitted successfully. If this counter is incremented then the ieee8023FramesTransmittedOKs count will also be incremented AND ieee8023MultipleCollisionFrames will NOT be incremented.')
ieee8023MultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MultipleCollisionFrames.setDescription('This contains a count of frames that are involved in more than one collision and are subsequntly transmitted successfully. If this counter is incremented then the ieee8023FramesTransmittedOKs count will also be incremented AND ieee8023SingleCollisionFrames will NOT be incremented.')
ieee8023OctetsTransmittedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023OctetsTransmittedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023OctetsTransmittedOks.setDescription('This contains a count of data and padding octets of frames that are successfully transmitted. This counter includes octets in broadcast and multicast frames that are transmitted. This count does not include the address fields, length/type field and CRC field of the frame. In Ethernet-Speak, it is JUST the data field (IP header, etc).')
ieee8023DeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023DeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023DeferredTransmissions.setDescription('This contains a count of frames whose transmission was delayed on its firs attempt because the medium was busy. Frames involved in collisions are NOT included in this count.')
ieee8023MulticastFramesTransmittedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MulticastFramesTransmittedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MulticastFramesTransmittedOks.setDescription('This contains a count of frames successfully transmitted to a group destination (multicast) address other than broadcast.')
ieee8023BroadcastFramesTransmittedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023BroadcastFramesTransmittedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023BroadcastFramesTransmittedOks.setDescription('This contains a count of frames successfully transmitted to the broadcast address. This does not include frames sent to a multicast address.')
ieee8023LateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023LateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023LateCollisions.setDescription('This contains a count of times that a collision has been detected later than 512 bit-times into the transmission of a packet. 512 bit-times is 51.2 micro-seconds. This type of collision is counted twice: both as a late collision and as a regurlar, run of the mill collision.')
ieee8023ExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023ExcessiveCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023ExcessiveCollisions.setDescription('This contains a count of frames that due to excessive collisions are not transmitted successfully.')
ieee8023InternalMACTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023InternalMACTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023InternalMACTransmitErrors.setDescription('This contains a count of frames which would otherwise be transmitted by the station, but could not be sent due to an internal MAC sublayer transmit error. If this counter is incremented then none of the other Counters in this section are incremented. The exact meaning and mechanism for incrementing this counter is implementation dependent. In short, htis is the count of errors for which there are no specific Counters.')
ieee8023CarrierSenseErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023CarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023CarrierSenseErrors.setDescription('This contains a count of times that carrier sense was lost or never appeared when attempting to transmit a packet. This counter is incremented ONCE per transmission attempt, even if Carrier Sense fluctuates during a transmission attempt.')
ieee8023ExcessiveDeferrals = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023ExcessiveDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023ExcessiveDeferrals.setDescription('This contains a count of frames which deferred for an excessive period of time.')
ieee8023FramesReceivedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023FramesReceivedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023FramesReceivedOks.setDescription('This contains a count of frames that are successfully received. This does not include frames received with a frame-too-long, FCS, length, or alignment errors or frames lost due to internal MAC sublayer error. This counter includes broadcast and multicast frames that are received.')
ieee8023OctetsReceivedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023OctetsReceivedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023OctetsReceivedOks.setDescription('This contains a count of data and padding octets in frames that are successfully received. This does not include frames received with a frame-too-long, FCS, length, or alighment errors or frames lost due to internal MAC sublayer error. This counter includes octets in broadcast and multicast frames that are received. This counter does not include the octets in the address, length/type and CRC fields.')
ieee8023MulticastFramesReceivedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MulticastFramesReceivedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MulticastFramesReceivedOks.setDescription('This contains a count of frames that are successfully received and are directed to an active non-broadcast group address. This does not include frames received with a frame-too-long, FCS, length, or alignment errors or frames lost due to internal MAC sublayer error. Broadcast packets are not included.')
ieee8023BroadcastFramesReceivedOks = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023BroadcastFramesReceivedOks.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023BroadcastFramesReceivedOks.setDescription('This contains a count of frames that are successfully received and are directed to the broadcast group address. This does not include frames received with a frame-too-long, FCS, length, or alignment errors or frames lost due to internal MAC sublayer error. Multicast packets are not included.')
ieee8023FrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023FrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023FrameTooLongs.setDescription('This contains a count of frames that are received and exceed the maximum permitted frame size.')
ieee8023AlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023AlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023AlignmentErrors.setDescription('This contains a count of frames that are not an integral number of octets in length and do not pass the FCS check.')
ieee8023FCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023FCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023FCSErrors.setDescription('This contains a count of frames that are an integral number of octets in length that do not pass the FCS check.')
ieee8023inRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023inRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023inRangeLengthErrors.setDescription('This contains a count of frames with a length field value between the minimum unpadded LLC data size and the maximum allowed LLC data size inclusive, and does not match the number of LLC data octets received. The counter also contains frames with a length field value less than the minimum unpaddes LLC data size.')
ieee8023outOfRangeLengthFields = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023outOfRangeLengthFields.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023outOfRangeLengthFields.setDescription('This contains a count of frames with a length field value graeater than the maximum allowed LLC data size.')
ieee8023InternalMACReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023InternalMACReceiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023InternalMACReceiveErrors.setDescription('This contains a count of frames which would otherwise be received by the station, but could not be accepted due to an internal MAC sublayer receive error. If this counter is incremented then none of the other Counters in this section are incremented. The exact meaning and mechanism for incrementing this counter is implementation dependent. In short, this is the count of errors for which there are no specific Counters.')
ieee8023InitializeMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("initialize", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8023InitializeMAC.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023InitializeMAC.setDescription('Resets the MAC layer counters. When set, only the value initialize may be sued. When read, this variable always returns the most recent value to which ieee8023InitializeMAC was set to. At the moment, this function only serves to zero the MAC counters.')
ieee8023PromiscuousReceiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8023PromiscuousReceiveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023PromiscuousReceiveStatus.setDescription('This variable causes the MAC sublayer to enter promiscuous receive state.')
ieee8023MACSubLayerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8023MACSubLayerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MACSubLayerStatus.setDescription('Causes the MAC sublayer to enter the normal operational state at idle.')
ieee8023TransmitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8023TransmitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023TransmitStatus.setDescription('This variable allows the MAC sublayer to be explicitly enabled/disabled for transmitting frames.')
ieee8023MulticastReceiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8023MulticastReceiveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MulticastReceiveStatus.setDescription('Enables reception of multicast frames.')
ieee8023MACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MACAddress.setDescription('This object contains the MAC station address i.e. the Ethernet address.')
ieee8023SQETestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023SQETestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023SQETestErrors.setDescription('This contains a count of times that the SQE test errors status was received.')
ieee8023NewMACAddress = MibTable((1, 3, 6, 1, 4, 1, 72, 3, 3), )
if mibBuilder.loadTexts: ieee8023NewMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023NewMACAddress.setDescription('A list of MAC addresses that will be allocated to an interface after the next station reset.')
ieee8023NewMACAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 3, 3, 1), ).setIndexNames((0, "RETIX-MIB", "ieee8023NewMACAddressIndex"))
if mibBuilder.loadTexts: ieee8023NewMACAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023NewMACAddressEntry.setDescription('A sequence defining an interface and the MAC address it will assume after the next station reset.')
ieee8023NewMACAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023NewMACAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023NewMACAddressIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ieee8023NewMACAddressValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 3, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8023NewMACAddressValue.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023NewMACAddressValue.setDescription('This object contains the MAC address which will be allocated to this interface after the next station reset.')
phySerIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 72, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySerIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfNumber.setDescription('The number of Physical Serial interfaces present on this system.')
phySerIfTable = MibTable((1, 3, 6, 1, 4, 1, 72, 4, 2), )
if mibBuilder.loadTexts: phySerIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfTable.setDescription('A list of interface entries. The number entries is given by the value of phySerIfNumber.')
phySerIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 4, 2, 1), ).setIndexNames((0, "RETIX-MIB", "phySerIfIndex"))
if mibBuilder.loadTexts: phySerIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfEntry.setDescription('An interface entry containing the objects pertinent to the phySer interface.')
phySerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySerIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfIndex.setDescription("The interface on which this entry's equivalence is effective.")
phySerIfInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("x21dte", 1), ("x21dce", 2), ("rs449", 3), ("g703", 4), ("v35", 5), ("v35btb", 6), ("rs232", 7), ("t1", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfInterfaceType.setDescription('Each of the values above indicates a particular personality module and hence the physical interface present. It is only possible to modify certain values of this variable, as follows: The value x21dte(1) may be modified to x21dce(2), and vice versa. The value v35(5) may be modified to v35btb(6), and vice versa. The changes will occur after the next link reset.')
phySerIfMeasuredSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySerIfMeasuredSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfMeasuredSpeed.setDescription('This parameter is the value of the measured channel speed in bits per second.')
phySerIfIsSpeedsettable = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySerIfIsSpeedsettable.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfIsSpeedsettable.setDescription('This parameter indicates whether the speed is settable or not for the particular personality module. This parameter does not guarantee that this will be the alue of the clock used over the serial link.')
phySerIfPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 9600, 19200, 24000, 32000, 48000, 64000, 256000, 512000, 1024000, 2048000))).clone(namedValues=NamedValues(("b1200", 1200), ("b2400", 2400), ("b4800", 4800), ("b9600", 9600), ("b19200", 19200), ("b24000", 24000), ("b32000", 32000), ("b48000", 48000), ("b64000", 64000), ("b256000", 256000), ("b512000", 512000), ("b1024000", 1024000), ("b2048000", 2048000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfPortSpeed.setDescription('The port speed is the value of the personality module sourced clock. It may be accessed if the value of isSpeedSettable is 1. In many cases a special cable is needed for this parameter to affect station operation - see product specifications for details. For the RS232 personality module the port speed can be set to any of the values 2400 through 48000 listed above. For all the other personality modules for which port speed is a settable parameter, the values 19600 and 24000 are invalid. These modules can assume any of the other speeds, dependent upon the product type - see product specifications for details. When a change has been made to this object, the new value will become effective after the next link reset.')
phySerIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySerIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfTransitDelay.setDescription("This parameter indicates the time taken for a frame to traverse the phySer link between the local and remote station. Its value is automatically determined by the station's software.")
phySerIfT1clockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfT1clockSource.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfT1clockSource.setDescription('This parameter indicates from where the clock is being derived. It can have the following values: clockFromData(0), internalSource (1), externalSource(2). If its value is clockFromData(0) then the clock signal comes from the data in the frame being received, if it is internalSource(1) then the clock is derived from an internal source and if its value is externalSource(2) the clock source is external. This parameter is only relevant for the T1 personality module. When a change has been made to this object, the new value will become effective after the next link reset.')
phySerIfT1SlotLvalue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfT1SlotLvalue.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfT1SlotLvalue.setDescription('This is the value of the lower time slot chosen withing a frame of the 1.544MHz T1 service. This parameter is only relevant for the T1 personality module. When a change has been made to this object, the new value will become effective after the next link reset.')
phySerIfT1SlotHvalue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfT1SlotHvalue.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfT1SlotHvalue.setDescription('This is the alue of the higher time slot chosen within a frame of the 1.544MHz T1 service. This parameter is only relevant for the T1 personality module. When a change has been made to this object the new value, will become effective after the next link reset.')
phySerIfT1dRatePerChan = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfT1dRatePerChan.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfT1dRatePerChan.setDescription('This object can have either of two values depending on the data rate required. If its value is 0 a data rate of 64k is provided, if its value is 4 then the data rate provided is 56k. This parameter is only relevant for the T1 personality module. When a change has been made to this object, the new value will become effective after the next link reset.')
phySerIfT1frameAndCode = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phySerIfT1frameAndCode.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfT1frameAndCode.setDescription('The values for this parameter represent the encoding on the 1.544MHz T1 service. It has the following values: fcD4andB8zs(0), fcD4Only(1), fcEsfAndB8zs(2), fcEsfOnly (3).')
phySerIfPartnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 4, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phySerIfPartnerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: phySerIfPartnerAddress.setDescription('The mac address of the remote station to which this particular serial link is connected.')
mlinkNumber = MibScalar((1, 3, 6, 1, 4, 1, 72, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkNumber.setDescription('The number of multilink interfaces, (regardless of their current state) present on this system.')
mlinkTable = MibTable((1, 3, 6, 1, 4, 1, 72, 5, 2), )
if mibBuilder.loadTexts: mlinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkTable.setDescription('A list of multilink entries. The number of entries is given by the value of mlinkNumber.')
mlinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 5, 2, 1), ).setIndexNames((0, "RETIX-MIB", "mlinkIndex"))
if mibBuilder.loadTexts: mlinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkEntry.setDescription('An interface entry containing objects at the multilink layer for a particular interface.')
mlinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkIndex.setDescription('This value reports the particular instance of multi-link being referenced.')
mlinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkState.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkState.setDescription('This parameter indicates the current state of the multilink connection. It can take on any of the folowing values: negotiating (0), notInUse(1), inUseActive(2), inUseInactive(3).')
mlinkSendSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkSendSeq.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkSendSeq.setDescription('This parameter represents the sequence number of the next-in-sequence multilink frame to be assigned to an SLP.')
mlinkRcvSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkRcvSeq.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkRcvSeq.setDescription('This parameter represents the sequence number of the next-in-sequence multilink frame to be received.')
mlinkSendUpperEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkSendUpperEdge.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkSendUpperEdge.setDescription('This parameter is the sum of the alue of the last received acknowledgement and the value of the multilink window size.')
mlinkRcvUpperEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkRcvUpperEdge.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkRcvUpperEdge.setDescription('This parameter is the sum of the value of the sequence number sent in the last acknowledgement and the receive window size.')
mlinkLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlinkLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkLostFrames.setDescription('This parameter represents the number of multilink packets lost because the out of sequence queue was full or the time spent waiting for an out of sequencce frame (in order to re-establish the sequence) exceeded some implementation specific period. It is the count since the last statistics reset of station restart.')
deletedMlinkFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deletedMlinkFrames.setStatus('mandatory')
if mibBuilder.loadTexts: deletedMlinkFrames.setDescription('This is the number of multilink frames which have been deleted, because they arrived out of sequence and were outside of the multi-link window.')
expressQueueCurrentLength = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expressQueueCurrentLength.setStatus('mandatory')
if mibBuilder.loadTexts: expressQueueCurrentLength.setDescription('This is the number of items enqueued in the multilink express queue.')
expressQueueUpperLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expressQueueUpperLimit.setStatus('mandatory')
if mibBuilder.loadTexts: expressQueueUpperLimit.setDescription('This is the upper limit of the enqueued information specific to the multilink express queue.')
hiPriQueueCurrentLength = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hiPriQueueCurrentLength.setStatus('mandatory')
if mibBuilder.loadTexts: hiPriQueueCurrentLength.setDescription('This is the number of items enqueued in the multilink high priority queue.')
hiPriQueueUpperLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hiPriQueueUpperLimit.setStatus('mandatory')
if mibBuilder.loadTexts: hiPriQueueUpperLimit.setDescription('This is the upper limit of the enqueued information specific to the multilink high priority queue.')
loPriQueueCurrentLength = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loPriQueueCurrentLength.setStatus('mandatory')
if mibBuilder.loadTexts: loPriQueueCurrentLength.setDescription('This is the number of items enqueued in the multilink low priority queue.')
loPriQueueUpperLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 5, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loPriQueueUpperLimit.setStatus('mandatory')
if mibBuilder.loadTexts: loPriQueueUpperLimit.setDescription('This is the upper limit of the enqueued information specific to the multilink low priority queue.')
mlinkWindow = MibScalar((1, 3, 6, 1, 4, 1, 72, 5, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mlinkWindow.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkWindow.setDescription('The Multilink window size parameter defines the number of sequentially numbered multilink frames that the DCE or DTE may transfer to its slp beyond the lowest numbered multilink frame which has not yet been acknowledged. This parameter is not instaced; it affects all instances of multilink.')
mlinkRxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 72, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mlinkRxTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mlinkRxTimeout.setDescription('The time, in 50ms units, after which the multilink resets due to a receive sequence error. This parameter is not instanced; it affects all instances of multilink.')
lanInterfaceType = MibScalar((1, 3, 6, 1, 4, 1, 72, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tenBase5", 1), ("oneBase5", 2), ("tenBase2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: lanInterfaceType.setDescription('This parameter indicates the physical medium which comprises the LAN.')
portNumber = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portNumber.setDescription('The number of ports supported by the bridging function in this station.')
bridgeStatsTable = MibTable((1, 3, 6, 1, 4, 1, 72, 7, 2), )
if mibBuilder.loadTexts: bridgeStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeStatsTable.setDescription('A list of bridge statistics entries. The number of entries is given by the value of bridgeNumber. This table is only valid for the LAN ports.')
bridgeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 7, 2, 1), ).setIndexNames((0, "RETIX-MIB", "bridgeStatsIndex"))
if mibBuilder.loadTexts: bridgeStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeStatsEntry.setDescription('A bridge statisticcs entry containing objects relevant to the bridging function.')
bridgeStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeStatsIndex.setDescription('A unique value for each bridge statistics instance.')
averageForwardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: averageForwardedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: averageForwardedFrames.setDescription('This reports the average number of frames per second accepted from the LAN for forwarding to the serial ports over the sampling period.')
maxForwardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxForwardedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: maxForwardedFrames.setDescription("This is the highest value of 'averageForwarded' recorded since the previous station or statistics reset.")
averageRejectedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: averageRejectedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: averageRejectedFrames.setDescription('This reports the average number of frames per second that have failed the filtering criterion for forwarding to the serial ports over the previous sampling period.')
maxRejectedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxRejectedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: maxRejectedFrames.setDescription("This parameter is a count of the highest value of 'averageRejected' recorded since the previous station or statistics reset.")
lanAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanAccepts.setStatus('mandatory')
if mibBuilder.loadTexts: lanAccepts.setDescription('This variable reports the total number of frames that have been accepted from the LAN for forwarding over the serial links since the last station or statistics reset.')
lanRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanRejects.setStatus('mandatory')
if mibBuilder.loadTexts: lanRejects.setDescription('This reports the total number of frames that have failed the filtering criterion for forwarding to the serial ports since the last station or statistics reset.')
deletedLanFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deletedLanFrames.setStatus('mandatory')
if mibBuilder.loadTexts: deletedLanFrames.setDescription('The number of LAN frames which have been deleted, due to an internal lack of resource error, since the last station restart or the last statistics reset.')
stpTable = MibTable((1, 3, 6, 1, 4, 1, 72, 7, 3), )
if mibBuilder.loadTexts: stpTable.setStatus('mandatory')
if mibBuilder.loadTexts: stpTable.setDescription('A list of stp entries. The number of entries is given by the value of bridgeNumber')
stpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 7, 3, 1), ).setIndexNames((0, "RETIX-MIB", "stpIndex"))
if mibBuilder.loadTexts: stpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stpEntry.setDescription('An entry containing objects relevant to the spanning tree algorithm')
stpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stpIndex.setDescription("The interface on which this entry's equivalence is effective.")
pathCostMode = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pathCostMode.setStatus('mandatory')
if mibBuilder.loadTexts: pathCostMode.setDescription('This variable controls the mode of determining the path cost for the port. If set to 0, the path cost is determined automatically by the station, if set to 1, it is configured by the manager.')
pathCostAutoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathCostAutoValue.setStatus('mandatory')
if mibBuilder.loadTexts: pathCostAutoValue.setDescription('This is the value of path cost assigned to the port automatically by the station.')
pathCostManualValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pathCostManualValue.setStatus('mandatory')
if mibBuilder.loadTexts: pathCostManualValue.setDescription('This is the value of path cost assigned to the port by the manager.')
portSpatState = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSpatState.setStatus('mandatory')
if mibBuilder.loadTexts: portSpatState.setDescription('This parameter indicates the spanning tree state of a particular port. It may return one of the following values: disabled (-1), blocking(0), listening(1), learning(2) or forwarding(3).')
portPriorityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPriorityMode.setStatus('mandatory')
if mibBuilder.loadTexts: portPriorityMode.setDescription('This variable controls the mode of determining the priority for the port. If set to 0, the priority is determined automatically by the station, if set to 1, it is configured by the manager.')
portPriorityAutoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPriorityAutoValue.setStatus('mandatory')
if mibBuilder.loadTexts: portPriorityAutoValue.setDescription('This is the value of priority assigned to the port automatically by the station.')
portPriorityManualValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPriorityManualValue.setStatus('mandatory')
if mibBuilder.loadTexts: portPriorityManualValue.setDescription('This is the value of priority assigned to the port by the manager.')
spanningTree = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spanningTree.setStatus('mandatory')
if mibBuilder.loadTexts: spanningTree.setDescription('This object describes whether or not the spanning tree protocol is enabled on this station. It can take on the following values: disabled (0) enabled (1).')
spatPriority = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spatPriority.setStatus('mandatory')
if mibBuilder.loadTexts: spatPriority.setDescription("Each station has a priority, used by the 'spanning Tree' protocol in determining the root bridge of a spanning tree network. The lower the value, which can range between the values 0 and 65535, the higher the priority.")
spatHelloTimer = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spatHelloTimer.setStatus('mandatory')
if mibBuilder.loadTexts: spatHelloTimer.setDescription('This is the period of time, in seconds, between the transmission of subsequent configuration BPDUs, used by the spanning tree algorithm.')
spatResetTimer = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spatResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: spatResetTimer.setDescription("The length of time, in seconds, after a serial link reset, for which the corresponding serial port's path cost is forced to its maximum value.")
spatVersion = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 8))).clone(namedValues=NamedValues(("revisionC", 3), ("revision8", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spatVersion.setStatus('mandatory')
if mibBuilder.loadTexts: spatVersion.setDescription('This variable determines the version of the spanning tree alogrithm implemented in the station.')
spanningMcastAddr = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spanningMcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: spanningMcastAddr.setDescription('This is the multicast address of the frames used by the spanning tree protocol. The multicast address is in hexadecimal form, in network byte order.')
operatingMode = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: operatingMode.setStatus('mandatory')
if mibBuilder.loadTexts: operatingMode.setDescription('This parameter determines whether the bridge will forward frames based only on the static addresses in the filtering database stored in its preconfigured table, if its value is proconfigured(1), or use its learning algorithm if its value is learning(0).')
preconfSourceFilter = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: preconfSourceFilter.setStatus('mandatory')
if mibBuilder.loadTexts: preconfSourceFilter.setDescription('This parameter determines whether the bridge will filter on destination address alone, indicated by a value of disabled(0), or destination and source addresses, indicated by a value of enabled (1).')
typeFilter = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: typeFilter.setStatus('mandatory')
if mibBuilder.loadTexts: typeFilter.setDescription('This parmaeter is used to enabld or disable frame type filtering. To enable set to a vaue of enabled(1), to disable set to a value of disabled(0).')
typePrioritisation = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: typePrioritisation.setStatus('mandatory')
if mibBuilder.loadTexts: typePrioritisation.setDescription('This parameter is used to enable or disable the prioritization of traffic destined for a remote LAN, dependent upon the type field of the frame. To enable type prioritization set this object to a value od enabled(1), a value of disabled(0) disables this action.')
dynamicLearningInLM = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dynamicLearningInLM.setStatus('mandatory')
if mibBuilder.loadTexts: dynamicLearningInLM.setDescription("This parameter is used to enable or disable dynamic learning when the station is configured to be in 'Learning' mode. A value of enabled(1) enabled this feature whilst a value of disabled(0) disables it.")
forgetAddressTimer = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(24, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: forgetAddressTimer.setStatus('mandatory')
if mibBuilder.loadTexts: forgetAddressTimer.setDescription("This is the time, in 5 second units, after which, if an address has not been seen on the local LAN, it is 'forgotten' from the learning address table.")
deleteAddressTimer = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deleteAddressTimer.setStatus('mandatory')
if mibBuilder.loadTexts: deleteAddressTimer.setDescription("This is the time, in 5 second units, after which, if an address has not been seen on the local LAN, it is 'deleted' from the learning address table.")
multicastDisposition = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multicastDisposition.setStatus('mandatory')
if mibBuilder.loadTexts: multicastDisposition.setDescription('This parameter determines the actions of the station upon receiving a multicast frame, when the station is set to preconfigured mode. If it is set to 1, multicasts are forwarded unconditionally to the serial link. If it is set to 0, they are handled like single cast addresses, being forwarded only if the multicast in question is present in the filtering database with the apropriate disposition.')
filterMatches = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterMatches.setStatus('mandatory')
if mibBuilder.loadTexts: filterMatches.setDescription('This parameter determines the action of the station when filtering on frame type. If it is set to 0, the frame is discarded if the type mateches, and forwarded if it does not. If it is set to 1, the frame is forwarded if it matches, and discarded if it does not.')
ieeeFormatFilter = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieeeFormatFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeFormatFilter.setDescription('This parameter determines whether IEEE802.3 frames will be forwarded or discarded when type filtering is being performed and a match found. To enabled this type of filtering set this object to a value of enabled(1), to disable set to a value of disabled (0).')
priorityMatches = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: priorityMatches.setStatus('mandatory')
if mibBuilder.loadTexts: priorityMatches.setDescription('This parameter defines the priority assigned to a frame if it is being forwarded after type matching. A value of high(0) is used to assign a high priority to the frame whilst a value of low(1) assigns a low priority.')
ieeeFormatPriority = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieeeFormatPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ieeeFormatPriority.setDescription('This parameter defines the priority assigned to an IEEE802.3 frame if it is being forwarded after type matching. A value of high(0) indicated high priority whilst a value of low(1) indicates a low priority.')
averagePeriod = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: averagePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: averagePeriod.setDescription('This is the averaging period over which the statistics in the BridgeStatsTable get updated.')
triangulation = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: triangulation.setStatus('mandatory')
if mibBuilder.loadTexts: triangulation.setDescription('To enable triangulation this object must be set to a value of enabled(1). To disable this feature set to a value of disabled (0).')
adaptiveRouting = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveRouting.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveRouting.setDescription('This parameter is used to enable, by setting this object to a value of enabled(1), or disable, set to a value of disabled(0), the adaptive routing feature. Adaptive routing can only be enabled if the spanningTree {bridge 4} has a value of enabled(1). ')
adaptiveMcastAddr = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adaptiveMcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: adaptiveMcastAddr.setDescription('This is the multicast address of the frames used by the adaptive routing protocol. The multicast address is in hexadecimal form, in network byte order.')
arAddressInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 7, 26))
standbyRemote = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 26, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: standbyRemote.setStatus('mandatory')
if mibBuilder.loadTexts: standbyRemote.setDescription('This object reports the total number of Adaptive Routing Destination Routes.')
standbyLocal = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 26, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: standbyLocal.setStatus('mandatory')
if mibBuilder.loadTexts: standbyLocal.setDescription('This object reports the total number of Adaptive Routing Source Routes.')
activeRemote = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 26, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeRemote.setStatus('mandatory')
if mibBuilder.loadTexts: activeRemote.setDescription('This object reports the total number of Adaptive Routing Remote Addresses.')
activeLocal = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 26, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeLocal.setStatus('mandatory')
if mibBuilder.loadTexts: activeLocal.setDescription('This object reports the total number of Adaptive Routing Learned Addresses.')
maxSerialLoading = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxSerialLoading.setStatus('mandatory')
if mibBuilder.loadTexts: maxSerialLoading.setDescription('This object is used by the Adaptive Routing protocol. If the loading of a serial link exceeds this value, then any frames enqueued for this link by Adaptive Routing will be removed from the queue and enqueued on the other serial link. The value of this object is a measure of the percentage loading of the line.')
serialLoadPeriod = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40, 50, 60))).clone(namedValues=NamedValues(("ten", 10), ("twenty", 20), ("thirty", 30), ("forty", 40), ("fifty", 50), ("sixty", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialLoadPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: serialLoadPeriod.setDescription('This is the sampling period over which the serial links loading is measured, in seconds.')
serialLoading = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialLoading.setStatus('mandatory')
if mibBuilder.loadTexts: serialLoading.setDescription('Each instance of this object gives the percentage loading on a particular serial line. The instances are indexed by the value of ifIndex.')
filteringDataBaseTable = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 7, 30))
filteringDbTable = MibTable((1, 3, 6, 1, 4, 1, 72, 7, 30, 1), )
if mibBuilder.loadTexts: filteringDbTable.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbTable.setDescription('A list of filtering data base entries.')
filteringDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 7, 30, 1, 1), ).setIndexNames((0, "RETIX-MIB", "filteringDbMacAddress"))
if mibBuilder.loadTexts: filteringDbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbEntry.setDescription('This OCTET STRING contains one entry from the table. Each entry consists of a MAC address, filter disposition, filter status and type.')
filteringDbMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 30, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filteringDbMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbMacAddress.setDescription('This OCTET STRING contains the MAC address in hexadecimal from, in network byte order.')
filteringDbDisposition = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 30, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filteringDbDisposition.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbDisposition.setDescription('This is the disposition applied to the Mac Address. It can have any of the following values: discard (0), lan (1), channel1 (2), channel2 (4) or flood (7).')
filteringDbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 30, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filteringDbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbStatus.setDescription('This is the status of the Mac Address. Only static may be configured from SNMP, thus a SetRequest on this object with any a value other than 3 (bit 0 and 1 both set) will fail. The status is a 8 bit field. The lower 2 bits (bits 0 and 1) can have the following values: if neither bit set (value of 0), this indicates a free address. A value of 1 is used for learnt addresses, a value of 2 for un-learnt addresses and a value of 3 for static addresses. If bit 2 is set then the MAC address is a multicast address, i.e. this object would have a value of 4. The upper 4 bits of the status field are used to represent different adaptive routing address types. if the upper 4 bits have a value of 2 this indicates an Adaptive Routing (AR) source address, a value of 4 indicates an AR destination address and a value of 8 an AR remote address. These values are not mutually exclusive which is why they are not listed in the enumeration. The byte can have different combinations of the above settings.')
filteringDbType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 30, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filteringDbType.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbType.setDescription('For a Get or GetNext, a value of valid(1) is always returned. For a Set, if the field is set to a value of valid(1) then the entry is added to the table, if the value is invalue(2) then the entry is deleted.')
filteringDbAction = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 30, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clearTable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filteringDbAction.setStatus('mandatory')
if mibBuilder.loadTexts: filteringDbAction.setDescription('This object is used to clear the Filtering Database Table of all static entries. Other entries are not affected. A value of noAction(1) is always returned when a GET is performed upon the object.')
priorityTable = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 7, 31))
prioritySubTable = MibTable((1, 3, 6, 1, 4, 1, 72, 7, 31, 1), )
if mibBuilder.loadTexts: prioritySubTable.setStatus('mandatory')
if mibBuilder.loadTexts: prioritySubTable.setDescription('A list of priority table entries.')
priorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 7, 31, 1, 1), ).setIndexNames((0, "RETIX-MIB", "priorityTableEntryValue"))
if mibBuilder.loadTexts: priorityTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: priorityTableEntry.setDescription('This sequence defines one entry in the priority table. There is a maximum of 8 instances of this sequence.')
priorityTableEntryValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 31, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: priorityTableEntryValue.setStatus('mandatory')
if mibBuilder.loadTexts: priorityTableEntryValue.setDescription('The priority being added to, deleted or read from the table.')
priorityTableEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 31, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: priorityTableEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: priorityTableEntryType.setDescription('This parameter determines whether an object is being added to or deleted from the table. A value os valid(1) is used to add entries while invalid(2) is used an entry is to be deleted from the table.')
priorityTableAction = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 31, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clearTable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: priorityTableAction.setStatus('mandatory')
if mibBuilder.loadTexts: priorityTableAction.setDescription('This object is used to clear the priorityTable. A value of noAction(1) is always returned to a GetRequest for this object. A Set with a value of noAction(1) has no affect.')
priorityPage = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 31, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: priorityPage.setStatus('optional')
if mibBuilder.loadTexts: priorityPage.setDescription('This OCTET STRING contains all of the active entries in the priority table. Each entry consists of two bytes, the first byte of each entry being the most significant byte of the entry.')
filterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 7, 32))
filterSubTable = MibTable((1, 3, 6, 1, 4, 1, 72, 7, 32, 1), )
if mibBuilder.loadTexts: filterSubTable.setStatus('mandatory')
if mibBuilder.loadTexts: filterSubTable.setDescription('This is a list of entries in the filter table.')
filterTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 7, 32, 1, 1), ).setIndexNames((0, "RETIX-MIB", "filterTableEntryValue"))
if mibBuilder.loadTexts: filterTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filterTableEntry.setDescription('This sequence defines one entry in the filter table. There is a maximum of 8 instances of this object.')
filterTableEntryValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 32, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterTableEntryValue.setStatus('mandatory')
if mibBuilder.loadTexts: filterTableEntryValue.setDescription('This is the value of a filter to be added to, deleted from or read from the filter table.')
filterTableEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 7, 32, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterTableEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: filterTableEntryType.setDescription('This parameter is used to indicate if a filter is to be added to or deleted from the table. A value of valid(1) causes the filter to be added. A value of invalid(2) causes it to be deleted. For a Get, this value is always returned as valid(1).')
filterTableAction = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 32, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("clearTable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterTableAction.setStatus('mandatory')
if mibBuilder.loadTexts: filterTableAction.setDescription('This object is used to clear the filter Table of its static entries, all others are not affected. Only two values are valid to use with this object. A value of noAction(1) is always returned when a GET is performed upon the object. To clear the table of static entries, a value of 2 must be used in the SET. A SET with a value of 1 has no effect.')
filterPage = MibScalar((1, 3, 6, 1, 4, 1, 72, 7, 32, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPage.setStatus('mandatory')
if mibBuilder.loadTexts: filterPage.setDescription('This OCTET STRING contains all of the active entries in the filter table. Each entry consists of two bytes, the first byte of each entry being the most significant byte of that entry.')
ipRSTable = MibTable((1, 3, 6, 1, 4, 1, 72, 10, 1), )
if mibBuilder.loadTexts: ipRSTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipRSTable.setDescription("A list of vairables associated with the router's status and its IP statistics.")
ipRSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 10, 1, 1), ).setIndexNames((0, "RETIX-MIB", "ipRSIndex"))
if mibBuilder.loadTexts: ipRSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipRSEntry.setDescription("This table contains objects which give information abouti the router's STATUS and its IP statistics.")
ipRSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipRSIndex.setDescription("The interface on which this entry's equivalence is effective. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.")
gwProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8))).clone(namedValues=NamedValues(("none", 1), ("rip", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gwProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: gwProtocol.setDescription('The protocols which are in use by the IP Routing element to exchange routing information. This field has two values rip(8) and none (1).')
ifStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ifStatus.setDescription('This parameter represents the status of the interface. For the LAN interface the values possible are rarpFail (2), inactive (0) and active (1). For the serial interfaces there are two possible values, inactive (0) and active (1).')
receivedTotalDgms = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receivedTotalDgms.setStatus('mandatory')
if mibBuilder.loadTexts: receivedTotalDgms.setDescription('This is a count of the total number of IP Datagrams received over this interface.')
transmittedTotalDgms = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmittedTotalDgms.setStatus('mandatory')
if mibBuilder.loadTexts: transmittedTotalDgms.setDescription('This is a count of the total number of IP Datagrams transmitted over this interface.')
outDiscardsTotalDgms = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outDiscardsTotalDgms.setStatus('mandatory')
if mibBuilder.loadTexts: outDiscardsTotalDgms.setDescription('This is a count of the number of IP Datagrams discarded due to exceeding the transmit queue length of this interface.')
noRouteTotalDgms = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 10, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noRouteTotalDgms.setStatus('mandatory')
if mibBuilder.loadTexts: noRouteTotalDgms.setDescription('This is a count of the number of frames which were received on this interface but discarded because no route could be found.')
icmpRSTable = MibIdentifier((1, 3, 6, 1, 4, 1, 72, 10, 2))
destUnreachLastRx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: destUnreachLastRx.setStatus('mandatory')
if mibBuilder.loadTexts: destUnreachLastRx.setDescription('The last time an ICMP Destination Unreachable message was received. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
destUnreachLastTx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: destUnreachLastTx.setStatus('mandatory')
if mibBuilder.loadTexts: destUnreachLastTx.setDescription('The last time an ICMP Destination Unreachable message was sent. The format of the returned Octet String is the same as that defined in setion b. of the definition of the stationTime (station.1) object.')
sourceQuenchLastRx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceQuenchLastRx.setStatus('mandatory')
if mibBuilder.loadTexts: sourceQuenchLastRx.setDescription('The last time an ICMP Source Quench message was received. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
sourceQuenchLastTx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceQuenchLastTx.setStatus('mandatory')
if mibBuilder.loadTexts: sourceQuenchLastTx.setDescription('The last time an ICMP Source Quench message was sent. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
redirectsLastRx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: redirectsLastRx.setStatus('mandatory')
if mibBuilder.loadTexts: redirectsLastRx.setDescription('The last time an ICMP Redirects message was received. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
redirectsLastTx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: redirectsLastTx.setStatus('mandatory')
if mibBuilder.loadTexts: redirectsLastTx.setDescription('The last time an ICMP Redirects message was sent. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
echoRequestsLastRx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoRequestsLastRx.setStatus('mandatory')
if mibBuilder.loadTexts: echoRequestsLastRx.setDescription('The last time an ICMP Echo request message was received. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
echoRequestsLastTx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoRequestsLastTx.setStatus('mandatory')
if mibBuilder.loadTexts: echoRequestsLastTx.setDescription('The last time an ICMP Echo request message was sent. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
timeExceededLastRx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeExceededLastRx.setStatus('mandatory')
if mibBuilder.loadTexts: timeExceededLastRx.setDescription('The last time an ICMP Time Exceeded message was received. The format of the returned Octet String is the same as that defined in section b. of the definition of the sationTime (station.1) object.')
timeExceededLastTx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeExceededLastTx.setStatus('mandatory')
if mibBuilder.loadTexts: timeExceededLastTx.setDescription('The last time an ICMP Time Exceeded message was sent. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
paramProbLastRx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: paramProbLastRx.setStatus('mandatory')
if mibBuilder.loadTexts: paramProbLastRx.setDescription('The last time an ICMP Param Problem message was received. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
paramProbLastTx = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 2, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: paramProbLastTx.setStatus('mandatory')
if mibBuilder.loadTexts: paramProbLastTx.setDescription('The last time an ICMP Param Problem message was sent. The format of the returned Octet String is the same as that defined in section b. of the definition of the stationTime (station.1) object.')
ipRouting = MibScalar((1, 3, 6, 1, 4, 1, 72, 10, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouting.setStatus('mandatory')
if mibBuilder.loadTexts: ipRouting.setDescription('This parameter is used to enable IP Routing, it also indicates the current state of the stations IP Routing capability. A value of enabled(1) enables IP Routing whilst a value of disabled(0) disables it.')
bootpRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: bootpRetryCount.setDescription('The number of times a Bootp Request will be transmitted before the Bootp attempt is considered to have failed. If this parameter is set to 0, Bootp is skipped and an immediate TFTP download attempted.')
downloadRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: downloadRetryCount.setDescription('The number of times the complete Bootp/TFTP download cycle is attempted before the download attempt is considered to have failed.')
downloadFilename = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: downloadFilename.setDescription("This character string is inserted in the 'boot file name' field of the Bootp Request; its semantics is determined by the Boot Server. If Bootp is skipped and an immediate TFTP download attempted, this parameter is used by TFTP as the name of the file to be downloaded.")
bootserverIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootserverIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bootserverIpAddress.setDescription('If this address is null (0.0.0.0), the Boot Request is sent to the IP broadcast address as determined by ipAdEntBcastAddr. Otherwise, it is sent to this address. It is known that certain bootserver implementations do not respond to the standard limited broadcast, hence the need for this parameter.')
loadserverIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadserverIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: loadserverIpAddress.setDescription('If this address is null (0.0.0.0), TFTP will request a download from the server address returned in the Bootp Response. Otherwise, it will use this address.')
uniqueBroadcastAddress = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uniqueBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: uniqueBroadcastAddress.setDescription('A unique broadcast address specified by the user which does not conform to the standard ip broadcast address format. If the user specifies a unique broadcast address, this will take precedence over the standard IP broadcast address.')
tftpRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: tftpRetryCount.setDescription('The number of PDU will be retransmitted during a TFTP transfer before declaring the transfer to have failed.')
tftpRetryPeriod = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpRetryPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: tftpRetryPeriod.setDescription('The time in units of 50ms that TFTP will wait for the next requested block before initiating error recovery.')
initiateBootpDll = MibScalar((1, 3, 6, 1, 4, 1, 72, 11, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("initiateBoot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: initiateBootpDll.setStatus('mandatory')
if mibBuilder.loadTexts: initiateBootpDll.setDescription('This parameter is used to initiate a bootp downline load from a remote server. A value of noAction(1) is always returned when a Get Request is performed on this object. A Set Request with a value of initiateBoot(2) causes the bootp download operation to be initiated.')
boothelperEnabled = MibScalar((1, 3, 6, 1, 4, 1, 72, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boothelperEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: boothelperEnabled.setDescription('This parameter is used to enable or disable the boot helper facility. A value of enabled(1) enabled this facility whilst a value of disabled(0) disables it.')
boothelperHopsLimit = MibScalar((1, 3, 6, 1, 4, 1, 72, 12, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boothelperHopsLimit.setStatus('mandatory')
if mibBuilder.loadTexts: boothelperHopsLimit.setDescription('This object repesents the limit on the distance that a boot request is forwarded. It specifies the maximum number of times that a boot request may have been forwarded by other boothelpers and still be forwarded by this helper. A value of 0 means that no boot request shall be forwarded.')
boothelperForwardingAddress = MibScalar((1, 3, 6, 1, 4, 1, 72, 12, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boothelperForwardingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: boothelperForwardingAddress.setDescription('This is the IpAddress to which the boot helper will forward a boot request.')
ipxRouting = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxRouting.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRouting.setDescription('This object is used to enable and disable IPX routing. It indicates whether the unit is functioning as an IPX Router. The default value is disabled (0). A value of enabled(1) is used to enable IPX Routing.')
ipxIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfNumber.setDescription('This is the number of interfaces on which you can send and received ipx datagrams.')
ipxIfTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 1, 3), )
if mibBuilder.loadTexts: ipxIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfTable.setDescription('This is a list of parameters associated with the IPX interfaces.')
ipxIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 1, 3, 1), ).setIndexNames((0, "RETIX-MIB", "ipxIfIndex"))
if mibBuilder.loadTexts: ipxIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfEntry.setDescription("This table contains objects which give information about the IPX Router's interfaces.")
ipxIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfIndex.setDescription("The interface on which this entry's equivalence is effective.")
ipxIfNwkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxIfNwkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfNwkNumber.setDescription('This object is the ascii representation of the network number which, when combined with the Host address, makes up the IPX address of this particular interface. It can be up to 8 characters long.')
ipxIfIPXAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(26, 26)).setFixedLength(26)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxIfIPXAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfIPXAddress.setDescription('This is an octet string which specifies the IPX address of a particular interfae, in ascii format. The format of the address is as follows: xxxxxxxx:yy.yy.yy.yy.yy.yy Where xxxxxxxx represents the network number portion of the address, and may be up to 8 chars long, and yy.yy.yy.yy.yy.yy represents the host address of the device and is always 17 chars long (including decimal points). The entire string including the colon and decimal points, can be up to 26 characters long.')
ipxIfEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxIfEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfEncapsulation.setDescription('This parameter indictes the encapsulation which is in use on a particular interface. It can have any one of the following values: ieee8023 (0), ethernet (1), llc (2), snap (3), dummy1 (4), dummy2 (5) or invalid (6). If the mlinkChan48Interop {mlinkEntry 15 } parameter has a value of disabled(0) for a multilink channel then the value of this parameter will be invalid(6). The values dummy1(4) and dummy2(5) are reserved for future expansion and cannot be used in a set operation on this parameter, they will not be returned in response to a Get Request either.')
ipxIfDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxIfDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ipxIfDelay.setDescription('This object indicates the delay associated with the network on the interface identified by the instance number used to instance this object. The delay is an estimate of the time take by a 576 byte IPX packet to traverse the network. The time is measured in ticks, the units of which are 1/18.2 seconds. The smallest value of ipxIfDelay is 1 tick or 1/18.2 seconds.')
ipxRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 1, 4), )
if mibBuilder.loadTexts: ipxRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRoutingTable.setDescription('This is a list of the entries in the Routing Information Table.')
ipxRITEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1), ).setIndexNames((0, "RETIX-MIB", "ipxRITDestNwkNumber"))
if mibBuilder.loadTexts: ipxRITEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITEntry.setDescription('This table contains the entries in the IPX Routing Information Table.')
ipxRITDestNwkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRITDestNwkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITDestNwkNumber.setDescription('This string contains the IPX Network number. The address contained in the returned string is in hexadecimal form. If the network number is not a full 4 bytes ling, then it is zero-filled eg, a network Number, 0x234fd will appear as 0x000234fd in this string.')
ipxRITGwyHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRITGwyHostAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITGwyHostAddress.setDescription('This is the Host Address of the gateway to the network specified by the corresponding ipxRITNwkNumber.')
ipxRITHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRITHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITHopCount.setDescription('This is the hop count to reach the specified network, it has a range of 0 to 15.')
ipxRITDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRITDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITDelay.setDescription('This is the estimated delay to reach the specified network.')
ipxRITInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRITInterface.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITInterface.setDescription('This is the interface through which the IPX datagram is routed to the gateway identified by the corresponding entry for ipxRITGwyHostAddress {ipxRITEntry 2}.')
ipxRITDirectConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxRITDirectConnect.setStatus('mandatory')
if mibBuilder.loadTexts: ipxRITDirectConnect.setDescription('')
ipxSAPBinderyTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 1, 5), )
if mibBuilder.loadTexts: ipxSAPBinderyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderyTable.setDescription('The table of SAP Bindaries.')
ipxSAPBinderyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 1, 5, 1), ).setIndexNames((0, "RETIX-MIB", "ipxSAPBinderyType"), (0, "RETIX-MIB", "ipxSAPBinderyServerIPXAddress"))
if mibBuilder.loadTexts: ipxSAPBinderyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderyEntry.setDescription('This is a list of entries in the ipxSAPBinderyTable')
ipxSAPBinderyType = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 71, 65535))).clone(namedValues=NamedValues(("user", 1), ("userGroup", 2), ("printQueue", 3), ("fileServer", 4), ("jobServer", 5), ("gateway", 6), ("printServer", 7), ("archiveQueue", 8), ("archiveServer", 9), ("jobQueue", 10), ("administration", 11), ("remoteBridgeServer", 36), ("advertizingPrintServer", 71), ("wild", 65535)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSAPBinderyType.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderyType.setDescription('This is the type of the server whose IPX address is given by ipxSAPBinderyIPXAddress {ipxSAPBinderyEntry 2}. If a value of 0 is returned to a Get Request then this indicates an unknown server type.')
ipxSAPBinderyServerIPXAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(26, 26)).setFixedLength(26)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSAPBinderyServerIPXAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderyServerIPXAddress.setDescription('This is an octet string which specifies the IPX address of a particular interface, in ascii format. The format of the address is as follows: xxxxxxxx:yy.yy.yy.yy.yy.yy where xxxxxxxx represents the network number portion of the address, and may be up to 8 chars long, and yy.yy.yy.yy.yy.yy represents the host address of the device and is always 17 chars long (including decimal points). The entire string including the colon and decimal point, can be up to 26 characters long.')
ipxSAPBinderyServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSAPBinderyServerName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderyServerName.setDescription('This is the Name of the Server. It is a text string up to 48 characters long.')
ipxSAPBinderyHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSAPBinderyHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderyHopCount.setDescription('This is the hop count ot reach the specified server. This object can take on any value in the range 0 to 15.')
ipxSAPBinderySocket = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 1, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxSAPBinderySocket.setStatus('mandatory')
if mibBuilder.loadTexts: ipxSAPBinderySocket.setDescription('This number identifies the socket at which the server provides services.')
ipxReceivedDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxReceivedDgms.setStatus('mandatory')
if mibBuilder.loadTexts: ipxReceivedDgms.setDescription('This is a count of the total number of IPX datagrams which have been received on the interfaces.')
ipxTransmittedDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxTransmittedDgms.setStatus('mandatory')
if mibBuilder.loadTexts: ipxTransmittedDgms.setDescription('This parameter represents the total number of IPX datagrams which have been transmitted on the interfaces.')
ipxNotRoutedRxDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxNotRoutedRxDgms.setStatus('mandatory')
if mibBuilder.loadTexts: ipxNotRoutedRxDgms.setDescription('This parameter represents the total number of IPX datagrams which have been received on the interface and which have been discarded due to no route being found for them.')
ipxForwardedDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxForwardedDgms.setStatus('mandatory')
if mibBuilder.loadTexts: ipxForwardedDgms.setDescription('This parameter represents the total number of IPX datagrams which have been received on the interface and routed onwards.')
ipxInDelivers = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInDelivers.setDescription('This parameter represents the total number of IPX datagrams which have been received on the interfaces and delivered internally (routed inwards) to RIP or SAP.')
ipxInHdrErrors = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInHdrErrors.setDescription('This parameter represents a count of the total number of IPX datagrams which have been received on the interfaces and discarded due to having a bad checksum, a length error or hopCountExpiry.')
ipxAccessViolations = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAccessViolations.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAccessViolations.setDescription('This parameter represents a count of the total number of IPX datagrams which have been received on the interface and discarded due to an addess violation for the datagram.')
ipxInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxInDiscards.setDescription('This parameter represents a count of the total number of IPX datagrams which have been received on the interface and discarded because the internal queue is full.')
ipxOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOutDiscards.setDescription('This parameter represents a count of the total number of IPX datagrams which have been received on the interface and discarded because the transmit queue for this interface is full.')
ipxOtherDiscards = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxOtherDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxOtherDiscards.setDescription('This parameter represents a count of the total number of IPX datagrams which have been received on the interface and discarded because the interface does not have a configured IPX address or the datagram is addresses to an unsupported socket.')
dcntRouting = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntRouting.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRouting.setDescription('This parameter is used to enable or disable DECnet routing on this unit. A Set with a value of enabled(1) enabled the DECnet routing feature, whilst a Set with a value of disabled(0) disabled this fature.')
dcntIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfNumber.setDescription('This is the number of interfaces on which you can send and receive decnet frames.')
dcntIfTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 2, 3), )
if mibBuilder.loadTexts: dcntIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfTable.setDescription('This table holds a list of entries of interface-specific configurable data.')
dcntIfTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 2, 3, 1), ).setIndexNames((0, "RETIX-MIB", "dcntIfIndex"))
if mibBuilder.loadTexts: dcntIfTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfTableEntry.setDescription('A interface entry containing objects pertinent to eachs interface for which Decnet is enabled.')
dcntIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfIndex.setDescription('')
dcntIfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntIfCost.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfCost.setDescription('This is the path cost associated with this interface.')
dcntIfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntIfRtrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfRtrPriority.setDescription('This is the priority associated with this interface, it is used to determine the designated route. The interface with the highest priority is the designated route.')
dcntIfDesgntdRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntIfDesgntdRtr.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfDesgntdRtr.setDescription("This parameter indicates if this is the designated router on this interface. A value of no(0) indicates there isn't a designated router on this interface, whilst a value of yes(1) indicates that there is.")
dcntIfHelloTimerBCT3 = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntIfHelloTimerBCT3.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIfHelloTimerBCT3.setDescription('The maximum time period between two hello messages, transmitted consecutively.')
dcntRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 2, 4), )
if mibBuilder.loadTexts: dcntRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRoutingTable.setDescription('This is the routing table for the area to which this device belongs, There are a maximum of 1023 entries in this table.')
dcntRITEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 2, 4, 1), ).setIndexNames((0, "RETIX-MIB", "dcntRITDestNode"))
if mibBuilder.loadTexts: dcntRITEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRITEntry.setDescription("An entry specifies a particular node's routing information.")
dcntRITDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntRITDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRITDestNode.setDescription('This is the address id of the node which uniquely identify the node within a given area.')
dcntRITNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 4, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntRITNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRITNextHop.setDescription('This is the address of the next hop in the path.')
dcntRITCost = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntRITCost.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRITCost.setDescription('This is the path cost of this route.')
dcntRITHops = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntRITHops.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRITHops.setDescription('This is the number of hops that have to be traversed to get to the destination.')
dcntRITInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntRITInterface.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRITInterface.setDescription('This parameter identifies the interface on which messages for this route should be forwarded. It has the following values: 0 for Lan, 1 for channel 1 and 2 for channel 2.')
dcntAreaRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 2, 5), )
if mibBuilder.loadTexts: dcntAreaRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRoutingTable.setDescription('This is the Area routing table, used to route packets fromt the area in which the device resides to other Areas in the network. There are a maximum of 63 entries in this table.')
dcntAreaRITEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 2, 5, 1), ).setIndexNames((0, "RETIX-MIB", "dcntAreaRITDestArea"))
if mibBuilder.loadTexts: dcntAreaRITEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRITEntry.setDescription("An entry specifies a particular node's routing information.")
dcntAreaRITDestArea = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntAreaRITDestArea.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRITDestArea.setDescription('This is the area id of the node which uniquely identifies the area.')
dcntAreaRITNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 5, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntAreaRITNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRITNextHop.setDescription('This is the address of the next hop in the path.')
dcntAreaRITCost = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntAreaRITCost.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRITCost.setDescription('This is the path cost of this route.')
dcntAreaRITHops = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntAreaRITHops.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRITHops.setDescription('This is the number of hops between here and the destination.')
dcntAreaRITInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntAreaRITInterface.setStatus('mandatory')
if mibBuilder.loadTexts: dcntAreaRITInterface.setDescription('This parameter identifies the interface on which messages for this route should be forwarded. It can have the following values: 0 for the Lan interface, 1 for channel 1 and 2 for channel 2.')
dcntNodeAddress = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcntNodeAddress.setDescription('This is the Node address of the device. The format of this is as follows: xx.yyyy where xx is an ascii representation (range 0-9) of the area id, with a range 0 to 63, and yyyy is an ascii representation (range 0 to 9) of the address id, with a range 0 to 1023. The string can be a maximum length of seven octets, this includes the decimal point separating the two components. DECnet routing cannot be enabled until this object has been given a valid value. When DECnet routing is disabled this value can be set to a value of NULL. This parameter may be changed to another valid value at any time.')
dcntInterAreaMaxCost = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntInterAreaMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: dcntInterAreaMaxCost.setDescription('This is the maximum cost possible in a path to a reachable area, from the area in which this device is situated.')
dcntInterAreaMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntInterAreaMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: dcntInterAreaMaxHops.setDescription('The maximum number of Hops allowed in a path to another reachable area.')
dcntIntraAreaMaxCost = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntIntraAreaMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIntraAreaMaxCost.setDescription('The maximum cost possible in a path from the device to a reachable node within the same area.')
dcntIntraAreaMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntIntraAreaMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: dcntIntraAreaMaxHops.setDescription('This is the Maximum Hops allowed in a path from this device to a reachable node within the same area.')
dcntMaxVisits = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntMaxVisits.setStatus('mandatory')
if mibBuilder.loadTexts: dcntMaxVisits.setDescription('The maximum number of nodes which a data packet can traverse, before being discarded.')
dcntRtngMsgTimerBCT1 = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntRtngMsgTimerBCT1.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRtngMsgTimerBCT1.setDescription('This is the maximum time period between broadcasted routing messages on the Ethernet.')
dcntRateControlFreqTimerT2 = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcntRateControlFreqTimerT2.setStatus('mandatory')
if mibBuilder.loadTexts: dcntRateControlFreqTimerT2.setDescription('This is the rate control frequency timer.')
dcntReveivedDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntReveivedDgms.setStatus('mandatory')
if mibBuilder.loadTexts: dcntReveivedDgms.setDescription('This is a total count of all Decnet Datagrams received by the device on all interfaces. This includes data packets, hello messages and routing messages.')
dcntForwardedDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntForwardedDgms.setStatus('mandatory')
if mibBuilder.loadTexts: dcntForwardedDgms.setDescription('This is a count of all the data packets which have been forwarded by the device on all interfaces.')
dcntOutRequestedDgms = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntOutRequestedDgms.setStatus('mandatory')
if mibBuilder.loadTexts: dcntOutRequestedDgms.setDescription('This is a count of all Decnet hello and routing messages transmitted by the device on all interfaces.')
dcntInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dcntInDiscards.setDescription('This is a count of all Decnet packets which have been received, but discarded. These frames are discarded by the Decnet protocol layer.')
dcntOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dcntOutDiscards.setDescription('This is the total number of Decnet frames discarded due to lack of internal resources. These frames are discarded by the Decnet protocol layer.')
dcntNoRoutes = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: dcntNoRoutes.setDescription('This is the total number of packets for which no route could be found.')
dcntInHdrErrors = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 2, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcntInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dcntInHdrErrors.setDescription('This is the total number of packets found with an invalid header in the data packet.')
rmtLapbConfigTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 3, 1), )
if mibBuilder.loadTexts: rmtLapbConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbConfigTable.setDescription('A list of configurable LapbCT entries, one entry per interface.')
rmtLapbCTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1), ).setIndexNames((0, "RETIX-MIB", "rmtLapbCTIndex"))
if mibBuilder.loadTexts: rmtLapbCTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTEntry.setDescription('A list of configurable data, for each lapb interface.')
rmtLapbCTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbCTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTIndex.setDescription('This parameter defines the interface for which this entry is valid.')
rmtLapbCTLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTLinkAddr.setDescription('This parameter defines both the link level and packet level logical address. A value of dte(0) indicates DTE operation, whilst a value of dce(1) indicates DCE operation.')
rmtLapbCTExtSeqNumbering = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTExtSeqNumbering.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTExtSeqNumbering.setDescription('This parameter is used to enable/disabled use of extended frame sequence numbering. Modulo 128 numbering is used if this parameter is set to a value of enabled(1), whilst modulo 8 numbering is used if this object is set to a value of disabled(0).')
rmtLapbCTWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTWindow.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTWindow.setDescription('This parameter represents the maximum number of I-frames which can be transmitted before an acknowledgement is received. It can have any value between 1 and 127, for this value to be greater than 7, extended sequence numbering must be invoked. This is the value of k as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCILE VIII.3.')
rmtLapbCTModeT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTModeT1.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTModeT1.setDescription("If the value of this parameter is automaticT1(0) then the value of the T1 timer is determined automatically by the software. If the value of this object is manualT1(1) then the timer is settable by the manager. The value of T1 won't change until the next reset of the station or the next link reset.")
rmtLapbCTManualT1Value = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTManualT1Value.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTManualT1Value.setDescription('This object allows the manager to set the value of the T1 timer as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCICLE VIII.3. The settable range is 10 to 5000 which represents the timer value in milliseconds. This object maybe set at any time, but it is only used if the value of modeT1 is 1. This value will not become active until the next link or station reset.')
rmtLapbCTT3LinkIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTT3LinkIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTT3LinkIdleTimer.setDescription('This is the value of the T3 timer, which defines the maximum time which a link can remain in the idle condition before being identified as non-operational.')
rmtLapbCTN2RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTN2RetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTN2RetryCount.setDescription('This is the value of N2 as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCICLE VIII.3.')
rmtLapbCTLinkReset = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetLink", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTLinkReset.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTLinkReset.setDescription('This parameter causes a link reset. The link reset occurs after a pre-determined period of time which is implementation specific. Set Request with a value of resetLink(2) is used to cause the link reset. A value of noAction(1) will be returned when a Get Request is performed on this object.')
rmtLapbCTX25PortLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 9600, 19200, 32000, 48000, 64000))).clone(namedValues=NamedValues(("b1200", 1200), ("b2400", 2400), ("b4800", 4800), ("b9600", 9600), ("b19200", 19200), ("b32000", 32000), ("b48000", 48000), ("b64000", 64000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTX25PortLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTX25PortLineSpeed.setDescription('This object allows the user to set the linespeed for X25 operation.')
rmtLapbCTInitLinkConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("connect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmtLapbCTInitLinkConnect.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbCTInitLinkConnect.setDescription('This parameter causes a link connect to take place. A Set Request with a value of connect(2) is used to initiate a link connect. A value of noAction(1) is returned to returned when a Get Request is performed on this object.')
rmtLapbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 3, 2), )
if mibBuilder.loadTexts: rmtLapbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbStatsTable.setDescription('A list of LAPB interface entries.')
rmtLapbSTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1), ).setIndexNames((0, "RETIX-MIB", "rmtLapbSTIndex"))
if mibBuilder.loadTexts: rmtLapbSTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTEntry.setDescription('The LAPB table. An entry in this table is uniquely identified by the value of the rmtLapbSTIndex variable associated with the interface to which the statistics refer.')
rmtLapbSTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTIndex.setDescription("The interface on which this entry's equivalence is effective. This object identifies the same physical interface as identified by the phySerIfIndex.")
rmtLapbSTState = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTState.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTState.setDescription('This parameter indicates the current state of the LAPB link. inactive(0) indicates that LAPB initialization was unsuccessful. A value of active(1) indicates that LAPB init- ialization was successful. A value of unused(2) indicates that, in the case where there are two parallel links between bridges one of which is slower, the slower link has been tagged unused. This is done to concentrate transmissions on the faster link and thus avoid heavy re-ordering overhead due to frames arriving out of sequence. A value of tooFast(3) indicates that the clock on the received signal is too fast for the interface in question.')
rmtLapbSTAutoT1value = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTAutoT1value.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTAutoT1value.setDescription('This parameter is the value of the T1 timer as defined in the 1984 CCITT Recommendation X.25 VOLUME VIII - FASCICLE VIII.3 and is determined empirically by the software. It is the actual value of the timer in milliseconds.')
rmtLapbSTLastResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTLastResetTime.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTLastResetTime.setDescription("Time and date when the last link reset occurred. The format of this string is the same as that defined for 'stationTime'.")
rmtLapbSTLastResetReason = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTLastResetReason.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTLastResetReason.setDescription('This object defines the reason for the last link reset. It may take on any one of the following values: noReason (0), xpcError (1), ctsLost (2), retryLimitExceeded (3), receivedIdle (4), personalityModule (5), softwareWatchdog (6), nmcInitiated (7), invalidConfiguration (8).')
rmtLapbSTCountResets = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountResets.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountResets.setDescription('This parameter represents the number of link resets performed since the last warmStart, coldStart or statistics reset of the station.')
rmtLapbSTCountSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountSentFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountSentFrames.setDescription('This parameter represents the number of link resets performed since the last warm or cold restart of the station or the last statistics reset.')
rmtLapbSTCountRcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountRcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountRcvFrames.setDescription('This parameter represents the number of I-frames sent since the last station restart or the last statistics reset.')
rmtLapbSTCountSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountSentOctets.setDescription('This parameter represents the number of I-frames received since the last station restart or the last statistics reset.')
rmtLapbSTCountRcvOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountRcvOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountRcvOctets.setDescription('This parameter represents the number of bytes sent since the last station restart or the last statistics reset.')
rmtLapbSTCountAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountAborts.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountAborts.setDescription('This parameter represents the number of bytes received since the last station restart or the last statistics reset.')
rmtLapbSTCountCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmtLapbSTCountCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rmtLapbSTCountCrcErrors.setDescription('This parameter represents the number of aborts received since last station restart or the last statistics reset.')
x25Operation = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25Operation.setStatus('mandatory')
if mibBuilder.loadTexts: x25Operation.setDescription('This parameter is used to enable or disable operation of the x.25 (at the packet level) facility on this station. If x.25 PLP is turned on then this markedly affects the manner in which LAPB works. It also affects the relevance and effictiveness of some LAPB managed objects. A Set Request with a value of enabled(1) will enable this facility whilst a Set Request with a value of disabled(0) disables it.')
x25OperNextReset = MibScalar((1, 3, 6, 1, 4, 1, 72, 13, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25OperNextReset.setStatus('mandatory')
if mibBuilder.loadTexts: x25OperNextReset.setDescription('This parameter indicates if x.25 (at the packet level) is to be enabled or disabled after the next reset of this station. A Set Request with a value of enabled(1) will enable this facility whilst a Set Request with a value of disabled(0) disables it.')
x25ConSetupTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 4, 3), )
if mibBuilder.loadTexts: x25ConSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConSetupTable.setDescription('This table holds configuration data used in setting up each X25 SVC.')
x25CSTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1), ).setIndexNames((0, "RETIX-MIB", "x25CSTIndex"))
if mibBuilder.loadTexts: x25CSTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTEntry.setDescription('Each entry in the Table includes all the configurable objects for each interface.')
x25CSTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CSTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTIndex.setDescription('This index defines the interface for which this entry is valid. This index is equivalent to the phySerIfNumber index representing the physical serial interfaces on the device.')
x25CST8084Switch = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CST8084Switch.setStatus('mandatory')
if mibBuilder.loadTexts: x25CST8084Switch.setDescription('This object is an operation switch, allowing the user to change the operating mode of x.25 on this interface. A value of x251980(0) sets the operating mode to 1980 operating mode, wheras a value of x251984(4) sets it to 1984.')
x25CSTSrcDTEAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTSrcDTEAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTSrcDTEAddr.setDescription('This is the address of the Source DTE associated with this interface. It can be any number, up to 15 ascii characters long, in the range 0-9.')
x25CSTDestDTEAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTDestDTEAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTDestDTEAddr.setDescription('This is the address of the Destination DTE associated with this interface. It can be any number, up to 15 ascii characters long, in the range 0-9.')
x25CST2WayLgclChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CST2WayLgclChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: x25CST2WayLgclChanNum.setDescription('This number uniquely identifies the two-way logical channel number to be used in the DTE/DCE interface when establishing an SVC on this interface.')
x25CSTPktSeqNumFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("mod8", 1), ("mod128", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTPktSeqNumFlg.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTPktSeqNumFlg.setDescription('This parameter allows the user to switch between Basic (modulo 8) and Extended (modulo 128) Packet Sequence Numbering. A value of mod8(1) indicates the use of Basic numbering, while a value of mod128(4) specifies Extended numbering.')
x25CSTFlowCntrlNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTFlowCntrlNeg.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTFlowCntrlNeg.setDescription('This parameter is used to enable/disable flow control negotiation on this interface. If the value is disable (0), the values of window size and packet size are the specified default values. If the value is enable (1), then this DTE offers its negotiation values and these may be negotiated downwards by the remote entity.')
x25CSTDefaultWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTDefaultWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTDefaultWinSize.setDescription('This is the window size used if Negoriation is not enabled. If basic frame numbering is in operation, then it cannot have a value greater than 7. If extended frame numbering is enabled, then it can have a value up to 127.')
x25CSTDefaultPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTDefaultPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTDefaultPktSize.setDescription('This is the packet size used if Negotiation is not enabled. This must be less than or equal to the Physical Block size on the device.')
x25CSTNegWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTNegWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTNegWinSize.setDescription('This is the window size requested when a connection is being initialised, if Negotiation is enabled. If basic frame numbering is in operation, then it cannot have a value greater than 7. If extended frame numbering is enabled, then it can have a value up to 127.')
x25CSTNegPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTNegPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTNegPktSize.setDescription('This is the packet size requested at call setup time, if Negotiation is enabled. This should not be larger than the Physical Block size defined for this device.')
x25CSTCUGSub = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTCUGSub.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTCUGSub.setDescription('This parameter allows the enabling of the Closed User Group (CUG) selection facitily for connections on this interface. A Set Request with a value of cugOnly(4) enables Closed User Group operation whilst a value of disabled(0) disables it.')
x25CSTLclCUGValue = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTLclCUGValue.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTLclCUGValue.setDescription('This value is the number which uniquely defines the Closed User Group value to be used within the Closed User Group Selection facility of the call packet.')
x25CSTRvrsChrgReq = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTRvrsChrgReq.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTRvrsChrgReq.setDescription('When a connection is being set up, this device will reuqest that Reverse Charging of the call be accepted by the remote end, if the value of this parameter is set to enable(1). A Set Request with a value of disabled(0) disabled this feature.')
x25CSTRvrsChrgAcc = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CSTRvrsChrgAcc.setStatus('mandatory')
if mibBuilder.loadTexts: x25CSTRvrsChrgAcc.setDescription('When a connection is being set up, this station will accept reverse charging of the call, initiated by the remote end, if the value of this object is set to enable(1). A Set Request with a value of disabled(0) disabled this feature.')
x25ConControlTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 4, 4), )
if mibBuilder.loadTexts: x25ConControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConControlTable.setDescription('This table holds configurable data used in controlling each X25 SVC.')
x25CCTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1), ).setIndexNames((0, "RETIX-MIB", "x25CCTIndex"))
if mibBuilder.loadTexts: x25CCTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTEntry.setDescription('Each entry contains configurable objects allowing the control of the status of the SVC.')
x25CCTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CCTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTIndex.setDescription('This index defines the interface for which this entry is valid. This index is equivalent to the phySerIfNumber index representing the physical serial interfaces on the device.')
x25CCTManualConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("connect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTManualConnect.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTManualConnect.setDescription('This parameter is used to perform a manual (re)connect of the x.25 SVC, when its value is set to connect(2). A value of noAction(1) is returned in response to Get Requests.')
x25CCTManualDisconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("disconnect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTManualDisconnect.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTManualDisconnect.setDescription('This parameter is used to perform a manual disconnect of the x.25 SVC, when its value is set to disconnect(2). A value of noAction(1) is returned in response to Get Requests.')
x25CCTCfgAutoConRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTCfgAutoConRetry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTCfgAutoConRetry.setDescription("This parameter is used to allow the user to configure whether retries are to take place when an SVC is being established. If the station is under manual control then the actual value of the automatic connect retry flag may be different to this object's value. A Set Request with a value of enabled(1) enables this feature whilst a Set Request with a value od disabled(0) disables it.")
x25CCTOperAutoConRetryFlg = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CCTOperAutoConRetryFlg.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTOperAutoConRetryFlg.setDescription('This parameter is the actual operation flag which tells us if automatic connect retry is currently enabled on this station. The value of the x25CCTCfgAutoConRetry object is the last configured value of the automatic connect retry flag. A Set Request with a value of enabled(1) enables this feature whilst a Set Request with a value od disabled(0) disables it.')
x25CCTAutoConRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTAutoConRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTAutoConRetryTimer.setDescription('This is the retry timer, which defines the delay, in seconds, between consecutive attempts to establish the X25 SVC.')
x25CCTMaxAutoConRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTMaxAutoConRetries.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTMaxAutoConRetries.setDescription('This defines the maximum no of attempts to set up a single X25 SVC allowed. A value of 0 means there is no limit to the number of retries allowed.')
x25CCTCfgTODControl = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTCfgTODControl.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTCfgTODControl.setDescription('This parameter is used to enable/disable the time-of-day control mechanism, which can control the time period for which an SVC may be active, between two devices. Setting this object also sets the current operating value of the underlying variable. However, this value survives a reset whereas the current value may not. A Set Request with a value of enabled(1) enables this feature whilst a Set Request with a value od disabled(0) disables it.')
x25CCTCurrentTODControl = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTCurrentTODControl.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTCurrentTODControl.setDescription('This parameter is used to enable/disable the time-of-day control mechanism, which can control the time period for which an SVC is active. A set to this object only sets the operating value of the underlying variable and does not survive a station reset. A Set Request with a value of enabled(1) enables this feature whilst a Set Request with a value od disabled(0) disables it.')
x25CCTTODToConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTTODToConnect.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTTODToConnect.setDescription('This parameter defined the time of day at which the time-of-day control mechanism, when enabled, will attempt to establish an SVC to the remote end. If the SVC exists at this time then no action is taken. The format of the time is as follows hhmm where hh is the hour and mm is the minute.')
x25CCTTODToDisconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 4, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CCTTODToDisconnect.setStatus('mandatory')
if mibBuilder.loadTexts: x25CCTTODToDisconnect.setDescription('This parameter defined the time of day at which the time-of-day control mechanism, when enabled, will attempt to disconnect an SVC from the remote end. If the SVC is already disconnected at this time then no action is taken. The format of the time is as follows: hhmm where hh is the hour and mm is the minute.')
x25TimerTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 4, 5), )
if mibBuilder.loadTexts: x25TimerTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25TimerTable.setDescription('This table holds the configurable timers used with each X25 connection (SVC).')
x25TTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1), ).setIndexNames((0, "RETIX-MIB", "x25TTIndex"))
if mibBuilder.loadTexts: x25TTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTEntry.setDescription('Each entry holds the configurable values of timers and retry limits in operation for each SVC.')
x25TTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25TTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTIndex.setDescription('This index defines the interface for which this entry is valid. This index is equivalent to the phySerIfNumber index representing the physical serial interfaces on the device.')
x25TTT20Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTT20Timer.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTT20Timer.setDescription('This defines the value of the restart retransmit timer, in seconds.')
x25TTT21Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTT21Timer.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTT21Timer.setDescription('This defines the value of the call retransmit timer, in seconds.')
x25TTT22Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTT22Timer.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTT22Timer.setDescription('This defines the value of the reset retransmit timer, in seconds.')
x25TTT23Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTT23Timer.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTT23Timer.setDescription('This defines the value of the clear retransmit timer, in seconds.')
x25TTR20Limit = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTR20Limit.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTR20Limit.setDescription('This defines the maximum value of the restart retransmit count, when operating as a DTE.')
x25TTR22Limit = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTR22Limit.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTR22Limit.setDescription('This defines the maximum value of the reset retransmit count, when operating as a DTE.')
x25TTR23Limit = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25TTR23Limit.setStatus('mandatory')
if mibBuilder.loadTexts: x25TTR23Limit.setDescription('This defines the maximum value of the clear retransmit count, when operating as a DTE.')
x25StatusTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 4, 6), )
if mibBuilder.loadTexts: x25StatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusTable.setDescription('This table holds status information for each X25 SVC and for each interface.')
x25StatusTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1), ).setIndexNames((0, "RETIX-MIB", "x25StatusIndex"))
if mibBuilder.loadTexts: x25StatusTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusTableEntry.setDescription('Each entry keeps status information on each Interface/SVC.')
x25StatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusIndex.setDescription('This index pertains to the interface/SVC for which this entry is valid.')
x25StatusIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusIfStatus.setDescription('This object defines the current status of the interface. More specifically, this is the state of the logical channel number 0, which governs the state of the entire SVC.')
x25StatusSVCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusSVCStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusSVCStatus.setDescription('This object defines the current status of the SVC, more specifically, the state of the active logical channel. This object has no meaning if the state of the Interface is not r1PktLevelReady.')
x25StatusWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusWinSize.setDescription('This is the window size in operation for the current SVC. This may be less than the Configured Window sized depending on whether Flow Control is enabled, and the result of the negotiation.')
x25StatusPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusPktSize.setDescription('This is the Packet size in use for the current SVC. This may be less than the Configured values, depending on whether Flow Control is enabled and if negotiation has taken place.')
x25StatusCauseLastInClear = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusCauseLastInClear.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusCauseLastInClear.setDescription('This object defines the Cause of the Last Incoming Clear Received on this interface. It is in th e form of a bit-map, the values and combinations of which are too numerous to list here. The values may be found by referring to the appropriate section in the X25 PLP standard from CCITT.')
x25StatusDiagLastInClear = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25StatusDiagLastInClear.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatusDiagLastInClear.setDescription('This object defines the Diagnostic of the Last Incoming Clear Received on this interface. It is in the form of a bit-map, the values and combinations of which are too numerous to list here. The values may be found by referring to the appropriate section in the X25 PLP standard from CCITT.')
x25StatsTable = MibTable((1, 3, 6, 1, 4, 1, 72, 13, 4, 7), )
if mibBuilder.loadTexts: x25StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatsTable.setDescription('This table holds all statistical data for each x25 SVC. There are two entries in this table, for a 4942.')
x25StatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1), ).setIndexNames((0, "RETIX-MIB", "x25STSVCIndex"))
if mibBuilder.loadTexts: x25StatsTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25StatsTableEntry.setDescription('Each entry in the Table includes all the statistical objects for each interface.')
x25STSVCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STSVCIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25STSVCIndex.setDescription('This index pertains to the interface for which this entry is valid.')
x25STTxDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STTxDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STTxDataPkts.setDescription('This is the number of Data Pkts transmitted on this interface.')
x25STRxDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STRxDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STRxDataPkts.setDescription('This is the number of Data Pkts received on this interface.')
x25STTxConnectReqPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STTxConnectReqPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STTxConnectReqPkts.setDescription('This is the number of Connect Request packets transmitted on this interface.')
x25STRxIncomingCallPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STRxIncomingCallPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STRxIncomingCallPkts.setDescription('This is the number of incoming Call request packets received on this interface.')
x25STTxClearReqPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STTxClearReqPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STTxClearReqPkts.setDescription('This is the number of Clear Request packets transmitted on this interface.')
x25STRxClearIndPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STRxClearIndPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STRxClearIndPkts.setDescription('This is the number of Clear Indication packets received on this interface.')
x25STTxResetReqPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STTxResetReqPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STTxResetReqPkts.setDescription('This is the number of Reset Request packets transmitted on this interface.')
x25STRxResetIndPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STRxResetIndPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STRxResetIndPkts.setDescription('This is the number of Reset Indication packets received on this interface.')
x25STTxRestartReqPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STTxRestartReqPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STTxRestartReqPkts.setDescription('This is the number of Restart Request packets transmitted on this interface.')
x25STRxRestartIndPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 72, 13, 4, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25STRxRestartIndPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25STRxRestartIndPkts.setDescription('This is the number of Restart Indication packets received on this interface.')
mibBuilder.exportSymbols("RETIX-MIB", ipxRITEntry=ipxRITEntry, ieee8023MulticastFramesReceivedOks=ieee8023MulticastFramesReceivedOks, filterMatches=filterMatches, rmtLapbCTInitLinkConnect=rmtLapbCTInitLinkConnect, x25CSTSrcDTEAddr=x25CSTSrcDTEAddr, dcntInDiscards=dcntInDiscards, ieee8023FCSErrors=ieee8023FCSErrors, x25TTT23Timer=x25TTT23Timer, x25CSTDestDTEAddr=x25CSTDestDTEAddr, trapDestTable=trapDestTable, lanInterfaceType=lanInterfaceType, arAddressInfo=arAddressInfo, x25StatusIndex=x25StatusIndex, deleteAddressTimer=deleteAddressTimer, ifStatus=ifStatus, serialTxQueueSize=serialTxQueueSize, pathCostAutoValue=pathCostAutoValue, expressQueueUpperLimit=expressQueueUpperLimit, x25STTxResetReqPkts=x25STTxResetReqPkts, rmtLapbSTEntry=rmtLapbSTEntry, ipxIfEncapsulation=ipxIfEncapsulation, priorityPage=priorityPage, dcntInHdrErrors=dcntInHdrErrors, x25STRxClearIndPkts=x25STRxClearIndPkts, serialLoading=serialLoading, x25CST8084Switch=x25CST8084Switch, x25CCTTODToConnect=x25CCTTODToConnect, ieee8023MACSubLayerStatus=ieee8023MACSubLayerStatus, ieee8023Table=ieee8023Table, x25STTxRestartReqPkts=x25STTxRestartReqPkts, standbyLocal=standbyLocal, hiPriQueueCurrentLength=hiPriQueueCurrentLength, phySerIfT1dRatePerChan=phySerIfT1dRatePerChan, dcntIfHelloTimerBCT3=dcntIfHelloTimerBCT3, x25StatusPktSize=x25StatusPktSize, mlink=mlink, x25ConSetupTable=x25ConSetupTable, freeHeaderCount=freeHeaderCount, ieee8023SingleCollisionFrames=ieee8023SingleCollisionFrames, lapbState=lapbState, x25=x25, phySerIfT1clockSource=phySerIfT1clockSource, dcntAreaRITCost=dcntAreaRITCost, x25TTR20Limit=x25TTR20Limit, phySerIfNumber=phySerIfNumber, stpIndex=stpIndex, authenticationTrapStatus=authenticationTrapStatus, mlinkRcvSeq=mlinkRcvSeq, phySerIfT1SlotHvalue=phySerIfT1SlotHvalue, freeBufferCount=freeBufferCount, physBlkSize=physBlkSize, ipxIfIndex=ipxIfIndex, x25CSTNegWinSize=x25CSTNegWinSize, x25StatusDiagLastInClear=x25StatusDiagLastInClear, priorityTableAction=priorityTableAction, x25CST2WayLgclChanNum=x25CST2WayLgclChanNum, filteringDbDisposition=filteringDbDisposition, x25CCTManualConnect=x25CCTManualConnect, queueUpperLimit=queueUpperLimit, ieee8023DeferredTransmissions=ieee8023DeferredTransmissions, echoRequestsLastTx=echoRequestsLastTx, x25CCTManualDisconnect=x25CCTManualDisconnect, operatingMode=operatingMode, preconfSourceFilter=preconfSourceFilter, ipxSAPBinderyServerIPXAddress=ipxSAPBinderyServerIPXAddress, priorityTableEntry=priorityTableEntry, typeFilter=typeFilter, dcntRITNextHop=dcntRITNextHop, x25OperNextReset=x25OperNextReset, loPriQueueUpperLimit=loPriQueueUpperLimit, sourceQuenchLastTx=sourceQuenchLastTx, x25StatusWinSize=x25StatusWinSize, rmtLapbCTX25PortLineSpeed=rmtLapbCTX25PortLineSpeed, prioritySubTable=prioritySubTable, rmtLapb=rmtLapb, ipxRITInterface=ipxRITInterface, mlinkEntry=mlinkEntry, pathCostMode=pathCostMode, boothelperHopsLimit=boothelperHopsLimit, x25STRxDataPkts=x25STRxDataPkts, x25CCTMaxAutoConRetries=x25CCTMaxAutoConRetries, filteringDbMacAddress=filteringDbMacAddress, initiateBootpDll=initiateBootpDll, ieee8023ExcessiveCollisions=ieee8023ExcessiveCollisions, stationCountResets=stationCountResets, ipRouting=ipRouting, portPriorityManualValue=portPriorityManualValue, dcntRouting=dcntRouting, phySerIfT1frameAndCode=phySerIfT1frameAndCode, ieee8023MultipleCollisionFrames=ieee8023MultipleCollisionFrames, ipxOtherDiscards=ipxOtherDiscards, dcntRateControlFreqTimerT2=dcntRateControlFreqTimerT2, lan=lan, portPriorityMode=portPriorityMode, phySerIfMeasuredSpeed=phySerIfMeasuredSpeed, x25StatusCauseLastInClear=x25StatusCauseLastInClear, x25TTT21Timer=x25TTT21Timer, rmtLapbCTT3LinkIdleTimer=rmtLapbCTT3LinkIdleTimer, maxRejectedFrames=maxRejectedFrames, dcntRITHops=dcntRITHops, ieee8023=ieee8023, uniqueBroadcastAddress=uniqueBroadcastAddress, standbyRemote=standbyRemote, lanQueueSize=lanQueueSize, lapbCountRcvFrames=lapbCountRcvFrames, ipxIfDelay=ipxIfDelay, x25STRxIncomingCallPkts=x25STRxIncomingCallPkts, ieee8023MulticastFramesTransmittedOks=ieee8023MulticastFramesTransmittedOks, retix=retix, ipRSIndex=ipRSIndex, mlinkLostFrames=mlinkLostFrames, ieee8023TransmitStatus=ieee8023TransmitStatus, lapbCountResets=lapbCountResets, dcntForwardedDgms=dcntForwardedDgms, internalQueueCurrentLength=internalQueueCurrentLength, rmtLapbCTLinkAddr=rmtLapbCTLinkAddr, trapDestPage=trapDestPage, dcntRITCost=dcntRITCost, x25CCTTODToDisconnect=x25CCTTODToDisconnect, bridge=bridge, ieee8023FrameTooLongs=ieee8023FrameTooLongs, noRouteTotalDgms=noRouteTotalDgms, phySerIfEntry=phySerIfEntry, mlinkTable=mlinkTable, x25CSTCUGSub=x25CSTCUGSub, station=station, ipxInDiscards=ipxInDiscards, ipxForwardedDgms=ipxForwardedDgms, rmtLapbSTAutoT1value=rmtLapbSTAutoT1value, ieee8023OctetsReceivedOks=ieee8023OctetsReceivedOks, filteringDbStatus=filteringDbStatus, rmtLapbCTEntry=rmtLapbCTEntry, snmpAccessPolicyType=snmpAccessPolicyType, mlinkNumber=mlinkNumber, ieee8023PromiscuousReceiveStatus=ieee8023PromiscuousReceiveStatus, rmtLapbSTCountCrcErrors=rmtLapbSTCountCrcErrors, decnet=decnet, filteringDataBaseTable=filteringDataBaseTable, filteringDbEntry=filteringDbEntry, spatResetTimer=spatResetTimer, ieee8023Number=ieee8023Number, snmpAccessPolicyTable=snmpAccessPolicyTable, ieee8023Entry=ieee8023Entry, rmtLapbSTCountRcvOctets=rmtLapbSTCountRcvOctets, dynamicLearningInLM=dynamicLearningInLM, dcntAreaRoutingTable=dcntAreaRoutingTable, x25CSTDefaultWinSize=x25CSTDefaultWinSize, accessMode=accessMode, expressQueueCurrentLength=expressQueueCurrentLength, serialLoadPeriod=serialLoadPeriod, dcntReveivedDgms=dcntReveivedDgms, ieee8023InternalMACTransmitErrors=ieee8023InternalMACTransmitErrors, ieee8023LateCollisions=ieee8023LateCollisions, timeExceededLastRx=timeExceededLastRx, dcntInterAreaMaxHops=dcntInterAreaMaxHops, ipxRITDelay=ipxRITDelay, loPriQueueCurrentLength=loPriQueueCurrentLength, stpEntry=stpEntry, x25CCTIndex=x25CCTIndex, x25STRxRestartIndPkts=x25STRxRestartIndPkts, typePrioritisation=typePrioritisation, ieee8023NewMACAddressIndex=ieee8023NewMACAddressIndex, multicastDisposition=multicastDisposition, boothelper=boothelper, ipxAccessViolations=ipxAccessViolations, sourceQuenchLastRx=sourceQuenchLastRx, x25CSTRvrsChrgAcc=x25CSTRvrsChrgAcc, trapDestinationTable=trapDestinationTable, rmtLapbCTManualT1Value=rmtLapbCTManualT1Value, priorityTable=priorityTable, phySerIfInterfaceType=phySerIfInterfaceType, receivedTotalDgms=receivedTotalDgms, x25StatsTable=x25StatsTable, product=product, lapbModeT1=lapbModeT1, snmpAccessPolicyObject=snmpAccessPolicyObject, adaptiveRouting=adaptiveRouting, dcntIfNumber=dcntIfNumber, dcntMaxVisits=dcntMaxVisits, tftpRetryPeriod=tftpRetryPeriod, lapbEntry=lapbEntry, mlinkRxTimeout=mlinkRxTimeout, loadserverIpAddress=loadserverIpAddress, x25STRxResetIndPkts=x25STRxResetIndPkts, mlinkState=mlinkState, x25CSTLclCUGValue=x25CSTLclCUGValue, rmtLapbSTState=rmtLapbSTState, ieee8023BroadcastFramesReceivedOks=ieee8023BroadcastFramesReceivedOks, dcntOutDiscards=dcntOutDiscards, lapbLinkReset=lapbLinkReset, boothelperForwardingAddress=boothelperForwardingAddress, bridgeStatsEntry=bridgeStatsEntry, filterSubTable=filterSubTable, ipxReceivedDgms=ipxReceivedDgms, lapbCountRcvOctets=lapbCountRcvOctets, ipxSAPBinderySocket=ipxSAPBinderySocket, dcntIfIndex=dcntIfIndex, lapbCountSentFrames=lapbCountSentFrames, ieee8023MulticastReceiveStatus=ieee8023MulticastReceiveStatus, x25StatusTable=x25StatusTable, boothelperEnabled=boothelperEnabled, paramProbLastRx=paramProbLastRx, x25STTxClearReqPkts=x25STTxClearReqPkts, dcntOutRequestedDgms=dcntOutRequestedDgms, trapDestEntryCommunityName=trapDestEntryCommunityName, ieee8023CarrierSenseErrors=ieee8023CarrierSenseErrors, dcntRoutingTable=dcntRoutingTable, rmtLapbSTCountSentFrames=rmtLapbSTCountSentFrames, filteringDbType=filteringDbType, trapDestEntryType=trapDestEntryType, ipxIfEntry=ipxIfEntry, lapbCountSentOctets=lapbCountSentOctets, ieee8023InternalMACReceiveErrors=ieee8023InternalMACReceiveErrors, rmtLapbCTModeT1=rmtLapbCTModeT1, hiPriQueueUpperLimit=hiPriQueueUpperLimit, lapbManualT1value=lapbManualT1value, ipxIfTable=ipxIfTable, priorityTableEntryType=priorityTableEntryType, ieeeFormatFilter=ieeeFormatFilter, ieee8023NewMACAddressEntry=ieee8023NewMACAddressEntry, filteringDbTable=filteringDbTable, lapbCountAborts=lapbCountAborts, dcntIfTableEntry=dcntIfTableEntry, priorityMatches=priorityMatches, spanningTree=spanningTree, dcntIfRtrPriority=dcntIfRtrPriority, mlinkRcvUpperEdge=mlinkRcvUpperEdge, tftpRetryCount=tftpRetryCount, dcntAreaRITDestArea=dcntAreaRITDestArea, averageForwardedFrames=averageForwardedFrames, filterTableEntry=filterTableEntry, ipxTransmittedDgms=ipxTransmittedDgms, activeRemote=activeRemote, phySerIfT1SlotLvalue=phySerIfT1SlotLvalue, rmtLapbCTExtSeqNumbering=rmtLapbCTExtSeqNumbering, dcntIntraAreaMaxHops=dcntIntraAreaMaxHops, ipxNotRoutedRxDgms=ipxNotRoutedRxDgms, ipxInDelivers=ipxInDelivers, lapbPolarity=lapbPolarity, echoRequestsLastRx=echoRequestsLastRx, x25CSTFlowCntrlNeg=x25CSTFlowCntrlNeg, ieee8023AlignmentErrors=ieee8023AlignmentErrors, destUnreachLastRx=destUnreachLastRx, resetStation=resetStation, x25StatsTableEntry=x25StatsTableEntry, averageRejectedFrames=averageRejectedFrames, x25CCTCurrentTODControl=x25CCTCurrentTODControl, ieeeFormatPriority=ieeeFormatPriority, ipxIfNumber=ipxIfNumber, ipx=ipx, lapbTable=lapbTable, x25CCTOperAutoConRetryFlg=x25CCTOperAutoConRetryFlg, snmpAccessPolicyPage=snmpAccessPolicyPage, deletedLanFrames=deletedLanFrames)
mibBuilder.exportSymbols("RETIX-MIB", rmtLapbSTCountAborts=rmtLapbSTCountAborts, ipxIfIPXAddress=ipxIfIPXAddress, dcntIntraAreaMaxCost=dcntIntraAreaMaxCost, mlinkSendSeq=mlinkSendSeq, pathCostManualValue=pathCostManualValue, newPhysBlkSize=newPhysBlkSize, phySerIfTransitDelay=phySerIfTransitDelay, x25StatusSVCStatus=x25StatusSVCStatus, dcntInterAreaMaxCost=dcntInterAreaMaxCost, triangulation=triangulation, x25TimerTable=x25TimerTable, router=router, x25CSTEntry=x25CSTEntry, dcntAreaRITNextHop=dcntAreaRITNextHop, spatPriority=spatPriority, destUnreachLastTx=destUnreachLastTx, ipxRoutingTable=ipxRoutingTable, ieee8023FramesTransmittedOks=ieee8023FramesTransmittedOks, filterTableEntryType=filterTableEntryType, boot=boot, rmtLapbCTN2RetryCount=rmtLapbCTN2RetryCount, rmtLapbSTLastResetReason=rmtLapbSTLastResetReason, lapbNumber=lapbNumber, x25TTIndex=x25TTIndex, lapbRetryCount=lapbRetryCount, rmtLapbCTIndex=rmtLapbCTIndex, ipxRITGwyHostAddress=ipxRITGwyHostAddress, ieee8023inRangeLengthErrors=ieee8023inRangeLengthErrors, spatVersion=spatVersion, paramProbLastTx=paramProbLastTx, passWord=passWord, rmtLapbSTCountResets=rmtLapbSTCountResets, phySerIfPortSpeed=phySerIfPortSpeed, mlinkWindow=mlinkWindow, ieee8023Index=ieee8023Index, ieee8023MACAddress=ieee8023MACAddress, phySerIfPartnerAddress=phySerIfPartnerAddress, ipxIfNwkNumber=ipxIfNwkNumber, trapDestEntryIpAddr=trapDestEntryIpAddr, ieee8023InitializeMAC=ieee8023InitializeMAC, x25CSTPktSeqNumFlg=x25CSTPktSeqNumFlg, lapbIndex=lapbIndex, icmpRSTable=icmpRSTable, remote=remote, trapDestAction=trapDestAction, spatHelloTimer=spatHelloTimer, ipRSEntry=ipRSEntry, lapbCountCrcErrors=lapbCountCrcErrors, redirectsLastRx=redirectsLastRx, dcntRITInterface=dcntRITInterface, x25TTT22Timer=x25TTT22Timer, lapb=lapb, ieee8023BroadcastFramesTransmittedOks=ieee8023BroadcastFramesTransmittedOks, lapbAutoT1value=lapbAutoT1value, ieee8023outOfRangeLengthFields=ieee8023outOfRangeLengthFields, outDiscardsTotalDgms=outDiscardsTotalDgms, rmtLapbCTLinkReset=rmtLapbCTLinkReset, x25CSTIndex=x25CSTIndex, rmtLapbSTCountRcvFrames=rmtLapbSTCountRcvFrames, snmpAccessPolicyEntry=snmpAccessPolicyEntry, maxSerialLoading=maxSerialLoading, mlinkSendUpperEdge=mlinkSendUpperEdge, ieee8023FramesReceivedOks=ieee8023FramesReceivedOks, dcntRITDestNode=dcntRITDestNode, ipxRITHopCount=ipxRITHopCount, ipxSAPBinderyType=ipxSAPBinderyType, dcntRITEntry=dcntRITEntry, dcntNoRoutes=dcntNoRoutes, portPriorityAutoValue=portPriorityAutoValue, x25TTEntry=x25TTEntry, phySerIfIsSpeedsettable=phySerIfIsSpeedsettable, resetStats=resetStats, filterTableAction=filterTableAction, x25CCTAutoConRetryTimer=x25CCTAutoConRetryTimer, mlinkIndex=mlinkIndex, dcntAreaRITHops=dcntAreaRITHops, ipxSAPBinderyEntry=ipxSAPBinderyEntry, x25StatusIfStatus=x25StatusIfStatus, bridgeStatsTable=bridgeStatsTable, redirectsLastTx=redirectsLastTx, x25CSTNegPktSize=x25CSTNegPktSize, rmtLapbConfigTable=rmtLapbConfigTable, dcntAreaRITEntry=dcntAreaRITEntry, ieee8023OctetsTransmittedOks=ieee8023OctetsTransmittedOks, ipxSAPBinderyServerName=ipxSAPBinderyServerName, ipxInHdrErrors=ipxInHdrErrors, x25STTxConnectReqPkts=x25STTxConnectReqPkts, timeExceededLastTx=timeExceededLastTx, ieee8023ExcessiveDeferrals=ieee8023ExcessiveDeferrals, filteringDbAction=filteringDbAction, transmittedTotalDgms=transmittedTotalDgms, downloadFilename=downloadFilename, x25ConControlTable=x25ConControlTable, forgetAddressTimer=forgetAddressTimer, x25CSTDefaultPktSize=x25CSTDefaultPktSize, rmtLapbSTCountSentOctets=rmtLapbSTCountSentOctets, phySerIfIndex=phySerIfIndex, averagePeriod=averagePeriod, x25CSTRvrsChrgReq=x25CSTRvrsChrgReq, x25STSVCIndex=x25STSVCIndex, portSpatState=portSpatState, downloadRetryCount=downloadRetryCount, dcntNodeAddress=dcntNodeAddress, lapbWindow=lapbWindow, bridgeStatsIndex=bridgeStatsIndex, communityName=communityName, phySerIf=phySerIf, ipRSTable=ipRSTable, maxForwardedFrames=maxForwardedFrames, rmtLapbSTIndex=rmtLapbSTIndex, x25Operation=x25Operation, ipxRITDirectConnect=ipxRITDirectConnect, ipxOutDiscards=ipxOutDiscards, ipxSAPBinderyHopCount=ipxSAPBinderyHopCount, portNumber=portNumber, stpTable=stpTable, filterTableEntryValue=filterTableEntryValue, ieee8023NewMACAddressValue=ieee8023NewMACAddressValue, snmpAccessPolicyAction=snmpAccessPolicyAction, processorLoading=processorLoading, lanRejects=lanRejects, activeLocal=activeLocal, stationTime=stationTime, dcntAreaRITInterface=dcntAreaRITInterface, ipxSAPBinderyTable=ipxSAPBinderyTable, x25CCTCfgTODControl=x25CCTCfgTODControl, rmtLapbSTLastResetTime=rmtLapbSTLastResetTime, deletedMlinkFrames=deletedMlinkFrames, trapDestEntry=trapDestEntry, x25TTR22Limit=x25TTR22Limit, x25TTR23Limit=x25TTR23Limit, ieee8023SQETestErrors=ieee8023SQETestErrors, bootserverIpAddress=bootserverIpAddress, filterTable=filterTable, x25TTT20Timer=x25TTT20Timer, priorityTableEntryValue=priorityTableEntryValue, dcntIfTable=dcntIfTable, initStation=initStation, x25CCTEntry=x25CCTEntry, rmtLapbCTWindow=rmtLapbCTWindow, bootpRetryCount=bootpRetryCount, phySerIfTable=phySerIfTable, gwProtocol=gwProtocol, dcntRtngMsgTimerBCT1=dcntRtngMsgTimerBCT1, dcntIfDesgntdRtr=dcntIfDesgntdRtr, x25StatusTableEntry=x25StatusTableEntry, adaptiveMcastAddr=adaptiveMcastAddr, lanAccepts=lanAccepts, lapbLastResetTime=lapbLastResetTime, x25CCTCfgAutoConRetry=x25CCTCfgAutoConRetry, rmtLapbStatsTable=rmtLapbStatsTable, ipxRITDestNwkNumber=ipxRITDestNwkNumber, x25STTxDataPkts=x25STTxDataPkts, lapbLastResetReason=lapbLastResetReason, dcntIfCost=dcntIfCost, spanningMcastAddr=spanningMcastAddr, ieee8023NewMACAddress=ieee8023NewMACAddress, ipxRouting=ipxRouting, filterPage=filterPage, accessPolicyIndex=accessPolicyIndex)

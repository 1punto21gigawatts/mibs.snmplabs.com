#
# PySNMP MIB module HPR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HPR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:42:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
SnaControlPointName, = mibBuilder.importSymbols("APPN-MIB", "SnaControlPointName")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
snanauMIB, = mibBuilder.importSymbols("SNA-NAU-MIB", "snanauMIB")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Gauge32, IpAddress, MibIdentifier, Counter64, Integer32, Counter32, ObjectIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Bits, iso, NotificationType, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "IpAddress", "MibIdentifier", "Counter64", "Integer32", "Counter32", "ObjectIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Bits", "iso", "NotificationType", "TimeTicks")
TimeStamp, TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "DisplayString", "DateAndTime")
hprMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 34, 6))
if mibBuilder.loadTexts: hprMIB.setLastUpdated('970514000000Z')
if mibBuilder.loadTexts: hprMIB.setOrganization('AIW APPN / HPR MIB SIG')
if mibBuilder.loadTexts: hprMIB.setContactInfo(' Bob Clouston Cisco Systems 7025 Kit Creek Road P.O. Box 14987 Research Triangle Park, NC 27709, USA Tel: 1 919 472 2333 E-mail: clouston@cisco.com Bob Moore IBM Corporation 800 Park Offices Drive RHJA/664 P.O. Box 12195 Research Triangle Park, NC 27709, USA Tel: 1 919 254 4436 E-mail: remoore@ralvm6.vnet.ibm.com ')
if mibBuilder.loadTexts: hprMIB.setDescription('This is the MIB module for objects used to manage network devices with HPR capabilities.')
class HprNceTypes(TextualConvention, Bits):
    description = 'A bit string identifying the set of functions provided by a network connection endpoint (NCE). The following values are defined: bit 0: control point bit 1: logical unit bit 2: boundary function bit 3: route setup '
    status = 'current'
    namedValues = NamedValues(("controlPoint", 0), ("logicalUnit", 1), ("boundaryFunction", 2), ("routeSetup", 3))

class HprRtpCounter(TextualConvention, Counter32):
    description = 'An object providing statistics for an RTP connection. A Management Station can detect discontinuities in this counter by monitoring the correspondingly indexed hprRtpCounterDisconTime object.'
    status = 'current'

hprObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 1))
hprGlobal = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 1, 1))
hprNodeCpName = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 1, 1), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprNodeCpName.setStatus('current')
if mibBuilder.loadTexts: hprNodeCpName.setDescription('Administratively assigned network name for the APPN node where this HPR implementation resides. If this object has the same value as the appnNodeCpName object in the APPN MIB, then the two objects are referring to the same APPN node.')
hprOperatorPathSwitchSupport = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("switchTriggerSupported", 2), ("switchToPathSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprOperatorPathSwitchSupport.setStatus('current')
if mibBuilder.loadTexts: hprOperatorPathSwitchSupport.setDescription("This object indicates an implementation's level of support for an operator-requested path switch. notSupported(1) - the agent does not support operator-requested path switches switchTriggerSupported(2) - the agent supports a 'switch path now' command from an operator, but not a command to switch to a specified path switchToPathSupported(3) - the agent supports both a 'switch path now' command and a command to switch to a specified path. Note that the latter command is not available via this MIB; a system that supports it must do so via other means, such as a local operator interface.")
hprAnrRouting = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 1, 2))
hprAnrsAssigned = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 1), Counter32()).setUnits('ANR labels').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrsAssigned.setStatus('current')
if mibBuilder.loadTexts: hprAnrsAssigned.setDescription('The count of ANR labels assigned by this node since it was last re-initialized. A Management Station can detect discontinuities in this counter by monitoring the appnNodeCounterDisconTime object in the APPN MIB.')
hprAnrCounterState = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hprAnrCounterState.setStatus('current')
if mibBuilder.loadTexts: hprAnrCounterState.setDescription('This object is used for a network management station to turn on/off the counting of ANR packets in the hprAnrRoutingTable. The initial value of this object is an implementation choice. notActive(1) - the counter hprAnrPacketsReceived returns no meaningful value active(2) - the counter hprAnrPacketsReceived is being incremented and is returning meaningful values')
hprAnrCounterStateTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrCounterStateTime.setStatus('current')
if mibBuilder.loadTexts: hprAnrCounterStateTime.setDescription('The time when the hprAnrCounterState object last changed its value. The initial value returned by this object is the time at which the APPN node instrumented with this MIB was last brought up.')
hprAnrRoutingTable = MibTable((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4), )
if mibBuilder.loadTexts: hprAnrRoutingTable.setStatus('current')
if mibBuilder.loadTexts: hprAnrRoutingTable.setDescription('The ANR Routing table provides a means of correlating an incoming ANR label (i.e., one assigned by this node) with the TG over which a packet containing the label will be forwarded. When the ANR label identifies a local NCE, the hprAnrOutTgDest and hprAnrOutTgNum objects have no meaning. The table also contains an object to count the number of packets received with a given ANR label.')
hprAnrRoutingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1), ).setIndexNames((0, "HPR-MIB", "hprAnrLabel"))
if mibBuilder.loadTexts: hprAnrRoutingEntry.setStatus('current')
if mibBuilder.loadTexts: hprAnrRoutingEntry.setDescription('The ANR label is used to index this table.')
hprAnrLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: hprAnrLabel.setStatus('current')
if mibBuilder.loadTexts: hprAnrLabel.setDescription('The first ANR label in an incoming packet.')
hprAnrType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nce", 1), ("tg", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrType.setStatus('current')
if mibBuilder.loadTexts: hprAnrType.setDescription('An object indicating whether an ANR label assigned by this node identifies a local NCE or a TG on which outgoing packets are forwarded. nce(1) - the ANR label identifies a local NCE. In this case the hprAnrOutTgDest and hprAnrOutTgNum objects have no meaning. tg(2) - the ANR label identifies a TG.')
hprAnrOutTgDest = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrOutTgDest.setStatus('current')
if mibBuilder.loadTexts: hprAnrOutTgDest.setDescription('Destination node for the TG over which packets with this ANR label are forwarded. This is the fully qualified name of an APPN network node or end node, formatted according to the SnaControlPointName textual convention. If the ANR label identifies a local NCE, then this object returns a zero-length string. This object corresponds to the appnLocalTgDest object in the APPN MIB.')
hprAnrOutTgNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrOutTgNum.setStatus('current')
if mibBuilder.loadTexts: hprAnrOutTgNum.setDescription('Number of the TG over which packets with this ANR label are forwarded. If the ANR label identifies a local NCE, then this object returns the value 0, since 0 is not a valid TG number for a TG that supports HPR. This object corresponds to the appnLocalTgNum object in the APPN MIB.')
hprAnrPacketsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1, 5), Counter32()).setUnits('ANR packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: hprAnrPacketsReceived.setDescription('The count of packets received with this ANR label as their first label. A Management Station can detect discontinuities in this counter by monitoring the hprAnrCounterDisconTime object in the same row.')
hprAnrCounterDisconTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 2, 4, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprAnrCounterDisconTime.setStatus('current')
if mibBuilder.loadTexts: hprAnrCounterDisconTime.setDescription('The value of the sysUpTime object when the hprAnrPacketsReceived counter for this ANR label last experienced a discontinuity. This will be the more recent of two times: the time at which the ANR label was associated with either an outgoing TG or a local NCE, or the time at which the ANR counters were last turned on or off.')
hprTransportUser = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 1, 3))
hprNceTable = MibTable((1, 3, 6, 1, 2, 1, 34, 6, 1, 3, 1), )
if mibBuilder.loadTexts: hprNceTable.setStatus('current')
if mibBuilder.loadTexts: hprNceTable.setDescription('The Network Connection Endpoint (NCE) table.')
hprNceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 6, 1, 3, 1, 1), ).setIndexNames((0, "HPR-MIB", "hprNceId"))
if mibBuilder.loadTexts: hprNceEntry.setStatus('current')
if mibBuilder.loadTexts: hprNceEntry.setDescription('The NCE ID is used to index this table.')
hprNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: hprNceId.setStatus('current')
if mibBuilder.loadTexts: hprNceId.setDescription('The Network Connection Endpoint (NCE) ID. NCEs identify Control Points (Cp), Logical Units (Lu), HPR Boundary Functions (Bf) and Route Setup (Rs) Functions. A value for this object can be retrieved from any of the following objects in the APPN MIB: - appnLsCpCpNceId - appnLsRouteNceId - appnLsBfNceId - appnIsInRtpNceId - appnIsRtpNceId In each case this value identifies a row in this table containing information related to that in the APPN MIB.')
hprNceType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 3, 1, 1, 2), HprNceTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprNceType.setStatus('current')
if mibBuilder.loadTexts: hprNceType.setDescription('A bit string identifying the function types provided by this Network Connection Endpoint (NCE).')
hprNceDefault = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 3, 1, 1, 3), HprNceTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprNceDefault.setStatus('current')
if mibBuilder.loadTexts: hprNceDefault.setDescription('A bit string identifying the function types for which this Network Connection Endpoint (NCE) is the default NCE. While default NCEs are not explicitly defined in the architecture, some implementations provide them; for such implementations, it is useful to make this information available to a Management Station.')
hprNceInstanceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprNceInstanceId.setStatus('current')
if mibBuilder.loadTexts: hprNceInstanceId.setDescription("The NCE instance identifier (NCEII) identifying the current instance of this NCE. An NCEII is used to denote different instances (IPLs) of an NCE component. Each time an NCE is activated (IPL'd), it acquires a different, unique NCEII.")
hprRtp = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 1, 4))
hprRtpGlobe = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 1))
hprRtpGlobeConnSetups = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 1, 1), Counter32()).setUnits('RTP connection setups').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpGlobeConnSetups.setStatus('current')
if mibBuilder.loadTexts: hprRtpGlobeConnSetups.setDescription('The count of RTP connection setups in which this node has participated, as either sender or receiver, since it was last re-initialized. Retries of a setup attempt do not cause the counter to be incremented. A Management Station can detect discontinuities in this counter by monitoring the appnNodeCounterDisconTime object in the APPN MIB.')
hprRtpGlobeCtrState = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hprRtpGlobeCtrState.setStatus('current')
if mibBuilder.loadTexts: hprRtpGlobeCtrState.setDescription('This object allows a network management station to turn the counters in the hprRtpTable on and off. The initial value of this object is an implementation choice. notActive(1) - the counters in the hprRtpTable are returning no meaningful values active(2) - the counters in the hprRtpTable are being incremented and are returning meaningful values')
hprRtpGlobeCtrStateTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpGlobeCtrStateTime.setStatus('current')
if mibBuilder.loadTexts: hprRtpGlobeCtrStateTime.setDescription('The time when the value of the hprRtpGlobeCtrState object last changed. The initial value returned by this object is the time at which the APPN node instrumented with this MIB was last brought up.')
hprRtpTable = MibTable((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2), )
if mibBuilder.loadTexts: hprRtpTable.setStatus('current')
if mibBuilder.loadTexts: hprRtpTable.setDescription('The RTP Connection table')
hprRtpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1), ).setIndexNames((0, "HPR-MIB", "hprRtpLocNceId"), (0, "HPR-MIB", "hprRtpLocTcid"))
if mibBuilder.loadTexts: hprRtpEntry.setStatus('current')
if mibBuilder.loadTexts: hprRtpEntry.setDescription('The local NCE ID and local TCID are used to index this table.')
hprRtpLocNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: hprRtpLocNceId.setStatus('current')
if mibBuilder.loadTexts: hprRtpLocNceId.setDescription('The local Network Connection Endpoint (NCE) ID of this RTP connection. NCEs identify CPs, LUs, Boundary Functions (BFs), and Route Setup (RS) components. A value for this object can be retrieved from any of the following objects in the APPN MIB: - appnLsCpCpNceId - appnLsRouteNceId - appnLsBfNceId - appnIsInRtpNceId - appnIsRtpNceId In each case this value identifies a row in this table containing information related to that in the APPN MIB.')
hprRtpLocTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8))
if mibBuilder.loadTexts: hprRtpLocTcid.setStatus('current')
if mibBuilder.loadTexts: hprRtpLocTcid.setDescription('The local TCID of this RTP connection. A value for this object can be retrieved from either the appnIsInRtpTcid object or the appnIsRtpTcid object the APPN MIB; in each case this value identifies a row in this table containing information related to that in the APPN MIB.')
hprRtpRemCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 3), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRemCpName.setStatus('current')
if mibBuilder.loadTexts: hprRtpRemCpName.setDescription('Administratively assigned network name for the remote node of this RTP connection.')
hprRtpRemNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRemNceId.setStatus('current')
if mibBuilder.loadTexts: hprRtpRemNceId.setDescription('The remote Network Connection Endpoint (NCE) of this RTP connection. NCEs identify CPs, LUs, Boundary Functions (BFs), and Route Setup (RS) components.')
hprRtpRemTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRemTcid.setStatus('current')
if mibBuilder.loadTexts: hprRtpRemTcid.setDescription('The remote TCID of this RTP connection.')
hprRtpPathSwitchTrigger = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("switchPathNow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hprRtpPathSwitchTrigger.setStatus('current')
if mibBuilder.loadTexts: hprRtpPathSwitchTrigger.setDescription('Object by which a Management Station can trigger an operator- requested path switch, by setting the value to switchPathNow(2). Setting this object to switchPathNow(2) triggers a path switch even if its previous value was already switchPathNow(2). The value ready(1) is returned on GET operations until a SET has been processed; after that the value received on the most recent SET is returned. This MIB module provides no support for an operator-requested switch to a specified path.')
hprRtpRscv = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRscv.setStatus('current')
if mibBuilder.loadTexts: hprRtpRscv.setDescription('The forward Route Selection Control Vector for this RTP connection. The format of this vector is described in SNA Formats. The value returned in this object during a path switch is implementation-dependent: it may be the old path, the new path, a zero-length string, or some other valid RSCV string.')
hprRtpTopic = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpTopic.setStatus('current')
if mibBuilder.loadTexts: hprRtpTopic.setDescription('The topic for this RTP connection. This is used to indicate the Class of Service.')
hprRtpState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 99))).clone(namedValues=NamedValues(("rtpListening", 1), ("rtpCalling", 2), ("rtpConnected", 3), ("rtpPathSwitching", 4), ("rtpDisconnecting", 5), ("other", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpState.setStatus('current')
if mibBuilder.loadTexts: hprRtpState.setDescription("The state of the RTP connection, from the perspective of the local RTP protocol machine: rtpListening - connection open; waiting for other end to call in rtpCalling - connection opened, attempting to call out, have not yet received any data from other end rtpConnected - connection is active; responded to a call-in or received other end's TCID from a call-out attempt rtpPathSwitching - the path switch timer is running; attempting to find a new path for this connection. rtpDisconnecting - no sessions are using this connection; in process of bringing it down other - the connection is not in any of the states listed above.")
hprRtpUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 10), TimeTicks()).setUnits('1/100ths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpUpTime.setStatus('current')
if mibBuilder.loadTexts: hprRtpUpTime.setDescription('The length of time the RTP connection has been up, measured in 1/100ths of a second.')
hprRtpLivenessTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 11), Unsigned32()).setUnits('1/100ths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpLivenessTimer.setStatus('current')
if mibBuilder.loadTexts: hprRtpLivenessTimer.setDescription('The value of the liveness (ALIVE) timer of this RTP connection, in units of 1/100th of a second. When this timer expires and no packet has arrived from the partner since it was last set, packets with Status Request indicators will be sent to see if the RTP connection is still alive.')
hprRtpShortReqTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 12), Unsigned32()).setUnits('1/100ths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpShortReqTimer.setStatus('current')
if mibBuilder.loadTexts: hprRtpShortReqTimer.setDescription('The value of the RTP SHORT-REQ timer, in units of 1/100 of a second. This timer represents the maximum time that a sender waits for a reply from a receiver.')
hprRtpPathSwTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 13), Unsigned32()).setUnits('1/100ths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpPathSwTimer.setStatus('current')
if mibBuilder.loadTexts: hprRtpPathSwTimer.setDescription('The length of time that RTP should attempt a path switch for a connection, in units of 1/100th of a second.')
hprRtpLivenessTimeouts = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 14), HprRtpCounter()).setUnits('liveness timeouts').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpLivenessTimeouts.setStatus('current')
if mibBuilder.loadTexts: hprRtpLivenessTimeouts.setDescription('The count of liveness timeouts for this RTP connection.')
hprRtpShortReqTimeouts = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 15), HprRtpCounter()).setUnits('short request timeouts').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpShortReqTimeouts.setStatus('current')
if mibBuilder.loadTexts: hprRtpShortReqTimeouts.setDescription('The count of short request timeouts for this RTP connection.')
hprRtpMaxSendRate = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 16), Gauge32()).setUnits('bytes per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpMaxSendRate.setStatus('current')
if mibBuilder.loadTexts: hprRtpMaxSendRate.setDescription("The high-water mark for this RTP connection's send rate, in units of bytes per second. This is the high-water mark for the entire life of the connection, not just the high-water mark for the connection's current path. For more details on this and other parameters related to HPR, see the High Performance Routing Architecture Reference.")
hprRtpMinSendRate = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 17), Gauge32()).setUnits('bytes per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpMinSendRate.setStatus('current')
if mibBuilder.loadTexts: hprRtpMinSendRate.setDescription("The low-water mark for this RTP connection's send rate, in units of bytes per second. This is the low-water mark for the entire life of the connection, not just the low-water mark for the connection's current path. For more details on this and other parameters related to HPR, see the High Performance Routing Architecture Reference.")
hprRtpCurSendRate = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 18), Gauge32()).setUnits('bytes per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpCurSendRate.setStatus('current')
if mibBuilder.loadTexts: hprRtpCurSendRate.setDescription('The current send rate for this RTP connection, in units of bytes per second. For more details on this and other parameters related to HPR, see the High Performance Routing Architecture Reference.')
hprRtpSmRdTripDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 19), Gauge32()).setUnits('1/1000ths of a second').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpSmRdTripDelay.setStatus('current')
if mibBuilder.loadTexts: hprRtpSmRdTripDelay.setDescription('The smoothed round trip delay for this RTP connection, in units of 1/1000th of a second (ms). For more details on this and other parameters related to HPR, see the High Performance Routing Architecture Reference.')
hprRtpSendPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 20), HprRtpCounter()).setUnits('RTP packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpSendPackets.setStatus('current')
if mibBuilder.loadTexts: hprRtpSendPackets.setDescription('The count of packets successfully sent on this RTP connection.')
hprRtpRecvPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 21), HprRtpCounter()).setUnits('RTP packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRecvPackets.setStatus('current')
if mibBuilder.loadTexts: hprRtpRecvPackets.setDescription('The count of packets received on this RTP connection. The counter is incremented only once if duplicate copies of a packet are received.')
hprRtpSendBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 22), HprRtpCounter()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpSendBytes.setStatus('current')
if mibBuilder.loadTexts: hprRtpSendBytes.setDescription('The count of bytes sent on this RTP connection. Both RTP Transport Header (THDR) bytes and data bytes are included in this count.')
hprRtpRecvBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 23), HprRtpCounter()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRecvBytes.setStatus('current')
if mibBuilder.loadTexts: hprRtpRecvBytes.setDescription('The count of bytes received on this RTP connection. Both RTP Transport Header (THDR) bytes and data bytes are included in this count.')
hprRtpRetrPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 24), HprRtpCounter()).setUnits('RTP packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRetrPackets.setStatus('current')
if mibBuilder.loadTexts: hprRtpRetrPackets.setDescription('The count of packets retransmitted on this RTP connection.')
hprRtpPacketsDiscarded = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 25), HprRtpCounter()).setUnits('RTP packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpPacketsDiscarded.setStatus('current')
if mibBuilder.loadTexts: hprRtpPacketsDiscarded.setDescription('The count of packets received on this RTP connection and then discarded. A packet may be discarded because it is determined to be a duplicate, or for other reasons.')
hprRtpDetectGaps = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 26), HprRtpCounter()).setUnits('gaps').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpDetectGaps.setStatus('current')
if mibBuilder.loadTexts: hprRtpDetectGaps.setDescription('The count of gaps detected on this RTP connection.')
hprRtpRateReqSends = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 27), HprRtpCounter()).setUnits('rate requests').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpRateReqSends.setStatus('current')
if mibBuilder.loadTexts: hprRtpRateReqSends.setDescription('The count of Rate Requests sent on this RTP connection.')
hprRtpOkErrPathSws = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 28), HprRtpCounter()).setUnits('path switch attempts').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpOkErrPathSws.setStatus('current')
if mibBuilder.loadTexts: hprRtpOkErrPathSws.setDescription('The count of successful path switch attempts for this RTP connection due to errors.')
hprRtpBadErrPathSws = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 29), HprRtpCounter()).setUnits('path switch attempts').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpBadErrPathSws.setStatus('current')
if mibBuilder.loadTexts: hprRtpBadErrPathSws.setDescription('The count of unsuccessful path switches for this RTP connection due to errors.')
hprRtpOkOpPathSws = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 30), HprRtpCounter()).setUnits('path switches').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpOkOpPathSws.setStatus('current')
if mibBuilder.loadTexts: hprRtpOkOpPathSws.setDescription('The count of successful path switches for this RTP connection due to operator requests.')
hprRtpBadOpPathSws = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 31), HprRtpCounter()).setUnits('path switches').setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpBadOpPathSws.setStatus('current')
if mibBuilder.loadTexts: hprRtpBadOpPathSws.setDescription('The count of unsuccessful path switches for this RTP connection due to operator requests. This counter is not incremented by an implementation that does not support operator-requested path switches, even if a Management Station requests such a path switch by setting the hprRtpPathSwitchTrigger object.')
hprRtpCounterDisconTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 2, 1, 32), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpCounterDisconTime.setStatus('current')
if mibBuilder.loadTexts: hprRtpCounterDisconTime.setDescription('The value of the sysUpTime object when the counters for this RTP connection last experienced a discontinuity. This will be the more recent of two times: the time at which the connection was established or the time at which the HPR counters were last turned on or off.')
hprRtpStatusTable = MibTable((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3), )
if mibBuilder.loadTexts: hprRtpStatusTable.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusTable.setDescription('RTP Connection Status Table: This table contains historical information on RTP connections. An entry is created in this table when a path switch is completed, either successfully or unsuccessfully.')
hprRtpStatusEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1), ).setIndexNames((0, "HPR-MIB", "hprRtpStatusLocNceId"), (0, "HPR-MIB", "hprRtpStatusLocTcid"), (0, "HPR-MIB", "hprRtpStatusIndex"))
if mibBuilder.loadTexts: hprRtpStatusEntry.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusEntry.setDescription('This table is indexed by local NCE ID, local TCID, and an integer hprRtpStatusIndex. Thus the primary grouping of table rows is by RTP connection, with the multiple entries for a given RTP connection ordered by time.')
hprRtpStatusLocNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: hprRtpStatusLocNceId.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusLocNceId.setDescription('The local Network Connection Endpoint (NCE) of this RTP connection. NCEs identify CPs, LUs, Boundary Functions (BFs), and Route Setup (RS) components.')
hprRtpStatusLocTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8))
if mibBuilder.loadTexts: hprRtpStatusLocTcid.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusLocTcid.setDescription('The local TCID of this RTP connection.')
hprRtpStatusIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: hprRtpStatusIndex.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusIndex.setDescription('Table index. This value begins at one and is incremented when a new entry is added to the table. It is an implementation choice whether to run a single counter for all entries in the table, or to run a separate counter for the entries for each RTP connection. In the unlikely event of a wrap, it is assumed that Management Stations will have the ability to order table entries correctly.')
hprRtpStatusStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 4), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusStartTime.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusStartTime.setDescription('The time when the path switch began.')
hprRtpStatusEndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusEndTime.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusEndTime.setDescription('The time when the path switch was ended, either successfully or unsuccessfully.')
hprRtpStatusRemCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 6), SnaControlPointName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusRemCpName.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusRemCpName.setDescription('Administratively assigned network name for the remote node of this RTP connection.')
hprRtpStatusRemNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusRemNceId.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusRemNceId.setDescription('The remote Network Connection Endpoint (NCE) of this RTP connection. NCEs identify CPs, LUs, Boundary Functions (BFs), and Route Setup (RS) components.')
hprRtpStatusRemTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusRemTcid.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusRemTcid.setDescription('The remote TCID of this RTP connection.')
hprRtpStatusNewRscv = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusNewRscv.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusNewRscv.setDescription('The new Route Selection Control Vector for this RTP connection. A zero-length string indicates that no value is available, perhaps because the implementation does not save RSCVs.')
hprRtpStatusOldRscv = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusOldRscv.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusOldRscv.setDescription('The old Route Selection Control Vector for this RTP connection. A zero-length string indicates that no value is available, perhaps because the implementation does not save RSCVs.')
hprRtpStatusCause = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("rtpConnFail", 2), ("locLinkFail", 3), ("remLinkFail", 4), ("operRequest", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusCause.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusCause.setDescription('The reason for the path switch: other(1) - Reason other than those listed below, rtpConnFail(2) - RTP connection failure detected, locLinkFail(3) - Local link failure, remLinkFail(4) - Remote link failure (learned from TDUs), operRequest(5) - Operator requested path switch. ')
hprRtpStatusLastAttemptResult = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 6, 1, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("successful", 1), ("initiatorMoving", 2), ("directorySearchFailed", 3), ("rscvCalculationFailed", 4), ("negativeRouteSetupReply", 5), ("backoutRouteSetupReply", 6), ("timeoutDuringFirstAttempt", 7), ("otherUnsuccessful", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hprRtpStatusLastAttemptResult.setStatus('current')
if mibBuilder.loadTexts: hprRtpStatusLastAttemptResult.setDescription("The result of the last completed path switch attempt. If the path switch is aborted in the middle of a path switch attempt because the path switch timer expires, the result of the previous path switch attempt is reported. The values are defined as follows: successful(1) - The final path switch attempt was successful. initiatorMoving(2) - The final path switch attempt failed because the initiator is mobile, and there was no active link out of this node. directorySearchFailed(3) - The final path switch attempt failed because a directory search for the destination node's CP name failed. rscvCalculationFailed(4) - The final path switch attempt failed because an RSCV to the node containing the remote RTP endpoint could not be calculated. negativeRouteSetupReply(5) - The final path switch attempt failed because route setup failed for the new path. backoutRouteSetupReply(6) - The final path switch attempt failed because the remote RTP endpoint refused to continue the RTP connection. timeoutDuringFirstAttempt(7) - The path switch timer expired during the first path switch attempt. otherUnsuccessful(8) - The final path switch attempt failed for a reason other than those listed above.")
hprConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 2))
hprCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 2, 1))
hprGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 6, 2, 2))
hprCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 34, 6, 2, 1, 1)).setObjects(("HPR-MIB", "hprGlobalConfGroup"), ("HPR-MIB", "hprAnrRoutingConfGroup"), ("HPR-MIB", "hprTransportUserConfGroup"), ("HPR-MIB", "hprRtpConfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hprCompliance = hprCompliance.setStatus('current')
if mibBuilder.loadTexts: hprCompliance.setDescription('The compliance statement for the SNMPv2 entities that implement the HPR MIB.')
hprGlobalConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 6, 2, 2, 1)).setObjects(("HPR-MIB", "hprNodeCpName"), ("HPR-MIB", "hprOperatorPathSwitchSupport"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hprGlobalConfGroup = hprGlobalConfGroup.setStatus('current')
if mibBuilder.loadTexts: hprGlobalConfGroup.setDescription('A collection of objects providing the instrumentation of HPR general information and capabilities.')
hprAnrRoutingConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 6, 2, 2, 2)).setObjects(("HPR-MIB", "hprAnrsAssigned"), ("HPR-MIB", "hprAnrCounterState"), ("HPR-MIB", "hprAnrCounterStateTime"), ("HPR-MIB", "hprAnrType"), ("HPR-MIB", "hprAnrOutTgDest"), ("HPR-MIB", "hprAnrOutTgNum"), ("HPR-MIB", "hprAnrPacketsReceived"), ("HPR-MIB", "hprAnrCounterDisconTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hprAnrRoutingConfGroup = hprAnrRoutingConfGroup.setStatus('current')
if mibBuilder.loadTexts: hprAnrRoutingConfGroup.setDescription("A collection of objects providing instrumentation for the node's ANR routing.")
hprTransportUserConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 6, 2, 2, 3)).setObjects(("HPR-MIB", "hprNceType"), ("HPR-MIB", "hprNceDefault"), ("HPR-MIB", "hprNceInstanceId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hprTransportUserConfGroup = hprTransportUserConfGroup.setStatus('current')
if mibBuilder.loadTexts: hprTransportUserConfGroup.setDescription('A collection of objects providing information on the users of the HPR transport known to the node.')
hprRtpConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 6, 2, 2, 4)).setObjects(("HPR-MIB", "hprRtpGlobeConnSetups"), ("HPR-MIB", "hprRtpGlobeCtrState"), ("HPR-MIB", "hprRtpGlobeCtrStateTime"), ("HPR-MIB", "hprRtpRemCpName"), ("HPR-MIB", "hprRtpRemNceId"), ("HPR-MIB", "hprRtpRemTcid"), ("HPR-MIB", "hprRtpPathSwitchTrigger"), ("HPR-MIB", "hprRtpRscv"), ("HPR-MIB", "hprRtpTopic"), ("HPR-MIB", "hprRtpState"), ("HPR-MIB", "hprRtpUpTime"), ("HPR-MIB", "hprRtpLivenessTimer"), ("HPR-MIB", "hprRtpShortReqTimer"), ("HPR-MIB", "hprRtpPathSwTimer"), ("HPR-MIB", "hprRtpLivenessTimeouts"), ("HPR-MIB", "hprRtpShortReqTimeouts"), ("HPR-MIB", "hprRtpMaxSendRate"), ("HPR-MIB", "hprRtpMinSendRate"), ("HPR-MIB", "hprRtpCurSendRate"), ("HPR-MIB", "hprRtpSmRdTripDelay"), ("HPR-MIB", "hprRtpSendPackets"), ("HPR-MIB", "hprRtpRecvPackets"), ("HPR-MIB", "hprRtpSendBytes"), ("HPR-MIB", "hprRtpRecvBytes"), ("HPR-MIB", "hprRtpRetrPackets"), ("HPR-MIB", "hprRtpPacketsDiscarded"), ("HPR-MIB", "hprRtpDetectGaps"), ("HPR-MIB", "hprRtpRateReqSends"), ("HPR-MIB", "hprRtpOkErrPathSws"), ("HPR-MIB", "hprRtpBadErrPathSws"), ("HPR-MIB", "hprRtpOkOpPathSws"), ("HPR-MIB", "hprRtpBadOpPathSws"), ("HPR-MIB", "hprRtpCounterDisconTime"), ("HPR-MIB", "hprRtpStatusStartTime"), ("HPR-MIB", "hprRtpStatusEndTime"), ("HPR-MIB", "hprRtpStatusRemNceId"), ("HPR-MIB", "hprRtpStatusRemTcid"), ("HPR-MIB", "hprRtpStatusRemCpName"), ("HPR-MIB", "hprRtpStatusNewRscv"), ("HPR-MIB", "hprRtpStatusOldRscv"), ("HPR-MIB", "hprRtpStatusCause"), ("HPR-MIB", "hprRtpStatusLastAttemptResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hprRtpConfGroup = hprRtpConfGroup.setStatus('current')
if mibBuilder.loadTexts: hprRtpConfGroup.setDescription('A collection of objects providing the instrumentation for RTP connection end points.')
mibBuilder.exportSymbols("HPR-MIB", HprNceTypes=HprNceTypes, hprRtpGlobe=hprRtpGlobe, hprNodeCpName=hprNodeCpName, hprRtpMinSendRate=hprRtpMinSendRate, hprRtpPacketsDiscarded=hprRtpPacketsDiscarded, hprAnrRoutingEntry=hprAnrRoutingEntry, hprRtpRetrPackets=hprRtpRetrPackets, hprRtpStatusNewRscv=hprRtpStatusNewRscv, hprRtpRscv=hprRtpRscv, hprRtpDetectGaps=hprRtpDetectGaps, hprAnrRouting=hprAnrRouting, hprRtpGlobeCtrStateTime=hprRtpGlobeCtrStateTime, hprAnrPacketsReceived=hprAnrPacketsReceived, hprRtpStatusStartTime=hprRtpStatusStartTime, hprAnrCounterStateTime=hprAnrCounterStateTime, hprAnrRoutingTable=hprAnrRoutingTable, hprNceType=hprNceType, HprRtpCounter=HprRtpCounter, hprRtpUpTime=hprRtpUpTime, hprNceTable=hprNceTable, hprRtpStatusLocTcid=hprRtpStatusLocTcid, hprRtpRemCpName=hprRtpRemCpName, hprAnrsAssigned=hprAnrsAssigned, hprRtpLocNceId=hprRtpLocNceId, hprNceEntry=hprNceEntry, hprRtpCounterDisconTime=hprRtpCounterDisconTime, hprRtpLocTcid=hprRtpLocTcid, hprRtpLivenessTimeouts=hprRtpLivenessTimeouts, hprRtpStatusEndTime=hprRtpStatusEndTime, hprAnrType=hprAnrType, hprRtpEntry=hprRtpEntry, hprAnrOutTgDest=hprAnrOutTgDest, hprRtpCurSendRate=hprRtpCurSendRate, hprNceId=hprNceId, hprOperatorPathSwitchSupport=hprOperatorPathSwitchSupport, hprRtpRateReqSends=hprRtpRateReqSends, hprRtpPathSwitchTrigger=hprRtpPathSwitchTrigger, hprGroups=hprGroups, hprAnrRoutingConfGroup=hprAnrRoutingConfGroup, hprRtpRemNceId=hprRtpRemNceId, hprNceInstanceId=hprNceInstanceId, hprRtpStatusRemCpName=hprRtpStatusRemCpName, hprRtpGlobeConnSetups=hprRtpGlobeConnSetups, hprRtpStatusOldRscv=hprRtpStatusOldRscv, hprTransportUserConfGroup=hprTransportUserConfGroup, hprRtpMaxSendRate=hprRtpMaxSendRate, hprRtpOkErrPathSws=hprRtpOkErrPathSws, hprRtpConfGroup=hprRtpConfGroup, hprRtpTopic=hprRtpTopic, hprRtpStatusLastAttemptResult=hprRtpStatusLastAttemptResult, hprAnrCounterState=hprAnrCounterState, hprRtpSendBytes=hprRtpSendBytes, hprRtpSmRdTripDelay=hprRtpSmRdTripDelay, hprRtpGlobeCtrState=hprRtpGlobeCtrState, hprTransportUser=hprTransportUser, hprRtpTable=hprRtpTable, hprRtpState=hprRtpState, hprAnrCounterDisconTime=hprAnrCounterDisconTime, hprRtpRecvPackets=hprRtpRecvPackets, hprRtpRemTcid=hprRtpRemTcid, hprObjects=hprObjects, hprAnrLabel=hprAnrLabel, hprMIB=hprMIB, hprRtpStatusLocNceId=hprRtpStatusLocNceId, hprRtpBadOpPathSws=hprRtpBadOpPathSws, hprRtpStatusRemNceId=hprRtpStatusRemNceId, hprRtpStatusIndex=hprRtpStatusIndex, hprRtpPathSwTimer=hprRtpPathSwTimer, hprRtp=hprRtp, hprRtpStatusEntry=hprRtpStatusEntry, hprRtpStatusTable=hprRtpStatusTable, hprRtpOkOpPathSws=hprRtpOkOpPathSws, hprRtpLivenessTimer=hprRtpLivenessTimer, hprRtpRecvBytes=hprRtpRecvBytes, hprAnrOutTgNum=hprAnrOutTgNum, hprRtpStatusCause=hprRtpStatusCause, hprRtpStatusRemTcid=hprRtpStatusRemTcid, hprCompliances=hprCompliances, hprCompliance=hprCompliance, hprRtpShortReqTimeouts=hprRtpShortReqTimeouts, hprGlobalConfGroup=hprGlobalConfGroup, PYSNMP_MODULE_ID=hprMIB, hprConformance=hprConformance, hprNceDefault=hprNceDefault, hprRtpShortReqTimer=hprRtpShortReqTimer, hprRtpSendPackets=hprRtpSendPackets, hprGlobal=hprGlobal, hprRtpBadErrPathSws=hprRtpBadErrPathSws)

#
# PySNMP MIB module CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:44:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
MacAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "MacAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Counter32, Integer32, Counter64, NotificationType, ObjectIdentity, iso, MibIdentifier, ModuleIdentity, Unsigned32, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Counter32", "Integer32", "Counter64", "NotificationType", "ObjectIdentity", "iso", "MibIdentifier", "ModuleIdentity", "Unsigned32", "Bits", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanChassis, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanChassis")
chasInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 1))
chasPhysical = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 2))
chasController = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 3))
chasPowerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 4))
chasEnvmnt = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 5))
chasStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 6))
chasAccounting = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 7))
chasFanTray = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 8))
chasDateAndTime = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 9))
class XylanChasType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29))
    namedValues = NamedValues(("invalid", 1), ("other", 2), ("omni5", 3), ("omni9", 4), ("pizza", 5), ("micro", 6), ("omni5cell", 7), ("omni9cell", 8), ("omni5e", 9), ("omni9e", 10), ("pizport", 11), ("omni5wx", 12), ("omni9wx", 13), ("omni3wx", 14), ("os5024", 15), ("os4016", 16), ("os3032", 17), ("os2032", 18), ("os2016", 19), ("os1032", 20), ("os6032", 21), ("os5032", 22), ("xframe5", 23), ("xframe9", 24), ("xframe3", 25), ("os4024", 26), ("omnicore13", 27), ("oa408", 28), ("oa512", 29))

class XylanModuleSubunit(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("base", 1), ("hsm1", 2), ("hsm2", 3), ("csm3", 4))

class XylanModuleType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 252, 253, 254, 251, 250, 256, 257, 258, 259), SingleValueConstraint(260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 272, 273, 274, 280, 281, 282, 283, 276, 279, 275, 291, 292, 293))
    namedValues = NamedValues(("unknown", 1), ("invalid", 2), ("empty", 3), ("hsm", 4), ("mpm", 5), ("eni8", 6), ("eni16", 7), ("tni", 8), ("fddi", 9), ("cddi", 10), ("x100eni", 11), ("atm", 12), ("eni12", 13), ("eni6", 14), ("mpm2", 15), ("atmds3", 16), ("fddis", 17), ("atms", 18), ("atmutp", 19), ("esm8f", 20), ("esm12t", 21), ("tokf", 22), ("atm2m", 23), ("atm2s", 24), ("wsm", 25), ("wsmbri", 26), ("hsm2", 27), ("pizza", 28), ("tsmcd6", 29), ("csm", 30), ("res31", 31), ("hre", 32), ("e10m", 33), ("atme3", 34), ("e100fsfd", 35), ("e100fmfd", 36), ("e100txfd", 37), ("mpm1g", 38), ("pizprt", 39), ("esm32", 40), ("fcsm", 41), ("csmh", 42), ("csm12s", 43), ("csma12", 44), ("csma24", 45), ("p10U", 46), ("asm2", 47), ("puplink", 48), ("res49", 49), ("res50", 50), ("fddisc2", 51), ("atmce2s2t", 52), ("atmce2s2e", 53), ("atmds3ux", 54), ("atme3ux", 55), ("atmoc3ux", 56), ("atmt1ux", 57), ("atme1ux", 58), ("wsm2s", 59), ("wsm2snc", 60), ("wsmprit1", 61), ("wsmprie1", 62), ("csm12l", 63), ("meth12", 64), ("meth32", 65), ("e1008pm", 66), ("e1008ps", 67), ("hsm3", 68), ("csmu", 69), ("e12f", 70), ("e12o", 71), ("csm6m2s", 72), ("atmsux", 73), ("atm2sux", 74), ("atm2mux", 75), ("atmuux", 76), ("atmshfs", 77), ("atm2rm", 78), ("atm2rs", 79), ("atmsrm", 80), ("atmsrs", 81), ("fesmh2m", 82), ("fesmh2s", 83), ("fesm4", 84), ("csm8c", 85), ("atm2sl", 86), ("csmfsl", 87), ("csmsfsl", 88), ("csm12fsl", 89), ("pme8", 90), ("pme32", 91), ("p5024", 92), ("p4016", 93), ("p3032", 94), ("p3032X", 95), ("p2032", 96), ("p2016", 97), ("p1032", 98), ("p1032F", 99), ("fcsm622", 100), ("cab155", 101), ("cab155fsl", 102), ("cab155c", 103), ("cab155s", 104), ("cabds1", 105), ("cabds3", 106), ("cabe1", 107), ("cabe3", 108), ("cabcee1", 109), ("cabcet1", 110), ("esxfm24", 111), ("tsmcd16", 112), ("tsmcd32", 113), ("tsm1g", 114), ("p1032cf", 115), ("cab4imat1", 116), ("cab4imae1", 117), ("cab8imat1", 118), ("cab8imae1", 119), ("mpmc", 120), ("mpmf", 121), ("mpmos", 122), ("atm2622s", 123), ("atm2622m", 124), ("atm2622sl", 125), ("ptsmcd16", 126), ("ptsmcd32", 127), ("atm2622rfsh", 128), ("mt12", 129), ("esmf8", 130), ("esmf16", 131), ("atm155fshe", 132), ("atm155fsh", 133), ("pme32r", 134), ("pme2", 135), ("gsmfm", 136), ("gsmfms", 137), ("gsmfmh", 138), ("cabt12m2", 139), ("cabt12m1", 140), ("cabt12s2", 141), ("cabt12s1", 142), ("cabt12l2", 143), ("cabt12l1", 144), ("cabt12c2", 145), ("cabt12c1", 146), ("cabt12ds32", 147), ("cabt12ds31", 148), ("cabt12e32", 149), ("cabt12e31", 150), ("cabcm", 151), ("cabce4sp", 152), ("esxc12", 153), ("esxc16", 154), ("esxc32", 155), ("esxf16", 156), ("gsxs2", 157), ("gsxs4", 158), ("gsxm2", 159), ("gsxm4", 160), ("gsxl2", 161), ("gsxl4", 162), ("tsxcd16", 163), ("tsxcd32", 164), ("etel24", 165), ("atm2155mu", 166), ("atm2155su", 167), ("atm2155fu", 168), ("atm2ds3u", 169), ("atm2e3u", 170), ("atm2t1u", 171), ("atm2e1u", 172), ("atm2utpu", 173), ("pizza6032", 174), ("pizza5032", 175), ("gsmx1", 176), ("esxfm12", 177), ("esxfm24a", 178), ("hsx", 179), ("pizza6032x", 180), ("pmfe32r", 181), ("os4024g", 182), ("os4024f", 183), ("os4024cf", 184), ("os4024c", 185), ("pmfe24", 186), ("gsmfm2", 187), ("gsmfs2", 188), ("esm100c32", 189), ("wsxm013", 190), ("asxrfm622", 191), ("asxrfs622", 192), ("atm2imat1u", 193), ("atm2imae1u", 194), ("atmcest12", 195), ("atmcese12", 196), ("esx100fm12", 197), ("esx100fs12", 198), ("csma122", 199), ("pfe", 200), ("osgsmfm2", 201), ("osgsmfs2", 202), ("atm2ds3", 203), ("atm2e3", 204), ("cop", 205), ("vsd", 206), ("mpo", 207), ("mpm3", 208), ("atm2155rfmce", 209), ("atm2ceds3x", 210), ("atm2155fmx", 211), ("atm2155fsx", 212), ("atm2155flx", 213), ("atm2155rsx", 214), ("atm2155rlx", 215), ("gso6", 216), ("os6000", 217), ("os6032e", 218), ("oa408", 219), ("oa512", 220), ("oa512u", 221), ("ocmbpc", 222), ("ocd12cmid", 223), ("hsxh", 224), ("oapmfe8", 225), ("oa4cet1", 226), ("oa4cee1", 227), ("oa408ce", 228), ("oa5xx", 229), ("oa5xxesm", 230), ("oa5xxwan", 231), ("oa5xxser", 232), ("oa5xxisdnst", 233), ("oa5xxisdnu", 234), ("oa5xxft1e1", 235), ("oa5xxvoip", 236), ("cabfrds18", 237), ("cabfre18", 238), ("cabfrsp4", 239), ("wsxds32", 240), ("asxu", 241), ("asxab622fm2", 242), ("asxab622fs2", 243), ("cabtds3", 244), ("cabte3", 245), ("mpx3", 246), ("kesxfm16", 252), ("kesxfs16", 253), ("kesxc32", 254), ("kgsxm2", 251), ("vsdplus", 250), ("csou", 256), ("ocab155c", 257), ("ocab155fm", 258), ("ocab155fs", 259)) + NamedValues(("ocab155fsh", 260), ("ocab622fm", 261), ("ocab622fs", 262), ("ocab622fsh", 263), ("ocab2488fs", 264), ("ocab2488fsh", 265), ("mpoatmdc", 266), ("hrevx", 267), ("vsa", 268), ("asxelsy", 269), ("asxasmk622", 270), ("kgsxs2", 272), ("kgsxsh2", 273), ("modTypeVsd128MB12CH", 274), ("modTypeVsd128MB24CH", 280), ("modTypeVsd128MB36CH", 281), ("modTypeVsd128MB48CH", 282), ("modTypeVsd128MB60CH", 283), ("modTypeVsb", 276), ("modTypeVsaFxs", 279), ("modTypeVsaFxo", 275), ("modTypeVsaFxsFxs", 291), ("modTypeVsaFxsFxo", 292), ("modTypeVsaFxoFxo", 293))

class XylanMPMStateType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("invalid", 2), ("primary", 3), ("secondary", 4))

class XylanPSStateType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("notPresent", 2), ("okay", 3), ("bad", 4))

class XylanTempStateType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("notPresent", 2), ("overThreshold", 3), ("underThreshold", 4))

class XylanImageSyncStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("insync", 1), ("newer", 2), ("older", 3), ("unknown", 4), ("syncing", 5))

class XylanConfigSyncStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("insync", 1), ("newer", 2), ("older", 3), ("unknown", 4), ("syncing", 5), ("bootvalues", 6))

class XylanConfigSyncEnable(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class XylanFFSFileAction(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("writingTo", 2), ("deletingFrom", 3), ("readingFrom", 4))

class XylanFFSFileActionStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("inProgress", 2), ("successfull", 3), ("failed", 4))

class XylanSerialPortSpeed(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("unknown", 1), ("invalid", 2), ("b1200", 3), ("b9600", 4), ("b19200", 5), ("b38400", 6))

class XylanSerialPortParity(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("none", 2), ("even", 3), ("odd", 4))

class XylanSerialPortMode(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("down", 1), ("console", 2), ("slip", 3))

class XylanFTStateType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("notPresent", 2), ("okay", 3), ("bad", 4))

chasMake = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasMake.setStatus('mandatory')
if mibBuilder.loadTexts: chasMake.setDescription("An authoritative identification of this chassis or device. By convention, this value is allocated within the SMI enterprises subtree(1.3.6.1.4.1), and provides an easy and unambiguous means for determining `what kind of box' is being managed. If this information is not present or unknown, its value should be set to chasTypeUnknown.")
chasType = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 2), XylanChasType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasType.setStatus('mandatory')
if mibBuilder.loadTexts: chasType.setDescription('The particular type of Xylan chassis. The value of other(2) will be returned if the variable is supported but the chassis is not one of the currently known types of Omni5(3) or Omni9(4).')
chasDescription = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasDescription.setStatus('mandatory')
if mibBuilder.loadTexts: chasDescription.setDescription('A description for this chassis/product. The value shall default to the textual product description, but the user can override this to anything desired.')
chasPhysicalChanges = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPhysicalChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasPhysicalChanges.setDescription('Depicts the number of physical changes that have occured to the chassis MIB since reset or power on. This includes additions and removal of modules in the module table or additions and removal of controllers in the controller table.')
chasLogicalChanges = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLogicalChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasLogicalChanges.setDescription('Depicts the number of logical changes that have occured to the chassis MIB since reset or power on. This includes all sets to name strings.')
chasNoOfResets = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasNoOfResets.setStatus('mandatory')
if mibBuilder.loadTexts: chasNoOfResets.setDescription('This object is a count of the number of times this this station has been reset since a cold-start.')
chasBaseMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBaseMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chasBaseMacAddress.setDescription("This object is the 'base' MAC address for this chassis.")
chasFreeSlots = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasFreeSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chasFreeSlots.setDescription('The number of free front panel slots.')
chasIpAddrToPing = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasIpAddrToPing.setStatus('mandatory')
if mibBuilder.loadTexts: chasIpAddrToPing.setDescription('The IP address to which a ping should be issued. A Network Management Station can use this to issue directed broadcast pings so as to augment the IP ARP table. The ARP table is useful in discovering the IP network topology.')
chasDupMacSupport = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasDupMacSupport.setStatus('mandatory')
if mibBuilder.loadTexts: chasDupMacSupport.setDescription('The number of Duplication of any single MAC address learned. 0 indicates no duplicate MAC support, 1 up to 64 indicates the number of duplication allowed per board. The value of 1 indicates no duplication allowed per board only, but it is allowed between boards for the entire chassis.')
chasNewDupMacSupport = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasNewDupMacSupport.setStatus('mandatory')
if mibBuilder.loadTexts: chasNewDupMacSupport.setDescription('This variable allows the user to cause duplicate MAC addresses to age out concurrently. If set to zero, it is ignored and the aging timer for each group where the address was learned will be used. Values 1 through 9 are not valid. If set to a value between 10 and 1000000, it will be used instead of the group aging timers. Units are seconds. ')
chasSonetMonitoring = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSonetMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: chasSonetMonitoring.setDescription('on(1) - Start Sonet Monitoring. If the image file (sec.img) is not loaded, this variable should be set to load it. off(2) - Stop Sonet Monitoring.')
chasVbusMode = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasVbusMode.setStatus('mandatory')
if mibBuilder.loadTexts: chasVbusMode.setDescription('The Vbus header type used in the OSR. A value of 0 indicates classic Vbus Mode is currently selected . 1 indicates the use of VBUS Mode 2.')
chasCurrentDateAndTime = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 9, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasCurrentDateAndTime.setStatus('mandatory')
if mibBuilder.loadTexts: chasCurrentDateAndTime.setDescription("Current date and time. Format - yyyymmddThhmmss yyyy - year, mm - month, dd - day, 'T' separator, hh - hour, mm - month, ss - second.")
chasTimezoneName = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 9, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasTimezoneName.setStatus('mandatory')
if mibBuilder.loadTexts: chasTimezoneName.setDescription('String containing the time zone name. nzst - New Zealand Time aest - Australia East Time gst - Guam Time acst - Australia Central Time jst - Japan Time kst - Korean Time awst - Australia West Time msk - Moscow Time eet - Eastern European Time cet - Central European Time met - Middle European Time bst - British Time wet - Western European Time gmt - Greenwich Mean Time wat - West Africa Time nst - Newfoundland Time ast - Atlantic Time est - Eastern Time (USA) cst - Cnetral Time (USA) mst - Mountain Time (USA) pst - Pacific Time (USA) akst - Alaska Time hst - Hawaii Time Returns none is not set.')
chasTimezoneOffset = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 9, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-780, 720))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasTimezoneOffset.setStatus('mandatory')
if mibBuilder.loadTexts: chasTimezoneOffset.setDescription('Time zone offset + or - minutes from UTC.')
chasTimezoneDstAdmin = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasTimezoneDstAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: chasTimezoneDstAdmin.setDescription('Daylight Savings Time enable/disable.')
chasTimezoneDst = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 9, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasTimezoneDst.setStatus('mandatory')
if mibBuilder.loadTexts: chasTimezoneDst.setDescription('Time and date information for the chassis. wdmmhhmmwdmmhhmmHHMM | start|| end ||offset| w-d-mm,hh:mm,w-d-mm,hh:mm,HH:MM w - Week (first(1), second(2), third(3), fourth(4), last(>4)) d - Day (Sunday(1), ..., Saturday(7)) m - Month (January(1), ..., December(12)) hh:mm - time of day DST changes (0-23:0-59) HH:MM - offset DST changes by. (0-23:0-59) Example: 11040200611002000100 - Starts First Sunday in April at 2:00 Ends Last Sunday in October at 2:00 Time changes by 1:00 hr. Returns disabled if disabled.')
chasModuleTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1), )
if mibBuilder.loadTexts: chasModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleTable.setDescription('A list of installed modules in this chassis.')
chasModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1), ).setIndexNames((0, "CHASSIS-MIB", "chasModuleSlot"), (0, "CHASSIS-MIB", "chasModuleSubUnit"))
if mibBuilder.loadTexts: chasModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleEntry.setDescription("A module entry containing objects for a particular module. This would contain entries that relate to the module in a specific 'slot'.")
chasModuleSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleSlot.setDescription('The (zero-based) front slot number within the chassis.')
chasModuleSubUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 2), XylanModuleSubunit()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleSubUnit.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleSubUnit.setDescription("The sub-unit number within module in slot 'n'. For each non-empty slot there will exist a module entry with a chasModuleSubUnit value of base. If the chasModuleType of that chasModuleEntry is hsm, then there may be additional chasModuleEntrys with the same chasModuleSlot value but with chasModuleSubUnit values of hsm1, hsm2 or csm3. These are HSM or CSM-U sub-modules. An HSM module can have up to 2 daughter cards on it. The first position would be denoted by hsm1(2) and the second position is hsm2(3). A CSM-U module can have up to 3 daughter cards on it.The first position would be denoted by hsm1(2) and the second position is hsm2(3) and the third postion is csm3(4). The general implication of this field is: each occupied slot will have an entry field will be base(1), and may if the module supports daughter cards have entries for which if this field is hsm1(2), hsm2(3) or cms3(4), corrosponding to an installed daughter card on the HSM or CMS-U in the specified chasModuleSlot. (and the card type will be listed in chasModuleType).")
chasModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 3), XylanModuleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleType.setDescription('An authoritative identification of the type of physical module that is in this physical location. Notice that the value empty(3) will not be seen in this table, because this table will only have entries that contain modules.')
chasModulePartNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModulePartNum.setStatus('mandatory')
if mibBuilder.loadTexts: chasModulePartNum.setDescription('The part number of ths module.')
chasModuleDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasModuleDescription.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleDescription.setDescription('Textual description of this particular module. The user can change this value to whatever is desired.')
chasModuleHwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleHwRevision.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleHwRevision.setDescription("The current revision of this module's hardware.")
chasModuleHwModLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleHwModLevel.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleHwModLevel.setDescription("The modification level of this module's hardware.")
chasModuleSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleSerialNumber.setDescription('The serial number of the module present in this physical location.')
chasModuleMfgDate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleMfgDate.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleMfgDate.setDescription('The manufacturing date for this module. This data is retrieved from the module non-volitile memory.')
chasModuleFwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleFwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleFwVersion.setDescription("Textual decription of the version/revision level for this module's firmware/software.")
chasModuleBaseMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 11), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleBaseMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleBaseMacAddress.setDescription("This is the 'base' MAC address for this module. If the module does not support the notion of MAC addresses, the vaule shall be 0.")
chasModuleTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleTimeStamp.setDescription('The value of sysUpTime of this management entitiy, when this module was last (re-) initialized.')
chasModuleAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("invalid", 2), ("enable", 3), ("disable", 4), ("reset", 5), ("load", 6), ("test", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasModuleAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleAdminStatus.setDescription('Provides desired (and actual) state of the given module. Notice that not all values may be supported by a specified physical module. In this case an SNMP error returned when a set is attempted. All modules (even empty slots) are in an unknown(1) state when the chassis first powers up. The invalid state is for non-existant modules, and hence is never seen. Neither of the unknown(1) or invalid(2) status values can be written. A physical module can be activated by writing a value of enable(3). A physical module may be de-activated by writing a value of disable(4). In a disabled state, the module is present in the chassis, but is benign. A disabled module is availible for subsequent activation. Writing a value of reset(5), disables the module AND initiates a reset sequence. Writing a value of load(6), disables the module AND initiates a software load sequence. Writing a value of test(7), disables the module AND initiates selftest within the module.')
chasModuleOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", 1), ("invalid", 2), ("operational", 3), ("disabled", 4), ("resetInProgress", 5), ("loadInProgress", 6), ("testing", 7), ("warning", 8), ("nonFatalError", 9), ("fatalError", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleOperStatus.setDescription("Provides operational state of the given module. The exact definition of the values is implementation specific. A value of unknown(1) implies some undetermined state, possibly as a result of a module failing the low-level selftest. A value of invalid(2) may mean that the module exists but the chassis manager has no direct control over it. A value of operational(3) implies that the entity is running with no errors or warnings. A value of disabled(4) reflects the response to the chasModuleAdminStatus of disable(4). A value of resetInProgress(5) also reflects the equivalent AdminStatus reset(5). Note that the states warning(8), nonFatalError(9), and fatalError(10) reflect conditions detected during operation. The module may or may not be fuctional at this point. For example a module's value of AdminStatus is disable(4), the OperStatus will reflect that. The AdminStatus is set to enable(3), the OperStatus might then change to testing(7) then change to operational(3).")
chasModuleLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleLedStatus.setDescription('The LED state for this module. The exact definition of the values are implimentation dependent. For example, a power supply module may not have any LEDs present, while a network interface element might have 28 LEDs and a Controller might have 6 LEDs. NOTE: due to European regulation, the LEDs will NEVER be illuminated RED! They in fact will be either green OR amber. This will be reflected in the MIB as either GRN=1/RED=0 or GRN=1/RED=1. Of course, if both are off then the LED is not illuminated. The current bit definitions for the defined modules are: mpm 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - PS1 RED (0 off, 1 on) 3 - PS2 RED (0 off, 1 on) 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - PS1 GRN (0 off, 1 on) 7 - PS2 GRN (0 off, 1 on) 8 - PRI MPM GRN (0 on, 1 off) 9 - SEC MPM GRN (0 on, 1 off) 10 - TEMP ALARM AMBER (0 on, 1 off) 11-21 - undefined 22 - HRE PRESENT (1 yes, 0 no) 23 - BUS SPEED (1 960, 0 640) 24-31 - reserved pizza 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2-3 - unused 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - HSM1 GRN (0 off, 1 on) 7 - HSM2 GRN (0 off, 1 on) 8-31 - reserved eni8 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined 8-15 - reserved 16 - STA1 GRN 17 - STA2 GRN 18 - STA3 GRN 19 - STA4 GRN 20 - STA5 GRN 21 - STA6 GRN 22 - STA7 GRN 23 - STA8 GRN mesm8 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined 8 - 1 = Full Duplex Port 1 9 - 1 = Full Duplex Port 2 10 - 1 = Full Duplex Port 3 11 - 1 = Full Duplex Port 4 12 - 1 = Full Duplex Port 5 13 - 1 = Full Duplex Port 6 14 - 1 = Full Duplex Port 7 15 - 1 = Full Duplex Port 8 16 - 1 = STA1 GRN 17 - 1 = STA2 GRN 18 - 1 = STA3 GRN 19 - 1 = STA4 GRN 20 - 1 = STA5 GRN 21 - 1 = STA6 GRN 22 - 1 = STA7 GRN 23 - 1 = STA8 GRN mesm12 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined 8 - 1 = STA1 GRN 9 - 1 = STA2 GRN 10 - 1 = STA3 GRN 11 - 1 = STA4 GRN 12 - 1 = STA5 GRN 13 - 1 = STA6 GRN 14 - 1 = STA7 GRN 15 - 1 = STA8 GRN 16 - 1 = STA9 GRN 17 - 1 = STA10 GRN 18 - 1 = STA11 GRN 19 - 1 = STA12 GRN 20-23 - reserved mesm16 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined 8 - 1 = STA1 GRN 9 - 1 = STA2 GRN 10 - 1 = STA3 GRN 11 - 1 = STA4 GRN 12 - 1 = STA5 GRN 13 - 1 = STA6 GRN 14 - 1 = STA7 GRN 15 - 1 = STA8 GRN 16 - 1 = STA9 GRN 17 - 1 = STA10 GRN 18 - 1 = STA11 GRN 19 - 1 = STA12 GRN 20 - 1 = STA13 GRN 21 - 1 = STA14 GRN 22 - 1 = STA15 GRN 23 - 1 = STA16 GRN eni12 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined 8 - STA1 GRN (1 on, 0 off) 9 - STA2 GRN (1 on, 0 off) 10 - STA3 GRN (1 on, 0 off) 11 - STA4 GRN (1 on, 0 off) 12 - STA5 GRN (1 on, 0 off) 13 - STA6 GRN (1 on, 0 off) 14 - STA7 GRN (1 on, 0 off) 15 - STA8 GRN (1 on, 0 off) 16 - STA9 GRN (1 on, 0 off) 17 - STA10 GRN (1 on, 0 off) 18 - STA11 GRN (1 on, 0 off) 19 - STA12 GRN (1 on, 0 off) 20-31 - reserved eni16 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6-7 - undefined 8 - ENB1 (1 - yes, 0 - no) 9 - ENB2 (1 - yes, 0 - no) 10 - ENB3 (1 - yes, 0 - no) 11 - ENB4 (1 - yes, 0 - no) 12 - ENB5 (1 - yes, 0 - no) 13 - ENB6 (1 - yes, 0 - no) 14 - ENB7 (1 - yes, 0 - no) 15 - ENB8 (1 - yes, 0 - no) 16 - ENB9 (1 - yes, 0 - no) 17 - ENB10 (1 - yes, 0 - no) 18 - ENB11 (1 - yes, 0 - no) 19 - ENB12 (1 - yes, 0 - no) 20 - ENB13 (1 - yes, 0 - no) 21 - ENB14 (1 - yes, 0 - no) 22 - ENB15 (1 - yes, 0 - no) 23 - ENB16 (1 - yes, 0 - no) 24-31 - reserved tni 0-11 - reserved 12 - Status_1 LED (0 = ON) 13 - Status_2 LED (0 = ON) 14 - Status_3 LED (0 = ON) 15 - Status_4 LED (0 = ON) 16 - Status_5 LED (0 = ON) 17 - Status_6 LED (0 = ON) 18 - Beacon_1 LED (0 = ON) 19 - Beacon_2 LED (0 = ON) 20 - Beacon_3 LED (0 = ON) 21 - Beacon_4 LED (0 = ON) 22 - Beacon_5 LED (0 = ON) 23 - Beacon_6 LED (0 = ON) 24-31 - undefined hsm 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6-31 - reserved fddi 0-3 - reserved 4 - LINK (0 flash (DISABLED), 1 on (ENABLED)) 5 - WRAP B LED (0 on, 1 off) 6 - WRAP A LED (0 on, 1 off) 7 - THRU LED (0 on, 1 off) 8-31 - reserved cddi 0-7 - reserved 8-9 - Link LED A 00 - off, x1 - on, 10 - flash 10-11 - Link LED B 00 - off, x1 - on, 10 - flash 12-13 - Link LED C 00 - off, x1 - on, 10 - flash 14-15 - Link LED D 00 - off, x1 - on, 10 - flash 16-31 - reserved for example, the value 0xD8xx indicates Link LED A - off Link LED B - flashing Link LED C - on Link LED D - on atm 0-3 - reserved 4 - FAR END (0 on, 1 off) 5 - YELLOW ALARM LED (0 on, 1 off) 6 - RED ALARM LED (0 on, 1 off) 7 - CELL ERROR LED (0 on, 1 off) 8 - Link (1 Green, 0 off) 9-31 - reserved atm2155fmx, These are ATM OC3/DS3 Uplink Cards for OA408 atm2155fsx, atm2155flx, atm2ds3u, atm2e3u: 0-3 - reserved - off yellow green 4-5 00 01 11 6-31 - reserved atm2155rsx, These are ATM OC3 Uplink Cards with redundant ports for OA408 atm2155rlx: 0-3 - reserved - off yellow green 4-5 LINK1 00 01 11 6-7 LINK2 00 01 11 8-31 - reserved fesm 0-6 - reserved 6 - STA On (1 on, 0 off) 7 - STA Flash (1 Flash, 0 solid) (Not used) 8 - LINK1 On (1 on, 0 off) 9 - LINK1 Flash (1 Flash, 0 solid) (Not used) -- The following are for Copper Only 10 - LINK2 On (1 on, 0 off) 11 - LINK2 Flash (1 Flash, 0 solid) (Not used) 12 - LINK3 On (1 on, 0 off) 13 - LINK3 Flash (1 Flash, 0 solid) (Not used) 14 - LINK4 On (1 on, 0 off) 15 - LINK4 Flash (1 Flash, 0 solid) (Not used) 16 - Full Duplex (1) Half Duplex (0) 17-31 - reserved wsm 0-7 - reserved - off blink slow blink on 8-9 - STA1 00 01 10 11 10-11 - STA2 00 01 10 11 12-13 - STA3 00 01 10 11 14-15 - STA4 00 01 10 11 16-17 - STA5 00 01 10 11 18-19 - STA6 00 01 10 11 20-21 - STA7 00 01 10 11 22-23 - STA8 00 01 10 11 24-31 - reserved csm 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined 8-23 - port = bit - 7; - 0 - port down, LINK OFF, RED Amber - 1 - port up, LINK Green, RED OFF 24-31 - unused cabcm 0-7 - reserved off blink on 8-9 LINK1 00 01 11 10-31 - reserved fcsm 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6-31 - unused atmce2s2t, atmce2s2e 0-7 - reserved 8 - LINK1 (1 on, 0 off) 9 - ERR1 (1 on, 0 off) 10 - LINK2 (1 on, 0 off) 11 - ERR2 (1 on, 0 off) - off blink on 12-13 - STA1 00 01 11 14-15 - STA2 00 01 11 16-31 - reserved csmu 0 - OK1 RED (0 off, 1 on) 1 - OK2 RED (0 off, 1 on) 2 - undefined 3 - undefined 4 - OK1 GRN (0 off, 1 on) 5 - OK2 GRN (0 off, 1 on) 6 - undefined 7 - undefined cabds3: cabe3: 0-7 - reserved off yellow green 8-9 LINK1 00 01 11 10-11 LINK2 00 01 11 12-31 - reserved atm2imat1u: for OA408 atm2imae1u: for OA408 cabds1: cabe1: cabcet1: cabcee1: 0-7 - reserved off yellow green 8-9 LINK1 00 01 11 10-11 LINK2 00 01 11 12-13 LINK3 00 01 11 14-15 LINK4 00 01 11 16-31 - reserved oa4cet1: 0-7 - reserved oa4cee1: off yellow green 8-9 LINK1 00 01 11 10-11 LINK2 00 01 11 12-13 PORT3 00 01 11 14-15 PORT4 00 01 11 16-31 - reserved cab4imat1: cab4imae1: cab8imat1: cab8imae1: 0-7 - reserved off yellow green 8-9 LINK1 00 01 11 10-11 LINK2 00 01 11 12-13 LINK3 00 01 11 14-15 LINK4 00 01 11 16-17 LINK5 00 01 11 18-19 LINK6 00 01 11 20-21 LINK7 00 01 11 22-23 LINK8 00 01 11 24-31 - reserved Other modules will be defined later.')
chasModuleVbusTxDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleVbusTxDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleVbusTxDiscards.setDescription('The current count of transmit VBUS buffer overruns.')
chasModuleVbusRxDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleVbusRxDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleVbusRxDiscards.setDescription('The current count of receive VBUS buffer overruns.')
chasModuleLedStatusExtend = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 2, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasModuleLedStatusExtend.setStatus('mandatory')
if mibBuilder.loadTexts: chasModuleLedStatusExtend.setDescription('A octet string containing module led information')
chasControlTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1), )
if mibBuilder.loadTexts: chasControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlTable.setDescription('A list of Module controller status. NOTE: Objects with ACCESS of read-write which are associated with configuration data which presists accross reboots are in fact only valid for the Primary MPM. If the Secondary MPM has different values this information is not available to snmp queries, nor is it possible to write to the Secondaries instance of these objects. Further, once the cconfigured data is sychronized from the Primary to the Secondary, all values set on the Primary will be those used by the Secondary after the Secondary is reset. There is no ability to change a value for the Secondary except by changinging it on the Primary and then writing the configuation of the Primary to the Secondary.')
chasControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1), ).setIndexNames((0, "CHASSIS-MIB", "chasControlSlot"))
if mibBuilder.loadTexts: chasControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEntry.setDescription('A controller entry containing objects for a particular controller.')
chasControlSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlSlot.setDescription('The physical slot number for this controller card. This is the same as chasModuleSlot.')
chasControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 2), XylanMPMStateType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlState.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlState.setDescription('Provides desired (and actual) state of the given controller module. The unknown state may be returned if the controller is not present or offline. A controller may be placed into the Primary state by writing a value of primary(3). Note that most implimentations will verify that only one controller is active; thus, setting this will automatically place all other controllers into the secondary state. A controller may be placed into the secondary state by writing a value of secondary(4). The system will ensure two modules are present and that the secondary is capable of entering the primary state.')
chasControlDCEPortRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 3), XylanSerialPortSpeed()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDCEPortRate.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDCEPortRate.setDescription('This is the current (and desired) baud rate for the DCE (console) serial port 1. The power-on default rate is 9600 b/s.')
chasControlDCEWordSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDCEWordSize.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDCEWordSize.setDescription('This is the current (and desired) word size for serial port 0 (DCE). The power-on default is 8 bits.')
chasControlDCEStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDCEStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDCEStopBits.setDescription('This is the current (and desired) number of stop bits for serial port 0 (DCE). The power-on default is 1 bit.')
chasControlDCEParity = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 6), XylanSerialPortParity()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDCEParity.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDCEParity.setDescription('This is the current (and desired) parity for serial port 0 (DCE). The power-on default rate is NONE.')
chasControlDTEPortRate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 7), XylanSerialPortSpeed()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDTEPortRate.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDTEPortRate.setDescription('This is the current (and desired) baud rate for the DTE (modem) serial port 0. The power-on default rate is 9600 b/s.')
chasControlDTEWordSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDTEWordSize.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDTEWordSize.setDescription('This is the current (and desired) word size for serial port 1 (DTE). The power-on default is 8 bits.')
chasControlDTEStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDTEStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDTEStopBits.setDescription('This is the current (and desired) number of stop bits for serial port 1 (DTE). The power-on default is 1 bit.')
chasControlDTEParity = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 10), XylanSerialPortParity()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlDTEParity.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDTEParity.setDescription('This is the current (and desired) parity for serial port 1 (DTE). The power-on default rate is NONE.')
chasControlIPAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlIPAdd.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlIPAdd.setDescription("The IP address for this MPM and it's snmp agent.")
chasControlBootCode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlBootCode.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlBootCode.setDescription('FW boot code to load on reset for this controller.')
chasControlFreeFFS = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFreeFFS.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFreeFFS.setDescription('The current free Flash File System space.')
chasControlFreeBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFreeBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFreeBuffers.setDescription('The current software does not pool a specific number of buffers. Therefore this object is obsolete.')
chasControlBufferUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlBufferUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlBufferUtilization.setDescription('The current software does not pool a specific number of buffers. Therefore this object is obsolete.')
chasControlCPUUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlCPUUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlCPUUtilization.setDescription('The current CPU utilization for this controller.')
chasControlImageSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlImageSuffix.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlImageSuffix.setDescription("This character string will be used to determine which file is downloaded to the NIs to be brought up by the chassis manager. Only files with suffixes (the part of the file name following '.') matching this character string will be downloaded to NIs which are inserted into the chassis or reset. If the chassis is rebooted these files will be used for the initial NI loads. This value can only be set on the Primary MPM. If automatic synchronization is enabled and the required image files on the Secondary match those on the Primary (State is Redundant or CONFIG FB) then the value set will be copied to the Secondary after the first 5min period of no configuration updates or when a configsync is envoked.")
chasControlImageSyncStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 18), XylanImageSyncStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlImageSyncStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlImageSyncStatus.setDescription("For the Primary this means: insync(1) the files in the secondary's flash file system are the same as those in the primary's. newer(2) the files in the secondary's flash file system have a more recent date than those on the primary older(3) the files in the secondary's flash file system have an earlier date than those on the primary unknown(4)no meaningfull answer exists syncing(5)The Primary has initiated file synchronization this should be temporay - 30 minutes at most! For the Secondary the meaning or 2 and 3 are reversed If this value is SET to 1, the chassis attempts to synchronize the image files.")
chasControlConfigSyncStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 19), XylanConfigSyncStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlConfigSyncStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlConfigSyncStatus.setDescription('insync(1) All configuration data on the Primary is the same as that on the secondary. newer(2) The config data on the Primary MPM has been updated more recently than the config data on the secondary. (This is not a possible value if the instance is the Secondary) older(3) The config data on the Primary MPM has been updated more recently than the config data on the secondary. (This is not a possible value if the instance is the Primary) unknown(4)No meaniful response can be given. syncing(5)The Primary has initiated configuration synchronization this should be temporay 15 minutes at most! bootvalues(6) The configuration data contains the boot values. Only possible on secondary if snmp is interaction with chassis is possible If this value is SET to 1, the chassis attempts to synchronize the configuration file.')
chasControlConfigSyncEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 20), XylanConfigSyncEnable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlConfigSyncEnable.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlConfigSyncEnable.setDescription('enabled(1) - After changes to configuration data AND after 5 min from the last change if the image files are synced, sync synchronize the configuration data. disabled(2) - never automatically synchronize the configuration data.')
chasControlDCEPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 21), XylanSerialPortMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlDCEPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDCEPortMode.setDescription('down(1) - This port is down. console(2) - This is the console port slip(3) - This is a slip port. This value can only be modified through the console/slip port')
chasControlDTEPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 22), XylanSerialPortMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlDTEPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlDTEPortMode.setDescription('down(1) - This port is down. console(2) - This is the console port slip(3) - This is a slip port. This value can only be modified through the console/slip port')
chasControlEthPortIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlEthPortIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortIPAddr.setDescription('The IP network address of the Ethernet Mgmt. Port.')
chasControlEthPortSubMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlEthPortSubMask.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortSubMask.setDescription('The IP network subnet mask of the Ethernet Mgmt. Port.')
chasControlEthPortBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlEthPortBcast.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortBcast.setDescription('The IP network broadcast address of the Ethernet Mgmt. Port.')
chasControlEthPortGateWay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 26), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlEthPortGateWay.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortGateWay.setDescription('The IP network gateway address of the Ethernet Mgmt. Port.')
chasControlEthPortRipMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("silent", 1), ("deaf", 2), ("active", 3), ("inactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlEthPortRipMode.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortRipMode.setDescription('The RIP mode of the Ethernet Mgmt. Port.')
chasControlEthPortRemoteHost = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 28), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlEthPortRemoteHost.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortRemoteHost.setDescription('The IP network remote host address of the Ethernet Mgmt. Port.')
chasControlEthPortRemoteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 1, 1, 29), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlEthPortRemoteMask.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlEthPortRemoteMask.setDescription('The IP network remote host subnet mask of the Ethernet Mgmt. Port.')
chasControlFFSTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2), )
if mibBuilder.loadTexts: chasControlFFSTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSTable.setDescription('This table provides a file directory listing of both the primary and secondary MPMs. and provides for simple file operations.')
chasControlFFSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1), ).setIndexNames((0, "CHASSIS-MIB", "chasControlFFSFileSlot"), (0, "CHASSIS-MIB", "chasControlFFSFileNameCks"))
if mibBuilder.loadTexts: chasControlFFSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSEntry.setDescription('Each entry describes as single file. Rather than use the entire file name as an instance, a checksum of the file name is used.')
chasControlFFSFileSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFFSFileSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSFileSlot.setDescription('Which slot, valid values are 1 and 2. If there is no Secondary MPM only one of these will be valid.')
chasControlFFSFileNameCks = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFFSFileNameCks.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSFileNameCks.setDescription('This value/instance is derived from the file name and is used to determine which file the NMS is inquiring about or operating on. The NMS must use the value given by the Switch.')
chasControlFFSFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFFSFileName.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSFileName.setDescription('The file name.')
chasControlFFSFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFFSFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSFileSize.setDescription('The file size: bytes of data.')
chasControlFFSFileDate = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlFFSFileDate.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSFileDate.setDescription('The unix date the file was created. this is based upon number of seconds since 1/ 1/70. Files created by older versions of the bootcode alway have 1/ 1/70 00:00 as the date. If the date is incorrect on the switch the values in the file system will reflect that.')
chasControlFFSFileAction = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 2, 1, 6), XylanFFSFileAction()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasControlFFSFileAction.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlFFSFileAction.setDescription('none(1) No action has been requested for this file writingTo(2) can only be specified for Primary causes the specified file to be written from Primary to Secondary. deletingFrom(3) this file is being removed can be specified for files on both Primary and Secondary. readingFrom(4) can only be specified for Secondary causes the specified file to be copoed from the Secondary to the Promary. This value may be set to delete files from an MPM or copy files between the Primary and Secondary. Only one action is permitted at a time. If a SET is attempted to ANY chasControlFFSFileAction when chasControlLastFFSActionSlot is inProgress(2) the resource will be unavailable.')
chasControlFFSActionStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3))
chasControlLastFFSAction = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3, 1), XylanFFSFileAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlLastFFSAction.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlLastFFSAction.setDescription('writingTo(2) The file is being written to the Seconday. deletingFrom(3) the file is being removed from the slot indicated by chasControlLastFFSActionSlot. readingFrom(4) the file is being copied from the Secondary to the Primary. The last action that was requested from the file system. Only one action is permitted at a time. If a SET is attempted to ANY chasControlFFSFileAction when chasControlLastFFSActionSlot is inProgress(2) that resource will be unavailable.')
chasControlLastFFSActionSlot = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlLastFFSActionSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlLastFFSActionSlot.setDescription('The slot number (1/2) which combined with the action says what is really happening. ')
chasControlLastFFSActionFileName = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlLastFFSActionFileName.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlLastFFSActionFileName.setDescription('The name of the file upon which the last Action is was successfully requested.')
chasControlLastFFSActionDate = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlLastFFSActionDate.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlLastFFSActionDate.setDescription('The time of the last successfull set to chasControlFFSFileAction')
chasControlLastFFSActionSource = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlLastFFSActionSource.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlLastFFSActionSource.setDescription('The IP address of the NMS which did the last successfull set to chasControlFFSFileAction')
chasControlLastFFSActionStatus = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 3, 3, 6), XylanFFSFileActionStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasControlLastFFSActionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasControlLastFFSActionStatus.setDescription('none(1) No file action has ever been succesfully requested since boot up of this MPM. Included takeover by Secondary MPM. inProgress(2) The action described by other members of this group is still underway. successfull(3) The action described by other members of this group completed successfully. failed(4) The action described by other members of this group failed.')
chasPowerSupply1State = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 4, 1), XylanPSStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSupply1State.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSupply1State.setDescription('The status of power supply slot 1.')
chasPowerSupply2State = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 4, 2), XylanPSStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSupply2State.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSupply2State.setDescription('The status of power supply slot 2.')
chasEnvrmnt1TempRange1 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 5, 1), XylanTempStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvrmnt1TempRange1.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvrmnt1TempRange1.setDescription('This field contains the state of the temp sensor located on the Primary MPM. This is temperature sensor 0.')
chasEnvrmnt1TempRange2 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 5, 2), XylanTempStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvrmnt1TempRange2.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvrmnt1TempRange2.setDescription('This field contains the state of the temp sensor located on the Primary MPM. This is temperature sensor 1. If the module type is mpm(5) the value returned is notPresent(2). On other MPM types a returned value of underThreshold(4) indcates that the temperature is NOT too low and overThreshold(3) indicates that the temperature IS too low.')
chasEnvrmnt2TempRange1 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 5, 3), XylanTempStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvrmnt2TempRange1.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvrmnt2TempRange1.setDescription('This field contains the state of the temp sensor located on the Secondary MPM. This is temperature sensor 0.')
chasEnvrmnt2TempRange2 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 5, 4), XylanTempStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvrmnt2TempRange2.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvrmnt2TempRange2.setDescription('This field contains the state of the temp sensor located on the Secondary MPM. This is temperature sensor 1. If there is no Secondary MPM or if the module type is mpm(5) the value returned is notPresent(2). On other MPM types a returned value of underThreshold(4) indcates that the temperature is NOT too low and overThreshold(3) indicates that the temperature IS too low.')
chasXylanOpaque = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 6, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(252, 252)).setFixedLength(252)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasXylanOpaque.setStatus('mandatory')
if mibBuilder.loadTexts: chasXylanOpaque.setDescription('The Xylan proprietary status structure.')
class XylanModPortTypes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36))
    namedValues = NamedValues(("unknown", 1), ("invalid", 2), ("empty", 3), ("serial", 4), ("ethutp", 5), ("xmpt6", 6), ("ethaui", 7), ("ethbnc", 8), ("ethfiorl", 9), ("tok", 10), ("xmpt11", 11), ("fsas", 12), ("fdas", 13), ("xmpt14", 14), ("cdas", 15), ("xmpt16", 16), ("atm", 17), ("oc12", 18), ("xmpt19", 19), ("xmpt20", 20), ("tokfbr", 21), ("irp", 22), ("fdxaui", 23), ("fdxaui2", 24), ("t1", 25), ("e1", 26), ("e3", 27), ("usp", 28), ("isdnbri", 29), ("e100baset", 30), ("atmds1", 31), ("tok100", 32), ("e100basef", 33), ("egigfm", 34), ("egigfms", 35), ("egigfmh", 36))

chasXylanCompaq = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 6, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(310, 310)).setFixedLength(310)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasXylanCompaq.setStatus('mandatory')
if mibBuilder.loadTexts: chasXylanCompaq.setDescription('The Xylan proprietary status structure.')
chasXylanPollData = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 6, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(388, 388)).setFixedLength(388)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasXylanPollData.setStatus('mandatory')
if mibBuilder.loadTexts: chasXylanPollData.setDescription('The third Xylan proprietary status structure.')
chasAccountCdrCount = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountCdrCount.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountCdrCount.setDescription('The number of Charging Detail Records currently in memory and not safely stored yet.')
chasAccountMethodInUse = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("wire", 2), ("disk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountMethodInUse.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountMethodInUse.setDescription('The method in use to store terminated Charging Detail Records.')
chasAccountDeviceInUse = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountDeviceInUse.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountDeviceInUse.setDescription('The IP address of the collection device with which a TCP connection was most recently established. If the method is disk, or if no device is available, this parameter is set to 0.0.0.0.')
chasAccountMaxCnxInUse = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountMaxCnxInUse.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountMaxCnxInUse.setDescription('Indicates the maximum number of taxable connections in use.')
chasAccountCdrNext = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountCdrNext.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountCdrNext.setDescription('The value put as CDR identifier in the next Charging Detail Record. Corresponds to the number of CDRs generated.')
chasAccountFileCount = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountFileCount.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountFileCount.setDescription('The number of terminated accounting files awaiting collection (and removal) by an external accounting collection agent.')
chasAccountPollCycle = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("waiting", 1), ("polling", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountPollCycle.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountPollCycle.setDescription('Indicates whether the switch is awaiting the end of the next period, or is busy completing Charging Detail Records at the end of the current period.')
chasAccountConnectState = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unused", 0), ("closed", 1), ("open", 2), ("openHold", 3), ("openAlternateHold", 4), ("openAlternate", 5), ("closeHold", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountConnectState.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountConnectState.setDescription('Shows the state of the connection state machine. Set to unused (0) when storing data on local disk.')
chasAccountMethod = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("wire", 2), ("disk", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountMethod.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountMethod.setDescription('The requested method to store terminated Charging Detail Records.')
chasAccountDevicePrimary = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountDevicePrimary.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountDevicePrimary.setDescription('The IP address of the primary collection device.')
chasAccountDeviceSecondary = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountDeviceSecondary.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountDeviceSecondary.setDescription('The IP address of the secondary collection device.')
chasAccountDevicePort = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountDevicePort.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountDevicePort.setDescription('The port on which the accounting collection device is listening.')
chasAccountPeriods = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountPeriods.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountPeriods.setDescription('A set of tariff periods. Each octet indicates the quarter-hour since midnight at which a new period begins. Each value is at least four units larger than its predecessor, else it is silently ignored.')
chasAccountInterval = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 8, 12, 48))).clone(namedValues=NamedValues(("hourly", 4), ("two-hours", 8), ("three-hours", 12), ("twice-daily", 48)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountInterval.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountInterval.setDescription('The interval for intermediate accounting collection .')
chasAccountChargedServices = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountChargedServices.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountChargedServices.setDescription('Indicates for which services charging can be enabled. The parameter is a bitmap where each bit represents a service. The following services are already defined: 00000001 = ATM switching 00000002 = FR switching Raising a bit enables charging the service, while clearing the bit disables charging for that service.')
chasAccountMaxCnx = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountMaxCnx.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountMaxCnx.setDescription('Indicates the configured maximum number of taxable connections.')
chasAccountFillingLevel = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAccountFillingLevel.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountFillingLevel.setDescription('This gauge indicates the amount of buffer taken up by accounting data. Values are a percentage of the buffer size.')
chasAccountThreshold1 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountThreshold1.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountThreshold1.setDescription('The first filling level of the intermediate storage area for accounting data. Crossing this threshold generates a warning. The level is expressed as a percentage of size.')
chasAccountThreshold2 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountThreshold2.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountThreshold2.setDescription('The second filling level of the intermediate storage area for accounting data. Crossing this threshold generates a warning, the current TCP connection is closed and a new one is established towards the alternate collection device. The level is expressed as a percentage of size.')
chasAccountThreshold3 = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 95))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountThreshold3.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountThreshold3.setDescription('The third filling level of the intermediate storage area for accounting data. Beyond this level, the switch enters a congestion state and may refuse new SVC connections. The level is expressed as a percentage of size.')
chasAccountTcpWriteTimer = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountTcpWriteTimer.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountTcpWriteTimer.setDescription('Indicates the ticker value for writing accounting data onto the TCP connection. Units are hundreds of milli-seconds.')
chasAccountHoldDownTimer = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountHoldDownTimer.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountHoldDownTimer.setDescription('Indicates the holding delay on crossing threshold2. When threshold2 is exceeded, the switch changes to the alternate TCP connection. The buffer must remain filled above the threshold2 level for at least T2 seconds before another change of the TCP connection is authorized. Units are seconds.')
chasAccountFileSize = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountFileSize.setDescription('When accounting data are stored on local disk, this parameter indicates the upper limit of an accounting file. If this limit is exceeded, the file is closed, compressed, and put in the outgoing directory for collection by an external device. Units are in Kbytes.')
chasAccountCongStrategy = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("acceptCalls", 1), ("refuseCalls", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountCongStrategy.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountCongStrategy.setDescription('When the switch is in congestion state, for lack of resources to store accounting data, this parameter indicates whether new SVC connections are accepted but not charged (acceptCalls), or whether they are refused (refuseCalls).')
chasAccountFileCountThreshold = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountFileCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountFileCountThreshold.setDescription('If more than this number of accounting files are awaiting collection, a trap will be generated.')
chasAccountName = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: chasAccountName.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountName.setDescription('The fully qualified path name of the most recently terminated accounting file. This object is not intended to be accessed directly. It is defined for use in accounting-related traps.')
chasAccountMake = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountMake.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountMake.setDescription('When chasAccountMake is enabled, the accounting data are collected')
chasAccountSwitch = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 7, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasAccountSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: chasAccountSwitch.setDescription('When chasAccountSwitch is enabled, it forces a switchover from the current to the alternate collection device if on the fly charging is enabled. It has no effect otherwise')
chasFanTray1State = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 8, 1), XylanFTStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasFanTray1State.setStatus('mandatory')
if mibBuilder.loadTexts: chasFanTray1State.setDescription('The status of fan tray 1.')
chasFanTray2State = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 1, 8, 2), XylanFTStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasFanTray2State.setStatus('mandatory')
if mibBuilder.loadTexts: chasFanTray2State.setDescription('The status of fan tray 2.')
mibBuilder.exportSymbols("CHASSIS-MIB", chasControlState=chasControlState, chasModuleSlot=chasModuleSlot, chasModuleBaseMacAddress=chasModuleBaseMacAddress, chasControlFFSFileNameCks=chasControlFFSFileNameCks, chasAccountCdrCount=chasAccountCdrCount, chasPhysical=chasPhysical, chasAccountMaxCnx=chasAccountMaxCnx, chasAccountThreshold2=chasAccountThreshold2, XylanConfigSyncEnable=XylanConfigSyncEnable, chasAccountFileCountThreshold=chasAccountFileCountThreshold, chasNewDupMacSupport=chasNewDupMacSupport, XylanModuleType=XylanModuleType, chasModuleTable=chasModuleTable, chasControlLastFFSActionSource=chasControlLastFFSActionSource, chasControlEthPortGateWay=chasControlEthPortGateWay, chasModuleLedStatus=chasModuleLedStatus, chasControlImageSuffix=chasControlImageSuffix, XylanConfigSyncStatus=XylanConfigSyncStatus, chasAccountMethodInUse=chasAccountMethodInUse, XylanSerialPortSpeed=XylanSerialPortSpeed, chasAccountFileSize=chasAccountFileSize, chasPowerSupply=chasPowerSupply, chasControlIPAdd=chasControlIPAdd, chasIpAddrToPing=chasIpAddrToPing, chasSonetMonitoring=chasSonetMonitoring, chasModuleOperStatus=chasModuleOperStatus, chasFreeSlots=chasFreeSlots, chasAccountThreshold1=chasAccountThreshold1, chasControlFFSEntry=chasControlFFSEntry, chasAccountMake=chasAccountMake, chasControlDTEParity=chasControlDTEParity, chasAccountInterval=chasAccountInterval, chasModuleHwRevision=chasModuleHwRevision, chasControlFreeBuffers=chasControlFreeBuffers, chasModuleHwModLevel=chasModuleHwModLevel, chasAccountMethod=chasAccountMethod, chasModulePartNum=chasModulePartNum, XylanSerialPortMode=XylanSerialPortMode, chasControlDCEPortMode=chasControlDCEPortMode, chasControlEthPortBcast=chasControlEthPortBcast, chasControlFFSFileName=chasControlFFSFileName, XylanMPMStateType=XylanMPMStateType, chasDupMacSupport=chasDupMacSupport, chasAccountDeviceInUse=chasAccountDeviceInUse, chasControlFreeFFS=chasControlFreeFFS, chasControlDCEParity=chasControlDCEParity, chasControlFFSTable=chasControlFFSTable, chasModuleSerialNumber=chasModuleSerialNumber, chasAccountDevicePort=chasAccountDevicePort, chasAccountSwitch=chasAccountSwitch, chasPhysicalChanges=chasPhysicalChanges, chasControlLastFFSAction=chasControlLastFFSAction, chasInfo=chasInfo, chasModuleEntry=chasModuleEntry, chasAccountName=chasAccountName, chasAccounting=chasAccounting, XylanImageSyncStatus=XylanImageSyncStatus, chasModuleType=chasModuleType, chasControlLastFFSActionSlot=chasControlLastFFSActionSlot, chasEnvmnt=chasEnvmnt, chasControlEthPortSubMask=chasControlEthPortSubMask, chasStatus=chasStatus, chasControlDCEPortRate=chasControlDCEPortRate, chasControlEthPortRemoteMask=chasControlEthPortRemoteMask, chasControlDTEStopBits=chasControlDTEStopBits, chasControlBootCode=chasControlBootCode, XylanPSStateType=XylanPSStateType, chasLogicalChanges=chasLogicalChanges, chasDescription=chasDescription, chasControlConfigSyncEnable=chasControlConfigSyncEnable, chasAccountCdrNext=chasAccountCdrNext, chasBaseMacAddress=chasBaseMacAddress, XylanModPortTypes=XylanModPortTypes, chasAccountDevicePrimary=chasAccountDevicePrimary, chasEnvrmnt2TempRange1=chasEnvrmnt2TempRange1, chasControlDCEWordSize=chasControlDCEWordSize, chasControlBufferUtilization=chasControlBufferUtilization, XylanTempStateType=XylanTempStateType, chasDateAndTime=chasDateAndTime, chasAccountConnectState=chasAccountConnectState, chasAccountDeviceSecondary=chasAccountDeviceSecondary, XylanFFSFileActionStatus=XylanFFSFileActionStatus, chasControlSlot=chasControlSlot, XylanSerialPortParity=XylanSerialPortParity, chasControlCPUUtilization=chasControlCPUUtilization, chasModuleFwVersion=chasModuleFwVersion, chasPowerSupply2State=chasPowerSupply2State, chasAccountChargedServices=chasAccountChargedServices, chasController=chasController, chasControlDTEWordSize=chasControlDTEWordSize, chasControlFFSFileAction=chasControlFFSFileAction, chasModuleSubUnit=chasModuleSubUnit, chasAccountMaxCnxInUse=chasAccountMaxCnxInUse, chasAccountFileCount=chasAccountFileCount, chasTimezoneName=chasTimezoneName, chasControlDTEPortRate=chasControlDTEPortRate, chasControlEthPortRipMode=chasControlEthPortRipMode, chasControlLastFFSActionStatus=chasControlLastFFSActionStatus, chasModuleMfgDate=chasModuleMfgDate, chasControlFFSFileSlot=chasControlFFSFileSlot, chasControlFFSActionStatus=chasControlFFSActionStatus, chasModuleDescription=chasModuleDescription, chasPowerSupply1State=chasPowerSupply1State, chasXylanOpaque=chasXylanOpaque, chasModuleVbusTxDiscards=chasModuleVbusTxDiscards, chasControlImageSyncStatus=chasControlImageSyncStatus, chasModuleAdminStatus=chasModuleAdminStatus, chasControlEthPortRemoteHost=chasControlEthPortRemoteHost, chasAccountPeriods=chasAccountPeriods, chasControlFFSFileSize=chasControlFFSFileSize, chasAccountThreshold3=chasAccountThreshold3, chasControlLastFFSActionDate=chasControlLastFFSActionDate, chasModuleVbusRxDiscards=chasModuleVbusRxDiscards, chasModuleLedStatusExtend=chasModuleLedStatusExtend, chasControlDCEStopBits=chasControlDCEStopBits, chasControlTable=chasControlTable, chasTimezoneOffset=chasTimezoneOffset, chasControlEntry=chasControlEntry, chasAccountCongStrategy=chasAccountCongStrategy, chasAccountPollCycle=chasAccountPollCycle, XylanFFSFileAction=XylanFFSFileAction, chasControlDTEPortMode=chasControlDTEPortMode, XylanModuleSubunit=XylanModuleSubunit, chasAccountHoldDownTimer=chasAccountHoldDownTimer, chasControlConfigSyncStatus=chasControlConfigSyncStatus, chasType=chasType, chasXylanPollData=chasXylanPollData, chasFanTray=chasFanTray, chasControlFFSFileDate=chasControlFFSFileDate, chasEnvrmnt1TempRange2=chasEnvrmnt1TempRange2, chasCurrentDateAndTime=chasCurrentDateAndTime, chasVbusMode=chasVbusMode, chasEnvrmnt2TempRange2=chasEnvrmnt2TempRange2, chasTimezoneDstAdmin=chasTimezoneDstAdmin, chasControlEthPortIPAddr=chasControlEthPortIPAddr, chasControlLastFFSActionFileName=chasControlLastFFSActionFileName, chasTimezoneDst=chasTimezoneDst, XylanChasType=XylanChasType, chasMake=chasMake, chasNoOfResets=chasNoOfResets, chasAccountFillingLevel=chasAccountFillingLevel, chasEnvrmnt1TempRange1=chasEnvrmnt1TempRange1, chasAccountTcpWriteTimer=chasAccountTcpWriteTimer, chasFanTray1State=chasFanTray1State, chasXylanCompaq=chasXylanCompaq, chasFanTray2State=chasFanTray2State, XylanFTStateType=XylanFTStateType, chasModuleTimeStamp=chasModuleTimeStamp)

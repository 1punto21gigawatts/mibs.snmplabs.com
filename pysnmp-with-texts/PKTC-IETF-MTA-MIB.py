#
# PySNMP MIB module PKTC-IETF-MTA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PKTC-IETF-MTA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:40:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
docsDevSoftwareGroupV2, = mibBuilder.importSymbols("DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroupV2")
docsBpi2CodeDownloadGroup, DocsX509ASN1DEREncodedCertificate = mibBuilder.importSymbols("DOCS-IETF-BPI2-MIB", "docsBpi2CodeDownloadGroup", "DocsX509ASN1DEREncodedCertificate")
ifPhysAddress, = mibBuilder.importSymbols("IF-MIB", "ifPhysAddress")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
sysDescr, = mibBuilder.importSymbols("SNMPv2-MIB", "sysDescr")
iso, Bits, Gauge32, TimeTicks, mib_2, NotificationType, ModuleIdentity, Integer32, Counter64, IpAddress, ObjectIdentity, MibIdentifier, Unsigned32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Bits", "Gauge32", "TimeTicks", "mib-2", "NotificationType", "ModuleIdentity", "Integer32", "Counter64", "IpAddress", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TruthValue")
LongUtf8String, = mibBuilder.importSymbols("SYSAPPL-MIB", "LongUtf8String")
pktcIetfMtaMib = ModuleIdentity((1, 3, 6, 1, 2, 1, 140))
pktcIetfMtaMib.setRevisions(('2006-09-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pktcIetfMtaMib.setRevisionsDescriptions(('Initial version, published as RFC 4682.',))
if mibBuilder.loadTexts: pktcIetfMtaMib.setLastUpdated('200609180000Z')
if mibBuilder.loadTexts: pktcIetfMtaMib.setOrganization('IETF IP over Cable Data Network Working Group')
if mibBuilder.loadTexts: pktcIetfMtaMib.setContactInfo('Eugene Nechamkin Broadcom Corporation, 200-13711 International Place, Richmond, BC, V6V 2Z8 CANADA Phone: +1 604 233 8500 Email: enechamkin@broadcom.com Jean-Francois Mule Cable Television Laboratories, Inc. 858 Coal Creek Circle Louisville, CO 80027-9750 U.S.A. Phone: +1 303 661 9100 Email: jf.mule@cablelabs.com IETF IPCDN Working Group General Discussion: ipcdn@ietf.org Subscribe: http://www.ietf.org/mailman/listinfo/ipcdn Archive: ftp://ftp.ietf.org/ietf-mail-archive/ipcdn Co-Chair: Jean-Francois Mule, jf.mule@cablelabs.com Co-Chair: Richard Woundy, Richard_Woundy@cable.comcast.com')
if mibBuilder.loadTexts: pktcIetfMtaMib.setDescription('This MIB module defines the basic management object for the Multimedia Terminal Adapter devices compliant with PacketCable and IPCablecom requirements. Copyright (C) The IETF Trust (2006). This version of this MIB module is part of RFC 4682; see the RFC itself for full legal notices.')
class PktcMtaDevProvEncryptAlg(TextualConvention, Integer32):
    description = " This textual convention defines various types of the encryption algorithms used for the encryption of the MTA configuration file. The description of the encryption algorithm for each enumerated value is as follows: 'none(0)' no encryption is used, 'des64CbcMode(1)' DES 64-bit key in CBC mode, 't3Des192CbcMode(2)' 3DES 192-bit key in CBC mode, 'aes128CbcMode(3)' AES 128-bit key in CBC mode, 'aes256CbcMode(4)' AES 256-bit key in CBC mode."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("none", 0), ("des64CbcMode", 1), ("t3Des192CbcMode", 2), ("aes128CbcMode", 3), ("aes256CbcMode", 4))

pktcMtaNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 0))
pktcMtaMibObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 1))
pktcMtaDevBase = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 1, 1))
pktcMtaDevServer = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 1, 2))
pktcMtaDevSecurity = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 1, 3))
pktcMtaDevErrors = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 1, 4))
pktcMtaConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 2))
pktcMtaDevResetNow = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevResetNow.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevResetNow.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevResetNow.setDescription(" This object controls the MTA software reset. Reading this object always returns 'false'. Setting this object to 'true' causes the device to reset immediately and the following actions to occur: 1. All connections (if present) are flushed locally. 2. All current actions such as ringing immediately terminate. 3. Requests for signaling notifications, such as notification based on digit map recognition, are flushed. 4. All endpoints are disabled. 5. The provisioning flow is started at step MTA-1. If a value is written into an instance of pktcMtaDevResetNow, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevSerialNumber = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevSerialNumber.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevSerialNumber.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevSerialNumber.setDescription(" This object specifies the manufacturer's serial number of this MTA. The value of this object MUST be identical to the value specified in DHCP option 43, sub-option 4. The list of sub-options for DHCP option 43 are defined in the PacketCable MTA Device Provisioning Specification.")
pktcMtaDevSwCurrentVers = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevSwCurrentVers.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevSwCurrentVers.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevSwCurrentVers.setDescription(" This object identifies the software version currently operating in the MTA. The MTA MUST return a string descriptive of the current software load. This object should use the syntax defined by the individual vendor to identify the software version. The data presented in this object MUST be identical to the software version information contained in the 'sysDescr' MIB object of the MTA. The value of this object MUST be identical to the value specified in DHCP option 43, sub-option 6. The list of sub-options for DHCP option 43 are defined in the PacketCable MTA Device Provisioning Specification.")
pktcMtaDevFQDN = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevFQDN.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevFQDN.setDescription(' This object contains the Fully Qualified Domain Name for this MTA. The MTA FQDN is used to uniquely identify the device to the PacketCable back office elements.')
pktcMtaDevEndPntCount = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevEndPntCount.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevEndPntCount.setDescription(' This object contains the number of physical endpoints for this MTA.')
pktcMtaDevEnabled = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevEnabled.setReference(' PacketCable MTA Device Provisioning Specification; PacketCable Security Specification; PacketCable Network-Based Call Signaling Protocol Specification.')
if mibBuilder.loadTexts: pktcMtaDevEnabled.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevEnabled.setDescription(" This object contains the MTA Admin Status of this device. If this object is set to 'true', the MTA is administratively enabled, and the MTA MUST be able to interact with the PacketCable entities, such as CMS, Provisioning Server, KDC, and other MTAs and MGs on all PacketCable interfaces. If this object is set to 'false', the MTA is administratively disabled, and the MTA MUST perform the following actions for all endpoints: - Shut down all media sessions, if present. - Shut down Network Control Signaling (NCS) signaling by following the Restart in Progress procedures in the PacketCable NCS specification. The MTA must execute all actions required to enable or disable the telephony services for all endpoints immediately upon receipt of an SNMP SET operation. Additionally, the MTA MUST maintain the SNMP Interface for management and also the SNMP Key management interface. Also, the MTA MUST NOT continue Kerberized key management with CMSes until this object is set to 'true'. Note: MTAs MUST renew the CMS Kerberos tickets according to the PacketCable Security or IPCablecom Specification. If a value is written into an instance of pktcMtaDevEnabled, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevTypeIdentifier = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevTypeIdentifier.setReference(' RFC 2132, DHCP Options and BOOTP Vendor Extensions; PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevTypeIdentifier.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevTypeIdentifier.setDescription(' This object provides the MTA device type identifier. The value of this object must be a copy of the DHCP option 60 value exchanged between the MTA and the DHCP server. The DHCP option 60 value contains an ASCII-encoded string identifying capabilities of the MTA as defined in the PacketCable MTA Device Provisioning Specification.')
pktcMtaDevProvisioningState = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("pass", 1), ("inProgress", 2), ("failConfigFileError", 3), ("passWithWarnings", 4), ("passWithIncompleteParsing", 5), ("failureInternalError", 6), ("failureOtherReason", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvisioningState.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvisioningState.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvisioningState.setDescription(" This object indicates the completion state of the MTA device provisioning process. pass: If the configuration file could be parsed successfully and the MTA is able to reflect the same in its MIB, the MTA MUST return the value 'pass'. inProgress: If the MTA is in the process of being provisioned, the MTA MUST return the value 'inProgress'. failConfigFileError: If the configuration file was in error due to incorrect values in the mandatory parameters, the MTA MUST reject the configuration file, and the MTA MUST return the value 'failConfigFileError'. passWithWarnings: If the configuration file had proper values for all the mandatory parameters but has errors in any of the optional parameters (this includes any vendor-specific Object Identifiers (OIDs) that are incorrect or not known to the MTA), the MTA MUST return the value 'passWithWarnings'. passWithIncompleteParsing: If the configuration file is valid but the MTA cannot reflect the same in its configuration (for example, too many entries caused memory exhaustion), it must accept the CMS configuration entries related, and the MTA MUST return the value 'passWithIncompleteParsing'. failureInternalError: If the configuration file cannot be parsed due to an Internal error, the MTA MUST return the value 'failureInternalError'. failureOtherReason: If the MTA cannot accept the configuration file for any other reason than the ones stated above, the MTA MUST return the value 'failureOtherReason'. When a final SNMP INFORM is sent as part of Step 25 of the MTA Provisioning process, this parameter is also included in the final INFORM message.")
pktcMtaDevHttpAccess = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevHttpAccess.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevHttpAccess.setDescription(' This object indicates whether the HTTP protocol is supported for the MTA configuration file transfer.')
pktcMtaDevProvisioningTimer = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30)).clone(10)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevProvisioningTimer.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvisioningTimer.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvisioningTimer.setDescription(' This object defines the time interval for the provisioning flow to complete. The MTA MUST finish all provisioning operations starting from the moment when an MTA receives its DHCP ACK and ending at the moment when the MTA downloads its configuration file (e.g., MTA5 to MTA23) within the period of time set by this object. Failure to comply with this condition constitutes a provisioning flow failure. If the object is set to 0, the MTA MUST ignore the provisioning timer condition. If a value is written into an instance of pktcMtaDevProvisioningTimer, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.')
pktcMtaDevProvisioningCounter = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvisioningCounter.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvisioningCounter.setDescription('This object counts the number of times the provisioning cycle has looped through step MTA-1.')
pktcMtaDevErrorOidsTable = MibTable((1, 3, 6, 1, 2, 1, 140, 1, 1, 12), )
if mibBuilder.loadTexts: pktcMtaDevErrorOidsTable.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevErrorOidsTable.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorOidsTable.setDescription(" This table contains the list of configuration errors or warnings the MTA encountered when parsing the configuration file it received from the Provisioning Server. For each error, an entry is created in this table, containing the configuration parameters the MTA rejected and the associated reason (e.g., wrong or unknown OID, inappropriate object values). If the MTA did not report a provisioning state of 'pass(1)' in the pktcMtaDevProvisioningState object, this table MUST be populated for each error or warning instance. Even if different parameters share the same error type (e.g., all realm name configuration parameters are invalid), all observed errors or warnings must be reported as different instances. Errors are placed into the table in no particular order. The table MUST be cleared each time the MTA reboots.")
pktcMtaDevErrorOidsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 140, 1, 1, 12, 1), ).setIndexNames((0, "PKTC-IETF-MTA-MIB", "pktcMtaDevErrorOidIndex"))
if mibBuilder.loadTexts: pktcMtaDevErrorOidsEntry.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorOidsEntry.setDescription(' This entry contains the necessary information the MTA MUST attempt to provide in case of configuration file errors or warnings.')
pktcMtaDevErrorOidIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 1, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: pktcMtaDevErrorOidIndex.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorOidIndex.setDescription(" This object is the index of the MTA configuration error table. It is an integer value that starts at value '1' and is incremented for each encountered configuration file error or warning. The maximum number of errors or warnings that can be recorded in the pktcMtaDevErrorOidsTable is set to 1024 as a configuration file is usually validated by operators before deployment. Given the possible number of configuration parameter assignments in the MTA configuration file, 1024 is perceived as a sufficient limit even with future extensions. If the number of the errors in the configuration file exceeds 1024, all errors beyond the 1024th one MUST be ignored and not be reflected in the pktcMtaDevErrorOidsTable.")
pktcMtaDevErrorOid = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 1, 12, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevErrorOid.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorOid.setDescription(" This object contains a human readable representation (character string) of the OID corresponding to the configuration file parameter that caused the particular error. For example, if the value of the pktcMtaDevEnabled object in the configuration file caused an error, then this object instance will contain the human-readable string of '1.3.6.1.2.1.140.1.1.6.0'. If the MTA generated an error because it was not able to recognize a particular OID, then this object instance would contain an empty value (zero-length string). For example, if the value of an OID in the configuration file was interpreted by the MTA as being 1.2.3.4.5, and if the MTA was not able to recognize this OID as a valid one, this object instance will contain a zero-length string. If the number of errors in the configuration file exceeds 1024, then for all subsequent errors, the pktcMtaDevErrorOid of the table's 1024th entry MUST contain a human-readable representation of the pktcMtaDevErrorsTooManyErrors object; i.e., the string '1.3.6.1.2.1.140.1.1.4.1.0'. Note that the syntax of this object is SnmpAdminString instead of OBJECT IDENTIFIER because the object value may not be a valid OID due to human or configuration tool encoding errors.")
pktcMtaDevErrorValue = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 1, 12, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevErrorValue.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorValue.setDescription(" This object contains the value of the OID corresponding to the configuration file parameter that caused the error. If the MTA cannot recognize the OID of the configuration parameter causing the error, then this object instance contains the OID itself as interpreted by the MTA in human-readable representation. If the MTA can recognize the OID but generate an error due to a wrong value of the parameter, then the object instance contains the erroneous value of the parameter as read from the configuration file. In both cases, the value of this object must be represented in human-readable form as a character string. For example, if the value of the pktcMtaDevEnabled object in the configuration file was 3 (invalid value), then the pktcMtaDevErrorValue object instance will contain the human-readable (string) representation of value '3'. Similarly, if the OID in the configuration file has been interpreted by the MTA as being 1.2.3.4.5 and the MTA cannot recognize this OID as a valid one, then this pktcMtaDevErrorValue object instance will contain human readable (string) representation of value '1.2.3.4.5'. If the number of errors in the configuration file exceeds 1024, then for all subsequent errors, the pktcMtaDevErrorValue of the table's 1024th entry MUST contain a human-readable representation of the pktcMtaDevErrorsTooManyErrors object; i.e., the string '1.3.6.1.2.1.140.1.1.4.1.0'.")
pktcMtaDevErrorReason = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 1, 12, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevErrorReason.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorReason.setDescription(" This object indicates the reason for the error or warning, as per the MTA's interpretation, in human-readable form. For example: 'VALUE NOT IN RANGE', 'VALUE DOES NOT MATCH TYPE', 'UNSUPPORTED VALUE', 'LAST 4 BITS MUST BE SET TO ZERO', 'OUT OF MEMORY - CANNOT STORE'. This object may also contain vendor specific errors for private vendor OIDs and any proprietary error codes or messages that can help diagnose configuration errors. If the number of errors in the configuration file exceeds 1024, then for all subsequent errors, the pktcMtaDevErrorReason of the table's 1024th entry MUST contain a human-readable string indicating the reason for an error; for example, 'Too many errors in the configuration file'.")
pktcMtaDevDhcpServerAddressType = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 1), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevDhcpServerAddressType.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevDhcpServerAddressType.setDescription(' This object contains the Internet address type for the PacketCable DHCP servers specified in MTA MIB.')
pktcMtaDevServerDhcp1 = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevServerDhcp1.setReference(' PacketCable MTA Device Provisioning Specification; RFC 2131, Dynamic Host Configuration Protocol; RFC 3495, DHCP Option for CableLabs Client Configuration.')
if mibBuilder.loadTexts: pktcMtaDevServerDhcp1.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevServerDhcp1.setDescription(" This object contains the Internet Address of the primary DHCP server the MTA uses during provisioning. The type of this address is determined by the value of the pktcMtaDevDhcpServerAddressType object. When the latter has the value 'ipv4(1)', this object contains the IP address of the primary DHCP server. It is provided by the CM to the MTA via the DHCP option code 122, sub-option 1, as defined in RFC 3495. The behavior of this object when the value of pktcMtaDevDhcpServerAddressType is other than 'ipv4(1)' is not presently specified, but it may be specified in future versions of this MIB module. If this object is of value 0.0.0.0, the MTA MUST stop all provisioning attempts, as well as all other activities. If this object is of value 255.255.255.255, it means that there was no preference given for the primary DHCP server, and, the MTA must follow the logic of RFC2131, and the value of DHCP option 122, sub-option 2, must be ignored.")
pktcMtaDevServerDhcp2 = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevServerDhcp2.setReference(' PacketCable MTA Device Provisioning Specification; RFC 3495, DHCP Option for CableLabs Client Configuration.')
if mibBuilder.loadTexts: pktcMtaDevServerDhcp2.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevServerDhcp2.setDescription(" This object contains the Internet Address of the secondary DHCP server the MTA uses during provisioning. The type of this address is determined by the value of the pktcMtaDevDhcpServerAddressType object. When the latter has the value 'ipv4(1)', this object contains the IP address of the secondary DHCP server. It is provided by the CM to the MTA via the DHCP option code 122, sub-option 2, as defined in RFC 3495. The behavior of this object when the value of pktcMtaDevDhcpServerAddressType is other than 'ipv4(1)' is not presently specified, but it may be specified in future versions of this MIB module. If there was no secondary DHCP server provided in DHCP Option 122, sub-option 2, this object must return the value 0.0.0.0.")
pktcMtaDevDnsServerAddressType = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 4), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevDnsServerAddressType.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevDnsServerAddressType.setDescription(' This object contains the Internet address type for the PacketCable DNS servers specified in MTA MIB.')
pktcMtaDevServerDns1 = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 5), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevServerDns1.setReference(' PacketCable MTA Device Provisioning Specification; RFC 2132, DHCP Options and BOOTP Vendor Extensions.')
if mibBuilder.loadTexts: pktcMtaDevServerDns1.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevServerDns1.setDescription(" This object contains the IP Address of the primary DNS server to be used by the MTA. The type of this address is determined by the value of the pktcMtaDevDnsServerAddressType object. When the latter has the value 'ipv4(1)', this object contains the IP address of the primary DNS server. As defined in RFC 2132, PacketCable-compliant MTAs receive the IP addresses of the DNS Servers in DHCP option 6. The behavior of this object when the value of pktcMtaDevDnsServerAddressType is other than 'ipv4(1)' is not presently specified, but it may be specified in future versions of this MIB module. If a value is written into an instance of pktcMtaDevServerDns1, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevServerDns2 = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevServerDns2.setReference(' PacketCable MTA Device Provisioning Specification; RFC 2132, DHCP Options and BOOTP Vendor Extensions.')
if mibBuilder.loadTexts: pktcMtaDevServerDns2.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevServerDns2.setDescription(" This object contains the IP Address of the secondary DNS server to be used by the MTA. The type of this address is determined by the value of the pktcMtaDevDnsServerAddressType object. When the latter has the value 'ipv4(1)', this object contains the IP address of the secondary DNS server. As defined in RFC 2132, PacketCable-compliant MTAs receive the IP addresses of the DNS Servers in DHCP option 6. The behavior of this object when the value of pktcMtaDevDnsServerAddressType is other than 'ipv4(1)' is not presently specified, but it may be specified in future versions of this MIB module. If a value is written into an instance of pktcMtaDevServerDns2, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevTimeServerAddressType = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 7), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevTimeServerAddressType.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevTimeServerAddressType.setDescription(' This object contains the Internet address type for the PacketCable Time servers specified in MTA MIB.')
pktcMtaDevTimeServer = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 8), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevTimeServer.setReference(' RFC 868, Time Protocol; RFC 2131, Dynamic Host Configuration Protocol; RFC 2132, DHCP Options and BOOTP Vendor Extensions.')
if mibBuilder.loadTexts: pktcMtaDevTimeServer.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevTimeServer.setDescription(" This object contains the Internet Address of the Time Server used by an S-MTA for Time Synchronization. The type of this address is determined by the value of the pktcMtaDevTimeServerAddressType object. When the latter has the value 'ipv4(1)', this object contains the IP address of the Time Server used for Time Synchronization. In the case of an S-MTA, this object must be populated with a value other than 0.0.0.0 as obtained from DHCP option 4. The protocol by which the time of day MUST be retrieved is defined in RFC 868. In the case of an E-MTA, this object must contain a value of 0.0.0.0 if the address type is 'ipv4(1)' since an E-MTA does not use the Time Protocol for time synchronization (an E-MTA uses the time retrieved by the DOCSIS cable modem). The behavior of this object when the value of pktcMtaDevTimeServerAddressType is other than 'ipv4(1)' is not presently specified, but it may be specified in future versions of this MIB module. If a value is written into an instance of pktcMtaDevTimeServer, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevConfigFile = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 9), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevConfigFile.setReference(' PacketCable MTA Device Provisioning Specification; RFC 3617, URI Scheme for TFTP; RFC 2616, HTTP 1.1')
if mibBuilder.loadTexts: pktcMtaDevConfigFile.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevConfigFile.setDescription(" This object specifies the MTA device configuration file information, including the access method, the server name, and the configuration file name. The value of this object is the Uniform Resource Locator (URL) of the configuration file for TFTP or HTTP download. If this object value is a TFTP URL, it must be formatted as defined in RFC 3617. If this object value is an HTTP URL, it must be formatted as defined in RFC 2616. If the MTA SNMP Enrollment mechanism is used, then the MTA must download the file provided by the Provisioning Server during provisioning via an SNMP SET on this object. If the MTA SNMP Enrollment mechanism is not used, this object MUST contain the URL value corresponding to the 'siaddr' and 'file' fields received in the DHCP ACK to locate the configuration file: the 'siaddr' and 'file' fields represent the host and file of the TFTP URL, respectively. In this case, the MTA MUST return an 'inconsistentValue' error in response to SNMP SET operations. The MTA MUST return a zero-length string if the server address (host part of the URL) is unknown. If a value is written into an instance of pktcMtaDevConfigFile, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevSnmpEntity = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 10), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevSnmpEntity.setReference(' PacketCable MTA Device Provisioning Specification; RFC 3495, DHCP Option for CableLabs Client Configuration.')
if mibBuilder.loadTexts: pktcMtaDevSnmpEntity.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevSnmpEntity.setDescription(' This object contains the FQDN of the SNMP entity of the Provisioning Server. When the MTA SNMP Enrollment Mechanism is used, this object represents the server that the MTA communicates with, that it receives the configuration file URL from, and that it sends the enrollment notification to. The SNMP entity is also the destination entity for all the provisioning notifications. It may be used for post-provisioning SNMP operations. During the provisioning phase, this SNMP entity FQDN is supplied to the MTA via DHCP option 122, sub-option 3, as defined in RFC 3495. The MTA must resolve the FQDN value before its very first network interaction with the SNMP entity during the provisioning phase.')
pktcMtaDevProvConfigHash = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevProvConfigHash.setReference(' PacketCable MTA Device Provisioning Specification; PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvConfigHash.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvConfigHash.setDescription(" This object contains the hash value of the contents of the configuration file. The authentication algorithm is Secure Hashing Algorithm 1 (SHA-1), and the length is 160 bits. The hash calculation MUST follow the requirements defined in the PacketCable Security Specification. When the MTA SNMP Enrollment mechanism is used, this hash value is calculated and sent to the MTA prior to sending the config file. This object value is then provided by the Provisioning server via an SNMP SET operation. When the MTA SNMP Enrollment mechanism is not in use, the hash value is provided in the configuration file itself, and it is also calculated by the MTA. This object value MUST represent the hash value calculated by the MTA. When the MTA SNMP Enrollment mechanism is not in use, the MTA must reject all SNMP SET operations on this object and return an 'inconsistentValue' error. If a value is written into an instance of pktcMtaDevProvConfigHash, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevProvConfigKey = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevProvConfigKey.setReference(' PacketCable MTA Device Provisioning Specification; PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvConfigKey.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvConfigKey.setDescription(" This object contains the key used to encrypt/decrypt the configuration file when secure SNMPv3 provisioning is used. The value of this object is provided along with the configuration file information (pktcMtaDevConfigFile) and hash (pktcMtaDevProvConfigHash) by the Provisioning Server via SNMP SET once the configuration file has been created, as defined by the PacketCable Security specification. The privacy algorithm is defined by the pktcMtaDevProvConfigEncryptAlg MIB object. The MTA requirements related to the privacy algorithm are defined in the PacketCable Security Specification. If this object is set at any other provisioning step than that allowed by the PacketCable MTA Device Provisioning Specification, the MTA SHOULD return an 'inconsistentValue' error. This object must not be used in non secure provisioning mode. In non-secure provisioning modes, the MTA SHOULD return an 'inconsistentValue' in response to SNMP SET operations, and the MTA SHOULD return a zero-length string in response to SNMP GET operations. If a value is written into an instance of pktcMtaDevProvConfigKey, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevProvConfigEncryptAlg = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 13), PktcMtaDevProvEncryptAlg().clone('des64CbcMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevProvConfigEncryptAlg.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvConfigEncryptAlg.setDescription(' This object defines the encryption algorithm used for privacy protection of the MTA Configuration File content.')
pktcMtaDevProvSolicitedKeyTimeout = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 180)).clone(3)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevProvSolicitedKeyTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvSolicitedKeyTimeout.setDescription(" This object defines a Kerberos Key Management timer on the MTA. It is the time period during which the MTA saves the nonce and Server Kerberos Principal Identifier to match an AP Request and its associated AP Reply response from the Provisioning Server. After the timeout has been exceeded, the client discards this (nonce, Server Kerberos Principal Identifier) pair, after which it will no longer accept a matching AP Reply. This timer only applies when the Provisioning Server initiated key management for SNMPv3 (with a Wake Up message). If this object is set to a zero value, the MTA MUST return an 'inconsistentValue' in response to SNMP SET operations. This object should not be used in non-secure provisioning modes. In non-secure provisioning modes, the MTA MUST return an 'inconsistentValue' in response to SNMP SET operations, and the MTA MUST return a zero value in response to SNMP GET operations. If a value is written into an instance of pktcMtaDevProvSolicitedKeyTimeout, the agent MUST NOT retain the supplied value across MTA re-initializations or reboots.")
pktcMtaDevProvUnsolicitedKeyMaxTimeout = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 600)).clone(600)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyMaxTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyMaxTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyMaxTimeout.setDescription(' This object defines the timeout value that applies to an MTA-initiated AP-REQ/REP key management exchange with the Provisioning Server in SNMPv3 provisioning. It is the maximum timeout value, and it may not be exceeded in the exponential back-off algorithm. If the DHCP option code 122, sub-option 5, is provided to the MTA, it overwrites this value. In non-secure provisioning modes, the MTA MUST return a zero value in response to SNMP GET operations.')
pktcMtaDevProvUnsolicitedKeyNomTimeout = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 600)).clone(3)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyNomTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyNomTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyNomTimeout.setDescription(' This object defines the starting value of the timeout for the AP-REQ/REP Backoff and Retry mechanism with exponential timeout in SNMPv3 provisioning. If the DHCP option code 122, sub-option 5, is provided the MTA, it overwrites this value. In non-secure provisioning modes, the MTA MUST return a zero value in response to SNMP GET operations.')
pktcMtaDevProvUnsolicitedKeyMaxRetries = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32)).clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyMaxRetries.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyMaxRetries.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvUnsolicitedKeyMaxRetries.setDescription(" This object contains a retry counter that applies to an MTA-initiated AP-REQ/REP key management exchange with the Provisioning Server in secure SNMPv3 provisioning. It is the maximum number of retries before the MTA stops attempting to establish a Security Association with Provisioning Server. If the DHCP option code 122, sub-option 5, is provided to the MTA, it overwrites this value. If this object is set to a zero value, the MTA MUST return an 'inconsistentValue' in response to SNMP SET operations. In non-secure provisioning modes, the MTA MUST return a zero value in response to SNMP GET operations.")
pktcMtaDevProvKerbRealmName = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvKerbRealmName.setReference(' PacketCable MTA Device Provisioning Specification; RFC 3495, DHCP Option for CableLabs Client Configuration.')
if mibBuilder.loadTexts: pktcMtaDevProvKerbRealmName.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvKerbRealmName.setDescription(' This object contains the name of the associated provisioning Kerberos realm acquired during the MTA4 provisioning step (DHCP Ack) for SNMPv3 provisioning. The uppercase ASCII representation of the associated Kerberos realm name MUST be used by both the Manager (SNMP entity) and the MTA. The Kerberos realm name for the Provisioning Server is supplied to the MTA via DHCP option code 122, sub-option 6, as defined in RFC 3495. In secure SNMP provisioning mode, the value of the Kerberos realm name for the Provisioning Server supplied in the MTA configuration file must match the value supplied in the DHCP option code 122, sub-option 6. Otherwise, the value of this object must contain the value supplied in DHCP Option 122, sub-option 6.')
pktcMtaDevProvState = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("waitingForSnmpSetInfo", 2), ("waitingForTftpAddrResponse", 3), ("waitingForConfigFile", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevProvState.setReference(' PacketCable MTA Device Provisioning Specification, PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevProvState.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvState.setDescription(" This object defines the MTA provisioning state. If the state is: 'operational(1)', the device has completed the loading and processing of the initialization parameters. 'waitingForSnmpSetInfo(2)', the device is waiting on its configuration file download access information. Note that this state is only reported when the MTA SNMP enrollment mechanism is used. 'waitingForTftpAddrResponse(3)', the device has sent a DNS request to resolve the server providing the configuration file, and it is awaiting for a response. Note that this state is only reported when the MTA SNMP enrollment mechanism is used. 'waitingForConfigFile(4)', the device has sent a request via TFTP or HTTP for the download of its configuration file, and it is awaiting for a response or the file download is in progress.")
pktcMtaDevManufacturerCertificate = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 1), DocsX509ASN1DEREncodedCertificate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevManufacturerCertificate.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevManufacturerCertificate.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevManufacturerCertificate.setDescription(" This object contains the MTA Manufacturer Certificate. The object value must be the ASN.1 DER encoding of the MTA manufacturer's X.509 public key certificate. The MTA Manufacturer Certificate is issued to each MTA manufacturer and is installed into each MTA at the time of manufacture or with a secure code download. The specific requirements related to this certificate are defined in the PacketCable or IPCablecom Security specifications.")
pktcMtaDevCertificate = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 2), DocsX509ASN1DEREncodedCertificate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevCertificate.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevCertificate.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCertificate.setDescription(" This object contains the MTA Device Certificate. The object value must be the ASN.1 DER encoding of the MTA's X.509 public-key certificate issued by the manufacturer and installed into the MTA at the time of manufacture or with a secure code download. This certificate contains the MTA MAC address. The specific requirements related to this certificate are defined in the PacketCable or IPCablecom Security specifications.")
pktcMtaDevCorrelationId = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevCorrelationId.setReference(' PacketCable MTA Device Provisioning Specification.')
if mibBuilder.loadTexts: pktcMtaDevCorrelationId.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCorrelationId.setDescription(' This object contains a correlation ID, an arbitrary value generated by the MTA that will be exchanged as part of the device capability data to the Provisioning Application. This random value is used as an identifier to correlate related events in the MTA provisioning sequence. This value is intended for use only during the MTA initialization and configuration file download.')
pktcMtaDevTelephonyRootCertificate = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 4), DocsX509ASN1DEREncodedCertificate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevTelephonyRootCertificate.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevTelephonyRootCertificate.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevTelephonyRootCertificate.setDescription(' This object contains the telephony Service Provider Root certificate. The object value is the ASN.1 DER encoding of the IP Telephony Service Provider Root X.509 public key certificate. This certification is stored in the MTA non-volatile memory and can be updated with a secure code download. This certificate is used to validate the initial AS Reply received by the MTA from the Key Distribution Center (KDC) during the MTA initialization. The specific requirements related to this certificate are defined in the PacketCable or IPCablecom Security specifications.')
pktcMtaDevRealmAvailSlot = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevRealmAvailSlot.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmAvailSlot.setDescription(" This object contains the index number of the first available entry in the realm table (pktcMtaDevRealmTable). If all the entries in the realm table have been assigned, this object contains the value of zero. A management station should create new entries in the realm table, using the following procedure: First, issue a management protocol retrieval operation to determine the value of the first available index in the realm table (pktcMtaDevRealmAvailSlot). Second, issue a management protocol SET operation to create an instance of the pktcMtaDevRealmStatus object by setting its value to 'createAndWait(5)'. Third, if the SET operation succeeded, continue modifying the object instances corresponding to the newly created conceptual row, without fear of collision with other management stations. When all necessary conceptual columns of the row are properly populated (via SET operations or default values), the management station may SET the pktcMtaDevRealmStatus object to 'active(1)'.")
pktcMtaDevRealmTable = MibTable((1, 3, 6, 1, 2, 1, 140, 1, 3, 6), )
if mibBuilder.loadTexts: pktcMtaDevRealmTable.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmTable.setDescription(' This object contains the realm table. The CMS table (pktcMtaDevCmsTable) and the realm table (pktcMtaDevRealmTable) are used for managing the MTA-CMS Security Associations. The realm table defines the Kerberos realms for the Application Servers (CMSes and the Provisioning Server).')
pktcMtaDevRealmEntry = MibTableRow((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1), ).setIndexNames((0, "PKTC-IETF-MTA-MIB", "pktcMtaDevRealmIndex"))
if mibBuilder.loadTexts: pktcMtaDevRealmEntry.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmEntry.setDescription(' This table entry object lists the MTA security parameters for a single Kerberos realm. The conceptual rows MUST NOT persist across MTA reboots.')
pktcMtaDevRealmIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: pktcMtaDevRealmIndex.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmIndex.setDescription(' This object defines the realm table index.')
pktcMtaDevRealmName = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmName.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmName.setDescription(' This object identifies the Kerberos realm name in all capitals. The MTA MUST prohibit the instantiation of any two rows with identical Kerberos realm names. The MTA MUST also verify that any search operation involving Kerberos realm names is done using the uppercase ASCII representation of the characters.')
pktcMtaDevRealmPkinitGracePeriod = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 600)).clone(15)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmPkinitGracePeriod.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevRealmPkinitGracePeriod.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmPkinitGracePeriod.setDescription(' This object contains the PKINIT Grace Period. For the purpose of key management with Application Servers (CMSes or the Provisioning Server), the MTA must utilize the PKINIT exchange to obtain Application Server tickets. The MTA may utilize the PKINIT exchange to obtain Ticket Granting Tickets (TGTs), which are then used to obtain Application Server tickets in a TGS exchange. The PKINIT exchange occurs according to the current Ticket Expiration Time (TicketEXP) and on the PKINIT Grace Period (PKINITGP). The MTA MUST initiate the PKINIT exchange at the time: TicketEXP - PKINITGP.')
pktcMtaDevRealmTgsGracePeriod = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(10)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmTgsGracePeriod.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevRealmTgsGracePeriod.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmTgsGracePeriod.setDescription(' This object contains the Ticket Granting Server Grace Period (TGSGP). The Ticket Granting Server (TGS) Request/Reply exchange may be performed by the MTA on demand whenever an Application Server ticket is needed to establish security parameters. If the MTA possesses a ticket that corresponds to the Provisioning Server or a CMS that currently exists in the CMS table, the MTA MUST initiate the TGS Request/Reply exchange at the time: TicketEXP - TGSGP.')
pktcMtaDevRealmOrgName = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 5), LongUtf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmOrgName.setReference(' PacketCable Security Specification; RFCs 3280 and 4630, Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile')
if mibBuilder.loadTexts: pktcMtaDevRealmOrgName.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmOrgName.setDescription(' This object contains the X.500 organization name attribute as defined in the subject name of the service provider certificate.')
pktcMtaDevRealmUnsolicitedKeyMaxTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(100)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyMaxTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyMaxTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyMaxTimeout.setDescription(' This object specifies the maximum time the MTA will attempt to perform the exponential back-off algorithm. This timer only applies when the MTA initiated key management. If the DHCP option code 122, sub-option 4, is provided to the MTA, it overwrites this value. Unsolicited key updates are retransmitted according to an exponential back-off mechanism using two timers and a maximum retry counter for AS replies. The initial retransmission timer value is the nominal timer value (pktcMtaDevRealmUnsolicitedKeyNomTimeout). The retransmissions occur with an exponentially increasing interval that caps at the maximum timeout value (pktcMtaDevRealmUnsolicitedKeyMaxTimeout). Retransmissions stop when the maximum retry counter is reached (pktcMatDevRealmUnsolicitedMaxRetries). For example, with values of 3 seconds for the nominal timer, 20 seconds for the maximum timeout, and 5 retries max, retransmission intervals will be 3 s, 6 s, 12 s, 20 s, and 20 s, and retransmissions then stop because the maximum number of retries has been reached.')
pktcMtaDevRealmUnsolicitedKeyNomTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 600000)).clone(3000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyNomTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyNomTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyNomTimeout.setDescription(' This object specifies the initial timeout value for the AS-REQ/AS-REP exponential back-off and retry mechanism. If the DHCP option code 122, sub-option 4, is provided to the MTA, it overwrites this value. This value should account for the average roundtrip time between the MTA and the KDC, as well as the processing delay on the KDC. Unsolicited key updates are retransmitted according to an exponential back-off mechanism using two timers and a maximum retry counter for AS replies. The initial retransmission timer value is the nominal timer value (pktcMtaDevRealmUnsolicitedKeyNomTimeout). The retransmissions occur with an exponentially increasing interval that caps at the maximum timeout value (pktcMtaDevRealmUnsolicitedKeyMaxTimeout). Retransmissions stop when the maximum retry counter is reached (pktcMatDevRealmUnsolicitedMaxRetries). For example, with values of 3 seconds for the nominal timer, 20 seconds for the maximum timeout, and 5 retries max, in retransmission intervals will be 3 s, 6 s, 12 s, 20 s, and 20 s; retransmissions then stop because the maximum number of retries has been reached.')
pktcMtaDevRealmUnsolicitedKeyMaxRetries = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyMaxRetries.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyMaxRetries.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmUnsolicitedKeyMaxRetries.setDescription(' This object specifies the maximum number of retries the MTA attempts to obtain a ticket from the KDC. Unsolicited key updates are retransmitted according to an exponential back-off mechanism using two timers and a maximum retry counter for AS replies. The initial retransmission timer value is the nominal timer value (pktcMtaDevRealmUnsolicitedKeyNomTimeout). The retransmissions occur with an exponentially increasing interval that caps at the maximum timeout value (pktcMtaDevRealmUnsolicitedKeyMaxTimeout). Retransmissions stop when the maximum retry counter is reached (pktcMatDevRealmUnsolicitedMaxRetries). For example, with values of 3 seconds for the nominal timer, 20 seconds for the maximum timeout, and 5 retries max, retransmission intervals will be 3 s, 6 s, 12 s, 20 s, and 20 s; retransmissions then stop because the maximum number of retries has been reached.')
pktcMtaDevRealmStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 6, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevRealmStatus.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevRealmStatus.setDescription(" This object defines the row status of this realm in the realm table (pktcMtaDevRealmTable). An entry in this table is not qualified for activation until the object instances of all corresponding columns have been initialized, either by default values, or via explicit SET operations. Until all object instances in this row are initialized, the status value for this realm must be 'notReady(3)'. In particular, two columnar objects must be explicitly SET: the realm name (pktcMtaDevRealmName) and the organization name (pktcMtaDevRealmOrgName). Once these 2 objects have been set and the row status is SET to 'active(1)', the MTA MUST NOT allow any modification of these 2 object values. The value of this object has no effect on whether other columnar objects in this row can be modified.")
pktcMtaDevCmsAvailSlot = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevCmsAvailSlot.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsAvailSlot.setDescription(" This object contains the index number of the first available entry in the CMS table (pktcMtaDevCmsTable). If all the entries in the CMS table have been assigned, this object contains the value of zero. A management station should create new entries in the CMS table, using the following procedure: First, issue a management protocol retrieval operation to determine the value of the first available index in the CMS table (pktcMtaDevCmsAvailSlot). Second, issue a management protocol SET operation to create an instance of the pktcMtaDevCmsStatus object by setting its value to 'createAndWait(5)'. Third, if the SET operation succeeded, continue modifying the object instances corresponding to the newly created conceptual row, without fear of collision with other management stations. When all necessary conceptual columns of the row are properly populated (via SET operations or default values), the management station may SET the pktcMtaDevCmsStatus object to 'active(1)'.")
pktcMtaDevCmsTable = MibTable((1, 3, 6, 1, 2, 1, 140, 1, 3, 8), )
if mibBuilder.loadTexts: pktcMtaDevCmsTable.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsTable.setDescription(' This object defines the CMS table. The CMS table (pktcMtaDevCmsTable) and the realm table (pktcMtaDevRealmTable) are used for managing security between the MTA and CMSes. Each CMS table entry defines a CMS the managed MTA is allowed to communicate with and contains security parameters for key management with that CMS.')
pktcMtaDevCmsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1), ).setIndexNames((0, "PKTC-IETF-MTA-MIB", "pktcMtaDevCmsIndex"))
if mibBuilder.loadTexts: pktcMtaDevCmsEntry.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsEntry.setDescription(' This table entry object lists the MTA key management parameters used when establishing Security Associations with a CMS. The conceptual rows MUST NOT persist across MTA reboots.')
pktcMtaDevCmsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)))
if mibBuilder.loadTexts: pktcMtaDevCmsIndex.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsIndex.setDescription(' This object defines the CMS table index.')
pktcMtaDevCmsFqdn = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsFqdn.setReference(' PacketCable MTA Device Provisioning Specification; PacketCable Security Specification; PacketCable Network-Based Call Signaling Protocol Specification.')
if mibBuilder.loadTexts: pktcMtaDevCmsFqdn.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsFqdn.setDescription(' This object specifies the CMS FQDN. The MTA must prohibit the instantiation of any two rows with identical FQDNs. The MTA must also verify that any search and/or comparison operation involving a CMS FQDN is case insensitive. The MTA must resolve the CMS FQDN as required by the corresponding PacketCable Specifications.')
pktcMtaDevCmsKerbRealmName = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsKerbRealmName.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsKerbRealmName.setDescription(' This object identifies the Kerberos realm name in uppercase characters associated with the CMS defined in this conceptual row. The object value is a reference point to the corresponding Kerberos realm name in the realm table (pktcMtaDevRealmTable).')
pktcMtaDevCmsMaxClockSkew = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsMaxClockSkew.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsMaxClockSkew.setDescription(' This object specifies the maximum allowable clock skew between the MTA and the CMS defined in this row.')
pktcMtaDevCmsSolicitedKeyTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000)).clone(1000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsSolicitedKeyTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevCmsSolicitedKeyTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsSolicitedKeyTimeout.setDescription(' This object defines a Kerberos Key Management timer on the MTA. It is the time period during which the MTA saves the nonce and Server Kerberos Principal Identifier to match an AP Request and its associated AP Reply response from the CMS. This timer only applies when the CMS initiated key management (with a Wake Up message or a Rekey message).')
pktcMtaDevCmsUnsolicitedKeyMaxTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyMaxTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyMaxTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyMaxTimeout.setDescription(' This object defines the timeout value that only applies to an MTA-initiated key management exchange. It is the maximum timeout, and it may not be exceeded in the exponential back-off algorithm.')
pktcMtaDevCmsUnsolicitedKeyNomTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000)).clone(500)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyNomTimeout.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyNomTimeout.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyNomTimeout.setDescription(' This object defines the starting value of the timeout for an MTA-initiated key management. It should account for the average roundtrip time between the MTA and the CMS and the processing time on the CMS.')
pktcMtaDevCmsUnsolicitedKeyMaxRetries = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyMaxRetries.setReference(' PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyMaxRetries.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsUnsolicitedKeyMaxRetries.setDescription(' This object contains the maximum number of retries before the MTA stops attempting to establish a Security Association with the CMS.')
pktcMtaDevCmsIpsecCtrl = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 9), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcMtaDevCmsIpsecCtrl.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsIpsecCtrl.setDescription(" This object specifies the MTA IPSec control flag. If the object value is 'true', the MTA must use Kerberos Key Management and IPsec to communicate with this CMS. If it is 'false', IPSec Signaling Security and Kerberos key management are disabled for this specific CMS.")
pktcMtaDevCmsStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 140, 1, 3, 8, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcMtaDevCmsStatus.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevCmsStatus.setDescription(" This object defines the row status associated with this particular CMS in the CMS table (pktcMtaDevCmsTable). An entry in this table is not qualified for activation until the object instances of all corresponding columns have been initialized, either by default values or via explicit SET operations. Until all object instances in this row are initialized, the status value for this realm must be 'notReady(3)'. In particular, two columnar objects must be SET: the CMS FQDN (pktcMtaDevCmsFqdn) and the Kerberos realm name (pktcMtaDevCmsKerbRealmName). Once these 2 objects have been set and the row status is SET to 'active(1)', the MTA MUST NOT allow any modification of these 2 object values. The value of this object has no effect on whether other columnar objects in this row can be modified.")
pktcMtaDevResetKrbTickets = MibScalar((1, 3, 6, 1, 2, 1, 140, 1, 3, 9), Bits().clone(namedValues=NamedValues(("invalidateProvOnReboot", 0), ("invalidateAllCmsOnReboot", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcMtaDevResetKrbTickets.setReference('PacketCable Security Specification.')
if mibBuilder.loadTexts: pktcMtaDevResetKrbTickets.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevResetKrbTickets.setDescription(" This object defines a Kerberos Ticket Control Mask that instructs the MTA to invalidate the specific Application Server Kerberos ticket(s) that are stored locally in the MTA NVRAM (non-volatile or persistent memory). If the MTA does not store Kerberos tickets in NVRAM, it MUST ignore setting of this object and MUST report a BITS value of zero when the object is read. If the MTA supports Kerberos tickets storage in NVRAM, the object value is encoded as follows: - Setting the invalidateProvOnReboot bit (bit 0) to 1 means that the MTA MUST invalidate the Kerberos Application Ticket(s) for the Provisioning Application at the next MTA reboot if secure SNMP provisioning mode is used. In non-secure provisioning modes, the MTA MUST return an 'inconsistentValue' in response to SNMP SET operations with a bit 0 set to 1. - Setting the invalidateAllCmsOnReboot bit (bit 1) to 1 means that the MTA MUST invalidate the Kerberos Application Ticket(s) for all CMSes currently assigned to the MTA endpoints. If a value is written into an instance of pktcMtaDevResetKrbTickets, the agent MUST retain the supplied value across an MTA re-initialization or reboot.")
pktcMtaDevErrorsTooManyErrors = ObjectIdentity((1, 3, 6, 1, 2, 1, 140, 1, 4, 1))
if mibBuilder.loadTexts: pktcMtaDevErrorsTooManyErrors.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevErrorsTooManyErrors.setDescription('This object defines the OID corresponding to the error condition when too many errors are encountered in the MTA configuration file during provisioning.')
pktcMtaDevProvisioningEnrollment = NotificationType((1, 3, 6, 1, 2, 1, 140, 0, 1)).setObjects(("SNMPv2-MIB", "sysDescr"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevSwCurrentVers"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevTypeIdentifier"), ("IF-MIB", "ifPhysAddress"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCorrelationId"))
if mibBuilder.loadTexts: pktcMtaDevProvisioningEnrollment.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvisioningEnrollment.setDescription(' This INFORM notification is issued by the MTA to initiate the PacketCable provisioning process when the MTA SNMP enrollment mechanism is used. It contains the system description, the current software version, the MTA device type identifier, the MTA MAC address (obtained in the MTA ifTable in the ifPhysAddress object that corresponds to the ifIndex 1), and a correlation ID.')
pktcMtaDevProvisioningStatus = NotificationType((1, 3, 6, 1, 2, 1, 140, 0, 2)).setObjects(("IF-MIB", "ifPhysAddress"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCorrelationId"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvisioningState"))
if mibBuilder.loadTexts: pktcMtaDevProvisioningStatus.setStatus('current')
if mibBuilder.loadTexts: pktcMtaDevProvisioningStatus.setDescription(' This INFORM notification may be issued by the MTA to confirm the completion of the PacketCable provisioning process, and to report its provisioning completion status. It contains the MTA MAC address (obtained in the MTA ifTable in the ifPhysAddress object that corresponds to the ifIndex 1), a correlation ID and the MTA provisioning state as defined in pktcMtaDevProvisioningState.')
pktcMtaCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 2, 1))
pktcMtaGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 140, 2, 2))
pktcMtaBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 140, 2, 1, 1)).setObjects(("PKTC-IETF-MTA-MIB", "pktcMtaGroup"), ("PKTC-IETF-MTA-MIB", "pktcMtaNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcMtaBasicCompliance = pktcMtaBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: pktcMtaBasicCompliance.setDescription(' The compliance statement for MTA devices that implement PacketCable or IPCablecom requirements. This compliance statement applies to MTA implementations that support PacketCable 1.0 or IPCablecom requirements, which are not IPv6-capable at the time of this RFC publication.')
pktcMtaGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 140, 2, 2, 1)).setObjects(("PKTC-IETF-MTA-MIB", "pktcMtaDevResetNow"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevSerialNumber"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevSwCurrentVers"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevFQDN"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevEndPntCount"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevEnabled"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvisioningCounter"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevErrorOid"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevErrorValue"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevErrorReason"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevTypeIdentifier"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvisioningState"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevHttpAccess"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCertificate"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCorrelationId"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevManufacturerCertificate"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevDhcpServerAddressType"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevDnsServerAddressType"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevTimeServerAddressType"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvConfigEncryptAlg"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevServerDhcp1"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevServerDhcp2"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevServerDns1"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevServerDns2"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevTimeServer"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevConfigFile"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevSnmpEntity"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmPkinitGracePeriod"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmTgsGracePeriod"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmAvailSlot"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmName"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmOrgName"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmUnsolicitedKeyMaxTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmUnsolicitedKeyNomTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmUnsolicitedKeyMaxRetries"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevRealmStatus"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsAvailSlot"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsFqdn"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsKerbRealmName"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsUnsolicitedKeyMaxTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsUnsolicitedKeyNomTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsUnsolicitedKeyMaxRetries"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsSolicitedKeyTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsMaxClockSkew"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsIpsecCtrl"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevCmsStatus"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevResetKrbTickets"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvUnsolicitedKeyMaxTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvUnsolicitedKeyNomTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvUnsolicitedKeyMaxRetries"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvKerbRealmName"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvSolicitedKeyTimeout"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvConfigHash"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvConfigKey"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvState"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvisioningTimer"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevTelephonyRootCertificate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcMtaGroup = pktcMtaGroup.setStatus('current')
if mibBuilder.loadTexts: pktcMtaGroup.setDescription(' A collection of objects for managing PacketCable or IPCablecom MTA implementations.')
pktcMtaNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 140, 2, 2, 2)).setObjects(("PKTC-IETF-MTA-MIB", "pktcMtaDevProvisioningStatus"), ("PKTC-IETF-MTA-MIB", "pktcMtaDevProvisioningEnrollment"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcMtaNotificationGroup = pktcMtaNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: pktcMtaNotificationGroup.setDescription(' A collection of notifications dealing with the change of MTA provisioning status.')
pktcMtaBasicSmtaCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 140, 2, 1, 2)).setObjects(("PKTC-IETF-MTA-MIB", "pktcMtaGroup"), ("PKTC-IETF-MTA-MIB", "pktcMtaNotificationGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroupV2"), ("DOCS-IETF-BPI2-MIB", "docsBpi2CodeDownloadGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcMtaBasicSmtaCompliance = pktcMtaBasicSmtaCompliance.setStatus('current')
if mibBuilder.loadTexts: pktcMtaBasicSmtaCompliance.setDescription(' The compliance statement for S-MTA devices that implement PacketCable or IPCablecom requirements. This compliance statement applies to S-MTA implementations that support PacketCable or IPCablecom requirements, which are not IPv6-capable at the time of this RFC publication.')
mibBuilder.exportSymbols("PKTC-IETF-MTA-MIB", pktcMtaDevErrorsTooManyErrors=pktcMtaDevErrorsTooManyErrors, pktcMtaDevProvisioningStatus=pktcMtaDevProvisioningStatus, pktcMtaDevRealmAvailSlot=pktcMtaDevRealmAvailSlot, pktcMtaDevErrorOidIndex=pktcMtaDevErrorOidIndex, pktcMtaNotificationGroup=pktcMtaNotificationGroup, pktcMtaDevDhcpServerAddressType=pktcMtaDevDhcpServerAddressType, pktcMtaBasicSmtaCompliance=pktcMtaBasicSmtaCompliance, pktcMtaDevResetNow=pktcMtaDevResetNow, pktcMtaConformance=pktcMtaConformance, PYSNMP_MODULE_ID=pktcIetfMtaMib, pktcMtaDevCmsIndex=pktcMtaDevCmsIndex, pktcMtaDevErrorOidsTable=pktcMtaDevErrorOidsTable, pktcIetfMtaMib=pktcIetfMtaMib, pktcMtaDevProvisioningCounter=pktcMtaDevProvisioningCounter, pktcMtaDevManufacturerCertificate=pktcMtaDevManufacturerCertificate, pktcMtaDevProvUnsolicitedKeyMaxRetries=pktcMtaDevProvUnsolicitedKeyMaxRetries, pktcMtaDevProvConfigHash=pktcMtaDevProvConfigHash, pktcMtaDevCmsTable=pktcMtaDevCmsTable, pktcMtaGroups=pktcMtaGroups, pktcMtaDevCmsEntry=pktcMtaDevCmsEntry, pktcMtaDevFQDN=pktcMtaDevFQDN, pktcMtaDevTimeServerAddressType=pktcMtaDevTimeServerAddressType, pktcMtaDevRealmTgsGracePeriod=pktcMtaDevRealmTgsGracePeriod, pktcMtaDevConfigFile=pktcMtaDevConfigFile, pktcMtaDevCmsUnsolicitedKeyMaxTimeout=pktcMtaDevCmsUnsolicitedKeyMaxTimeout, PktcMtaDevProvEncryptAlg=PktcMtaDevProvEncryptAlg, pktcMtaDevProvConfigKey=pktcMtaDevProvConfigKey, pktcMtaDevHttpAccess=pktcMtaDevHttpAccess, pktcMtaDevSwCurrentVers=pktcMtaDevSwCurrentVers, pktcMtaDevDnsServerAddressType=pktcMtaDevDnsServerAddressType, pktcMtaGroup=pktcMtaGroup, pktcMtaDevTypeIdentifier=pktcMtaDevTypeIdentifier, pktcMtaDevRealmUnsolicitedKeyNomTimeout=pktcMtaDevRealmUnsolicitedKeyNomTimeout, pktcMtaDevProvisioningState=pktcMtaDevProvisioningState, pktcMtaDevResetKrbTickets=pktcMtaDevResetKrbTickets, pktcMtaDevProvState=pktcMtaDevProvState, pktcMtaDevProvKerbRealmName=pktcMtaDevProvKerbRealmName, pktcMtaDevCmsUnsolicitedKeyNomTimeout=pktcMtaDevCmsUnsolicitedKeyNomTimeout, pktcMtaDevRealmTable=pktcMtaDevRealmTable, pktcMtaDevRealmOrgName=pktcMtaDevRealmOrgName, pktcMtaBasicCompliance=pktcMtaBasicCompliance, pktcMtaDevCmsFqdn=pktcMtaDevCmsFqdn, pktcMtaDevTimeServer=pktcMtaDevTimeServer, pktcMtaDevServerDhcp1=pktcMtaDevServerDhcp1, pktcMtaDevServerDns1=pktcMtaDevServerDns1, pktcMtaDevErrorOid=pktcMtaDevErrorOid, pktcMtaDevBase=pktcMtaDevBase, pktcMtaDevCorrelationId=pktcMtaDevCorrelationId, pktcMtaDevErrorValue=pktcMtaDevErrorValue, pktcMtaDevProvConfigEncryptAlg=pktcMtaDevProvConfigEncryptAlg, pktcMtaDevServerDns2=pktcMtaDevServerDns2, pktcMtaDevRealmPkinitGracePeriod=pktcMtaDevRealmPkinitGracePeriod, pktcMtaDevProvUnsolicitedKeyMaxTimeout=pktcMtaDevProvUnsolicitedKeyMaxTimeout, pktcMtaDevProvisioningTimer=pktcMtaDevProvisioningTimer, pktcMtaDevTelephonyRootCertificate=pktcMtaDevTelephonyRootCertificate, pktcMtaDevServerDhcp2=pktcMtaDevServerDhcp2, pktcMtaDevEndPntCount=pktcMtaDevEndPntCount, pktcMtaDevRealmName=pktcMtaDevRealmName, pktcMtaDevErrorReason=pktcMtaDevErrorReason, pktcMtaDevCertificate=pktcMtaDevCertificate, pktcMtaDevRealmUnsolicitedKeyMaxRetries=pktcMtaDevRealmUnsolicitedKeyMaxRetries, pktcMtaDevCmsAvailSlot=pktcMtaDevCmsAvailSlot, pktcMtaNotification=pktcMtaNotification, pktcMtaDevCmsIpsecCtrl=pktcMtaDevCmsIpsecCtrl, pktcMtaDevCmsUnsolicitedKeyMaxRetries=pktcMtaDevCmsUnsolicitedKeyMaxRetries, pktcMtaDevSecurity=pktcMtaDevSecurity, pktcMtaDevProvSolicitedKeyTimeout=pktcMtaDevProvSolicitedKeyTimeout, pktcMtaCompliances=pktcMtaCompliances, pktcMtaDevRealmIndex=pktcMtaDevRealmIndex, pktcMtaDevRealmStatus=pktcMtaDevRealmStatus, pktcMtaDevEnabled=pktcMtaDevEnabled, pktcMtaDevErrors=pktcMtaDevErrors, pktcMtaDevProvUnsolicitedKeyNomTimeout=pktcMtaDevProvUnsolicitedKeyNomTimeout, pktcMtaDevCmsKerbRealmName=pktcMtaDevCmsKerbRealmName, pktcMtaDevErrorOidsEntry=pktcMtaDevErrorOidsEntry, pktcMtaDevRealmUnsolicitedKeyMaxTimeout=pktcMtaDevRealmUnsolicitedKeyMaxTimeout, pktcMtaDevServer=pktcMtaDevServer, pktcMtaDevSnmpEntity=pktcMtaDevSnmpEntity, pktcMtaMibObjects=pktcMtaMibObjects, pktcMtaDevCmsStatus=pktcMtaDevCmsStatus, pktcMtaDevRealmEntry=pktcMtaDevRealmEntry, pktcMtaDevCmsMaxClockSkew=pktcMtaDevCmsMaxClockSkew, pktcMtaDevProvisioningEnrollment=pktcMtaDevProvisioningEnrollment, pktcMtaDevSerialNumber=pktcMtaDevSerialNumber, pktcMtaDevCmsSolicitedKeyTimeout=pktcMtaDevCmsSolicitedKeyTimeout)

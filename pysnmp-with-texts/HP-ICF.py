#
# PySNMP MIB module HP-ICF (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-ICF
# Produced by pysmi-0.3.4 at Wed May  1 13:33:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
rptrAddrTrackLastSourceAddress, rptrPortAdminStatus = mibBuilder.importSymbols("SNMP-REPEATER-MIB", "rptrAddrTrackLastSourceAddress", "rptrPortAdminStatus")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Integer32, enterprises, IpAddress, iso, ModuleIdentity, MibIdentifier, NotificationType, Unsigned32, Counter32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter64, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "enterprises", "IpAddress", "iso", "ModuleIdentity", "MibIdentifier", "NotificationType", "Unsigned32", "Counter32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter64", "TimeTicks", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
nm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2))
hpSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3))
netElement = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7))
icf = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class TimeStamp(TimeTicks):
    pass

class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

class TAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 127)

hpicfAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10))
hpicfDomains = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 1))
hpicfLLCDomain = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 1, 1))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 1))
router = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8))
bridge1010 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 1, 1))
bridgeRemote = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 1, 2))
eswitch = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 1, 3))
icfRouterER = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 1))
icfRouterTR = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 2))
icfRouterSR = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 3))
icfRouterFR = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 4))
icfRouterLR = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 5))
icfRouterBR = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 6))
icfRouterPR = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 7))
icfRouter650 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 8))
icfRouter230 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 9))
icfRouter250 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 10))
icfRouter255 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 11))
icfRouter210 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 12))
icfRouter650Engine = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 8, 2))
icfRouter650Port4E = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 8, 3))
icfRouter650Port4S = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 8, 4))
icfRouter650Port4T = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 2, 8, 5))
etherTwist12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 1))
fiberOptic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 3))
etherTwist48 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 4))
thinLAN = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 5))
etherTwist24S = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 6))
advStack12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 7))
advStack24 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 8))
advStack48 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 9))
advStackVg15 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 10))
advStackU8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 11))
advStackU16 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 5, 12))
repeaterAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 1))
chassisAgents = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 2))
icfSensors = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 3))
icfVgAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 2, 1))
icfEnetAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 2, 2))
icfPowerSupplySensor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 3, 1))
icfFanSensor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 3, 2))
icfTemperatureSensor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 8, 3, 3))
icfCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1))
lastSetError = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111))).clone(namedValues=NamedValues(("unexpectedError", 100), ("resourceLimitExceeded", 101), ("disallowedSTPPortState", 102), ("incompleteSetlet", 103), ("invalidEventObject", 104), ("disallowedRemoteDevice", 105), ("disallowedLAPBAdrsPair", 106), ("adrsAlreadyPresent", 107), ("staticSectionFull", 108), ("cantDeletePermAdrs", 109), ("inconsistentValues", 110), ("downloadInProgress", 111)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastSetError.setStatus('obsolete')
if mibBuilder.loadTexts: lastSetError.setDescription("Provide more detailed, enterprise specific error type. Any error resulting from a SET request will cause this object to be updated, and the previous value overwritten. A management entity may retrieve more detailed error information than that implied by the pdu's ErrorStatus, especially in the case of a genErr. In SNMPv2, there are several more error codes which provide most of the information that is provided by the above codes. Therefore, this object is now obsolete.")
password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: password.setStatus('obsolete')
if mibBuilder.loadTexts: password.setDescription("This is the encrypted password for the device. The algorithm used for the encryption process is HP proprietary. Third party vendor support is provided by not setting a password on the device, and using the community name 'public'. This object is now obsolete, and is supported only on 'D' revision EtherTwist hubs and bridges and earlier. It has been superseded by icfSecurPassword.")
reset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("warm", 1), ("cold", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reset.setStatus('obsolete')
if mibBuilder.loadTexts: reset.setDescription("When the reset object is set to to 'warm' it results in a 'warm' reset, which does not clear the parameters in NOVRAM to factory defaults. When set to 'cold', it results in NOVRAM being set to factory defaults. When this object is set, the agent replies, dallies a short time to allow the reply to be emitted from the device, then performs the reset. When read, this object always returns 0. This object is now obsolete. It has been replaced by hpicfReset.")
selfTest = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selfTest.setStatus('obsolete')
if mibBuilder.loadTexts: selfTest.setDescription("Self test is invoked by setting this flag to 'stExecute. When the object changes to 'stSuccess', the test has completed successfully. Icf devices will 'hard-fail' if the test does not succeed. This object is now obsolete. It has been replaced by hpicfSelfTest.")
semaphore = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: semaphore.setStatus('obsolete')
if mibBuilder.loadTexts: semaphore.setDescription("This object allows a set of objects to be locked. The lock is only assured by the 'cooperation' of other management entities; they must wait until the lock is cleared (to value zero) prior to setting the lock. When this object is set to a management entity's IP address, if no other management entity has previously set the lock, the set will succeed. Otherwise, an error (BadValue) will be returned. It is the responsibility of the owning management entity to clear the lock when the transactions complete. To protect against a management entity failure during a locked transaction, the agent is NOT responsible for verifying which management entity is performing transactions on locked objects; thus, any management entity can clear this object at any time. The agent does not do anything with this object except disallow multiple sets of different IP addresses (unless the object has been cleared to zero). This means management entities can use this for locking any valid transactions on defined sets of objects. This object can also be used on IPX networks by specifying the low 4 bytes of the station address for the IpAddress. This object is now obsolete. Individual groups of objects now maintain their own locking mechanisms.")
discovery = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6))
pollResponse = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollResponse.setStatus('obsolete')
if mibBuilder.loadTexts: pollResponse.setDescription("Flag indicating whether device should respond to multicast SNMP PDUs. When set 'true', the device will respond to multicast SNMP PDU's. Otherwise, the response is discarded.")
announceAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: announceAddress.setStatus('deprecated')
if mibBuilder.loadTexts: announceAddress.setDescription("When set to any MAC multicast address, the device will transmit three identical packets, each with the MAC source set to the device's MAC address, the MAC destination to the multi-cast address, the destination SAP is F8, and the destination HP XSAP is 165D. These packets will traverse other ICF devices, allowing them to learn the port connectivity of the multicasting device.")
mapAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapAddress.setStatus('deprecated')
if mibBuilder.loadTexts: mapAddress.setDescription('When this object is set a map address search begins. If the address is detected on only one port, then the mapPort object is set to the port number on which the address was detected. This object has been deprecated.')
mapState = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapState.setStatus('deprecated')
if mibBuilder.loadTexts: mapState.setDescription("This object will be set to 'psNone' if the address set in the mapAddress object has not been received on any of the device's interface/ports. It will be set to 'psSingle' if the mapAddress has been detected on only one interface/port. It will be set to 'psMany' if the mapAddress has been detected on more than one interface/port. This object has been deprecated.")
mapPort = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapPort.setStatus('deprecated')
if mibBuilder.loadTexts: mapPort.setDescription("The port number on which the map address was detected. If map state is 'psNone' or 'psMany' then this object is not valid. This object has been deprecated.")
ipSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 6, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSubnetMask.setStatus('obsolete')
if mibBuilder.loadTexts: ipSubnetMask.setDescription('This object is the IP subnet mask. This object is obsolete. Management applications should retrieve the ipAddrTable, which contains the ipAdEntNetMask object for each interface on the device.')
icfEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7))
eventNotificationNode = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 1))
evtIpNotify = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evtIpNotify.setStatus('obsolete')
if mibBuilder.loadTexts: evtIpNotify.setDescription('The network address of the manager node which is to receive the event notification trap. This functionality is currently duplicated in the authorized manager list.')
evtIpxNotify = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evtIpxNotify.setStatus('obsolete')
if mibBuilder.loadTexts: evtIpxNotify.setDescription('The IPX address of the manager node which is to receive the event notification trap. This functionality is currently duplicated in the authorized manager list.')
evtTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 2), )
if mibBuilder.loadTexts: evtTable.setStatus('obsolete')
if mibBuilder.loadTexts: evtTable.setDescription('A list of event entries for event processing.')
evtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("warmStartEvent", 1), ("coldStartEvent", 2), ("spanTreeOrLinkBeatEvent", 3), ("temperatureOrSegmentationEvent", 4), ("backupLinkEvent", 5), ("intrusionEvent", 6), ("addressMovedEvent", 7), ("newAddressEvent", 8), ("rptrHealthEvent", 9), ("rptrResetEvent", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evtIndex.setStatus('obsolete')
if mibBuilder.loadTexts: evtIndex.setDescription('The index value which uniquely identifies the event to which this entry is applicable.')
evtArm = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evtArm.setStatus('obsolete')
if mibBuilder.loadTexts: evtArm.setDescription('This object arms and disarms events. Events are implicitly rearmed, that is, once an event occurs, it is rearmed. Sets to the intrusionEvent instance of this object are ignored, since intrusion events are actually armed through the hubSecPtAlarmEnable object.')
evtTimeSinceOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evtTimeSinceOccurrence.setStatus('obsolete')
if mibBuilder.loadTexts: evtTimeSinceOccurrence.setDescription('This object specifies the number of centiseconds since this event last occurred.')
evtThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3), )
if mibBuilder.loadTexts: evtThresholdTable.setStatus('obsolete')
if mibBuilder.loadTexts: evtThresholdTable.setDescription('A list of event entries for event processing.')
evthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evthIndex.setStatus('obsolete')
if mibBuilder.loadTexts: evthIndex.setDescription('The index value which uniquely identifies the event to which this entry is applicable.')
evthArm = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evthArm.setStatus('obsolete')
if mibBuilder.loadTexts: evthArm.setDescription("This object arms and disarms events. The notification node, the associated event object, threshold, hysteresis, and time interval should all be set before an event is armed. The objects do not need to be re-set if the existing values are acceptable. The device will refuse to arm an event with uninitialized objects. Once armed, if the threshold is met or exceeded during the event time interval, a trap PDU is sent to the eventNotificationNode. Subsequently, the monitored object must fall to or below the hysteresis before another trap can be sent via the threshold mechanism. The hysteresis may equal threshold. Events are implicitly rearmed, that is, once an event occurs, it is rearmed. Setting this object to 'on' will result in a genErr in any of the following cases: object not set; cannot set an event on this object; time interval not set; threshold not set.")
evthObject = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evthObject.setStatus('obsolete')
if mibBuilder.loadTexts: evthObject.setDescription('The data of this object is itself an OBJECT IDENTIFIER which selects the mib object and instance that is to be monitored for the event. Only types INTEGER and Counter are allowed.')
evthThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evthThreshold.setStatus('obsolete')
if mibBuilder.loadTexts: evthThreshold.setDescription('The threshold against which the variable specified in evthObject is tested over the time interval specified in the evthTimeInterval When the threshold is met or exceeded, the event is triggered. The event will not trigger again until the variable falls to or below the evthHysteresis value, and then meets or exceeds the threshold.')
evthHysteresis = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evthHysteresis.setStatus('obsolete')
if mibBuilder.loadTexts: evthHysteresis.setDescription('The low value which the variable specified in evthObject must fall to or below after exceeding evthThreshold before the event can re-occur when the threshold is met or exceeded.')
evthTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 6), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evthTimeInterval.setStatus('obsolete')
if mibBuilder.loadTexts: evthTimeInterval.setDescription('The time interval over which the variable specified in the evthObject is sampled.')
evthTimeSinceOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 7, 3, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evthTimeSinceOccurrence.setStatus('obsolete')
if mibBuilder.loadTexts: evthTimeSinceOccurrence.setDescription('This object specifies the number of centiseconds since this event was last triggered.')
linkTest = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8))
linkTestAddress = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 1))
linkTest802MacAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkTest802MacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: linkTest802MacAddress.setDescription('If this object is set to the MAC address of a node to link test in the same PDU that sets linkTestRepetitions to a nonzero value, the link test performed will use IEEE 802 Test frames. Note that setting more than one of linkTest802MacAddress, linkTestIpAddress, and linkTestIpxAddress to a non-null value in the same PDU will result in a genErr.')
linkTestIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkTestIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: linkTestIpAddress.setDescription('If this object is set to the network address of a node to link test in the same PDU that sets linkTestRepetitions to a nonzero value, the link test performed will use ICMP Echo packets. Note that setting more than one of linkTest802MacAddress, linkTestIpAddress, and linkTestIpxAddress to a non-null value in the same PDU will result in a genErr.')
linkTestIpxAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkTestIpxAddress.setStatus('deprecated')
if mibBuilder.loadTexts: linkTestIpxAddress.setDescription('If this object is set to the IPX address of a node to link test in the same PDU that sets linkTestRepetitions to a nonzero value, the link test performed will use IPX diagnostic packets. Note that setting more than one of linkTest802MacAddress, linkTestIpAddress, and linkTestIpxAddress to a non-null value in the same PDU will result in a genErr.')
linkTestRepetitions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkTestRepetitions.setStatus('deprecated')
if mibBuilder.loadTexts: linkTestRepetitions.setDescription("The number of link tests that the device is to complete. When this object is set to a non-zero value, the linkTestSuccess object is zeroed and the device begins a link test using IEEE 802.2 Test frames, ICMP Echo packets, or IPX diagnostic packets depending on the address selected. Link test results are contained in the link test success object. This object's value decrements (to zero) as the test proceeds. The test may be canceled at any point by setting this object to 0.")
linkTestSuccess = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkTestSuccess.setStatus('deprecated')
if mibBuilder.loadTexts: linkTestSuccess.setDescription('For every successful link test, this counter is incremented. When link tests are completed, this counter contains the total number of successful tests.')
linkTestTimeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 8, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkTestTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: linkTestTimeout.setDescription('The time interval over which a link test response must be received, or the test is counted as failed.')
icf8023MacTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9), )
if mibBuilder.loadTexts: icf8023MacTable.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacTable.setDescription('A list of icf8023Mac entries.')
icf8023MacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacIndex.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacIndex.setDescription('The index value which uniquely identifies the port to which this entry is applicable. The port identified by a particular value of this index on a hub is the same port as identified by the same value of rptrPortIndex. Note that since this hub always has exactly 1 port group, there is no group index for this table. For a bridge, the port identified by a particular value of this index is the same port identified by the same value of ifIndex.')
icf8023MacInBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacInBroadcastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacInBroadcastPkts.setDescription('Count of the broadcast packets received.')
icf8023MacOutBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacOutBroadcastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacOutBroadcastPkts.setDescription('Count of the broadcast packets transmitted.')
icf8023MacInMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacInMulticastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacInMulticastPkts.setDescription('Count of the multicast packets received.')
icf8023MacOutMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacOutMulticastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacOutMulticastPkts.setDescription('Count of the multicast packets transmitted.')
icf8023MacRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacRunts.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacRunts.setDescription('The number of media frames encountered that were too short (by ethernet/802.3 standards).')
icf8023MacGiants = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacGiants.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacGiants.setDescription('The number of media frames encountered that were too long (by ethernet/802.3 standards).')
icf8023MacMissedPktErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacMissedPktErrors.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacMissedPktErrors.setDescription('The number of frames lost due to lack of resources (e.g. ring buffers, memory buffers, etc).')
icf8023MacExcessDeferrals = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacExcessDeferrals.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacExcessDeferrals.setDescription('The number of times a frame could not be sent due to excess deferrals because another node was transmitting continually.')
icf8023MacTotalMediaErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacTotalMediaErrors.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacTotalMediaErrors.setDescription('Count of all possible medium transmit and receive errors, such as crc, alignment, sequence, length, excess etc. The purpose of this object is to support aggregate LAN medium errors for event processing. Collisions and runts are not considered an error.')
icf8023MacSpuriousIntrs = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 9, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icf8023MacSpuriousIntrs.setStatus('obsolete')
if mibBuilder.loadTexts: icf8023MacSpuriousIntrs.setDescription('The number of times that the network interface for this port generated a spurious hardware interrupt. A non-zero value for this object indicates a potential hardware problem.')
icfDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 10))
icfDownloadAddress = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 10, 1))
icfDownloadIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfDownloadIpAddress.setStatus('obsolete')
if mibBuilder.loadTexts: icfDownloadIpAddress.setDescription('The IP address of the TFTP server to download firmware from.')
icfDownloadIpxAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfDownloadIpxAddress.setStatus('obsolete')
if mibBuilder.loadTexts: icfDownloadIpxAddress.setDescription('The IPX address of the TFTP server to download firmware from.')
icfDownloadFilename = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 1, 10, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfDownloadFilename.setStatus('obsolete')
if mibBuilder.loadTexts: icfDownloadFilename.setDescription('Filename and path of file to download (maximum length of 63 characters + NULL).')
icfHub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 2))
hubThinlanFault = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubThinlanFault.setStatus('obsolete')
if mibBuilder.loadTexts: hubThinlanFault.setDescription("When set to 'true' this object causes the Fault LED to blink if the ThinLan Port is segmented. This object has been deprecated in favor of hpRptrThinlanFault.")
hubGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2))
hubGlobalErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalErrors.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalErrors.setDescription('This counter is incremented for each packet with an error received on any port. This counter does not include runts, as they are a normal media condition. This object has been deprecated in favor of hpRptrMonGlobalErrors.')
hubGlobalCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalCollisions.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalCollisions.setDescription('This counter is incremented for each collision between any two or more ports (or AUI) detected by the hub. This object has been deprecated in favor of rptrMonitorTransmitCollisions.')
hubGlobalPktFragments = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalPktFragments.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalPktFragments.setDescription('This counter is the sum of hubPortPktFragments for all ports. This object has been deprecated in favor of hpRptrMonGlobalFrames.')
hubGlobalRunts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalRunts.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalRunts.setDescription('This counter is incremented for each runt frame received on any port. This object has been deprecated in favor of hpRptrMonGlobalRunts.')
hubGlobalGiants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalGiants.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalGiants.setDescription('This counter is incremented for each giant frame received on any port. This object has been deprecated in favor of hpRptrMonGlobalFrameTooLongs.')
hubGlobalCrcErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalCrcErrors.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalCrcErrors.setDescription('This counter is incremented for each frame with a CRC error received on any port. This object has been deprecated in favor of hpRptrMonGlobalFCSErrors.')
hubGlobalAlignmentErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalAlignmentErrors.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalAlignmentErrors.setDescription('This counter is incremented for each frame with an alignment error received on any port. This object has been deprecated in favor of hpRptrMonGlobalAlignmentErrors.')
hubGlobalInOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalInOctets.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalInOctets.setDescription('This counter is incremented for each octet received on any port. This object has been deprecated in favor of hpRptrMonGlobalOctets.')
hubGlobalInUcastPkts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalInUcastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalInUcastPkts.setDescription('This counter is incremented for each unicast packet received on any port. This counter has been deprecated in favor of hpRptrMonGlobalUcastPackets.')
hubGlobalInNUcastPkts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalInNUcastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalInNUcastPkts.setDescription('This counter is incremented for each non-unicast packet received on any port. This object has been deprecated in favor of hpRptrMonGlobalBcastPackets and hpRptrMonGlobalMcastPackets.')
hubGlobalInBroadcastPkts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubGlobalInBroadcastPkts.setStatus('obsolete')
if mibBuilder.loadTexts: hubGlobalInBroadcastPkts.setDescription('This counter is incremented for each broadcast packet received on any port. This object has been deprecated in favor of hpRptrMonGlobalBcastPackets.')
hubPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3), )
if mibBuilder.loadTexts: hubPortTable.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortTable.setDescription('A list of hubPort entries.')
hubPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortIndex.setDescription('The index value which uniquely identifies the port to which this entry is applicable. The port identified by a particular value of this index is the same port as identified by the same value of rptrPortIndex.')
hubPortPktFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortPktFragments.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortPktFragments.setDescription('This counter is incremented when a packet or packet fragment is encountered for a port instance. This object has been deprecated in favor of rptrMonitorPortReadableFrames.')
hubPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortCollisions.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortCollisions.setDescription('This counter is incremented when a port is involved in a collision. This object has been deprecated in favor of rptrMonitorPortCollisions.')
hubPortSegmentation = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortSegmentation.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortSegmentation.setDescription("This is a flag which is 'true' if the port is currently segmented and 'false' otherwise. This object has been deprecated in favor of rptrPortAutoPartitionState.")
hubPortLinkBeatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortLinkBeatStatus.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortLinkBeatStatus.setDescription("This is a flag which is 'true' if link beat is detected on the port and 'false' otherwise. The value of this variable will always be 'true' when the corresponding instance of hubPortLinkBeatEnable is 'false'. This object has been deprecated in favor of rpMauMediaAvailable.")
hubPortLinkBeatEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubPortLinkBeatEnable.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortLinkBeatEnable.setDescription("When this flag is set to 'true' the port's link beat is enabled and when set to 'false' it is disabled. This object has been deprecated in favor of hpRptrPtLinkbeatEnable.")
hubPortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortMacAddress.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortMacAddress.setDescription("Each port maintains the MAC address of the node currently attached to it. This address is valid only when the port state flag is set to 'psSingle'. This object has been deprecated in favor of rptrAddrTrackNewLastSrcAddress.")
hubPortAddressState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubPortAddressState.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortAddressState.setDescription("The port state object may take on three values. 'psNone' means no packets have been received on the port. 'psSingle' means all packets received on the port have originated from a single MAC address. 'psMany' means that packets originating from more than one node have been received on the port. To (re)start a search for a MAC address set the port state to 'psNone'.")
hubPortPolarityReversed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortPolarityReversed.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortPolarityReversed.setDescription('This object is used to indicate that the hub port was wired with the positive/negative polarity of its transmit and receive pairs reversed. Note that the port will continue to operate in this state, with the hub inverting the polarity internally. This object has been deprecated in favor of hpRptrPtPolarityReversed.')
hubPortLateEventDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortLateEventDisable.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortLateEventDisable.setDescription("This object indicates that the hub port was disabled as a result of excessive late collisions being caused by the end node attached to this port. This flag is cleared when the port is reenabled by setting rptrPortAdminStatus to 'enabled'.")
hubBitmaps = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 4))
hubPortsOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubPortsOperStatus.setStatus('obsolete')
if mibBuilder.loadTexts: hubPortsOperStatus.setDescription('The hubPortsOperStatus is a bit map of the state of all hub ports. The object has a 1 bit for each port that is enabled, not segmented, and linkbeat is detected. Ports on which these conditions are not true have a 0 bit. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined. This object has been deprecated in favor of hpRptrGrpPortsAdminStatus.')
hubAddressTableMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubAddressTableMaxAge.setStatus('obsolete')
if mibBuilder.loadTexts: hubAddressTableMaxAge.setDescription('The hubAddressTableMaxAge is the time beyond which an inactive MAC address will be removed from the hubPortMacAddress table and the hubAddressTable. Although hubAddressTableMaxAge is specified in units of 10ms time ticks, the actual resolution of this timer is 10 seconds. A value of 65535000 indicates no aging shall take place.')
hubAddressTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 6), )
if mibBuilder.loadTexts: hubAddressTable.setStatus('deprecated')
if mibBuilder.loadTexts: hubAddressTable.setDescription('A list of entries present in the hub address table.')
hubAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 52))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddressIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hubAddressIndex.setDescription('The index value which uniquely identifies the chunk to which this entry is applicable.')
hubAddressChunk = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 6, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(408, 408)).setFixedLength(408)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddressChunk.setStatus('obsolete')
if mibBuilder.loadTexts: hubAddressChunk.setDescription("The hubAddressChunk object returns an opaque chunk of the address table. Each chunk can be interpreted as an array of records in the form: mac address [6 bytes], port number [2 bytes], inactivity time [4 bytes] On a Get, the returned chunk can include empty (unused) entries. Instances are chunk numbers, which start at 1 and go to 52. Each chunk can hold 34 addresses. A returned chunk might look like: Address Port Inactivity Time 080009001234 1 0 080009002345 2 10000 080009003456 1 20000 000000000000 1 0 080009009876 EMPTY 0 080009004567 EMPTY 15000 . . . 080009005678 EOL 959000 A value of EMPTY in the Port field indicates an unused (i.e. aged out) entry in the table. When the EOL (End Of List) bit is set in the Port field, that entry is the last entry in the table. It is possible for EOL to be seen in any entry. EOL (0x4000) and EMPTY (0x8000) are bit masks which are ORed with the port number in the port field of the entry. It is possible for both the EOL and EMPTY bits to be set in the same entry. The remainder of the chunk after the EOL entry will be zeroed. The inactivityTime and Address fields are meaningless if the EMPTY bit is set in the Port field. In this case, inactivityTime and Address are not guaranteed to be zeroed. The Manager may start with any chunk it likes and request the chunks in any order. It may perform multiple requests for the same chunk. The agent does not save state from previous requests. A request of chunk #1 would return the contents of the first 34 address table entries, whether they are all full, all empty, or some full and the rest empty. A request of chunk #2 will return entries #35 through #68. And so on. The address table can change between Get requests. An address' location can change, or an address could age out and then be added back in at a different location in the table. Thus, the Manager could see the address twice in the table.")
hubNumBkpLinks = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubNumBkpLinks.setStatus('obsolete')
if mibBuilder.loadTexts: hubNumBkpLinks.setDescription('The number of backup links configurable on this hub.')
hubBkpLinkTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8), )
if mibBuilder.loadTexts: hubBkpLinkTable.setStatus('obsolete')
if mibBuilder.loadTexts: hubBkpLinkTable.setDescription('A list of backup link configuration entries. For a given backup link, the hub will periodically send a test packet to the device at the end of the link. If there are no responses (the number is configurable), the hub will enable the backup port and disable the primary port. After the primary link is fixed, the user must turn the primary port on to resume normal operation. At any time, the management station can look at rptrPortAdminStatus for the backup port to determine if it is currently in use. The backup link algorithm enables and disables the backup port by modifying rptrPortAdminStatus for that port. After the backup port has been enabled by the backup link algorithm, if the primary port is subsequently enabled via the hub console port or by a set of rptrPortAdminStatus, the backup port will be turned off and the periodic test packets will begin again. When the backup link objects are set, the backup port will be turned off, the primary port will be turned on, and the periodic test packets will be sent. The time between test packets is configurable by setting hubBackupTestTime. The number of failures needed to switch to the backup link is configured by setting hubBackupConsecutiveFails. The backup link function can be turned off by setting hubBackupPort to 0. All five of the backup link objects must be set together in a single PDU except for the case of setting hubBackupPort to 0, in which case, the hubBackupPort can be set without setting the other objects. Currently, the size of the backup link table is one; future releases may provide the ability to monitor more than one backup link.')
hubBkpLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubBkpLinkIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hubBkpLinkIndex.setDescription('The index value which uniquely identifies the backup link configuration entry to which the instance is applicable.')
hubBackupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubBackupPort.setStatus('obsolete')
if mibBuilder.loadTexts: hubBackupPort.setDescription('The port number of the backup link. Setting this object to zero removes the backup link configuration.')
hubPrimaryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubPrimaryPort.setStatus('obsolete')
if mibBuilder.loadTexts: hubPrimaryPort.setDescription('The port number of the primary link. It can only be set to zero if the hubBackupPort is also zero.')
hubBackupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubBackupAddress.setStatus('obsolete')
if mibBuilder.loadTexts: hubBackupAddress.setDescription('The MAC address of the device at the other end of the primary link which will respond to the periodic test packets sent by this hub.')
hubBackupTestTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubBackupTestTime.setStatus('obsolete')
if mibBuilder.loadTexts: hubBackupTestTime.setDescription('The frequency, in time ticks, between sending the periodic test packets. The actual resolution of this timer is in seconds. The test packet response timeout is fixed at 500ms.')
hubBackupConsecutiveFails = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubBackupConsecutiveFails.setStatus('obsolete')
if mibBuilder.loadTexts: hubBackupConsecutiveFails.setDescription('The number of test packet failures which will cause the hub to switch to the backup link (i.e., backup port turned on, primary port turned off). A value of one is generally not recomended and will cause the backup link to be enabled upon the first failure.')
hubSqeEnabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSqeEnabled.setStatus('obsolete')
if mibBuilder.loadTexts: hubSqeEnabled.setDescription("When 'true', this flag indicates that SQE has been detected for the last ten agent transmits and there is a high probability that the SQE switch on the transceiver attached to the AUI port is set to Enabled, when it should be Disabled. This object has been deprecated in favor of hpRptrSqeEnabled.")
hubSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10))
hubSecurePortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1), )
if mibBuilder.loadTexts: hubSecurePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecurePortTable.setDescription('Table containing security configuration for each port.')
hubSecurePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1), ).setIndexNames((0, "HP-ICF", "hubSecPtGroupIndex"), (0, "HP-ICF", "hubSecPtPortIndex"))
if mibBuilder.loadTexts: hubSecurePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecurePortEntry.setDescription('An entry in the hubSecurePortTable, containing the security configuration for a single port.')
hubSecPtGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSecPtGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains security configuration information.')
hubSecPtPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSecPtPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtPortIndex.setDescription('This object identifies the port within the group for which this entry contains security configuration information.')
hubSecPtSecurityAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtSecurityAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtSecurityAddress.setDescription('The desired authorized MAC address for this port. This can be either a regular station address to configure a specific address, or it can be one of the following special values to specify the address learning method: FFFF-FFFF-FFFE: learnOnce. First source MAC address heard on this port becomes the authorized address. Setting this value initiates learning of a new authorized address. When a new authorized address is learned, it will be stored in nonvolatile memory. This variable will return learnOnceConditionally to a GET operation after it has been set to this value. FFFF-FFFF-FFFD: learnOnceConditionally. This option will initiate learning of a new authorized address only if the previous hubSecPtSecurityAddress was set to a specific address or learnContinuous. No action will be performed if the previous value was already learnOnceConditionally. FFFF-FFFF-FFFC: learnContinuous. Any address heard becomes the new authorized address. When a new address is learned, it may cause an alarm, but it does not store anything in nonvolatile memory.')
hubSecPtAuthorizedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSecPtAuthorizedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtAuthorizedAddress.setDescription('The MAC address of the station authorized to be on this port. This address could either have been configured by specifying a regular station address for hubSecPtSecurityAddress, or it could have been learned by the agent if hubSecPtSecurityAddress was set to one of the special values listed above. Once the agent has learned an authorized address, it will be saved across powerfails, unless the agent was configured for learnContinuous mode.')
hubSecPtPreventEavesdrop = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtPreventEavesdrop.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtPreventEavesdrop.setDescription('If enabled, unicast packets not addressed to the authorized address for this port will be scrambled.')
hubSecPtAlarmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtAlarmEnable.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtAlarmEnable.setDescription('If enabled, the agent will generate an intrusionTrap if a packet is received on this port with a source MAC address that is different from the hubSecPtAuthorizedAddress for this port.')
hubSecPtIntrusionFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("intrusion", 1), ("noIntrusion", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtIntrusionFlag.setStatus('mandatory')
if mibBuilder.loadTexts: hubSecPtIntrusionFlag.setDescription('This flag indicates if an intrusion has occurred on this port. The Security LED on the hub will blink if any instance of this flag has the value intrusion. Setting this flag to noIntrusion will turn off the Security LED if no other ports have this flag set to intrusion. An intrusion will only cause an alarm and an intrusion log entry if this flag is equal to noIntrusion.')
hubIntruderLogTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2), )
if mibBuilder.loadTexts: hubIntruderLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderLogTable.setDescription('This table contains a record of the twenty most recent port security violations. The first entry in the table is the oldest.')
hubIntruderLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1), ).setIndexNames((0, "HP-ICF", "hubIntruderIndex"))
if mibBuilder.loadTexts: hubIntruderLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderLogEntry.setDescription('A row in the hubIntruderLogTable containing information about a single port security violation.')
hubIntruderIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderIndex.setDescription('The index of this entry in the intruder log table. Index 1 will always contain the oldest entry. If the table is full when a new intrusion occurs, the new entry becomes index 20, and all earlier entries are shifted down by one entry, removing the old index 1.')
hubIntruderGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderGroup.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderGroup.setDescription('This object identifies the group containing the port on which this intrusion occurred.')
hubIntruderPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderPort.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderPort.setDescription('This object identifies the port within the group on which this intrusion occurred. A port number of zero indicates that this entry is unused and the values for the other variables in this entry are undefined.')
hubIntruderAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderAddress.setDescription('This object contains the source MAC address of the intruder.')
hubIntruderTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderTime.setStatus('mandatory')
if mibBuilder.loadTexts: hubIntruderTime.setDescription('The value of sysUpTime when the intrusion occurred. This will be zero if the agent has been reset since the intruder was detected, since sysUpTime could be misinterpreted in that case.')
hubAddressMoveLogTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11), )
if mibBuilder.loadTexts: hubAddressMoveLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddressMoveLogTable.setDescription('A log of the 20 most recent times that the agent detected that a source MAC address which had been heard on one port had moved to a different port.')
hubAddressMoveLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1), ).setIndexNames((0, "HP-ICF", "hubAddrMoveIndex"))
if mibBuilder.loadTexts: hubAddressMoveLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddressMoveLogEntry.setDescription('A row in the hubAddressMoveLogTable containing information about a single address movement.')
hubAddrMoveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddrMoveIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddrMoveIndex.setDescription('The index of this entry in the address movement log table. Index 1 will always contain the oldest entry. If the table is full when a new address movement occurs, the new entry becomes index 20, and all earlier entries are shifted down by one entry, removing the old index 1.')
hubAddrMoveAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddrMoveAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddrMoveAddress.setDescription('The MAC address of the station that moved to a new port.')
hubAddrMoveOldGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddrMoveOldGroup.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddrMoveOldGroup.setDescription('The group containing the port on which this address had been operating before it moved.')
hubAddrMoveOldPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddrMoveOldPort.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddrMoveOldPort.setDescription('The port within the group on which this address had been operating before it moved.')
hubAddrMoveNewGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddrMoveNewGroup.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddrMoveNewGroup.setDescription('The group containing the port that the address moved to.')
hubAddrMoveNewPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubAddrMoveNewPort.setStatus('mandatory')
if mibBuilder.loadTexts: hubAddrMoveNewPort.setDescription('The port within the group that the address moved to.')
hubLateEventMonitor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onSingle", 2), ("onAll", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubLateEventMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: hubLateEventMonitor.setDescription("This object configures the late event monitoring functionality for the hub. This mode periodically samples the rptrMonitorPortLateEvents value for each port. If the agent detects excessive late events on a port, the port will be disabled by setting the rptrPortAdminStatus for that port to 'disabled', and the hubPortLateEventDisable flag for that port will be set to 'true'. This mode is 'off' by default. Setting it to 'onSingle' enables the mode for all non-cascaded hub ports. Setting it to 'onAll' enables the mode for all hub ports, including cascaded ports.")
icfBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 3))
operationalState = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: operationalState.setStatus('obsolete')
if mibBuilder.loadTexts: operationalState.setDescription('This object controls the forwarding nature of the bridge. In the Learning state the bridge will learn new MAC addresses, and it ages out older MAC addresses. Statically configured addresses are discarded (they do not age). In the Secure state, the bridge will not learn new MAC addresses. Statically configured addresses are forwarded (they do not age).')
forwardDbMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: forwardDbMaxAge.setStatus('obsolete')
if mibBuilder.loadTexts: forwardDbMaxAge.setDescription("The value of this object controls how long a MAC address stays in the forwarding database. See 802.1d, section 3.9.2 'Dynamic Entries'.")
addressTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 3), )
if mibBuilder.loadTexts: addressTable.setStatus('obsolete')
if mibBuilder.loadTexts: addressTable.setDescription('A list of address entries.')
addressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: addressIndex.setStatus('obsolete')
if mibBuilder.loadTexts: addressIndex.setDescription('The index value which uniquely identifies the chunk to which this entry is applicable.')
addressChunk = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(410, 410)).setFixedLength(410)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addressChunk.setStatus('obsolete')
if mibBuilder.loadTexts: addressChunk.setDescription('This object returns an opaque chunk of the address table. The instance specifies a chunk of the address table. Each chunk can be interpreted as an array of 41 records of the form: { macAddress[6bytes], port number[2bytes], permanence[2bytes] }. Address Port Perm 00 080009001234 1 Dynamic(0x0000) 01 080009002345 2 Dynamic(0x0000) 02 000000000000 EMPTY(0x8000) Dynamic(0x0000) 03 080009003456 1 Dynamic(0x0000) 04 000000000000 1 Dynamic(0x0000) 05 080009009876 EMPTY(0x8000) Dynamic(0x0000) 06 080009004567 EMPTY(0x8000) Static(0x0008) 07 080009041d08 ... ... ... 40 080009005678 EOL(0x4000) Permanent(0x0000) A value of EMPTY in the Port field indicates an aged out table entry. A value of EOL in the Port field indicates that it is the last entry in the table. Of course, EOL will only be seen in the last entry. EOL and EMPTY are AND-able bit fields. The Disposition and Address are meaningless if Port is EMPTY. When instance=1 is used on a Set, the agent clears the table prior to setting any addresses. On subsequent Sets, the agent adds the specified addresses. If a Set starts at instance > 1, the specified addresses will be added to the table without first clearing the table. Addresses are already in the table are deleted and then readded.')
brgPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 4), )
if mibBuilder.loadTexts: brgPortTable.setStatus('obsolete')
if mibBuilder.loadTexts: brgPortTable.setDescription('A list of brgPort entries.')
brgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brgPortIndex.setStatus('obsolete')
if mibBuilder.loadTexts: brgPortIndex.setDescription('The index value which uniquely identifies the interface/port to which this entry is applicable. The interface/port identified by a particular value of this index is the same interface/port as identified by the same value of ifIndex.')
brgPortCacheHits = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brgPortCacheHits.setStatus('obsolete')
if mibBuilder.loadTexts: brgPortCacheHits.setDescription('Count of the successful cache matches when looking up a destination MAC address.')
brgPortCacheMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brgPortCacheMisses.setStatus('obsolete')
if mibBuilder.loadTexts: brgPortCacheMisses.setDescription('Count of the unsuccessful cache matches when looking up a destination MAC address.')
brgPortForwardedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brgPortForwardedPkts.setStatus('obsolete')
if mibBuilder.loadTexts: brgPortForwardedPkts.setDescription('Count of the packets received on this port and forwarded to the other port.')
brgPortFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brgPortFilteredPkts.setStatus('obsolete')
if mibBuilder.loadTexts: brgPortFilteredPkts.setDescription('Count of the frames that were received on this port and filtered.')
wildcardTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5), )
if mibBuilder.loadTexts: wildcardTable.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardTable.setDescription('A list of wildcard entries.')
wildcardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wildcardIndex.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardIndex.setDescription('The index value which uniquely identifies the interface/port to which this entry is applicable. The interface/port identified by a particular value of this index is the same interface/port as identified by the same value of ifIndex.')
wildcardFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wildcardFilter.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardFilter.setDescription("This object contains the binary value used to filter frames. The data in the frame at the offset specified by the Wildcard offsets is XOR'ed with this object after AND'ing with the Wildcard Mask. If zero result occurs, the packet is discarded (filtered). Suppose the user specifies the following values: data: 11001010 10101010 10101010 10101010 mask: 11100000 00000000 00000000 00000000 filter: 11100000 00000000 00000000 00000000 AND'ing data with the mask gives: 11000000 00000000 00000000 00000000 XOR'ing that value with the filter gives: 00100000 00000000 00000000 00000000 The non-zero result indicates no match (don't discard). Another example: data: 10011010 10101010 10101010 10101010 mask: 10010000 00000000 00000000 00000000 filter: 10010000 00000000 00000000 00000000 AND'ing data with the mask gives: 10010000 00000000 00000000 00000000 XOR'ing that value with the filter gives: 00000000 00000000 00000000 00000000 A zero result indicates a match, so we discard (filter) the packet. The filter AND'ed with the mask must equal the filter. This is an example of a legal filter/mask pair: filter: 00010000 00000000 00000000 00000000 mask: 10010000 00000000 00000000 00000000 AND'ed: 00010000 00000000 00000000 00000000 (equals filter) Another way of saying this: if a mask bit is zero, the corresponding filter bit must be zero. The following would be an illegal pair: filter: 01110000 00000000 00000000 00000000 mask: 10010000 00000000 00000000 00000000 AND'ed: 00010000 00000000 00000000 00000000 ( != filter)")
wildcardMask = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wildcardMask.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardMask.setDescription("This object indicates which portion of the wildcardFilter is to be used in filtering. The data in the frame at the offset specified by Wildcard offsets is AND'ed with this object. The result is XOR'ed with the Wildcard Filter object. If a zero result is obtained, the packet is discarded. If an all-zeros wildcardMask is specified, a genErr is returned. Also, see mask/filter constraints in the description of the wildcardFilter object.")
wildcardOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wildcardOffset.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardOffset.setDescription('Indicates the position in a received frame which is to have the Wildcard Mask/Filter applied. The indicated packet byte is aligned with the 0th byte of the wildcard mask/filter held in network byte order. The MAC destination address starts at byte position (wildcardOffset) zero. The wildcardOffset must fall on a 2-byte boundary, 0,2,4,...,1512 (violations of this constraint result in a genErr). Filters can be aligned on non 2-byte boundaries through use of the wildcardUserOffset.')
wildcardUserOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wildcardUserOffset.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardUserOffset.setDescription('This value is a byte offset from the beginning of the packet. If this offset is such that any portion of the filter extends past the end of the packet (for wildcard filtering purposes, the FCS is part of the packet), then the filter is considered not to match, and the packet is not filtered. For a particular filter, the wildcardUserOffset must be greater than or equal to the wildcardOffset. wildcardUserOffset must be between 0 and 1514, inclusive. The wildcardUserOffset, wildcardOffset pair must conform to one of the following four relationships and also be subject to the range restrictions listed above. For n = 0,..,378 Offset 4n 4n 4n 4n+2 UserOffset 4n 4n+1 4n+2 4n+3 As an example, consider four examples in the following table for locating the filter at or near the beginning of a packet: - 6 filter/mask bytes - - desired - 0 1 2 3 4 5 6 - position - A|f/m0 f/m1 f/m2 f/m3 00 00 00 |0,4,8,12,... B| 00 f/m0 f/m1 f/m2 f/m3 00 00 |1,5,9,13,... C| 00 00 f/m0 f/m1 f/m2 f/m3 00 |2,6,10,14,... D| 00 00 00 f/m0 f/m1 f/m2 f/m3|3,7,11,15,... Example A corresponds to a UserOffset/Offset pair such as 0/0 (4n/4n). Example B represents a pair such as 0/1 (4n/4n+1). Example C is 0/2 (4n/4n+2). Finally, example D is 2/3 (4n+2/4n+3). If any of the above constraints is not honored, the SET Response will indicate genErr.')
wildcardArm = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 5, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wildcardArm.setStatus('obsolete')
if mibBuilder.loadTexts: wildcardArm.setDescription('This object arms (enables) the Wildcard Filter provided all of the other wildcard objects have been set to proper values. To disarm a wildcard, only the wildcardArm object need be set.')
stp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6))
stpBridgeId = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpBridgeId.setStatus('obsolete')
if mibBuilder.loadTexts: stpBridgeId.setDescription("A 64 bit binary bridge id composed of bridge priority and the bridge's mac address fields. see: IEEE 802.1(d) 6.8.1.1.3(1), 4.5.3.7")
stpTopoChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpTopoChangeTime.setStatus('obsolete')
if mibBuilder.loadTexts: stpTopoChangeTime.setDescription('The time since the last topology change. see: IEEE 802.1(d) 6.8.1.1.3(2), 4.5.3.12')
stpTopoNumChanges = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpTopoNumChanges.setStatus('obsolete')
if mibBuilder.loadTexts: stpTopoNumChanges.setDescription('The number of topo changes since initialization of STP. see: IEEE 802.1(d) 6.8.1.1.3(3)')
stpTopoChange = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpTopoChange.setStatus('obsolete')
if mibBuilder.loadTexts: stpTopoChange.setDescription('A 1 bit flag broadcast by the root bridge indicating that a topology change is underway, and Stp bridges should use short term aging. see: IEEE 802.1(d) 6.8.1.1.3(4), 4.5.3.12')
stpDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpDesignatedRoot.setStatus('obsolete')
if mibBuilder.loadTexts: stpDesignatedRoot.setDescription('The binary bridge id that this bridge believes to be the root bridge for the bridged Lan. see: IEEE 802.1(d) 6.8.1.1.3(5), 4.5.3.1')
stpRootCost = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpRootCost.setStatus('obsolete')
if mibBuilder.loadTexts: stpRootCost.setDescription('The cost of the path to the root bridge from this bridge; equal to the sum of the designated cost and the path cost held for the root port. see: IEEE 802.1(d) 6.8.1.1.3(6), 4.5.3.2')
stpRootPort = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpRootPort.setStatus('obsolete')
if mibBuilder.loadTexts: stpRootPort.setDescription("The port id that this bridge believes to be the root bridge's root port for the bridged Lan. see: IEEE 802.1(d) 6.8.1.1.3(7), 4.5.3.3")
stpCurrentMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpCurrentMaxAge.setStatus('obsolete')
if mibBuilder.loadTexts: stpCurrentMaxAge.setDescription('The Max Age value received from the Root Bridge (in seconds); the Stp is currently using the value. see: IEEE 802.1(d) 6.8.1.1.3(8), 4.5.3.4')
stpCurrentHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpCurrentHelloTime.setStatus('obsolete')
if mibBuilder.loadTexts: stpCurrentHelloTime.setDescription('The Hello time value received from the Root Bridge (in seconds); the Stp records the value. see: IEEE 802.1(d) 6.8.1.1.3(9), 4.5.3.5')
stpCurrentForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpCurrentForwardDelay.setStatus('obsolete')
if mibBuilder.loadTexts: stpCurrentForwardDelay.setDescription('The forward delay value received from the Root Bridge (in seconds); the Stp is currently using the value. see: IEEE 802.1(d) 6.8.1.1.3(10), 4.5.3.6')
stpMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpMaxAge.setStatus('obsolete')
if mibBuilder.loadTexts: stpMaxAge.setDescription('The maximum age allowed of Config information for a port before a bridge will attempt to become the root (in seconds). Transmitted by this bridge when it is, or is attempting to become the root. see: IEEE 802.1(d) 6.8.1.1.3(11), 6.8.1.2.2(1), 4.5.3.8')
stpHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpHelloTime.setStatus('obsolete')
if mibBuilder.loadTexts: stpHelloTime.setDescription('The time between Config packet transmission when this bridge is, or is attempting to become the root (in seconds). Transmitted by this bridge when it is, or is attempting to become the root. see: IEEE 802.1(d) 6.8.1.1.3(12), 6.8.1.2.2(2), 4.5.3.9')
stpForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpForwardDelay.setStatus('obsolete')
if mibBuilder.loadTexts: stpForwardDelay.setDescription('The time spent in the Listening and Learning states used when this bridge is, or is attempting to become the root (in seconds). Transmitted by this bridge when it is, or is attempting to become the root. see: IEEE 802.1(d) 6.8.1.1.3(13), 6.8.1.2.2(3), 4.5.3.10')
stpPriority = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpPriority.setStatus('obsolete')
if mibBuilder.loadTexts: stpPriority.setDescription("The upper 16 bits of the 64 bit BridgeId composed of priority and the bridge's mac address fields. see: IEEE 802.1(d) 6.8.1.2.2(4), 4.5.3.7")
stpPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15), )
if mibBuilder.loadTexts: stpPortTable.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortTable.setDescription('A list of stpPort entries.')
stpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpPortIndex.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortIndex.setDescription('The index value which uniquely identifies the port to which this entry is applicable. The port identified by a particular value of this index is the same interface/port as identified by the same value of ifIndex. Not an IEEE 802.1(d) reqmt.')
stpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpPortState.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortState.setDescription("The state of a port on a 2 port bridge is really the state of the bridge itself. Management is only allowed to set this object to 'stpDisabled' or 'stpBlocking'. Setting the object to 'stpDisabled' will turn off spanning tree only if the state is not 'stpBlocking' (to prevent loops). Setting the object to 'stpBlocking' will turn on spanning tree only if it was previously disabled. see: IEEE 802.1(d) 6.8.2.1.3(2), 4.4, 4.5.5.2")
stpPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpPortId.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortId.setDescription("The 16 bit port id composed of priority and the port's unique id fields. see: IEEE 802.1(d) 6.8.2.1.3(3), 4.5.5.1")
stpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpPortPathCost.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortPathCost.setDescription('The contribution of the path through this port, when the port is the root port, to the total cost of the path to the root for this bridge. see: IEEE 802.1(d) 6.8.2.1.3(4), 6.8.2.3.2(2), 4.5.5.3')
stpPortRootId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpPortRootId.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortRootId.setDescription('The bridge id that this port believes to be the root bridge for the bridged Lan. see: IEEE 802.1(d) 6.8.2.1.3(5), 4.5.5.4')
stpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpPortDesignatedCost.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortDesignatedCost.setDescription('The cost of the path to the root offered by the Designated Port on the LAN to which this Port is attached. see: IEEE 802.1(d) 6.8.2.1.3(6), 4.5.5.5')
stpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpPortDesignatedBridge.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortDesignatedBridge.setDescription('The Bridge Id of the designated bridge for the LAN associated with the port. see: IEEE 802.1(d) 6.8.2.1.3(7), 4.5.5.6')
stpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stpPortDesignatedPort.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortDesignatedPort.setDescription('The port id of the bridge believed to be the designated port of the LAN associated with the port. see: IEEE 802.1(d) 6.8.2.1.3(8), 4.5.5.7')
stpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 6, 15, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stpPortPriority.setStatus('obsolete')
if mibBuilder.loadTexts: stpPortPriority.setDescription("The upper 8 bits of the 16 bit PortId composed of priority and the port's unique id fields. see: IEEE 802.1(d) 6.8.2.3.2(3), 4.5.5.1")
hdlcErrorTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7), )
if mibBuilder.loadTexts: hdlcErrorTable.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcErrorTable.setDescription('A list of hdlcError entries.')
hdlcErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcErrorIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcErrorIndex.setDescription("The index value which uniquely identifies the port to which this entry is applicable. The port identified by a particular value of this index is the same interface/port as identified by the same value of ifIndex. IcfBridge.HP28674: There is only one 'real' instance of this object on port 2.")
hdlcErrorIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcErrorIndications.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcErrorIndications.setDescription('Errors occurring during information transfer which required instruction from CPU for recovery. This is a serious link problem. The local node will either reset or disconnect after receiving this message.')
hdlcT1Timeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcT1Timeouts.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcT1Timeouts.setDescription('The number of times the retransmission timer (x25T1Timer) timed out.')
hdlcMissedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcMissedPackets.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcMissedPackets.setDescription("Count of the frames lost by the receiver because there wasn't a receive buffer.")
hdlcRcvOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRcvOverruns.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRcvOverruns.setDescription("Count of the number of times the reciever's FIFO was full when the receiver was ready to put new data into the FIFO.")
hdlcXmtUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcXmtUnderruns.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcXmtUnderruns.setDescription('Count of the number of times the transmitter has aborted a frame transmission because data was late from memory.')
hdlcProviderLostPrimitives = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcProviderLostPrimitives.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcProviderLostPrimitives.setDescription('Count of the number of lost control frames due to 802.3 priority processing on receive.')
hdlcRuntFrameReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRuntFrameReceives.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRuntFrameReceives.setDescription('Count of the HDLC frames received that were less than the minimum legal HDLC size.')
hdlcGiantFrameReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcGiantFrameReceives.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcGiantFrameReceives.setDescription('Count of the HDLC frames received that were larger than the maximum legal size that can be sent on the 802.3 LAN link.')
hdlcBadFrameReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcBadFrameReceives.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcBadFrameReceives.setDescription('Count of the sum of: HDLC frames with bad checksum, and misaligned HDLC frames.')
hdlcRejectFrameReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRejectFrameReceives.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRejectFrameReceives.setDescription('Count of the HDLC reject frames received.')
hdlcRejectFrameSends = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRejectFrameSends.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRejectFrameSends.setDescription('Count of the HDLC reject frames sent.')
hdlcFrameRejectFrameRecs = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 7, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcFrameRejectFrameRecs.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcFrameRejectFrameRecs.setDescription('Count of the HDLC frame reject frames (FRMR) received.')
hdlcLocalTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8), )
if mibBuilder.loadTexts: hdlcLocalTable.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalTable.setDescription('A list of hdlcLocal entries.')
hdlcLocalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalIndex.setDescription("Index into Hdlc local statistics table on a per port basis. bridge.HP28674: There is only one 'real' instance of this object on port 2.")
hdlcLocalResetRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalResetRequests.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalResetRequests.setDescription('Count of local HDLC requests to reset current logical link.')
hdlcLocalResetConfirms = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalResetConfirms.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalResetConfirms.setDescription('Count of local HDLC node link reset confirmations.')
hdlcLocalConnectRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalConnectRequests.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalConnectRequests.setDescription('Count of local HDLC node attempts to establish logical link.')
hdlcLocalConnectConfirms = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalConnectConfirms.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalConnectConfirms.setDescription('Count of local HDLC node connect request acceptances.')
hdlcLocalDisconnectRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalDisconnectRequests.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalDisconnectRequests.setDescription('Count of local HDLC node disconnect requests.')
hdlcLocalDisconnectConfirms = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalDisconnectConfirms.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalDisconnectConfirms.setDescription('Count of local HDLC node disconnects granted.')
hdlcLocalState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalState.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalState.setDescription('Current local HDLC operational state.')
hdlcLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("hdlcDTEAddress", 1), ("hdlcDCEAddress", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hdlcLocalAddress.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalAddress.setDescription("The local HDLC address during communication with the remote node. This object is valid only if a brouter is on the remote end of the HDLC link. It can only be set to one of the two values: 'hdlcDTEAddress' or 'hdlcDTEAddress'. Furthermore, the setting of this object must be different from the setting of the hdlcRemoteHdlcAddress object. This object, along with hdlcRemoteAddress and hdlcRemoteNodeId, constitute a superobject. See hdlcRemoteNodeId for more details.")
hdlcLocalPhase = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 8, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcLocalPhase.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcLocalPhase.setDescription('Current HDLC operational phase.')
hdlcRemoteTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9), )
if mibBuilder.loadTexts: hdlcRemoteTable.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteTable.setDescription('A list of hdlcRemote entries.')
hdlcRemoteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteIndex.setDescription("Index into Hdlc remote statistics table on a per port basis. bridge.HP28674: There is only one 'real' instance of this object on port 2.")
hdlcRemoteResetRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteResetRequests.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteResetRequests.setDescription('Count of remote HDLC requests to reset current logical link.')
hdlcRemoteResetConfirms = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteResetConfirms.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteResetConfirms.setDescription('Count of remote HDLC node link reset confirmations.')
hdlcRemoteConnectRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteConnectRequests.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteConnectRequests.setDescription('Count of remote HDLC node attempts to establish logical link.')
hdlcRemoteConnectConfirms = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteConnectConfirms.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteConnectConfirms.setDescription('Count of remote HDLC node connect request acceptances.')
hdlcRemoteDisconnectRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteDisconnectRequests.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteDisconnectRequests.setDescription('Count of remote HDLC node disconnect requests.')
hdlcRemoteState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteState.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteState.setDescription('Current remote HDLC operational state.')
hdlcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("hdlcDTEAddress", 1), ("hdlcDCEAddress", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hdlcRemoteAddress.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteAddress.setDescription("The remote HDLC address during communication with the local node. This object is valid only if a brouter is on the remote end of the HDLC link. It can only be set to one of the two values: 'hdlcDCEAddress' or 'hdlcDTEAddress'. Furthermore, the setting of this object must be different from the setting of the hdlcLocalAddress object. This object, along with hdlcLocalAddress and hdlcRemoteNodeId, constitute a superobject. See hdlcRemoteNodeId for more details.")
hdlcRemoteXidCommands = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteXidCommands.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteXidCommands.setDescription('Count of XID commands issued by remote node.')
hdlcRemoteXidResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteXidResponses.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteXidResponses.setDescription('Count of XID responses issued by remote node.')
hdlcRemoteTestCommands = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteTestCommands.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteTestCommands.setDescription('Count of Test commands issued by remote node.')
hdlcRemoteTestResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdlcRemoteTestResponses.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteTestResponses.setDescription('Count of Test responses issued by remote node.')
hdlcRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 9, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hdlcRemoteNodeId.setStatus('obsolete')
if mibBuilder.loadTexts: hdlcRemoteNodeId.setDescription("Identification of the node at the opposite end of the HDLC link (eg. brouter or bridge). This object, along with hdlcLocalAddress and hdlcRemoteAddress, constitute a superobject. This object may only be set to one of the two values: 'remoteNodeBridge' or 'remoteNodeRouter'. If this object is set to 'remoteNodeUnknown', then hdlcLocalAddress and hdlcRemoteAddress need not be supplied, and will be ignored if provided. In a get, this object may report 'remoteNodeBridge', but attempts to set this object to 'remoteNodeBridge' will result in an error pdu with error type invalidData. If this object is set to 'remoteNodeRouter', then hdlcLocalAddress and hdlcRemoteAddress must be present and contiguous in the pdu in order to properly complete the superobject. The three objects may be in any order within the pdu.")
x25Table = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 10), )
if mibBuilder.loadTexts: x25Table.setStatus('obsolete')
if mibBuilder.loadTexts: x25Table.setDescription('A list of X25 entries.')
x25Index = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25Index.setStatus('obsolete')
if mibBuilder.loadTexts: x25Index.setDescription("Index into X25 remote timer table on a per port basis. bridge.HP28674: There is only one 'real' instance of this object on port 2.")
x25T1Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 10, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25T1Timer.setStatus('obsolete')
if mibBuilder.loadTexts: x25T1Timer.setDescription('Period of time used to timeout retransmits for X25.')
x25N2Count = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 10, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25N2Count.setStatus('obsolete')
if mibBuilder.loadTexts: x25N2Count.setDescription('Number of retries to be performed during X.25 communication.')
x25T3Timer = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 3, 10, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25T3Timer.setStatus('obsolete')
if mibBuilder.loadTexts: x25T3Timer.setDescription('Period of idle time before a disconnect is executed for X25.')
icfSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 4))
icfSecurPassword = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfSecurPassword.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurPassword.setDescription("This variable contains a string which is used both as the community name for the password community, and as the login password for the console port. This community name is needed for most SET operations. In addition, the variables in the ICF security group are only visible within the password community, and must use the value of this variable as the community name for GET operations. If the value of this variable is equal to the null string, the community name 'public' or the null string will be treated the same as the password community.")
icfSecurAuthAnyMgr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfSecurAuthAnyMgr.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurAuthAnyMgr.setDescription('When this variable is set to enabled, any manager with a valid community name may perform SET operations on this device. In this configuration, entries in the icfSecurAuthMgrTable are used only for trap destinations. If this variable is set to disabled, a manager must be in the icfSecurAuthMgrTable and have a valid community name in order to perform SET operations.')
icfSecurAuthMgrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 3), )
if mibBuilder.loadTexts: icfSecurAuthMgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurAuthMgrTable.setDescription('This table contains a list of addresses of managers that are allowed to perform SET operations on this device, and controls the destination addresses for traps. If icfSecurAuthAnyMgr is set to disabled, a manager must be in this table and use the correct community name for the password community in order to perform a GET operation on this table.')
icfSecurAuthMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 3, 1), ).setIndexNames((0, "HP-ICF", "icfAuthMgrIndex"))
if mibBuilder.loadTexts: icfSecurAuthMgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurAuthMgrEntry.setDescription('An entry in the icfSecurAuthMgrTable containing information about a single manager.')
icfAuthMgrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfAuthMgrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: icfAuthMgrIndex.setDescription('This object contains the index which uniquely identifies this entry in the icfSecurAuthMgrTable.')
icfAuthMgrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfAuthMgrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfAuthMgrIpAddress.setDescription('The IP address of a manager that is allowed to manage this device. Setting this variable to a nonzero value will clear the corresponding instance of the icfAuthMgrIpxAddress variable.')
icfAuthMgrIpxAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfAuthMgrIpxAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfAuthMgrIpxAddress.setDescription('The IPX address of a manager that is allowed to manage this device. Setting this variable to a valid IPX address will clear the corresponding instance of the icfAuthMgrIpAddress variable.')
icfAuthMgrRcvTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfAuthMgrRcvTraps.setStatus('mandatory')
if mibBuilder.loadTexts: icfAuthMgrRcvTraps.setDescription('If this variable is set to enabled, any traps generated by this device will be sent to the manager indicated by the corresponding instance of either icfAuthMgrIpAddress or icfAuthMgrIpxAddress, whichever is valid.')
icfSecurIntruder = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 4))
icfSecurIntruderFlag = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfSecurIntruderFlag.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurIntruderFlag.setDescription("If this object is set to 'valid', the remainder of the intruder objects contain information about an authentication failure. The Security LED on the device will blink if this flag is set to 'valid'. The intruder objects will not be overwritten as long as this flag is set to 'valid'. Setting this flag to 'invalid' will turn off the Security LED if there are no other current violations, and will allow the intruder objects to be overwritten by subsequent authentication failures.")
icfSecurIntruderIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 4, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfSecurIntruderIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurIntruderIpAddress.setDescription('The IP address of the manager that caused the authentication failure. Only one of icfSecurIntruderIpAddress and icfSecurIntruderIPXAddress will be valid.')
icfSecurIntruderIpxAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 4, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfSecurIntruderIpxAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurIntruderIpxAddress.setDescription('The IPX address of the manager that caused the authentication failure. Only one of icfSecurIntruderIpAddress and icfSecurIntruderIPXAddress will be valid.')
icfSecurIntruderTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 4, 4, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfSecurIntruderTime.setStatus('mandatory')
if mibBuilder.loadTexts: icfSecurIntruderTime.setDescription('The value of sysUpTime when the authentication failure occurred. A value of 0 indicates that the agent has been reset since this authentication failure occurred.')
icfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 5))
icfConfigIfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 1), )
if mibBuilder.loadTexts: icfConfigIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIfTable.setDescription('This table contains per-interface configuration information that will take effect after the next reset of the device.')
icfConfigIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 1, 1), ).setIndexNames((0, "HP-ICF", "icfConfigIfIndex"))
if mibBuilder.loadTexts: icfConfigIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIfEntry.setDescription('An entry in the icfConfigIfTable containing information about a single interface.')
icfConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfConfigIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIfIndex.setDescription('The index of the interface which this information contains configuration information for. The interface identified by a particular value of this index is the same interface identified by the same value of ifIndex.')
icfConfigIfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfConfigIfIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIfIpAddress.setDescription('This variable contains the IP address for this interface which will be used after the next reset of the device.')
icfConfigIfNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfConfigIfNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIfNetMask.setDescription('This variable contains the IP subnet mask for this interface which will be used after the next reset of the device.')
icfConfigIfDefaultGate = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfConfigIfDefaultGate.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIfDefaultGate.setDescription('This variable contains the IP address of the default router for this interface which will be used after the next reset of the device.')
icfConfigIpTTL = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfConfigIpTTL.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigIpTTL.setDescription('This variable contains the default IP time to live which will be used after the next reset of the device.')
icfConfigBootpEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfConfigBootpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: icfConfigBootpEnable.setDescription("Setting this flag to 'enabled' (the default) will clear any existing IP address configuration for this device, and will cause the device to use the Bootp protocol to obtain its IP configuration after the next reset. This flag must be set to 'disabled' in order to configure an IP address for the device. Setting this flag to 'disabled' will prevent the Bootp protocol from running. Setting this flag to 'disabled' when there is no IP address configured will disable the IP protocol stack on this device.")
icfDot12Draft = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8))
icfVgRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1))
icfVgBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1))
icfVgBasicRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1))
icfVgMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgMACAddress.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aMACAddress.')
if mibBuilder.loadTexts: icfVgMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgMACAddress.setDescription('The MAC address used by the repeater when it initiates training on the uplink port. Repeaters are allowed to train with an assigned MAC address or a null (all zeroes) MAC address.')
icfVgCurrentFramingType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgCurrentFramingType.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aCurrentFramingType.')
if mibBuilder.loadTexts: icfVgCurrentFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgCurrentFramingType.setDescription('The type of framing (802.3 or 802.5) currently in use by the repeater.')
icfVgDesiredFramingType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgDesiredFramingType.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aDesiredFramingType.')
if mibBuilder.loadTexts: icfVgDesiredFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgDesiredFramingType.setDescription('The type of framing which will be used by the repeater after the next time it is reset. The value of this object should be preserved across repeater resets and power failures')
icfVgFramingCapability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgFramingCapability.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aFramingCapability.')
if mibBuilder.loadTexts: icfVgFramingCapability.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgFramingCapability.setDescription('The type of framing this repeater is capable of supporting.')
icfVgTrainingVersion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgTrainingVersion.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aRMACVersion.')
if mibBuilder.loadTexts: icfVgTrainingVersion.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgTrainingVersion.setDescription('The highest version bits (vvv bits) supported by the repeater during training.')
icfVgRepeaterGroupCapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRepeaterGroupCapacity.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aRepeaterGroupCapacity.')
if mibBuilder.loadTexts: icfVgRepeaterGroupCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgRepeaterGroupCapacity.setDescription('The icfVgGroupCapacity is the number of groups that can be contained within the repeater. Within each managed repeater, the groups are uniquely numbered in the range from 1 to icfVgRepeaterGroupCapacity. Some groups may not be present in the repeater, in which case the actual number of groups present will be less than icfVgRepeaterGroupCapacity. The number of groups present is never greater than icfVgRepeaterGroupCapacity.')
icfVgRepeaterHealthState = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRepeaterHealthState.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aRepeaterHealthState.')
if mibBuilder.loadTexts: icfVgRepeaterHealthState.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgRepeaterHealthState.setDescription("The icfVgRepeaterHealthState object indicates the operational state of the repeater. The icfVgRepeaterHealthText may be consulted for more specific information about the state of the repeater's health. In the case of multiple kinds of failures (e.g., repeater failure and port failure), the value of this attribute shall reflect the highest priority failure in the following order, listed highest priority first: rptrFailure(3) groupFailure(4) portFailure(5) generalFailure(6).")
icfVgRepeaterHealthText = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRepeaterHealthText.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.1, aRepeaterHealthText.')
if mibBuilder.loadTexts: icfVgRepeaterHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgRepeaterHealthText.setDescription('The health text object is a text string that provides information relevant to the operational state of the repeater. Agents may use this string to provide detailed information on current failures, including how they were detected, and/or instructions for problem resolution. The contents are agent specific.')
icfVgRepeaterReset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgRepeaterReset.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.2, acResetRepeater.')
if mibBuilder.loadTexts: icfVgRepeaterReset.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgRepeaterReset.setDescription('Setting this object to reset(2) causes the repeater to transition to its initial state as specified in clause 12 [IEEE Draft Std 802.12]. Setting this object to noReset(1) has no effect. The agent will always return the value noReset(1) when this object is read. After receiving a request to set this variable to reset(2), the agent is allowed to delay the reset for a short period. For example, the implementor may choose to delay the reset long enough to allow the SNMP response to be transmitted. In any event, the SNMP response must be transmitted. This action does not reset the management counters defined in this document nor does it affect the icfVgPortAdminStatus parameters. Included in this action is the execution of a disruptive Self-Test with the following characteristics: a) The nature of the tests is not specified. b) The test resets the repeater but without affecting management information about the repeater. c) The test does not inject packets onto any segment. d) Packets received during the test may or may not be transferred. e) The test does not interfere with management functions. After performing this self-test, the agent will update the repeater health information (including icfVgRepeaterHealthState and icfVgRepeaterHealthText).')
icfVgRepeaterNonDisruptTest = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgRepeaterNonDisruptTest.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.2.2, acExecuteNonDisruptiveSelfTest.')
if mibBuilder.loadTexts: icfVgRepeaterNonDisruptTest.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgRepeaterNonDisruptTest.setDescription("Setting this object to selfTest(2) causes the repeater to perform an agent-specific, non-disruptive self-test that has the following characteristics: a) The nature of the tests is not specified. b) The test does not change the state of the repeater or management information about the repeater. c) The test does not inject packets onto any segment. d) The test does not prevent the relay of any packets. e) The test does not interfere with management functions. After performing this test, the agent will update the repeater health information (including icfVgRepeaterHealthState and icfVgRepeaterHealthText). Note that this definition allows returning an 'okay' result after doing a trivial test. Setting this object to noSelfTest(1) has no effect. The agent will always return the value noSelfTest(1) when this object is read.")
icfVgBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2))
icfVgBasicGroupTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1), )
if mibBuilder.loadTexts: icfVgBasicGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgBasicGroupTable.setDescription('A table containing information about groups of ports.')
icfVgBasicGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1), ).setIndexNames((0, "HP-ICF", "icfVgGroupIndex"))
if mibBuilder.loadTexts: icfVgBasicGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgBasicGroupEntry.setDescription('An entry in the icfVgBasicGroupTable, containing information about a single group of ports.')
icfVgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: icfVgGroupIndex.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.4.1, aGroupID.')
if mibBuilder.loadTexts: icfVgGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information. This value is never greater than icfVgRepeaterGroupCapacity.')
icfVgGroupDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupDescr.setDescription("A textual description of the group. This value should include the full name and version identification of the group's hardware type and indicate how the group is differentiated from other types of groups in the repeater. 'Plug-in Module, Rev A' or 'Barney Rubble 100BaseVG 4-port socket Version 2.1' are examples of valid group descriptions. It is mandatory that this only contain printable ASCII characters.")
icfVgGroupObjectID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value may be allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this object could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port Plug-in Module.'")
icfVgGroupOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group is temporarily or permanently physically and/or logically not a part of the repeater. It is an implementation-specific matter as to whether the agent effectively removes notPresent entries from the table. A status of operational(2) indicates that the group is functioning, and a status of malfunctioning(3) indicates that the group is malfunctioning in some way.')
icfVgGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupLastOperStatusChange.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupLastOperStatusChange.setDescription("An object that contains the value of sysUpTime at the time that the value of the icfVgGroupOperStatus object for this group last changed. A value of zero indicates that the group's operational status has not changed since the agent last restarted.")
icfVgGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupPortCapacity.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.4.1, aGroupPortCapacity.')
if mibBuilder.loadTexts: icfVgGroupPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupPortCapacity.setDescription('The icfVgGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to icfVgGroupPortCapacity. Some ports may not be present in a given group instance, in which case the actual number of ports present is less than icfVgGroupPortCapacity. The number of ports present is never greater than icfVgGroupPortCapacity.')
icfVgGroupCablesBundled = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("someCablesBundled", 1), ("noCablesBundled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgGroupCablesBundled.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.4.1, aGroupCablesBundled.')
if mibBuilder.loadTexts: icfVgGroupCablesBundled.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgGroupCablesBundled.setDescription("This configuration flag is used to select either bundled or unbundled cabling. When this flag is 'someCablesBundled(1)' and the port is not promiscuous or cascaded, frames received from ports on this group and destined to go out multiple ports on this group will be buffered completely before being repeated out ports on this group. When this flag is 'noCablesBundled(2)' or the port is promiscuous or cascaded, these frames will be repeated out ports on this group as the frame is being received. Note that the value 'someCablesBundled(1)' will work in the vast majority of installations, regardless of whether or not any cables are physically in a bundle, since promiscuous and cascaded ports automatically avoid the store and forward. The main situation in which 'noCablesBundled(2)' is beneficial is when there is a large amount of multicast traffic and the cables are not in a bundle. The value of this object should be preserved across repeater resets and power failures.")
icfVgBasicPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3))
icfVgBasicPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1), )
if mibBuilder.loadTexts: icfVgBasicPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgBasicPortTable.setDescription('A table containing information about ports.')
icfVgBasicPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "icfVgPortGroupIndex"), (0, "HP-ICF", "icfVgPortIndex"))
if mibBuilder.loadTexts: icfVgBasicPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgBasicPortEntry.setDescription('An entry in the icfVgBasicPortTable, containing information about a single port.')
icfVgPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: icfVgPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
icfVgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: icfVgPortIndex.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPortID.')
if mibBuilder.loadTexts: icfVgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value can never be greater than icfVgGroupPortCapacity for the associated group.')
icfVgPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cascadeExternal", 1), ("cascadeInternal", 2), ("localExternal", 3), ("localInternal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortType.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPortType.')
if mibBuilder.loadTexts: icfVgPortType.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortType.setDescription("Describes the type of port. One of the following: cascadeExternal - Port is an uplink with physical connections which are externally visible cascadeInternal - Port is an uplink with physical connections which are not externally visible, such as a connection to an internal backplane in a chassis localExternal - Port is a downlink or local port with externally visible connections localInternal - Port is a downlink or local port with connections which are not externally visible, such as a connection to an internal agent 'internal' is used to identify ports which place traffic into the repeater, but do not have any external connections. Note that both DTE and cascaded repeater downlinks are considered 'local' ports.")
icfVgPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgPortAdminStatus.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPortAdministrativeState.')
if mibBuilder.loadTexts: icfVgPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortAdminStatus.setDescription('Port enable/disable function. Enabling a disabled port will cause training to be initiated. Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes.')
icfVgPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("training", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortStatus.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPortStatus.')
if mibBuilder.loadTexts: icfVgPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortStatus.setDescription("Current status for the port as specified by the PORT_META_STATE in the port process module of clause 12 [IEEE Draft Std 802.12]. During initialization or any link warning conditions, icfVgPortStatus will be 'inactive(2)'. When Training_Up is received by the repeater on a local port (or when Training_Down is received on a cascade port), icfVgPortStatus will change to 'training(3)' and icfVgTrainingResult can be monitored to see the detailed status regarding training. When 24 consecutive good FCS packets are received and the configuration bits are OK, icfVgPortStatus will change to 'active(1)'. A disabled port shall have a port status of 'inactive(2)'.")
icfVgPortSupportedPromiscMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("singleModeOnly", 1), ("singleOrPromiscMode", 2), ("promiscModeOnly", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortSupportedPromiscMode.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aSupportedPromiscMode.')
if mibBuilder.loadTexts: icfVgPortSupportedPromiscMode.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortSupportedPromiscMode.setDescription("This object describes whether the port hardware is capable of supporting promiscuous mode, single address mode (i.e., repeater filters unicasts not addressed to the end station attached to this port), or both. A port for which icfVgPortType is equal to 'cascadeInternal' or 'cascadeExternal' will always have a value of 'promiscModeOnly' for this object.")
icfVgPortSupportedCascadeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("endNodesOnly", 1), ("endNodesOrRepeaters", 2), ("cascadePort", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortSupportedCascadeMode.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aSupportedCascadeMode.')
if mibBuilder.loadTexts: icfVgPortSupportedCascadeMode.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortSupportedCascadeMode.setDescription("This object describes whether the port hardware is capable of supporting cascaded repeaters, end nodes, or both. A port for which icfVgPortType is equal to 'cascadeInternal' or 'cascadeExternal' will always have a value of 'cascadePort' for this object.")
icfVgPortAllowedTrainType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allowEndNodesOnly", 1), ("allowPromiscuousEndNodes", 2), ("allowEndNodesOrRepeaters", 3), ("allowAnything", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgPortAllowedTrainType.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aAllowableTrainingType.')
if mibBuilder.loadTexts: icfVgPortAllowedTrainType.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortAllowedTrainType.setDescription("This security object is set by the network manager to configure what type of device is permitted to connect to the port. One of the following values: allowEndNodesOnly - only non-promiscuous end nodes permitted. allowPromiscuousEndNodes - promiscuous or non- promiscuous end nodes permitted allowEndNodesOrRepeaters - repeaters or non- promiscuous end nodes permitted allowAnything - repeaters, promiscuous or non-promiscuous end nodes permitted For a port for which icfVgPortType is equal to 'cascadeInternal' or 'cascadeExternal', the corresponding instance of this object may not be set to 'allowEndNodesOnly' or 'allowPromiscuousEndNodes'. The agent must reject a SET of this object if the value includes no capabilities that are supported by this port's hardware, as defined by the values of the corresponding instances of icfVgPortSupportedPromiscMode and icfVgPortSupportedCascadeMode.")
icfVgPortLastTrainConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortLastTrainConfig.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aLastTrainingConfig.')
if mibBuilder.loadTexts: icfVgPortLastTrainConfig.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortLastTrainConfig.setDescription("This 16 bit field contains the most recent training configuration in an error-free training frame sent by the end node connected to the port. For cascade ports, this is the responder's configuration field from the most recent error-free training response frame received in response to training initiated by this repeater. This object is formatted as follows: First Octet: Second Octet: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ |v|v|v|0|0|0|0|0| |0|0|0|F|F|P|P|R| +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ vvv: The version of the 802.12 training protocol with which the training initiator is compliant FF: 00 = frameType88023 is requested 01 = frameType88025 is requested 10 = reserved 11 = either frameType88023 or frameType88025 is acceptable PP: 00 = request singleAddressMode 01 = request promiscuousMode 10 = reserved 11 = reserved R: 0 = request is from an end node 1 = request is from a repeater")
icfVgPortTrainingResult = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortTrainingResult.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aTrainingResult.')
if mibBuilder.loadTexts: icfVgPortTrainingResult.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortTrainingResult.setDescription("This 18 bit field is used to indicate the result of training. It contains two bits which indicate if error-free training frames have been received, and it also contains the 16 bits of the most recent valid training response frame on the port. First Octet: Second Octet: Third Octet: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ |0|0|0|0|0|0|V|G| |v|v|v|D|C|N|0|0| |0|0|0|F|F|P|P|R| +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ V: Valid: set when at least one error-free training frame has been received. Indicates the 16 training configuration bits in icfVgPortLastTrainConfig and icfVgPortTrainingResult contain valid information. This bit is cleared when icfVgPortStatus transitions to the 'inactive' or 'training' state. G: LinkGood: indicates the link hardware is OK. Set if 24 consecutive error-free training packets have been received. Cleared when a training packet with errors is received, and when icfVgPortStatus transitions to the 'inactive' or 'training' state. vvv: The version of the 802.12 training protocol with which the training responder is compliant D: 0 = no duplicate address has been detected 1 = duplicate address has been detected C: 0 = the requested configuration is compatible with the port 1 = the requested configuration is not compatible with the port. The FF, PP and R bits indicate the configuration which would be allowed (providing N = 0). N: 0 = access will be allowed, providing the configuration is compatible (C = 0). 1 = access not allowed because of security restrictions FF: 00 = frameType88023 will be used 01 = frameType88025 will be used 10 = reserved 11 = reserved PP: 00 = singleAddressMode will be used 01 = promiscuousMode will be used 10 = reserved 11 = reserved R: 0 = requested access as an end node is allowed 1 = requested access as a repeater is allowed If the port is in training, a management station can examine this object to see if any training packets have been passed successfully. If there have been any good training packets, the Valid bit will be set and the management station can examine the 16 training response bits to see if there is a duplicate address, configuration, or security problem. Note that on a repeater local port, this repeater generates the training response bits, while on the cascade port, the higher level repeater originated the training response bits.")
icfVgPortPriorityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgPortPriorityEnable.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPriorityEnable.')
if mibBuilder.loadTexts: icfVgPortPriorityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortPriorityEnable.setDescription("A configuration flag used to determine whether the repeater will service high priority requests received on the port as high priority or normal priority. When 'false', high priority requests on this port will be serviced as normal priority. The value of this object should be preserved across repeater resets and power failures. The setting of this object has no effect on a cascade port.")
icfVgPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("pmdMissing", 3), ("utp4", 4), ("stp2", 5), ("fibre", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortMediaType.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aMediaType.')
if mibBuilder.loadTexts: icfVgPortMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortMediaType.setDescription("The type of physical media in use. One of the following values: other undefined unknown true state not known pmdMissing PMD device not attached utp4 4-pair unshielded twisted pair stp2 2-pair shielded twisted pair fibre 802.12 fibre optic cabling This object may be 'unknown' if the implementation is not capable of identifying the PMD media type, or whether or not the PMD is even present.")
icfVgMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2))
icfVgMonRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 1))
icfVgMonGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 2))
icfVgMonPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3))
icfVgMonPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1), )
if mibBuilder.loadTexts: icfVgMonPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgMonPortTable.setDescription('A table of performance and error statistics for the ports.')
icfVgMonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "icfVgPortGroupIndex"), (0, "HP-ICF", "icfVgPortIndex"))
if mibBuilder.loadTexts: icfVgMonPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgMonPortEntry.setDescription('An entry in the icfVgMonPortTable, containing performance and error statistics for a single port.')
icfVgPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortReadableFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aReadableFramesReceived.')
if mibBuilder.loadTexts: icfVgPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortReadableFrames.setDescription('This object is the number of good frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on the port which is not counted by icfVgPortIPMFrames or icfVgPortDataErrorFrames.')
icfVgPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortReadableOctets.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aReadableOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortReadableOctets.setDescription('This object is a count of the number of octets contained in good frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e. each frame counted by icfVgPortReadableFrames). Note that this counter may roll over very quickly.')
icfVgPortUnreadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortUnreadableOctets.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aOctetsInUnreadableFramesRcvd.')
if mibBuilder.loadTexts: icfVgPortUnreadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortUnreadableOctets.setDescription('This object is a count of the number of octets contained in invalid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortIPMFrames or icfVgPortDataErrorFrames. This counter can be combined with icfVgPortReadableOctets to calculate network utilization. Note that this counter may roll over very quickly.')
icfVgPortHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHighPriorityFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aHighPriorityFramesReceived.')
if mibBuilder.loadTexts: icfVgPortHighPriorityFrames.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortHighPriorityFrames.setDescription('This object is a count of high priority frames that have been received on this port. This counter is incremented by one for each high priority frame received on this port, including readable, invalid, and training frames. This counter does not include normal priority frames which were priority promoted.')
icfVgPortHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHighPriorityOctets.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aHighPriorityOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortHighPriorityOctets.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortHighPriorityOctets.setDescription('This object is a count of the number of octets contained in high priority frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortHighPriorityFrames. Note that this counter may roll over very quickly.')
icfVgPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortBroadcastFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aBroadcastFramesReceived.')
if mibBuilder.loadTexts: icfVgPortBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortBroadcastFrames.setDescription('This object is a count of broadcast packets that have been received on this port. This counter is incremented by one for each readable frame received on this port whose destination MAC address is the broadcast address. Frames counted by this counter are also counted by icfVgPortReadableFrames.')
icfVgPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortMulticastFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aMulticastFramesReceived.')
if mibBuilder.loadTexts: icfVgPortMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortMulticastFrames.setDescription('This object is a count of multicast packets that have been received on this port. This counter is incremented by one for each readable frame received on this port whose destination MAC address has the group address bit set, but is not the broadcast address. Frames counted by this counter are also counted by icfVgPortReadableFrames, but not by icfVgPortBroadcastFrames')
icfVgPortIPMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortIPMFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aIPMFramesReceived.')
if mibBuilder.loadTexts: icfVgPortIPMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortIPMFrames.setDescription('This object is a count of the number of frames that have been received on this port with an invalid packet marker and no PMI errors. A repeater will write an invalid packet marker to the end of a frame containing errors as it is forwarded through the repeater to the other ports. This counter is incremented by one for each frame received on this port which has had an invalid packet marker added to the end of the frame. This counter indicates problems with remote cable segments, as opposed to problems with cables directly attached to this repeater.')
icfVgPortDataErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortDataErrorFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aDataErrorFramesReceived.')
if mibBuilder.loadTexts: icfVgPortDataErrorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortDataErrorFrames.setDescription('This object is a count of errored frames received on this port. This counter is incremented by one for each frame received on this port with any of the following errors: FCS (with no IPM), PMI erorrs (excluding frames with an IPM error as the only PMI error), oversize (with no IPM), or undersize (with no IPM). Does not include packets counted by icfVgPortIPMFrames. This counter indicates problems with the cable directly attached to this repeater, while icfVgPorrtIPMFrames indicates problems with remote cables attached to other repeaters.')
icfVgPortPriorityPromotions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortPriorityPromotions.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPriorityPromotions.')
if mibBuilder.loadTexts: icfVgPortPriorityPromotions.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgPortPriorityPromotions.setDescription('This counter is incremented by one each time the priority promotion timer has expired on this port and a normal priority frame was priority promoted.')
icfVgAddrTrack = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3))
icfVgAddrTrackRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 1))
icfVgAddrTrackGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 2))
icfVgAddrTrackPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3))
icfVgAddrTrackTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1), )
if mibBuilder.loadTexts: icfVgAddrTrackTable.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgAddrTrackTable.setDescription('Table of address mapping information about the ports.')
icfVgAddrTrackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "icfVgPortGroupIndex"), (0, "HP-ICF", "icfVgPortIndex"))
if mibBuilder.loadTexts: icfVgAddrTrackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgAddrTrackEntry.setDescription('An entry in the table, containing address mapping information about a single port.')
icfVgAddrLastTrainedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(6, 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgAddrLastTrainedAddress.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aLastTrainedAddress.')
if mibBuilder.loadTexts: icfVgAddrLastTrainedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgAddrLastTrainedAddress.setDescription('This object is the MAC address of the last station which succeeded in training on this port. A cascaded repeater may train using the null address. If no stations have succeeded in training on this port since the agent began monitoring the port activity, the agent shall return a string of length zero.')
icfVgAddrTrainedAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgAddrTrainedAddrChanges.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aTrainedAddressChanges.')
if mibBuilder.loadTexts: icfVgAddrTrainedAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: icfVgAddrTrainedAddrChanges.setDescription('This counter is incremented by one for each time that the icfVgAddrLastTrainedAddress object for this port has changed.')
hpicfObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11))
hpicfCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1))
hpicfChain = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1))
hpicfChainMaxMembers = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainMaxMembers.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainMaxMembers.setDescription('The maximum number of devices that can be supported on the Distributed Management Chain from this agent.')
hpicfChainCurMembers = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainCurMembers.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainCurMembers.setDescription('The number of devices currently on the Distributed Management Chain connected to this agent.')
hpicfChainLastChange = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainLastChange.setDescription('The value of sysUpTime on this agent the last time a device was added to or removed from the Distributed Management Chain connected to this agent.')
hpicfChainChanges = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainChanges.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainChanges.setDescription('A count of the number of times devices have been added to or removed from the Distributed Management Chain connected to this agent.')
hpicfChainTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5), )
if mibBuilder.loadTexts: hpicfChainTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainTable.setDescription('A table of boxes currently connected to the same Distributed Management Chain as this agent.')
hpicfChainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1), ).setIndexNames((0, "HP-ICF", "hpicfChainId"))
if mibBuilder.loadTexts: hpicfChainEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainEntry.setDescription('An entry in the table describing a single box on the Distributed Management Chain connected to this device.')
hpicfChainId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainId.setDescription('An identifier which uniquely identifies this particular box. In practice, this will be a box serial number or MAC address.')
hpicfChainObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainObjectId.setDescription('The authoritative identification of the box which provides an easy and unambiguous means for determining the type of box.')
hpicfChainTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainTimestamp.setDescription("The value of the agent's sysUpTime at which this box was last initialized. If the box has not been initialized since the last reinitialization of the agent, then this object has a zero value.")
hpicfChainHasAgent = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainHasAgent.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainHasAgent.setDescription("This object will contain the value 'true' if this box contains at least one network management agent capable of responding to SNMP requests, and will contain the value 'false' otherwise.")
hpicfChainThisBox = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainThisBox.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainThisBox.setDescription("This object will contain the value 'true' if this entry in the chain table corresponds to the box which contains the agent which is responding to this SNMP request, and will contain the value 'false' otherwise.")
hpicfChainLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfChainLocation.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainLocation.setDescription('This byte is settable by a management station and is not interpreted by the agent. The intent is that a management station can use it to assign an ordering to boxes on the chain that can later be used when displaying the chain.')
hpicfChainViewTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 6), )
if mibBuilder.loadTexts: hpicfChainViewTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainViewTable.setDescription('This table contains one entry for each box on the Distributed Management Chain for which this agent is able to act as a proxy.')
hpicfChainViewEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 6, 1), ).setIndexNames((0, "HP-ICF", "hpicfChainViewId"))
if mibBuilder.loadTexts: hpicfChainViewEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainViewEntry.setDescription('An entry in the hpicfChainViewTable containing information about how to proxy to a single box.')
hpicfChainViewId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainViewId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainViewId.setDescription('An identifier which uniquely identifies this particular box. In practice, this will be a box serial number or MAC address.')
hpicfChainViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 1, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChainViewName.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChainViewName.setDescription("The local name of this box. This is used by the proxy agent for the box to determine which box on the Distributed Management Chain is being addressed. If an agent does not use this method to distinguish proxy destinations, it should return a zero length octet string for this object. For SNMPv1, the destination box is specified by appending this name to the proxy agent's community name. For example, if this agent has a community with a community name of 'public', and the value of this object is 'repeater1', the community 'public/repeater1' will specify that the agent should proxy to the public community of the 'repeater1' box. The default value for this object for box-level repeaters is an ASCII hex representation of the low-order three bytes of the device MAC address.")
hpicfChassis = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2))
hpicfChassisId = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChassisId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChassisId.setDescription('An identifier that uniquely identifies this particular chassis. This will be the same value as the instance of hpicfChainId for this chassis.')
hpicfChassisNumSlots = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChassisNumSlots.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChassisNumSlots.setDescription('The number of slots in this chassis.')
hpicfSlotTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 3), )
if mibBuilder.loadTexts: hpicfSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotTable.setDescription('A table that contains information on all the slots in this chassis.')
hpicfSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 3, 1), ).setIndexNames((0, "HP-ICF", "hpicfSlotIndex"))
if mibBuilder.loadTexts: hpicfSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotEntry.setDescription('Information about a slot in a chassis')
hpicfSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotIndex.setDescription('The slot number within the box for which this entry contains information.')
hpicfSlotObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSlotObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotObjectId.setDescription('The authoritative identification of the card plugged into this slot in this chassis. A value of { 0 0 } indicates an empty slot.')
hpicfSlotLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSlotLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotLastChange.setDescription("The value of the agent's sysUpTime at which a card in this slot was last inserted or removed. If no module has been inserted or removed since the last reinitialization of the agent, this object has a zero value.")
hpicfSlotDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSlotDescr.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotDescr.setDescription('A textual description of the card plugged into this slot in this chassis, including the product number and version information.')
hpicfEntityTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4), )
if mibBuilder.loadTexts: hpicfEntityTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityTable.setDescription('A table that contains information about the (logical) networking devices contained in this chassis.')
hpicfEntityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4, 1), ).setIndexNames((0, "HP-ICF", "hpicfEntityIndex"))
if mibBuilder.loadTexts: hpicfEntityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityEntry.setDescription('Information about a single logical networking device contained in this chassis.')
hpicfEntityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfEntityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityIndex.setDescription('An index that uniquely identifies the logical network device for which this entry contains information.')
hpicfEntityFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfEntityFunction.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityFunction.setDescription('The generic function provided by the logical network device. The value is a sum. Starting from zero, for each type of generic function that the entity performs, 2 raised to a power is added to the sum. The powers are according to the following table: Function Power other 0 repeater 1 bridge 2 router 3 agent 5 For example, an entity performing both bridging and routing functions would have a value of 12 (2^2 + 2^3).')
hpicfEntityObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfEntityObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityObjectId.setDescription("The authoritative identification of the logical network device which provides an unambiguous means of determining the type of device. The value of this object is analagous to MIB-II's sysObjectId.")
hpicfEntityDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfEntityDescr.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityDescr.setDescription("A textual description of this device, including the product number and version information. The value of this object is analogous to MIB-II's sysDescr.")
hpicfEntityTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 4, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfEntityTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfEntityTimestamp.setDescription("The value of the agent's sysUpTime at which this logical network device was last reinitialized. If the entity has not been reinitialized since the last reinitialization of the agent, then this object has a zero value.")
hpicfSlotMapTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 5), )
if mibBuilder.loadTexts: hpicfSlotMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotMapTable.setDescription('A table that contains information about which entities are in which slots in this chassis.')
hpicfSlotMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 5, 1), ).setIndexNames((0, "HP-ICF", "hpicfSlotMapSlot"), (0, "HP-ICF", "hpicfSlotMapEntity"))
if mibBuilder.loadTexts: hpicfSlotMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotMapEntry.setDescription('A relationship between a slot and an entity in this chassis. Such a relationship exists if the particular slot is occupied by a physical module performing part of the function of the particular entity.')
hpicfSlotMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSlotMapSlot.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotMapSlot.setDescription('A slot number within the chassis which contains (part of) this entity.')
hpicfSlotMapEntity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSlotMapEntity.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSlotMapEntity.setDescription('The entity described in this mapping.')
hpicfSensorTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6), )
if mibBuilder.loadTexts: hpicfSensorTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorTable.setDescription('A table that contains information on all the sensors in this chassis')
hpicfSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1), ).setIndexNames((0, "HP-ICF", "hpicfSensorIndex"))
if mibBuilder.loadTexts: hpicfSensorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorEntry.setDescription('Information about a sensor in a chassis')
hpicfSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorIndex.setDescription('An index that uniquely identifies the sensor for which this entry contains information.')
hpicfSensorObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorObjectId.setDescription('The authoritative identification of the kind of sensor this is.')
hpicfSensorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorNumber.setDescription('A number which identifies a particular sensor from other sensors of the same kind. For instance, if there are many temperature sensors in this chassis, this number whould identify a particular temperature sensor in this chassis.')
hpicfSensorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("bad", 2), ("warning", 3), ("good", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorStatus.setDescription('Actual status indicated by the sensor.')
hpicfSensorWarnings = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorWarnings.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorWarnings.setDescription("The number of times hpicfSensorStatus has entered the 'warning'(3) state.")
hpicfSensorFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorFailures.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorFailures.setDescription("The number of times hpicfSensorStatus has entered the 'bad'(2) state.")
hpicfSensorDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 6, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfSensorDescr.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSensorDescr.setDescription('A textual description of the sensor.')
hpicfChassisAddrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 7), )
if mibBuilder.loadTexts: hpicfChassisAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChassisAddrTable.setDescription('A table of network addresses for entities in this chassis. The primary use of this table is to map a specific entity address to a specific chassis. Note that this table may not be a complete list of network addresses for this entity.')
hpicfChassisAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 7, 1), ).setIndexNames((0, "HP-ICF", "hpicfChasAddrType"), (0, "HP-ICF", "hpicfChasAddrAddress"))
if mibBuilder.loadTexts: hpicfChassisAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChassisAddrEntry.setDescription('An entry containing a single network address being used by a logical network device in this chassis.')
hpicfChasAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipAddr", 1), ("ipxAddr", 2), ("macAddr", 3))))
if mibBuilder.loadTexts: hpicfChasAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChasAddrType.setDescription('The kind of network address represented in this entry.')
hpicfChasAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 10)))
if mibBuilder.loadTexts: hpicfChasAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChasAddrAddress.setDescription('The network address being used by the logical network device associated with this entry, formatted according to the value of the associated instance of hpicfChasAddrType. For hpicfChasAddrType of ipAddr, this value is four octets long, with each octet representing one byte of the IP address, in network byte order. For hpicfChasAddrType of ipxAddr, this value is ten octets long, with the first four octets representing the IPX network number in network byte order, followed by the six byte host number in network byte order. For hpicfChasAddrType of macAddr, this value is six octets long, representing the MAC address in canonical order.')
hpicfChasAddrEntity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfChasAddrEntity.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfChasAddrEntity.setDescription('An index that uniquely identifies the logical network device in this chassis that is using this network address..')
hpicfDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3))
hpicfDownloadTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1), )
if mibBuilder.loadTexts: hpicfDownloadTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadTable.setDescription('A table of firmware downloads to this device. There will at any time be either 0 or 1 rows in this table, and the only valid index for this table is 1. It is only a table so that we may take advantage of the RowStatus textual convention for configuring the download parameters.')
hpicfDownloadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "hpicfDownloadIndex"))
if mibBuilder.loadTexts: hpicfDownloadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadEntry.setDescription('The row in the hpicfDownloadTable containing the download parameters.')
hpicfDownloadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("dlInstance", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadIndex.setDescription('The index which uniquely identifies this row. The only legal value for this object is 1.')
hpicfDownloadOwnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 2), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadOwnerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadOwnerAddress.setDescription('The transport address of the management station that initiated this download attempt, formatted according to the value of the associated instance of hpicfDownloadOwnerDomain.')
hpicfDownloadOwnerDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadOwnerDomain.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadOwnerDomain.setDescription('The kind of transport service used by the management station that initiated this download attempt.')
hpicfDownloadTAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 4), TAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfDownloadTAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadTAddress.setDescription("The transport address of the node to download firmware from, formatted according to the value of the associated instance of hpicfDownloadTDomain. An attempt to modify this value will fail if the associated hpicfDownloadStatus object would be equal to 'active' both before and after the modification attempt.")
hpicfDownloadTDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfDownloadTDomain.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadTDomain.setDescription("The kind of transport service to be used for the download. Currently supports snmpUDPDomain and snmpIPXDomain. An attempt to modify this value will fail if the associated hpicfDownloadStatus object would be equal to 'active' both before and after the modification attempt.")
hpicfDownloadFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfDownloadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadFilename.setDescription("Filename and path of file to download (maximum length of 63 characters + NULL). An attempt to modify this value will fail if the associated hpicfDownloadStatus object would be equal to 'active' both before and after the modification attempt.")
hpicfDownloadResetType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("warmReset", 2), ("factoryReset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfDownloadResetType.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadResetType.setDescription('The type of reset to perform after completion of the firmware download. Note that not all agents will support all possible values, and there may be other agent-specific values for this object.')
hpicfDownloadErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("fileNotFound", 1), ("accessViolation", 2), ("diskFull", 3), ("illegalOperation", 4), ("unknownTID", 5), ("fileExists", 6), ("noSuchUser", 7), ("notDefined", 8), ("corruptFile", 9), ("noServer", 10), ("tftpTimeout", 11), ("hardwareError", 12), ("success", 13), ("aborted", 14), ("inProgress", 15), ("idle", 16), ("erasingEeprom", 17), ("incompleteFirmware", 18), ("requirePowerCycle", 19), ("cannotUpgrade", 20), ("cannotDowngrade", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadErrorStatus.setDescription("Status of download. The first seven codes are equal to the codes defined by the TFTP protocol. 'notDefined' is the same as TFTP protocol error 0. The following are the other possible values for this object: corruptFile - the agent detected a problem with the download file format. noServer - the TFTP server at hpicfDownloadTAddress did not respond to the TFTP request. tftpTimeout - the download was aborted due to excessive timeouts. hardwareError - there was a hardware problem on the agent that forced an abort of the download (see hpicfDownloadErrorText for more detailed information). success - the download has completed successfully. aborted - the download was aborted by setting the hpicfDownloadStatus to 'notInService' or 'delete'. inProgress - the TFTP transfer is currently active. idle - means that the download has not yet started (i.e. the value of hpicfDownloadStatus has not yet been set to 'active'). erasingEeprom - the agent is currently erasing the EEPROM device. Currently only used on JetDirect agents. incompleteFirmware - the agent is running an incomplete version of firmware and requires a download. Currently only used on JetDirect agents. requirePowerCycle - the agent must be power cycled to run the newly downloaded firmware. Currently only used on JetDirect agents. cannotUpgrade - the agent's current firmware revision cannot be upgraded to the revision in the download file. cannotDowngrade - the agent's current firmware revision cannot be downgraded to the revision in the download file.")
hpicfDownloadErrorText = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadErrorText.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadErrorText.setDescription('A textual description of the current error status of the firmware download.')
hpicfDownloadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 1, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfDownloadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadStatus.setDescription("The status of this download entry. This object may not be set to 'active' unless the following columnar objects exist in this row: hpicfDownloadTAddress, hpicfDownloadTDomain, hpicfDownloadFilename, and hpicfDownloadResetType.")
hpicfDownloadLogMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadLogMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadLogMaxSize.setDescription('The maximum number of the download log entries supported by this agent. Note that 0 is a legal value for this variable.')
hpicfDownloadLogSize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDownloadLogSize.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadLogSize.setDescription('The number of download log entries currently in the hpicfDownloadLogTable.')
hpicfDownloadLogTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4), )
if mibBuilder.loadTexts: hpicfDownloadLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadLogTable.setDescription('A log of the hpicfDownloadSize most recent download attempts to this device. The first entry in the table is the oldest.')
hpicfDownloadLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1), ).setIndexNames((0, "HP-ICF", "hpicfDlLogIndex"))
if mibBuilder.loadTexts: hpicfDownloadLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDownloadLogEntry.setDescription('An entry in the hpicfDownloadLogTable containing information about a single download attempt.')
hpicfDlLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogIndex.setDescription('The index of this entry in the download log table. Index 1 will always contain the oldest entry. If the table is full when a download attempt is made, the new entry becomes the last entry (hpicfDownloadLogMaxSize), and all earlier entries are shifted down by one entry, removing the old index 1.')
hpicfDlLogOwnerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 2), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogOwnerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogOwnerAddress.setDescription('The transport address of the management station that attempted to initiate a download of this device, formatted according to the value of hpicfDlLastOwnerDomain.')
hpicfDlLogOwnerDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogOwnerDomain.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogOwnerDomain.setDescription('The kind of transport service used by the management station that attempted to initiate a download of this device.')
hpicfDlLogTAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 4), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogTAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogTAddress.setDescription('The transport address of the node from which this device attempted to download firmware, formatted according to the value of hpicfDlLastTDomain.')
hpicfDlLogTDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogTDomain.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogTDomain.setDescription('The kind of transport service which was used for the attempt to download firmware to this device.')
hpicfDlLogFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogFilename.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogFilename.setDescription('The filename from which this device attempted to download firmware.')
hpicfDlLogResetType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("warmReset", 2), ("factoryReset", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogResetType.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogResetType.setDescription('The type of reset requested to be performed after completion of the firmware download attempt.')
hpicfDlLogErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("fileNotFound", 1), ("accessViolation", 2), ("diskFull", 3), ("illegalOperation", 4), ("unknownTID", 5), ("fileExists", 6), ("noSuchUser", 7), ("notDefined", 8), ("corruptFile", 9), ("noServer", 10), ("tftpTimeout", 11), ("hardwareError", 12), ("success", 13), ("aborted", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogErrorStatus.setDescription('The result of the attempt to download firmware to this device. The values are the same as the corresponding values of hpicfDownloadErrorStatus.')
hpicfDlLogErrorText = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 3, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfDlLogErrorText.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfDlLogErrorText.setDescription('A textual description of the final error status of the attempt to download firmware to this device.')
hpicfBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 4))
hpicfReset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("normalReset", 2), ("factoryReset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfReset.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfReset.setDescription("When this object is set to to 'normalReset' it results in a 'warm' reset, which does not clear the parameters in NOVRAM to factory defaults. When set to 'factoryReset', it results in NOVRAM being set to factory defaults. When this object is set, the agent replies, dallies a short time to allow the reply to be emitted from the device, then performs the reset. When read, this object always returns 'noReset'.")
hpicfSelfTest = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stSuccess", 1), ("stExecute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfSelfTest.setStatus('mandatory')
if mibBuilder.loadTexts: hpicfSelfTest.setDescription("Self test is invoked by setting this flag to 'stExecute'. When the object changes to 'stSuccess', the test has completed successfully. Icf devices will 'hard-fail' if the test does not succeed.")
hpicfRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2))
hpRptrBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1))
hpRptrBasicGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 1))
hpRptrEntityName = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrEntityName.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrEntityName.setDescription("The local name of this repeater. This is the same value as hpicfEntityName in the case where there is Distributed Management Protocol to access this device. For SNMPv1, this name is appended to the agent community name to obtain a community name to use to specify that the agent should proxy to this repeater. For example, if this agent has a community with a community name of 'public', and the value of this object is 'repeater1', the community 'public/repeater1' will specify that the agent should proxy to the public community of the repeater1 box to obtain management information about this repeater. If an agent receives a management request where the localEntity is not specified, it will default to the local repeater on which this agent is executing.")
hpRptrThinlanFault = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpRptrThinlanFault.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrThinlanFault.setDescription("When set to 'true' this object causes the Fault Led to blink if the ThinLan Port is segmented.")
hpRptrSqeEnabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrSqeEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrSqeEnabled.setDescription("When 'true', this flag indicates that SQE has been detected for the last ten agent transmits and there is a high probability that the SQE switch on the transceiver attached to the AUI port is set to Enabled, when it should be Disabled.")
hpRptrRobustHealing = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpRptrRobustHealing.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrRobustHealing.setDescription("When this flag is set to 'true', it enables robust port healing mode. The 802.3 specification states that a segmented port is healed by successfully transmitting or receiving a packet on the port. This mode disables port healing on successful packet reception and requires that a packet be successfully transmitted on a port in order for a segmented port to be healed. Note that it is illegal to set this variable to 'true' on a repeater that does not have a local network management agent.")
hpRptrBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2))
hpRptrBasicGroupTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1), )
if mibBuilder.loadTexts: hpRptrBasicGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrBasicGroupTable.setDescription('HP specific extensions to the rptrGroupTable.')
hpRptrBasicGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1), ).setIndexNames((0, "HP-ICF", "hpRptrGrpGroupIndex"))
if mibBuilder.loadTexts: hpRptrBasicGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrBasicGroupEntry.setDescription('An entry in the table, containing HP extensions for a specific group.')
hpRptrGrpGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrGrpGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrGrpGroupIndex.setDescription('The group within the repeater for which this entry contains information. This object has the same value as the corresponding instance of rptrGroupIndex.')
hpRptrGrpPortsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrGrpPortsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrGrpPortsAdminStatus.setDescription("The hpRptrGrpPortsAdminStatus is a bit map of the state of the rptrPortAdminStatus object for all of the ports in this group. The object has a one bit for each port for which the value of rptrPortAdminStatus is equal to 'enabled(1)' and a zero bit for each port for which the value of rptrPortAdminStatus is equal to 'disabled(2)'. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpRptrGrpPortsSegStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrGrpPortsSegStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrGrpPortsSegStatus.setDescription("The hpRptrGrpPortsSegStatus is a bit map of the state of the rptrPortAutoPartitionState of all of the ports in this group. The object has a one bit for each port for which the value of rptrPortAutoPartitionState is equal to 'notAutoPartitioned(1)' and a zero bit for each port for which the value of rptrPortAutoPartitionState is equal to 'autoPartitioned(2)'. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpRptrGrpPortsMediaAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrGrpPortsMediaAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrGrpPortsMediaAvailable.setDescription("The hpRptrGrpPortsMediaAvailable is a bit map of the state of the rpMauMediaAvailable object for all of the ports in this group. The object has a one bit for each port for which the value of rpMauMediaAvailable is equal to 'available(3)' and a zero bit for each port for which the value of rpMauMediaAvailable is not equal to 'available(3)'. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpRptrGrpPortsLinkbeatEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrGrpPortsLinkbeatEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrGrpPortsLinkbeatEnabled.setDescription("The hpRptrGrpPortsLinkbeatEnabled is a bit map of the state of the hpRptrPtLinkbeatEnable object for all of the ports in this group. The object has a one bit for each port for which the value of hpRptrPtLinkbeatEnable is equal to 'true(1)' and a zero bit for each port for which the value of hpRptrPtLinkbeatEnable is equal to 'false(2)'. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpRptrGrpPortsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrGrpPortsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrGrpPortsOperStatus.setDescription('The hpRptrGrpPortsOperStatus is a bit map of the state of all hub ports in the group. The object has a 1 bit for each port that is enabled, not segmented, and the media is available. Ports on which these conditions are not true have a 0 bit. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.')
hpRptrBasicPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3))
hpRptrBasicPtTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3, 1), )
if mibBuilder.loadTexts: hpRptrBasicPtTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrBasicPtTable.setDescription('HP specific extensions to the rptrPortTable.')
hpRptrBasicPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "hpRptrPtGroupIndex"), (0, "HP-ICF", "hpRptrPtPortIndex"))
if mibBuilder.loadTexts: hpRptrBasicPtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrBasicPtEntry.setDescription('An entry in the table, containing HP extensions for a specific port.')
hpRptrPtGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrPtGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrPtGroupIndex.setDescription('The group containing the port for which this entry contains information. This object has the same value as the corresponding instance of rptrPortGroupIndex.')
hpRptrPtPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrPtPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrPtPortIndex.setDescription('The port within the group for which this entry contains information. This object has the same value as the corresponding instance of rptrPortIndex.')
hpRptrPtLinkbeatEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpRptrPtLinkbeatEnable.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrPtLinkbeatEnable.setDescription("When this flag is set to 'true' the port's link beat is enabled and when set to 'false' it is disabled.")
hpRptrPtPolarityReversed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 1, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrPtPolarityReversed.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrPtPolarityReversed.setDescription('This object is used to indicate that the hub port was wired with the positive/negative polarity of its transmit and receive pairs reversed. Note that the port will continue to operate in this state, with the hub inverting the polarity internally.')
hpRptrMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2))
hpRptrMonitorGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1))
hpRptrMonCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1))
hpRptrMonGlobalFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalFrames.setReference('Reference RFC 1516 rptrMonitorPortReadableFrames and rptrMonitorGroupTotalFrames, and IEEE 802.3 Rptr Mgt, 19.2.6.2, aReadableFrames.')
if mibBuilder.loadTexts: hpRptrMonGlobalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalFrames.setDescription('The total number of frames of valid frame length that have been received on all ports in this repeater. This counter is the summation of the values of the rptrMonitorPortReadableFrames counter for all of the ports in this repeater. Equivalently, this counter is the summation of the values of the rptrMonitorGroupTotalFrames counter for all of the port groups in this repeater.')
hpRptrMonGlobalOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalOctets.setReference('Reference RFC 1516 rptrMonitorPortReadableOctets and rptrMonitorGroupTotalOctets, and IEEE 802.3 Rptr Mgt, 19.2.6.2, aReadableOctets.')
if mibBuilder.loadTexts: hpRptrMonGlobalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this repeater. This counter is the summation of the values of the rptrMonitorPortReadableOctets counter for all of the ports in this repeater. Equivalently, this counter is the summation of the values of the rptrMonitorGroupTotalOctets counter for all of the port groups in this repeater.')
hpRptrMonGlobalFCSErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalFCSErrors.setReference('Reference RFC 1516 rptrMonitorPortFCSErrors and IEEE 802.3 Rptr Mgt, 19.2.6.2, aFrameCheckSequenceErrors.')
if mibBuilder.loadTexts: hpRptrMonGlobalFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalFCSErrors.setDescription('This counter is incremented by one for each frame received on any port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). This counter is the summation of the values of the rptrMonitorPortFCSErrors counter for all of the ports in this repeater.')
hpRptrMonGlobalAlignmentErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalAlignmentErrors.setReference('Reference RFC 1516 rptrMonitorPortAlignmentErrors and IEEE 802.3 Rptr Mgt, 19.2.6.2, aAlignmentErrors.')
if mibBuilder.loadTexts: hpRptrMonGlobalAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalAlignmentErrors.setDescription('This counter is incremented by one for each frame received on any port with the FCSError and FramingError signals asserted and CollisonEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If hpRptrMonGlobalAlignmentErrors is incremented, then the hpRptrMonGlobalFCSErorrs counter shall not be incremented for the same frame. This counter is the summation of the values of the rptrMonitorPortAlignmentErrors counter for all of the ports in this repeater.')
hpRptrMonGlobalFrameTooLongs = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalFrameTooLongs.setReference('Reference RFC 1516 rptrMonitorPortFrameTooLongs and IEEE 802.3 Rptr Mgt, 19.2.6.2, aFramesTooLong')
if mibBuilder.loadTexts: hpRptrMonGlobalFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalFrameTooLongs.setDescription('This counter is incremented by one for each frame received on any port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If hpRptrMonGlobalFrameTooLongs is incremented, then neither the hpRptrMonGlobalAlignmentErorrs nor the hpRptrMonGlobalFCSErrors counter shall be incremented for the frame. This counter is the summation of the values of the rptrMonitorPortFrameTooLongs counter for all of the ports in this repeater.')
hpRptrMonGlobalShortEvents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalShortEvents.setReference('Reference RFC 1516 rptrMonitorPortShortEvents and IEEE 802.3 Rptr Mgt, 19.2.6.2, aShortEvents.')
if mibBuilder.loadTexts: hpRptrMonGlobalShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalShortEvents.setDescription('This counter is incremented by one for each CarrierEvent on any port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. This counter is the summation of the values of the rptrMonitorPortShortEvents counter for all of the ports in this repeater.')
hpRptrMonGlobalRunts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalRunts.setReference('Reference RFC 1516 rptrMonitorPortRunts and IEEE 802.3 Rptr Mgt, 19.2.6.2, aRunts.')
if mibBuilder.loadTexts: hpRptrMonGlobalRunts.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalRunts.setDescription('This counter is incremented by one for each CarrierEvent on any port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times but less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the hpRptrMonGlobalShortEvents counter or the hpRptrMonGlobalRunts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not increment the hpRptrMonGlobalRunts counter. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. This counter is the summation of the values of the rptrMonitorPortRunts counter for all of the ports in this repeater.')
hpRptrMonGlobalCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalCollisions.setReference('Reference RFC 1516 rptrMonitorPortCollisions and IEEE 802.3 Rptr Mgt, 19.2.6.2, aCollisions.')
if mibBuilder.loadTexts: hpRptrMonGlobalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalCollisions.setDescription('This counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on any port is asserted. This counter differs from rptrMonitorTransmitCollisions in that it counts all collisions seen by this repeater, even those involving only a single port on this repeater, whereas rptrMonitorTransmitCollisions counts only collisions involving multiple ports on this repeater.')
hpRptrMonGlobalLateEvents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalLateEvents.setReference('Reference RFC 1516 rptrMonitorPortLateEvents and IEEE 802.3 Rptr Mgt, 19.2.6.2, aLateEvents.')
if mibBuilder.loadTexts: hpRptrMonGlobalLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalLateEvents.setDescription('This counter is incremented by one for each CarrierEvent on any port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both hpRptrMonGlobalCollisions and hpRptrMonGlobalLateEvents. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. This counter is the summation of the values of the rptrMonitorPortLateEvents counter for all of the ports in this repeater.')
hpRptrMonGlobalVeryLongEvents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalVeryLongEvents.setReference('Reference RFC 1516 rptrMonitorPortVeryLongEvents and IEEE 802.3 Rptr Mgt, 19.2.6.2, aVeryLongEvents.')
if mibBuilder.loadTexts: hpRptrMonGlobalVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalVeryLongEvents.setDescription('This counter is incremented by one for each CarrierEvent on any port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate. This counter is the summation of the values of the rptrMonitorPortVeryLongEvents counter for all of the ports in this repeater.')
hpRptrMonGlobalDataRateMismatches = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalDataRateMismatches.setReference('Reference RFC 1516 rptrMonitorPortDataRateMismatches and IEEE 802.3 Rptr Mgt, 19.2.6.2, aDataRateMismatches.')
if mibBuilder.loadTexts: hpRptrMonGlobalDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalDataRateMismatches.setDescription('This counter is incremented by one for each frame received on any port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented. This counter is the summation of the values of the rptrMonitorPortDatRateMismatches counter for all of the ports in this repeater.')
hpRptrMonGlobalAutoPartitions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalAutoPartitions.setReference('Reference RFC 1516 rptrMonitorPortAutoPartitions and IEEE 802.3 Rptr Mgt, 19.2.6.2, aAutoPartitions.')
if mibBuilder.loadTexts: hpRptrMonGlobalAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalAutoPartitions.setDescription('This counter is incremented by one for each time the repeater has automatically partitioned any port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 of the IEEE 802.3 Std. This counter is the summation of the values of the rptrMonitorPortAutoPartitions for all of the ports in this repeater.')
hpRptrMonGlobalErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalErrors.setReference('RFC 1516, rptrMonitorGroupTotalErrors and hpRptrMonitorPortTotalErrors.')
if mibBuilder.loadTexts: hpRptrMonGlobalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalErrors.setDescription('The total number of errors which have occured on any port in this repeater. This counter is the summation of the values of other error counters, namely: hpRptrMonGlobalFCSErrors, hpRptrMonGlobalAlignmentErrors, hpRptrMonGlobalFrameTooLongs, hpRptrMonGlobalShortEvents, hpRptrMonGlobalLateEvents, hpRptrMonGlobalVeryLongEvents, and hpRptrMonGlobalDataRateMismatches. Equivalently, this counter is the summation of the values of the rptrMonitorPortTotalErrors counter for all of the ports in this repeater, or it is the summation of the values of rptrMonitorGroupTotalErrors for all of the port groups in this repeater.')
hpRptrMonGlobalUcastPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalUcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalUcastPackets.setDescription('This counter is incremented by one for each unicast packet of valid frame length received on any port. This counter is the summation of hpRptrMonPortUcastPackets for all of the ports in this repeater. This counter may not be implemented for repeaters which do not have a local network management agent.')
hpRptrMonGlobalBcastPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalBcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalBcastPackets.setDescription('This counter is incremented by one for each broadcast packet of valid frame length received on any port. This counter is the summation of hpRptrMonPortBcastPackets for all of the ports in this repeater. This counter may not be implemented for repeaters which do not have a local network management agent.')
hpRptrMonGlobalMcastPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonGlobalMcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonGlobalMcastPackets.setDescription('This counter is incremented by one for each multicast packet of valid frame length received on any port. This counter is the summation of hpRptrMonPortMcastPackets for all of the ports in this repeater. This counter may not be implemented for repeaters which do not have a local network management agent.')
hpRptrMonitorGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 2))
hpRptrMonitorPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3))
hpRptrMonPtTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1), )
if mibBuilder.loadTexts: hpRptrMonPtTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtTable.setDescription('Table of HP specific per port monitor objects.')
hpRptrMonPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "hpRptrMonPtGroupIndex"), (0, "HP-ICF", "hpRptrMonPtPortIndex"))
if mibBuilder.loadTexts: hpRptrMonPtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtEntry.setDescription('An entry in the table, containing per port objects for a single port.')
hpRptrMonPtGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonPtGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtGroupIndex.setDescription('The group containing the port for which this entry contains information. This object has the same value as the corresponding instance of rptrMonitorPortGroupIndex.')
hpRptrMonPtPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonPtPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtPortIndex.setDescription('The port within the group for which this entry contains information. This object has the same value as the corresponding instance of rptrMonitorPortIndex.')
hpRptrMonPtUcastPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonPtUcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtUcastPackets.setDescription('This counter is incremented by one for each unicast packet of valid frame length received on this port. This object may not be implemented for repeaters which do not have a local network management agent.')
hpRptrMonPtBcastPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonPtBcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtBcastPackets.setDescription('This counter is incremented by one for each broadcast packet of valid frame length received on this port. This object may not be implemented for repeaters which do not have a local network management agent.')
hpRptrMonPtMcastPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpRptrMonPtMcastPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hpRptrMonPtMcastPackets.setDescription('This counter is incremented by one for each multicast packet of valid frame length received on this port. This object may not be implemented for repeaters which do not have a local network management agent.')
hpRptrAddrTrack = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 3))
hpRptrAddrTrkGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 3, 1))
hpRptrAddrTrkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 3, 2))
hpRptrAddrTrkPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 2, 3, 3))
hpicfVg = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3))
hpVgBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1))
hpVgBasicGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 1))
hpVgEntityName = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgEntityName.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgEntityName.setDescription("The local name of this 100BaseVG repeater. This is the same value as hpicfEntityName in the case where there is Distributed Management Protocol to access this device. For SNMPv1, this name is appended to the agent community name to obtain a community name to use to specify that the agent should proxy to this repeater. For example, if this agent has a community with a community name of 'public', and the value of this object is 'repeater1', the community 'public/repeater1' will specify that the agent should proxy to the public community of the repeater1 box to obtain management information about this repeater. If an agent receives a management request where the localEntity is not specified, it will default to the local repeater on which this agent is executing.")
hpVgBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2))
hpVgBasicGroupTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1), )
if mibBuilder.loadTexts: hpVgBasicGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgBasicGroupTable.setDescription('HP specific extensions to the vgBasicGroupTable.')
hpVgBasicGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1), ).setIndexNames((0, "HP-ICF", "hpVgGrpGroupIndex"))
if mibBuilder.loadTexts: hpVgBasicGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgBasicGroupEntry.setDescription('An entry in the table, containing HP extensions for a specific group.')
hpVgGrpGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: hpVgGrpGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgGrpGroupIndex.setDescription('The group within the repeater for which this entry contains information. This object has the same value as the corresponding instance of icfVgGroupIndex.')
hpVgGrpPortsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgGrpPortsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgGrpPortsAdminStatus.setDescription("The hpVgGrpPortsAdminStatus is a bit map of the state of the icfVgPortAdminStatus object for all of the ports in this group. The object has a one bit for each port for which the value of icfVgPortAdminStatus is equal to 'enabled(1)' and a zero bit for each port for which the value of icfVgPortAdminStatus is equal to 'disabled(2)'. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpVgGrpPortsTrained = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgGrpPortsTrained.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgGrpPortsTrained.setDescription("The hpVgGrpPortsTrained is a bit map which indicates which ports in this group are currently online. The object has a one bit for each port for which meets the following conditions: 1. The value of the corresponding instance of the ifVgPortAdminStatus object is equal to 'enabled(1)'. 2. The value of the corresponding instance of the icfVgPortStatus object is equal to 'active(1)'. The object has a zero bit for each port which does not meet the above conditions. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpVgGrpPortsInTraining = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgGrpPortsInTraining.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgGrpPortsInTraining.setDescription("The hpVgGrpPortsInTraining is a bit map which indicates which ports in this group are currently in the training state. The object has a one bit for each port which meets the following conditions: 1. The value of the corresponding instance of the ifVgPortAdminStatus object is equal to 'enabled(1)'. 2. The value of the corresponding instance of the icfVgPortStatus object is equal to 'training(3)'. The object has a zero bit for each port which does not meet the above conditions. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpVgGrpPortsCascaded = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgGrpPortsCascaded.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgGrpPortsCascaded.setDescription("The hpVgGrpPortsCascaded is a bit map which indicates which ports in this group have trained as cascaded repeater ports. The object has a one bit for each port which meets the following conditions: 1. The value of the corresponding instance of the ifVgPortAdminStatus object is equal to 'enabled(1)'. 2. The value of the corresponding instance of the icfVgPortStatus object is equal to 'active(1)'. 3. The value of the corresponding instance of the icfVgPortType object is equal to either 'normalInternal(3)' or 'normalExternal(4)'. 4. The value of the 'R' bit in the corresponding instance of the icfVgPortTrainingResult object is equal to one. The object has a zero bit for each port which does not meet the above conditions. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpVgGrpPortsPromiscuous = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgGrpPortsPromiscuous.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgGrpPortsPromiscuous.setDescription("The hpVgGrpPortsPromiscuous is a bit map which indicates which ports in this group have trained for promiscuous operation. The object has a one bit for each port which meets the following conditions: 1. The value of the corresponding instance of the ifVgPortAdminStatus object is equal to 'enabled(1)'. 2. The value of the corresponding instance of the icfVgPortStatus object is equal to 'active(1)'. 3. The value of the corresponding instance of the icfVgPortType object is equal to either 'normalInternal(3)' or 'normalExternal(4)'. 4. The value of the 'R' bit in the corresponding instance of the icfVgPortTrainingResult object is equal to zero. 5. The value of the 'PP' field in the corresponding instance of the icfVgPortTrainingResult object is equal to 01. The object has a zero bit for each port which does not meet the above conditions. The bits are placed into the OCTET STRING in the following order: octet 0 octet 1 octet 2 ... bits 7-0 bits 7-0 bits 7-0 ... ports 1-8 ports 9-16 ports 17-24 ... Values of unused bits in the last octet are undefined.")
hpVgBasicPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3))
hpVgBasicPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3, 1), )
if mibBuilder.loadTexts: hpVgBasicPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgBasicPortTable.setDescription('HP specific extensions to the vg port table.')
hpVgBasicPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3, 1, 1), ).setIndexNames((0, "HP-ICF", "hpVgPortGroupIndex"), (0, "HP-ICF", "hpVgPortIndex"))
if mibBuilder.loadTexts: hpVgBasicPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgBasicPortEntry.setDescription('HP extended information about a specific vg port.')
hpVgPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: hpVgPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgPortGroupIndex.setDescription('The group that contains the port for which this entry contains information.')
hpVgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: hpVgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgPortIndex.setDescription('The port within the group for which this entry contains information.')
hpVgPortPolarityReversed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgPortPolarityReversed.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgPortPolarityReversed.setDescription('This object is used to indicate that the hub port was wired with the positive/negative polarity of its wire pairs reversed. Note that the port will continue to operate in this state, with the hub inverting the polarity internally.')
hpVgPortWireSkewError = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 1, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgPortWireSkewError.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgPortWireSkewError.setDescription('This object is used to indicate that a wire skew error has been detected on this port.')
hpVgMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2))
hpVgMonitorGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1))
hpVgMonCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1))
hpVgMonGlbReadableFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbReadableFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aReadableFramesReceived.')
if mibBuilder.loadTexts: hpVgMonGlbReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbReadableFrames.setDescription('This object is the total number of good frames of valid frame length that have been received on all ports in this repeater. This counter is the summation of the values of the icfVgPortReadableFrames counter for all of the ports in this repeater.')
hpVgMonGlbReadableOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbReadableOctets.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aReadableOctetsReceived.')
if mibBuilder.loadTexts: hpVgMonGlbReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbReadableOctets.setDescription('This object is a count of the total number of octets contained in good frames that have been received on all ports in this repeater. This counter is the summation of the values of the icfVgPortReadableOctets counter for all of the ports in this repeater. Note that this counter may roll over very quickly.')
hpVgMonGlbUnreadableOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbUnreadableOctets.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aOctetsInUnreadableFramesRcvd.')
if mibBuilder.loadTexts: hpVgMonGlbUnreadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbUnreadableOctets.setDescription('This object is a count of the total number of octets contained in invalid frames that have been received on all ports in this repeater. This counter is the summation of the values of icfVgPortUnreadableOctets counter for all of the ports in this repeater. Note that this counter may roll over very quickly.')
hpVgMonGlbHighPriorityFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbHighPriorityFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aHighPriorityFramesReceived.')
if mibBuilder.loadTexts: hpVgMonGlbHighPriorityFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbHighPriorityFrames.setDescription('This object is a count of the total number of high priority frames that have been received on all ports in this repeater. This counter is a summation of the values of the icfVgPortHighPriorityFrames counter for all of the ports in this repeater.')
hpVgMonGlbHighPriorityOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbHighPriorityOctets.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aHighPriorityOctetsReceived.')
if mibBuilder.loadTexts: hpVgMonGlbHighPriorityOctets.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbHighPriorityOctets.setDescription('This object is a count of the total number of octets contained in high priority frames that have been received on all ports of this repeater. This counter is a summation of the values of the icfVgPortHighPriorityOctets counter for all of the ports in this repeater. Note that this counter may roll over very quickly.')
hpVgMonGlbBroadcastFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbBroadcastFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aBroadcastFramesReceived.')
if mibBuilder.loadTexts: hpVgMonGlbBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbBroadcastFrames.setDescription('This object is a count of the total number of broadcast packets that have been received on all ports in this repeater. This counter is a summation of the values of the icfVgPortBroadcastFrames counter for all of the ports in this repeater.')
hpVgMonGlbMulticastFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbMulticastFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aMulticastFramesReceived.')
if mibBuilder.loadTexts: hpVgMonGlbMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbMulticastFrames.setDescription('This object is a count of the total number of multicast packets that have been received on all ports in this repeater. This counter is a summation of the values of the icfVgPortMulticastFrames counter for all of the ports in this repeater.')
hpVgMonGlbIPMFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbIPMFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aIPMFramesReceived.')
if mibBuilder.loadTexts: hpVgMonGlbIPMFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbIPMFrames.setDescription('This object is a count of the total number of frames that have been received on all ports in this repeater with an invalid packet marker. This counter is a summation of the values of the icfVgPortIPMFrames counter for all of the ports in this repeater.')
hpVgMonGlbDataErrorFrames = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbDataErrorFrames.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aDataErrorFramesReceived.')
if mibBuilder.loadTexts: hpVgMonGlbDataErrorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbDataErrorFrames.setDescription('This object is a count of the total number of errored frames received on all ports in this repeater. This counter is a summation of the values of the icfVgPortDataErrorFrames counter for all of the ports in this repeater.')
hpVgMonGlbPriorityPromotions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpVgMonGlbPriorityPromotions.setReference('Reference IEEE Draft Std. 802.12, 31 October, 1994, 13.2.4.5.1, aPriorityPromotions.')
if mibBuilder.loadTexts: hpVgMonGlbPriorityPromotions.setStatus('mandatory')
if mibBuilder.loadTexts: hpVgMonGlbPriorityPromotions.setDescription('This object is a count of the total number of times the priority promotion timer has expired on any port in this repeater. This counter is a summation of the values of the icfVgPortPriorityPromotions counter for all of the ports in this repeater.')
hpVgMonitorGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 2))
hpVgMonitorPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 3, 2, 3))
hpicfGenericRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4))
hpGRpBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1))
hpGRpBasicGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1))
hpGRpSelfHealEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpSelfHealEnable.setStatus('mandatory')
if mibBuilder.loadTexts: hpGRpSelfHealEnable.setDescription('This flag controls whether or not the device will send self healing packets. Self healing packets are normally sent once per second by the agent when no other traffic is present. When there is no traffic present on a network, there is no way to detect cabling problems (or the repair of cabling problems) and status LEDs are not always correct. Enabling this flag allows the agent to detect cabling problems on an idle network. This flag can be disabled if self healing packets are not wanted. On the 100BaseVG-AnyLAN SNMP/Bridge card, these packets are addressed to a unique unused unicast station address which has been reserved by HP for this purpose. On 802.3 repeaters, these packets are self addressed. On an 802.3 repeater, this flag MUST be enabled when using the Robust Port Healing feature. Without Robust Port Healing either a good transmit or a good receive will reconnect an autopartitioned port. With Robust Port Healing the criteria is more restrictive and only a good transmit will heal a segmented port. If all ports are segmented, the repeater will not repeat anything until the agent transmits a self healing packet and reconnects the autopartitioned ports.')
hpGRpBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 2))
hpGRpBasicPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 3))
hpGRpMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2))
hpGRpAddrTrack = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3))
hpicfNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 12))
hpicfCommonTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 1))
hpicf8023RptrTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 2))
hpicfVgRptrTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 3))
hpicfGenRptrTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 4))
hpicfChainAddition = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 1) + (0,1)).setObjects(("HP-ICF", "hpicfChainId"))
if mibBuilder.loadTexts: hpicfChainAddition.setDescription('An hpicfChainAddition trap indicates that a new node has been added to the Distributed Management Chain connected to this agent. The hpicfChainId returned is the identifier for the new node.')
hpicfChainRemoval = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 1) + (0,2)).setObjects(("HP-ICF", "hpicfChainId"))
if mibBuilder.loadTexts: hpicfChainRemoval.setDescription('An hpicfChainRemoval trap indicates that a node has been removed from the Distributed Management Chain connected to this agent. The hpicfChainId returned is the identifier for the node that was removed.')
thresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 1) + (0,0)).setObjects(("HP-ICF", "evthObject"), ("HP-ICF", "evthThreshold"), ("HP-ICF", "evthHysteresis"), ("HP-ICF", "evthTimeInterval"))
if mibBuilder.loadTexts: thresholdTrap.setDescription('A thresholdTrap(0) is specific to ICF devices. It signifies that the threshold entity in the device has detected that the object identified by evthObject has exceeded the threshold identified by evthThreshold during the time interval evthTimeInterval. After this condition occurs, it will not reoccur until the the object identified by evthObject falls below evthHysteresis for the duration of evthTimeInterval.')
stpTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 3) + (0,3)).setObjects(("HP-ICF", "stpPortState"))
if mibBuilder.loadTexts: stpTrap.setDescription('A stpTrap(3) is device type specific to ICF bridges. It signifies that the Spanning Tree entity in the bridge has detected a change of state to either Blocking or Forwarding.')
temperatureTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 3) + (0,4))
if mibBuilder.loadTexts: temperatureTrap.setDescription('A temperatureTrap(4) is device type specific to ICF bridges. It signifies that the bridge hardware has detected an overheated condition.')
linkBeatTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 2) + (0,3)).setObjects(("HP-ICF", "hubPortLinkBeatStatus"))
if mibBuilder.loadTexts: linkBeatTrap.setDescription("A linkBeatTrap(3) is device type specific to ICF hubs. It signifies that the hub hardware has detected a change of state in a port's link beat status. The current value of the port's link beat status is returned in the PDU.")
segmentationTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 2) + (0,4)).setObjects(("HP-ICF", "hubPortSegmentation"))
if mibBuilder.loadTexts: segmentationTrap.setDescription("A segmentationTrap(4) is device type specific to ICF hubs. It signifies that the hub hardware has detected a change of state in a port's segmentation status. The current value of the port's segmentation status is returned in the PDU.")
backupLinkTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 2) + (0,5)).setObjects(("SNMP-REPEATER-MIB", "rptrPortAdminStatus"))
if mibBuilder.loadTexts: backupLinkTrap.setDescription("A backupLinkTrap(5) is device type specific to most ICF hubs. It signifies that there has been a change in state of rptrPortAdminStatus for a backup port on the hub. The new value of rptrPortAdminStatus is returned in the PDU. Note that in EtherTwist hubs with revision 'D' or earlier firmware, the SNMP-REPEATER-MIB is not supported. These hubs map hub ports to interfaces in the interfaces group of RFC1213-MIB. For these hubs, the variable binding list contains ifAdminStatus for the backup port on the hub instead of rptrPortAdminStatus. Backup links are not supported on the HP28688A hub.")
intrusionTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 2) + (0,6)).setObjects(("HP-ICF", "hubIntruderAddress"), ("HP-ICF", "hubIntruderPort"))
if mibBuilder.loadTexts: intrusionTrap.setDescription("An intrusionTrap(6) is device type specific to EtherTwist hubs with revision 'E' firmware or later and AdvanceStack hubs. It signifies that a port security violation has been detected on a port which has the hubSecPtAlarmEnable flag set to 'enabled'. The MAC address of the intruder and the port on which the intrusion occurred are returned in the PDU.")
addressMovedTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 2) + (0,7)).setObjects(("HP-ICF", "hubAddrMoveAddress"), ("HP-ICF", "hubAddrMoveOldGroup"), ("HP-ICF", "hubAddrMoveOldPort"), ("HP-ICF", "hubAddrMoveNewGroup"), ("HP-ICF", "hubAddrMoveNewPort"))
if mibBuilder.loadTexts: addressMovedTrap.setDescription("An addressMovedTrap(7) is device type specific to EtherTwist hubs with revision 'E' firmware or later and AdvanceStack hubs. It signifies that a source MAC address which had been operating at one port has moved to a new port. The MAC address that moved, the group and port that the address moved from, and the group and port that the address moved to are returned in the PDU.")
newAddressTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 2) + (0,8)).setObjects(("SNMP-REPEATER-MIB", "rptrAddrTrackLastSourceAddress"))
if mibBuilder.loadTexts: newAddressTrap.setDescription("A newAddressTrap(8) is device type specific to EtherTwist hubs with revision 'E' firmware or later and AdvanceStack hubs. It signifies that a new MAC address has been detected on one of the hub's ports. The instance of rptrAddrTrackLastSourceAddress for the port with the new address is returned in the PDU.")
mibBuilder.exportSymbols("HP-ICF", icfVgMonRptr=icfVgMonRptr, stpCurrentHelloTime=stpCurrentHelloTime, hubBackupAddress=hubBackupAddress, RowStatus=RowStatus, hpVgGrpPortsPromiscuous=hpVgGrpPortsPromiscuous, hdlcRemoteConnectRequests=hdlcRemoteConnectRequests, hdlcErrorIndications=hdlcErrorIndications, icfRouterER=icfRouterER, hpicfDownloadErrorText=hpicfDownloadErrorText, icfRouter650Engine=icfRouter650Engine, evthArm=evthArm, evtIndex=evtIndex, thresholdTrap=thresholdTrap, hpicfEntityObjectId=hpicfEntityObjectId, addressTable=addressTable, hdlcRejectFrameReceives=hdlcRejectFrameReceives, hpRptrMonGlobalRunts=hpRptrMonGlobalRunts, icfVgPortIndex=icfVgPortIndex, hpicfEntityTable=hpicfEntityTable, icfVgBasicPortEntry=icfVgBasicPortEntry, icfVgGroupDescr=icfVgGroupDescr, hpVgPortWireSkewError=hpVgPortWireSkewError, icfDownload=icfDownload, icfRouter255=icfRouter255, reset=reset, hpicfDownloadLogSize=hpicfDownloadLogSize, x25Table=x25Table, hpRptrMonPtUcastPackets=hpRptrMonPtUcastPackets, hpRptrPtGroupIndex=hpRptrPtGroupIndex, evthTimeSinceOccurrence=evthTimeSinceOccurrence, hpRptrMonGlobalCollisions=hpRptrMonGlobalCollisions, stpPortId=stpPortId, hubAddrMoveOldPort=hubAddrMoveOldPort, hpicfObjects=hpicfObjects, icfVgPortIPMFrames=icfVgPortIPMFrames, hpRptrMonGlobalMcastPackets=hpRptrMonGlobalMcastPackets, hpicfChasAddrEntity=hpicfChasAddrEntity, hpicfChassisAddrEntry=hpicfChassisAddrEntry, newAddressTrap=newAddressTrap, hubSecPtPreventEavesdrop=hubSecPtPreventEavesdrop, hdlcLocalConnectRequests=hdlcLocalConnectRequests, hubIntruderGroup=hubIntruderGroup, hpVgBasicPortTable=hpVgBasicPortTable, hpicfSlotMapTable=hpicfSlotMapTable, advStackU16=advStackU16, forwardDbMaxAge=forwardDbMaxAge, hpRptrMonGlobalDataRateMismatches=hpRptrMonGlobalDataRateMismatches, icfConfig=icfConfig, icf8023MacOutMulticastPkts=icf8023MacOutMulticastPkts, icfVgRepeater=icfVgRepeater, hpRptrMonGlobalAutoPartitions=hpRptrMonGlobalAutoPartitions, stpForwardDelay=stpForwardDelay, hdlcRemoteConnectConfirms=hdlcRemoteConnectConfirms, hpicfDownloadTAddress=hpicfDownloadTAddress, hpicfDlLogIndex=hpicfDlLogIndex, hpRptrPtLinkbeatEnable=hpRptrPtLinkbeatEnable, hpVgMonGlbReadableOctets=hpVgMonGlbReadableOctets, icf8023MacMissedPktErrors=icf8023MacMissedPktErrors, hdlcRemoteXidCommands=hdlcRemoteXidCommands, icfVgGroupObjectID=icfVgGroupObjectID, icfVgGroupPortCapacity=icfVgGroupPortCapacity, icfVgAddrTrackPort=icfVgAddrTrackPort, hpicfDlLogTDomain=hpicfDlLogTDomain, icfFanSensor=icfFanSensor, stpTopoNumChanges=stpTopoNumChanges, stpHelloTime=stpHelloTime, wildcardArm=wildcardArm, hdlcLocalDisconnectConfirms=hdlcLocalDisconnectConfirms, hubGlobalInNUcastPkts=hubGlobalInNUcastPkts, hub=hub, hubIntruderAddress=hubIntruderAddress, brgPortCacheMisses=brgPortCacheMisses, hpicfLLCDomain=hpicfLLCDomain, hubSecPtAuthorizedAddress=hubSecPtAuthorizedAddress, evthThreshold=evthThreshold, hpicfEntityTimestamp=hpicfEntityTimestamp, hdlcRuntFrameReceives=hdlcRuntFrameReceives, hpicfSlotDescr=hpicfSlotDescr, icfVgPortAllowedTrainType=icfVgPortAllowedTrainType, icf8023MacIndex=icf8023MacIndex, hubBackupConsecutiveFails=hubBackupConsecutiveFails, hubAddressChunk=hubAddressChunk, stpPortRootId=stpPortRootId, hpicfChainThisBox=hpicfChainThisBox, hpVgMonGlbPriorityPromotions=hpVgMonGlbPriorityPromotions, hubAddrMoveAddress=hubAddrMoveAddress, hubSecurity=hubSecurity, hubIntruderIndex=hubIntruderIndex, hpicfGenericRepeater=hpicfGenericRepeater, hpicfDownloadTable=hpicfDownloadTable, hpVgGrpPortsTrained=hpVgGrpPortsTrained, hpVgMonitorPort=hpVgMonitorPort, advStack48=advStack48, icfVgBasicRptr=icfVgBasicRptr, hpicfEntityDescr=hpicfEntityDescr, hpRptrGrpPortsLinkbeatEnabled=hpRptrGrpPortsLinkbeatEnabled, icfTemperatureSensor=icfTemperatureSensor, icfVgDesiredFramingType=icfVgDesiredFramingType, hubPortPolarityReversed=hubPortPolarityReversed, addressIndex=addressIndex, hpRptrGrpPortsSegStatus=hpRptrGrpPortsSegStatus, icfConfigIfEntry=icfConfigIfEntry, hpicfChainAddition=hpicfChainAddition, hpicfDownload=hpicfDownload, hpRptrMonGlobalFrames=hpRptrMonGlobalFrames, hpicfChainObjectId=hpicfChainObjectId, hdlcRemoteNodeId=hdlcRemoteNodeId, icfRouter230=icfRouter230, stpBridgeId=stpBridgeId, icfVgBasicGroupTable=icfVgBasicGroupTable, hubBackupTestTime=hubBackupTestTime, eswitch=eswitch, hpRptrMonGlobalShortEvents=hpRptrMonGlobalShortEvents, icfVgMonPortEntry=icfVgMonPortEntry, hpVgPortGroupIndex=hpVgPortGroupIndex, hpicfAdmin=hpicfAdmin, hdlcRemoteTestCommands=hdlcRemoteTestCommands, repeaterAgent=repeaterAgent, hdlcLocalResetRequests=hdlcLocalResetRequests, x25Index=x25Index, hpVgGrpGroupIndex=hpVgGrpGroupIndex, hpicfEntityFunction=hpicfEntityFunction, advStackVg15=advStackVg15, hdlcRemoteResetConfirms=hdlcRemoteResetConfirms, icfVgPortPriorityPromotions=icfVgPortPriorityPromotions, evtIpxNotify=evtIpxNotify, icf8023MacTotalMediaErrors=icf8023MacTotalMediaErrors, icfVgPortBroadcastFrames=icfVgPortBroadcastFrames, hpVgBasicGroup=hpVgBasicGroup, icf8023MacInBroadcastPkts=icf8023MacInBroadcastPkts, nm=nm, icfDownloadIpxAddress=icfDownloadIpxAddress, hubAddrMoveOldGroup=hubAddrMoveOldGroup, hpicfDownloadStatus=hpicfDownloadStatus, hpVgMonitor=hpVgMonitor, hpicfSensorWarnings=hpicfSensorWarnings, hpRptrMonPtGroupIndex=hpRptrMonPtGroupIndex, hpicfChassisNumSlots=hpicfChassisNumSlots, hpicfEntityEntry=hpicfEntityEntry, icfVgAddrTrackGroup=icfVgAddrTrackGroup, hpVgEntityName=hpVgEntityName, hpRptrRobustHealing=hpRptrRobustHealing, hpicfSlotMapEntry=hpicfSlotMapEntry, stpTopoChangeTime=stpTopoChangeTime, hubAddressMoveLogEntry=hubAddressMoveLogEntry, hubIntruderLogTable=hubIntruderLogTable, icfConfigIfNetMask=icfConfigIfNetMask, hpRptrMonGlobalFrameTooLongs=hpRptrMonGlobalFrameTooLongs, icfRouter210=icfRouter210, stpPortDesignatedPort=stpPortDesignatedPort, hpicfDownloadIndex=hpicfDownloadIndex, icfEnetAgent=icfEnetAgent, fiberOptic=fiberOptic, eventNotificationNode=eventNotificationNode, hpVgMonGlbUnreadableOctets=hpVgMonGlbUnreadableOctets, hdlcErrorIndex=hdlcErrorIndex, stpPortPriority=stpPortPriority, hpicfDomains=hpicfDomains, TAddress=TAddress, stpDesignatedRoot=stpDesignatedRoot, icfSecurPassword=icfSecurPassword, hpicfDlLogErrorText=hpicfDlLogErrorText, hubPortTable=hubPortTable, hpicfRepeater=hpicfRepeater, hpRptrBasicGroup=hpRptrBasicGroup, discovery=discovery, hubSecPtPortIndex=hubSecPtPortIndex, hpicfDlLogFilename=hpicfDlLogFilename, icfPowerSupplySensor=icfPowerSupplySensor, icfVgMonGroup=icfVgMonGroup, hubBkpLinkTable=hubBkpLinkTable, hpicfChainId=hpicfChainId, hdlcRemoteIndex=hdlcRemoteIndex, icfVgPortMulticastFrames=icfVgPortMulticastFrames, hubGlobalCrcErrors=hubGlobalCrcErrors, hpicfChainViewId=hpicfChainViewId, hpicfSlotTable=hpicfSlotTable, icfEvent=icfEvent, semaphore=semaphore, hpicfSlotObjectId=hpicfSlotObjectId, hpRptrMonPtBcastPackets=hpRptrMonPtBcastPackets, icfRouterFR=icfRouterFR, stpCurrentForwardDelay=stpCurrentForwardDelay, hpVgMonGlbHighPriorityOctets=hpVgMonGlbHighPriorityOctets, hpicfSelfTest=hpicfSelfTest, advStackU8=advStackU8, hpicfSensorIndex=hpicfSensorIndex, wildcardFilter=wildcardFilter, hpRptrGrpPortsOperStatus=hpRptrGrpPortsOperStatus, stpPortDesignatedBridge=stpPortDesignatedBridge, icfRouter650Port4S=icfRouter650Port4S, hpRptrBasicPtTable=hpRptrBasicPtTable, hubPortSegmentation=hubPortSegmentation, stpPortIndex=stpPortIndex, icfVgPortUnreadableOctets=icfVgPortUnreadableOctets, hdlcLocalTable=hdlcLocalTable, stpMaxAge=stpMaxAge, hdlcFrameRejectFrameRecs=hdlcFrameRejectFrameRecs, segmentationTrap=segmentationTrap, hpRptrAddrTrack=hpRptrAddrTrack, icfVgPortDataErrorFrames=icfVgPortDataErrorFrames, hpicfDownloadLogMaxSize=hpicfDownloadLogMaxSize, hpicfDlLogOwnerAddress=hpicfDlLogOwnerAddress, icfVgBasicPortTable=icfVgBasicPortTable, icfVgMACAddress=icfVgMACAddress, selfTest=selfTest, linkTest=linkTest, operationalState=operationalState, hpVgMonitorGroup=hpVgMonitorGroup, hubPortLinkBeatStatus=hubPortLinkBeatStatus, icfVgMonPortTable=icfVgMonPortTable, hpicfVgRptrTraps=hpicfVgRptrTraps, hpRptrPtPortIndex=hpRptrPtPortIndex, hubPortCollisions=hubPortCollisions, icfVgTrainingVersion=icfVgTrainingVersion, linkBeatTrap=linkBeatTrap, hpGRpAddrTrack=hpGRpAddrTrack, etherTwist24S=etherTwist24S, hdlcRemoteState=hdlcRemoteState, wildcardIndex=wildcardIndex, hdlcRemoteDisconnectRequests=hdlcRemoteDisconnectRequests, icfVgBasic=icfVgBasic, linkTest802MacAddress=linkTest802MacAddress, chassisAgents=chassisAgents, hpVgMonCounters=hpVgMonCounters, hpicfSlotEntry=hpicfSlotEntry, hubPortMacAddress=hubPortMacAddress, stpRootPort=stpRootPort, hubPortLateEventDisable=hubPortLateEventDisable, hpRptrMonGlobalAlignmentErrors=hpRptrMonGlobalAlignmentErrors, hpicfDownloadResetType=hpicfDownloadResetType, icfCommon=icfCommon, hpGRpBasic=hpGRpBasic, icfVgPortSupportedPromiscMode=icfVgPortSupportedPromiscMode, hpVgBasicGlobal=hpVgBasicGlobal, icfDot12Draft=icfDot12Draft, hdlcGiantFrameReceives=hdlcGiantFrameReceives, hdlcLocalResetConfirms=hdlcLocalResetConfirms, hdlcLocalIndex=hdlcLocalIndex, icf8023MacInMulticastPkts=icf8023MacInMulticastPkts, icfSecurAuthAnyMgr=icfSecurAuthAnyMgr, hpicfDownloadLogEntry=hpicfDownloadLogEntry, hubAddressMoveLogTable=hubAddressMoveLogTable, icfRouterSR=icfRouterSR, wildcardOffset=wildcardOffset, hpRptrMonGlobalFCSErrors=hpRptrMonGlobalFCSErrors, hpVgMonitorGlobal=hpVgMonitorGlobal, hpicfSensorEntry=hpicfSensorEntry, hdlcRemoteTable=hdlcRemoteTable, icfVgRepeaterHealthState=icfVgRepeaterHealthState, icfAuthMgrRcvTraps=icfAuthMgrRcvTraps, hpicfChasAddrAddress=hpicfChasAddrAddress, hpicfCommon=hpicfCommon, hpRptrSqeEnabled=hpRptrSqeEnabled)
mibBuilder.exportSymbols("HP-ICF", hpRptrMonGlobalLateEvents=hpRptrMonGlobalLateEvents, hubGlobalRunts=hubGlobalRunts, hpicfDlLogOwnerDomain=hpicfDlLogOwnerDomain, hpicfNotifications=hpicfNotifications, advStack12=advStack12, brgPortFilteredPkts=brgPortFilteredPkts, temperatureTrap=temperatureTrap, icfSecurAuthMgrTable=icfSecurAuthMgrTable, hdlcLocalState=hdlcLocalState, hpicfDlLogTAddress=hpicfDlLogTAddress, hubAddressTable=hubAddressTable, linkTestSuccess=linkTestSuccess, icfSecurIntruderFlag=icfSecurIntruderFlag, hubPortLinkBeatEnable=hubPortLinkBeatEnable, icfSensors=icfSensors, evthObject=evthObject, icfVgAddrTrainedAddrChanges=icfVgAddrTrainedAddrChanges, icfVgPortMediaType=icfVgPortMediaType, hpRptrMonCounters=hpRptrMonCounters, linkTestTimeout=linkTestTimeout, icfVgPortReadableOctets=icfVgPortReadableOctets, addressMovedTrap=addressMovedTrap, hpRptrBasicPtEntry=hpRptrBasicPtEntry, hpRptrMonitorGroup=hpRptrMonitorGroup, icfSecurIntruderTime=icfSecurIntruderTime, MacAddress=MacAddress, x25T1Timer=x25T1Timer, icfVgMonitor=icfVgMonitor, hdlcRcvOverruns=hdlcRcvOverruns, hpicfDownloadOwnerDomain=hpicfDownloadOwnerDomain, x25T3Timer=x25T3Timer, hpicfGenRptrTraps=hpicfGenRptrTraps, hpicfChassisAddrTable=hpicfChassisAddrTable, icfRouterLR=icfRouterLR, hdlcRemoteAddress=hdlcRemoteAddress, intrusionTrap=intrusionTrap, hpicfDlLogResetType=hpicfDlLogResetType, wildcardUserOffset=wildcardUserOffset, netElement=netElement, hubSecurePortEntry=hubSecurePortEntry, hubGlobalPktFragments=hubGlobalPktFragments, stp=stp, icf8023MacOutBroadcastPkts=icf8023MacOutBroadcastPkts, icfRouterPR=icfRouterPR, icfRouter650=icfRouter650, hubPortPktFragments=hubPortPktFragments, hpicfSensorObjectId=hpicfSensorObjectId, stpPortTable=stpPortTable, icfVgRepeaterNonDisruptTest=icfVgRepeaterNonDisruptTest, hpicfChassisId=hpicfChassisId, hpicfChainViewTable=hpicfChainViewTable, hpVgBasicGroupEntry=hpVgBasicGroupEntry, icfVgRepeaterGroupCapacity=icfVgRepeaterGroupCapacity, icfVgAddrTrackEntry=icfVgAddrTrackEntry, hdlcProviderLostPrimitives=hdlcProviderLostPrimitives, hpicfSlotMapEntity=hpicfSlotMapEntity, hpVgBasicPortEntry=hpVgBasicPortEntry, hubPortAddressState=hubPortAddressState, icfSecurIntruder=icfSecurIntruder, hubBkpLinkIndex=hubBkpLinkIndex, thinLAN=thinLAN, hpicfSensorNumber=hpicfSensorNumber, hpRptrBasicGroupTable=hpRptrBasicGroupTable, hpVgGrpPortsAdminStatus=hpVgGrpPortsAdminStatus, hpicfDownloadTDomain=hpicfDownloadTDomain, hdlcLocalAddress=hdlcLocalAddress, hubGlobalGiants=hubGlobalGiants, icf8023MacTable=icf8023MacTable, icfHub=icfHub, icf=icf, router=router, hubThinlanFault=hubThinlanFault, hpVgMonGlbBroadcastFrames=hpVgMonGlbBroadcastFrames, icfVgGroupLastOperStatusChange=icfVgGroupLastOperStatusChange, chassis=chassis, linkTestIpAddress=linkTestIpAddress, hdlcErrorTable=hdlcErrorTable, pollResponse=pollResponse, icfBridge=icfBridge, icfVgPortSupportedCascadeMode=icfVgPortSupportedCascadeMode, icfVgAddrLastTrainedAddress=icfVgAddrLastTrainedAddress, icfVgPortHighPriorityFrames=icfVgPortHighPriorityFrames, icfVgGroupIndex=icfVgGroupIndex, icfRouterBR=icfRouterBR, hpGRpBasicPort=hpGRpBasicPort, icfConfigIfIndex=icfConfigIfIndex, hpRptrMonGlobalErrors=hpRptrMonGlobalErrors, hubSqeEnabled=hubSqeEnabled, icfVgGroupOperStatus=icfVgGroupOperStatus, hubGlobalInOctets=hubGlobalInOctets, x25N2Count=x25N2Count, hpicfVg=hpicfVg, hpicfSlotIndex=hpicfSlotIndex, hpicfChainTable=hpicfChainTable, icfSecurIntruderIpAddress=icfSecurIntruderIpAddress, hpRptrBasicPort=hpRptrBasicPort, hubAddrMoveNewPort=hubAddrMoveNewPort, icfVgAddrTrackTable=icfVgAddrTrackTable, addressChunk=addressChunk, hpRptrEntityName=hpRptrEntityName, backupLinkTrap=backupLinkTrap, icfVgAddrTrack=icfVgAddrTrack, hubSecurePortTable=hubSecurePortTable, announceAddress=announceAddress, TimeStamp=TimeStamp, hpRptrMonGlobalBcastPackets=hpRptrMonGlobalBcastPackets, icfVgFramingCapability=icfVgFramingCapability, icfVgGroupCablesBundled=icfVgGroupCablesBundled, brgPortIndex=brgPortIndex, icfVgBasicGroupEntry=icfVgBasicGroupEntry, icf8023MacRunts=icf8023MacRunts, hpRptrGrpPortsAdminStatus=hpRptrGrpPortsAdminStatus, hpVgPortPolarityReversed=hpVgPortPolarityReversed, linkTestAddress=linkTestAddress, mapPort=mapPort, hpVgGrpPortsCascaded=hpVgGrpPortsCascaded, icfVgPortTrainingResult=icfVgPortTrainingResult, linkTestRepetitions=linkTestRepetitions, wildcardTable=wildcardTable, evtArm=evtArm, hpicfChain=hpicfChain, hubIntruderTime=hubIntruderTime, hpGRpBasicGroup=hpGRpBasicGroup, hpicfChassis=hpicfChassis, icfConfigIfDefaultGate=icfConfigIfDefaultGate, hpVgMonGlbHighPriorityFrames=hpVgMonGlbHighPriorityFrames, icfVgAddrTrackRptr=icfVgAddrTrackRptr, hpVgBasic=hpVgBasic, hpicf8023RptrTraps=hpicf8023RptrTraps, hpicfChainHasAgent=hpicfChainHasAgent, TruthValue=TruthValue, icfVgRepeaterReset=icfVgRepeaterReset, hpVgPortIndex=hpVgPortIndex, stpPortState=stpPortState, hpRptrGrpGroupIndex=hpRptrGrpGroupIndex, hpRptrMonitorPort=hpRptrMonitorPort, hpicfSlotLastChange=hpicfSlotLastChange, stpPortPathCost=stpPortPathCost, hpicfChainViewName=hpicfChainViewName, hubAddrMoveIndex=hubAddrMoveIndex, icfAuthMgrIndex=icfAuthMgrIndex, hpicfSlotMapSlot=hpicfSlotMapSlot, hpicfChainLocation=hpicfChainLocation, linkTestIpxAddress=linkTestIpxAddress, icfAuthMgrIpAddress=icfAuthMgrIpAddress, bridge1010=bridge1010, hubBitmaps=hubBitmaps, stpPortDesignatedCost=stpPortDesignatedCost, evtIpNotify=evtIpNotify, icf8023MacSpuriousIntrs=icf8023MacSpuriousIntrs, hdlcRejectFrameSends=hdlcRejectFrameSends, stpTrap=stpTrap, hpicfDownloadLogTable=hpicfDownloadLogTable, hubGlobalCollisions=hubGlobalCollisions, hpicfChainLastChange=hpicfChainLastChange, mapAddress=mapAddress, hdlcRemoteTestResponses=hdlcRemoteTestResponses, hpRptrMonitor=hpRptrMonitor, icfConfigIfIpAddress=icfConfigIfIpAddress, icfSecurAuthMgrEntry=icfSecurAuthMgrEntry, icfVgMonPort=icfVgMonPort, icfVgBasicPort=icfVgBasicPort, icfConfigIpTTL=icfConfigIpTTL, hdlcRemoteResetRequests=hdlcRemoteResetRequests, hdlcLocalConnectConfirms=hdlcLocalConnectConfirms, icf8023MacGiants=icf8023MacGiants, hpGRpBasicGlobal=hpGRpBasicGlobal, hpicfSensorDescr=hpicfSensorDescr, hpicfChasAddrType=hpicfChasAddrType, wildcardMask=wildcardMask, hdlcLocalPhase=hdlcLocalPhase, hpRptrBasicGroupEntry=hpRptrBasicGroupEntry, password=password, hpRptrBasic=hpRptrBasic, hpRptrGrpPortsMediaAvailable=hpRptrGrpPortsMediaAvailable, stpRootCost=stpRootCost, brgPortCacheHits=brgPortCacheHits, hdlcXmtUnderruns=hdlcXmtUnderruns, icfSecurIntruderIpxAddress=icfSecurIntruderIpxAddress, hpicfChainEntry=hpicfChainEntry, hubLateEventMonitor=hubLateEventMonitor, hpicfDownloadFilename=hpicfDownloadFilename, hpVgBasicGroupTable=hpVgBasicGroupTable, bridge=bridge, icfVgPortStatus=icfVgPortStatus, brgPortForwardedPkts=brgPortForwardedPkts, hpRptrMonPtTable=hpRptrMonPtTable, hpicfChainChanges=hpicfChainChanges, evtTable=evtTable, stpCurrentMaxAge=stpCurrentMaxAge, hpicfChainCurMembers=hpicfChainCurMembers, hpRptrAddrTrkGlobal=hpRptrAddrTrkGlobal, hpVgBasicPort=hpVgBasicPort, brgPortTable=brgPortTable, icfDownloadFilename=icfDownloadFilename, hubAddrMoveNewGroup=hubAddrMoveNewGroup, hpRptrMonitorGlobal=hpRptrMonitorGlobal, hdlcMissedPackets=hdlcMissedPackets, hpVgMonGlbIPMFrames=hpVgMonGlbIPMFrames, hpicfChainMaxMembers=hpicfChainMaxMembers, hpicfDownloadErrorStatus=hpicfDownloadErrorStatus, stpTopoChange=stpTopoChange, hubAddressIndex=hubAddressIndex, hpRptrAddrTrkGroup=hpRptrAddrTrkGroup, hpicfSensorStatus=hpicfSensorStatus, icfRouter650Port4T=icfRouter650Port4T, hpicfDownloadOwnerAddress=hpicfDownloadOwnerAddress, icfVgPortAdminStatus=icfVgPortAdminStatus, hpicfChainTimestamp=hpicfChainTimestamp, icfVgPortType=icfVgPortType, icfVgPortReadableFrames=icfVgPortReadableFrames, icfConfigIfTable=icfConfigIfTable, hpicfSensorTable=hpicfSensorTable, hdlcT1Timeouts=hdlcT1Timeouts, hubSecPtIntrusionFlag=hubSecPtIntrusionFlag, hubGlobalInUcastPkts=hubGlobalInUcastPkts, hubGlobalAlignmentErrors=hubGlobalAlignmentErrors, hubGlobalInBroadcastPkts=hubGlobalInBroadcastPkts, hubIntruderLogEntry=hubIntruderLogEntry, hubGlobalErrors=hubGlobalErrors, hpVgMonGlbMulticastFrames=hpVgMonGlbMulticastFrames, hpVgGrpPortsInTraining=hpVgGrpPortsInTraining, icfSecurity=icfSecurity, hubNumBkpLinks=hubNumBkpLinks, evthHysteresis=evthHysteresis, hpicfEntityIndex=hpicfEntityIndex, hpVgMonGlbReadableFrames=hpVgMonGlbReadableFrames, hdlcRemoteXidResponses=hdlcRemoteXidResponses, hpVgMonGlbDataErrorFrames=hpVgMonGlbDataErrorFrames, ipSubnetMask=ipSubnetMask, hpSystem=hpSystem, hubSecPtAlarmEnable=hubSecPtAlarmEnable, hubSecPtGroupIndex=hubSecPtGroupIndex, lastSetError=lastSetError, hpicfChainRemoval=hpicfChainRemoval, hpicfChainViewEntry=hpicfChainViewEntry, icfDownloadIpAddress=icfDownloadIpAddress, icfVgPortHighPriorityOctets=icfVgPortHighPriorityOctets, hpicfBasic=hpicfBasic, hpRptrThinlanFault=hpRptrThinlanFault, icf8023MacExcessDeferrals=icf8023MacExcessDeferrals, icfRouter650Port4E=icfRouter650Port4E, icfConfigBootpEnable=icfConfigBootpEnable, hpGRpSelfHealEnable=hpGRpSelfHealEnable, hpRptrMonGlobalUcastPackets=hpRptrMonGlobalUcastPackets, hdlcBadFrameReceives=hdlcBadFrameReceives, hpGRpMonitor=hpGRpMonitor, hpRptrMonGlobalOctets=hpRptrMonGlobalOctets, icfDownloadAddress=icfDownloadAddress, hubAddressTableMaxAge=hubAddressTableMaxAge, hubPrimaryPort=hubPrimaryPort, hpicfDlLogErrorStatus=hpicfDlLogErrorStatus, icfVgRepeaterHealthText=icfVgRepeaterHealthText, icfVgPortLastTrainConfig=icfVgPortLastTrainConfig)
mibBuilder.exportSymbols("HP-ICF", hubGlobal=hubGlobal, evthIndex=evthIndex, etherTwist48=etherTwist48, hubPortsOperStatus=hubPortsOperStatus, icfVgPortPriorityEnable=icfVgPortPriorityEnable, hp=hp, bridgeRemote=bridgeRemote, hpRptrMonGlobalVeryLongEvents=hpRptrMonGlobalVeryLongEvents, evtTimeSinceOccurrence=evtTimeSinceOccurrence, hpRptrAddrTrkPort=hpRptrAddrTrkPort, icfRouter250=icfRouter250, hpRptrMonPtEntry=hpRptrMonPtEntry, hubPortIndex=hubPortIndex, hubIntruderPort=hubIntruderPort, hpRptrMonPtPortIndex=hpRptrMonPtPortIndex, hpicfCommonTraps=hpicfCommonTraps, stpPriority=stpPriority, hpicfReset=hpicfReset, hpicfSensorFailures=hpicfSensorFailures, hubBackupPort=hubBackupPort, icfVgPortGroupIndex=icfVgPortGroupIndex, icfVgCurrentFramingType=icfVgCurrentFramingType, hpRptrPtPolarityReversed=hpRptrPtPolarityReversed, icfVgAgent=icfVgAgent, evthTimeInterval=evthTimeInterval, advStack24=advStack24, evtThresholdTable=evtThresholdTable, hpRptrMonPtMcastPackets=hpRptrMonPtMcastPackets, hdlcLocalDisconnectRequests=hdlcLocalDisconnectRequests, icfAuthMgrIpxAddress=icfAuthMgrIpxAddress, icfVgBasicGroup=icfVgBasicGroup, hubSecPtSecurityAddress=hubSecPtSecurityAddress, icfRouterTR=icfRouterTR, etherTwist12=etherTwist12, mapState=mapState, hpRptrBasicGlobal=hpRptrBasicGlobal, hpicfDownloadEntry=hpicfDownloadEntry)

#
# PySNMP MIB module CTRON-BDG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTRON-BDG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:44:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
bridge, layerMgmt = mibBuilder.importSymbols("IRM-OIDS", "bridge", "layerMgmt")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Integer32, Counter32, Counter64, NotificationType, ObjectIdentity, iso, MibIdentifier, ModuleIdentity, Unsigned32, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Integer32", "Counter32", "Counter64", "NotificationType", "ObjectIdentity", "iso", "MibIdentifier", "ModuleIdentity", "Unsigned32", "Bits", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
bridgeRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1))
bdgdevice = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1))
bdgPort = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2))
filterDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3))
trapTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 4))
bdgTables = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 5))
acqDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1))
permDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2))
specialDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3))
acqStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1))
acqOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2))
permStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1))
permOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2))
specStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1))
specFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2))
bdgdeviceDisableBdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableBridge", 0), ("enableBridge", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceDisableBdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceDisableBdg.setDescription('Indicates if the bridge will be disabled.')
bdgdeviceRestoreSettings = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("restoreSettings", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceRestoreSettings.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRestoreSettings.setDescription('Restore the following settings to their default values: Bridge Name to ETHERNET_BRIDGE, Location to LOCAL, Port 1 Name to PORT_1, Port 2 Name to PORT_2, Port 1 Network Name to LAN_1, Port 2 Network Name to LAN_2, Ageing Time for Acquired Database to 300 seconds, Erase the acquired database, Erase the permanent database, Place sixteen default multicast addresses into the permanent and acquired databases, Type of Spanning Tree to 802.1, Type of Filtering to IEEE 802.1, Bridge Max Age to 20 seconds, Bridge Forward Delay to 15 seconds, Bridge Hello Time to 2 seconds, Bridge Priority to 8000, Port 1 Priority to 80, Port 2 Priority to 80, Port 1 Path Cost to 100, Port 2 Path Cost to 100, Restart the bridge.')
bdgdeviceBdgName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgName.setDescription('The user-defined name (up to 32 characters long) of the bridge. The default bridge name is ETHERNET_BRIDGE.')
bdgdeviceNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceNumPorts.setDescription('The number of ports present on the bridge.')
bdgdeviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceType.setDescription('The type of bridge, NB25E, IRBM, or NB20E.')
bdgdeviceVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceVersion.setDescription('The release version of the firmware installed in the bridge.')
bdgdeviceLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceLocation.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceLocation.setDescription('The user-defined name to indicate the location of the bridge on the network. The default location name is LOCAL.')
bdgdeviceStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceStatus.setDescription('The status of the bridge, ON-LINE, STAND BY or DISABLED.')
bdgdeviceRestartBdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("restartBridge", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceRestartBdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRestartBdg.setDescription('Force the bridge to undergo a software reset.')
bdgdeviceFrFwd = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrFwd.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrFwd.setDescription('The number of frames forwarded by the bridge.')
bdgdeviceFrRx = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrRx.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrRx.setDescription('The number of frames received by the bridge.')
bdgdeviceFrFlt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrFlt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrFlt.setDescription('The number of frames filtered by the bridge.')
bdgdeviceErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceErr.setDescription('The total number of network errors that have occurred.')
bdgdeviceSwitchSetting = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceSwitchSetting.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceSwitchSetting.setDescription('Indicates the current switch settings read from the bridge hardware.')
bdgdeviceNumRestarts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceNumRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceNumRestarts.setDescription('The number of times the bridge has been powered up or restarted.')
bdgdeviceTypeFiltering = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ieee8021", 0), ("specialDB", 1), ("both", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceTypeFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTypeFiltering.setDescription('The type of filtering to be performed by the bridge. The default is IEEE 802.1.')
bdgdeviceSTAProtocol = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ieee8021", 0), ("dec", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceSTAProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceSTAProtocol.setDescription('The spanning tree algorithm under which the bridge is operating. The selections are as follows: - IEEE 802.1 compliant spanning tree algorithm environment (802.1) - DEC LAN Bridge 100 environment (DEC) - Without the spanning tree algorithm enabled (NONE) The default is 802.1.')
bdgdeviceBridgeID = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceBridgeID.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBridgeID.setDescription('The unique identifier of the bridge. The first two bytes of the identifier are the bridge priority and the last six bytes are the Ethernet address.')
bdgdeviceTopChgCnt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTopChgCnt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTopChgCnt.setDescription("The number of times the bridge's Topology Change Flag has been changed since the bridge was powered up or initialized.")
bdgdeviceRootCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRootCost.setDescription('The cost of the path to the root from this bridge.')
bdgdeviceRootPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRootPort.setDescription('The port identifier for the port which offers the lowest cost path to the root, i.e. that port for which the sum of the values of the designated cost and path cost parameters held for the port is lowest.')
bdgdeviceHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceHelloTime.setDescription("The time interval between the transmission of Configuration BPDU's by a bridge which is attempting to become the root or is the root.")
bdgdeviceBdgMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgMaxAge.setDescription('The value of the Max Age parameter when the bridge is the root or is attempting to become the root. A time of 6 to 40 seconds is allowed. The default is 20 seconds.')
bdgdeviceBdgFwdDly = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgFwdDly.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgFwdDly.setDescription('The value of the forward delay parameter when the bridge is the root or is attempting to become the root. A time of 4 to 30 seconds is allowed.')
bdgdeviceTimeTopChg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTimeTopChg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTimeTopChg.setDescription("The time in seconds that has elapsed since the bridge's Topology Change Flag last recorded the value of a topology change.")
bdgdeviceTopChg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noTopologyChangeInProgress", 0), ("topologyChangeInProgress", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTopChg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTopChg.setDescription('Indicates if a bridge topology change is in progress.')
bdgdeviceDesigRoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceDesigRoot.setDescription('The unique identifier of the bridge recorded as the root.')
bdgdeviceMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceMaxAge.setDescription('The maximum age of received protocol information before it is discarded.')
bdgdeviceHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceHoldTime.setDescription("The minimum time period elapsing between the transmission of configuration BPDU's through a given bridge port.")
bdgdeviceFwdDly = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFwdDly.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFwdDly.setDescription('The time spent in the listening state while moving from the blocking state to the learning state, or the time spent in the learning state while moving from the listening state to the forwarding state.')
bdgdeviceBdgHello = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgHello.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgHello.setDescription('The value of the Hello Time parameter when the bridge is the root or is attempting to become the root. A time of 1 to 10 seconds is allowed. The default is 2 seconds.')
bdgdeviceBdgPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgPriority.setDescription('The part of the bridge address that contains the identifier used in the spanning tree for priority comparisons. Allowed range is 0 through FFFF. The default is 8000.')
bdgdeviceResetCounts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("resetCounts", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceResetCounts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceResetCounts.setDescription('Reset all counters to zero.')
bdgdeviceUptime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceUptime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceUptime.setDescription('The time, in seconds, that has elapsed since the bridge was last reset or initialized.')
bdgdeviceTrapType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 36), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTrapType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTrapType.setDescription('Contains the object identifier of the first VarBinding in the last trap generated by the bridge.')
bdgPortAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortAddress.setDescription('The Ethernet address of the port.')
bdgPortName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortName.setDescription('The user-defined name assigned to the port. The default port 1 name is PORT_1 and the default Port 2 name is PORT_2.')
bdgPortType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortType.setDescription('The IEEE specification the port meets, e.g. 802.3.')
bdgPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortStatus.setDescription('The status in which the port is operating. The status messages for Ports 1 and 2 are: OFF - The port is off, due to a failed network interface chip associated with that port. OK/SQE ON - The port is communicating with the network and the transceiver making the connection to the network has SQE enabled. OK/SQE OFF - The port is communicating with the network and the transceiver making the connection to the network has SQE disabled. CARRIER LOST - Communication with the network has not been established or has been lost.')
bdgPortNetName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortNetName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortNetName.setDescription('The user-defined name assigned to a network segment connected to the port. The default network name for Port 1 is LAN_1 and the default network name for Port 2 is LAN_2.')
bdgPortFrRx = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrRx.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrRx.setDescription('The number of frames received at the specified port.')
bdgPortDisInb = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisInb.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisInb.setDescription('The total number of valid frames that were received at the port but then discarded by the bridge in the forwarding process.')
bdgPortFwdOutb = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFwdOutb.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFwdOutb.setDescription('The number of frames forwarded successfully to the appropriate port.')
bdgPortDisLOB = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisLOB.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisLOB.setDescription('The number of packets that were discarded by the bridge because of a lack of buffer space to maintain the data.')
bdgPortDisTDE = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisTDE.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisTDE.setDescription('The number of frames that were intended for forwarding but were discarded when the maximum time period set for transmission was exceeded before forwarding was possible.')
bdgPortDisErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisErr.setDescription('The number of frames that could not be transmitted because the frame was too large for the attached network (1526 bytes, including preamble, for 802.3 networks).')
bdgPortColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortColl.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortColl.setDescription('The number of collisions that have occurred on the network at the specified port.')
bdgPortTxAbrt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortTxAbrt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortTxAbrt.setDescription('The number of transmissions that have been aborted due to excessive collisions (over 16 attempts to transmit the same packet).')
bdgPortOowColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortOowColl.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortOowColl.setDescription('The number of collisions out of the standard collision window (51.2 uS). This indicates a network problem.')
bdgPortCRCErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortCRCErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortCRCErr.setDescription('The number of packets detected with Cyclical Redundancy Check failures.')
bdgPortFrAlErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrAlErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrAlErr.setDescription('The number of errors due to misaligned packets.')
bdgPortPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortPriority.setDescription('The part of the port identifier which is used with the spanning tree algorithm when determining which port in a LAN segment has priority. The default is 80.')
bdgPortState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortState.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortState.setDescription('The current state of the port, DISABLED, LISTENING, LEARNING, FORWARDING or BLOCKING.')
bdgPortPathCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortPathCost.setDescription('The contributory cost of the applicable port to the overall cost of the path when the specified port is the root port. Allowable range is 1 to 65535. The default is 100.')
bdgPortDesigCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigCost.setDescription('The cost of the path of this port to the root bridge on the network.')
bdgPortDesigBrdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigBrdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigBrdg.setDescription('The network address of the bridge that is assumed to be the root bridge on the network.')
bdgPortDesigPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigPort.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigPort.setDescription('The port identifier of the bridge port believed to be the designated port for the LAN associated with the port.')
bdgPortTopChgAck = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noTopologyChangeIsOccurring", 0), ("topologyChangeIsOccurring", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortTopChgAck.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortTopChgAck.setDescription('The value of the topology change acknowledgement flag in the next configuration BPDU to be transmitted on the associated port.')
bdgPortDesigRoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigRoot.setDescription('The unique bridge identifier of the bridge that is assumed to be the root bridge on the network.')
bdgPortRuntPackets = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortRuntPackets.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortRuntPackets.setDescription('The number of packets received at the indicated bdgPort that were less than the IEEE 802.3 minimum Ethernet frame size of 64 bytes.')
bdgPortOversizePackets = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortOversizePackets.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortOversizePackets.setDescription('The number of packets received at the indicated port that were greater than the IEEE 802.3 maximum Ethernet frame size of 1518 bytes.')
bdgPortFrFilt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrFilt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrFilt.setDescription('The number of frames received at the indicated port that were filtered by the bridge.')
acqTotalEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqTotalEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqTotalEntries.setDescription('The total number of entries in the acquired database.')
acqMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqMaxEntries.setDescription('The maximum number of entries allowed in the acquired database.')
acqStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqStaticEntries.setDescription('The number of addresses added to the Acquired database by the user or network manager.')
acqStaticAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqStaticAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: acqStaticAgeTime.setDescription('The length of time allowed for a static entry in the Acquired database to be inactive before it is dropped from the database. This time is fixed at zero.')
acqDynEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDynEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqDynEntries.setDescription("The number of entries that have been accumulated in the Acquired database through the bridge's learning process.")
acqDynAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqDynAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: acqDynAgeTime.setDescription('The length of time allowed for a dynamic entry in the acquired database to be inactive before it is dropped from the database. A time from 10 - 1,000,000 seconds is allowed. The default is 300 seconds.')
acqEraseDatabase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("eraseAcquiredDatabase", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqEraseDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: acqEraseDatabase.setDescription('Set to zero to erase all entries in the acquired database.')
acqCreate00 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryFilterPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate00.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate00.setDescription('Add an entry to the acquired database to filter packets entering ports 1 and 2 if those packets are destined for the specified address.')
acqCreate20 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryForwardPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate20.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate20.setDescription('Add an entry to the acquired database to forward packets entering port1 to port2 and filter packets entering port2 if those packets are destined for the specified address.')
acqCreate01 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryFilterPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate01.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate01.setDescription('Add an entry to the acquired database to filter packets entering port 1 and forward packets entering port 2 to port 1 if those packets are destined for the specified address.')
acqCreate21 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryForwardPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate21.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate21.setDescription('Add an entry to the acquired database to forward packets entering port 1 to port 2 and to forward packets entering port 2 to port 1 if those packets are destined for the specified address.')
acqDelete = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deleteAcquiredEntry", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqDelete.setStatus('mandatory')
if mibBuilder.loadTexts: acqDelete.setDescription('Delete an entry from the acquired database.')
acqDispType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispType.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispType.setDescription('Display the entry type, STATIC or DYNAMIC.')
acqDispOutp1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispOutp1.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispOutp1.setDescription('The outbound port for packets entering port 1.')
acqDispOutp2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispOutp2.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispOutp2.setDescription('The outbound port for packets entering port 2.')
acqSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: acqSrcAddress.setDescription('The source address of this acquired database entry, i.e. the instance.')
permMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: permMaxEntries.setDescription('The maximum number of entries allowed in the permanent database.')
permCurrEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permCurrEntries.setStatus('mandatory')
if mibBuilder.loadTexts: permCurrEntries.setDescription("The number of entries currently recorded in the bridge's permanent database.")
permEraseDatabase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("erasePermanentDatabase", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permEraseDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: permEraseDatabase.setDescription('Erase all entries in the permanent database.')
permCreate00 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryFilterPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate00.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate00.setDescription('Add an entry to the permanent database to filter packets entering ports 1 and 2 if those packets are destined for the specified address.')
permCreate20 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryForwardPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate20.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate20.setDescription('Add an entry to the permanent database to forward packets entering port 1 and filter packets entering port 2 if those packets are destined for the specified address.')
permCreate01 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryFilterPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate01.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate01.setDescription('Add an entry to the permanent database to filter packets entering port 1 and forward packets entering port 2 if those packets are destined for the specified address.')
permCreate21 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryForwardPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate21.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate21.setDescription('Add an entry to the permanent database to forward packets entering ports 1 and 2 if those packets are destined for the specified address.')
permDelete = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deletePermanentEntry", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permDelete.setStatus('mandatory')
if mibBuilder.loadTexts: permDelete.setDescription('Delete an entry from the permanent database.')
permDispType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispType.setStatus('mandatory')
if mibBuilder.loadTexts: permDispType.setDescription('Display the entry type, STATIC or DYNAMIC.')
permDispOutp1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispOutp1.setStatus('mandatory')
if mibBuilder.loadTexts: permDispOutp1.setDescription('The outbound port for packets entering port 1.')
permDispOutp2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispOutp2.setStatus('mandatory')
if mibBuilder.loadTexts: permDispOutp2.setDescription('The outbound port for packets entering port 2.')
permSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: permSrcAddress.setDescription('The source address in this permanent database entry, i.e. the instance.')
specNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: specNumEntries.setDescription('The number of filters in the special database.')
specMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: specMaxEntries.setDescription('The maximum number of filters the special database can contain.')
specNextFilterNum = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specNextFilterNum.setStatus('mandatory')
if mibBuilder.loadTexts: specNextFilterNum.setDescription('The number of the next available filter that can be added to the special database.')
specEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableFilter", 0), ("enableFilter", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specEnable.setStatus('mandatory')
if mibBuilder.loadTexts: specEnable.setDescription('Enable or disable the filter.')
specPort1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specPort1.setStatus('mandatory')
if mibBuilder.loadTexts: specPort1.setDescription('Set port 1 to filter or forward packets.')
specPort2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specPort2.setStatus('mandatory')
if mibBuilder.loadTexts: specPort2.setDescription('Set port 2 to filter or forward packets.')
specDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: specDestAddress.setDescription('Set the special database to filter packets with a specific destination address.')
specSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: specSrcAddress.setDescription('Set the special database to filter packets with a specific source address.')
specType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specType.setStatus('mandatory')
if mibBuilder.loadTexts: specType.setDescription('Set the special database to filter packets with a specific type field.')
specDataField = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDataField.setStatus('mandatory')
if mibBuilder.loadTexts: specDataField.setDescription('Set the special database to filter packets based on the first sixteen bytes of data in the packet.')
specDeleteFilter = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deleteFilter", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDeleteFilter.setStatus('mandatory')
if mibBuilder.loadTexts: specDeleteFilter.setDescription('Delete a filter from the special database.')
lmcommon = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 1))
mAC = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2))
ieee8023 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1))
pcIF = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1))
pcIfRev = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1))
pcDeviceName = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDeviceName.setStatus('mandatory')
if mibBuilder.loadTexts: pcDeviceName.setDescription('Name of the PC device')
pcBoardType = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: pcBoardType.setDescription('An object Identifier that indicates the type of the PC board. This will include MAC type and Media type.')
pcOwnerName = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcOwnerName.setStatus('mandatory')
if mibBuilder.loadTexts: pcOwnerName.setDescription('The owner of this PC.')
pcLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLocation.setStatus('mandatory')
if mibBuilder.loadTexts: pcLocation.setDescription('A text description of the location of this PC.')
pcMMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACAddr.setDescription('The MAC address of the MMAC that this PC is connected to.')
pcMMACBoard = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACBoard.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACBoard.setDescription('The slot number of the board in the MMAC that this PC is connected to.')
pcMMACPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACPort.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACPort.setDescription('The number of the port on the board of the MMAC that this PC is connected to.')
pcApplication = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcApplication.setStatus('mandatory')
if mibBuilder.loadTexts: pcApplication.setDescription('A text description of the network application running on this PC.')
pcDriverRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDriverRev.setStatus('mandatory')
if mibBuilder.loadTexts: pcDriverRev.setDescription('The revision of the LAN card driver.')
pcOnboardMemory = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcOnboardMemory.setStatus('mandatory')
if mibBuilder.loadTexts: pcOnboardMemory.setDescription('The number of Kilobytes of memory (eg. a 16K board would reply 16)')
pcComment = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcComment.setStatus('mandatory')
if mibBuilder.loadTexts: pcComment.setDescription('A user-defined character string.')
pcMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcMACAddr.setDescription('The MAC address of the PC card.')
pcFramesXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcFramesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcFramesXmit.setDescription('The number of MAC frames transmitted by this PC card.')
pcBytesXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBytesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcBytesXmit.setDescription('The number bytes transmitted by this PC card.')
pcMcastXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMcastXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcMcastXmit.setDescription('The number of multicasted frames sent by this PC card.')
pcBcastXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBcastXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcBcastXmit.setDescription('The number of broadcast frames from this PC card.')
pcDeferXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDeferXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcDeferXmit.setDescription('The number of transmit packets that were deferred due to busy media.')
pcSglColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcSglColl.setStatus('mandatory')
if mibBuilder.loadTexts: pcSglColl.setDescription('The number of transmit packet experiencing a single collision.')
pcMultiColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMultiColl.setStatus('mandatory')
if mibBuilder.loadTexts: pcMultiColl.setDescription('The number of transmit packets that have experienced multiple collisions.')
pcTotXmitErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTotXmitErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcTotXmitErrs.setDescription('The total number of transmit errors.')
pcLateColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLateColls.setStatus('mandatory')
if mibBuilder.loadTexts: pcLateColls.setDescription('The number of transmit packets that experienced late collisions.')
pcXcessColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcXcessColls.setStatus('mandatory')
if mibBuilder.loadTexts: pcXcessColls.setDescription('The number of transmit packets aborted due to excess collisions.')
pcCarrErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcCarrErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcCarrErr.setDescription('The number of transmit packets that experience carrier sense errors (ie. lose carrier during transmission).')
pcFramesRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcFramesRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcFramesRec.setDescription('The number of frames received.')
pcBytesRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBytesRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcBytesRec.setDescription('The number of bytes received by this station.')
pcMcastRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMcastRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcMcastRec.setDescription('The number of multicasted frames received.')
pcBcastRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBcastRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcBcastRec.setDescription('The number of broadcast packets received.')
pcTotRecErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTotRecErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcTotRecErrs.setDescription('The total number of receive errors.')
pcTooLong = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: pcTooLong.setDescription('The number of packets received that are too long (over 1518 bytes).')
pcTooShort = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTooShort.setStatus('mandatory')
if mibBuilder.loadTexts: pcTooShort.setDescription('The number of packets that are too short. (under 64 bytes long).')
pcAlignErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcAlignErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcAlignErrs.setDescription('The number of alignment errors in receive packets.')
pcCRCErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcCRCErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcCRCErrs.setDescription('The number of receive packets with CRC errors.')
pcLenErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcLenErrs.setDescription('The number of packets whose length is not equal to the number of bytes received.')
pcIntRecErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcIntRecErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcIntRecErr.setDescription('The number of receive packets that experienced internal errors (eg. no receive buffers).')
pcSqeErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcSqeErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcSqeErr.setDescription('The number of SQE errors.')
mibBuilder.exportSymbols("CTRON-BDG-MIB", acqCreate21=acqCreate21, bdgPortTxAbrt=bdgPortTxAbrt, bdgPortPriority=bdgPortPriority, specEnable=specEnable, permCreate21=permCreate21, specPort1=specPort1, bdgdeviceRootCost=bdgdeviceRootCost, permCreate01=permCreate01, bdgPortState=bdgPortState, acqDispOutp2=acqDispOutp2, bdgdeviceVersion=bdgdeviceVersion, acqEraseDatabase=acqEraseDatabase, specDeleteFilter=specDeleteFilter, ieee8023=ieee8023, pcDeviceName=pcDeviceName, bdgPortDesigRoot=bdgPortDesigRoot, pcIntRecErr=pcIntRecErr, lmcommon=lmcommon, bdgPortAddress=bdgPortAddress, bdgPortTopChgAck=bdgPortTopChgAck, permSrcAddress=permSrcAddress, bdgdeviceFwdDly=bdgdeviceFwdDly, permDB=permDB, pcFramesXmit=pcFramesXmit, pcFramesRec=pcFramesRec, bdgPortFrAlErr=bdgPortFrAlErr, bdgPortColl=bdgPortColl, pcBcastRec=pcBcastRec, acqCreate20=acqCreate20, bdgPortFrFilt=bdgPortFrFilt, permMaxEntries=permMaxEntries, pcBcastXmit=pcBcastXmit, bdgPortDisErr=bdgPortDisErr, bdgPortOowColl=bdgPortOowColl, acqDynAgeTime=acqDynAgeTime, acqStaticAgeTime=acqStaticAgeTime, bdgPortDisTDE=bdgPortDisTDE, pcMultiColl=pcMultiColl, pcTotRecErrs=pcTotRecErrs, specStats=specStats, acqStaticEntries=acqStaticEntries, bdgdeviceNumRestarts=bdgdeviceNumRestarts, acqDelete=acqDelete, mAC=mAC, bdgdeviceTopChgCnt=bdgdeviceTopChgCnt, pcMMACAddr=pcMMACAddr, bdgTables=bdgTables, permCurrEntries=permCurrEntries, pcCRCErrs=pcCRCErrs, bdgdeviceTopChg=bdgdeviceTopChg, bdgdeviceUptime=bdgdeviceUptime, pcIF=pcIF, acqCreate01=acqCreate01, pcDriverRev=pcDriverRev, pcXcessColls=pcXcessColls, bdgPortDesigPort=bdgPortDesigPort, bdgdeviceResetCounts=bdgdeviceResetCounts, bdgdeviceFrFlt=bdgdeviceFrFlt, specFilters=specFilters, bdgdeviceBdgMaxAge=bdgdeviceBdgMaxAge, specType=specType, pcOnboardMemory=pcOnboardMemory, permEraseDatabase=permEraseDatabase, bdgdeviceBdgName=bdgdeviceBdgName, bdgdeviceBridgeID=bdgdeviceBridgeID, bdgdeviceSTAProtocol=bdgdeviceSTAProtocol, acqTotalEntries=acqTotalEntries, permOptions=permOptions, bdgPortOversizePackets=bdgPortOversizePackets, pcCarrErr=pcCarrErr, bdgPortFrRx=bdgPortFrRx, bdgPortDisInb=bdgPortDisInb, bdgdeviceBdgFwdDly=bdgdeviceBdgFwdDly, bdgdeviceTimeTopChg=bdgdeviceTimeTopChg, pcSglColl=pcSglColl, bdgdeviceFrRx=bdgdeviceFrRx, specNumEntries=specNumEntries, bdgdeviceNumPorts=bdgdeviceNumPorts, bdgdeviceTypeFiltering=bdgdeviceTypeFiltering, bdgPortDesigBrdg=bdgPortDesigBrdg, pcMMACPort=pcMMACPort, pcIfRev=pcIfRev, permCreate00=permCreate00, pcMcastXmit=pcMcastXmit, bridgeRev1=bridgeRev1, acqDB=acqDB, permCreate20=permCreate20, pcTotXmitErrs=pcTotXmitErrs, specialDB=specialDB, bdgPortType=bdgPortType, bdgdeviceType=bdgdeviceType, pcOwnerName=pcOwnerName, pcBoardType=pcBoardType, trapTypes=trapTypes, bdgdeviceBdgPriority=bdgdeviceBdgPriority, permDelete=permDelete, bdgdeviceHoldTime=bdgdeviceHoldTime, bdgdeviceSwitchSetting=bdgdeviceSwitchSetting, bdgPortName=bdgPortName, acqDispOutp1=acqDispOutp1, bdgPortNetName=bdgPortNetName, bdgdeviceHelloTime=bdgdeviceHelloTime, bdgdeviceDesigRoot=bdgdeviceDesigRoot, specNextFilterNum=specNextFilterNum, pcApplication=pcApplication, acqSrcAddress=acqSrcAddress, bdgdeviceLocation=bdgdeviceLocation, pcComment=pcComment, filterDB=filterDB, bdgPortDisLOB=bdgPortDisLOB, specDestAddress=specDestAddress, pcSqeErr=pcSqeErr, acqMaxEntries=acqMaxEntries, bdgPortStatus=bdgPortStatus, pcTooLong=pcTooLong, bdgdevice=bdgdevice, bdgPortPathCost=bdgPortPathCost, bdgdeviceFrFwd=bdgdeviceFrFwd, specMaxEntries=specMaxEntries, specSrcAddress=specSrcAddress, pcMACAddr=pcMACAddr, permDispType=permDispType, pcMcastRec=pcMcastRec, bdgdeviceMaxAge=bdgdeviceMaxAge, pcAlignErrs=pcAlignErrs, bdgdeviceRootPort=bdgdeviceRootPort, permDispOutp1=permDispOutp1, bdgPort=bdgPort, bdgdeviceErr=bdgdeviceErr, permDispOutp2=permDispOutp2, bdgPortRuntPackets=bdgPortRuntPackets, pcBytesRec=pcBytesRec, pcLenErrs=pcLenErrs, pcTooShort=pcTooShort, pcDeferXmit=pcDeferXmit, permStats=permStats, acqOptions=acqOptions, bdgdeviceTrapType=bdgdeviceTrapType, bdgdeviceBdgHello=bdgdeviceBdgHello, bdgPortFwdOutb=bdgPortFwdOutb, bdgPortDesigCost=bdgPortDesigCost, pcLocation=pcLocation, acqDispType=acqDispType, specPort2=specPort2, bdgdeviceRestoreSettings=bdgdeviceRestoreSettings, acqCreate00=acqCreate00, pcLateColls=pcLateColls, bdgPortCRCErr=bdgPortCRCErr, acqDynEntries=acqDynEntries, acqStats=acqStats, pcMMACBoard=pcMMACBoard, specDataField=specDataField, bdgdeviceStatus=bdgdeviceStatus, pcBytesXmit=pcBytesXmit, bdgdeviceDisableBdg=bdgdeviceDisableBdg, bdgdeviceRestartBdg=bdgdeviceRestartBdg)

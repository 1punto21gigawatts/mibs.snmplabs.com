#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-TdmaIwfMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-TdmaIwfMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
Gauge32, Unsigned32, StorageType, RowPointer, Counter32, DisplayString, Integer32, RowStatus = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Gauge32", "Unsigned32", "StorageType", "RowPointer", "Counter32", "DisplayString", "Integer32", "RowStatus")
FixedPoint2, Link, AsciiString, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "FixedPoint2", "Link", "AsciiString", "NonReplicated")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, Unsigned32, ObjectIdentity, IpAddress, Bits, Counter32, TimeTicks, MibIdentifier, NotificationType, ModuleIdentity, iso, Counter64, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Unsigned32", "ObjectIdentity", "IpAddress", "Bits", "Counter32", "TimeTicks", "MibIdentifier", "NotificationType", "ModuleIdentity", "iso", "Counter64", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
tdmaIwfMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140))
mscTdmaCs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135))
mscTdmaCsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 1), )
if mibBuilder.loadTexts: mscTdmaCsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCs components.')
mscTdmaCsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"))
if mibBuilder.loadTexts: mscTdmaCsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCs component.')
mscTdmaCsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCs components. These components can be added and deleted.')
mscTdmaCsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsStorageType.setDescription('This variable represents the storage type value for the mscTdmaCs tables.')
mscTdmaCsCsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: mscTdmaCsCsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCsIndex.setDescription('This variable represents the index for the mscTdmaCs tables.')
mscTdmaCsServProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100), )
if mibBuilder.loadTexts: mscTdmaCsServProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsServProvTable.setDescription('This group contains all the necessary timers for call setup and call clearing scenarios on the IWF.')
mscTdmaCsServProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"))
if mibBuilder.loadTexts: mscTdmaCsServProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsServProvEntry.setDescription('An entry in the mscTdmaCsServProvTable.')
mscTdmaCsTIwf1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsTIwf1.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsTIwf1.setDescription('This is an internal timer to the call server of the IWF and is used during call setup for ensuring the MIT protocol stack and the NIT modem for a new call have been allocated and initialized.')
mscTdmaCsTIwf2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsTIwf2.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsTIwf2.setDescription('This is an internal timer to the call server of the IWF and is used during call clearing for ensuring the MIT protocol stack and NIT modem for a call have been deallocated correctly.')
mscTdmaCsT303 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsT303.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsT303.setDescription('This timer is a call setup timer and is used for ensuring a CallProceeding message is received for a Setup message that has been sent by the IWF to the MTX.')
mscTdmaCsT305 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsT305.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsT305.setDescription('This timer is a call clearing timer and is used for ensuring a Release message is received for a Disconnect message the IWF has sent to the MTX.')
mscTdmaCsT308 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsT308.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsT308.setDescription('This timer is a call clearing timer and is used for ensuring a ReleaseComplete message is received for the Release message the IWF has sent to the MTX.')
mscTdmaCsT313 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsT313.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsT313.setDescription('This is a call setup timer and is used for ensuring a ConnectAck message is received in response for the Connect message the IWF has sent to the MTX.')
mscTdmaCsT999 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsT999.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsT999.setDescription('This timer is used during a mobile termination call setup and is used for ensuring the Setup message is received from the MTX.')
mscTdmaCsSupportedTechnology = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("tdmaOnly", 0), ("cdmaOnly", 1), ("tdmaAndCdma", 2))).clone('tdmaOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsSupportedTechnology.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsSupportedTechnology.setDescription('This attribute specifies the wireless technology that is supported for data calls on this IWF.')
mscTdmaCsSupportedService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 100, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("asyncDataOnly", 0), ("g3FaxOnly", 1), ("analogFaxOnly", 2), ("packetOnly", 3), ("asyncDataAndG3Fax", 4), ("asyncDataAndAnalogFax", 5), ("asyncDataAndPacket", 6), ("asyncDataG3FaxAndPacket", 7), ("asyncDataAFaxAndPacket", 8))).clone('asyncDataOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsSupportedService.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsSupportedService.setDescription('This attribute specifies the type(s) of data calls this IWF supports.')
mscTdmaCsMiscProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 101), )
if mibBuilder.loadTexts: mscTdmaCsMiscProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsMiscProvTable.setDescription('This group contains general provisioning data for the TdmaIwfCallServer that does not fit within other provisioning groups.')
mscTdmaCsMiscProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"))
if mibBuilder.loadTexts: mscTdmaCsMiscProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsMiscProvEntry.setDescription('An entry in the mscTdmaCsMiscProvTable.')
mscTdmaCsCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 101, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, this attribute is used to specify the name of the DMS- MTX configured for this TdmaIwfCallServer plus any other commentary information.')
mscTdmaCsMscIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 101, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsMscIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsMscIpAddress.setDescription('This attribute specifies the Internet Protocol (IP) Address of the Mobile Telephone Exchange (MTX) that is permitted to set up MTX InterWorking Function (IWF) data calls using this TdmaIwfCallServer. This address must be specified in order for this TdmaIwfCallServer to provide service. If call setups are attempted from an MSC which does not have this address, those calls are rejected. The callsRequested statistic of this TdmaIwfCallServer is incremented and appropriate call failure logs are generated at the MSC.')
mscTdmaCsVirtualRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 101, 1, 3), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsVirtualRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsVirtualRouterName.setDescription('This attribute specifies the virtual router that this TdmaIwfCallServer uses for transmitting and receiving signaling messages to and from the DMS-MTX.')
mscTdmaCsVoiceLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 101, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aLaw", 0), ("muLaw", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsVoiceLaw.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsVoiceLaw.setDescription('This attribute specifies the voice law to be established for the IWF to PSTN modem link for calls established by this TdmaIwfCallServer. This attribute has one of the following values: aLaw: A protocol for encoding voice-band audio, Pulse Code Modulation (PCM). muLaw: A protocol for encoding voice-band audio, PCM. Note that this value must match the voice law used at the DMS- MTX connected to this TdmaIwfCallServer.')
mscTdmaCsCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 103), )
if mibBuilder.loadTexts: mscTdmaCsCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscTdmaCsCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 103, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"))
if mibBuilder.loadTexts: mscTdmaCsCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCidDataEntry.setDescription('An entry in the mscTdmaCsCidDataTable.')
mscTdmaCsCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 103, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscTdmaCsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 104), )
if mibBuilder.loadTexts: mscTdmaCsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscTdmaCsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 104, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"))
if mibBuilder.loadTexts: mscTdmaCsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsStateEntry.setDescription('An entry in the mscTdmaCsStateTable.')
mscTdmaCsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscTdmaCsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 104, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscTdmaCsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 104, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscTdmaCsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121), )
if mibBuilder.loadTexts: mscTdmaCsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsStatsTable.setDescription('This group contains operational attributes that measure the performance used for the calls set up by this particular TdmaIwfCallServer.')
mscTdmaCsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"))
if mibBuilder.loadTexts: mscTdmaCsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsStatsEntry.setDescription('An entry in the mscTdmaCsStatsTable.')
mscTdmaCsCurrentCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsCurrentCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCurrentCalls.setDescription('This attribute indicates the number of active calls currently serviced by this particular TdmaIwfCallServer.')
mscTdmaCsCallsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsCallsRequested.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCallsRequested.setDescription('This attribute counts the number of IWF call setup requests received at this particular TdmaIwfCallServer from the DMS-MTX. The counter wraps when it exceeds the maximum value.')
mscTdmaCsCallsSetUp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsCallsSetUp.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCallsSetUp.setDescription('This attribute counts the number of IWF calls successfully setup by this particular TdmaIwfCallServer. A call is considered setup when the IWF-Setup-Request message is received, indicating a request for a data communications service, and the IWF has successfully allocated the necessary resources to fulfill the request. The counter wraps when it exceeds the maximum value.')
mscTdmaCsCallsReleasedNormal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsCallsReleasedNormal.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCallsReleasedNormal.setDescription('This attribute counts the number of IWF calls that have completed successfully on this particular TdmaIwfCallServer. The counter wraps when it exceeds the maximum value.')
mscTdmaCsCallsReleasedAbnormal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsCallsReleasedAbnormal.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsCallsReleasedAbnormal.setDescription('This attribute counts the number of IWF calls that have been released due to error conditions at this particular TdmaIwfCallServer or one if its TdmaIwfBearerChannel(s). The counter wraps when it exceeds the maximum value.')
mscTdmaCsErroredLFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 121, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsErroredLFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsErroredLFrames.setDescription('This attribute counts the number of CM/IWF Control Interface (CCI) messages received from the DMS-MTX that have an incorrect format. The counter wraps when it exceeds the maximum value.')
mscTdmaCsModem = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2))
mscTdmaCsModemRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2, 1), )
if mibBuilder.loadTexts: mscTdmaCsModemRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsModemRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsModem components.')
mscTdmaCsModemRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsModemIndex"))
if mibBuilder.loadTexts: mscTdmaCsModemRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsModemRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsModem component.')
mscTdmaCsModemRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsModemRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsModemRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsModem components. These components cannot be added nor deleted.')
mscTdmaCsModemComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsModemComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsModemComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsModemStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsModemStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsModemStorageType.setDescription('This variable represents the storage type value for the mscTdmaCsModem tables.')
mscTdmaCsModemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaCsModemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsModemIndex.setDescription('This variable represents the index for the mscTdmaCsModem tables.')
mscTdmaCsFax = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3))
mscTdmaCsFaxRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3, 1), )
if mibBuilder.loadTexts: mscTdmaCsFaxRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsFaxRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsFax components.')
mscTdmaCsFaxRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsFaxIndex"))
if mibBuilder.loadTexts: mscTdmaCsFaxRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsFaxRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsFax component.')
mscTdmaCsFaxRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsFaxRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsFaxRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsFax components. These components cannot be added nor deleted.')
mscTdmaCsFaxComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsFaxComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsFaxComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsFaxStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsFaxStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsFaxStorageType.setDescription('This variable represents the storage type value for the mscTdmaCsFax tables.')
mscTdmaCsFaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaCsFaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsFaxIndex.setDescription('This variable represents the index for the mscTdmaCsFax tables.')
mscTdmaCsDce = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4))
mscTdmaCsDceRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4, 1), )
if mibBuilder.loadTexts: mscTdmaCsDceRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDceRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsDce components.')
mscTdmaCsDceRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsDceIndex"))
if mibBuilder.loadTexts: mscTdmaCsDceRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDceRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsDce component.')
mscTdmaCsDceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsDceRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDceRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsDce components. These components cannot be added nor deleted.')
mscTdmaCsDceComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsDceComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDceComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsDceStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsDceStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDceStorageType.setDescription('This variable represents the storage type value for the mscTdmaCsDce tables.')
mscTdmaCsDceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaCsDceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDceIndex.setDescription('This variable represents the index for the mscTdmaCsDce tables.')
mscTdmaCsDsc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5))
mscTdmaCsDscRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 1), )
if mibBuilder.loadTexts: mscTdmaCsDscRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsDsc components.')
mscTdmaCsDscRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsDscIndex"))
if mibBuilder.loadTexts: mscTdmaCsDscRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsDsc component.')
mscTdmaCsDscRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsDscRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsDsc components. These components cannot be added nor deleted.')
mscTdmaCsDscComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsDscComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsDscStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsDscStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscStorageType.setDescription('This variable represents the storage type value for the mscTdmaCsDsc tables.')
mscTdmaCsDscIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaCsDscIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscIndex.setDescription('This variable represents the index for the mscTdmaCsDsc tables.')
mscTdmaCsDscProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10), )
if mibBuilder.loadTexts: mscTdmaCsDscProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscProvTable.setDescription('This group contains the provisionable attributes for Data Service Control Asynchronous Data Service portion of the wireless protocol stack used for the calls set up by this particular TdmaIwfCallServer.')
mscTdmaCsDscProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsDscIndex"))
if mibBuilder.loadTexts: mscTdmaCsDscProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscProvEntry.setDescription('An entry in the mscTdmaCsDscProvTable.')
mscTdmaCsDscLl0BufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(80, 65535)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscLl0BufferSize.setStatus('obsolete')
if mibBuilder.loadTexts: mscTdmaCsDscLl0BufferSize.setDescription('This attribute specifies the maximum size of the DSC logical link 0 control buffer. Changes impact the amount of memory used (more memory is used when increasing the attribute). The gain in performance obtained from the selection of a larger buffer size may be offset by less memory being available. The customer might wish to increase the buffer size when a degradation in throughput of the system is seen.')
mscTdmaCsDscLl1BufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(160, 65535)).clone(160)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscLl1BufferSize.setStatus('obsolete')
if mibBuilder.loadTexts: mscTdmaCsDscLl1BufferSize.setDescription('This attribute specifies the maximum size of the DSC logical link 1 data buffer. Changes impact the amount of memory used (more memory is used when increasing the attribute). The gain in performance obtained from the selection of a larger buffer size may be offset by less memory being available. The customer might wish to increase the buffer size when a degradation in throughput of the system is seen.')
mscTdmaCsDscK0Ll0WindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscK0Ll0WindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscK0Ll0WindowSize.setDescription('This attribute specifies the maximum size of the DSC logical link 0 window.')
mscTdmaCsDscK1Ll1WindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscK1Ll1WindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsDscK1Ll1WindowSize.setDescription('This attribute specifies the maximum size of the DSC logical link 1 window.')
mscTdmaCsDscP0CompressionDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noCompression", 0), ("compInitrResp", 1), ("compRespInitr", 2), ("compBoth", 3))).clone('noCompression')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscP0CompressionDirection.setStatus('obsolete')
if mibBuilder.loadTexts: mscTdmaCsDscP0CompressionDirection.setDescription('This attribute specifies the compression configuration for DSC. This attribute has one of the following values: noCompression: No compression. compInitrResp: Compression initiator to responder. compRespInitr: Compression responder to initiator. compBoth: Compression both directions.')
mscTdmaCsDscP1CompressionMaximumCodewords = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(512, 4096)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscP1CompressionMaximumCodewords.setStatus('obsolete')
if mibBuilder.loadTexts: mscTdmaCsDscP1CompressionMaximumCodewords.setDescription('This attribute specifies the maximum number of codewords to be used for compression. A codeword is a binary number that represents a string of characters. Changes to this attribute impact the amount of memory used (more memory is used when increasing the attribute). The gain in performance obtained from the selection of a larger dictionary may be offset by the larger codeword size needed, and for certain types of data, better performance may be obtained by using a smaller dictionary. Changes to this attribute do not affect existing calls.')
mscTdmaCsDscP2CompressionMaximumCharacters = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 150)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsDscP2CompressionMaximumCharacters.setStatus('obsolete')
if mibBuilder.loadTexts: mscTdmaCsDscP2CompressionMaximumCharacters.setDescription('This attribute specifies the maximum number of characters that can be represented by a single codeword to be used for compression from logical link 0.')
mscTdmaCsRlp1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6))
mscTdmaCsRlp1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 1), )
if mibBuilder.loadTexts: mscTdmaCsRlp1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1RowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsRlp1 components.')
mscTdmaCsRlp1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsRlp1Index"))
if mibBuilder.loadTexts: mscTdmaCsRlp1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1RowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsRlp1 component.')
mscTdmaCsRlp1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsRlp1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsRlp1 components. These components can be added.')
mscTdmaCsRlp1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsRlp1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsRlp1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsRlp1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1StorageType.setDescription('This variable represents the storage type value for the mscTdmaCsRlp1 tables.')
mscTdmaCsRlp1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("halfRate", 0), ("fullRate", 1), ("doubleRate", 2), ("tripleRate", 3))))
if mibBuilder.loadTexts: mscTdmaCsRlp1Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1Index.setDescription('This variable represents the index for the mscTdmaCsRlp1 tables.')
mscTdmaCsRlp1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 10), )
if mibBuilder.loadTexts: mscTdmaCsRlp1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1ProvTable.setDescription('This group contains provisionable attributes for the Radio Link Protocol 1 (RLP1) parameters used for the calls set up by this particular TdmaIwfCallServer. Changes to these attributes do not affect existing calls.')
mscTdmaCsRlp1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsRlp1Index"))
if mibBuilder.loadTexts: mscTdmaCsRlp1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1ProvEntry.setDescription('An entry in the mscTdmaCsRlp1ProvTable.')
mscTdmaCsRlp1T1ResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 20)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsRlp1T1ResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1T1ResponseTimer.setDescription('This attribute specifies the time the receiving Radio Link Protocol (RLP1) entity shall wait for a response from the peer TIA-136-310 (formerly IS-130) application. During the Exchange Information (XID) negotiation, both RLP1 entities (mobile station and IWF) can agree to use a specific value for this timer (T1). The IWF attempts to negotiate to the value specified by this attribute. Changes to this attribute do not affect existing calls.')
mscTdmaCsRlp1T2LinkActivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 120)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsRlp1T2LinkActivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1T2LinkActivityTimer.setDescription('This attribute specifies the maximum time the receiving Radio Link Protocol (RLP1) entity shall wait for link activity. During the Exchange Information (XID) negotiation, both RLP1 entities (mobile station and IWF) can agree to use a specific value for this timer (T2). The IWF attempts to negotiate to the value specified by this attribute. Changes to this attribute do not affect existing calls.')
mscTdmaCsRlp1T3PeerAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 20)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsRlp1T3PeerAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsRlp1T3PeerAckTimer.setDescription('This attribute specifies the maximum time the receiving Radio Link Protocol (RLP1) entity shall wait for the peer to ACK or NAK data. During the Exchange Information (XID) negotiation, both RLP1 entities (mobile station and IWF) can agree to use a specific value for this timer (T3). The IWF attempts to negotiate to the value specified by this attribute. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7))
mscTdmaCsV42RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 1), )
if mibBuilder.loadTexts: mscTdmaCsV42RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42RowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsV42 components.')
mscTdmaCsV42RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsV42Index"))
if mibBuilder.loadTexts: mscTdmaCsV42RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42RowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsV42 component.')
mscTdmaCsV42RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsV42RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsV42 components. These components cannot be added nor deleted.')
mscTdmaCsV42ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsV42ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsV42StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsV42StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42StorageType.setDescription('This variable represents the storage type value for the mscTdmaCsV42 tables.')
mscTdmaCsV42Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaCsV42Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42Index.setDescription('This variable represents the index for the mscTdmaCsV42 tables.')
mscTdmaCsV42ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10), )
if mibBuilder.loadTexts: mscTdmaCsV42ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42ProvTable.setDescription('This group contains the provisionable attributes for the V.42 protocol used for the calls set up by this particular IwfCallServer. Changes to these attributes do not affect existing calls.')
mscTdmaCsV42ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsV42Index"))
if mibBuilder.loadTexts: mscTdmaCsV42ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42ProvEntry.setDescription('An entry in the mscTdmaCsV42ProvTable.')
mscTdmaCsV42T400DetectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 1), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(75, 254)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42T400DetectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42T400DetectTimer.setDescription('This attribute specifies the maximum amount of time that the IWF waits for an Originator Detection Pattern (ODP) or Answerer Detection Pattern (ADP). ODP/ADP is a series of special bit patterns used during the call setup procedures. If the IWF is the originator of the call, it starts sending ODP patterns and waits for an ADP for the duration of T400 from the answerer at call setup time. If the IWF is the answerer of the call, it waits for an ODP for T400 seconds from the originator and if it receives during that time it sends an ADP pattern to the originator at the call setup time. Since both sides operate with different values of T400 timer, a higher value increases the chance of a successful call setup. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42T401AckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 2), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(50, 900)).clone(400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42T401AckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42T401AckTimer.setDescription('This attribute specifies the maximum amount of time that the IWF waits for an acknowledgment before retransmitting a frame. Since information about the T401 timer is not carried in the Exchange Identification (XID) negotiations at call setup time, both sides operate with different timer values. The value for T401 depends on many factors, such as propagation delay or frame processing time. A frame is retransmitted up to N400 times if the timer T401 expires before an acknowledgment for a frame is actually received. The performance of the data link layer can be impacted by the value of this timer as retransmissions of frames occur on expiry of timer T401. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42T402AckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 3), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(25, 450)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42T402AckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42T402AckDelayTimer.setDescription('This attribute specifies the maximum amount of time that the IWF may wait following the receipt of any frame requiring a reply before it initiates transmission of an appropriate reply in order to ensure that the reply frame is received by the remote error-correcting entity prior to expiration of the T401 timer of the remote error-correcting entity. Since information about the T402 timer is not carried in the Exchange Identification (XID) negotiations at call setup, both sides operate with different timer values. If this timer expires, then the reply that would have been returned prior to its expiration is not sent. The performance of the data link layer can be impacted by the value of this timer as retransmissions of frames occur on expiry of timer T401. For better performance, a value of t402AckDelayTimer (T402) equal to half the value of t401AckTimer (T401) is recommended. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42T403IdleProbeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 90)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42T403IdleProbeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42T403IdleProbeTimer.setDescription('This attribute specifies the maximum amount of time that the IWF allows to elapse without frames being exchanged. The link is permitted to remain idle with no frames being exchanged on the data link. Upon expiry of this timer, the IWF polls its peer for status. Since information about the T403 timer is not carried in the Exchange Identification (XID) negotiations at call setup time, both sides operate with different timer values. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42TxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42TxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42TxN401FrameSize.setDescription('This attribute specifies the maximum number of octets that can be carried in the information field of an Information (I) frame, Exchange Identification (XID) frame, and a Unnumbered Information (UI) frame from the IWF to the remote entity. The default value is 128 octets, and no XID negotiations required for txN401FrameSize. If the value for txN401FrameSize value is set to other than 128 octets, then XID frames are exchanged to negotiate a value. The value provided for txN401FrameSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 128 is specified, then the IWF negotiates or attempts to negotiate a value between the 128 (as a minimum) and the given value (as a maximum). If a value less than 128 is specified, then the IWF attempts to negotiate a value between the given value (as a minimum) and 128 (as a maximum). Any value can be specified as long as it is within the provisionable limits. However, a value equal to or close to 128 is recommended. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42RxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42RxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42RxN401FrameSize.setDescription('This attribute specifies the maximum number of octets that can be carried in the information field of an Information (I) frame, Exchange Identification (XID) frame, and a Unnumbered Information (UI) frame from the remote entity to the IWF. The default value is 128 octets, and no XID negotiations are required for rxN401FrameSize. If the value set for rxN401FrameSize is other than 128, XID frames are exchanged to negotiate a value. The value provided for rxN401FrameSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 128 is specified, then the IWF attempts to negotiate for a value between 128 (as a minimum) and the given value (as a maximum). If a value less than 128 value is specified, then the IWF attempts to negotiate for a value between the given value (as a minimum) and 128 (as a maximum). Any value can be specified as long as it is within the provisionable limits. However, a value equal to or close to the default is recommended. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42TxKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42TxKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42TxKWindowSize.setDescription('This attribute specifies the maximum number of outstanding unacknowledged sequenced Information (I) frames from the IWF to the remote entity. The default value is 15 frames, and if this value is used then no Exchange Identification (XID) negotiations are required for txKWindowSize. If the value set for txKWindowSize is other than 15, then XID frames are exchanged to negotiate a value. The value provided for txKWindowSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 15 is specified, then the IWF attempts to negotiate a value between 15 (as a minimum) and the given value (as a maximum). If a value less than 15 is specified, then the IWF attempts to negotiate for a value between the given value (as a minimum) and 15 (as a maximum). Any value can be specified as long at it is within the provisionable limits. However, a value equal to or close to the default is recommended. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42RxKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42RxKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42RxKWindowSize.setDescription('This attribute specifies the maximum number of outstanding unacknowledged sequenced Information (I) frames from the remote entity to the IWF. The default value is 15 frames, and if this value is used then no Exchange Identification (XID) negotiations are required for rxKWindowSize. If the value set for rxKWindowSize is other than 15, then XID frames are exchanged to negotiate a value. The value provided for rxKWindowSize sets up the bounds during XID negotiations. The IWF performs XID negotiations with this value as a minimum or maximum value. If a value greater than 15 is specified, then the IWF attempts to negotiate a value between 15 (as a minimum) and the given value (as a maximum). If a value less than 15 is specified, then the IWF attempts to negotiate for a value between the given value (as a minimum) and 15 (as a maximum). Any value can be specified as long as it is within the provisionable limits. However, a value equal to or close to the default is recommended. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42N400RetransLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42N400RetransLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42N400RetransLimit.setDescription('This attribute specifies the maximum number of times the IWF retransmits a frame upon expiry of t401AckTimer before appropriate recovery action is taken. Information about N400 (Retransmission Limit) is not carried in the Exchange Identification (XID) negotiation at call setup time so both sides operate with different N400 values. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42FcsLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 7, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fcs16", 0), ("fcs32Or16", 1), ("fcs32", 2))).clone('fcs32Or16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42FcsLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42FcsLength.setDescription('This attribute specifies whether a 16 bit or a 32 bit Frame Check Sequence (FCS) will be used for the link between the IWF and the far end DCE. This attribute has one of the following values: fcs16: Use only a 16 bit FCS. fcs32Or16: 32 bit FCS is preferred; Use a 16 bit FCS if needed. fcs32Only: Use only a 32 it FCS; If unavailable, drop the connection.')
mscTdmaCsV42Bis = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8))
mscTdmaCsV42BisRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 1), )
if mibBuilder.loadTexts: mscTdmaCsV42BisRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsV42Bis components.')
mscTdmaCsV42BisRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsV42BisIndex"))
if mibBuilder.loadTexts: mscTdmaCsV42BisRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsV42Bis component.')
mscTdmaCsV42BisRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsV42BisRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsV42Bis components. These components cannot be added nor deleted.')
mscTdmaCsV42BisComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsV42BisComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsV42BisStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsV42BisStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisStorageType.setDescription('This variable represents the storage type value for the mscTdmaCsV42Bis tables.')
mscTdmaCsV42BisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaCsV42BisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisIndex.setDescription('This variable represents the index for the mscTdmaCsV42Bis tables.')
mscTdmaCsV42BisProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 10), )
if mibBuilder.loadTexts: mscTdmaCsV42BisProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisProvTable.setDescription('This group contains the provisionable attributes for the V.42bis data compression protocol parameters used for the calls set up by this particular CallServer. Changes to these attributes do not affect existing calls.')
mscTdmaCsV42BisProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsV42BisIndex"))
if mibBuilder.loadTexts: mscTdmaCsV42BisProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisProvEntry.setDescription('An entry in the mscTdmaCsV42BisProvTable.')
mscTdmaCsV42BisP0CompressionDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noCompression", 0), ("compInitrResp", 1), ("compRespInitr", 2), ("compBoth", 3))).clone('compBoth')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42BisP0CompressionDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisP0CompressionDirection.setDescription('This attribute specifies the V.42bis data compression direction to be supported. The value for compression direction is negotiated at link setup by the data link protocol by way of the Exchange Identification (XID) negotiation of parameter P0 (compression direction). During XID negotiation of parameter P0, both sides (IWF and mobile or IWF and PSTN) agree on the compression direction. This attribute has one of the following values: noCompression: No compression is present. compInitrResp: The data sent by the IWF to the other entity is compressed. compRespInitr: The data received by the IWF from the other entity is compressed. compBoth: The data sent and received by the IWF is compressed. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42BisP1MaximumCodewords = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(512, 4096)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42BisP1MaximumCodewords.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisP1MaximumCodewords.setDescription('This attribute specifies the maximum number of V.42bis codewords the IWF supports. A codeword is a binary number that represents a string of characters in compressed form. V.42bis keeps a dictionary of codewords for each compression direction. Changes to this attribute impact the compression ratio for the encoder (component TdmaBc V42Bis attribute compRatioEncoder). Changes also impact the amount of memory used (more memory is used when increasing the attribute). The gain in performance obtained from the selection of a larger dictionary may be offset by the larger codeword size needed, and for certain types of data, better performance may be obtained by using a smaller dictionary. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42BisP2MaximumStringSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 250)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42BisP2MaximumStringSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisP2MaximumStringSize.setDescription('This attribute specifies the maximum number of characters allowed in a string represented by a codeword that the IWF supports. Each codeword in a V.42bis dictionary represents a string of characters. Changes to this attribute impact the compression ratio for the encoder. Changes to this attribute do not affect existing calls.')
mscTdmaCsV42BisActionOnError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("resetLink", 0), ("takeDownCall", 1))).clone('resetLink')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsV42BisActionOnError.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsV42BisActionOnError.setDescription('This attribute specifies whether or not V.42bis takes down the call or resets the link when any of the following errors occur: 1.Receipt of STEPUP (step up codeword size) codeword when it would cause C2 (current code word size) to exceed N1 (maximum code word size). 2. Receipt of a codeword, at any time, equal to C1 (next empty dictionary entry). 3. Receipt of a codeword representing an empty dictionary entry. 4. Receipt of a reserved command code. 5. Receipt of any other error. If the value is resetLink, the error corrected connection and V.42bis dictionaries are reset. Some data is lost but the call continues. If the value is takeDownCall, the call is taken down. Changes to this attribute do not affect existing calls.')
mscTdmaCsLp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9))
mscTdmaCsLpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 1), )
if mibBuilder.loadTexts: mscTdmaCsLpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaCsLp components.')
mscTdmaCsLpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsLpIndex"))
if mibBuilder.loadTexts: mscTdmaCsLpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaCsLp component.')
mscTdmaCsLpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaCsLpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaCsLp components. These components can be added and deleted.')
mscTdmaCsLpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsLpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaCsLpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsLpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpStorageType.setDescription('This variable represents the storage type value for the mscTdmaCsLp tables.')
mscTdmaCsLpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscTdmaCsLpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpIndex.setDescription('This variable represents the index for the mscTdmaCsLp tables.')
mscTdmaCsLpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 10), )
if mibBuilder.loadTexts: mscTdmaCsLpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpOperTable.setDescription('This group contains operational attributes pertaining to information about TdmaIwfBearerChannels and TdmaIwfLogicalProcessor associated with a TdmaIwfCallServer from a high-level view.')
mscTdmaCsLpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaCsLpIndex"))
if mibBuilder.loadTexts: mscTdmaCsLpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpOperEntry.setDescription('An entry in the mscTdmaCsLpOperTable.')
mscTdmaCsLpConfiguredBearerChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 124))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsLpConfiguredBearerChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpConfiguredBearerChannels.setDescription('This attribute indicates the number of TdmaIwfBearerChannel components provisioned for the TdmaIwfLogicalProcessor represented by this component.')
mscTdmaCsLpActiveCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 124))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsLpActiveCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpActiveCalls.setDescription('This attribute indicates the number of calls currently active on this LogicalProcessor.')
mscTdmaCsLpModemsSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 135, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaCsLpModemsSupported.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaCsLpModemsSupported.setDescription('This attribute indicates if modems are supported with this TdmaIwfLogicalProcessor. This attribute has one of the following values: yes: Modems are supported with this TdmaIwfLogicalProcessor. no: Modems are not supported with this TdmaIwfLogicalProcessor.')
mscTdmaBc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136))
mscTdmaBcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1), )
if mibBuilder.loadTexts: mscTdmaBcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBc components.')
mscTdmaBcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"))
if mibBuilder.loadTexts: mscTdmaBcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBc component.')
mscTdmaBcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaBcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBc components. These components can be added and deleted.')
mscTdmaBcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcStorageType.setDescription('This variable represents the storage type value for the mscTdmaBc tables.')
mscTdmaBcCsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: mscTdmaBcCsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcCsIndex.setDescription('This variable represents an index for the mscTdmaBc tables.')
mscTdmaBcBcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: mscTdmaBcBcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcBcIndex.setDescription('This variable represents an index for the mscTdmaBc tables.')
mscTdmaBcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 101), )
if mibBuilder.loadTexts: mscTdmaBcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcOperTable.setDescription('This group contains operational attributes concerning the operation of this particular TdmaIwfBearerChannel for the current or most recent call.')
mscTdmaBcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"))
if mibBuilder.loadTexts: mscTdmaBcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcOperEntry.setDescription('An entry in the mscTdmaBcOperTable.')
mscTdmaBcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 101, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("idle", 0), ("setup", 1), ("active", 2), ("release", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcState.setDescription('This attribute indicates the current state of the MSC/IWF Interface Protocol (MIP) Message Router (MMR) for an IWF element. This attribute has one of the following values: idle: Startup state of IWF element. setup: This call half is being set up. active: This call half has been connected by both the MTX and IWF and is active. release: This call half is being released.')
mscTdmaBcCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 101, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("analogSpeech", 0), ("digitalSpeech", 1), ("analogPrefSpeech", 2), ("digitalPrefSpeech", 3), ("asyncData", 4), ("g3Fax", 5), ("rejected", 6), ("stuIII", 7), ("notUsedYet", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcCallType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcCallType.setDescription('This attribute indicates the current call type. This attribute has one of the following values: analogSpeech: Analog speech calls. digitalSpeech: Digital speech calls. analogPrefSpeech: Analog preferred speech calls. digitalPrefSpeech: Digital preferred speech calls. asyncData: Asynchronous data service calls. g3Fax: Group 3 fax calls. rejected: Rejected calls. stuIII: STU III calls. notUsedYet: Bearer Channel has not been used in a call yet.')
mscTdmaBcLastResponseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 101, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 16, 17, 18, 19, 28, 31, 41, 44, 47, 49, 63, 79, 81, 82, 95, 96, 97, 98, 102, 111))).clone(namedValues=NamedValues(("noCause", 0), ("unassignedNumber", 1), ("noRouteToDest", 3), ("normalClearing", 16), ("userBusy", 17), ("noResponse", 18), ("userNoAnswer", 19), ("invalidNumberFormat", 28), ("unspecNormal", 31), ("temporaryFailure", 41), ("channelUnavailable", 44), ("resourceUnavailable", 47), ("qosUnavailable", 49), ("serviceUnavailable", 63), ("unimplementedOption", 79), ("invalidCallRefValue", 81), ("invalidChannel", 82), ("unspecInvalidMessage", 95), ("missingMandatoryIe", 96), ("invalidMessageType", 97), ("incompatibleMessage", 98), ("timerRecovery", 102), ("unspecProtocolError", 111)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcLastResponseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcLastResponseCode.setDescription('This attribute indicates the MSC/IWF Interface Protocol (MIP) Message Router (MMR) response code returned for the last call which was active on this particular TdmaIwfBearerChannel. This attribute has one of the following values: noCause: No cause available. unassignedNumber: Unallocated or unassigned number. noRouteToDest: No route to destination. normalClearing: The call was terminated normally. userBusy: User busy. noResponse: No carrier. userNoAnswer: No answer from user. invalidNumberFormat: Translation or routing problem. unspecNormal: Normal, unspecified. temporaryFailure: Temporary failure. channelUnavailable: Channel unavailable. resourceUnavailable: Resources unavailable to handle call. qosUnavailabled: Specified rate of call unavailable. serviceUnavailable: Service not implemented. unimplementedOption: Option not implemented. invalidCallRefValue: Invalid call reference value. invalidChannel: Identified channel does not exist. unspecInvalidMessage: Invalid message, unspecified. missingMandatoryIe: Missing mandatory information element. invalidMessageType: Message type not implemented. incompatibleMessage: Message not compatible with call state. timerRecovery: Recovery on timer expiration. protocolError: Protocol error, unspecified.')
mscTdmaBcMateBearerChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 101, 1, 4), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcMateBearerChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcMateBearerChannel.setDescription('This attribute contains the name of the mate TdmaIwfBearerChannel that this TdmaIwfBearerChannel is involved with in the currently active call.')
mscTdmaBcCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 103), )
if mibBuilder.loadTexts: mscTdmaBcCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscTdmaBcCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 103, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"))
if mibBuilder.loadTexts: mscTdmaBcCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcCidDataEntry.setDescription('An entry in the mscTdmaBcCidDataTable.')
mscTdmaBcCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 103, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaBcCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscTdmaBcStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 104), )
if mibBuilder.loadTexts: mscTdmaBcStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscTdmaBcStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 104, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"))
if mibBuilder.loadTexts: mscTdmaBcStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcStateEntry.setDescription('An entry in the mscTdmaBcStateTable.')
mscTdmaBcAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscTdmaBcOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 104, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscTdmaBcUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 104, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscTdmaBcFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2))
mscTdmaBcFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 1), )
if mibBuilder.loadTexts: mscTdmaBcFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcFramer components.')
mscTdmaBcFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFramerIndex"))
if mibBuilder.loadTexts: mscTdmaBcFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcFramer component.')
mscTdmaBcFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcFramer components. These components cannot be added nor deleted.')
mscTdmaBcFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcFramer tables.')
mscTdmaBcFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerIndex.setDescription('This variable represents the index for the mscTdmaBcFramer tables.')
mscTdmaBcFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 10), )
if mibBuilder.loadTexts: mscTdmaBcFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscTdmaBcFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFramerIndex"))
if mibBuilder.loadTexts: mscTdmaBcFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerProvEntry.setDescription('An entry in the mscTdmaBcFramerProvTable.')
mscTdmaBcFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaBcFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscTdmaBcFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 11), )
if mibBuilder.loadTexts: mscTdmaBcFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerStatsTable.setDescription('This group contains the operational statistics data for a TdmaIwfFramer component.')
mscTdmaBcFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFramerIndex"))
if mibBuilder.loadTexts: mscTdmaBcFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerStatsEntry.setDescription('An entry in the mscTdmaBcFramerStatsTable.')
mscTdmaBcFramerTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerTxFrames.setDescription('This attribute counts the number of frames transmitted to the link interface by TdmaIwfFramer. The counter wraps when it exceeds the maximum value.')
mscTdmaBcFramerRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerRxFrames.setDescription('This attribute counts the number of frames received from the link interface by TdmaIwfFramer. The counter wraps when it exceeds the maximum value.')
mscTdmaBcFramerRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerRxBytes.setDescription('This attribute counts the number of bytes received from the link interface by TdmaIwfFramer. The counter wraps when it exceeds the maximum value.')
mscTdmaBcFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 12), )
if mibBuilder.loadTexts: mscTdmaBcFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerLinkTable.setDescription('This group contains provisionable attributes for the TdmaIwfFramer which controls link layer framing for application components sending and receiving data on a link interface for this particular TdmaIwfBearerChannel.')
mscTdmaBcFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFramerIndex"))
if mibBuilder.loadTexts: mscTdmaBcFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerLinkEntry.setDescription('An entry in the mscTdmaBcFramerLinkTable.')
mscTdmaBcFramerFramingType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 8))).clone(namedValues=NamedValues(("btdsFraming", 2), ("mtxFraming", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTdmaBcFramerFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerFramingType.setDescription('This attribute indicates the type of framing for the link layer data received and transmitted on this channel. This attribute has one of the following values: btdsFraming: Bit transparent framing for the TdmaIwfBearerChannel components on MVP cards. mtxFraming: DMS-MTX InterSystem Link Protocol (ISLP) framing required for the TdmaIwfBearerChannel components on DS1C/E1C cards.')
mscTdmaBcFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 13), )
if mibBuilder.loadTexts: mscTdmaBcFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscTdmaBcFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFramerIndex"))
if mibBuilder.loadTexts: mscTdmaBcFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerStateEntry.setDescription('An entry in the mscTdmaBcFramerStateTable.')
mscTdmaBcFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscTdmaBcFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscTdmaBcFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscTdmaBcModem = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3))
mscTdmaBcModemRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 1), )
if mibBuilder.loadTexts: mscTdmaBcModemRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcModem components.')
mscTdmaBcModemRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcModemIndex"))
if mibBuilder.loadTexts: mscTdmaBcModemRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcModem component.')
mscTdmaBcModemRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcModem components. These components cannot be added nor deleted.')
mscTdmaBcModemComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcModemStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcModem tables.')
mscTdmaBcModemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcModemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemIndex.setDescription('This variable represents the index for the mscTdmaBcModem tables.')
mscTdmaBcModemOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10), )
if mibBuilder.loadTexts: mscTdmaBcModemOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemOperTable.setDescription('This group contains operational attributes that measure performance of the modem component for this particular TdmaIwfBearerChannel.')
mscTdmaBcModemOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcModemIndex"))
if mibBuilder.loadTexts: mscTdmaBcModemOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemOperEntry.setDescription('An entry in the mscTdmaBcModemOperTable.')
mscTdmaBcModemVoiceLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aLaw", 0), ("muLaw", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemVoiceLaw.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemVoiceLaw.setDescription("This attribute indicates the active voice law associated with the modem component. This attribute has one of the following values: aLaw and muLaw. Both protocols are utilized for encoding voice- band audio. For additional information on each, refer to ITU-T G.711 'Pulse Code Modulation (PCM) of Voice Frequencies'.")
mscTdmaBcModemRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("n50", 0), ("n300", 1), ("n600", 2), ("n1200", 3), ("n2400", 4), ("n4800", 5), ("n7200", 6), ("n9600", 7), ("n12000", 8), ("n14400", 9), ("n16800", 10), ("n19200", 11), ("n21600", 12), ("n24000", 13), ("n26400", 14), ("n28800", 15), ("n31200", 16), ("n32000", 17), ("n33600", 18), ("n38400", 19), ("n43200", 20), ("n48000", 21), ("n56000", 22), ("n57600", 23), ("n64000", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemRate.setDescription('This attribute indicates the transmission rate of the current modem in use. All rates are the same in both the transmit and receive directions.')
mscTdmaBcModemModemAlgorithmInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemModemAlgorithmInUse.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemModemAlgorithmInUse.setDescription('This attribute indicates the current modem algorithm(s) active for the channel. This attribute has one of the following values: t30: T.30 is active. T.30 is the Group 3 fax protocol. v17: V.17 is active.V.17 is an ITU-T 14400bit/s modem standard. v21: V.21 is active. V.21 is an ITU-4 300bit/s modem standard. v22: V.22 ia active. V.22 is an ITU-T modem standard that operates at 1200bit/s and 600 baud. v22bis: V.22bis is active. V.22bis is an ITU-T modem standard that operates at 2400bit/s and 600 baud. v27ter: V.27ter is active. V.27ter is an ITU-T 7200bit/s modem standard. v29: V.29 is active. V.29 is an ITU-T 9600bit/s modem standard. v32: V.32 is active. V.32 is an ITU-T modem standard that operates at 9600bit/s and 2400 baud. v32bis: V.32bis is an ITU-T modem standard that operates at a speed of 14.4kbit/s. Description of bits: t30(0) v17(1) v21(2) v22(3) v22bis(4) v27ter(5) v29(6) v32(7) v32bis(8)')
mscTdmaBcModemProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("idle", 0), ("training", 1), ("connected", 2), ("releasing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemProtocolState.setDescription('This attribute indicates the active protocol state of the modem in use.This attribute has one of the following values: idle: Modem is in an inactive state and has no current connection established. training: Modem is attempting to establish a connection with the far end modem via handshaking. connected: Modem has establish a connection with the far end modem. releasing: Modem has begun tearing down the connection.')
mscTdmaBcModemMobileSideFlowControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemMobileSideFlowControlState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemMobileSideFlowControlState.setDescription('This attribute indicates the state of flow control based on whether flow control was requested by the mobile side of the connection and an indication was sent to an upper layer protocol. This attribute has one of the following values: on: Flow control is active towards the mobile side of the call. off: Flow control is not active towards the mobile side of the call. DESCRIPTION')
mscTdmaBcModemPstnSideFlowControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemPstnSideFlowControlState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemPstnSideFlowControlState.setDescription('This attribute indicates the state of flow control based on whether flow control was requested by the PSTN side of the connection and an indication was sent to the Digital Signal Processor. This attribute has one of the following values: on: Flow control is active towards the DSP (PSTN side of the call). off: Flow control is not active towards the DSP (PSTN side of the call).')
mscTdmaBcModemAsyncMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemAsyncMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemAsyncMode.setDescription('This attribute indicates whether conversion between synchronous and asynchronous data format (specifically, the stripping or insertion of start and stop bits) is being performed. The value is on unless the V.42 layer is active or it is a fax call. This attribute has one of the following values: on: Conversion between synchronous and asynchronous data is being performed. off: Conversion between synchronous and asynchronous data is not being performed.')
mscTdmaBcModemOutbandFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemOutbandFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemOutbandFlowControl.setDescription('This attribute indicates whether outband flow control conversions are being performed. If outband flow control is on, then when the Modem Application Layer (MAL) receives an xon or xoff from the PSTN, the MAL converts the instruction into a primitive and sends it to the Data Service Control (DSC). In the opposite direction with outband flow control on, when the MAL receives a primitive from the DSC, the MAL converts the primitive into an xon or xoff and forwards it to the PSTN. If outband flow control is off, then all flow control is handled inband. The modem performs either inband or outband flow control unless V.42 layer is active, it is a fax call, or no flow control was specified by the DMS-MTX. This attribute has one of the following values: on: Conversion to and from out-of-band signaling is enabled. off: Conversion to and from out-of-band signaling is disabled.')
mscTdmaBcModemOutbandBreak = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemOutbandBreak.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemOutbandBreak.setDescription('This attribute indicates whether inband or outband break control conversions are being performed. If outband break control is on, when the modem detects a break condition coming from the PSTN, the Modem Application Layer (MAL) converts the instruction into a primitive and forwards it to the Data Service Control (DSC). In the opposite direction with outband break control on, when the MAL receives a primitive from the DSC, the MAL converts the primitive into a break and forwards it to the PSTN. When a break condition is discovered all subsequent incoming data is discarded until a start bit is received.')
mscTdmaBcModemAutobaud = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemAutobaud.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemAutobaud.setDescription('This attribute indicates whether autobaud is active. The modem is instructed at call setup time by the DMS-MTX on the following: (1) the initial modem data rate value, and (2) whether a modem is allowed to perform autobauding (on) or not (off). With autobauding on, the modem is allowed to connect using a valid modem data rate less than or equal to the initial rate specified to the modem by the DMS-MTX. If a modem cannot perform autobauding and the carrier cannot be established at the initial data rate, the modem is disabled.')
mscTdmaBcModemStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 11), )
if mibBuilder.loadTexts: mscTdmaBcModemStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemStatsTable.setDescription('This group contains operational attributes that measure performance of the modem component for this particular TdmaIwfBearerChannel.')
mscTdmaBcModemStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcModemIndex"))
if mibBuilder.loadTexts: mscTdmaBcModemStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemStatsEntry.setDescription('An entry in the mscTdmaBcModemStatsTable.')
mscTdmaBcModemTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemTxBytes.setDescription('This attribute counts the number of payload bytes transmitted. The counter wraps when it exceeds the maximum value.')
mscTdmaBcModemRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemRxBytes.setDescription('This attribute counts the number of payload bytes received. The counter wraps when it exceeds the maximum value.')
mscTdmaBcModemFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 3, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcModemFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcModemFramingErrors.setDescription('This attribute counts the number of framing errors detected by the hardware. This is the absence of a stop bit after a start bit and eight bits of data. All incoming data is discarded until the next start bit is received. The counter wraps when it exceeds the maximum value.')
mscTdmaBcFax = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4))
mscTdmaBcFaxRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 1), )
if mibBuilder.loadTexts: mscTdmaBcFaxRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcFax components.')
mscTdmaBcFaxRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFaxIndex"))
if mibBuilder.loadTexts: mscTdmaBcFaxRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcFax component.')
mscTdmaBcFaxRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcFax components. These components cannot be added nor deleted.')
mscTdmaBcFaxComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcFaxStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcFax tables.')
mscTdmaBcFaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcFaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxIndex.setDescription('This variable represents the index for the mscTdmaBcFax tables.')
mscTdmaBcFaxOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 10), )
if mibBuilder.loadTexts: mscTdmaBcFaxOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxOperTable.setDescription('This group contains operational attributes which measure the performance of the fax protocol.')
mscTdmaBcFaxOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFaxIndex"))
if mibBuilder.loadTexts: mscTdmaBcFaxOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxOperEntry.setDescription('An entry in the mscTdmaBcFaxOperTable.')
mscTdmaBcFaxActiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("ecm", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxActiveMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxActiveMode.setDescription('This attribute indicates the mode of the fax T.30 protocol, determined during Exchange Identification (XID) negotiations. The following modes are supported: normal: Normal T.30 protocol, Error Correction Mode (ECM) not used. ecm: Error Correction Mode used. Fax error correction is done using a half-duplex page selective repeat technique.')
mscTdmaBcFaxProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("setup", 0), ("idle", 1), ("bcsRx", 2), ("bcsTx", 3), ("msgRx", 4), ("msgTx", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxProtocolState.setDescription('This attribute indicates the protocol state of the fax adaptor. This attribute has one of the following values: setup: Call setup state. idle: Idle state only transmitting Synchronize (SYNC) frames. bcsRx: Receiving Binary Coded Signal (BCS) packet from modem. bcsTx: Transmitting BCS packet to modem. msgRx: Receiving fax message from modem. msgTx: Transmitting fax message to modem.')
mscTdmaBcFaxMessageRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxMessageRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxMessageRate.setDescription('This attribute indicates the fax message rate used for sending fax documents.')
mscTdmaBcFaxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 11), )
if mibBuilder.loadTexts: mscTdmaBcFaxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxStatsTable.setDescription('This group contains statistical attributes which measure the performance of the fax protocol.')
mscTdmaBcFaxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcFaxIndex"))
if mibBuilder.loadTexts: mscTdmaBcFaxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxStatsEntry.setDescription('An entry in the mscTdmaBcFaxStatsTable.')
mscTdmaBcFaxTxPagesToMobile = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxTxPagesToMobile.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxTxPagesToMobile.setDescription('The attribute counts the number of fax pages transmitted to the mobile. The counter wraps when it exceeds the maximum value.')
mscTdmaBcFaxRxPagesFromMobile = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcFaxRxPagesFromMobile.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcFaxRxPagesFromMobile.setDescription('This attribute counts the number of fax pages received from the mobile. The counter wraps when it exceeds the maximum value.')
mscTdmaBcDce = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5))
mscTdmaBcDceRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5, 1), )
if mibBuilder.loadTexts: mscTdmaBcDceRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDceRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcDce components.')
mscTdmaBcDceRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcDceIndex"))
if mibBuilder.loadTexts: mscTdmaBcDceRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDceRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcDce component.')
mscTdmaBcDceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDceRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDceRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcDce components. These components cannot be added nor deleted.')
mscTdmaBcDceComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDceComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDceComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcDceStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDceStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDceStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcDce tables.')
mscTdmaBcDceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcDceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDceIndex.setDescription('This variable represents the index for the mscTdmaBcDce tables.')
mscTdmaBcDsc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6))
mscTdmaBcDscRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 1), )
if mibBuilder.loadTexts: mscTdmaBcDscRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcDsc components.')
mscTdmaBcDscRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcDscIndex"))
if mibBuilder.loadTexts: mscTdmaBcDscRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcDsc component.')
mscTdmaBcDscRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcDsc components. These components cannot be added nor deleted.')
mscTdmaBcDscComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcDscStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcDsc tables.')
mscTdmaBcDscIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcDscIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscIndex.setDescription('This variable represents the index for the mscTdmaBcDsc tables.')
mscTdmaBcDscOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 10), )
if mibBuilder.loadTexts: mscTdmaBcDscOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscOperTable.setDescription('This group contains operational attributes that measure the performance of the DSC asynchronous data service.')
mscTdmaBcDscOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcDscIndex"))
if mibBuilder.loadTexts: mscTdmaBcDscOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscOperEntry.setDescription('An entry in the mscTdmaBcDscOperTable.')
mscTdmaBcDscP0CompressionDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noCompression", 0), ("compInitrResp", 1), ("compRespInitr", 2), ("compBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscP0CompressionDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscP0CompressionDirection.setDescription('This attribute indicates the direction of compression requested from logical link 0 (LL0). This attribute has one of the following values: noCpmpression: No data compression. compInitrResp: Compression initiator to responder. compRespInitr: compression responder to initiator. compBoth: compression in both directions.')
mscTdmaBcDscP1CompressionMaximumCodewords = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(512, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscP1CompressionMaximumCodewords.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscP1CompressionMaximumCodewords.setDescription('This attribute indicates the maximum number of codewords to be requested from logical link 0 (LL0) for compression. A codeword is a binary number that represents a string of characters.')
mscTdmaBcDscP2CompressionMaximumCharacters = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscP2CompressionMaximumCharacters.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscP2CompressionMaximumCharacters.setDescription('This attribute indicates the maximum number of characters that can be represented by a single codeword to be requested from logical link 0 (LL0) for compression.')
mscTdmaBcDscStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 11), )
if mibBuilder.loadTexts: mscTdmaBcDscStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscStatsTable.setDescription('This group contains statistical attributes that measure the performance of the DSC asynchronous data service.')
mscTdmaBcDscStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcDscIndex"))
if mibBuilder.loadTexts: mscTdmaBcDscStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscStatsEntry.setDescription('An entry in the mscTdmaBcDscStatsTable.')
mscTdmaBcDscTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscTxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscTxBytes.setDescription('This attribute counts the number of data bytes relayed by DSC in the transmit direction (towards the mobile). The counter wraps when it exceeds the maximum value.')
mscTdmaBcDscRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 6, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcDscRxBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcDscRxBytes.setDescription('This attribute counts the number of data bytes relayed by DSC in the receive direction (from the mobile). The counter wraps when it exceeds the maximum value.')
mscTdmaBcRlp1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7))
mscTdmaBcRlp1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 1), )
if mibBuilder.loadTexts: mscTdmaBcRlp1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1RowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcRlp1 components.')
mscTdmaBcRlp1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcRlp1Index"))
if mibBuilder.loadTexts: mscTdmaBcRlp1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1RowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcRlp1 component.')
mscTdmaBcRlp1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcRlp1 components. These components cannot be added nor deleted.')
mscTdmaBcRlp1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcRlp1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1StorageType.setDescription('This variable represents the storage type value for the mscTdmaBcRlp1 tables.')
mscTdmaBcRlp1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcRlp1Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1Index.setDescription('This variable represents the index for the mscTdmaBcRlp1 tables.')
mscTdmaBcRlp1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10), )
if mibBuilder.loadTexts: mscTdmaBcRlp1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1OperTable.setDescription('This group contains operational attributes that measure performance of the TdmaIwfBearerChannel.')
mscTdmaBcRlp1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcRlp1Index"))
if mibBuilder.loadTexts: mscTdmaBcRlp1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1OperEntry.setDescription('An entry in the mscTdmaBcRlp1OperTable.')
mscTdmaBcRlp1Layer3L0ReqWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1Layer3L0ReqWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1Layer3L0ReqWinSize.setDescription('This attribute indicates the window size for Service Access Point (SAP) 0 requested by layer 3. The window size is the maximum number of sequentially numbered Information (I) frames that may be unacknowledged at any given time.')
mscTdmaBcRlp1Layer3L1ReqWinSize1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1Layer3L1ReqWinSize1.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1Layer3L1ReqWinSize1.setDescription('This attribute indicates the window size for Service Access Point (SAP) 1 requested by layer 3. The window size is the maximum number of sequentially numbered Information (I) frames that may be unacknowledged at any given time.')
mscTdmaBcRlp1T1ResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1T1ResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1T1ResponseTimer.setDescription('This attribute indicates the current T1 timer for Service Access Points (SAP) 0 and 1 negotiated by the Radio Link Protocol 1 (RLP1), during Exchange Information (XID). This attribute specifies the time the receiving RLP1 entity shall wait for a response from the peer TIA-136-310 (formerly IS-130) application. The value used for XID negotiations can be provisioned in the TdmaCs/* Rlp1 t1ResponseTimer attribute.')
mscTdmaBcRlp1T2LinkActivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1T2LinkActivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1T2LinkActivityTimer.setDescription('This attribute indicates the current T2 timer for Service Access Points (SAP) 0 and 1 negotiated by the Radio Link Protocol 1 (RLP1), during Exchange Information (XID). This attribute specifies the maximum time the receiving RLP1 entity shall wait for link activity. The value used for XID negotiations can be provisioned in the TdmaCs/* Rlp1 t2LinkActivityTimer attribute.')
mscTdmaBcRlp1T3PeerAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1T3PeerAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1T3PeerAckTimer.setDescription('This attribute indicates the current T2 timer for Service Access Points (SAP) 0 and 1 negotiated by the Radio Link Protocol 1 (RLP1), during Exchange Information (XID). The attribute specifies the maximum time the receiving RLP1 entity shall wait for the peer to ACK or NAK data. The value used for XID negotiations can be provisioned in the TdmaCs/* Rlp1 t3PeerAckTimer attribute.')
mscTdmaBcRlp1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 11), )
if mibBuilder.loadTexts: mscTdmaBcRlp1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1StatsTable.setDescription('This group contains operational attributes that measure performance of the TdmaIwfBearerChannel.')
mscTdmaBcRlp1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcRlp1Index"))
if mibBuilder.loadTexts: mscTdmaBcRlp1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1StatsEntry.setDescription('An entry in the mscTdmaBcRlp1StatsTable.')
mscTdmaBcRlp1TxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1TxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1TxFrames.setDescription('This attribute counts the number of valid frames transmitted to the mobile. The counter wraps when it exceeds the maximum value.')
mscTdmaBcRlp1RxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1RxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1RxFrames.setDescription('This attributes counts the number of valid frames received from the mobile. The counter wraps when it exceeds the maximum value.')
mscTdmaBcRlp1BadRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 7, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcRlp1BadRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcRlp1BadRxFrames.setDescription('This attribute count the total number of bad RLP1 frames received from the mobile. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8))
mscTdmaBcV42RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 1), )
if mibBuilder.loadTexts: mscTdmaBcV42RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcV42 components.')
mscTdmaBcV42RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcV42Index"))
if mibBuilder.loadTexts: mscTdmaBcV42RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcV42 component.')
mscTdmaBcV42RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcV42 components. These components cannot be added nor deleted.')
mscTdmaBcV42ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcV42StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42StorageType.setDescription('This variable represents the storage type value for the mscTdmaBcV42 tables.')
mscTdmaBcV42Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcV42Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42Index.setDescription('This variable represents the index for the mscTdmaBcV42 tables.')
mscTdmaBcV42OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10), )
if mibBuilder.loadTexts: mscTdmaBcV42OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42OperTable.setDescription('This group contains operational attributes which measure V.42 error detection and correction performance.')
mscTdmaBcV42OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcV42Index"))
if mibBuilder.loadTexts: mscTdmaBcV42OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42OperEntry.setDescription('An entry in the mscTdmaBcV42OperTable.')
mscTdmaBcV42ProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notActive", 0), ("disconnected", 1), ("linkSetup", 2), ("frameReject", 3), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42ProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42ProtocolState.setDescription('This attribute indicates the state of V.42. Valid states are: notActive: The V.42 link connection with the PSTN modem is not established. None of the V.42 functions including the error detection, error correction, and flow control is provided to the data call. This is the initial state of V.42. disconnected: This means that the V42 link is disconnected. linkSetup: The V.42 operation enters this state from the disconnected state after the V.42 sends to the PSTN modem a Set Asynchronous Balanced Mode Extended (SABME) frame in an attempt to establish the error control connection with the PSTN modem. frameReject: The V.42 operation enters into this state after it identifies an invalid frame sent by the peer and it sends back a frame reject (FRMR) frame to the peer. disconnectRequest: The V.42 operation enters into this state after it sends to the peer a disconnect (DISC) frame with the attempt to disconnect the V.42 error control link. informationTransfer: The V.42 enters into this state after it receives a UA (unnumbered acknowledgment) frame which the peer sent upon receipt of the SAMBE frame from IWF V.42. Once in this state, the V.42 can exchange data and supervisory information with its peer. waitingAck: The V.42 enters this state after it sends polling enquiry to its peer. The V.42 sends the polling enquiry when it receives a reject frame (REJ) from its peer or either its acknowledgment timer or inactivity timer timed out on the information frames sent out.')
mscTdmaBcV42TxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65355))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42TxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42TxN401FrameSize.setDescription('This attribute indicates the current value of parameter N401 for V.42 which is negotiated during Exchange Information (XID). This is the maximum number of octets that can be carried in the information field of an information frame that the IWF V.42 transmits to the PSTN modem. The IWF V.42 puts this or even smaller size of data into the outgoing information frame. The value used for XID negotiations can be provisioned via TdmaCs/* V42.')
mscTdmaBcV42RxN401FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RxN401FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RxN401FrameSize.setDescription('This attribute indicates the current value of N401, that is negotiated during Exchange Identification (XID). This is the maximum number of octets that can be carried in the information field of an information frame received from the PSTN modem. An incoming information frame carrying data octets more than this size shall be rejected by the IWF V.42. The value used for XID negotiations can be provisioned via TdmaCs/* V42.')
mscTdmaBcV42TxKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42TxKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42TxKWindowSize.setDescription('This attribute indicates the current value of k, that is negotiated during Exchange Identification (XID). This is the size of flow control sliding window used for the information frames that the V.42 transmits to the PSTN modem. This size governs the maximum number of information frames that the IWF V.42 error- correcting entity can have outstanding (that is, unacknowledged). The value used for XID negotiations can be provisioned via TdmaCs/* V42.')
mscTdmaBcV42RxKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RxKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RxKWindowSize.setDescription('This attribute indicates the current value of k that is negotiated during Exchange Identification (XID). This is the size of flow control sliding window used for information frames transmitted from the PSTN modem. This size governs the maximum number of information frames that the peer of the IWF V.42 error-correcting entity can have outstanding (that is, unacknowledged). The value used for XID negotiations can be provisioned via TdmaCs/* V42.')
mscTdmaBcV42V42ActiveInCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notActiveInCall", 0), ("activeInCall", 1))).clone('notActiveInCall')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42V42ActiveInCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42V42ActiveInCall.setDescription('This attribute indicates whether V42 is really being used in this data call.')
mscTdmaBcV42V42BisActiveInCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notActiveInCall", 0), ("activeInCall", 1))).clone('notActiveInCall')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42V42BisActiveInCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42V42BisActiveInCall.setDescription('This attribute indicates whether V42bis is really being used in this data call.')
mscTdmaBcV42StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11), )
if mibBuilder.loadTexts: mscTdmaBcV42StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42StatsTable.setDescription('This group contains statistical attributes that measure the V.42 error detection and correction performance.')
mscTdmaBcV42StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcV42Index"))
if mibBuilder.loadTexts: mscTdmaBcV42StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42StatsEntry.setDescription('An entry in the mscTdmaBcV42StatsTable.')
mscTdmaBcV42RxIBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RxIBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RxIBytes.setDescription('This attribute counts the total number of bytes that the V.42 actually received from the PSTN modem in a data call. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42TxIBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42TxIBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42TxIBytes.setDescription('This attribute counts the total number of bytes that the V.42 transmitted to the PSTN modem in a data call. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42RxIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RxIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RxIFrames.setDescription('This attribute counts the total number of Information (I) frames that the V.42 received from the PSTN modem in a data call. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42TxIFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42TxIFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42TxIFrames.setDescription('This attribute counts the total number of information frames that the V.42 transmitted to the PSTN modem in a data call. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42RetransmittedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RetransmittedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RetransmittedFrames.setDescription('This attribute counts the total number of frames retransmitted by the IWF V.42 entity in a data call. The V.42 retransmits the same frame when the associated T401 acknowledgment timer timeouts or when a Reject (REJ) supervisory frame has been received from the PSTN modem. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42T1AckTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42T1AckTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42T1AckTimeouts.setDescription("This attribute counts the total number of times that the T401 timer has timed out within a data call. If this timer times-out frequently, the operator may need to adjust the provisioned parameter T401 acknowledgment timer to a larger time amount, since every time that V.42 sends out a frame it sets the T401 timer to wait for the peer's acknowledgment of the frame. When the timer times-out and no acknowledgment has been received, the V.42 sends the same frame to its peer. The counter wraps when it exceeds the maximum value.")
mscTdmaBcV42RemoteBusyIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42RemoteBusyIndications.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42RemoteBusyIndications.setDescription('This attribute counts the total number of times the PSTN modem enters a busy state (the IWF has received a Receive Not Ready message) and asks the IWF V.42 not to send Information (I) frames to it until it is ready to receive information frames again (indicated by receipt of a Receive Ready message or a data message). The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42LocalBusyIndications = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42LocalBusyIndications.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42LocalBusyIndications.setDescription('This attribute counts the total number of times the IWF V.42 enters in a busy condition and asks the peer to stop sending information frames until it has cleared up from the busy condition. The V.42 enters busy condition when its data buffer is about to be overflowed by the incoming Information (I) frames. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42BadFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BadFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BadFramesRx.setDescription("This attribute counts the total number of bad frames the IWF V.42 has received from the PSTN remote modem within the data call. In this instance, 'bad frames' refer to the V.42 protocol error frames other than the check sequence error frames. The counter wraps when it exceeds the maximum value.")
mscTdmaBcV42CrcErrorsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 8, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42CrcErrorsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42CrcErrorsRx.setDescription('This attribute counts the total number of frames received from the remote PSTN modem that contain incorrect frame check sequence. A high value signifies the condition of the physical medium is poor. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42Bis = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9))
mscTdmaBcV42BisRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 1), )
if mibBuilder.loadTexts: mscTdmaBcV42BisRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcV42Bis components.')
mscTdmaBcV42BisRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcV42BisIndex"))
if mibBuilder.loadTexts: mscTdmaBcV42BisRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcV42Bis component.')
mscTdmaBcV42BisRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcV42Bis components. These components cannot be added nor deleted.')
mscTdmaBcV42BisComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcV42BisStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcV42Bis tables.')
mscTdmaBcV42BisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcV42BisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisIndex.setDescription('This variable represents the index for the mscTdmaBcV42Bis tables.')
mscTdmaBcV42BisOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10), )
if mibBuilder.loadTexts: mscTdmaBcV42BisOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisOperTable.setDescription('This group contains operational attributes that measure the performance of IwfV42bis.')
mscTdmaBcV42BisOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcV42BisIndex"))
if mibBuilder.loadTexts: mscTdmaBcV42BisOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisOperEntry.setDescription('An entry in the mscTdmaBcV42BisOperTable.')
mscTdmaBcV42BisProtocolModeEncoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("transparent", 0), ("compressed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisProtocolModeEncoder.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisProtocolModeEncoder.setDescription('This attribute indicates the current mode of the IwfV42bis encoder. This mode can be either: transparent: A mode of operation in which compression has been selected but data is being transmitted in uncompressed form. Transparent mode command sequences may be inserted into the data stream. compressed: A mode of operation in which data is transmitted in codewords. The encoder switches between the two modes depending on whether the data coming from the Date Terminal Equipment (DTE) is suitable for compression. The data compression function periodically determines the compressibility of the data based on a comparison of the number of bits required to represent a segment of the data stream before and after compression.')
mscTdmaBcV42BisProtocolModeDecoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("transparent", 0), ("compressed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisProtocolModeDecoder.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisProtocolModeDecoder.setDescription('This attribute indicates the current mode of the V.42bis decoder. This mode can be either: transparent: A mode of operation in which compression has been selected but data is being transmitted in uncompressed form. Transparent mode command sequences may be inserted into the data stream. compressed: A mode of operation in which data is transmitted in codewords. The encoder (at the mobile or PSTN) switches between the two modes depending on whether the data coming from the Date Terminal Equipment (DTE) is suitable for compression. The data compression function periodically determines the compressibility of the data based on a comparison of the number of bits required to represent a segment of the data stream before and after compression.')
mscTdmaBcV42BisP0CompressionDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noCompression", 0), ("compInitrResp", 1), ("compRespInitr", 2), ("compBoth", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisP0CompressionDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisP0CompressionDirection.setDescription('This attribute indicates the direction in which V.42bis is active, negotiated at link setup by the data link protocol through Exchange Identification (XID) negotiation of parameter P0 (compression direction). The value used for XID negotiations can be provisioned via TdmaCs/* V42bis. This attribute has one of the following values: noCompression: No data compression. compInitrResp: The data sent by the IWF to the other entity is compressed. compRespInitr: The data received by the IWF from the other entity is compressed. compBoth: compression in both directions.')
mscTdmaBcV42BisP1MaximumCodewords = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisP1MaximumCodewords.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisP1MaximumCodewords.setDescription('This attribute indicates the maximum number of codewords in the dictionary negotiated at link setup by the data link protocol by way of the Exchange Identification (XID) negotiation of parameter P1 (number of codewords). The value used for XID negotiations can be provisioned via TdmaCs/* V42bis.')
mscTdmaBcV42BisP2MaximumStringSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisP2MaximumStringSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisP2MaximumStringSize.setDescription('This attribute indicates the maximum number of characters allowed in a string represented by a codeword negotiated at link setup by the data link protocol by way of the Exchange Identification (XID) negotiation of parameter P2 (maximum string size). The value used for XID negotiations can be provisioned via TdmaCs/* V42bis.')
mscTdmaBcV42BisLastDecodeError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 0), ("badStepup", 1), ("codewordEqC1", 2), ("emptyCodeword", 3), ("rsvdCommand", 4), ("generalError", 5))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisLastDecodeError.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisLastDecodeError.setDescription('This attribute indicates last error found by the decoder. This attribute has one of the following values: none: No errors found. badStepup: Receipt of STEPUP (step up codeword size) codeword when it would cause C2 (current code word size) to exceed N1 (maximum code word size). codewordEqC1: Receipt of a codeword, at any time, equal to C1 (next empty dictionary entry). emptyCodeword: Receipt of a codeword representing an empty dictionary entry. reservedCommand: Receipt of a reserved command code. generalError: Receipt of any other error. The action taken by V.42bis on detecting an error is provisioned via TdmaCs/* V42bis.')
mscTdmaBcV42BisCompRatioEncoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 7), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisCompRatioEncoder.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisCompRatioEncoder.setDescription('This attribute indicates the number of uncompressed bytes divided by the number of compressed bytes. A value greater than one means that the data is being compressed. This is the compression ratio achieved by the V.42bis encoder running on the Passport. This attribute is relevant for both protocol modes transparent and compressed as the encoder switches between the two modes.')
mscTdmaBcV42BisCompRatioDecoder = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 10, 1, 8), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisCompRatioDecoder.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisCompRatioDecoder.setDescription('This attribute indicates the number of uncompressed bytes divided by the number of compressed bytes. A value greater than one means that the data is being compressed. This is the compression ratio achieved by the V.42bis encoder at the mobile or PSTN. This attribute is relevant for both protocol modes transparent and compressed as the encoder switches between the two modes.')
mscTdmaBcV42BisStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11), )
if mibBuilder.loadTexts: mscTdmaBcV42BisStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisStatsTable.setDescription('This group contains statistical attributes that measure the performance of IwfV42bis.')
mscTdmaBcV42BisStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcV42BisIndex"))
if mibBuilder.loadTexts: mscTdmaBcV42BisStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisStatsEntry.setDescription('An entry in the mscTdmaBcV42BisStatsTable.')
mscTdmaBcV42BisModeChangesEncode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisModeChangesEncode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisModeChangesEncode.setDescription('This attribute counts the number of mode changes (from transparent to compressed or from compressed to transparent) by the encoder. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42BisModeChangesDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisModeChangesDecode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisModeChangesDecode.setDescription('This attribute counts the number of mode changes (from transparent to compressed or from compressed to transparent) by the decoder. The mode changes are determined by the encoder at the mobile or the PSTN. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42BisResetsEncode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisResetsEncode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisResetsEncode.setDescription('This attribute counts the number of resets sent by the encoder. A reset is a command code sent by the encoder to force dictionary reinitialization. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42BisResetsDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisResetsDecode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisResetsDecode.setDescription('This attribute counts the number of resets received by the decoder. A reset is a command code sent by the encoder to force dictionary reinitialization. The resets of the decoder are determined by the encoder at the mobile or PSTN. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42BisReinitializations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisReinitializations.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisReinitializations.setDescription('This attribute counts the number of times V.42bis is reinitialized because of a destructive break (a destructive break is a break that causes data to be discarded) occurring on the error-corrected connection initiated by either the mobile or PSTN. The counter wraps when it exceeds the maximum value.')
mscTdmaBcV42BisErrorsInDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 9, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcV42BisErrorsInDecode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcV42BisErrorsInDecode.setDescription('This attribute counts the number of errors found by the decoder. The errors could be any of the following: 1.Receipt of STEPUP (step up codeword size) codeword when it would cause C2 (current code word size) to exceed N1 (maximum code word size). 2. Receipt of a codeword, at any time, equal to C1 (next empty dictionary entry). 3. Receipt of a codeword representing an empty dictionary entry. 4. Receipt of a reserved command code. 5. Receipt of any other error. The counter wraps when it exceeds the maximum value. The action taken by V.42bis on detecting any of these errors is provisioned via TdmaCs/* V42bis.')
mscTdmaBcUr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10))
mscTdmaBcUrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 1), )
if mibBuilder.loadTexts: mscTdmaBcUrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrRowStatusTable.setDescription('This entry controls the addition and deletion of mscTdmaBcUr components.')
mscTdmaBcUrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcUrIndex"))
if mibBuilder.loadTexts: mscTdmaBcUrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrRowStatusEntry.setDescription('A single entry in the table represents a single mscTdmaBcUr component.')
mscTdmaBcUrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTdmaBcUr components. These components cannot be added nor deleted.')
mscTdmaBcUrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTdmaBcUrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrStorageType.setDescription('This variable represents the storage type value for the mscTdmaBcUr tables.')
mscTdmaBcUrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTdmaBcUrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrIndex.setDescription('This variable represents the index for the mscTdmaBcUr tables.')
mscTdmaBcUrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 10), )
if mibBuilder.loadTexts: mscTdmaBcUrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrOperTable.setDescription('This group contains operational attributes that measure the performance of the UpperRelay.')
mscTdmaBcUrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcUrIndex"))
if mibBuilder.loadTexts: mscTdmaBcUrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrOperEntry.setDescription('An entry in the mscTdmaBcUrOperTable.')
mscTdmaBcUrRxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrRxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrRxBufferSize.setDescription('This attribute indicates the size of the receive flow control buffer. This attribute may be viewed via TdmaBc/*,*,*,* UpperRelay.')
mscTdmaBcUrTxFlowControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrTxFlowControlState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrTxFlowControlState.setDescription('This attribute indicates whether the transmit flow control is active or not. This attribute has one of the following values: active: The transmit flow control is active. inactive: The transmit flow control is inactive. This attribute may be viewed via TdmaBc/*,*,*,* UpperRelay.')
mscTdmaBcUrRxFlowControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrRxFlowControlState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrRxFlowControlState.setDescription('This attribute indicates whether the receive flow control is active or not. This attribute has one of the following values: active: The receive flow control is active. inactive: The receive flow control is inactive. This attribute may be viewed via TdmaBc/*,*,*,* UpperRelay.')
mscTdmaBcUrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 11), )
if mibBuilder.loadTexts: mscTdmaBcUrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrStatsTable.setDescription('This group contains operational attributes that measure the performance of the UpperRelay.')
mscTdmaBcUrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcCsIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcBcIndex"), (0, "Nortel-MsCarrier-MscPassport-TdmaIwfMIB", "mscTdmaBcUrIndex"))
if mibBuilder.loadTexts: mscTdmaBcUrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrStatsEntry.setDescription('An entry in the mscTdmaBcUrStatsTable.')
mscTdmaBcUrTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrTxFrames.setDescription('This attribute counts the number of frames that are sent in the transmit direction. The counter wraps when it exceeds the maximum value. The counter wraps when it exceeds the maximum value.')
mscTdmaBcUrRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrRxFrames.setDescription('This attribute counts the number of frames that are sent in the receive direction. The counter wraps when it exceeds the maximum value.')
mscTdmaBcUrUnacknowledgedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrUnacknowledgedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrUnacknowledgedFrames.setDescription('This attribute indicates the current number of frames sent that have not been acknowledged for this instance of the UpperRelay. The counter wraps when it exceeds the maximum value.')
mscTdmaBcUrCumUnacknowledgedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 136, 10, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTdmaBcUrCumUnacknowledgedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscTdmaBcUrCumUnacknowledgedFrames.setDescription('This attribute is the total number of unacknowledged frames for this instance of the UpperRelay. It is not reset when a new call starts.')
tdmaIwfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 1))
tdmaIwfGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 1, 1))
tdmaIwfGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 1, 1, 3))
tdmaIwfGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 1, 1, 3, 2))
tdmaIwfCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 3))
tdmaIwfCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 3, 1))
tdmaIwfCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 3, 1, 3))
tdmaIwfCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 140, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-TdmaIwfMIB", mscTdmaBcUrOperEntry=mscTdmaBcUrOperEntry, mscTdmaBcModemRowStatus=mscTdmaBcModemRowStatus, mscTdmaBcUrUnacknowledgedFrames=mscTdmaBcUrUnacknowledgedFrames, mscTdmaCsStorageType=mscTdmaCsStorageType, mscTdmaBcRlp1Layer3L1ReqWinSize1=mscTdmaBcRlp1Layer3L1ReqWinSize1, mscTdmaBcV42BisCompRatioEncoder=mscTdmaBcV42BisCompRatioEncoder, tdmaIwfGroup=tdmaIwfGroup, mscTdmaCsRlp1T2LinkActivityTimer=mscTdmaCsRlp1T2LinkActivityTimer, mscTdmaCsSupportedTechnology=mscTdmaCsSupportedTechnology, mscTdmaCsV42ProvEntry=mscTdmaCsV42ProvEntry, tdmaIwfGroupCA02A=tdmaIwfGroupCA02A, mscTdmaBcRlp1RowStatus=mscTdmaBcRlp1RowStatus, mscTdmaBcV42BisStorageType=mscTdmaBcV42BisStorageType, mscTdmaCsT313=mscTdmaCsT313, mscTdmaBcFramerComponentName=mscTdmaBcFramerComponentName, mscTdmaBcV42StatsTable=mscTdmaBcV42StatsTable, mscTdmaCsLp=mscTdmaCsLp, mscTdmaBcFramerUsageState=mscTdmaBcFramerUsageState, mscTdmaCsOperationalState=mscTdmaCsOperationalState, mscTdmaBcCsIndex=mscTdmaBcCsIndex, mscTdmaBcFaxRowStatusTable=mscTdmaBcFaxRowStatusTable, mscTdmaBcCallType=mscTdmaBcCallType, mscTdmaBcFramerAdminState=mscTdmaBcFramerAdminState, mscTdmaCsV42BisRowStatus=mscTdmaCsV42BisRowStatus, mscTdmaCsV42BisP2MaximumStringSize=mscTdmaCsV42BisP2MaximumStringSize, mscTdmaBcV42RxIFrames=mscTdmaBcV42RxIFrames, mscTdmaCs=mscTdmaCs, mscTdmaCsDscP1CompressionMaximumCodewords=mscTdmaCsDscP1CompressionMaximumCodewords, mscTdmaBcFramerProvTable=mscTdmaBcFramerProvTable, mscTdmaCsDscRowStatusEntry=mscTdmaCsDscRowStatusEntry, mscTdmaBcV42RxN401FrameSize=mscTdmaBcV42RxN401FrameSize, mscTdmaBcV42TxIBytes=mscTdmaBcV42TxIBytes, mscTdmaBcV42TxN401FrameSize=mscTdmaBcV42TxN401FrameSize, mscTdmaCsDscComponentName=mscTdmaCsDscComponentName, mscTdmaCsV42T403IdleProbeTimer=mscTdmaCsV42T403IdleProbeTimer, mscTdmaCsLpRowStatusTable=mscTdmaCsLpRowStatusTable, mscTdmaBcDscRxBytes=mscTdmaBcDscRxBytes, mscTdmaBcDscIndex=mscTdmaBcDscIndex, mscTdmaBcFramerInterfaceName=mscTdmaBcFramerInterfaceName, mscTdmaCsV42ComponentName=mscTdmaCsV42ComponentName, mscTdmaCsTIwf2=mscTdmaCsTIwf2, mscTdmaBcFaxStatsTable=mscTdmaBcFaxStatsTable, mscTdmaBcV42BisOperTable=mscTdmaBcV42BisOperTable, mscTdmaBcV42Index=mscTdmaBcV42Index, mscTdmaBcV42BisIndex=mscTdmaBcV42BisIndex, mscTdmaBcOperEntry=mscTdmaBcOperEntry, mscTdmaBcV42BisReinitializations=mscTdmaBcV42BisReinitializations, mscTdmaBcStorageType=mscTdmaBcStorageType, mscTdmaCsDscP2CompressionMaximumCharacters=mscTdmaCsDscP2CompressionMaximumCharacters, mscTdmaCsV42BisIndex=mscTdmaCsV42BisIndex, mscTdmaCsV42T400DetectTimer=mscTdmaCsV42T400DetectTimer, mscTdmaBcDsc=mscTdmaBcDsc, mscTdmaBcV42BisP1MaximumCodewords=mscTdmaBcV42BisP1MaximumCodewords, mscTdmaBcModemOperEntry=mscTdmaBcModemOperEntry, mscTdmaBcV42BisP2MaximumStringSize=mscTdmaBcV42BisP2MaximumStringSize, mscTdmaBcFaxRxPagesFromMobile=mscTdmaBcFaxRxPagesFromMobile, mscTdmaBcDceRowStatus=mscTdmaBcDceRowStatus, mscTdmaBcFramerLinkTable=mscTdmaBcFramerLinkTable, mscTdmaCsServProvTable=mscTdmaCsServProvTable, mscTdmaBcV42RemoteBusyIndications=mscTdmaBcV42RemoteBusyIndications, mscTdmaBcV42ComponentName=mscTdmaBcV42ComponentName, mscTdmaBcV42BisRowStatus=mscTdmaBcV42BisRowStatus, mscTdmaCsCommentText=mscTdmaCsCommentText, mscTdmaBcV42RxKWindowSize=mscTdmaBcV42RxKWindowSize, mscTdmaCsV42Index=mscTdmaCsV42Index, mscTdmaBcV42RowStatus=mscTdmaBcV42RowStatus, mscTdmaBcStateTable=mscTdmaBcStateTable, mscTdmaCsDceStorageType=mscTdmaCsDceStorageType, mscTdmaBcModem=mscTdmaBcModem, mscTdmaBcV42BisComponentName=mscTdmaBcV42BisComponentName, mscTdmaBcRlp1T1ResponseTimer=mscTdmaBcRlp1T1ResponseTimer, mscTdmaBcRlp1T2LinkActivityTimer=mscTdmaBcRlp1T2LinkActivityTimer, mscTdmaBcV42StorageType=mscTdmaBcV42StorageType, mscTdmaBcRlp1ComponentName=mscTdmaBcRlp1ComponentName, mscTdmaCsV42RxN401FrameSize=mscTdmaCsV42RxN401FrameSize, mscTdmaBcV42V42BisActiveInCall=mscTdmaBcV42V42BisActiveInCall, mscTdmaBcFramerStatsTable=mscTdmaBcFramerStatsTable, mscTdmaBcFramerRowStatusEntry=mscTdmaBcFramerRowStatusEntry, mscTdmaCsV42BisRowStatusTable=mscTdmaCsV42BisRowStatusTable, mscTdmaBcCustomerIdentifier=mscTdmaBcCustomerIdentifier, mscTdmaBcUsageState=mscTdmaBcUsageState, mscTdmaBcFaxStatsEntry=mscTdmaBcFaxStatsEntry, mscTdmaBcModemStorageType=mscTdmaBcModemStorageType, mscTdmaCsFaxRowStatus=mscTdmaCsFaxRowStatus, mscTdmaBcOperationalState=mscTdmaBcOperationalState, mscTdmaCsLpRowStatusEntry=mscTdmaCsLpRowStatusEntry, mscTdmaBcBcIndex=mscTdmaBcBcIndex, mscTdmaBcState=mscTdmaBcState, mscTdmaBcV42ProtocolState=mscTdmaBcV42ProtocolState, mscTdmaBcFramerTxFrames=mscTdmaBcFramerTxFrames, mscTdmaCsVirtualRouterName=mscTdmaCsVirtualRouterName, mscTdmaCsStatsTable=mscTdmaCsStatsTable, mscTdmaBcModemModemAlgorithmInUse=mscTdmaBcModemModemAlgorithmInUse, mscTdmaCsFaxRowStatusEntry=mscTdmaCsFaxRowStatusEntry, mscTdmaBcUrTxFlowControlState=mscTdmaBcUrTxFlowControlState, mscTdmaBcFramerRxBytes=mscTdmaBcFramerRxBytes, mscTdmaBcV42BisStatsEntry=mscTdmaBcV42BisStatsEntry, mscTdmaCsFaxStorageType=mscTdmaCsFaxStorageType, mscTdmaBcV42BisProtocolModeEncoder=mscTdmaBcV42BisProtocolModeEncoder, mscTdmaBcV42StatsEntry=mscTdmaBcV42StatsEntry, mscTdmaBcDscTxBytes=mscTdmaBcDscTxBytes, mscTdmaCsCallsSetUp=mscTdmaCsCallsSetUp, mscTdmaBcV42BisStatsTable=mscTdmaBcV42BisStatsTable, mscTdmaBcModemOutbandFlowControl=mscTdmaBcModemOutbandFlowControl, mscTdmaBcModemIndex=mscTdmaBcModemIndex, mscTdmaBcModemPstnSideFlowControlState=mscTdmaBcModemPstnSideFlowControlState, mscTdmaCsV42N400RetransLimit=mscTdmaCsV42N400RetransLimit, mscTdmaBcFaxIndex=mscTdmaBcFaxIndex, mscTdmaBcDscStatsTable=mscTdmaBcDscStatsTable, mscTdmaBcModemRowStatusEntry=mscTdmaBcModemRowStatusEntry, mscTdmaBcModemRate=mscTdmaBcModemRate, tdmaIwfCapabilitiesCA=tdmaIwfCapabilitiesCA, mscTdmaBcUrCumUnacknowledgedFrames=mscTdmaBcUrCumUnacknowledgedFrames, mscTdmaCsTIwf1=mscTdmaCsTIwf1, mscTdmaCsDceRowStatusEntry=mscTdmaCsDceRowStatusEntry, mscTdmaCsDscLl0BufferSize=mscTdmaCsDscLl0BufferSize, mscTdmaBcRlp1Layer3L0ReqWinSize=mscTdmaBcRlp1Layer3L0ReqWinSize, mscTdmaCsRlp1StorageType=mscTdmaCsRlp1StorageType, mscTdmaBcV42CrcErrorsRx=mscTdmaBcV42CrcErrorsRx, mscTdmaBcDscStorageType=mscTdmaBcDscStorageType, mscTdmaBc=mscTdmaBc, mscTdmaBcV42BisResetsEncode=mscTdmaBcV42BisResetsEncode, mscTdmaCsUsageState=mscTdmaCsUsageState, mscTdmaCsDce=mscTdmaCsDce, mscTdmaBcModemStatsEntry=mscTdmaBcModemStatsEntry, mscTdmaCsRlp1RowStatusTable=mscTdmaCsRlp1RowStatusTable, mscTdmaCsV42RowStatus=mscTdmaCsV42RowStatus, mscTdmaCsDscLl1BufferSize=mscTdmaCsDscLl1BufferSize, mscTdmaCsV42TxKWindowSize=mscTdmaCsV42TxKWindowSize, mscTdmaCsT999=mscTdmaCsT999, mscTdmaBcRlp1TxFrames=mscTdmaBcRlp1TxFrames, mscTdmaCsLpComponentName=mscTdmaCsLpComponentName, mscTdmaCsMscIpAddress=mscTdmaCsMscIpAddress, mscTdmaCsCallsReleasedNormal=mscTdmaCsCallsReleasedNormal, mscTdmaCsV42=mscTdmaCsV42, mscTdmaBcRlp1T3PeerAckTimer=mscTdmaBcRlp1T3PeerAckTimer, mscTdmaCsRowStatus=mscTdmaCsRowStatus, tdmaIwfCapabilitiesCA02A=tdmaIwfCapabilitiesCA02A, mscTdmaCsV42TxN401FrameSize=mscTdmaCsV42TxN401FrameSize, mscTdmaBcModemAsyncMode=mscTdmaBcModemAsyncMode, mscTdmaBcModemAutobaud=mscTdmaBcModemAutobaud, mscTdmaCsT303=mscTdmaCsT303, mscTdmaCsDscRowStatusTable=mscTdmaCsDscRowStatusTable, tdmaIwfCapabilitiesCA02=tdmaIwfCapabilitiesCA02, mscTdmaBcUrComponentName=mscTdmaBcUrComponentName, mscTdmaBcModemOutbandBreak=mscTdmaBcModemOutbandBreak, mscTdmaCsRowStatusTable=mscTdmaCsRowStatusTable, mscTdmaBcCidDataTable=mscTdmaBcCidDataTable, mscTdmaBcFramer=mscTdmaBcFramer, mscTdmaBcFaxActiveMode=mscTdmaBcFaxActiveMode, mscTdmaBcV42=mscTdmaBcV42, mscTdmaBcFaxRowStatusEntry=mscTdmaBcFaxRowStatusEntry, mscTdmaBcV42TxIFrames=mscTdmaBcV42TxIFrames, mscTdmaCsAdminState=mscTdmaCsAdminState, mscTdmaBcUrStatsTable=mscTdmaBcUrStatsTable, mscTdmaBcV42RowStatusTable=mscTdmaBcV42RowStatusTable, mscTdmaBcV42BisCompRatioDecoder=mscTdmaBcV42BisCompRatioDecoder, mscTdmaBcV42BisModeChangesEncode=mscTdmaBcV42BisModeChangesEncode, mscTdmaBcDscStatsEntry=mscTdmaBcDscStatsEntry, mscTdmaBcDscRowStatusEntry=mscTdmaBcDscRowStatusEntry, mscTdmaBcModemStatsTable=mscTdmaBcModemStatsTable, mscTdmaBcModemProtocolState=mscTdmaBcModemProtocolState, mscTdmaBcRlp1Index=mscTdmaBcRlp1Index, mscTdmaCsFaxComponentName=mscTdmaCsFaxComponentName, mscTdmaCsComponentName=mscTdmaCsComponentName, mscTdmaCsCurrentCalls=mscTdmaCsCurrentCalls, mscTdmaCsDceComponentName=mscTdmaCsDceComponentName, mscTdmaBcModemMobileSideFlowControlState=mscTdmaBcModemMobileSideFlowControlState, mscTdmaBcModemFramingErrors=mscTdmaBcModemFramingErrors, mscTdmaCsDscP0CompressionDirection=mscTdmaCsDscP0CompressionDirection, mscTdmaCsLpConfiguredBearerChannels=mscTdmaCsLpConfiguredBearerChannels, mscTdmaCsV42BisP1MaximumCodewords=mscTdmaCsV42BisP1MaximumCodewords, mscTdmaBcDscOperEntry=mscTdmaBcDscOperEntry, mscTdmaBcV42LocalBusyIndications=mscTdmaBcV42LocalBusyIndications, mscTdmaBcUrRowStatusEntry=mscTdmaBcUrRowStatusEntry, mscTdmaCsDsc=mscTdmaCsDsc, mscTdmaCsLpRowStatus=mscTdmaCsLpRowStatus, mscTdmaCsCidDataTable=mscTdmaCsCidDataTable, mscTdmaBcFramerProvEntry=mscTdmaBcFramerProvEntry, mscTdmaBcV42OperEntry=mscTdmaBcV42OperEntry, mscTdmaCsModemStorageType=mscTdmaCsModemStorageType, mscTdmaCsV42BisProvTable=mscTdmaCsV42BisProvTable, mscTdmaCsV42BisP0CompressionDirection=mscTdmaCsV42BisP0CompressionDirection, mscTdmaBcLastResponseCode=mscTdmaBcLastResponseCode, mscTdmaBcRlp1=mscTdmaBcRlp1, mscTdmaCsV42RowStatusEntry=mscTdmaCsV42RowStatusEntry, mscTdmaCsV42RxKWindowSize=mscTdmaCsV42RxKWindowSize, mscTdmaBcFaxStorageType=mscTdmaBcFaxStorageType, mscTdmaCsStateEntry=mscTdmaCsStateEntry, mscTdmaCsRlp1=mscTdmaCsRlp1, mscTdmaCsDscIndex=mscTdmaCsDscIndex, mscTdmaCsCallsReleasedAbnormal=mscTdmaCsCallsReleasedAbnormal, mscTdmaBcFramerOperationalState=mscTdmaBcFramerOperationalState, mscTdmaBcFramerStateTable=mscTdmaBcFramerStateTable, mscTdmaCsV42BisActionOnError=mscTdmaCsV42BisActionOnError, mscTdmaCsRowStatusEntry=mscTdmaCsRowStatusEntry, mscTdmaBcDceRowStatusEntry=mscTdmaBcDceRowStatusEntry, mscTdmaCsDscStorageType=mscTdmaCsDscStorageType, mscTdmaBcModemRxBytes=mscTdmaBcModemRxBytes, mscTdmaCsLpOperTable=mscTdmaCsLpOperTable, mscTdmaBcComponentName=mscTdmaBcComponentName, mscTdmaBcFaxOperEntry=mscTdmaBcFaxOperEntry, mscTdmaCsModem=mscTdmaCsModem, mscTdmaBcDceRowStatusTable=mscTdmaBcDceRowStatusTable, mscTdmaCsV42BisRowStatusEntry=mscTdmaCsV42BisRowStatusEntry, mscTdmaBcV42V42ActiveInCall=mscTdmaBcV42V42ActiveInCall, mscTdmaBcModemComponentName=mscTdmaBcModemComponentName, mscTdmaBcFramerRowStatusTable=mscTdmaBcFramerRowStatusTable, mscTdmaCsModemIndex=mscTdmaCsModemIndex, tdmaIwfCapabilities=tdmaIwfCapabilities, mscTdmaCsStatsEntry=mscTdmaCsStatsEntry, mscTdmaCsRlp1ProvTable=mscTdmaCsRlp1ProvTable, mscTdmaBcDscRowStatus=mscTdmaBcDscRowStatus, mscTdmaBcUrRxBufferSize=mscTdmaBcUrRxBufferSize, mscTdmaBcStateEntry=mscTdmaBcStateEntry, mscTdmaBcRowStatusEntry=mscTdmaBcRowStatusEntry, mscTdmaBcAdminState=mscTdmaBcAdminState, mscTdmaBcFaxComponentName=mscTdmaBcFaxComponentName, mscTdmaCsModemRowStatusEntry=mscTdmaCsModemRowStatusEntry, mscTdmaCsModemComponentName=mscTdmaCsModemComponentName, mscTdmaCsV42BisProvEntry=mscTdmaCsV42BisProvEntry, mscTdmaCsLpOperEntry=mscTdmaCsLpOperEntry, mscTdmaBcOperTable=mscTdmaBcOperTable, mscTdmaCsFaxIndex=mscTdmaCsFaxIndex, mscTdmaCsDscK1Ll1WindowSize=mscTdmaCsDscK1Ll1WindowSize, mscTdmaBcCidDataEntry=mscTdmaBcCidDataEntry, mscTdmaBcUrStatsEntry=mscTdmaBcUrStatsEntry, mscTdmaBcFaxRowStatus=mscTdmaBcFaxRowStatus, mscTdmaBcModemRowStatusTable=mscTdmaBcModemRowStatusTable, mscTdmaBcDceComponentName=mscTdmaBcDceComponentName, mscTdmaBcV42BisModeChangesDecode=mscTdmaBcV42BisModeChangesDecode, mscTdmaCsCsIndex=mscTdmaCsCsIndex, mscTdmaCsVoiceLaw=mscTdmaCsVoiceLaw, mscTdmaCsV42RowStatusTable=mscTdmaCsV42RowStatusTable, mscTdmaCsCallsRequested=mscTdmaCsCallsRequested, mscTdmaCsFaxRowStatusTable=mscTdmaCsFaxRowStatusTable, mscTdmaBcFaxOperTable=mscTdmaBcFaxOperTable, mscTdmaCsDceRowStatusTable=mscTdmaCsDceRowStatusTable, mscTdmaBcRlp1OperTable=mscTdmaBcRlp1OperTable, mscTdmaBcV42Bis=mscTdmaBcV42Bis, mscTdmaBcFaxProtocolState=mscTdmaBcFaxProtocolState, mscTdmaCsLpIndex=mscTdmaCsLpIndex, mscTdmaBcDceIndex=mscTdmaBcDceIndex, mscTdmaCsV42Bis=mscTdmaCsV42Bis, mscTdmaCsDscK0Ll0WindowSize=mscTdmaCsDscK0Ll0WindowSize, mscTdmaBcUrIndex=mscTdmaBcUrIndex, mscTdmaBcRlp1StatsEntry=mscTdmaBcRlp1StatsEntry, mscTdmaCsRlp1T1ResponseTimer=mscTdmaCsRlp1T1ResponseTimer, mscTdmaBcFramerStatsEntry=mscTdmaBcFramerStatsEntry, mscTdmaBcFramerStateEntry=mscTdmaBcFramerStateEntry, mscTdmaBcFramerFramingType=mscTdmaBcFramerFramingType, mscTdmaCsModemRowStatus=mscTdmaCsModemRowStatus, mscTdmaBcRlp1OperEntry=mscTdmaBcRlp1OperEntry, mscTdmaBcV42BisLastDecodeError=mscTdmaBcV42BisLastDecodeError)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-TdmaIwfMIB", mscTdmaBcDscComponentName=mscTdmaBcDscComponentName, mscTdmaBcRlp1StatsTable=mscTdmaBcRlp1StatsTable, mscTdmaBcRlp1RowStatusEntry=mscTdmaBcRlp1RowStatusEntry, mscTdmaBcDscP1CompressionMaximumCodewords=mscTdmaBcDscP1CompressionMaximumCodewords, mscTdmaBcFramerRxFrames=mscTdmaBcFramerRxFrames, mscTdmaBcFaxMessageRate=mscTdmaBcFaxMessageRate, mscTdmaCsRlp1ProvEntry=mscTdmaCsRlp1ProvEntry, mscTdmaBcV42BisRowStatusTable=mscTdmaBcV42BisRowStatusTable, mscTdmaCsDscProvEntry=mscTdmaCsDscProvEntry, mscTdmaCsLpModemsSupported=mscTdmaCsLpModemsSupported, tdmaIwfGroupCA02=tdmaIwfGroupCA02, mscTdmaBcDce=mscTdmaBcDce, mscTdmaBcFramerRowStatus=mscTdmaBcFramerRowStatus, mscTdmaCsSupportedService=mscTdmaCsSupportedService, mscTdmaBcV42TxKWindowSize=mscTdmaBcV42TxKWindowSize, mscTdmaBcV42BisErrorsInDecode=mscTdmaBcV42BisErrorsInDecode, mscTdmaCsV42BisComponentName=mscTdmaCsV42BisComponentName, mscTdmaBcDscOperTable=mscTdmaBcDscOperTable, mscTdmaCsCustomerIdentifier=mscTdmaCsCustomerIdentifier, mscTdmaBcFaxTxPagesToMobile=mscTdmaBcFaxTxPagesToMobile, mscTdmaCsFax=mscTdmaCsFax, mscTdmaCsDscProvTable=mscTdmaCsDscProvTable, mscTdmaBcV42BisResetsDecode=mscTdmaBcV42BisResetsDecode, mscTdmaBcV42RowStatusEntry=mscTdmaBcV42RowStatusEntry, mscTdmaBcRlp1RowStatusTable=mscTdmaBcRlp1RowStatusTable, mscTdmaCsLpStorageType=mscTdmaCsLpStorageType, mscTdmaBcFramerStorageType=mscTdmaBcFramerStorageType, tdmaIwfMIB=tdmaIwfMIB, mscTdmaCsV42ProvTable=mscTdmaCsV42ProvTable, mscTdmaBcUrOperTable=mscTdmaBcUrOperTable, mscTdmaBcV42RetransmittedFrames=mscTdmaBcV42RetransmittedFrames, mscTdmaBcUrRxFlowControlState=mscTdmaBcUrRxFlowControlState, mscTdmaCsServProvEntry=mscTdmaCsServProvEntry, mscTdmaCsRlp1RowStatus=mscTdmaCsRlp1RowStatus, mscTdmaCsV42T402AckDelayTimer=mscTdmaCsV42T402AckDelayTimer, mscTdmaBcModemTxBytes=mscTdmaBcModemTxBytes, mscTdmaBcRowStatusTable=mscTdmaBcRowStatusTable, mscTdmaBcV42RxIBytes=mscTdmaBcV42RxIBytes, mscTdmaCsRlp1Index=mscTdmaCsRlp1Index, mscTdmaCsMiscProvEntry=mscTdmaCsMiscProvEntry, mscTdmaBcV42BisProtocolModeDecoder=mscTdmaBcV42BisProtocolModeDecoder, mscTdmaCsModemRowStatusTable=mscTdmaCsModemRowStatusTable, mscTdmaCsT305=mscTdmaCsT305, mscTdmaBcUr=mscTdmaBcUr, mscTdmaBcUrRowStatus=mscTdmaBcUrRowStatus, mscTdmaBcDscRowStatusTable=mscTdmaBcDscRowStatusTable, mscTdmaBcFax=mscTdmaBcFax, mscTdmaCsDceIndex=mscTdmaCsDceIndex, mscTdmaBcRlp1BadRxFrames=mscTdmaBcRlp1BadRxFrames, mscTdmaBcV42BisRowStatusEntry=mscTdmaBcV42BisRowStatusEntry, mscTdmaBcDceStorageType=mscTdmaBcDceStorageType, mscTdmaBcModemVoiceLaw=mscTdmaBcModemVoiceLaw, mscTdmaBcV42BadFramesRx=mscTdmaBcV42BadFramesRx, mscTdmaBcUrRowStatusTable=mscTdmaBcUrRowStatusTable, mscTdmaCsLpActiveCalls=mscTdmaCsLpActiveCalls, mscTdmaCsV42StorageType=mscTdmaCsV42StorageType, mscTdmaBcModemOperTable=mscTdmaBcModemOperTable, tdmaIwfGroupCA=tdmaIwfGroupCA, mscTdmaBcV42BisOperEntry=mscTdmaBcV42BisOperEntry, mscTdmaBcUrTxFrames=mscTdmaBcUrTxFrames, mscTdmaBcDscP2CompressionMaximumCharacters=mscTdmaBcDscP2CompressionMaximumCharacters, mscTdmaBcV42T1AckTimeouts=mscTdmaBcV42T1AckTimeouts, mscTdmaCsCidDataEntry=mscTdmaCsCidDataEntry, mscTdmaCsDscRowStatus=mscTdmaCsDscRowStatus, mscTdmaCsV42BisStorageType=mscTdmaCsV42BisStorageType, mscTdmaBcMateBearerChannel=mscTdmaBcMateBearerChannel, mscTdmaBcV42OperTable=mscTdmaBcV42OperTable, mscTdmaBcV42BisP0CompressionDirection=mscTdmaBcV42BisP0CompressionDirection, mscTdmaCsDceRowStatus=mscTdmaCsDceRowStatus, mscTdmaCsV42FcsLength=mscTdmaCsV42FcsLength, mscTdmaBcDscP0CompressionDirection=mscTdmaBcDscP0CompressionDirection, mscTdmaBcFramerLinkEntry=mscTdmaBcFramerLinkEntry, mscTdmaBcRowStatus=mscTdmaBcRowStatus, mscTdmaBcUrRxFrames=mscTdmaBcUrRxFrames, mscTdmaCsT308=mscTdmaCsT308, mscTdmaCsStateTable=mscTdmaCsStateTable, mscTdmaCsErroredLFrames=mscTdmaCsErroredLFrames, mscTdmaCsV42T401AckTimer=mscTdmaCsV42T401AckTimer, mscTdmaCsMiscProvTable=mscTdmaCsMiscProvTable, mscTdmaCsRlp1RowStatusEntry=mscTdmaCsRlp1RowStatusEntry, mscTdmaBcUrStorageType=mscTdmaBcUrStorageType, mscTdmaBcRlp1StorageType=mscTdmaBcRlp1StorageType, mscTdmaCsRlp1ComponentName=mscTdmaCsRlp1ComponentName, mscTdmaBcFramerIndex=mscTdmaBcFramerIndex, mscTdmaCsRlp1T3PeerAckTimer=mscTdmaCsRlp1T3PeerAckTimer, mscTdmaBcRlp1RxFrames=mscTdmaBcRlp1RxFrames)

#
# PySNMP MIB module XYLAN-WSM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-WSM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter64, Unsigned32, IpAddress, iso, NotificationType, MibIdentifier, ObjectIdentity, Bits, TimeTicks, ModuleIdentity, Counter32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter64", "Unsigned32", "IpAddress", "iso", "NotificationType", "MibIdentifier", "ObjectIdentity", "Bits", "TimeTicks", "ModuleIdentity", "Counter32", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
xylanWsmArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanWsmArch")
wsmPortGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 7, 1))
wsmLinkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 7, 2))
wsmPortTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1), )
if mibBuilder.loadTexts: wsmPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortTable.setDescription("A table of port layer status and parameter information for the WSM's physical interfaces.")
wsmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1), ).setIndexNames((0, "XYLAN-WSM-MIB", "wsmPortSlotIndex"), (0, "XYLAN-WSM-MIB", "wsmPortPortIndex"))
if mibBuilder.loadTexts: wsmPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortEntry.setDescription('An entry in the table, containing information about the physical layer of a WSM interface.')
wsmPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsmPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortSlotIndex.setDescription('A unique value which identifies this HSM board slot.')
wsmPortPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsmPortPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortPortIndex.setDescription('A unique value which identifies this WSM submodule port.')
wsmPortInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("universalSerial", 1), ("isdnBRI", 2), ("ds1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsmPortInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortInterfaceType.setDescription('The type of interface on this WSM physical port.')
wsmPortCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("noneAttached", 1), ("indeterminate", 2), ("unknown", 3), ("rs232DTE", 4), ("rs232DCE", 5), ("v35DTE", 6), ("v35DCE", 7), ("rs530DTE", 8), ("rs530DCE", 9), ("x21DTE", 10), ("x21DCE", 11), ("isdnU", 12), ("isdnSt", 13), ("t1", 14), ("e1", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsmPortCableType.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortCableType.setDescription("The type of cable attached to the universal serial port. Non Universal Serial Ports will always return 'unknown'. NOTE: RS-449 cables will return as RS-530 as they are detected as the same type. RS-449 is implemented only as a different connector (DB-37 instead of DB-25) on the end of the cable.")
wsmPortSerialRxClockPol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("non-inverted", 1), ("inverted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsmPortSerialRxClockPol.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortSerialRxClockPol.setDescription('The receive clock polarity. It is inverted or not inverted. For interfaces that do not support this, the value will be stored but ignored.')
wsmPortSerialTxClockPol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("non-inverted", 1), ("inverted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsmPortSerialTxClockPol.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortSerialTxClockPol.setDescription('The Transmit clock polarity. It is inverted or not inverted. For interfaces that do not support this, the value will be stored but ignored.')
wsmPortFunctionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameType", 1), ("cellType", 2), ("cbrType", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsmPortFunctionType.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortFunctionType.setDescription("The functional capability of the port. This allows the Manager code to determine the capabilities of the port so the proper data can be managed based on the functions the WAN port can provide. A 'frameType' port supports layer 2 protocols such as HDLC and Frame Relay. A 'cellType' performs ATM interface functions such as ATM T1 UNI interface. A 'cbrType' port is used to perform Bit to Cell Conversion (AAL1).")
wsmPortProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("frameRelay", 2), ("ppp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsmPortProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortProtocol.setDescription("The layer 2 protocol of the port. This parameter only applies when wsmPortFunctionType is equal to frameType(1). For ports that don't support this (e.g. Circuit Emulation T1 ports) only a value of none(1) is supported. For ports that support upper layer protocols (frameType ports) a value other than none must be used.")
wsmPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsmPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortIfIndex.setDescription('The ifIndex of the WAN port. This parameter is used in order to get the physical port Index used for SNMP standard MIBs that use ifIndex instead of slot/port.')
wsmPortT1E1StartingTimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsmPortT1E1StartingTimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortT1E1StartingTimeSlot.setDescription('Starting TimeSlot for Fractional T1E1 board. This is only use for Fractional T1E1 board type. Valid Range: T1: 1..24 E1: 1..31 (May need to skip 16) The valid range may be effected by wsmPortT1E1NumberOfTimeSlot too.')
wsmPortT1E1NumberOfTimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsmPortT1E1NumberOfTimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wsmPortT1E1NumberOfTimeSlot.setDescription('Number of TimeSlot for Fractional T1E1 board. This is only use for Fractional T1E1 board type. Valid Range: T1: 1..24 E1: 1..31 The valid range may be effected by wsmPortT1E1NumberOfTimeSlot too.')
linkxTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1), )
if mibBuilder.loadTexts: linkxTable.setStatus('mandatory')
if mibBuilder.loadTexts: linkxTable.setDescription('A table of WAN link(s) configuration information.')
linkxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1), ).setIndexNames((0, "XYLAN-WSM-MIB", "linkxPeerID"), (0, "XYLAN-WSM-MIB", "linkxIfIndex"))
if mibBuilder.loadTexts: linkxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: linkxEntry.setDescription("An entry in the WAN link Configuration table, containing information about a single link's configuration.")
linkxPeerID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkxPeerID.setStatus('mandatory')
if mibBuilder.loadTexts: linkxPeerID.setDescription("The peer ID. This is used as a unique ID to identify a remote entity and to associate links to it. For example, for 'normal' PPP, there is one entry in the link table. For Multilink PPP there are one or more multiple links. In either case the Link table is indexed by Link index (one per link) and by Peer ID. When one or more entrys in the link table has the same Peer ID, then these entries form a group for use either for Multilink PPP, or as a rotary group.")
linkxIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkxIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: linkxIfIndex.setDescription('The ifIndex of the Link. This is used as a unique ID to identify an individual WAN link entity.')
linkxDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkxDescription.setStatus('mandatory')
if mibBuilder.loadTexts: linkxDescription.setDescription('A description for this WAN link.')
linkxAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkxAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: linkxAdminStatus.setDescription('This object controls the Administrative Status of this WAN Link Entity. Enabled will allow the Link Entity to operate. Disabled will disable the Link Entity without deleting it. Delete will disable the Link entity and delete the PPP configuration record.')
linkxType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wsmPort", 1), ("isdnCall", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkxType.setStatus('mandatory')
if mibBuilder.loadTexts: linkxType.setDescription('The type of link. A wsmPort type is for WSM serial and Fractional T1 ports. An ISDN call is for incoming or outgoing ISDN calls. Additional information can then be found in Xylan and Standard MIBs based on the type of the link.')
linkxSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkxSlot.setStatus('mandatory')
if mibBuilder.loadTexts: linkxSlot.setDescription('The slot that is Link is on or zero if the link is not tied to a given slot (e.g. for ISDN incoming calls). If type is wsmPort(1), this must be a non-zero value.')
linkxPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkxPort.setStatus('mandatory')
if mibBuilder.loadTexts: linkxPort.setDescription('The port that is Link is on or zero if the link is not tied to a given port (e.g. for ISDN incoming calls or Multilink PPP that requires to run Multilink with combined serial ports and ISDN calls on the same slot, but not necessarily fixed to a given ISDN port on that slot). If type is wsmPort(1), this must be a non-zero value.')
linkxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 7, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ondemand", 1), ("backup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkxMode.setStatus('mandatory')
if mibBuilder.loadTexts: linkxMode.setDescription('This object define whether the given link is to be a On-Demand Link or it is use for Backup.')
mibBuilder.exportSymbols("XYLAN-WSM-MIB", linkxIfIndex=linkxIfIndex, wsmPortCableType=wsmPortCableType, wsmPortPortIndex=wsmPortPortIndex, wsmPortSlotIndex=wsmPortSlotIndex, wsmPortT1E1NumberOfTimeSlot=wsmPortT1E1NumberOfTimeSlot, wsmPortFunctionType=wsmPortFunctionType, wsmPortInterfaceType=wsmPortInterfaceType, wsmPortProtocol=wsmPortProtocol, linkxEntry=linkxEntry, linkxType=linkxType, wsmPortGroup=wsmPortGroup, linkxPeerID=linkxPeerID, linkxSlot=linkxSlot, wsmPortTable=wsmPortTable, linkxAdminStatus=linkxAdminStatus, linkxMode=linkxMode, linkxPort=linkxPort, wsmPortEntry=wsmPortEntry, linkxTable=linkxTable, linkxDescription=linkxDescription, wsmLinkGroup=wsmLinkGroup, wsmPortSerialTxClockPol=wsmPortSerialTxClockPol, wsmPortSerialRxClockPol=wsmPortSerialRxClockPol, wsmPortT1E1StartingTimeSlot=wsmPortT1E1StartingTimeSlot, wsmPortIfIndex=wsmPortIfIndex)

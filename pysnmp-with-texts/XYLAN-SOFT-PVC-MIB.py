#
# PySNMP MIB module XYLAN-SOFT-PVC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-SOFT-PVC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:22 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Counter64, ModuleIdentity, Gauge32, Integer32, IpAddress, MibIdentifier, NotificationType, Counter32, Unsigned32, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Counter64", "ModuleIdentity", "Gauge32", "Integer32", "IpAddress", "MibIdentifier", "NotificationType", "Counter32", "Unsigned32", "ObjectIdentity", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanCsmArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanCsmArch")
AtmxTrafficDescrParamIndex, = mibBuilder.importSymbols("XYLAN-CSM-MIB", "AtmxTrafficDescrParamIndex")
atmxSoftPvcMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2))
atmxSoftPvcMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1))
atmxSoftPvcMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 2))
class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class AtmxSoftPvcBbcIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2048)

atmxSoftPvcBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 1))
atmxSoftPvcCallFailuresTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcCallFailuresTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcCallFailuresTrapEnable.setDescription("Allows the generation of traps in response to call failures. By default, this object is set to 'false'.")
atmxSoftPvcCallFailures = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSoftPvcCallFailures.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcCallFailures.setDescription('The number of times a series of call attempts has failed to establish a Soft PVCC or Soft PVPC. The number of call attempts in a series is determined by atmSoftPVccRetryThreshold or atmSoftPVpcRetryThreshold, respectively.')
atmxSoftPvcCurrentlyFailingSoftPVccs = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSoftPvcCurrentlyFailingSoftPVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcCurrentlyFailingSoftPVccs.setDescription("The current number of Soft PVCCs for which there is an active row in the atmSoftPVccTable having an atmSoftPVccOperStatus with a value other than 'connected'.")
atmxSoftPvcCurrentlyFailingSoftPVpcs = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxSoftPvcCurrentlyFailingSoftPVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcCurrentlyFailingSoftPVpcs.setDescription("The current number of Soft PVPCs for which there is an active row in the atmSoftPVpcTable having an atmSoftPVpcOperStatus with a value other than 'connected'.")
atmxSoftPvcNotificationInterval = MibScalar((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 1, 5), Integer32().clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcNotificationInterval.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcNotificationInterval.setDescription('The minimum interval between the sending of atmSoftPvcCallFailuresTrap notifications.')
atmxCurrentlyFailingSoftPVccTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2), )
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccTable.setDescription("A table indicating all Soft Permanent Virtual Channel Connections (Soft PVCCs) for which the atmSoftPVccRowStatus is 'active' and the atmSoftPVccOperStatus is other than 'connected'.")
atmxCurrentlyFailingSoftPVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1), ).setIndexNames((0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVccSlotIndex"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVccPortIndex"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVccVpi"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVccVci"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVccLeafReference"))
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccEntry.setDescription("Each entry in this table represents a Soft Permanent Virtual Channel Connection (Soft PVCC) for which the atmSoftPVccRowStatus is 'active' and the atmSoftPVccOperStatus is other than 'connected'.")
atmxCurrentlyFailingSoftPVccSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccSlotIndex.setDescription('The slot instance')
atmxCurrentlyFailingSoftPVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1, 2), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccPortIndex.setDescription('The port instance')
atmxCurrentlyFailingSoftPVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1, 3), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccVpi.setDescription('The vpi instance')
atmxCurrentlyFailingSoftPVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1, 4), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccVci.setDescription('The vci instance')
atmxCurrentlyFailingSoftPVccLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1, 5), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccLeafReference.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccLeafReference.setDescription('The leaf reference')
atmxCurrentlyFailingSoftPVccTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVccTimeStamp.setDescription('The time at which this Soft PVCC began to fail.')
atmxCurrentlyFailingSoftPVpcTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3), )
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcTable.setDescription("A table indicating all Soft Permanent Virtual Path Connections (Soft PVPCs) for which the atmSoftPVpcRowStatus is 'active' and the atmSoftPVpcOperStatus is other than 'connected'.")
atmxCurrentlyFailingSoftPVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3, 1), ).setIndexNames((0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVpcSlotIndex"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVpcPortIndex"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVpcVpi"), (0, "XYLAN-SOFT-PVC-MIB", "atmxCurrentlyFailingSoftPVpcLeafReference"))
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcEntry.setDescription("Each entry in this table represents a Soft Permanent Virtual Path Connection (Soft PVPC) for which the atmSoftPVpcRowStatus is 'active' and the atmSoftPVpcOperStatus is other than 'connected'.")
atmxCurrentlyFailingSoftPVpcSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcSlotIndex.setDescription('The slot instance')
atmxCurrentlyFailingSoftPVpcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3, 1, 2), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcPortIndex.setDescription('The port instance')
atmxCurrentlyFailingSoftPVpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3, 1, 3), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcVpi.setDescription('The vpi instance')
atmxCurrentlyFailingSoftPVpcLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3, 1, 4), Integer32())
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcLeafReference.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcLeafReference.setDescription('The leaf reference')
atmxCurrentlyFailingSoftPVpcTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCurrentlyFailingSoftPVpcTimeStamp.setDescription('The time at which this Soft PVPC began to fail.')
xylnatmSoftPVpcTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4), )
if mibBuilder.loadTexts: xylnatmSoftPVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcTable.setDescription('The (conceptual) table used to manage Soft Permanent Virtual Path Connections (Soft PVPCs) The Soft PVPC table is applicable only to switches.')
xylnatmSoftPVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1), ).setIndexNames((0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVpcSlotIndex"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVpcPortIndex"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVpcVpi"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVpcLeafReference"))
if mibBuilder.loadTexts: xylnatmSoftPVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcEntry.setDescription('Each entry in this table represents a Soft Permanent Virtual Path Connection (Soft PVPC) originating at a switch interface. A Soft PVPC is a VPC that is: - provisioned at the originating (source) interface of the connection - established by signalling procedures across a network to a destination interface. When a row is made active, an attempt is made to set up a switched connection to an interface at the destination switch. No objects (other than atmSoftPVpcRowStatus) can be set while the row is active. At the destination, the VPL may be defined (but not cross-connected) prior to arrival of the Setup request. The combination of slot/port, atmVplVpi specified in the index clause of this entry serves to identify the VPL on the source interface. The atmSoftPVpcLeafReference object aids in distinguishing between leaves of a point-to-multipoint Soft PVPC.')
xylnatmSoftPVpcSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcSlotIndex.setDescription('The slot index for this vpc')
xylnatmSoftPVpcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcPortIndex.setDescription('The port number')
xylnatmSoftPVpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcVpi.setDescription('The VPI value of the VPL used at the in interface.')
xylnatmSoftPVpcLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcLeafReference.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcLeafReference.setDescription('The leaf reference for this Vpl')
xylnatmSoftPVpcTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcTargetAddress.setDescription('The target ATM Address of this Soft PVPC.')
xylnatmSoftPVpcTargetSelectType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("required", 1), ("any", 2))).clone('required')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcTargetSelectType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcTargetSelectType.setDescription("Indicates whether the target VPI value is to be used at the destination. If the value 'any' is specified, the destination switch will choose the VPI value. In such a case, once the Soft PVPC atmSoftPVpcOperStatus value is 'connected', the value of this object changes to 'required', such that the same VPI value will continue to be used even if the connection is subsequently torn down and re-established. The VPI value chosen will be available for reading in atmSoftPVpcTargetVpi. If the value 'required' is specified, then a value must be supplied for object atmSoftPVpcTargetVpi prior to activation of the row. This value is then to be used at the destination.")
xylnatmSoftPVpcTargetVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcTargetVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcTargetVpi.setDescription("The VPI value of the VPL used at the target interface. This value must be filled in when the atmSoftPVpcTargetSelectType is set to 'required'. This value is not relevant when the value of atmSoftPVpcTargetSelectType is 'any'.")
xylnatmSoftPVpcLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcLastReleaseCause.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcLastReleaseCause.setDescription('Value of the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVPC. Indicates the reason for the Release.')
xylnatmSoftPVpcLastReleaseDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcLastReleaseDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcLastReleaseDiagnostic.setDescription('Value of the first 8 bytes of diagnostic information from the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVPC.')
xylnatmSoftPVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcOperStatus.setDescription("Describes the status of the Soft PVPC. When the row is not 'active', the value of this object is 'other'.")
xylnatmSoftPVpcRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcRestart.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRestart.setDescription("When the value is set to 'restart', the Soft PVPC is released if necessary and a new setup procedure is begun. As a result of this action, the atmSoftPVpcOperStatus object transitions to 'establishmentInProgress' (if not already in this state) and the atmSoftPVpcRetryFailures object is cleared. When the value is set to 'noop', no operation is performed. When read, the value 'noop' is returned.")
xylnatmSoftPVpcRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryInterval.setDescription('Defines the period to wait before attempting to establish the Soft PVPC connection after the first failed call attempt. Zero represents an infinite interval indicating no retries.')
xylnatmSoftPVpcRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryTimer.setDescription('Indicates the current value of the retry timer for this connection. When the value reaches zero an attempt will be made to establish the Soft PVPC. When the timer is not running, the value zero shall be returned.')
xylnatmSoftPVpcRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryThreshold.setDescription('Indicates the number of consecutive call setup attempts for the same Soft PVPC which need to fail before the atmSoftPvcCallFailures object is incremented. A value of zero indicates that an infinite number of call attempts are required to increment the atmSoftPvcCallFailures object and thus disables alarms for the Soft PVPC.')
xylnatmSoftPVpcRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryFailures.setDescription('Indicates how many attempts to establish the connection have failed. This count is reset whenever a connection is successfully established or the Soft PVPC is restarted.')
xylnatmSoftPVpcRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful call setup attempts can be made before stopping the attempt to set up the connection. If this limit is reached then management action will be required (e.g. setting atmSoftPVpcRestart to 'restart') to initiate a new attempt to establish the connection. A value of zero indicates no limit - the attempts will continue until successful.")
xylnatmSoftPVpcLowTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 17), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcLowTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcLowTDIndex.setDescription(' The low end Traffic Descriptor ..refer rfc1695 for details')
xylnatmSoftPVpcHighTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 18), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcHighTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcHighTDIndex.setDescription('The high end of the TD')
xylnatmSoftPVpcLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcLastChange.setDescription('The value of MIB II sysUptime object at the time this VPL entered its current op state.')
xylnatmSoftPVpcOutSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcOutSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcOutSlot.setDescription(' The outgoing slot once the connection is established..else its 0')
xylnatmSoftPVpcOutPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcOutPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcOutPort.setDescription('The out going slot if the connection is established..else its 0')
xylnatmSoftPVpcOutVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcOutVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcOutVpi.setDescription('The outgoing vpi if established..else 0')
xylnatmSoftPVpcAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcAdminStatus.setDescription('The admin status of the VPL')
xylnatmSoftPVpcCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVpcCrossConnectIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcCrossConnectIdentifier.setDescription('A unique non-zero value if the VPL is exiting the switch apart from the input')
xylnatmSoftPVpcBbcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcBbcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcBbcIndex.setDescription('The BBC Index from the BBC Table')
xylnatmSoftPVpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 4, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVpcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVpcRowStatus.setDescription('Used to create and delete a Soft PVPC.')
xylnatmSoftPVccTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5), )
if mibBuilder.loadTexts: xylnatmSoftPVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccTable.setDescription('The (conceptual) table used to manage Soft Permanent Virtual Channel Connections (Soft PVCCs). The Soft PVCC table is applicable only to switches.')
xylnatmSoftPVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1), ).setIndexNames((0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVccSlotIndex"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVccPortIndex"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVccVpi"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVccVci"), (0, "XYLAN-SOFT-PVC-MIB", "xylnatmSoftPVccLeafReference"))
if mibBuilder.loadTexts: xylnatmSoftPVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccEntry.setDescription('Each entry in this table represents a Soft Permanent Virtual Channel Connection (Soft PVCC) originating at a switch interface. When a row is made active, an attempt is made to set up a switched connection to an interface at the destination switch. No objects (other than atmSoftPVccRowStatus) can be set while the row is active. At the destination, the VCL may be defined (but not cross-connected) prior to arrival of the Setup request. The combination of Slot/Port, atmVclVpi, and atmVclVci specified in the index clause of this entry serves to identify the VCL on the source interface. The atmSoftPVccLeafReference object aids in distinguishing between leaves of a point-to-multipoint Soft PVCC.')
xylnatmSoftPVccSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccSlotIndex.setDescription('Slot Instance')
xylnatmSoftPVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccPortIndex.setDescription('Port Instance')
xylnatmSoftPVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccVpi.setDescription('Vpi instance')
xylnatmSoftPVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccVci.setDescription('Vcl instance')
xylnatmSoftPVccLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccLeafReference.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccLeafReference.setDescription("An arbitrary integer which, in the case of the source VCL having an atmVclCastType of 'p2mpRoot', serves to distinguish between the multiple leaves attached to a root of a point-to-multipoint Soft PVCC. If the atmVclCastType is not 'p2mpRoot' the value 1 shall be used.")
xylnatmSoftPVccTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccTargetAddress.setDescription('The target ATM Address of this Soft PVCC.')
xylnatmSoftPVccTargetSelectType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("required", 1), ("any", 2))).clone('required')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccTargetSelectType.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccTargetSelectType.setDescription("Indicates whether the target VPI/VCI values are to be used at the destination. If the value 'any' is specified, the destination switch will choose the VPI/VCI values. In such a case, once the Soft PVCC atmSoftPVccOperStatus value is 'connected', the value of this object changes to 'required', such that the same VPI/VCI values will continue to be used even if the connection is subsequently torn down and re-established. The VPI/VCI values chosen will be available for reading in atmSoftPVccTargetVpi and atmSoftPVccTargetVci. If the value 'required' is specified, then values must be supplied for objects atmSoftPVccTargetVpi and atmSoftPVccTargetVci prior to activation of the row. These values are then to be used at the destination.")
xylnatmSoftPVccTargetVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccTargetVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccTargetVpi.setDescription("The VPI value of the VCL used at the target interface. This value is not relevant when the value of atmSoftPVccTargetSelectType is 'any'.")
xylnatmSoftPVccTargetVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccTargetVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccTargetVci.setDescription("The VCI value of the VCL used at the target interface. This value must be filled in when the atmSoftPVccTargetSelectType is set to 'required'.This value is not relevant when the value of atmSoftPVccTargetSelectType is 'any'.")
xylnatmSoftPVccLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccLastReleaseCause.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccLastReleaseCause.setDescription('Value of the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVCC. Indicates the reason for the Release.')
xylnatmSoftPVccLastReleaseDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccLastReleaseDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccLastReleaseDiagnostic.setDescription('Value of the first 8 bytes of diagnostic information from the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVCC.')
xylnatmSoftPVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccOperStatus.setDescription("Describes the status of the Soft PVCC. When the row is not 'active', the value of this object is 'other'.")
xylnatmSoftPVccRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccRestart.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRestart.setDescription("When the value is set to 'restart' the Soft PVCC is released if necessary and a new setup procedure is begun. As a result of this action, the atmSoftPVccOperStatus object transitions to 'establishmentInProgress' (if not already in this state) and the atmSoftPVccRetryFailures object is cleared When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
xylnatmSoftPVccRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 14), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRetryInterval.setDescription('Defines the period to wait before attempting to establish the Soft PVC after the first failed call attempt. Zero represents an infinite interval indicating no retries.')
xylnatmSoftPVccRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRetryTimer.setDescription('Indicates the current value of the retry timer for this connection. When the value reaches zero an attempt will be made to establish the Soft PVCC. When the timer is not running, the value zero shall be returned.')
xylnatmSoftPVccRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 16), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccRetryThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRetryThreshold.setDescription('Indicates the number of consecutive call setup attempts for the same Soft PVCC which need to fail before the atmSoftPvcCallFailures object is incremented. A value of zero indicates that an infinite number of call attempts are required to increment the atmSoftPvcCallFailures object and thus disables alarms for the Soft PVCC.')
xylnatmSoftPVccRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccRetryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRetryFailures.setDescription('Indicates how many attempts to establish the connection have failed. This count is reset whenever a connection is successfully established or the Soft PVCC is restarted.')
xylnatmSoftPVccRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful call setup attempts can be made before stopping the attempt to set up the connection. If this limit is reached then management action will be required (e.g. setting atmSoftPVccRestart to 'restart') to initiate a new attempt to establish the connection. A value of zero indicates no limit - the attempts will continue until successful.")
xylnatmSoftPVccLowTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 19), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccLowTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccLowTDIndex.setDescription(' The low end TD...Refer 1695 for interpretation')
xylnatmSoftPVccHighTDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 20), AtmxTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccHighTDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccHighTDIndex.setDescription('The high end TD')
xylnatmSoftPVccLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccLastChange.setDescription(' The value of MIB II sysUpTime at the time this VCL entered its current operational state. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value')
xylnatmSoftPVccOutSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccOutSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccOutSlot.setDescription('The outgoing slot if the connection has been established..else 0')
xylnatmSoftPVccOutPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccOutPort.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccOutPort.setDescription('The outgoing port...')
xylnatmSoftPVccOutVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccOutVpi.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccOutVpi.setDescription('The outgoing vpi')
xylnatmSoftPVccOutVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccOutVci.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccOutVci.setDescription('The outgoing vci..')
xylnatmSoftPVccAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccAdminStatus.setDescription('The admin status of this VCL')
xylnatmSoftPVccCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylnatmSoftPVccCrossConnectIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccCrossConnectIdentifier.setDescription('A non zero value if the VCL is cross-connected')
xylnatmSoftPVccBbcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccBbcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccBbcIndex.setDescription('The BBC Index from the BBC Table')
xylnatmSoftPVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 5, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylnatmSoftPVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xylnatmSoftPVccRowStatus.setDescription('Used to create and delete a Soft PVCC.')
atmxSoftPvcBbcTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6), )
if mibBuilder.loadTexts: atmxSoftPvcBbcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcTable.setDescription('This table contains information related to ATM bearer capability type and associated parameters.')
atmxSoftPvcBbcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1), ).setIndexNames((0, "XYLAN-SOFT-PVC-MIB", "atmxSoftPvcBbcIndex"))
if mibBuilder.loadTexts: atmxSoftPvcBbcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcEntry.setDescription('An entry in this table is used to specify the bearer capa- bility of a given soft PVC.')
atmxSoftPvcBbcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 1), AtmxSoftPvcBbcIndex())
if mibBuilder.loadTexts: atmxSoftPvcBbcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcIndex.setDescription('Identifies an entry in the atmSoftPvcBbcTable.')
atmxSoftPvcBbcClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bcobA", 1), ("bcobC", 2), ("bcobX", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcBbcClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcClass.setDescription('Indicates the broadband bearer capability class.')
atmxSoftPvcBbcTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noIndication", 1), ("constantBitRate", 2), ("variableBitRate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcBbcTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcTrafficType.setDescription('Indicates the broadband bearer capability traffic class.')
atmxSoftPvcBbcTimingRequirements = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noIndication", 1), ("endToEndTimingRequired", 2), ("endToEndTimingNotRequired", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcBbcTimingRequirements.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcTimingRequirements.setDescription('Indicates the broadband bearer capability timing requirements.')
atmxSoftPvcBbcSusceptibilityToClipping = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("susceptibleToClipping", 1), ("notSusceptibleToClipping", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcBbcSusceptibilityToClipping.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcSusceptibilityToClipping.setDescription('Indicates the broadband bearer capability susceptibility to clipping parameter.')
atmxSoftPvcBbcUserPlaneConnectionConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("point-to-point", 1), ("point-to-multipoint", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcBbcUserPlaneConnectionConfig.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcUserPlaneConnectionConfig.setDescription('Indicates the broadband bearer capability user plane configuration parmmeter.')
atmxSoftPvcBbcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxSoftPvcBbcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxSoftPvcBbcRowStatus.setDescription("This object is used to create, modify, and delete rows in the 'atmSoftPvcBbcTable'.")
atmxSoftPvcTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 2, 1))
atmxSoftPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 2, 1, 1))
atmxSoftPvcCallFailuresTrap = NotificationType((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 2, 1, 1) + (0,1)).setObjects(("XYLAN-SOFT-PVC-MIB", "atmxSoftPvcCallFailures"), ("XYLAN-SOFT-PVC-MIB", "atmxSoftPvcCurrentlyFailingSoftPVccs"), ("XYLAN-SOFT-PVC-MIB", "atmxSoftPvcCurrentlyFailingSoftPVpcs"))
if mibBuilder.loadTexts: atmxSoftPvcCallFailuresTrap.setDescription('A notification indicating that one or more series of call attempts in trying to establish a Soft PVPC or Soft PVCC have failed since the last atmSoftPvcCallFailureTrap was sent. If this trap has not been sent for the last atmSoftPvcNotificationInterval, then it will be sent on the next increment of atmSoftPvcCallFailures.')
atmxSoftPvcMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3))
atmxSoftPvcMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 1))
atmxSoftPvcMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2))
atmxSoftPvcMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 1, 1))
atmxSoftPvcBaseMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2, 1))
atmxSoftPvcVccMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2, 2))
atmxSoftPvcVpcMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2, 3))
atmxSoftPvcAddressMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2, 4))
atmxCurrentlyFailingSoftPVccMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2, 5))
atmxCurrentlyFailingSoftPVpcMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 9, 2, 3, 2, 6))
mibBuilder.exportSymbols("XYLAN-SOFT-PVC-MIB", xylnatmSoftPVccVci=xylnatmSoftPVccVci, xylnatmSoftPVpcAdminStatus=xylnatmSoftPVpcAdminStatus, xylnatmSoftPVpcHighTDIndex=xylnatmSoftPVpcHighTDIndex, xylnatmSoftPVccBbcIndex=xylnatmSoftPVccBbcIndex, atmxSoftPvcCurrentlyFailingSoftPVpcs=atmxSoftPvcCurrentlyFailingSoftPVpcs, xylnatmSoftPVpcLastChange=xylnatmSoftPVpcLastChange, xylnatmSoftPVpcCrossConnectIdentifier=xylnatmSoftPVpcCrossConnectIdentifier, atmxCurrentlyFailingSoftPVccTimeStamp=atmxCurrentlyFailingSoftPVccTimeStamp, atmxSoftPvcMIBCompliances=atmxSoftPvcMIBCompliances, atmxCurrentlyFailingSoftPVccTable=atmxCurrentlyFailingSoftPVccTable, atmxSoftPvcBbcSusceptibilityToClipping=atmxSoftPvcBbcSusceptibilityToClipping, atmxSoftPvcMIBTraps=atmxSoftPvcMIBTraps, xylnatmSoftPVpcTargetSelectType=xylnatmSoftPVpcTargetSelectType, atmxSoftPvcBbcClass=atmxSoftPvcBbcClass, atmxSoftPvcAddressMIBGroup=atmxSoftPvcAddressMIBGroup, atmxCurrentlyFailingSoftPVpcTable=atmxCurrentlyFailingSoftPVpcTable, xylnatmSoftPVccLeafReference=xylnatmSoftPVccLeafReference, xylnatmSoftPVpcLowTDIndex=xylnatmSoftPVpcLowTDIndex, xylnatmSoftPVpcOutVpi=xylnatmSoftPVpcOutVpi, xylnatmSoftPVccRetryTimer=xylnatmSoftPVccRetryTimer, xylnatmSoftPVccLowTDIndex=xylnatmSoftPVccLowTDIndex, xylnatmSoftPVccAdminStatus=xylnatmSoftPVccAdminStatus, atmxSoftPvcBbcRowStatus=atmxSoftPvcBbcRowStatus, xylnatmSoftPVccRowStatus=xylnatmSoftPVccRowStatus, atmxSoftPvcBaseMIBGroup=atmxSoftPvcBaseMIBGroup, xylnatmSoftPVccRestart=xylnatmSoftPVccRestart, atmxSoftPvcMIBGroups=atmxSoftPvcMIBGroups, xylnatmSoftPVpcRetryThreshold=xylnatmSoftPVpcRetryThreshold, atmxSoftPvcTrapsPrefix=atmxSoftPvcTrapsPrefix, atmxSoftPvcVccMIBGroup=atmxSoftPvcVccMIBGroup, atmxCurrentlyFailingSoftPVccLeafReference=atmxCurrentlyFailingSoftPVccLeafReference, xylnatmSoftPVccOutVpi=xylnatmSoftPVccOutVpi, atmxCurrentlyFailingSoftPVpcSlotIndex=atmxCurrentlyFailingSoftPVpcSlotIndex, xylnatmSoftPVpcRowStatus=xylnatmSoftPVpcRowStatus, xylnatmSoftPVccSlotIndex=xylnatmSoftPVccSlotIndex, atmxCurrentlyFailingSoftPVccMIBGroup=atmxCurrentlyFailingSoftPVccMIBGroup, atmxCurrentlyFailingSoftPVccSlotIndex=atmxCurrentlyFailingSoftPVccSlotIndex, atmxSoftPvcBaseGroup=atmxSoftPvcBaseGroup, xylnatmSoftPVccTable=xylnatmSoftPVccTable, atmxSoftPvcTraps=atmxSoftPvcTraps, xylnatmSoftPVpcRetryTimer=xylnatmSoftPVpcRetryTimer, xylnatmSoftPVpcLeafReference=xylnatmSoftPVpcLeafReference, xylnatmSoftPVpcRestart=xylnatmSoftPVpcRestart, atmxSoftPvcCallFailuresTrap=atmxSoftPvcCallFailuresTrap, atmxCurrentlyFailingSoftPVpcEntry=atmxCurrentlyFailingSoftPVpcEntry, xylnatmSoftPVccLastChange=xylnatmSoftPVccLastChange, xylnatmSoftPVccTargetVci=xylnatmSoftPVccTargetVci, xylnatmSoftPVccLastReleaseDiagnostic=xylnatmSoftPVccLastReleaseDiagnostic, atmxSoftPvcCallFailuresTrapEnable=atmxSoftPvcCallFailuresTrapEnable, xylnatmSoftPVpcOperStatus=xylnatmSoftPVpcOperStatus, atmxCurrentlyFailingSoftPVccPortIndex=atmxCurrentlyFailingSoftPVccPortIndex, atmxSoftPvcCurrentlyFailingSoftPVccs=atmxSoftPvcCurrentlyFailingSoftPVccs, xylnatmSoftPVccOutSlot=xylnatmSoftPVccOutSlot, xylnatmSoftPVccCrossConnectIdentifier=xylnatmSoftPVccCrossConnectIdentifier, atmxSoftPvcBbcEntry=atmxSoftPvcBbcEntry, xylnatmSoftPVccOutPort=xylnatmSoftPVccOutPort, xylnatmSoftPVpcLastReleaseCause=xylnatmSoftPVpcLastReleaseCause, atmxCurrentlyFailingSoftPVpcPortIndex=atmxCurrentlyFailingSoftPVpcPortIndex, AtmxSoftPvcBbcIndex=AtmxSoftPvcBbcIndex, xylnatmSoftPVpcEntry=xylnatmSoftPVpcEntry, xylnatmSoftPVpcOutSlot=xylnatmSoftPVpcOutSlot, xylnatmSoftPVpcOutPort=xylnatmSoftPVpcOutPort, atmxSoftPvcBbcTimingRequirements=atmxSoftPvcBbcTimingRequirements, TruthValue=TruthValue, xylnatmSoftPVpcPortIndex=xylnatmSoftPVpcPortIndex, atmxSoftPvcMIBObjects=atmxSoftPvcMIBObjects, atmxCurrentlyFailingSoftPVpcVpi=atmxCurrentlyFailingSoftPVpcVpi, xylnatmSoftPVccEntry=xylnatmSoftPVccEntry, xylnatmSoftPVccTargetVpi=xylnatmSoftPVccTargetVpi, atmxSoftPvcVpcMIBGroup=atmxSoftPvcVpcMIBGroup, xylnatmSoftPVccRetryThreshold=xylnatmSoftPVccRetryThreshold, xylnatmSoftPVpcRetryFailures=xylnatmSoftPVpcRetryFailures, xylnatmSoftPVccTargetSelectType=xylnatmSoftPVccTargetSelectType, xylnatmSoftPVccRetryLimit=xylnatmSoftPVccRetryLimit, xylnatmSoftPVccPortIndex=xylnatmSoftPVccPortIndex, xylnatmSoftPVpcLastReleaseDiagnostic=xylnatmSoftPVpcLastReleaseDiagnostic, xylnatmSoftPVpcRetryLimit=xylnatmSoftPVpcRetryLimit, xylnatmSoftPVpcVpi=xylnatmSoftPVpcVpi, atmxSoftPvcCallFailures=atmxSoftPvcCallFailures, atmxCurrentlyFailingSoftPVpcLeafReference=atmxCurrentlyFailingSoftPVpcLeafReference, xylnatmSoftPVccHighTDIndex=xylnatmSoftPVccHighTDIndex, atmxCurrentlyFailingSoftPVccEntry=atmxCurrentlyFailingSoftPVccEntry, xylnatmSoftPVpcTargetVpi=xylnatmSoftPVpcTargetVpi, xylnatmSoftPVpcRetryInterval=xylnatmSoftPVpcRetryInterval, xylnatmSoftPVccLastReleaseCause=xylnatmSoftPVccLastReleaseCause, atmxSoftPvcMIBCompliance=atmxSoftPvcMIBCompliance, atmxCurrentlyFailingSoftPVpcTimeStamp=atmxCurrentlyFailingSoftPVpcTimeStamp, xylnatmSoftPVpcSlotIndex=xylnatmSoftPVpcSlotIndex, atmxSoftPvcBbcIndex=atmxSoftPvcBbcIndex, atmxCurrentlyFailingSoftPVccVpi=atmxCurrentlyFailingSoftPVccVpi, atmxSoftPvcBbcTrafficType=atmxSoftPvcBbcTrafficType, xylnatmSoftPVpcTable=xylnatmSoftPVpcTable, atmxSoftPvcNotificationInterval=atmxSoftPvcNotificationInterval, atmxSoftPvcMIBConformance=atmxSoftPvcMIBConformance, xylnatmSoftPVccOperStatus=xylnatmSoftPVccOperStatus, xylnatmSoftPVccRetryInterval=xylnatmSoftPVccRetryInterval, xylnatmSoftPVccRetryFailures=xylnatmSoftPVccRetryFailures, atmxCurrentlyFailingSoftPVpcMIBGroup=atmxCurrentlyFailingSoftPVpcMIBGroup, xylnatmSoftPVpcBbcIndex=xylnatmSoftPVpcBbcIndex, xylnatmSoftPVpcTargetAddress=xylnatmSoftPVpcTargetAddress, atmxCurrentlyFailingSoftPVccVci=atmxCurrentlyFailingSoftPVccVci, atmxSoftPvcMIB=atmxSoftPvcMIB, xylnatmSoftPVccTargetAddress=xylnatmSoftPVccTargetAddress, atmxSoftPvcBbcUserPlaneConnectionConfig=atmxSoftPvcBbcUserPlaneConnectionConfig, atmxSoftPvcBbcTable=atmxSoftPvcBbcTable, xylnatmSoftPVccVpi=xylnatmSoftPVccVpi, xylnatmSoftPVccOutVci=xylnatmSoftPVccOutVci)

#
# PySNMP MIB module SYNOPTICS-COMMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYNOPTICS-COMMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:14:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, NotificationType, Bits, Gauge32, IpAddress, ModuleIdentity, ObjectIdentity, TimeTicks, iso, Unsigned32, Integer32, Counter32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "NotificationType", "Bits", "Gauge32", "IpAddress", "ModuleIdentity", "ObjectIdentity", "TimeTicks", "iso", "Unsigned32", "Integer32", "Counter32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
s3SnmpAgent, SnpxBackplaneType, series3000, SnpxChassisType = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "s3SnmpAgent", "SnpxBackplaneType", "series3000", "SnpxChassisType")
class S3ModuleType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129))
    namedValues = NamedValues(("empty", 1), ("other", 2), ("m3302", 3), ("m3304-ST", 4), ("m3305", 5), ("m3308", 6), ("m3313", 7), ("m3313M", 8), ("m3314-ST", 9), ("m3314M-ST", 10), ("m3323", 11), ("m3324-ST", 12), ("m3502", 13), ("m3532", 14), ("m3552", 15), ("m3301", 16), ("m3307", 17), ("m3356", 18), ("m3512", 19), ("m3514", 20), ("m3505", 21), ("m3554", 22), ("m3534", 23), ("m3383", 24), ("m3384", 25), ("m331x", 26), ("m351x", 27), ("m3502-A", 28), ("m3902", 29), ("m3904", 30), ("m3910S", 31), ("m3386", 32), ("m3394", 33), ("m3395", 34), ("m3323S", 35), ("m3324S-ST", 36), ("m3307A", 37), ("m3308A", 38), ("m3505A", 39), ("m3513", 40), ("m3333", 41), ("m3334-ST", 42), ("m3040", 43), ("m3100R", 44), ("notUsed45", 45), ("notUsed46", 46), ("m2810-hm", 47), ("m2810-nmm", 48), ("m3313S", 49), ("m3314S", 50), ("m3368", 51), ("m3512S", 52), ("m3513S", 53), ("m3514S", 54), ("m3522", 55), ("m2912", 56), ("m2914", 57), ("notUsed58", 58), ("m3301-75", 59), ("m3301-93", 60), ("m271x-nmm", 61), ("m2705-hm", 62), ("m2715-hm", 63), ("m2813-nmm", 64), ("m2814-nmm", 65), ("m2813-hm", 66), ("m2814-hm", 67), ("m2803-hm", 68), ("m2804-hm", 69), ("m3395A", 70), ("m3040S", 71), ("m3502B", 72), ("m3505B", 73), ("m2715-F-hm", 74), ("m2712-hm", 75), ("m2712-F-hm", 76), ("m2702-hm", 77), ("m2702-C-hm", 78), ("m2705-F-hm", 79), ("m2702-F-hm", 80), ("m2705-C-hm", 81), ("m3902A", 82), ("m2912A", 83), ("m3313A", 84), ("m3314A", 85), ("m3307HD", 86), ("m3328", 87), ("m3904-2SM", 88), ("m3910S-SM", 89), ("m3800", 90), ("m3910S-SD", 91), ("m3904-4SM", 92), ("m2915", 93), ("m3910SA", 94), ("m3910SA-SM", 95), ("m3905", 96), ("m2715B-hm", 97), ("m2705B-hm", 98), ("m2715B-F-hm", 99), ("m2712B-hm", 100), ("m2712B-F-hm", 101), ("m2702B-C-hm", 102), ("m3304A", 103), ("m3486", 104), ("m3308B", 105), ("m2813SA-nmm", 106), ("m2814SA-nmm", 107), ("m3517SA", 108), ("m810M", 109), ("m3313SA", 110), ("m3314SA", 111), ("m3522A", 112), ("m3504-ST", 113), ("m3513SA", 114), ("mAlcatel-Eth-nmm", 115), ("mAlcatel-Eth-hm1", 116), ("mAlcatel-Eth-hm", 117), ("m2486-nmm", 118), ("m2486-hm", 119), ("m3174", 120), ("m271xSA-nmm", 121), ("m3299C", 122), ("m3299U", 123), ("m3299F", 124), ("m2300x", 125), ("m2310x", 126), ("m3410", 127), ("m3405", 128), ("m3475", 129))

class S3PsType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("other", 1), ("low", 2), ("medium", 3), ("high", 4), ("redundantCapable", 5), ("empty", 6))

s3AgentSw = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 2, 1))
s3AgentNetProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 2, 2))
s3AgentIpProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1))
s3AgentHw = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 2, 4))
s3AgentSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 2, 5))
s3AgentLocImage = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 2, 6))
s3000Chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 1))
s3000RedundantPs = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10))
s3000Ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 2))
s3000TokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3))
s3000FDDI = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 4))
s3000Bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 5))
s3000TerminalServer = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 6))
s3000LattisTalk = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 7))
s3000Trb = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 8))
s3ChassisType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 1), SnpxChassisType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisType.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisType.setDescription('The chassis type.')
s3ChassisBkplType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 2), SnpxBackplaneType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisBkplType.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisBkplType.setDescription('The chassis backplane type.')
s3ChassisBkplRev = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisBkplRev.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisBkplRev.setDescription('The chassis backplane revision.')
s3ChassisPsType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 4), S3PsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisPsType.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisPsType.setDescription('The chassis power supply type. This value is valid only when the backplane type is not other(1). If the chassis has a redundant backplane, the agent returns redundantCapable(5), even if only one power supply is installed. The objects s3RedPsPrimaryConfig and s3RedPsSecondaryConfig should be consulted to determine the installed power supply type(s) with redundant backplanes.')
s3ChassisPsStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("primaryFail", 2), ("secondaryFail", 3), ("bothFail", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisPsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisPsStatus.setDescription('The chassis power supply status.')
s3ChassisFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisFanStatus.setDescription('The status of the chassis cooling fan.')
s3SlotConfigTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7), )
if mibBuilder.loadTexts: s3SlotConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotConfigTable.setDescription('The chassis slot configuration table.')
s3SlotConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1), ).setIndexNames((0, "SYNOPTICS-COMMON-MIB", "s3SlotNumber"))
if mibBuilder.loadTexts: s3SlotConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotConfigEntry.setDescription('What type of module is in each slot of the chassis.')
s3SlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotNumber.setDescription('The 3000 Chassis slot number. Valid entries are 1-12.')
s3SlotModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotModuleId.setDescription('ID for the module. Values are specified in SynOptics technical documents.')
s3SlotModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1, 3), S3ModuleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotModuleType.setStatus('deprecated')
if mibBuilder.loadTexts: s3SlotModuleType.setDescription('The type of module this entry represents. Values are specified in SynOptics technical documents.')
s3SlotModuleDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotModuleDescr.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotModuleDescr.setDescription('Module description. Values are specified in SynOptics technical documents.')
s3SlotModuleLed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotModuleLed.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotModuleLed.setDescription('Status of the module LEDs. Format is specified in SynOptics technical documents. NOTE: the 291x FDDI workgroup concentrators actually return a string with size of 10.')
s3SlotModuleMdaId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotModuleMdaId.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotModuleMdaId.setDescription('ID of the medium-dependent part of the board. The value is board dependent. Values are specified in SynOptics technical documents.')
s3CommonBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8), )
if mibBuilder.loadTexts: s3CommonBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardTable.setDescription('A table containing information about the boards currently plugged into the 3000 Chassis. This board table contains an entry for each non-empty slot in the s3SlotConfigTable, EXCEPT for those slots containing Retiming Modules. All of the information in this board table is retrievable using the NMI commands that are common to all boards integrated into the SynOptics Series 3000 Concentrators.')
s3CommonBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1), ).setIndexNames((0, "SYNOPTICS-COMMON-MIB", "s3CommonBoardIndex"))
if mibBuilder.loadTexts: s3CommonBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardEntry.setDescription('A table entry containing information about a single Board currently plugged into the 3000 Chassis. These values can be retrieved using the common board NMI commands.')
s3CommonBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3CommonBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
s3CommonBoardId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 88, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 114, 115, 116, 117, 119, 120, 121, 122, 250, 251, 252))).clone(namedValues=NamedValues(("m331x", 1), ("m3302", 2), ("m332x", 3), ("m3304ST", 4), ("m3305", 5), ("m333x", 6), ("m3307", 7), ("m3308", 8), ("m3301", 9), ("m3904", 10), ("m3902", 11), ("m3910S", 12), ("m331xS", 14), ("m3100R", 15), ("m3502", 16), ("m3502A", 17), ("m353x", 18), ("m3040", 19), ("m3505", 20), ("m3505A", 21), ("m355x", 22), ("m3040S", 23), ("m351x", 24), ("m332xS", 25), ("m338x", 26), ("m3328", 27), ("m3395", 28), ("m3394", 29), ("m3522", 30), ("m3395A", 31), ("m3800", 32), ("m3368", 36), ("m3308A", 38), ("m2810nmm", 39), ("m2810hm", 40), ("m3301ohms75", 41), ("m3301ohms93", 42), ("m2912", 43), ("m2914", 44), ("m3502B", 45), ("m3505B", 46), ("m3307HD", 47), ("m2702Fhm", 48), ("m2712Fhm", 49), ("m2712hm", 50), ("m2702hm", 51), ("m2813nmm", 52), ("m2813hm", 53), ("m2814hm", 54), ("m2803hm", 55), ("m3356", 56), ("m2814nmm", 57), ("m2804hm", 58), ("m2702Chm", 59), ("m2715Fhm", 60), ("m2705Fhm", 61), ("m2705Chm", 62), ("m3902A", 63), ("m2912A", 64), ("m271xnmm", 65), ("m2715hm", 66), ("m3910SSD", 67), ("m3313A", 68), ("m3314A", 69), ("m3304A", 70), ("m3910SA", 71), ("m2705hm", 72), ("m3905", 73), ("m2915", 74), ("m2715Bhm", 75), ("m2705Bhm", 76), ("m2715BFhm", 77), ("m2712Bhm", 78), ("m2712BFhm", 79), ("m2702BChm", 80), ("m3486", 82), ("m810m", 88), ("m3517SA", 101), ("m3308B", 102), ("m2813SAnmm", 103), ("m2814SAnmm", 104), ("m3313SA", 105), ("m3314SA", 106), ("m3174", 107), ("m3522A", 108), ("m3513SA", 109), ("m271xSAnmm", 110), ("m2300x", 114), ("m2310x", 115), ("m3299C", 116), ("m3299U", 117), ("m3299F", 119), ("m3410", 120), ("m3405", 121), ("m3475", 122), ("mAlcatelEthConcnmm", 250), ("mAlcatelEthConchm", 251), ("mAlcatelEthExpConchm", 252)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3CommonBoardId.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardId.setDescription("This is the ID of the board, which is 'hard-coded' in the board, and identifies the board's basic functionality. Some boards have the capability to change aspects of their functionality, such as media type, interface types, or power supply wattages, by plugging in different daughter cards. Other boards may identify the type of cable plugged into them. The boards that have these capabilities use different values for the object s3SlotModuleMda to identify the changable portion of the functionality currently used. Boards that do not support these capabilities typically set the object s3SlotModuleMda to 255 or zero. The combination of the value of this object and the s3SlotModuleMda object are then mapped by software to determine the type of module (i.e., s3SlotModuleType). Notes: 1.) The object s3SlotModuleType is marked as deprecated. 2.) Agents do not implement a complete mapping of s3CommonBoardId and s3SlotModuleMda to s3SlotModuleType. The mapping that is performed pertains to the media type of the agent. The possible values for this object are: m331x(1)...................331x Ethernet NMM m3302(2)...................3302 Ethernet STP Host m332x(3)...................332x Ethernet Local Bridge m3304ST(4).................3304 Ethernet FOIRL-ST Host m3305(5)...................3305 Ethernet UTP Host m333x(6)...................333x Ethernet Repeater/Retiming m3307(7)...................3307 Ethernet 50 Pin UTP Host m3308(8)...................3308 10BaseT UTP Host m3301(9)...................3301 10Base2 Thin Net Host m3904(10)..................3904 FDDI Multimode Fiber Host m3902(11)..................3902 FDDI STP Host m3910S(12).................3910S FDDI NMM m331xS(14).................331xS Ethernet NMM m3100R(15).................3100R Power Supply Summing m3502(16)..................3502 Token Ring Passive STP Host m3502A(17).................3502A Token Ring Passive STP/UTP Host m353x(18)..................353x Token Ring RI/RO Repeater m3040(19)..................3040 Network Control Engine (NCE) m3505(20)..................3505 Token Ring Active UTP Host m3505A(21).................3505A Token Ring Active UTP Host m355x(22)..................355x Token Ring FOIRL RI/RO Repeater m3040S(23).................3040S Network Control Engine m351x(24)..................351x Token Ring NMM m332xS(25).................332xS Ethernet High Speed Local Bridge m338x(26)..................338x Ethernet Remote Router m3328(27)..................3328 Ethernet Switching Engine (ESE) m3395(28)..................3395 Terminal Server m3394(29)..................3394 LattisTalk Router/Repeater m3522(30)..................3522 Token Ring Local Bridge m3395A(31).................3395A Terminal Server m3800(32)..................3800 Multimedia Router m3368(36)..................3368 Ethernet LattisSecure Host m3308A(38).................3308A 10BaseT Host m2810nmm(39)...............2810 Ethernet NMM m2810hm(40)................2810 Ethernet Host m3301ohms75(41)............3301-75 Ethernet Thin Net Host (75-ohm) m3301ohms93(42)............3301-93 Ethernet Thin Net Host (93-ohm) m2912(43)..................2912 FDDI STP Concentrator m2914(44)..................2914 FDDI Fiber Concentrator m3502B(45).................3502B Token Ring Passive STP/UTP Host m3505B(46).................3505B Token Ring Active STP/UTP Host m3307HD(47)................3307HD Ethernet 100 Pin UTP Host m2702Fhm(48)...............2702F Token Ring Passive Host m2712Fhm(49)...............2712F Token Ring Passive Host m2712hm(50)................2712 Token Ring Passive Host m2702hm(51)................2702 Token Ring Passive Host m2813nmm(52)...............2813 Ethernet NMM m2813hm(53)................2813 Ethernet Host m2814hm(54)................2814 Ethernet Host m2803hm(55)................2803 Ethernet Host m3356(56)..................3356 Ethernet Remote Bridge m2814nmm(57)...............2814 Ethernet NMM m2804hm(58)................2804 Ethernet Host m2702Chm(59)...............2702C Token Ring Passive Host m2715Fhm(60)...............2715F Token Ring Active Host m2705Fhm(61)...............2705F Token Ring Active Host m2705Chm(62)...............2705C Token Ring Active Host m3902A(63).................3902A FDDI STP Host m2912A(64).................2912A FDDI STP Concentrator m271xnmm(65)...............271x Token Ring NMM m2715hm(66)................2715 Token Ring Active Host m3910SSD(67)...............3910S-SD FDDI NMM m3313A(68).................3313A Ethernet NMM m3314A(69).................3314A Ethernet NMM m3304A(70).................3304A Ethernet 10BaseF Host m3910SA(71)................3910SA FDDI NMM m2705hm(72)................2705 Token Ring Active Host m3905(73)..................3905 FDDI UTP Host m2915(74)..................2915 FDDI UTP Concentrator m2715Bhm(75)...............2715B Token Ring Active Host m2705Bhm(76)...............2505B Token Ring Active Host m2715BFhm(77)..............2715B-F Token Ring Active Host m2712Bhm(78)...............2712B Token Ring Passive Host m2712BFhm(79)..............2712B-F Token Ring Passive Host m2702BChm(80)..............2702B-C Token Ring Passive Host m3486(82)..................3486 LattisEngine/486 m810m(88)..................810M Ethernet Concentrator m3517SA(101)...............3517SA Token Ring NMM m3308B(102)................3308B 10BaseT Host m2813SAnmm(103)............2813SA Ethernet NMM m2814SAnmm(104)............2814SA Ethernet NMM m3313SA(105)...............3313SA Ethernet NMM m3314SA(106)...............3314SA Ethernet NMM m3174(107).................3174 Workstation Controller m3522A(108)................3522A Token Ring Local Bridge m3513SA(109)...............3513SA Token Ring NMM m271xSAnmm(110)............271xSA Token Ring NMM m2300x(114)................2300x Product m2310x(115)................2310x Product m3299C(116)................3299-C Terminal Multiplexor Adapter m3299U(117)................3299-U TTP Terminal Multiplexor Adapter m3299F(119)................3299-F Fiber Optic Terminal Adapter m3410(120).................3410 Fast Ethernet Network Management Module m3405(121).................3405 Fast Ethernet Host Module with 12 100BASE-TX ports m3475(122).................3475 Fast Ethernet Host Module with 11 100BASE-TX ports and 1 100BASE-FX port mAlcatelEthConcnmm(250)....Alcatel Ethernet NMM mAlcatelEthConchm(251).....Alcatel Ethernet Host mAlcatelEthExpConchm(252)..Alcatel Ethernet Expansion Host")
s3CommonBoardHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3CommonBoardHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardHwVer.setDescription('The hardware revision of the board. 0=Rev. A, 1=Rev. B, etc.')
s3CommonBoardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3CommonBoardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardStatus.setDescription('This indicates the operational status of the board.')
s3CommonBoardReset = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3CommonBoardReset.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardReset.setDescription('This indicates the reset state of the board. Writing with the value reset (2) will reset the board.')
s3CommonBoardPartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("partition", 2), ("timedPartition", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3CommonBoardPartStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardPartStatus.setDescription('Tells whether the board is partitioned or enabled. Writing with the value partition(2) will partition the board indefinitely and writing with the value enabled(1) will enable the board. If a timed partition is desired, then this object must be written with timedPartition(3) and in the same PDU a partition duration must be supplied in s3CommonBoardPartTime. Timed partitions will not survive across a reset. In this case the port will go to the partition(2) state. Boards cannot be partitioned in the 2810 concentrator and other workgroup concentrators. These agents will implement this object as read-only.')
s3CommonBoardNmCntlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notNmControl", 1), ("nmControl", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3CommonBoardNmCntlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardNmCntlStatus.setDescription('Tells whether the board is under network management control. The value nmControl(2) indicates that the board or one or more ports are being controlled by network management. This means that the board or one or more ports are partitioned via a network manager.')
s3CommonBoardPsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3CommonBoardPsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardPsStatus.setDescription('This indicates the operational status of the board power supply. A fail(2) indicates that one of the power supplies on the board has failed.')
s3CommonBoardPartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 8, 1, 9), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3CommonBoardPartTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3CommonBoardPartTime.setDescription('When partitioning the board for a specified time, s3CommonBoardPartStatus must be set with timedPartition(3) and this object must be supplied with the duration value. If a PDU sets s3CommonBoardPartStatus and not this object, the board will not be partitioned. This value is decremented while the board is partitioned until the value reaches zero at which time the board is enabled.')
s3SlotConfigOctetString = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 144))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3SlotConfigOctetString.setStatus('mandatory')
if mibBuilder.loadTexts: s3SlotConfigOctetString.setDescription('Packed octet string for the slot configuration table. Format is specified in SynOptics technical documents. NOTE: the 291x FDDI workgroup concentrators actually return a string with size a multiple of 14.')
s3RedPsPlus5vCurrent = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsPlus5vCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsPlus5vCurrent.setDescription('This gauge is measured in amperes.')
s3RedPsPlus12vCurrent = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsPlus12vCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsPlus12vCurrent.setDescription('This gauge is measured in amperes.')
s3RedPsAmbientTempStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("normalTemperature", 2), ("aboveNormalTemp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsAmbientTempStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsAmbientTempStatus.setDescription('This status indicates whether the ambient temperature is normal, i.e., below 40 degree C.')
s3RedPsAmbientTemperature = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsAmbientTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsAmbientTemperature.setDescription('This gauge is measured in Celsius.')
s3RedPsPrimaryConfig = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 5), S3PsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsPrimaryConfig.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsPrimaryConfig.setDescription('This indicates the primary power supply type (PS 1). Note that value redundantCapable(5) should not be returned for this object.')
s3RedPsSecondaryConfig = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 6), S3PsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsSecondaryConfig.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsSecondaryConfig.setDescription('This indicates the secondary power supply type (PS 2). Note that value redundantCapable(5) should not be returned for this object.')
s3RedPsDiodeStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("bothOk", 2), ("primaryFail", 3), ("secondaryFail", 4), ("bothFail", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsDiodeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsDiodeStatus.setDescription('This gives the status of the summing diode on the 3100R associated with the indicated power supply.')
s3RedPsPowerAlarm = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 10, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("bothOk", 2), ("primaryFail", 3), ("secondaryFail", 4), ("bothFail", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3RedPsPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: s3RedPsPowerAlarm.setDescription('This tells whether the indicated power supply is sensing voltage on the backplane.')
s3ChassisBkPlEthChanDiv = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisBkPlEthChanDiv.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisBkPlEthChanDiv.setDescription('A value that describes the divisions of the segmentable ethernet channel. For those devices that do not implement a backplane with this feature, they still need to implement this object and return a value (i.e., zero) to indicate that no divisions are enabled. The value is a sum (i.e., integer bit string). This value initially takes the value of zero, then for each division that is enabled on the channel, 2 raised to a power is added to the sum. The powers are according to the following table: Division between Power Slots 4 and 5 0 Slots 6 and 7 1 Slots 8 and 9 2 For example, a channel with no divisions enabled (i.e., not segmented) would have a value of 0. A channel with divisions between slots 6 and 7, and slots 8 and 9 enabled (i.e., having three segments) would have a value of 6 (2**1 + 2**2).')
s3ChassisEnetChannelAType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("aSegmentable", 2), ("aNotSegmentable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3ChassisEnetChannelAType.setStatus('mandatory')
if mibBuilder.loadTexts: s3ChassisEnetChannelAType.setDescription('The agent will return aSegmentable(2) for the 3000N, 3000NT, 3000S, 3000SR, and any other backplanes in which Ethernet channel A can be divided into multiple segments. The value aNotSegmentable(3) indicates that the Ethernet backplane channel A cannot be segmented. For Token Ring or FDDI workgroup concentrators, or other devices in which there is no Ethernet channel, the agent will return other(1).')
s3AgentType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30))).clone(namedValues=NamedValues(("other", 1), ("m3313", 2), ("m3313M", 3), ("m3314-ST", 4), ("m3314M-ST", 5), ("m2310", 6), ("m3512", 7), ("m3514", 8), ("m332x", 9), ("m3356", 10), ("m332xS", 11), ("m3910S", 12), ("m3395", 13), ("m3394", 14), ("m3513", 15), ("m331xS", 16), ("m291x", 17), ("m271x", 18), ("m281x", 19), ("m331xA", 20), ("m3522", 21), ("m2722", 22), ("m281xSA", 23), ("m810M", 24), ("m351xSA", 25), ("m331xSA", 26), ("m271xSA", 27), ("m2486", 28), ("m2300x", 29), ("m2310x", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentType.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentType.setDescription("The 3000 series agent's Module type.")
s3AgentFwVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentFwVer.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentFwVer.setDescription("The agent's module firmware version 0=Rev A,1=Rev B,etc.")
s3AgentSwMajorVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentSwMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentSwMajorVer.setDescription('The agent major software version number. (version is specified as major.minor.maint or 3.0.1). Object is in decimal.')
s3AgentSwMinorVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentSwMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentSwMinorVer.setDescription('The agent minor software version number (version is specified as major.minor.maint or 3.0.1). Object is in decimal.')
s3AgentBootProtocol = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("bootp-tftp", 2), ("tftp-only", 3), ("ieee802-1e", 4), ("proprietary", 5), ("dll-download", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentBootProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentBootProtocol.setDescription('Boot protocol used to load the module with its software. On Agents with the Local Load option the value return by this object is valid only if the MIB object s3LocImageLoadMode is remoteBoot(2) or localAsBackup(4).')
s3AgentBootFile = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentBootFile.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentBootFile.setDescription('The name of the boot file that is sent to the file server during boot time. The actual boot protocol used to retrieve the file is determined by s3AgentBootProtocol. This parameter will not take effect until written into EEPROM (s3AgentWriteEeprom) and a reset (s3AgentReset) is issued. This parameter is used only if the s3AgentBootMode is set to use EEPROM.')
s3AgentAuthTrap = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentAuthTrap.setStatus('deprecated')
if mibBuilder.loadTexts: s3AgentAuthTrap.setDescription('Enable or disable the use of authentication error trap generation. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless the specific NMM configuration file is updated to reflect the change. This object is now deprecated. Managers should use the snmpEnableAuthenTraps object in MIB-II instead. This object is aliased to snmpEnableAuthenTraps. Changing either variable will change the other accordingly.')
s3AgentLocation = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentLocation.setStatus('deprecated')
if mibBuilder.loadTexts: s3AgentLocation.setDescription('This is a informational string that could be used to show the physical location (i.e. area) of the NMM or concentrator. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless the specific NMM configuration file is updated to reflect the change. This object is now deprecated. Managers should use the sysLocation object in MIB-II instead.')
s3AgentMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentMibLevel.setDescription('Used to determine current MIB release supported by agent. The encoding of this object is of the following form: xyy, where x is the major version number and yy is the minor version number. Thus, version 3.0 would be represented as 300, version 3.01 would be 301 and 3.1 would be 310. Object is in decimal. Values that correspond to each agent type and version are specified in the other SynOptics documentation.')
s3AgentFeatureLevel = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentFeatureLevel.setStatus('deprecated')
if mibBuilder.loadTexts: s3AgentFeatureLevel.setDescription('Used to determine feature level of the agent. The encoding of this object is of the following form: xyy, where x is the major version number and yy is the minor version number. Thus, feature level version 1.0 would be represented as 100, version 1.01 would be 101 and 1.1 would be 110. Object is in decimal. The current values are the following: 100 - 331x V3.x - Basic Agent 100 - 351x - Basic Agent 100 - 271x V3.x - Basic Agent 101 - 281x V5.0 - Basic Agent - Dual Stack 102 - 331x V4.2.0 - Basic Agent - Non Segmentable Chassis - Ethernet Common board table - Ethernet Command port table - redundant power supply group 103 - 331xA V4.2.0 - Basic Agent - Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group - Ethernet plus statistics, 104 - 331xA V4.2.0 - Basic Agent - Non-Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group - Ethernet plus statistics, 109 - 331x V4.2.0 - Basic Agent - Segmentable Chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group 112 - 281x V5.1.0 - Basic Agent - Dual Stack - Network to MAC address mapping 113 - 331x V5.1.0 - Basic Agent - Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping 114 - 331x V5.1.0 - Basic Agent - Non-Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping 115 - 331xA V5.1.0 - Basic Agent - Segmentable chassis - Dual Stack - Full Truffle Support - Network to MAC address mapping 116 - 331xA V5.1.0 - Basic Agent - Non-Segmentable chassis - Dual Stack - Full Truffle Support - Network to MAC address mapping 200 - 331x V4.0 & V4.0.1 - Advanced Agent 200 - 271x V4.x - Advanced Agent 200 - 351x V4.x - Advanced Agent 200 - all FDDI Agents 201 - 331x V4.1.0, V4.1.1 - Advanced Agent - redundant power supply group 202 - 331xS V4.1.0, V4.1.1 - Advanced Agent - redundant power supply group - DS/SD traffic tables, - Ethernet plus statistics, - frame type distribution table - frame length distribution table 203 - 281x V4.2.0 - Advanced Agent - Dual Stack 204 - 331x V4.2.0 - Advanced Agent - Non-Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group 205 - 331xS V4.2.0 - Advanced Agent - Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group - DS/SD traffic tables, - Ethernet plus statistics, - frame type distribution table - frame length distribution table 206 - 331xS V4.2.0 - Advanced Agent - Non-Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group - DS/SD traffic tables, - Ethernet plus statistics, - frame type distribution table - frame length distribution table 207 - 331xA V4.2.0 - Advanced agent - Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group - Ethernet plus statistics, 208 - 331xA V4.2.0 - Advanced agent - Non-Segmentable chassis - Ethernet Common board table - Ethernet Common port table - redundant power supply group - Ethernet plus statistics, 209 - 331x V4.2.0 - Advanced agent - Segmentable chassis - Ethernet Common board table - Ethernet Command port table - redundant power supply group 212 - 331x V5.1.0 - Advanced Agent - Dual Stack - Network to MAC address mapping - RMON Ether Stats, History, Alarm, Event Groups 213 - 281x V5.1.0 - Advanced Agent - Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping - RMON Ether Stats, History, Alarm, Event Groups 214 - 331x V5.1.0 - Advanced Agent - Non-Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping - RMON Ether Stats, History, Alarm, Event Groups 215 - 331xA V5.1.0 - Advanced Agent - Segmentable chassis - RMON Ether Stats, History, Alarm, Event Groups - Dual Stack - Full Truffle Support - Network to MAC address mapping 216 - 331xA V5.1.0 - Advanced Agent - Non-Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping - RMON Ether Stats, History, Alarm, Event Groups 217 - 331xS V5.1.0 - Advanced Agent - Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping - RMON Ether Stats, History, Alarm, Event Groups - Bulk table retrieval for traffic matrix 218 - 331xS V5.1.0 - Advanced Agent - Non-Segmentable chassis - Full Truffle Support - Dual Stack - Network to MAC address mapping - RMON Ether Stats, History, Alarm, Event Groups - Bulk table retrieval for traffic matrix')
s3AgentMySlotId = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentMySlotId.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentMySlotId.setDescription('Slot where this agent currently resides. If hardware is unable to determine then a 0 should be returned.')
s3AgentUnAuthIp = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentUnAuthIp.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentUnAuthIp.setDescription('This object contains the IP address of the last station that tried to access this agent with an invalid community string. This object is used as a VarBind in an Authentication Trap PDU. A get request will return the last value used, and will return the null address 0.0.0.0 if no authentication traps have been sent.')
s3AgentUnAuthComm = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentUnAuthComm.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentUnAuthComm.setDescription('This object contains the community string of the last unauthenticated attempt to access this agent. This object is used as a VarBind in an Authentication Trap PDU. A get request will return the last value used, and will return the null string (length 0) if no authentication traps have been sent.')
s3AgentSwLicenseCode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentSwLicenseCode.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentSwLicenseCode.setDescription('The software license code assigned to this agent. This code is required for initializing the agent. The code consists of exactly eight printable characters.')
s3AgentPerformance = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentPerformance.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentPerformance.setDescription('This counts the CPU idle time of the agent in units of 10 microseconds.')
s3AgentSwMaintVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentSwMaintVer.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentSwMaintVer.setDescription('The agent software maintenance version number (version is specified as major.minor.maint or 3.0.1). Object is in decimal.')
s3AgentConfigLoadMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("remoteConfig", 2), ("localConfig", 3), ("localAsBackup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentConfigLoadMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentConfigLoadMode.setDescription('This indicates whether the agent should get configuration data from the network, use the local configuration data, or try the network first and then fall back to local configuration if the network load fails. This object applies only to agents with boot prom support for agent configuration load options. This parameter will not take effect until written into EEPROM (s3AgentWriteEeprom) and a reset (s3AgentReset) is issued.')
s3AgentConfigActualSource = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("remoteConfig", 2), ("localConfig", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentConfigActualSource.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentConfigActualSource.setDescription('This indicates whether the agent loaded configuration data from the network or used the local configuration data.')
s3AgentMgmtProtoMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ip", 2), ("ipx", 3), ("ipAndIpx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentMgmtProtoMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentMgmtProtoMode.setDescription('This indicates from which network transports over which the agent will accept SNMP requests. This object only applies to agents with IP and IPX dual stack support. This parameter will not take effect until written into EEPROM (s3AgentWriteEeprom) and a reset (s3AgentReset) or a restart (s3AgentRestart) is issued.')
s3AgentActualMgmtProtocol = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ip", 2), ("ipx", 3), ("ipAndIpx", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentActualMgmtProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentActualMgmtProtocol.setDescription('This indicates which network transports over which the agent will currently accept SNMP requests.')
s3AgentImageFile = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentImageFile.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentImageFile.setDescription('The name of the agent image file that the NMM loads at boot time. This parameter will not take effect until written to EEPROM (s3AgentWriteEeprom) and a reset (s3AgentReset) is issued. This parameter is used only if s3AgentBootMode is set to use eeprom(1), s3AgentConfigLoadMode is set to localConfig(3) and s3LocImageLoadMode is not set to localBoot(3).')
s3AgentIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentIpAddr.setDescription("The Agent's administrative IP address. The current operational IP address can be obtained by the ipAdEntAddr entry in the ipAddrTable. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless it is written into EEPROM (s3AgentWriteEeprom). This parameter is used only if the s3AgentBootMode is set to use EEPROM.")
s3AgentNetMask = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentNetMask.setDescription("The Agent's administrative subnet mask. The current operational subnet mask can be obtained by the ipAdEntNetMask entry in the ipAddrTable. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless it is written into EEPROM (s3AgentWriteEeprom). This parameter is used only if the agentBootMode is set to use EEPROM. NOTE: The Model 331x (3313, 3313M, 3314-ST, 3314M-ST) Ethernet NMM agents do not store this parameter in EEPROM, so for these agents the subnet mask configuration must be downloaded in the configuration file.")
s3AgentDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentDefaultGateway.setDescription("The Agent's administrative default gateway IP address. The current operational default gateway's IP address can be obtained from the ipRoutingTable. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless it is written into EEPROM (s3AgentWriteEeprom). This parameter is used only if the agentBootMode is set to use EEPROM.")
s3AgentBootServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentBootServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentBootServerAddr.setDescription('The IP address to which the requests for boot files are sent. The protocol used to retrieve the boot files is determined by object s3AgentBootProtocol. This parameter will not take effect until until written into EEPROM (s3AgentWriteEeprom) and a reset (s3AgentReset) is issued. This parameter is used only if the s3AgentBootMode is set to use EEPROM.')
s3AgentSecDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentSecDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentSecDefaultGateway.setDescription("The agent's administrative secondary default gateway IP address. This default gateway's IP address will be used when the primary default gateway (s3AgentDefaultGateway) is determined unreachable. This parameter will not survive a reset (s3AgentReset) unless it is written into EEPROM (s3AgentWriteEeprom).")
s3AgentPingDefaultRtrSwitch = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentPingDefaultRtrSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentPingDefaultRtrSwitch.setDescription("Controls whether the agent will periodically send out the icmp echos (pings) to the default router(s). The values are: other(1)...unknown or other on(2)......agent will periodically send out pings to the default router(s). off(3).....agent won't send out the pings to the default router(s).")
s3AgentPingDefaultRtrTime = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 7), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentPingDefaultRtrTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentPingDefaultRtrTime.setDescription('The time interval that the agent uses to send out the pings periodically to the default router(s) to check if the router(s) are still reachable.')
s3AgentBootRouter = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentBootRouter.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentBootRouter.setDescription("The default route IP address used at boot time to download the NMM's agent configuration and image files from the TFTP server. This parameter will not survive a reset (s3AgentReset) unless it is written into EEPROM (s3AgentWriteEeprom).")
s3AgentTrapReceiverTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 2, 3), )
if mibBuilder.loadTexts: s3AgentTrapReceiverTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentTrapReceiverTable.setDescription("Table containing list of NMS's that are to receive traps generated by this NMM.")
s3AgentTrapReceiverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 2, 3, 1), ).setIndexNames((0, "SYNOPTICS-COMMON-MIB", "s3AgentTrapRcvrNetAddress"))
if mibBuilder.loadTexts: s3AgentTrapReceiverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentTrapReceiverEntry.setDescription('A destination address and community string to a particular trap server, along with a trap filter and entry aging capability.')
s3AgentTrapRcvrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("valid", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentTrapRcvrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentTrapRcvrStatus.setDescription('Setting this object to the value invalid(3) has the effect of invalidating the corresponding entry in the s3AgentTrapReceiverTable. That is, it effectively disassociates the address identified with the entry by removing the entry from the table. On a read the value of valid(2) should be returned if the entry contains a valid record, or invalid(3) should be returned if the entry contains an invalid record.')
s3AgentTrapRcvrNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 2, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentTrapRcvrNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentTrapRcvrNetAddress.setDescription('IP address for trap server that is to receive the trap.')
s3AgentTrapRcvrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 2, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentTrapRcvrComm.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentTrapRcvrComm.setDescription('Community string used for traps sent to this trap receiver.')
s3AgentTrapRcvrAgeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 2, 3, 1, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentTrapRcvrAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentTrapRcvrAgeTime.setDescription('This is the time interval used to age entries out of the trap receiver table. The default value if not specified will be 0, or infinite, never to be aged out.')
s3AgentStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offline", 1), ("online", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentStatus.setDescription('This indicates whether the NMM is online(2) and operating, or offline(1) (ie: not connected to the concentrator backplane).')
s3AgentMdaHwVer = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentMdaHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentMdaHwVer.setDescription("The network management module's MDA hardware version number (0=Rev. A, 1=Rev. B, etc.).")
s3AgentMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentMode.setDescription('This indicates whether the NMM is operating in primary(1) or secondary(2) mode.')
s3AgentReset = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentReset.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentReset.setDescription('Network management module reset status. Writing a reset(2) to this object will reset the NMM and perform a download and restart.')
s3AgentRestart = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noRestart", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentRestart.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentRestart.setDescription('Network management module restart status. Writing a restart(2) to this object will restart the NMM. This initializes all the counters, re-reads the EEPROM data structure and starts executing from the beginning of the code.')
s3AgentBootMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eeprom", 1), ("net", 2), ("otherCase", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentBootMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentBootMode.setDescription("The method for obtaining boot parameter information. The possible values are: eeprom(1)......get boot info from eeprom net(2).........get boot info from remote server otherCase(3)...not eeprom or net This parameter will not take effect until written into EEPROM (s3AgentWriteEeprom) and a reset (s3AgentReset) is issued. Note: In previous versions of this MIB the name associated with the value '2' was 'other', which implied the same meaning as it does now. Thus to prevent confusion, the name for value '3' was chosen to be 'otherCase'.")
s3AgentWriteEeprom = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noWriteEeprom", 1), ("writeEeprom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentWriteEeprom.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentWriteEeprom.setDescription('Network management module EEPROM write status. Writing a (2) to this object will write the contents of current EEPROM data structure in the EEPROM.')
s3AgentBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 8), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentBaudRate.setDescription('Specifies the baud rate in bits per second of either the internal modem or the RS-232 port. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless the specific NMM configuration file is updated to reflect the change.')
s3AgentInitString = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3AgentInitString.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentInitString.setDescription('This is the initialization string used to establish the out-of-band connection. (i.e. could contain the string ATDT,415-960-1100 for an internal or external modem). This is used as a hint for the network manager since this string is not used by the agent to initiate a connection to a management station. This parameter will take effect only after a restart (s3AgentRestart) is issued. This parameter will not survive a reset (s3AgentReset) unless the specific NMM configuration file is updated to reflect the change.')
s3AgentEepromSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentEepromSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentEepromSize.setDescription('The size of the EEPROM of the agent in units of bytes.')
s3AgentEpromSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentEpromSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentEpromSize.setDescription('The size of the EPROM of the agent in units of bytes.')
s3AgentDramSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentDramSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentDramSize.setDescription('The size of the DRAM of the agent in units of bytes.')
s3AgentHexDisplay = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentHexDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentHexDisplay.setDescription('The current 4 ASCII character display of the agent. Agents with no hex display hardware should return a zero length string.')
s3AgentFlashStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("fail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3AgentFlashStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3AgentFlashStatus.setDescription('This indicates the operational status of the flash device of the agent. A fail(3) indicates that either the flash device configuration on board is not valid or the flash EEPROMs on the board have failed.')
s3LocImageValid = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("localImageValid", 2), ("localImageInvalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3LocImageValid.setStatus('mandatory')
if mibBuilder.loadTexts: s3LocImageValid.setDescription('This indicates whether the agent has a valid local code image on board. An EPROM checksum failure would cause the agent to return localImageInvalid(3).')
s3LocImageMajorVersion = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3LocImageMajorVersion.setStatus('mandatory')
if mibBuilder.loadTexts: s3LocImageMajorVersion.setDescription('The major software version number of the locally-stored image. This object applies only to agents with valid local image. Other agents should return zero.')
s3LocImageMinorVersion = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3LocImageMinorVersion.setStatus('mandatory')
if mibBuilder.loadTexts: s3LocImageMinorVersion.setDescription('The minor software version number of the locally-stored image. This object applies only to agents with valid local image. Other agents should return zero.')
s3LocImageLoadMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("remoteBoot", 2), ("localBoot", 3), ("localAsBackup", 4), ("remoteNoUpdate", 5), ("remoteNewUpdate", 6), ("localAutoUpdate", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3LocImageLoadMode.setStatus('mandatory')
if mibBuilder.loadTexts: s3LocImageLoadMode.setDescription('This indicates whether the agent should get code from the network, use a local image, or try the network first and then fall back to local image if the network boot fails. The localBoot(3) and localAsBackup(4) values apply only to agents with local load option. Note: on agents that have no local storage, either remoteBoot(2), or remoteNoUpdate(5) may be specified, however the value remoteBoot(2) is prefered due to backwards compatibility ')
s3LocImageActualSource = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("remoteImage", 2), ("localImage", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3LocImageActualSource.setStatus('mandatory')
if mibBuilder.loadTexts: s3LocImageActualSource.setDescription('This indicates whether the agent loaded code from the network or used a local image. When the the ImageLoadMode is localAsBackup, this variable indicates whether the network load was successful.')
s3LocImageMaintVersion = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 2, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3LocImageMaintVersion.setStatus('mandatory')
if mibBuilder.loadTexts: s3LocImageMaintVersion.setDescription('The maintenance software version number of the locally-stored image. This object applies only to agents with valid local image. Other agents should return zero.')
mibBuilder.exportSymbols("SYNOPTICS-COMMON-MIB", s3CommonBoardEntry=s3CommonBoardEntry, s3LocImageMaintVersion=s3LocImageMaintVersion, s3CommonBoardPartTime=s3CommonBoardPartTime, s3RedPsPowerAlarm=s3RedPsPowerAlarm, s3SlotConfigTable=s3SlotConfigTable, s3AgentDefaultGateway=s3AgentDefaultGateway, s3AgentTrapReceiverTable=s3AgentTrapReceiverTable, S3ModuleType=S3ModuleType, s3AgentSwMinorVer=s3AgentSwMinorVer, s3CommonBoardNmCntlStatus=s3CommonBoardNmCntlStatus, s3AgentDramSize=s3AgentDramSize, s3RedPsSecondaryConfig=s3RedPsSecondaryConfig, s3AgentFlashStatus=s3AgentFlashStatus, s3AgentMode=s3AgentMode, s3000TokenRing=s3000TokenRing, s3SlotModuleMdaId=s3SlotModuleMdaId, s3AgentBootRouter=s3AgentBootRouter, s3CommonBoardStatus=s3CommonBoardStatus, s3AgentTrapRcvrStatus=s3AgentTrapRcvrStatus, s3AgentType=s3AgentType, s3LocImageActualSource=s3LocImageActualSource, s3AgentReset=s3AgentReset, s3AgentSpecific=s3AgentSpecific, s3000RedundantPs=s3000RedundantPs, s3000LattisTalk=s3000LattisTalk, s3AgentLocation=s3AgentLocation, s3AgentSwMaintVer=s3AgentSwMaintVer, s3AgentLocImage=s3AgentLocImage, s3AgentFeatureLevel=s3AgentFeatureLevel, s3AgentBootServerAddr=s3AgentBootServerAddr, s3AgentTrapReceiverEntry=s3AgentTrapReceiverEntry, s3AgentFwVer=s3AgentFwVer, s3ChassisBkplRev=s3ChassisBkplRev, s3ChassisEnetChannelAType=s3ChassisEnetChannelAType, s3000FDDI=s3000FDDI, s3AgentHw=s3AgentHw, S3PsType=S3PsType, s3RedPsDiodeStatus=s3RedPsDiodeStatus, s3AgentWriteEeprom=s3AgentWriteEeprom, s3000TerminalServer=s3000TerminalServer, s3AgentImageFile=s3AgentImageFile, s3AgentRestart=s3AgentRestart, s3AgentEpromSize=s3AgentEpromSize, s3AgentIpProtocol=s3AgentIpProtocol, s3CommonBoardPartStatus=s3CommonBoardPartStatus, s3SlotNumber=s3SlotNumber, s3ChassisPsType=s3ChassisPsType, s3SlotConfigOctetString=s3SlotConfigOctetString, s3AgentNetMask=s3AgentNetMask, s3AgentPingDefaultRtrSwitch=s3AgentPingDefaultRtrSwitch, s3AgentSwMajorVer=s3AgentSwMajorVer, s3LocImageMajorVersion=s3LocImageMajorVersion, s3SlotModuleDescr=s3SlotModuleDescr, s3AgentPerformance=s3AgentPerformance, s3LocImageLoadMode=s3LocImageLoadMode, s3ChassisBkPlEthChanDiv=s3ChassisBkPlEthChanDiv, s3AgentTrapRcvrAgeTime=s3AgentTrapRcvrAgeTime, s3CommonBoardIndex=s3CommonBoardIndex, s3RedPsPlus5vCurrent=s3RedPsPlus5vCurrent, s3AgentMySlotId=s3AgentMySlotId, s3AgentHexDisplay=s3AgentHexDisplay, s3AgentBaudRate=s3AgentBaudRate, s3SlotConfigEntry=s3SlotConfigEntry, s3AgentTrapRcvrComm=s3AgentTrapRcvrComm, s3AgentConfigLoadMode=s3AgentConfigLoadMode, s3AgentMibLevel=s3AgentMibLevel, s3AgentUnAuthIp=s3AgentUnAuthIp, s3CommonBoardHwVer=s3CommonBoardHwVer, s3ChassisFanStatus=s3ChassisFanStatus, s3CommonBoardPsStatus=s3CommonBoardPsStatus, s3RedPsPrimaryConfig=s3RedPsPrimaryConfig, s3ChassisPsStatus=s3ChassisPsStatus, s3AgentSecDefaultGateway=s3AgentSecDefaultGateway, s3AgentIpAddr=s3AgentIpAddr, s3CommonBoardTable=s3CommonBoardTable, s3RedPsPlus12vCurrent=s3RedPsPlus12vCurrent, s3AgentBootFile=s3AgentBootFile, s3AgentPingDefaultRtrTime=s3AgentPingDefaultRtrTime, s3AgentStatus=s3AgentStatus, s3AgentTrapRcvrNetAddress=s3AgentTrapRcvrNetAddress, s3ChassisType=s3ChassisType, s3AgentNetProtocol=s3AgentNetProtocol, s3000Ethernet=s3000Ethernet, s3SlotModuleLed=s3SlotModuleLed, s3000Chassis=s3000Chassis, s3000Trb=s3000Trb, s3AgentSw=s3AgentSw, s3AgentBootProtocol=s3AgentBootProtocol, s3LocImageMinorVersion=s3LocImageMinorVersion, s3RedPsAmbientTemperature=s3RedPsAmbientTemperature, s3CommonBoardId=s3CommonBoardId, s3AgentInitString=s3AgentInitString, s3AgentMgmtProtoMode=s3AgentMgmtProtoMode, s3AgentActualMgmtProtocol=s3AgentActualMgmtProtocol, s3AgentAuthTrap=s3AgentAuthTrap, s3CommonBoardReset=s3CommonBoardReset, s3LocImageValid=s3LocImageValid, s3AgentEepromSize=s3AgentEepromSize, s3AgentSwLicenseCode=s3AgentSwLicenseCode, s3SlotModuleType=s3SlotModuleType, s3ChassisBkplType=s3ChassisBkplType, s3RedPsAmbientTempStatus=s3RedPsAmbientTempStatus, s3AgentBootMode=s3AgentBootMode, s3SlotModuleId=s3SlotModuleId, s3AgentMdaHwVer=s3AgentMdaHwVer, s3AgentUnAuthComm=s3AgentUnAuthComm, s3AgentConfigActualSource=s3AgentConfigActualSource, s3000Bridge=s3000Bridge)

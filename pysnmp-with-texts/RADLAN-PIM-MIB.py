#
# PySNMP MIB module RADLAN-PIM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-PIM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:47:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
IANAipRouteProtocol, = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddressPrefixLength, InetVersion, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetVersion", "InetAddressType", "InetAddress")
pimNeighborAddressType, pimNeighborIfIndex, pimInterfaceIPVersion, pimInterfaceEntry, pimNeighborAddress, pimInterfaceIfIndex = mibBuilder.importSymbols("PIM-STD-MIB", "pimNeighborAddressType", "pimNeighborIfIndex", "pimInterfaceIPVersion", "pimInterfaceEntry", "pimNeighborAddress", "pimInterfaceIfIndex")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Integer32, Unsigned32, Gauge32, ObjectIdentity, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, TimeTicks, Counter32, Counter64, NotificationType, iso, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Unsigned32", "Gauge32", "ObjectIdentity", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "TimeTicks", "Counter32", "Counter64", "NotificationType", "iso", "IpAddress")
TextualConvention, RowStatus, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "DisplayString")
rlPim = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 211))
rlPim.setRevisions(('2008-09-25 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlPim.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rlPim.setLastUpdated('200809250000Z')
if mibBuilder.loadTexts: rlPim.setOrganization('Marvell Semiconductor, Inc.')
if mibBuilder.loadTexts: rlPim.setContactInfo('www.marvell.com')
if mibBuilder.loadTexts: rlPim.setDescription('The private MIB module definition for PIM MIB.')
class AdminStatus(TextualConvention, Integer32):
    description = 'The desired administrative state of a MIB row.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("adminStatusUp", 1), ("adminStatusDown", 2))

class OperStatus(TextualConvention, Integer32):
    description = 'The current operational state of a MIB row. This set of values is used by many Data Connection products written before 2006.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("operStatusUp", 1), ("operStatusDown", 2), ("operStatusGoingUp", 3), ("operStatusGoingDown", 4), ("operStatusActFailed", 5))

class Unsigned32NonZero(TextualConvention, Unsigned32):
    description = 'A non-zero Unsigned32.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class NumericIndex(TextualConvention, Integer32):
    description = 'A numeric index value or identifier.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class NumericIndexOrZero(TextualConvention, Integer32):
    description = 'Either a numeric index value or identifier, or the value zero with a special meaning defined by the object description. Do not use this TC for MIB table index objects. Zero is not valid for such objects.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class EntityIndex(TextualConvention, Integer32):
    description = 'The HAF entity index value identifying a DC software entity. This TC is deprecated. Use NumericIndex for all indexes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class EntityIndexOrZero(TextualConvention, Integer32):
    description = 'The HAF entity index value identifying a DC software entity, or zero which is used to indicate that the entity is not present. This TC is deprecated. Use NumericIndexOrZero for all references to indexes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class StdAccessListListIndexOrZero(TextualConvention, Integer32):
    description = 'An arbitrary index value identifying a standard access list or zero for no access list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class StdAccessListRuleIndex(TextualConvention, Integer32):
    description = 'An index value identifying a particular rule within a standard access list. Rules are tested in order of increasing rule index.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class ExtAccessListListIndex(TextualConvention, Integer32):
    description = 'An arbitrary index value identifying an extended access list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class ExtAccessListListIndexOrZero(TextualConvention, Integer32):
    description = 'An arbitrary index value identifying an extended access list or zero for no access list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class PimStatsCounter(TextualConvention, Unsigned32):
    description = "The count of the number of events of a particular type that have occurred since the last time either the NMI join was established (caused by activating DC-PIM TIB Manager or DC-PIM Neighbor Manager, or by recovery after NMI join failure/fail-over), or the statistics were explicitly reset by setting the pimNmEntClearStatsCounters object to 'true'. This value can wrap."
    status = 'current'

class NpgOperStatus(TextualConvention, Integer32):
    description = 'The current operational state of a MIB row. This set of values has been used by the Data Connection Networking Protocols Group since 2006.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 8, 10, 11))
    namedValues = NamedValues(("operStatusUp", 1), ("operStatusDown", 2), ("operStatusGoingUp", 3), ("operStatusGoingDown", 4), ("operStatusActFailed", 5), ("operStatusFailed", 8), ("operStatusFailedPerm", 10), ("operStatusFailing", 11))

rlPimInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 89, 211, 1), )
if mibBuilder.loadTexts: rlPimInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceTable.setDescription('This table is used to create and manage the {interface, IP version} pairs for which PIM is enabled.')
rlPimInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 211, 1, 1), )
pimInterfaceEntry.registerAugmentions(("RADLAN-PIM-MIB", "rlPimInterfaceEntry"))
rlPimInterfaceEntry.setIndexNames(*pimInterfaceEntry.getIndexNames())
if mibBuilder.loadTexts: rlPimInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceEntry.setDescription('An entry (conceptual row) in the pimInterfaceTable.')
rlPimInterfaceAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 3), AdminStatus().clone('adminStatusUp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceAdminStatus.setDescription('The desired administrative state of this interface.')
rlPimInterfaceOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 4), NpgOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimInterfaceOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceOperStatus.setDescription('The current operational state of this interface.')
rlPimInterfaceStubInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceStubInterface.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceStubInterface.setDescription("Whether this interface is a 'stub interface' with regard to PIM. If this is set to 'true', no PIM packets are sent or processed (if received) on this interface. This should be set to 'true' if there are no other PIM routers on the interface but there may be untrusted hosts on the interface, to prevent the router processing forged PIM messages from those hosts. If there are other PIM routers on this interface, this must be left as 'false'. Changing the value of this object while the interface is operational causes the interface to be deactivated and then reactivated.")
rlPimInterfaceP2PNoHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceP2PNoHellos.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceP2PNoHellos.setDescription('Whether this interface is a point-to-point interface on which we do not require the neighbor to send PIM-Hello signals. Provided for back-compatibility with some older implementations that do not send Hellos on point-to-point links. Changing the value of this object while the interface is operational causes the interface to be deactivated and then reactivated.')
rlPimInterfaceMgmdEntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 7), NumericIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceMgmdEntIndex.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceMgmdEntIndex.setDescription('The HAF entity index of the DC-MGMD (for example, for IPv4 this is DC-IGMP) Router component that owns this interface. Zero is a wildcard value meaning that no DC-MGMD Router component currently owns the interface, and the first DC-MGMD Router component that sends Group Membership information for this interface will take ownership of it.')
rlPimInterfaceNeighborCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimInterfaceNeighborCount.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceNeighborCount.setDescription('The number of PIM neighbors on this interface.')
rlPimInterfaceStarGStateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceStarGStateLimit.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceStarGStateLimit.setDescription('The maximum number of groups for which DC-PIM TIB Manager is allowed to store (*,G,I) state specific to this interface. A value of zero means that there is no limit.')
rlPimInterfaceStarGStateWarnThold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceStarGStateWarnThold.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceStarGStateWarnThold.setDescription('DC-PIM TIB Manager logs an exception if the number of groups for which it is storing (*,G,I) state specific to this interface exceeds this value. A value of zero means that there is no warning threshold.')
rlPimInterfaceStarGStateStored = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimInterfaceStarGStateStored.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceStarGStateStored.setDescription('The number of groups for which DC-PIM TIB Manager is storing (*,G,I) state specific to this interface.')
rlPimInterfaceSGStateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 12), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceSGStateLimit.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceSGStateLimit.setDescription('The maximum number of {source, group} pairs for which DC-PIM TIB Manager is allowed to store (S,G,I) state specific to this interface. A value of zero means that there is no limit.')
rlPimInterfaceSGStateWarnThold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 13), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceSGStateWarnThold.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceSGStateWarnThold.setDescription('DC-PIM TIB Manager logs an exception if the number of {source, group} pairs for which it is storing (S,G,I) state specific to this interface exceeds this value. A value of zero means that there is no warning threshold.')
rlPimInterfaceSGStateStored = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimInterfaceSGStateStored.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceSGStateStored.setDescription('The number of {source, group} pairs for which DC-PIM TIB Manager is storing (S,G,I) state specific to this interface.')
rlPimInterfaceNeighborFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 15), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceNeighborFilter.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceNeighborFilter.setDescription("When neighbor filtering is enabled, the local router will process link-local multicast PIM messages received on this interface only if the originator's IP address (that is, the source address in the IP header) is included in the standard access list corresponding to the list name configured for this object. Note that this filter does not apply to unicast PIM messages, even if the originator is directly connected to the local router. So, for example, this filter has no effect on the processing of received Register messages. In other words, the standard access list is a whitelist, and the local router will treat any router excluded from the list as not being a valid PIM neighbor. To filter out all PIM neighbors, either configure this object to be the list name of an 'exclude all' standard access list, or use the rlPimInterfaceStubInterface object.")
rlPimInterfaceAssertInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(177)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceAssertInterval.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceAssertInterval.setDescription("The frequency at which this router sends PIM Assert messages on this interface when it is the assert winner. This object corresponds to the 'Assert_Time' minus the 'Assert_Override_Interval' defined in the PIM-SM specification [I-D.ietf-rlPim-sm-v2-new]. This must be less than rlPimInterfaceAssertHoldtime.")
rlPimInterfaceAssertHoldtime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(180)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceAssertHoldtime.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceAssertHoldtime.setDescription("The interval before this router leaves assert loser state on this interface, unless it receives a PIM Assert message that refreshes this state. This object corresponds to the 'Assert_Time' timer value defined in the PIM-SM specification [I-D.ietf-rlPim-sm-v2-new]. Note that configuring different values for this object for different routers on the same interface might lead to incorrect protocol operation.")
rlPimInterfaceAsmGrpFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 18), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceAsmGrpFilter.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceAsmGrpFilter.setDescription('When ASM group filtering is enabled, then for groups in the ASM space the local router will: - process PIM (*,G) Join and (S,G) Join messages received on this interface only if the group address is included in the standard access list corresponding to the list index value configured for this object - only send PIM (*,G) Join and (S,G) Join messages over this interface if the group address is included in the standard access list corresponding to the list index value configured for this object. Local membership requests from the MGMD Router component are not filtered. These should be filtered by the MGMD Router component. In other words, the standard access list is a whitelist of the ASM groups for which DC-PIM is permitted to request or receive traffic over the interface. rlPimInterfaceAsmGrpFilter defaults to an empty string, which indicates that no access list is specified. If the name does not correspond to a valid access list, no group addresses will match the list and therefore all PIM (*,G) Join and PIM (S,G) Join messages will be filtered.')
rlPimInterfaceSsmSrcAndGrpFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 1, 1, 19), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimInterfaceSsmSrcAndGrpFilter.setStatus('current')
if mibBuilder.loadTexts: rlPimInterfaceSsmSrcAndGrpFilter.setDescription('When SSM source and group filtering is enabled, then for groups in the SSM space the local router will - process PIM (S,G) Join messages received on this interface only if the {source, group} pair is included in the extended access list corresponding to the list index value configured for this object - only send PIM (S,G) Join messages over this interface if the {source, group} pair is included in the extended access list corresponding to the list index value configured for this object. In other words, the extended access list is a whitelist of the SSM {source, group} pairs for which DC-PIM is permitted to request or receive traffic over the interface. rlPimInterfaceSsmSrcAndGrpFilter defaults to an empty string, which indicates that no access list is specified. If the name does not correspond to a valid access list, no {source, group} pairs will match the list and therefore all PIM (S,G) Join messages will be filtered.')
rlPimIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 211, 2), )
if mibBuilder.loadTexts: rlPimIfStatsTable.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsTable.setDescription('This table lists the statistics for {interface, IP version} pairs for which PIM is enabled. Note that any messages filtered out by rlPimInterfaceNeighborFilter do not contribute to any statistics in this table except for rlPimIfStatsNumFilteredOut.')
rlPimIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 211, 2, 1), ).setIndexNames((0, "PIM-STD-MIB", "pimInterfaceIfIndex"), (0, "PIM-STD-MIB", "pimInterfaceIPVersion"))
if mibBuilder.loadTexts: rlPimIfStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsEntry.setDescription('An entry (conceptual row) in the rlPimIfStatsTable.')
rlPimIfStatsNumSentHello = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 1), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumSentHello.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumSentHello.setDescription('The number of PIM Hello messages that have been sent out this interface.')
rlPimIfStatsNumSentJoinPrune = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 2), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumSentJoinPrune.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumSentJoinPrune.setDescription('The number of PIM Join/Prune messages that have been sent out this interface.')
rlPimIfStatsNumSentAssert = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 3), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumSentAssert.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumSentAssert.setDescription('The number of PIM Assert messages that have been sent out this interface.')
rlPimIfStatsNumSentBsm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 4), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumSentBsm.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumSentBsm.setDescription('The number of PIM Bootstrap Router messages that have been sent out this interface. DC-PIM always multicasts this type of message.')
rlPimIfStatsNumErrHello = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 5), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumErrHello.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumErrHello.setDescription('The number of PIM Hello messages that have been received on this interface that have contained errors.')
rlPimIfStatsNumRecvUnknownNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 6), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumRecvUnknownNbr.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumRecvUnknownNbr.setDescription("The number of PIM Join/Prune, Assert and multicast Bootstrap Router messages that have been received on this interface from a neighbor from which we had not previously received a valid PIM Hello message (and for which rlPimInterfaceP2PNoHellos was 'false'). Bootstrap Router messages which are sent to a unicast address are not included in this count.")
rlPimIfStatsNumUnknownHelloOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 7), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumUnknownHelloOpt.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumUnknownHelloOpt.setDescription('The number of unknown options that have been received in PIM Hello messages on this interface.')
rlPimIfStatsNumFilteredOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 2, 1, 8), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimIfStatsNumFilteredOut.setStatus('current')
if mibBuilder.loadTexts: rlPimIfStatsNumFilteredOut.setDescription('The number of link-local multicast PIM messages filtered out by rlPimInterfaceNeighborFilter on this interface.')
rlPimNmEntTable = MibTable((1, 3, 6, 1, 4, 1, 89, 211, 3), )
if mibBuilder.loadTexts: rlPimNmEntTable.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntTable.setDescription('This table is used to create and manage DC-PIM Neighbor Manager entities.')
rlPimNmEntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 211, 3, 1), ).setIndexNames((0, "RADLAN-PIM-MIB", "rlPimNmEntIndex"))
if mibBuilder.loadTexts: rlPimNmEntEntry.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntEntry.setDescription('Each entry represents an instance of the DC-PIM Neighbor Manager entity.')
rlPimNmEntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 1), NumericIndex())
if mibBuilder.loadTexts: rlPimNmEntIndex.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntIndex.setDescription('The index of this rlPimNmEntEntry. This is the HAF entity index passed on the entity create parameters.')
rlPimNmEntRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntRowStatus.setDescription('Used to create and delete a DC-PIM Neighbor Manager Entity Table entry.')
rlPimNmEntAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 3), AdminStatus().clone('adminStatusUp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntAdminStatus.setDescription('The desired administrative state of the DC-PIM Neighbor Manager entity.')
rlPimNmEntOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 4), NpgOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntOperStatus.setDescription('The current operational state of the DC-PIM Neighbor Manager entity.')
rlPimNmEntTmEntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 5), NumericIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntTmEntIndex.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntTmEntIndex.setDescription('The HAF entity index value of the DC-PIM TIB Manager to join to. Once set, the value of this object cannot be changed.')
rlPimNmEntI3JoinOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 6), NpgOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntI3JoinOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntI3JoinOperStatus.setDescription("The current operational state of the I3 join. rlPimNmEntOperStatus cannot transition to 'operStatusUp' unless this object has a value of 'operStatusUp', and cannot transition to 'operStatusDown' unless this object has a value of 'operStatusDown'.")
rlPimNmEntNmiJoinOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 7), NpgOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntNmiJoinOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntNmiJoinOperStatus.setDescription("The current operational state of the NMI join. rlPimNmEntOperStatus cannot transition to 'operStatusUp' unless this object has a value of 'operStatusUp', and cannot transition to 'operStatusDown' unless this object has a value of 'operStatusDown'.")
rlPimNmEntSckJoinOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 8), NpgOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntSckJoinOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntSckJoinOperStatus.setDescription("The current operational state of the SCK join. rlPimNmEntOperStatus cannot transition to 'operStatusUp' unless this object has a value of 'operStatusUp', and cannot transition to 'operStatusDown' unless this object has a value of 'operStatusDown'.")
rlPimNmEntClearStatsCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntClearStatsCounters.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntClearStatsCounters.setDescription("Set this object to 'true' to cause DC-PIM Neighbor Manager to reset all its statistics counters (that is, all objects with syntax PimStatsCounter that are either in the rlPimNmEntStatsTable, or in a row of the rlPimIfStatsTable or rlPimNbrStatsTable for an interface for which rlPimInterfaceNmEntIndex equals rlPimNmEntIndex). Reading the value of this object has no meaning.")
rlPimNmEntStatsUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsUpTime.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsUpTime.setDescription("The time since the statistics counters were last reset, either by establishing the NMI join (caused by activating DC-PIM TIB Manager or DC-PIM Neighbor Manager, or by recovery after NMI join failure/fail-over) or by setting the rlPimNmEntClearStatsCounters object to 'true'.")
rlPimNmEntEnableUnicastMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 11), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntEnableUnicastMessages.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntEnableUnicastMessages.setDescription("Set this object to 'true' to enable DC-PIM Neighbor Manager to send and receive unicast PIM messages. This object must only be set to 'false' if the local router will never be an RP for any multicast group, and will never be the DR for any connected source that sends data to any ASM group. Note that this will always be the case if the local router will perform only the SSM subset of PIM-SM.")
rlPimNmEntAcceptUnicastBsms = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntAcceptUnicastBsms.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntAcceptUnicastBsms.setDescription("Set this object to 'true' to enable DC-PIM Neighbor Manager to accept PIM Bootstrap Messages (BSMs) which are sent to DC-PIM as unicast messages. Setting the object to 'false' means that DC-PIM Neighbor Manager ignores received unicast BSMs. The setting of this object has no effect on the ability of DC-PIM to accept BSMs which are multicast. DC-PIM only ever multicasts BSMs; it never sends them as unicast messages. This object can only be set to 'true' if the rlPimNmEntEnableUnicastMessages object is also set to 'true'.")
rlPimNmEntCrpAdvFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 3, 1, 13), StdAccessListListIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimNmEntCrpAdvFilterIndex.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntCrpAdvFilterIndex.setDescription('Set this object to zero to disable Candidate-RP Advertisement filtering. This means that the local router will process a Candidate-RP Advertisement message from any source IP address. Set this object to a non-zero value to enable Candidate-RP Advertisement filtering. The value gives the standard access list index used to filter received Candidate-RP Advertisement messages. The local router will process a received Candidate-RP Advertisement message only if its source IP address is included in the specified standard access list. In other words, the standard access list is a whitelist of the unicast sources from which DC-PIM is permitted to accept Candidate-RP advertisements.')
rlPimNmEntStatsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 211, 4), )
if mibBuilder.loadTexts: rlPimNmEntStatsTable.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsTable.setDescription('This table lists the statistics for DC-PIM Neighbor Manager entities. Note that any messages filtered out by rlPimInterfaceNeighborFilter do not contribute to any statistics in this table. Note that in the case of critical parsing errors, only the first error encountered will be counted. The checks are made in the following order. - Length. - Checksum. - Message type. - Version.')
rlPimNmEntStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 211, 4, 1), ).setIndexNames((0, "RADLAN-PIM-MIB", "rlPimNmEntIndex"))
if mibBuilder.loadTexts: rlPimNmEntStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsEntry.setDescription('Each entry represents the statistics for a DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumSentCRPAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 1), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumSentCRPAdvert.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumSentCRPAdvert.setDescription('The number of PIM Candidate-RP-Advertisement messages that have been sent by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumSentRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 2), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumSentRegister.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumSentRegister.setDescription('The number of PIM Register messages that have been sent by this DC-PIM Neighbor Manager entity. Note that this only includes PIM Register messages forwarded to other members of Anycast-RP sets, and Null-Register messages. It does not include Register-encapsulated data packets sent from the DR to the RP; these are sent by the data plane.')
rlPimNmEntStatsNumSentRegisterStop = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 3), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumSentRegisterStop.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumSentRegisterStop.setDescription('The number of PIM Register-Stop messages that have been sent by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvCRPAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 4), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvCRPAdvert.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvCRPAdvert.setDescription('The number of valid PIM Candidate-RP-Advertisement messages that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 5), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvRegister.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvRegister.setDescription('The number of valid PIM Register messages that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvRegisterStop = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 6), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvRegisterStop.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvRegisterStop.setDescription('The number of valid PIM Register-Stop messages that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumErrCRPAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 7), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumErrCRPAdvert.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumErrCRPAdvert.setDescription('The number of PIM Candidate-RP-Advertisement messages that have been received by this DC-PIM Neighbor Manager entity that have contained errors.')
rlPimNmEntStatsNumErrRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 8), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumErrRegister.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumErrRegister.setDescription('The number of PIM Register messages that have been received by this DC-PIM Neighbor Manager entity that have contained errors.')
rlPimNmEntStatsNumErrRegisterStop = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 9), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumErrRegisterStop.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumErrRegisterStop.setDescription('The number of PIM Register-Stop messages that have been received by this DC-PIM Neighbor Manager entity that have contained errors.')
rlPimNmEntStatsNumRecvIgnoredType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 10), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvIgnoredType.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvIgnoredType.setDescription('The number of PIM messages with a known but unsupported PIM message type that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvUnknownType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 11), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvUnknownType.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvUnknownType.setDescription('The number of PIM messages with an unknown PIM message type that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvUnknownVer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 12), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvUnknownVer.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvUnknownVer.setDescription('The number of PIM messages with an unknown PIM version that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvBadChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 13), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvBadChecksum.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvBadChecksum.setDescription('The number of PIM messages with a incorrect PIM checksum that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumRecvBadLength = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 14), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvBadLength.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumRecvBadLength.setDescription('The number of PIM messages with a length too short to contain a common PIM header that have been received by this DC-PIM Neighbor Manager entity.')
rlPimNmEntStatsNumCRPAdvfiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 4, 1, 15), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNmEntStatsNumCRPAdvfiltered.setStatus('current')
if mibBuilder.loadTexts: rlPimNmEntStatsNumCRPAdvfiltered.setDescription('The number of C-RP-Advertisement messages which have been filtered out by this DC-PIM Neighbor Manager entity.')
rlPimNbrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 211, 5), )
if mibBuilder.loadTexts: rlPimNbrStatsTable.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsTable.setDescription("This table lists the statistics for PIM neighbors. Note that if a neighbor's Liveness Timer expires (including on receipt of a PIM Hello message with a zero Holdtime), this event resets all of the statistics in this table. However, if a neighbor's Generation ID value changes, none of the statistics in this table are affected.")
rlPimNbrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 211, 5, 1), ).setIndexNames((0, "PIM-STD-MIB", "pimNeighborIfIndex"), (0, "PIM-STD-MIB", "pimNeighborAddressType"), (0, "PIM-STD-MIB", "pimNeighborAddress"))
if mibBuilder.loadTexts: rlPimNbrStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsEntry.setDescription('An entry (conceptual row) in the rlPimNbrStatsTable.')
rlPimNbrStatsNumRecvHello = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 1), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvHello.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvHello.setDescription('The number of valid PIM Hello messages that have been received from this neighbor.')
rlPimNbrStatsNumRecvJoinPrune = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 2), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvJoinPrune.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvJoinPrune.setDescription('The number of valid PIM Join/Prune messages that have been received from this neighbor.')
rlPimNbrStatsNumRecvAssert = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 3), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvAssert.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvAssert.setDescription('The number of valid PIM Assert messages that have been received from this neighbor.')
rlPimNbrStatsNumRecvBSM = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 4), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvBSM.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumRecvBSM.setDescription('The number of valid PIM Bootstrap messages that have been received from this neighbor.')
rlPimNbrStatsNumErrJoinPrune = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 5), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumErrJoinPrune.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumErrJoinPrune.setDescription('The number of PIM Join/Prune messages that have been received from this neighbor that have contained errors. Note that this does not include messages for which the RP in the message differs from the RP known by the local router, nor does it include (*,G) messages received for SSM groups.')
rlPimNbrStatsNumErrAssert = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 6), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumErrAssert.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumErrAssert.setDescription('The number of PIM Assert messages that have been received from this neighbor that have contained errors.')
rlPimNbrStatsNumErrBSM = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 5, 1, 7), PimStatsCounter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimNbrStatsNumErrBSM.setStatus('current')
if mibBuilder.loadTexts: rlPimNbrStatsNumErrBSM.setDescription('The number of PIM Bootstrap messages that have been received from this neighbor that have contained errors.')
rlPimTmEntTable = MibTable((1, 3, 6, 1, 4, 1, 89, 211, 6), )
if mibBuilder.loadTexts: rlPimTmEntTable.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntTable.setDescription('This table is used to create and manage DC-PIM TIB Manager entities.')
rlPimTmEntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 211, 6, 1), ).setIndexNames((0, "RADLAN-PIM-MIB", "rlPimTmEntIndex"))
if mibBuilder.loadTexts: rlPimTmEntEntry.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntEntry.setDescription('Each entry represents an instance of the DC-PIM TIB Manager entity.')
rlPimTmEntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 1), NumericIndex())
if mibBuilder.loadTexts: rlPimTmEntIndex.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntIndex.setDescription('The index of this rlPimTmEntEntry. This is the HAF entity index passed on the entity create parameters.')
rlPimTmEntRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntRowStatus.setDescription('Used to create and delete a DC-PIM TIB Manager Entity Table entry.')
rlPimTmEntAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 3), AdminStatus().clone('adminStatusUp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntAdminStatus.setDescription('The desired administrative state of the DC-PIM TIB Manager entity.')
rlPimTmEntOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 4), NpgOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimTmEntOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntOperStatus.setDescription('The current operational state of the DC-PIM TIB Manager entity.')
rlPimTmEntGStateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntGStateLimit.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntGStateLimit.setDescription('The maximum number of groups for which DC-PIM TIB Manager is allowed to store non-interface specific (*,G) and/or (S,G) state. A value of zero means that there is no limit.')
rlPimTmEntGStateWarnThold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntGStateWarnThold.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntGStateWarnThold.setDescription('DC-PIM TIB Manager logs an exception if the number of groups for which it is storing non-interface specific (*,G) and/or (S,G) state exceeds this value. A value of zero means that there is no warning threshold.')
rlPimTmEntGStateStored = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimTmEntGStateStored.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntGStateStored.setDescription('The number of groups for which DC-PIM TIB Manager is storing non-interface specific (*,G) and/or (S,G) state.')
rlPimTmEntSGStateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSGStateLimit.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSGStateLimit.setDescription('The maximum number of {source, group} pairs for which DC-PIM TIB Manager is allowed to store non-interface specific (S,G) state. A value of zero means that there is no limit.')
rlPimTmEntSGStateWarnThold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSGStateWarnThold.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSGStateWarnThold.setDescription('DC-PIM TIB Manager logs an exception if the number of {source, group} pairs for which it is storing non-interface specific (S,G) state exceeds this value. A value of zero means that there is no warning threshold.')
rlPimTmEntSGStateStored = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimTmEntSGStateStored.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSGStateStored.setDescription('The number of {source, group} pairs for which DC-PIM TIB Manager is storing non-interface specific (S,G) state.')
rlPimTmEntStarGIStateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntStarGIStateLimit.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntStarGIStateLimit.setDescription('The maximum number of {group, interface} pairs for which DC-PIM TIB Manager is allowed to store (*,G,I) state. A value of zero means that there is no limit.')
rlPimTmEntStarGIStateWarnThold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 12), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntStarGIStateWarnThold.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntStarGIStateWarnThold.setDescription('DC-PIM TIB Manager logs an exception if the number of {group, interface} pairs for which it is storing (*,G,I) state exceeds this value. A value of zero means that there is no warning threshold.')
rlPimTmEntStarGIStateStored = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimTmEntStarGIStateStored.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntStarGIStateStored.setDescription('The number of {group, interface} pairs for which DC-PIM TIB Manager is storing (*,G,I) state.')
rlPimTmEntSGIStateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 14), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSGIStateLimit.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSGIStateLimit.setDescription('The maximum number of {source, group, interface} triplets for which DC-PIM TIB Manager is allowed to store (S,G,I) state. A value of zero means that there is no limit.')
rlPimTmEntSGIStateWarnThold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 15), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSGIStateWarnThold.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSGIStateWarnThold.setDescription('DC-PIM TIB Manager logs an exception if the number of {source, group, interface} triplets for which it is storing (S,G,I) state exceeds this value. A value of zero means that there is no warning threshold.')
rlPimTmEntSGIStateStored = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPimTmEntSGIStateStored.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSGIStateStored.setDescription('The number of {source, group, interface} triplets for which DC-PIM TIB Manager is storing (S,G,I) state.')
rlPimTmEntAsmGrpFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 17), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntAsmGrpFilter.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntAsmGrpFilter.setDescription('When ASM group filtering is enabled, then for groups in the ASM space, the local router will: - process received PIM (*,G) Join and (S,G) Join messages only if the group address is included in the standard access list corresponding to the list index value configured for this object, and - accept (*,G) and (S,G) local membership requests from the MGMD Router component only if the group address is included in the standard access list corresponding to the list index value configured for this object. In other words, the standard access list is a whitelist of the ASM groups for which DC-PIM is permitted to request traffic. Note that DC-PIM will never Register-encapsulate multicast data packets for groups that are blocked by this filter. See rlPimTmEntRegSrcAndGrpFilter for additional Register message filtering options. rlPimTmEntAsmGrpFilter defaults to an empty string, which indicates that no access list is specified.')
rlPimTmEntSsmSrcAndGrpFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 18), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSsmSrcAndGrpFilter.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSsmSrcAndGrpFilter.setDescription('When SSM source and group filtering is enabled, then for groups in the SSM space, the local router will: - process received PIM (S,G) Join messages only if the {source, group} pair is included in the extended access list corresponding to the list index value configured for this object, and - accept (S,G) local membership requests from the MGMD Router component only if the {source, group} pair is included in the extended access list corresponding to the list index value configured for this object. In other words, the extended access list is a whitelist of the SSM {source, group} pairs for which DC-PIM is permitted to request traffic. rlPimTmEntSsmSrcAndGrpFilter defaults to an empty string, which indicates that no access list is specified.')
rlPimTmEntRegSrcAndGrpFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 19), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntRegSrcAndGrpFilter.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntRegSrcAndGrpFilter.setDescription('When Register message filtering by source and group address is enabled then: - for groups for which the local router is the RP, it will process received PIM Register messages as normal only if the {source, group} pair of the encapsulated multicast data packet is included in the extended access list corresponding to the list index value configured for this object; if the {source, group} pair is excluded from the extended access list, the local router will send a Register-Stop message, and - on interfaces on which the local router is the DR, it will encapsulate received multicast data packets and forward them in PIM Register messages only if the {source, group} pair of the multicast data packet is included in the extended access list corresponding to the list index value configured for this object. In other words, the extended access list is a whitelist of the {source, group} pairs for which the local router is permitted to Register-encapsulate/decapsulate multicast data packets. rlPimTmEntRegSrcAndGrpFilter defaults to an empty string, which indicates that no access list is specified.')
rlPimTmEntRegSuppressionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntRegSuppressionTime.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntRegSuppressionTime.setDescription("The mean value of the randomized interval during which a DR stops Register-encapsulation after receiving a PIM Register-Stop message. This object corresponds to the 'Register_Suppression_Time' defined in the PIM-SM specification [I-D.ietf-dcPim-sm-v2-new]. Note that configuring different values for this object for different routers in the PIM domain might lead to incorrect protocol operation.")
rlPimTmEntRegProbeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntRegProbeTime.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntRegProbeTime.setDescription("The time to wait for a PIM Register-Stop message after sending a PIM Null-Register message, before resuming Register-encapsulation at a DR. This object corresponds to the 'Register_Probe_Time' defined in the PIM-SM specification [I-D.ietf-dcPim-sm-v2-new].")
rlPimTmEntKeepalivePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(210)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntKeepalivePeriod.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntKeepalivePeriod.setDescription("The time keep (S,G) state alive in the absence of PIM (S,G) Join messages, (S,G) local membership or (S,G) data packets. This object corresponds to the 'Keepalive_Period' defined in the PIM-SM specification [I-D.ietf-dcPim-sm-v2-new]. Note that this value must also be configured in the MPF stub, as the duration of its Data Flow Liveness timer. Note that configuring different values for this object for different routers in the PIM domain might lead to incorrect protocol operation.")
rlPimTmEntSendIfStateChangeTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 23), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSendIfStateChangeTraps.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSendIfStateChangeTraps.setDescription("Setting this object to 'true' means that DC-PIM TIB Manager will send a rlPimInterfaceStateChange trap when an interface's operational state changes.")
rlPimTmEntSupportedAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 211, 6, 1, 24), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlPimTmEntSupportedAddrType.setStatus('current')
if mibBuilder.loadTexts: rlPimTmEntSupportedAddrType.setDescription('This field indicates the address family type that this entity supports. On routers which support multiple address families, separate DC-PIM-TM and DC-PIM-NM entities must be configured for each family. This configuration can only be updated when the row status of the TM entity is NotInService or the admin status is Down.')
rlPimEmbeddedRpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 89, 211, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPimEmbeddedRpEnabled.setStatus('current')
if mibBuilder.loadTexts: rlPimEmbeddedRpEnabled.setDescription('The enabled status of Embedded-RP function for PIM-SM on this system.')
mibBuilder.exportSymbols("RADLAN-PIM-MIB", rlPimNmEntStatsNumRecvUnknownType=rlPimNmEntStatsNumRecvUnknownType, rlPimTmEntRegSuppressionTime=rlPimTmEntRegSuppressionTime, rlPimNbrStatsNumRecvJoinPrune=rlPimNbrStatsNumRecvJoinPrune, StdAccessListListIndexOrZero=StdAccessListListIndexOrZero, rlPimTmEntIndex=rlPimTmEntIndex, PYSNMP_MODULE_ID=rlPim, rlPimNbrStatsNumErrJoinPrune=rlPimNbrStatsNumErrJoinPrune, rlPimNbrStatsNumErrAssert=rlPimNbrStatsNumErrAssert, StdAccessListRuleIndex=StdAccessListRuleIndex, rlPimNmEntStatsNumCRPAdvfiltered=rlPimNmEntStatsNumCRPAdvfiltered, rlPimTmEntStarGIStateStored=rlPimTmEntStarGIStateStored, rlPimTmEntSGIStateStored=rlPimTmEntSGIStateStored, rlPimTmEntSGStateLimit=rlPimTmEntSGStateLimit, rlPimNmEntNmiJoinOperStatus=rlPimNmEntNmiJoinOperStatus, rlPimTmEntSGIStateWarnThold=rlPimTmEntSGIStateWarnThold, rlPimTmEntKeepalivePeriod=rlPimTmEntKeepalivePeriod, rlPimInterfaceEntry=rlPimInterfaceEntry, rlPimNmEntOperStatus=rlPimNmEntOperStatus, rlPimTmEntSGIStateLimit=rlPimTmEntSGIStateLimit, Unsigned32NonZero=Unsigned32NonZero, rlPimInterfaceTable=rlPimInterfaceTable, rlPimIfStatsNumUnknownHelloOpt=rlPimIfStatsNumUnknownHelloOpt, rlPimInterfaceSGStateWarnThold=rlPimInterfaceSGStateWarnThold, rlPimTmEntRowStatus=rlPimTmEntRowStatus, rlPimIfStatsTable=rlPimIfStatsTable, rlPimIfStatsNumSentHello=rlPimIfStatsNumSentHello, rlPimNmEntStatsNumRecvUnknownVer=rlPimNmEntStatsNumRecvUnknownVer, rlPimIfStatsNumSentBsm=rlPimIfStatsNumSentBsm, rlPimTmEntGStateLimit=rlPimTmEntGStateLimit, OperStatus=OperStatus, NpgOperStatus=NpgOperStatus, rlPimNmEntTmEntIndex=rlPimNmEntTmEntIndex, rlPimNbrStatsTable=rlPimNbrStatsTable, rlPimNbrStatsNumRecvAssert=rlPimNbrStatsNumRecvAssert, rlPimInterfaceStarGStateWarnThold=rlPimInterfaceStarGStateWarnThold, rlPimNmEntStatsTable=rlPimNmEntStatsTable, rlPimNbrStatsNumRecvHello=rlPimNbrStatsNumRecvHello, rlPimTmEntSGStateStored=rlPimTmEntSGStateStored, rlPimInterfaceStubInterface=rlPimInterfaceStubInterface, rlPimInterfaceOperStatus=rlPimInterfaceOperStatus, rlPimNmEntStatsNumErrCRPAdvert=rlPimNmEntStatsNumErrCRPAdvert, rlPimTmEntSGStateWarnThold=rlPimTmEntSGStateWarnThold, rlPimIfStatsNumSentJoinPrune=rlPimIfStatsNumSentJoinPrune, rlPimNmEntStatsNumErrRegister=rlPimNmEntStatsNumErrRegister, rlPimNmEntTable=rlPimNmEntTable, rlPimIfStatsNumRecvUnknownNbr=rlPimIfStatsNumRecvUnknownNbr, rlPimNmEntSckJoinOperStatus=rlPimNmEntSckJoinOperStatus, rlPimNmEntClearStatsCounters=rlPimNmEntClearStatsCounters, rlPimNmEntStatsNumRecvIgnoredType=rlPimNmEntStatsNumRecvIgnoredType, rlPimNbrStatsNumRecvBSM=rlPimNbrStatsNumRecvBSM, EntityIndexOrZero=EntityIndexOrZero, rlPimTmEntRegProbeTime=rlPimTmEntRegProbeTime, rlPimTmEntStarGIStateWarnThold=rlPimTmEntStarGIStateWarnThold, rlPimInterfaceStarGStateStored=rlPimInterfaceStarGStateStored, rlPimInterfaceMgmdEntIndex=rlPimInterfaceMgmdEntIndex, rlPimEmbeddedRpEnabled=rlPimEmbeddedRpEnabled, rlPimTmEntGStateStored=rlPimTmEntGStateStored, rlPimTmEntRegSrcAndGrpFilter=rlPimTmEntRegSrcAndGrpFilter, rlPimInterfaceNeighborFilter=rlPimInterfaceNeighborFilter, NumericIndexOrZero=NumericIndexOrZero, rlPimNmEntStatsUpTime=rlPimNmEntStatsUpTime, rlPimInterfaceAssertInterval=rlPimInterfaceAssertInterval, rlPimNmEntIndex=rlPimNmEntIndex, rlPimTmEntOperStatus=rlPimTmEntOperStatus, rlPimIfStatsNumErrHello=rlPimIfStatsNumErrHello, rlPimNmEntStatsNumSentRegisterStop=rlPimNmEntStatsNumSentRegisterStop, rlPimInterfaceP2PNoHellos=rlPimInterfaceP2PNoHellos, rlPim=rlPim, rlPimTmEntSupportedAddrType=rlPimTmEntSupportedAddrType, rlPimTmEntSsmSrcAndGrpFilter=rlPimTmEntSsmSrcAndGrpFilter, rlPimNmEntAcceptUnicastBsms=rlPimNmEntAcceptUnicastBsms, rlPimNmEntStatsNumErrRegisterStop=rlPimNmEntStatsNumErrRegisterStop, rlPimTmEntEntry=rlPimTmEntEntry, rlPimInterfaceSsmSrcAndGrpFilter=rlPimInterfaceSsmSrcAndGrpFilter, rlPimTmEntTable=rlPimTmEntTable, rlPimIfStatsNumSentAssert=rlPimIfStatsNumSentAssert, PimStatsCounter=PimStatsCounter, rlPimNmEntI3JoinOperStatus=rlPimNmEntI3JoinOperStatus, rlPimNmEntEnableUnicastMessages=rlPimNmEntEnableUnicastMessages, rlPimInterfaceSGStateLimit=rlPimInterfaceSGStateLimit, rlPimNmEntStatsNumSentRegister=rlPimNmEntStatsNumSentRegister, rlPimTmEntStarGIStateLimit=rlPimTmEntStarGIStateLimit, rlPimNmEntStatsNumRecvRegister=rlPimNmEntStatsNumRecvRegister, EntityIndex=EntityIndex, rlPimNbrStatsNumErrBSM=rlPimNbrStatsNumErrBSM, rlPimNmEntEntry=rlPimNmEntEntry, rlPimTmEntAdminStatus=rlPimTmEntAdminStatus, rlPimNmEntCrpAdvFilterIndex=rlPimNmEntCrpAdvFilterIndex, rlPimInterfaceAssertHoldtime=rlPimInterfaceAssertHoldtime, rlPimNmEntStatsEntry=rlPimNmEntStatsEntry, rlPimNmEntRowStatus=rlPimNmEntRowStatus, ExtAccessListListIndex=ExtAccessListListIndex, rlPimNmEntStatsNumSentCRPAdvert=rlPimNmEntStatsNumSentCRPAdvert, AdminStatus=AdminStatus, rlPimNmEntAdminStatus=rlPimNmEntAdminStatus, rlPimInterfaceSGStateStored=rlPimInterfaceSGStateStored, rlPimTmEntSendIfStateChangeTraps=rlPimTmEntSendIfStateChangeTraps, rlPimNmEntStatsNumRecvBadChecksum=rlPimNmEntStatsNumRecvBadChecksum, NumericIndex=NumericIndex, rlPimTmEntAsmGrpFilter=rlPimTmEntAsmGrpFilter, rlPimInterfaceAsmGrpFilter=rlPimInterfaceAsmGrpFilter, rlPimInterfaceAdminStatus=rlPimInterfaceAdminStatus, rlPimIfStatsNumFilteredOut=rlPimIfStatsNumFilteredOut, rlPimTmEntGStateWarnThold=rlPimTmEntGStateWarnThold, rlPimNmEntStatsNumRecvBadLength=rlPimNmEntStatsNumRecvBadLength, rlPimNbrStatsEntry=rlPimNbrStatsEntry, rlPimInterfaceStarGStateLimit=rlPimInterfaceStarGStateLimit, rlPimNmEntStatsNumRecvRegisterStop=rlPimNmEntStatsNumRecvRegisterStop, rlPimInterfaceNeighborCount=rlPimInterfaceNeighborCount, rlPimIfStatsEntry=rlPimIfStatsEntry, ExtAccessListListIndexOrZero=ExtAccessListListIndexOrZero, rlPimNmEntStatsNumRecvCRPAdvert=rlPimNmEntStatsNumRecvCRPAdvert)
